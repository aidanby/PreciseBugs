{"buggy_code": ["/**\n *\n * Copyright 2009 Jive Software.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.smack;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;\nimport org.jivesoftware.smack.SmackException.AlreadyConnectedException;\nimport org.jivesoftware.smack.SmackException.AlreadyLoggedInException;\nimport org.jivesoftware.smack.SmackException.NoResponseException;\nimport org.jivesoftware.smack.SmackException.NotConnectedException;\nimport org.jivesoftware.smack.SmackException.ConnectionException;\nimport org.jivesoftware.smack.SmackException.ResourceBindingNotOfferedException;\nimport org.jivesoftware.smack.SmackException.SecurityRequiredException;\nimport org.jivesoftware.smack.XMPPException.XMPPErrorException;\nimport org.jivesoftware.smack.compress.packet.Compress;\nimport org.jivesoftware.smack.compression.XMPPInputOutputStream;\nimport org.jivesoftware.smack.debugger.SmackDebugger;\nimport org.jivesoftware.smack.filter.IQReplyFilter;\nimport org.jivesoftware.smack.filter.StanzaFilter;\nimport org.jivesoftware.smack.filter.StanzaIdFilter;\nimport org.jivesoftware.smack.iqrequest.IQRequestHandler;\nimport org.jivesoftware.smack.packet.Bind;\nimport org.jivesoftware.smack.packet.ErrorIQ;\nimport org.jivesoftware.smack.packet.IQ;\nimport org.jivesoftware.smack.packet.Mechanisms;\nimport org.jivesoftware.smack.packet.Stanza;\nimport org.jivesoftware.smack.packet.ExtensionElement;\nimport org.jivesoftware.smack.packet.Presence;\nimport org.jivesoftware.smack.packet.Session;\nimport org.jivesoftware.smack.packet.StartTls;\nimport org.jivesoftware.smack.packet.PlainStreamElement;\nimport org.jivesoftware.smack.packet.XMPPError;\nimport org.jivesoftware.smack.parsing.ParsingExceptionCallback;\nimport org.jivesoftware.smack.parsing.UnparsablePacket;\nimport org.jivesoftware.smack.provider.ExtensionElementProvider;\nimport org.jivesoftware.smack.provider.ProviderManager;\nimport org.jivesoftware.smack.util.BoundedThreadPoolExecutor;\nimport org.jivesoftware.smack.util.DNSUtil;\nimport org.jivesoftware.smack.util.Objects;\nimport org.jivesoftware.smack.util.PacketParserUtils;\nimport org.jivesoftware.smack.util.ParserUtils;\nimport org.jivesoftware.smack.util.SmackExecutorThreadFactory;\nimport org.jivesoftware.smack.util.StringUtils;\nimport org.jivesoftware.smack.util.dns.HostAddress;\nimport org.jxmpp.util.XmppStringUtils;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\n\npublic abstract class AbstractXMPPConnection implements XMPPConnection {\n    private static final Logger LOGGER = Logger.getLogger(AbstractXMPPConnection.class.getName());\n\n    /** \n     * Counter to uniquely identify connections that are created.\n     */\n    private final static AtomicInteger connectionCounter = new AtomicInteger(0);\n\n    static {\n        // Ensure the SmackConfiguration class is loaded by calling a method in it.\n        SmackConfiguration.getVersion();\n    }\n\n    /**\n     * Get the collection of listeners that are interested in connection creation events.\n     * \n     * @return a collection of listeners interested on new connections.\n     */\n    protected static Collection<ConnectionCreationListener> getConnectionCreationListeners() {\n        return XMPPConnectionRegistry.getConnectionCreationListeners();\n    }\n \n    /**\n     * A collection of ConnectionListeners which listen for connection closing\n     * and reconnection events.\n     */\n    protected final Set<ConnectionListener> connectionListeners =\n            new CopyOnWriteArraySet<ConnectionListener>();\n\n    /**\n     * A collection of PacketCollectors which collects packets for a specified filter\n     * and perform blocking and polling operations on the result queue.\n     * <p>\n     * We use a ConcurrentLinkedQueue here, because its Iterator is weakly\n     * consistent and we want {@link #invokePacketCollectors(Stanza)} for-each\n     * loop to be lock free. As drawback, removing a PacketCollector is O(n).\n     * The alternative would be a synchronized HashSet, but this would mean a\n     * synchronized block around every usage of <code>collectors</code>.\n     * </p>\n     */\n    private final Collection<PacketCollector> collectors = new ConcurrentLinkedQueue<PacketCollector>();\n\n    /**\n     * List of PacketListeners that will be notified synchronously when a new stanza(/packet) was received.\n     */\n    private final Map<StanzaListener, ListenerWrapper> syncRecvListeners = new LinkedHashMap<>();\n\n    /**\n     * List of PacketListeners that will be notified asynchronously when a new stanza(/packet) was received.\n     */\n    private final Map<StanzaListener, ListenerWrapper> asyncRecvListeners = new LinkedHashMap<>();\n\n    /**\n     * List of PacketListeners that will be notified when a new stanza(/packet) was sent.\n     */\n    private final Map<StanzaListener, ListenerWrapper> sendListeners =\n            new HashMap<StanzaListener, ListenerWrapper>();\n\n    /**\n     * List of PacketListeners that will be notified when a new stanza(/packet) is about to be\n     * sent to the server. These interceptors may modify the stanza(/packet) before it is being\n     * actually sent to the server.\n     */\n    private final Map<StanzaListener, InterceptorWrapper> interceptors =\n            new HashMap<StanzaListener, InterceptorWrapper>();\n\n    protected final Lock connectionLock = new ReentrantLock();\n\n    protected final Map<String, ExtensionElement> streamFeatures = new HashMap<String, ExtensionElement>();\n\n    /**\n     * The full JID of the authenticated user, as returned by the resource binding response of the server.\n     * <p>\n     * It is important that we don't infer the user from the login() arguments and the configurations service name, as,\n     * for example, when SASL External is used, the username is not given to login but taken from the 'external'\n     * certificate.\n     * </p>\n     */\n    protected String user;\n\n    protected boolean connected = false;\n\n    /**\n     * The stream ID, see RFC 6120 \u00a7 4.7.3\n     */\n    protected String streamId;\n\n    /**\n     * \n     */\n    private long packetReplyTimeout = SmackConfiguration.getDefaultPacketReplyTimeout();\n\n    /**\n     * The SmackDebugger allows to log and debug XML traffic.\n     */\n    protected SmackDebugger debugger = null;\n\n    /**\n     * The Reader which is used for the debugger.\n     */\n    protected Reader reader;\n\n    /**\n     * The Writer which is used for the debugger.\n     */\n    protected Writer writer;\n\n    /**\n     * Set to success if the last features stanza from the server has been parsed. A XMPP connection\n     * handshake can invoke multiple features stanzas, e.g. when TLS is activated a second feature\n     * stanza is send by the server. This is set to true once the last feature stanza has been\n     * parsed.\n     */\n    protected final SynchronizationPoint<Exception> lastFeaturesReceived = new SynchronizationPoint<Exception>(\n                    AbstractXMPPConnection.this);\n\n    /**\n     * Set to success if the sasl feature has been received.\n     */\n    protected final SynchronizationPoint<SmackException> saslFeatureReceived = new SynchronizationPoint<SmackException>(\n                    AbstractXMPPConnection.this);\n \n    /**\n     * The SASLAuthentication manager that is responsible for authenticating with the server.\n     */\n    protected SASLAuthentication saslAuthentication = new SASLAuthentication(this);\n\n    /**\n     * A number to uniquely identify connections that are created. This is distinct from the\n     * connection ID, which is a value sent by the server once a connection is made.\n     */\n    protected final int connectionCounterValue = connectionCounter.getAndIncrement();\n\n    /**\n     * Holds the initial configuration used while creating the connection.\n     */\n    protected final ConnectionConfiguration config;\n\n    /**\n     * Defines how the from attribute of outgoing stanzas should be handled.\n     */\n    private FromMode fromMode = FromMode.OMITTED;\n\n    protected XMPPInputOutputStream compressionHandler;\n\n    private ParsingExceptionCallback parsingExceptionCallback = SmackConfiguration.getDefaultParsingExceptionCallback();\n\n    /**\n     * ExecutorService used to invoke the PacketListeners on newly arrived and parsed stanzas. It is\n     * important that we use a <b>single threaded ExecutorService</b> in order to guarantee that the\n     * PacketListeners are invoked in the same order the stanzas arrived.\n     */\n    private final BoundedThreadPoolExecutor executorService = new BoundedThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS,\n                    100, new SmackExecutorThreadFactory(connectionCounterValue, \"Incoming Processor\"));\n\n    /**\n     * This scheduled thread pool executor is used to remove pending callbacks.\n     */\n    private final ScheduledExecutorService removeCallbacksService = Executors.newSingleThreadScheduledExecutor(\n                    new SmackExecutorThreadFactory(connectionCounterValue, \"Remove Callbacks\"));\n\n    /**\n     * A cached thread pool executor service with custom thread factory to set meaningful names on the threads and set\n     * them 'daemon'.\n     */\n    private final ExecutorService cachedExecutorService = Executors.newCachedThreadPool(\n                    // @formatter:off\n                    new SmackExecutorThreadFactory(    // threadFactory\n                                    connectionCounterValue,\n                                    \"Cached Executor\"\n                                    )\n                    // @formatter:on\n                    );\n\n    /**\n     * A executor service used to invoke the callbacks of synchronous stanza(/packet) listeners. We use a executor service to\n     * decouple incoming stanza processing from callback invocation. It is important that order of callback invocation\n     * is the same as the order of the incoming stanzas. Therefore we use a <i>single</i> threaded executor service.\n     */\n    private final ExecutorService singleThreadedExecutorService = Executors.newSingleThreadExecutor(new SmackExecutorThreadFactory(\n                    getConnectionCounter(), \"Single Threaded Executor\"));\n\n    /**\n     * The used host to establish the connection to\n     */\n    protected String host;\n\n    /**\n     * The used port to establish the connection to\n     */\n    protected int port;\n\n    /**\n     * Flag that indicates if the user is currently authenticated with the server.\n     */\n    protected boolean authenticated = false;\n\n    /**\n     * Flag that indicates if the user was authenticated with the server when the connection\n     * to the server was closed (abruptly or not).\n     */\n    protected boolean wasAuthenticated = false;\n\n    private final Map<String, IQRequestHandler> setIqRequestHandler = new HashMap<>();\n    private final Map<String, IQRequestHandler> getIqRequestHandler = new HashMap<>();\n\n    /**\n     * Create a new XMPPConnection to an XMPP server.\n     * \n     * @param configuration The configuration which is used to establish the connection.\n     */\n    protected AbstractXMPPConnection(ConnectionConfiguration configuration) {\n        config = configuration;\n    }\n\n    /**\n     * Get the connection configuration used by this connection.\n     *\n     * @return the connection configuration.\n     */\n    public ConnectionConfiguration getConfiguration() {\n        return config;\n    }\n\n    @Override\n    public String getServiceName() {\n        if (serviceName != null) {\n            return serviceName;\n        }\n        return config.getServiceName();\n    }\n\n    @Override\n    public String getHost() {\n        return host;\n    }\n\n    @Override\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public abstract boolean isSecureConnection();\n\n    protected abstract void sendStanzaInternal(Stanza packet) throws NotConnectedException;\n\n    @Override\n    public abstract void send(PlainStreamElement element) throws NotConnectedException;\n\n    @Override\n    public abstract boolean isUsingCompression();\n\n    /**\n     * Establishes a connection to the XMPP server and performs an automatic login\n     * only if the previous connection state was logged (authenticated). It basically\n     * creates and maintains a connection to the server.\n     * <p>\n     * Listeners will be preserved from a previous connection.\n     * \n     * @throws XMPPException if an error occurs on the XMPP protocol level.\n     * @throws SmackException if an error occurs somewhere else besides XMPP protocol level.\n     * @throws IOException \n     * @throws ConnectionException with detailed information about the failed connection.\n     * @return a reference to this object, to chain <code>connect()</code> with <code>login()</code>.\n     */\n    public synchronized AbstractXMPPConnection connect() throws SmackException, IOException, XMPPException {\n        // Check if not already connected\n        throwAlreadyConnectedExceptionIfAppropriate();\n\n        // Reset the connection state\n        saslAuthentication.init();\n        saslFeatureReceived.init();\n        lastFeaturesReceived.init();\n        streamId = null;\n\n        // Perform the actual connection to the XMPP service\n        connectInternal();\n        return this;\n    }\n\n    /**\n     * Abstract method that concrete subclasses of XMPPConnection need to implement to perform their\n     * way of XMPP connection establishment. Implementations are required to perform an automatic\n     * login if the previous connection state was logged (authenticated).\n     * \n     * @throws SmackException\n     * @throws IOException\n     * @throws XMPPException\n     */\n    protected abstract void connectInternal() throws SmackException, IOException, XMPPException;\n\n    private String usedUsername, usedPassword, usedResource;\n\n    /**\n     * Logs in to the server using the strongest SASL mechanism supported by\n     * the server. If more than the connection's default stanza(/packet) timeout elapses in each step of the \n     * authentication process without a response from the server, a\n     * {@link SmackException.NoResponseException} will be thrown.\n     * <p>\n     * Before logging in (i.e. authenticate) to the server the connection must be connected\n     * by calling {@link #connect}.\n     * </p>\n     * <p>\n     * It is possible to log in without sending an initial available presence by using\n     * {@link ConnectionConfiguration.Builder#setSendPresence(boolean)}.\n     * Finally, if you want to not pass a password and instead use a more advanced mechanism\n     * while using SASL then you may be interested in using\n     * {@link ConnectionConfiguration.Builder#setCallbackHandler(javax.security.auth.callback.CallbackHandler)}.\n     * For more advanced login settings see {@link ConnectionConfiguration}.\n     * </p>\n     * \n     * @throws XMPPException if an error occurs on the XMPP protocol level.\n     * @throws SmackException if an error occurs somewhere else besides XMPP protocol level.\n     * @throws IOException if an I/O error occurs during login.\n     */\n    public synchronized void login() throws XMPPException, SmackException, IOException {\n        if (isAnonymous()) {\n            throwNotConnectedExceptionIfAppropriate(\"Did you call connect() before login()?\");\n            throwAlreadyLoggedInExceptionIfAppropriate();\n            loginAnonymously();\n        } else {\n            // The previously used username, password and resource take over precedence over the\n            // ones from the connection configuration\n            CharSequence username = usedUsername != null ? usedUsername : config.getUsername();\n            String password = usedPassword != null ? usedPassword : config.getPassword();\n            String resource = usedResource != null ? usedResource : config.getResource();\n            login(username, password, resource);\n        }\n    }\n\n    /**\n     * Same as {@link #login(CharSequence, String, String)}, but takes the resource from the connection\n     * configuration.\n     * \n     * @param username\n     * @param password\n     * @throws XMPPException\n     * @throws SmackException\n     * @throws IOException\n     * @see #login\n     */\n    public synchronized void login(CharSequence username, String password) throws XMPPException, SmackException,\n                    IOException {\n        login(username, password, config.getResource());\n    }\n\n    /**\n     * Login with the given username (authorization identity). You may omit the password if a callback handler is used.\n     * If resource is null, then the server will generate one.\n     * \n     * @param username\n     * @param password\n     * @param resource\n     * @throws XMPPException\n     * @throws SmackException\n     * @throws IOException\n     * @see #login\n     */\n    public synchronized void login(CharSequence username, String password, String resource) throws XMPPException,\n                    SmackException, IOException {\n        if (!config.allowNullOrEmptyUsername) {\n            StringUtils.requireNotNullOrEmpty(username, \"Username must not be null or empty\");\n        }\n        throwNotConnectedExceptionIfAppropriate();\n        throwAlreadyLoggedInExceptionIfAppropriate();\n        usedUsername = username != null ? username.toString() : null;\n        usedPassword = password;\n        usedResource = resource;\n        loginNonAnonymously(usedUsername, usedPassword, usedResource);\n    }\n\n    protected abstract void loginNonAnonymously(String username, String password, String resource)\n                    throws XMPPException, SmackException, IOException;\n\n    protected abstract void loginAnonymously() throws XMPPException, SmackException, IOException;\n\n    @Override\n    public final boolean isConnected() {\n        return connected;\n    }\n\n    @Override\n    public final boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    @Override\n    public final String getUser() {\n        return user;\n    }\n\n    @Override\n    public String getStreamId() {\n        if (!isConnected()) {\n            return null;\n        }\n        return streamId;\n    }\n\n    // TODO remove this suppression once \"disable legacy session\" code has been removed from Smack\n    @SuppressWarnings(\"deprecation\")\n    protected void bindResourceAndEstablishSession(String resource) throws XMPPErrorException,\n                    IOException, SmackException {\n\n        // Wait until either:\n        // - the servers last features stanza has been parsed\n        // - the timeout occurs\n        LOGGER.finer(\"Waiting for last features to be received before continuing with resource binding\");\n        lastFeaturesReceived.checkIfSuccessOrWait();\n\n\n        if (!hasFeature(Bind.ELEMENT, Bind.NAMESPACE)) {\n            // Server never offered resource binding, which is REQURIED in XMPP client and\n            // server implementations as per RFC6120 7.2\n            throw new ResourceBindingNotOfferedException();\n        }\n\n        // Resource binding, see RFC6120 7.\n        // Note that we can not use IQReplyFilter here, since the users full JID is not yet\n        // available. It will become available right after the resource has been successfully bound.\n        Bind bindResource = Bind.newSet(resource);\n        PacketCollector packetCollector = createPacketCollectorAndSend(new StanzaIdFilter(bindResource), bindResource);\n        Bind response = packetCollector.nextResultOrThrow();\n        // Set the connections user to the result of resource binding. It is important that we don't infer the user\n        // from the login() arguments and the configurations service name, as, for example, when SASL External is used,\n        // the username is not given to login but taken from the 'external' certificate.\n        user = response.getJid();\n        serviceName = XmppStringUtils.parseDomain(user);\n\n        Session.Feature sessionFeature = getFeature(Session.ELEMENT, Session.NAMESPACE);\n        // Only bind the session if it's announced as stream feature by the server, is not optional and not disabled\n        // For more information see http://tools.ietf.org/html/draft-cridland-xmpp-session-01\n        if (sessionFeature != null && !sessionFeature.isOptional() && !getConfiguration().isLegacySessionDisabled()) {\n            Session session = new Session();\n            packetCollector = createPacketCollectorAndSend(new StanzaIdFilter(session), session);\n            packetCollector.nextResultOrThrow();\n        }\n    }\n\n    protected void afterSuccessfulLogin(final boolean resumed) throws NotConnectedException {\n        // Indicate that we're now authenticated.\n        this.authenticated = true;\n\n        // If debugging is enabled, change the the debug window title to include the\n        // name we are now logged-in as.\n        // If DEBUG was set to true AFTER the connection was created the debugger\n        // will be null\n        if (config.isDebuggerEnabled() && debugger != null) {\n            debugger.userHasLogged(user);\n        }\n        callConnectionAuthenticatedListener(resumed);\n\n        // Set presence to online. It is important that this is done after\n        // callConnectionAuthenticatedListener(), as this call will also\n        // eventually load the roster. And we should load the roster before we\n        // send the initial presence.\n        if (config.isSendPresence() && !resumed) {\n            sendStanza(new Presence(Presence.Type.available));\n        }\n    }\n\n    @Override\n    public final boolean isAnonymous() {\n        return config.getUsername() == null && usedUsername == null\n                        && !config.allowNullOrEmptyUsername;\n    }\n\n    private String serviceName;\n\n    protected List<HostAddress> hostAddresses;\n\n    /**\n     * Populates {@link #hostAddresses} with at least one host address.\n     *\n     * @return a list of host addresses where DNS (SRV) RR resolution failed.\n     */\n    protected List<HostAddress> populateHostAddresses() {\n        List<HostAddress> failedAddresses = new LinkedList<>();\n        // N.B.: Important to use config.serviceName and not AbstractXMPPConnection.serviceName\n        if (config.host != null) {\n            hostAddresses = new ArrayList<HostAddress>(1);\n            HostAddress hostAddress;\n            hostAddress = new HostAddress(config.host, config.port);\n            hostAddresses.add(hostAddress);\n        } else {\n            hostAddresses = DNSUtil.resolveXMPPDomain(config.serviceName, failedAddresses);\n        }\n        // If we reach this, then hostAddresses *must not* be empty, i.e. there is at least one host added, either the\n        // config.host one or the host representing the service name by DNSUtil\n        assert(!hostAddresses.isEmpty());\n        return failedAddresses;\n    }\n\n    protected Lock getConnectionLock() {\n        return connectionLock;\n    }\n\n    protected void throwNotConnectedExceptionIfAppropriate() throws NotConnectedException {\n        throwNotConnectedExceptionIfAppropriate(null);\n    }\n\n    protected void throwNotConnectedExceptionIfAppropriate(String optionalHint) throws NotConnectedException {\n        if (!isConnected()) {\n            throw new NotConnectedException(optionalHint);\n        }\n    }\n\n    protected void throwAlreadyConnectedExceptionIfAppropriate() throws AlreadyConnectedException {\n        if (isConnected()) {\n            throw new AlreadyConnectedException();\n        }\n    }\n\n    protected void throwAlreadyLoggedInExceptionIfAppropriate() throws AlreadyLoggedInException {\n        if (isAuthenticated()) {\n            throw new AlreadyLoggedInException();\n        }\n    }\n\n    @Deprecated\n    @Override\n    public void sendPacket(Stanza packet) throws NotConnectedException {\n        sendStanza(packet);\n    }\n\n    @Override\n    public void sendStanza(Stanza packet) throws NotConnectedException {\n        Objects.requireNonNull(packet, \"Packet must not be null\");\n\n        throwNotConnectedExceptionIfAppropriate();\n        switch (fromMode) {\n        case OMITTED:\n            packet.setFrom(null);\n            break;\n        case USER:\n            packet.setFrom(getUser());\n            break;\n        case UNCHANGED:\n        default:\n            break;\n        }\n        // Invoke interceptors for the new packet that is about to be sent. Interceptors may modify\n        // the content of the packet.\n        firePacketInterceptors(packet);\n        sendStanzaInternal(packet);\n    }\n\n    /**\n     * Returns the SASLAuthentication manager that is responsible for authenticating with\n     * the server.\n     * \n     * @return the SASLAuthentication manager that is responsible for authenticating with\n     *         the server.\n     */\n    protected SASLAuthentication getSASLAuthentication() {\n        return saslAuthentication;\n    }\n\n    /**\n     * Closes the connection by setting presence to unavailable then closing the connection to\n     * the XMPP server. The XMPPConnection can still be used for connecting to the server\n     * again.\n     *\n     */\n    public void disconnect() {\n        try {\n            disconnect(new Presence(Presence.Type.unavailable));\n        }\n        catch (NotConnectedException e) {\n            LOGGER.log(Level.FINEST, \"Connection is already disconnected\", e);\n        }\n    }\n\n    /**\n     * Closes the connection. A custom unavailable presence is sent to the server, followed\n     * by closing the stream. The XMPPConnection can still be used for connecting to the server\n     * again. A custom unavailable presence is useful for communicating offline presence\n     * information such as \"On vacation\". Typically, just the status text of the presence\n     * stanza(/packet) is set with online information, but most XMPP servers will deliver the full\n     * presence stanza(/packet) with whatever data is set.\n     * \n     * @param unavailablePresence the presence stanza(/packet) to send during shutdown.\n     * @throws NotConnectedException \n     */\n    public synchronized void disconnect(Presence unavailablePresence) throws NotConnectedException {\n        sendStanza(unavailablePresence);\n        shutdown();\n        callConnectionClosedListener();\n    }\n\n    /**\n     * Shuts the current connection down.\n     */\n    protected abstract void shutdown();\n\n    @Override\n    public void addConnectionListener(ConnectionListener connectionListener) {\n        if (connectionListener == null) {\n            return;\n        }\n        connectionListeners.add(connectionListener);\n    }\n\n    @Override\n    public void removeConnectionListener(ConnectionListener connectionListener) {\n        connectionListeners.remove(connectionListener);\n    }\n\n    @Override\n    public PacketCollector createPacketCollectorAndSend(IQ packet) throws NotConnectedException {\n        StanzaFilter packetFilter = new IQReplyFilter(packet, this);\n        // Create the packet collector before sending the packet\n        PacketCollector packetCollector = createPacketCollectorAndSend(packetFilter, packet);\n        return packetCollector;\n    }\n\n    @Override\n    public PacketCollector createPacketCollectorAndSend(StanzaFilter packetFilter, Stanza packet)\n                    throws NotConnectedException {\n        // Create the packet collector before sending the packet\n        PacketCollector packetCollector = createPacketCollector(packetFilter);\n        try {\n            // Now we can send the packet as the collector has been created\n            sendStanza(packet);\n        }\n        catch (NotConnectedException | RuntimeException e) {\n            packetCollector.cancel();\n            throw e;\n        }\n        return packetCollector;\n    }\n\n    @Override\n    public PacketCollector createPacketCollector(StanzaFilter packetFilter) {\n        PacketCollector.Configuration configuration = PacketCollector.newConfiguration().setStanzaFilter(packetFilter);\n        return createPacketCollector(configuration);\n    }\n\n    @Override\n    public PacketCollector createPacketCollector(PacketCollector.Configuration configuration) {\n        PacketCollector collector = new PacketCollector(this, configuration);\n        // Add the collector to the list of active collectors.\n        collectors.add(collector);\n        return collector;\n    }\n\n    @Override\n    public void removePacketCollector(PacketCollector collector) {\n        collectors.remove(collector);\n    }\n\n    @Override\n    @Deprecated\n    public void addPacketListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        addAsyncStanzaListener(packetListener, packetFilter);\n    }\n\n    @Override\n    @Deprecated\n    public boolean removePacketListener(StanzaListener packetListener) {\n        return removeAsyncStanzaListener(packetListener);\n    }\n\n    @Override\n    public void addSyncStanzaListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        if (packetListener == null) {\n            throw new NullPointerException(\"Packet listener is null.\");\n        }\n        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);\n        synchronized (syncRecvListeners) {\n            syncRecvListeners.put(packetListener, wrapper);\n        }\n    }\n\n    @Override\n    public boolean removeSyncStanzaListener(StanzaListener packetListener) {\n        synchronized (syncRecvListeners) {\n            return syncRecvListeners.remove(packetListener) != null;\n        }\n    }\n\n    @Override\n    public void addAsyncStanzaListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        if (packetListener == null) {\n            throw new NullPointerException(\"Packet listener is null.\");\n        }\n        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);\n        synchronized (asyncRecvListeners) {\n            asyncRecvListeners.put(packetListener, wrapper);\n        }\n    }\n\n    @Override\n    public boolean removeAsyncStanzaListener(StanzaListener packetListener) {\n        synchronized (asyncRecvListeners) {\n            return asyncRecvListeners.remove(packetListener) != null;\n        }\n    }\n\n    @Override\n    public void addPacketSendingListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        if (packetListener == null) {\n            throw new NullPointerException(\"Packet listener is null.\");\n        }\n        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);\n        synchronized (sendListeners) {\n            sendListeners.put(packetListener, wrapper);\n        }\n    }\n\n    @Override\n    public void removePacketSendingListener(StanzaListener packetListener) {\n        synchronized (sendListeners) {\n            sendListeners.remove(packetListener);\n        }\n    }\n\n    /**\n     * Process all stanza(/packet) listeners for sending packets.\n     * <p>\n     * Compared to {@link #firePacketInterceptors(Stanza)}, the listeners will be invoked in a new thread.\n     * </p>\n     * \n     * @param packet the stanza(/packet) to process.\n     */\n    @SuppressWarnings(\"javadoc\")\n    protected void firePacketSendingListeners(final Stanza packet) {\n        final List<StanzaListener> listenersToNotify = new LinkedList<StanzaListener>();\n        synchronized (sendListeners) {\n            for (ListenerWrapper listenerWrapper : sendListeners.values()) {\n                if (listenerWrapper.filterMatches(packet)) {\n                    listenersToNotify.add(listenerWrapper.getListener());\n                }\n            }\n        }\n        if (listenersToNotify.isEmpty()) {\n            return;\n        }\n        // Notify in a new thread, because we can\n        asyncGo(new Runnable() {\n            @Override\n            public void run() {\n                for (StanzaListener listener : listenersToNotify) {\n                    try {\n                        listener.processPacket(packet);\n                    }\n                    catch (Exception e) {\n                        LOGGER.log(Level.WARNING, \"Sending listener threw exception\", e);\n                        continue;\n                    }\n                }\n            }});\n    }\n\n    @Override\n    public void addPacketInterceptor(StanzaListener packetInterceptor,\n            StanzaFilter packetFilter) {\n        if (packetInterceptor == null) {\n            throw new NullPointerException(\"Packet interceptor is null.\");\n        }\n        InterceptorWrapper interceptorWrapper = new InterceptorWrapper(packetInterceptor, packetFilter);\n        synchronized (interceptors) {\n            interceptors.put(packetInterceptor, interceptorWrapper);\n        }\n    }\n\n    @Override\n    public void removePacketInterceptor(StanzaListener packetInterceptor) {\n        synchronized (interceptors) {\n            interceptors.remove(packetInterceptor);\n        }\n    }\n\n    /**\n     * Process interceptors. Interceptors may modify the stanza(/packet) that is about to be sent.\n     * Since the thread that requested to send the stanza(/packet) will invoke all interceptors, it\n     * is important that interceptors perform their work as soon as possible so that the\n     * thread does not remain blocked for a long period.\n     * \n     * @param packet the stanza(/packet) that is going to be sent to the server\n     */\n    private void firePacketInterceptors(Stanza packet) {\n        List<StanzaListener> interceptorsToInvoke = new LinkedList<StanzaListener>();\n        synchronized (interceptors) {\n            for (InterceptorWrapper interceptorWrapper : interceptors.values()) {\n                if (interceptorWrapper.filterMatches(packet)) {\n                    interceptorsToInvoke.add(interceptorWrapper.getInterceptor());\n                }\n            }\n        }\n        for (StanzaListener interceptor : interceptorsToInvoke) {\n            try {\n                interceptor.processPacket(packet);\n            } catch (Exception e) {\n                LOGGER.log(Level.SEVERE, \"Packet interceptor threw exception\", e);\n            }\n        }\n    }\n\n    /**\n     * Initialize the {@link #debugger}. You can specify a customized {@link SmackDebugger}\n     * by setup the system property <code>smack.debuggerClass</code> to the implementation.\n     * \n     * @throws IllegalStateException if the reader or writer isn't yet initialized.\n     * @throws IllegalArgumentException if the SmackDebugger can't be loaded.\n     */\n    protected void initDebugger() {\n        if (reader == null || writer == null) {\n            throw new NullPointerException(\"Reader or writer isn't initialized.\");\n        }\n        // If debugging is enabled, we open a window and write out all network traffic.\n        if (config.isDebuggerEnabled()) {\n            if (debugger == null) {\n                debugger = SmackConfiguration.createDebugger(this, writer, reader);\n            }\n\n            if (debugger == null) {\n                LOGGER.severe(\"Debugging enabled but could not find debugger class\");\n            } else {\n                // Obtain new reader and writer from the existing debugger\n                reader = debugger.newConnectionReader(reader);\n                writer = debugger.newConnectionWriter(writer);\n            }\n        }\n    }\n\n    @Override\n    public long getPacketReplyTimeout() {\n        return packetReplyTimeout;\n    }\n\n    @Override\n    public void setPacketReplyTimeout(long timeout) {\n        packetReplyTimeout = timeout;\n    }\n\n    private static boolean replyToUnknownIqDefault = true;\n\n    /**\n     * Set the default value used to determine if new connection will reply to unknown IQ requests. The pre-configured\n     * default is 'true'.\n     *\n     * @param replyToUnkownIqDefault\n     * @see #setReplyToUnknownIq(boolean)\n     */\n    public static void setReplyToUnknownIqDefault(boolean replyToUnkownIqDefault) {\n        AbstractXMPPConnection.replyToUnknownIqDefault = replyToUnkownIqDefault;\n    }\n\n    private boolean replyToUnkownIq = replyToUnknownIqDefault;\n\n    /**\n     * Set if Smack will automatically send\n     * {@link org.jivesoftware.smack.packet.XMPPError.Condition#feature_not_implemented} when a request IQ without a\n     * registered {@link IQRequestHandler} is received.\n     *\n     * @param replyToUnknownIq\n     */\n    public void setReplyToUnknownIq(boolean replyToUnknownIq) {\n        this.replyToUnkownIq = replyToUnknownIq;\n    }\n\n    protected void parseAndProcessStanza(XmlPullParser parser) throws Exception {\n        ParserUtils.assertAtStartTag(parser);\n        int parserDepth = parser.getDepth();\n        Stanza stanza = null;\n        try {\n            stanza = PacketParserUtils.parseStanza(parser);\n        }\n        catch (Exception e) {\n            CharSequence content = PacketParserUtils.parseContentDepth(parser,\n                            parserDepth);\n            UnparsablePacket message = new UnparsablePacket(content, e);\n            ParsingExceptionCallback callback = getParsingExceptionCallback();\n            if (callback != null) {\n                callback.handleUnparsablePacket(message);\n            }\n        }\n        ParserUtils.assertAtEndTag(parser);\n        if (stanza != null) {\n            processPacket(stanza);\n        }\n    }\n\n    /**\n     * Processes a stanza(/packet) after it's been fully parsed by looping through the installed\n     * stanza(/packet) collectors and listeners and letting them examine the stanza(/packet) to see if\n     * they are a match with the filter.\n     *\n     * @param packet the stanza(/packet) to process.\n     * @throws InterruptedException\n     */\n    protected void processPacket(Stanza packet) throws InterruptedException {\n        assert(packet != null);\n        lastStanzaReceived = System.currentTimeMillis();\n        // Deliver the incoming packet to listeners.\n        executorService.executeBlocking(new ListenerNotification(packet));\n    }\n\n    /**\n     * A runnable to notify all listeners and stanza(/packet) collectors of a packet.\n     */\n    private class ListenerNotification implements Runnable {\n\n        private final Stanza packet;\n\n        public ListenerNotification(Stanza packet) {\n            this.packet = packet;\n        }\n\n        public void run() {\n            invokePacketCollectorsAndNotifyRecvListeners(packet);\n        }\n    }\n\n    /**\n     * Invoke {@link PacketCollector#processPacket(Stanza)} for every\n     * PacketCollector with the given packet. Also notify the receive listeners with a matching stanza(/packet) filter about the packet.\n     *\n     * @param packet the stanza(/packet) to notify the PacketCollectors and receive listeners about.\n     */\n    protected void invokePacketCollectorsAndNotifyRecvListeners(final Stanza packet) {\n        if (packet instanceof IQ) {\n            final IQ iq = (IQ) packet;\n            final IQ.Type type = iq.getType();\n            switch (type) {\n            case set:\n            case get:\n                final String key = XmppStringUtils.generateKey(iq.getChildElementName(), iq.getChildElementNamespace());\n                IQRequestHandler iqRequestHandler = null;\n                switch (type) {\n                case set:\n                    synchronized (setIqRequestHandler) {\n                        iqRequestHandler = setIqRequestHandler.get(key);\n                    }\n                    break;\n                case get:\n                    synchronized (getIqRequestHandler) {\n                        iqRequestHandler = getIqRequestHandler.get(key);\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException(\"Should only encounter IQ type 'get' or 'set'\");\n                }\n                if (iqRequestHandler == null) {\n                    if (!replyToUnkownIq) {\n                        return;\n                    }\n                    // If the IQ stanza is of type \"get\" or \"set\" with no registered IQ request handler, then answer an\n                    // IQ of type \"error\" with code 501 (\"feature-not-implemented\")\n                    ErrorIQ errorIQ = IQ.createErrorResponse(iq, new XMPPError(\n                                    XMPPError.Condition.feature_not_implemented));\n                    try {\n                        sendStanza(errorIQ);\n                    }\n                    catch (NotConnectedException e) {\n                        LOGGER.log(Level.WARNING, \"NotConnectedException while sending error IQ to unkown IQ request\", e);\n                    }\n                } else {\n                    ExecutorService executorService = null;\n                    switch (iqRequestHandler.getMode()) {\n                    case sync:\n                        executorService = singleThreadedExecutorService;\n                        break;\n                    case async:\n                        executorService = cachedExecutorService;\n                        break;\n                    }\n                    final IQRequestHandler finalIqRequestHandler = iqRequestHandler;\n                    executorService.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            IQ response = finalIqRequestHandler.handleIQRequest(iq);\n                            if (response == null) {\n                                // It is not ideal if the IQ request handler does not return an IQ response, because RFC\n                                // 6120 \u00a7 8.1.2 does specify that a response is mandatory. But some APIs, mostly the\n                                // file transfer one, does not always return a result, so we need to handle this case.\n                                // Also sometimes a request handler may decide that it's better to not send a response,\n                                // e.g. to avoid presence leaks.\n                                return;\n                            }\n                            try {\n                                sendStanza(response);\n                            }\n                            catch (NotConnectedException e) {\n                                LOGGER.log(Level.WARNING, \"NotConnectedException while sending response to IQ request\", e);\n                            }\n                        }\n                    });\n                    // The following returns makes it impossible for packet listeners and collectors to\n                    // filter for IQ request stanzas, i.e. IQs of type 'set' or 'get'. This is the\n                    // desired behavior.\n                    return;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        // First handle the async recv listeners. Note that this code is very similar to what follows a few lines below,\n        // the only difference is that asyncRecvListeners is used here and that the packet listeners are started in\n        // their own thread.\n        final Collection<StanzaListener> listenersToNotify = new LinkedList<StanzaListener>();\n        synchronized (asyncRecvListeners) {\n            for (ListenerWrapper listenerWrapper : asyncRecvListeners.values()) {\n                if (listenerWrapper.filterMatches(packet)) {\n                    listenersToNotify.add(listenerWrapper.getListener());\n                }\n            }\n        }\n\n        for (final StanzaListener listener : listenersToNotify) {\n            asyncGo(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        listener.processPacket(packet);\n                    } catch (Exception e) {\n                        LOGGER.log(Level.SEVERE, \"Exception in async packet listener\", e);\n                    }\n                }\n            });\n        }\n\n        // Loop through all collectors and notify the appropriate ones.\n        for (PacketCollector collector: collectors) {\n            collector.processPacket(packet);\n        }\n\n        // Notify the receive listeners interested in the packet\n        listenersToNotify.clear();\n        synchronized (syncRecvListeners) {\n            for (ListenerWrapper listenerWrapper : syncRecvListeners.values()) {\n                if (listenerWrapper.filterMatches(packet)) {\n                    listenersToNotify.add(listenerWrapper.getListener());\n                }\n            }\n        }\n\n        // Decouple incoming stanza processing from listener invocation. Unlike async listeners, this uses a single\n        // threaded executor service and therefore keeps the order.\n        singleThreadedExecutorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                for (StanzaListener listener : listenersToNotify) {\n                    try {\n                        listener.processPacket(packet);\n                    } catch(NotConnectedException e) {\n                        LOGGER.log(Level.WARNING, \"Got not connected exception, aborting\", e);\n                        break;\n                    } catch (Exception e) {\n                        LOGGER.log(Level.SEVERE, \"Exception in packet listener\", e);\n                    }\n                }\n            }\n        });\n\n    }\n\n    /**\n     * Sets whether the connection has already logged in the server. This method assures that the\n     * {@link #wasAuthenticated} flag is never reset once it has ever been set.\n     * \n     */\n    protected void setWasAuthenticated() {\n        // Never reset the flag if the connection has ever been authenticated\n        if (!wasAuthenticated) {\n            wasAuthenticated = authenticated;\n        }\n    }\n\n    protected void callConnectionConnectedListener() {\n        for (ConnectionListener listener : connectionListeners) {\n            listener.connected(this);\n        }\n    }\n\n    protected void callConnectionAuthenticatedListener(boolean resumed) {\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.authenticated(this, resumed);\n            } catch (Exception e) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener and finish the shutdown process\n                LOGGER.log(Level.SEVERE, \"Exception in authenticated listener\", e);\n            }\n        }\n    }\n\n    void callConnectionClosedListener() {\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.connectionClosed();\n            }\n            catch (Exception e) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener and finish the shutdown process\n                LOGGER.log(Level.SEVERE, \"Error in listener while closing connection\", e);\n            }\n        }\n    }\n\n    protected void callConnectionClosedOnErrorListener(Exception e) {\n        LOGGER.log(Level.WARNING, \"Connection closed with error\", e);\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.connectionClosedOnError(e);\n            }\n            catch (Exception e2) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener\n                LOGGER.log(Level.SEVERE, \"Error in listener while closing connection\", e2);\n            }\n        }\n    }\n\n    /**\n     * Sends a notification indicating that the connection was reconnected successfully.\n     */\n    protected void notifyReconnection() {\n        // Notify connection listeners of the reconnection.\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.reconnectionSuccessful();\n            }\n            catch (Exception e) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener\n                LOGGER.log(Level.WARNING, \"notifyReconnection()\", e);\n            }\n        }\n    }\n\n    /**\n     * A wrapper class to associate a stanza(/packet) filter with a listener.\n     */\n    protected static class ListenerWrapper {\n\n        private final StanzaListener packetListener;\n        private final StanzaFilter packetFilter;\n\n        /**\n         * Create a class which associates a stanza(/packet) filter with a listener.\n         * \n         * @param packetListener the stanza(/packet) listener.\n         * @param packetFilter the associated filter or null if it listen for all packets.\n         */\n        public ListenerWrapper(StanzaListener packetListener, StanzaFilter packetFilter) {\n            this.packetListener = packetListener;\n            this.packetFilter = packetFilter;\n        }\n\n        public boolean filterMatches(Stanza packet) {\n            return packetFilter == null || packetFilter.accept(packet);\n        }\n\n        public StanzaListener getListener() {\n            return packetListener;\n        }\n    }\n\n    /**\n     * A wrapper class to associate a stanza(/packet) filter with an interceptor.\n     */\n    protected static class InterceptorWrapper {\n\n        private final StanzaListener packetInterceptor;\n        private final StanzaFilter packetFilter;\n\n        /**\n         * Create a class which associates a stanza(/packet) filter with an interceptor.\n         * \n         * @param packetInterceptor the interceptor.\n         * @param packetFilter the associated filter or null if it intercepts all packets.\n         */\n        public InterceptorWrapper(StanzaListener packetInterceptor, StanzaFilter packetFilter) {\n            this.packetInterceptor = packetInterceptor;\n            this.packetFilter = packetFilter;\n        }\n\n        public boolean filterMatches(Stanza packet) {\n            return packetFilter == null || packetFilter.accept(packet);\n        }\n\n        public StanzaListener getInterceptor() {\n            return packetInterceptor;\n        }\n    }\n\n    @Override\n    public int getConnectionCounter() {\n        return connectionCounterValue;\n    }\n\n    @Override\n    public void setFromMode(FromMode fromMode) {\n        this.fromMode = fromMode;\n    }\n\n    @Override\n    public FromMode getFromMode() {\n        return this.fromMode;\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        LOGGER.fine(\"finalizing XMPPConnection ( \" + getConnectionCounter()\n                        + \"): Shutting down executor services\");\n        try {\n            // It's usually not a good idea to rely on finalize. But this is the easiest way to\n            // avoid the \"Smack Listener Processor\" leaking. The thread(s) of the executor have a\n            // reference to their ExecutorService which prevents the ExecutorService from being\n            // gc'ed. It is possible that the XMPPConnection instance is gc'ed while the\n            // listenerExecutor ExecutorService call not be gc'ed until it got shut down.\n            executorService.shutdownNow();\n            cachedExecutorService.shutdown();\n            removeCallbacksService.shutdownNow();\n            singleThreadedExecutorService.shutdownNow();\n        } catch (Throwable t) {\n            LOGGER.log(Level.WARNING, \"finalize() threw trhowable\", t);\n        }\n        finally {\n            super.finalize();\n        }\n    }\n\n    protected final void parseFeatures(XmlPullParser parser) throws XmlPullParserException,\n                    IOException, SmackException {\n        streamFeatures.clear();\n        final int initialDepth = parser.getDepth();\n        while (true) {\n            int eventType = parser.next();\n\n            if (eventType == XmlPullParser.START_TAG && parser.getDepth() == initialDepth + 1) {\n                ExtensionElement streamFeature = null;\n                String name = parser.getName();\n                String namespace = parser.getNamespace();\n                switch (name) {\n                case StartTls.ELEMENT:\n                    streamFeature = PacketParserUtils.parseStartTlsFeature(parser);\n                    break;\n                case Mechanisms.ELEMENT:\n                    streamFeature = new Mechanisms(PacketParserUtils.parseMechanisms(parser));\n                    break;\n                case Bind.ELEMENT:\n                    streamFeature = Bind.Feature.INSTANCE;\n                    break;\n                case Session.ELEMENT:\n                    streamFeature = PacketParserUtils.parseSessionFeature(parser);\n                    break;\n                case Compress.Feature.ELEMENT:\n                    streamFeature = PacketParserUtils.parseCompressionFeature(parser);\n                    break;\n                default:\n                    ExtensionElementProvider<ExtensionElement> provider = ProviderManager.getStreamFeatureProvider(name, namespace);\n                    if (provider != null) {\n                        streamFeature = provider.parse(parser);\n                    }\n                    break;\n                }\n                if (streamFeature != null) {\n                    addStreamFeature(streamFeature);\n                }\n            }\n            else if (eventType == XmlPullParser.END_TAG && parser.getDepth() == initialDepth) {\n                break;\n            }\n        }\n\n        if (hasFeature(Mechanisms.ELEMENT, Mechanisms.NAMESPACE)) {\n            // Only proceed with SASL auth if TLS is disabled or if the server doesn't announce it\n            if (!hasFeature(StartTls.ELEMENT, StartTls.NAMESPACE)\n                            || config.getSecurityMode() == SecurityMode.disabled) {\n                saslFeatureReceived.reportSuccess();\n            }\n        }\n\n        // If the server reported the bind feature then we are that that we did SASL and maybe\n        // STARTTLS. We can then report that the last 'stream:features' have been parsed\n        if (hasFeature(Bind.ELEMENT, Bind.NAMESPACE)) {\n            if (!hasFeature(Compress.Feature.ELEMENT, Compress.NAMESPACE)\n                            || !config.isCompressionEnabled()) {\n                // This was was last features from the server is either it did not contain\n                // compression or if we disabled it\n                lastFeaturesReceived.reportSuccess();\n            }\n        }\n        afterFeaturesReceived();\n    }\n\n    protected void afterFeaturesReceived() throws SecurityRequiredException, NotConnectedException {\n        // Default implementation does nothing\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <F extends ExtensionElement> F getFeature(String element, String namespace) {\n        return (F) streamFeatures.get(XmppStringUtils.generateKey(element, namespace));\n    }\n\n    @Override\n    public boolean hasFeature(String element, String namespace) {\n        return getFeature(element, namespace) != null;\n    }\n\n    private void addStreamFeature(ExtensionElement feature) {\n        String key = XmppStringUtils.generateKey(feature.getElementName(), feature.getNamespace());\n        streamFeatures.put(key, feature);\n    }\n\n    @Override\n    public void sendStanzaWithResponseCallback(Stanza stanza, StanzaFilter replyFilter,\n                    StanzaListener callback) throws NotConnectedException {\n        sendStanzaWithResponseCallback(stanza, replyFilter, callback, null);\n    }\n\n    @Override\n    public void sendStanzaWithResponseCallback(Stanza stanza, StanzaFilter replyFilter,\n                    StanzaListener callback, ExceptionCallback exceptionCallback)\n                    throws NotConnectedException {\n        sendStanzaWithResponseCallback(stanza, replyFilter, callback, exceptionCallback,\n                        getPacketReplyTimeout());\n    }\n\n    @Override\n    public void sendStanzaWithResponseCallback(Stanza stanza, final StanzaFilter replyFilter,\n                    final StanzaListener callback, final ExceptionCallback exceptionCallback,\n                    long timeout) throws NotConnectedException {\n        Objects.requireNonNull(stanza, \"stanza must not be null\");\n        // While Smack allows to add PacketListeners with a PacketFilter value of 'null', we\n        // disallow it here in the async API as it makes no sense\n        Objects.requireNonNull(replyFilter, \"replyFilter must not be null\");\n        Objects.requireNonNull(callback, \"callback must not be null\");\n\n        final StanzaListener packetListener = new StanzaListener() {\n            @Override\n            public void processPacket(Stanza packet) throws NotConnectedException {\n                try {\n                    XMPPErrorException.ifHasErrorThenThrow(packet);\n                    callback.processPacket(packet);\n                }\n                catch (XMPPErrorException e) {\n                    if (exceptionCallback != null) {\n                        exceptionCallback.processException(e);\n                    }\n                }\n                finally {\n                    removeAsyncStanzaListener(this);\n                }\n            }\n        };\n        removeCallbacksService.schedule(new Runnable() {\n            @Override\n            public void run() {\n                boolean removed = removeAsyncStanzaListener(packetListener);\n                // If the packetListener got removed, then it was never run and\n                // we never received a response, inform the exception callback\n                if (removed && exceptionCallback != null) {\n                    exceptionCallback.processException(NoResponseException.newWith(AbstractXMPPConnection.this, replyFilter));\n                }\n            }\n        }, timeout, TimeUnit.MILLISECONDS);\n        addAsyncStanzaListener(packetListener, replyFilter);\n        sendStanza(stanza);\n    }\n\n    @Override\n    public void sendIqWithResponseCallback(IQ iqRequest, StanzaListener callback)\n                    throws NotConnectedException {\n        sendIqWithResponseCallback(iqRequest, callback, null);\n    }\n\n    @Override\n    public void sendIqWithResponseCallback(IQ iqRequest, StanzaListener callback,\n                    ExceptionCallback exceptionCallback) throws NotConnectedException {\n        sendIqWithResponseCallback(iqRequest, callback, exceptionCallback, getPacketReplyTimeout());\n    }\n\n    @Override\n    public void sendIqWithResponseCallback(IQ iqRequest, final StanzaListener callback,\n                    final ExceptionCallback exceptionCallback, long timeout)\n                    throws NotConnectedException {\n        StanzaFilter replyFilter = new IQReplyFilter(iqRequest, this);\n        sendStanzaWithResponseCallback(iqRequest, replyFilter, callback, exceptionCallback, timeout);\n    }\n\n    @Override\n    public void addOneTimeSyncCallback(final StanzaListener callback, final StanzaFilter packetFilter) {\n        final StanzaListener packetListener = new StanzaListener() {\n            @Override\n            public void processPacket(Stanza packet) throws NotConnectedException {\n                try {\n                    callback.processPacket(packet);\n                } finally {\n                    removeSyncStanzaListener(this);\n                }\n            }\n        };\n        addSyncStanzaListener(packetListener, packetFilter);\n        removeCallbacksService.schedule(new Runnable() {\n            @Override\n            public void run() {\n                removeSyncStanzaListener(packetListener);\n            }\n        }, getPacketReplyTimeout(), TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public IQRequestHandler registerIQRequestHandler(final IQRequestHandler iqRequestHandler) {\n        final String key = XmppStringUtils.generateKey(iqRequestHandler.getElement(), iqRequestHandler.getNamespace());\n        switch (iqRequestHandler.getType()) {\n        case set:\n            synchronized (setIqRequestHandler) {\n                return setIqRequestHandler.put(key, iqRequestHandler);\n            }\n        case get:\n            synchronized (getIqRequestHandler) {\n                return getIqRequestHandler.put(key, iqRequestHandler);\n            }\n        default:\n            throw new IllegalArgumentException(\"Only IQ type of 'get' and 'set' allowed\");\n        }\n    }\n\n    @Override\n    public final IQRequestHandler unregisterIQRequestHandler(IQRequestHandler iqRequestHandler) {\n        return unregisterIQRequestHandler(iqRequestHandler.getElement(), iqRequestHandler.getNamespace(),\n                        iqRequestHandler.getType());\n    }\n\n    @Override\n    public IQRequestHandler unregisterIQRequestHandler(String element, String namespace, IQ.Type type) {\n        final String key = XmppStringUtils.generateKey(element, namespace);\n        switch (type) {\n        case set:\n            synchronized (setIqRequestHandler) {\n                return setIqRequestHandler.remove(key);\n            }\n        case get:\n            synchronized (getIqRequestHandler) {\n                return getIqRequestHandler.remove(key);\n            }\n        default:\n            throw new IllegalArgumentException(\"Only IQ type of 'get' and 'set' allowed\");\n        }\n    }\n\n    private long lastStanzaReceived;\n\n    public long getLastStanzaReceived() {\n        return lastStanzaReceived;\n    }\n\n    /**\n     * Install a parsing exception callback, which will be invoked once an exception is encountered while parsing a\n     * stanza\n     * \n     * @param callback the callback to install\n     */\n    public void setParsingExceptionCallback(ParsingExceptionCallback callback) {\n        parsingExceptionCallback = callback;\n    }\n\n    /**\n     * Get the current active parsing exception callback.\n     *  \n     * @return the active exception callback or null if there is none\n     */\n    public ParsingExceptionCallback getParsingExceptionCallback() {\n        return parsingExceptionCallback;\n    }\n\n    protected final void asyncGo(Runnable runnable) {\n        cachedExecutorService.execute(runnable);\n    }\n\n    protected final ScheduledFuture<?> schedule(Runnable runnable, long delay, TimeUnit unit) {\n        return removeCallbacksService.schedule(runnable, delay, unit);\n    }\n}\n", "/**\n *\n * Copyright 2003-2007 Jive Software.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.smack.tcp;\n\nimport org.jivesoftware.smack.AbstractConnectionListener;\nimport org.jivesoftware.smack.AbstractXMPPConnection;\nimport org.jivesoftware.smack.ConnectionConfiguration;\nimport org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;\nimport org.jivesoftware.smack.ConnectionCreationListener;\nimport org.jivesoftware.smack.StanzaListener;\nimport org.jivesoftware.smack.SmackConfiguration;\nimport org.jivesoftware.smack.SmackException;\nimport org.jivesoftware.smack.SmackException.AlreadyConnectedException;\nimport org.jivesoftware.smack.SmackException.AlreadyLoggedInException;\nimport org.jivesoftware.smack.SmackException.NoResponseException;\nimport org.jivesoftware.smack.SmackException.NotConnectedException;\nimport org.jivesoftware.smack.SmackException.ConnectionException;\nimport org.jivesoftware.smack.SmackException.SecurityRequiredByClientException;\nimport org.jivesoftware.smack.SmackException.SecurityRequiredByServerException;\nimport org.jivesoftware.smack.SmackException.SecurityRequiredException;\nimport org.jivesoftware.smack.SynchronizationPoint;\nimport org.jivesoftware.smack.XMPPException.StreamErrorException;\nimport org.jivesoftware.smack.XMPPConnection;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.XMPPException.XMPPErrorException;\nimport org.jivesoftware.smack.compress.packet.Compressed;\nimport org.jivesoftware.smack.compression.XMPPInputOutputStream;\nimport org.jivesoftware.smack.filter.StanzaFilter;\nimport org.jivesoftware.smack.compress.packet.Compress;\nimport org.jivesoftware.smack.packet.Element;\nimport org.jivesoftware.smack.packet.IQ;\nimport org.jivesoftware.smack.packet.Message;\nimport org.jivesoftware.smack.packet.StreamOpen;\nimport org.jivesoftware.smack.packet.Stanza;\nimport org.jivesoftware.smack.packet.Presence;\nimport org.jivesoftware.smack.packet.StartTls;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements.Challenge;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements.SASLFailure;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements.Success;\nimport org.jivesoftware.smack.sm.SMUtils;\nimport org.jivesoftware.smack.sm.StreamManagementException;\nimport org.jivesoftware.smack.sm.StreamManagementException.StreamIdDoesNotMatchException;\nimport org.jivesoftware.smack.sm.StreamManagementException.StreamManagementCounterError;\nimport org.jivesoftware.smack.sm.StreamManagementException.StreamManagementNotEnabledException;\nimport org.jivesoftware.smack.sm.packet.StreamManagement;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.AckAnswer;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.AckRequest;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Enable;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Enabled;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Failed;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Resume;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Resumed;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.StreamManagementFeature;\nimport org.jivesoftware.smack.sm.predicates.Predicate;\nimport org.jivesoftware.smack.sm.provider.ParseStreamManagement;\nimport org.jivesoftware.smack.packet.PlainStreamElement;\nimport org.jivesoftware.smack.packet.XMPPError;\nimport org.jivesoftware.smack.util.ArrayBlockingQueueWithShutdown;\nimport org.jivesoftware.smack.util.Async;\nimport org.jivesoftware.smack.util.PacketParserUtils;\nimport org.jivesoftware.smack.util.StringUtils;\nimport org.jivesoftware.smack.util.TLSUtils;\nimport org.jivesoftware.smack.util.dns.HostAddress;\nimport org.jxmpp.util.XmppStringUtils;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.PasswordCallback;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.Provider;\nimport java.security.Security;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Creates a socket connection to an XMPP server. This is the default connection\n * to an XMPP server and is specified in the XMPP Core (RFC 6120).\n * \n * @see XMPPConnection\n * @author Matt Tucker\n */\npublic class XMPPTCPConnection extends AbstractXMPPConnection {\n\n    private static final int QUEUE_SIZE = 500;\n    private static final Logger LOGGER = Logger.getLogger(XMPPTCPConnection.class.getName());\n\n    /**\n     * The socket which is used for this connection.\n     */\n    private Socket socket;\n\n    /**\n     * \n     */\n    private boolean disconnectedButResumeable = false;\n\n    /**\n     * Flag to indicate if the socket was closed intentionally by Smack.\n     * <p>\n     * This boolean flag is used concurrently, therefore it is marked volatile.\n     * </p>\n     */\n    private volatile boolean socketClosed = false;\n\n    private boolean usingTLS = false;\n\n    /**\n     * Protected access level because of unit test purposes\n     */\n    protected PacketWriter packetWriter;\n\n    /**\n     * Protected access level because of unit test purposes\n     */\n    protected PacketReader packetReader;\n\n    private final SynchronizationPoint<Exception> initalOpenStreamSend = new SynchronizationPoint<Exception>(this);\n\n    /**\n     * \n     */\n    private final SynchronizationPoint<XMPPException> maybeCompressFeaturesReceived = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    /**\n     * \n     */\n    private final SynchronizationPoint<XMPPException> compressSyncPoint = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    /**\n     * The default bundle and defer callback, used for new connections.\n     * @see bundleAndDeferCallback\n     */\n    private static BundleAndDeferCallback defaultBundleAndDeferCallback;\n\n    /**\n     * The used bundle and defer callback.\n     * <p>\n     * Although this field may be set concurrently, the 'volatile' keyword was deliberately not added, in order to avoid\n     * having a 'volatile' read within the writer threads loop.\n     * </p>\n     */\n    private BundleAndDeferCallback bundleAndDeferCallback = defaultBundleAndDeferCallback;\n\n    private static boolean useSmDefault = false;\n\n    private static boolean useSmResumptionDefault = true;\n\n    /**\n     * The stream ID of the stream that is currently resumable, ie. the stream we hold the state\n     * for in {@link #clientHandledStanzasCount}, {@link #serverHandledStanzasCount} and\n     * {@link #unacknowledgedStanzas}.\n     */\n    private String smSessionId;\n\n    private final SynchronizationPoint<XMPPException> smResumedSyncPoint = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    private final SynchronizationPoint<XMPPException> smEnabledSyncPoint = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    /**\n     * The client's preferred maximum resumption time in seconds.\n     */\n    private int smClientMaxResumptionTime = -1;\n\n    /**\n     * The server's preferred maximum resumption time in seconds.\n     */\n    private int smServerMaxResumptimTime = -1;\n\n    /**\n     * Indicates whether Stream Management (XEP-198) should be used if it's supported by the server.\n     */\n    private boolean useSm = useSmDefault;\n    private boolean useSmResumption = useSmResumptionDefault;\n\n    /**\n     * The counter that the server sends the client about it's current height. For example, if the server sends\n     * {@code <a h='42'/>}, then this will be set to 42 (while also handling the {@link #unacknowledgedStanzas} queue).\n     */\n    private long serverHandledStanzasCount = 0;\n\n    /**\n     * The counter for stanzas handled (\"received\") by the client.\n     * <p>\n     * Note that we don't need to synchronize this counter. Although JLS 17.7 states that reads and writes to longs are\n     * not atomic, it guarantees that there are at most 2 separate writes, one to each 32-bit half. And since\n     * {@link SMUtils#incrementHeight(long)} masks the lower 32 bit, we only operate on one half of the long and\n     * therefore have no concurrency problem because the read/write operations on one half are guaranteed to be atomic.\n     * </p>\n     */\n    private long clientHandledStanzasCount = 0;\n\n    private BlockingQueue<Stanza> unacknowledgedStanzas;\n\n    /**\n     * Set to true if Stream Management was at least once enabled for this connection.\n     */\n    private boolean smWasEnabledAtLeastOnce = false;\n\n    /**\n     * This listeners are invoked for every stanza that got acknowledged.\n     * <p>\n     * We use a {@link ConccurrentLinkedQueue} here in order to allow the listeners to remove\n     * themselves after they have been invoked.\n     * </p>\n     */\n    private final Collection<StanzaListener> stanzaAcknowledgedListeners = new ConcurrentLinkedQueue<StanzaListener>();\n\n    /**\n     * This listeners are invoked for a acknowledged stanza that has the given stanza ID. They will\n     * only be invoked once and automatically removed after that.\n     */\n    private final Map<String, StanzaListener> stanzaIdAcknowledgedListeners = new ConcurrentHashMap<String, StanzaListener>();\n\n    /**\n     * Predicates that determine if an stream management ack should be requested from the server.\n     * <p>\n     * We use a linked hash set here, so that the order how the predicates are added matches the\n     * order in which they are invoked in order to determine if an ack request should be send or not.\n     * </p>\n     */\n    private final Set<StanzaFilter> requestAckPredicates = new LinkedHashSet<StanzaFilter>();\n\n    private final XMPPTCPConnectionConfiguration config;\n\n    /**\n     * Creates a new XMPP connection over TCP (optionally using proxies).\n     * <p>\n     * Note that XMPPTCPConnection constructors do not establish a connection to the server\n     * and you must call {@link #connect()}.\n     * </p>\n     *\n     * @param config the connection configuration.\n     */\n    public XMPPTCPConnection(XMPPTCPConnectionConfiguration config) {\n        super(config);\n        this.config = config;\n        addConnectionListener(new AbstractConnectionListener() {\n            @Override\n            public void connectionClosedOnError(Exception e) {\n                if (e instanceof XMPPException.StreamErrorException) {\n                    dropSmState();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates a new XMPP connection over TCP.\n     * <p>\n     * Note that {@code jid} must be the bare JID, e.g. \"user@example.org\". More fine-grained control over the\n     * connection settings is available using the {@link #XMPPTCPConnection(XMPPTCPConnectionConfiguration)}\n     * constructor.\n     * </p>\n     * \n     * @param jid the bare JID used by the client.\n     * @param password the password or authentication token.\n     */\n    public XMPPTCPConnection(CharSequence jid, String password) {\n        this(XmppStringUtils.parseLocalpart(jid.toString()), password, XmppStringUtils.parseDomain(jid.toString()));\n    }\n\n    /**\n     * Creates a new XMPP connection over TCP.\n     * <p>\n     * This is the simplest constructor for connecting to an XMPP server. Alternatively,\n     * you can get fine-grained control over connection settings using the\n     * {@link #XMPPTCPConnection(XMPPTCPConnectionConfiguration)} constructor.\n     * </p>\n     * @param username\n     * @param password\n     * @param serviceName\n     */\n    public XMPPTCPConnection(CharSequence username, String password, String serviceName) {\n        this(XMPPTCPConnectionConfiguration.builder().setUsernameAndPassword(username, password).setServiceName(\n                                        serviceName).build());\n    }\n\n    @Override\n    protected void throwNotConnectedExceptionIfAppropriate() throws NotConnectedException {\n        if (packetWriter == null) {\n            throw new NotConnectedException();\n        }\n        packetWriter.throwNotConnectedExceptionIfDoneAndResumptionNotPossible();\n    }\n\n    @Override\n    protected void throwAlreadyConnectedExceptionIfAppropriate() throws AlreadyConnectedException {\n        if (isConnected() && !disconnectedButResumeable) {\n            throw new AlreadyConnectedException();\n        }\n    }\n\n    @Override\n    protected void throwAlreadyLoggedInExceptionIfAppropriate() throws AlreadyLoggedInException {\n        if (isAuthenticated() && !disconnectedButResumeable) {\n            throw new AlreadyLoggedInException();\n        }\n    }\n\n    @Override\n    protected void afterSuccessfulLogin(final boolean resumed) throws NotConnectedException {\n        // Reset the flag in case it was set\n        disconnectedButResumeable = false;\n        super.afterSuccessfulLogin(resumed);\n    }\n\n    @Override\n    protected synchronized void loginNonAnonymously(String username, String password, String resource) throws XMPPException, SmackException, IOException {\n        if (saslAuthentication.hasNonAnonymousAuthentication()) {\n            // Authenticate using SASL\n            if (password != null) {\n                saslAuthentication.authenticate(username, password, resource);\n            }\n            else {\n                saslAuthentication.authenticate(resource, config.getCallbackHandler());\n            }\n        } else {\n            throw new SmackException(\"No non-anonymous SASL authentication mechanism available\");\n        }\n\n        // If compression is enabled then request the server to use stream compression. XEP-170\n        // recommends to perform stream compression before resource binding.\n        if (config.isCompressionEnabled()) {\n            useCompression();\n        }\n\n        if (isSmResumptionPossible()) {\n            smResumedSyncPoint.sendAndWaitForResponse(new Resume(clientHandledStanzasCount, smSessionId));\n            if (smResumedSyncPoint.wasSuccessful()) {\n                // We successfully resumed the stream, be done here\n                afterSuccessfulLogin(true);\n                return;\n            }\n            // SM resumption failed, what Smack does here is to report success of\n            // lastFeaturesReceived in case of sm resumption was answered with 'failed' so that\n            // normal resource binding can be tried.\n            LOGGER.fine(\"Stream resumption failed, continuing with normal stream establishment process\");\n        }\n\n        List<Stanza> previouslyUnackedStanzas = new LinkedList<Stanza>();\n        if (unacknowledgedStanzas != null) {\n            // There was a previous connection with SM enabled but that was either not resumable or\n            // failed to resume. Make sure that we (re-)send the unacknowledged stanzas.\n            unacknowledgedStanzas.drainTo(previouslyUnackedStanzas);\n            // Reset unacknowledged stanzas to 'null' to signal that we never send 'enable' in this\n            // XMPP session (There maybe was an enabled in a previous XMPP session of this\n            // connection instance though). This is used in writePackets to decide if stanzas should\n            // be added to the unacknowledged stanzas queue, because they have to be added right\n            // after the 'enable' stream element has been sent.\n            dropSmState();\n        }\n\n        // Now bind the resource. It is important to do this *after* we dropped an eventually\n        // existing Stream Management state. As otherwise <bind/> and <session/> may end up in\n        // unacknowledgedStanzas and become duplicated on reconnect. See SMACK-706.\n        bindResourceAndEstablishSession(resource);\n\n        if (isSmAvailable() && useSm) {\n            // Remove what is maybe left from previously stream managed sessions\n            serverHandledStanzasCount = 0;\n            // XEP-198 3. Enabling Stream Management. If the server response to 'Enable' is 'Failed'\n            // then this is a non recoverable error and we therefore throw an exception.\n            smEnabledSyncPoint.sendAndWaitForResponseOrThrow(new Enable(useSmResumption, smClientMaxResumptionTime));\n            synchronized (requestAckPredicates) {\n                if (requestAckPredicates.isEmpty()) {\n                    // Assure that we have at lest one predicate set up that so that we request acks\n                    // for the server and eventually flush some stanzas from the unacknowledged\n                    // stanza queue\n                    requestAckPredicates.add(Predicate.forMessagesOrAfter5Stanzas());\n                }\n            }\n        }\n        // (Re-)send the stanzas *after* we tried to enable SM\n        for (Stanza stanza : previouslyUnackedStanzas) {\n            sendStanzaInternal(stanza);\n        }\n\n        afterSuccessfulLogin(false);\n    }\n\n    @Override\n    public synchronized void loginAnonymously() throws XMPPException, SmackException, IOException {\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        if (saslAuthentication.hasAnonymousAuthentication()) {\n            saslAuthentication.authenticateAnonymously();\n        }\n        else {\n            throw new SmackException(\"No anonymous SASL authentication mechanism available\");\n        }\n\n        // If compression is enabled then request the server to use stream compression\n        if (config.isCompressionEnabled()) {\n            useCompression();\n        }\n\n        bindResourceAndEstablishSession(null);\n\n        afterSuccessfulLogin(false);\n    }\n\n    @Override\n    public boolean isSecureConnection() {\n        return usingTLS;\n    }\n\n    public boolean isSocketClosed() {\n        return socketClosed;\n    }\n\n    /**\n     * Shuts the current connection down. After this method returns, the connection must be ready\n     * for re-use by connect.\n     */\n    @Override\n    protected void shutdown() {\n        if (isSmEnabled()) {\n            try {\n                // Try to send a last SM Acknowledgement. Most servers won't find this information helpful, as the SM\n                // state is dropped after a clean disconnect anyways. OTOH it doesn't hurt much either.\n                sendSmAcknowledgementInternal();\n            } catch (NotConnectedException e) {\n                LOGGER.log(Level.FINE, \"Can not send final SM ack as connection is not connected\", e);\n            }\n        }\n        shutdown(false);\n    }\n\n    /**\n     * Performs an unclean disconnect and shutdown of the connection. Does not send a closing stream stanza.\n     */\n    public synchronized void instantShutdown() {\n        shutdown(true);\n    }\n\n    private void shutdown(boolean instant) {\n        if (disconnectedButResumeable) {\n            return;\n        }\n        if (packetReader != null) {\n                packetReader.shutdown();\n        }\n        if (packetWriter != null) {\n                packetWriter.shutdown(instant);\n        }\n\n        // Set socketClosed to true. This will cause the PacketReader\n        // and PacketWriter to ignore any Exceptions that are thrown\n        // because of a read/write from/to a closed stream.\n        // It is *important* that this is done before socket.close()!\n        socketClosed = true;\n        try {\n                socket.close();\n        } catch (Exception e) {\n                LOGGER.log(Level.WARNING, \"shutdown\", e);\n        }\n\n        setWasAuthenticated();\n        // If we are able to resume the stream, then don't set\n        // connected/authenticated/usingTLS to false since we like behave like we are still\n        // connected (e.g. sendStanza should not throw a NotConnectedException).\n        if (isSmResumptionPossible() && instant) {\n            disconnectedButResumeable = true;\n        } else {\n            disconnectedButResumeable = false;\n            // Reset the stream management session id to null, since if the stream is cleanly closed, i.e. sending a closing\n            // stream tag, there is no longer a stream to resume.\n            smSessionId = null;\n        }\n        authenticated = false;\n        connected = false;\n        usingTLS = false;\n        reader = null;\n        writer = null;\n\n        maybeCompressFeaturesReceived.init();\n        compressSyncPoint.init();\n        smResumedSyncPoint.init();\n        smEnabledSyncPoint.init();\n        initalOpenStreamSend.init();\n    }\n\n    @Override\n    public void send(PlainStreamElement element) throws NotConnectedException {\n        packetWriter.sendStreamElement(element);\n    }\n\n    @Override\n    protected void sendStanzaInternal(Stanza packet) throws NotConnectedException {\n        packetWriter.sendStreamElement(packet);\n        if (isSmEnabled()) {\n            for (StanzaFilter requestAckPredicate : requestAckPredicates) {\n                if (requestAckPredicate.accept(packet)) {\n                    requestSmAcknowledgementInternal();\n                    break;\n                }\n            }\n        }\n    }\n\n    private void connectUsingConfiguration() throws IOException, ConnectionException {\n        List<HostAddress> failedAddresses = populateHostAddresses();\n        SocketFactory socketFactory = config.getSocketFactory();\n        if (socketFactory == null) {\n            socketFactory = SocketFactory.getDefault();\n        }\n        for (HostAddress hostAddress : hostAddresses) {\n            String host = hostAddress.getFQDN();\n            int port = hostAddress.getPort();\n            socket = socketFactory.createSocket();\n            try {\n                Iterator<InetAddress> inetAddresses = Arrays.asList(InetAddress.getAllByName(host)).iterator();\n                if (!inetAddresses.hasNext()) {\n                    // This should not happen\n                    LOGGER.warning(\"InetAddress.getAllByName() returned empty result array.\");\n                    throw new UnknownHostException(host);\n                }\n                innerloop: while (inetAddresses.hasNext()) {\n                    // Create a *new* Socket before every connection attempt, i.e. connect() call, since Sockets are not\n                    // re-usable after a failed connection attempt. See also SMACK-724.\n                    socket = socketFactory.createSocket();\n\n                    final InetAddress inetAddress = inetAddresses.next();\n                    final String inetAddressAndPort = inetAddress + \" at port \" + port;\n                    LOGGER.finer(\"Trying to establish TCP connection to \" + inetAddressAndPort);\n                    try {\n                        socket.connect(new InetSocketAddress(inetAddress, port), config.getConnectTimeout());\n                    } catch (Exception e) {\n                        if (inetAddresses.hasNext()) {\n                            continue innerloop;\n                        } else {\n                            throw e;\n                        }\n                    }\n                    LOGGER.finer(\"Established TCP connection to \" + inetAddressAndPort);\n                    // We found a host to connect to, return here\n                    this.host = host;\n                    this.port = port;\n                    return;\n                }\n            }\n            catch (Exception e) {\n                hostAddress.setException(e);\n                failedAddresses.add(hostAddress);\n            }\n        }\n        // There are no more host addresses to try\n        // throw an exception and report all tried\n        // HostAddresses in the exception\n        throw ConnectionException.from(failedAddresses);\n    }\n\n    /**\n     * Initializes the connection by creating a stanza(/packet) reader and writer and opening a\n     * XMPP stream to the server.\n     *\n     * @throws XMPPException if establishing a connection to the server fails.\n     * @throws SmackException if the server failes to respond back or if there is anther error.\n     * @throws IOException \n     */\n    private void initConnection() throws IOException {\n        boolean isFirstInitialization = packetReader == null || packetWriter == null;\n        compressionHandler = null;\n\n        // Set the reader and writer instance variables\n        initReaderAndWriter();\n\n        if (isFirstInitialization) {\n            packetWriter = new PacketWriter();\n            packetReader = new PacketReader();\n\n            // If debugging is enabled, we should start the thread that will listen for\n            // all packets and then log them.\n            if (config.isDebuggerEnabled()) {\n                addAsyncStanzaListener(debugger.getReaderListener(), null);\n                if (debugger.getWriterListener() != null) {\n                    addPacketSendingListener(debugger.getWriterListener(), null);\n                }\n            }\n        }\n        // Start the packet writer. This will open an XMPP stream to the server\n        packetWriter.init();\n        // Start the packet reader. The startup() method will block until we\n        // get an opening stream packet back from server\n        packetReader.init();\n\n        if (isFirstInitialization) {\n            // Notify listeners that a new connection has been established\n            for (ConnectionCreationListener listener : getConnectionCreationListeners()) {\n                listener.connectionCreated(this);\n            }\n        }\n    }\n\n    private void initReaderAndWriter() throws IOException {\n        InputStream is = socket.getInputStream();\n        OutputStream os = socket.getOutputStream();\n        if (compressionHandler != null) {\n            is = compressionHandler.getInputStream(is);\n            os = compressionHandler.getOutputStream(os);\n        }\n        // OutputStreamWriter is already buffered, no need to wrap it into a BufferedWriter\n        writer = new OutputStreamWriter(os, \"UTF-8\");\n        reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n\n        // If debugging is enabled, we open a window and write out all network traffic.\n        initDebugger();\n    }\n\n    /**\n     * The server has indicated that TLS negotiation can start. We now need to secure the\n     * existing plain connection and perform a handshake. This method won't return until the\n     * connection has finished the handshake or an error occurred while securing the connection.\n     * @throws IOException \n     * @throws CertificateException \n     * @throws NoSuchAlgorithmException \n     * @throws NoSuchProviderException \n     * @throws KeyStoreException \n     * @throws UnrecoverableKeyException \n     * @throws KeyManagementException \n     * @throws SmackException \n     * @throws Exception if an exception occurs.\n     */\n    private void proceedTLSReceived() throws NoSuchAlgorithmException, CertificateException, IOException, KeyStoreException, NoSuchProviderException, UnrecoverableKeyException, KeyManagementException, SmackException {\n        SSLContext context = this.config.getCustomSSLContext();\n        KeyStore ks = null;\n        KeyManager[] kms = null;\n        PasswordCallback pcb = null;\n\n        if(config.getCallbackHandler() == null) {\n           ks = null;\n        } else if (context == null) {\n            if(config.getKeystoreType().equals(\"NONE\")) {\n                ks = null;\n                pcb = null;\n            }\n            else if(config.getKeystoreType().equals(\"PKCS11\")) {\n                try {\n                    Constructor<?> c = Class.forName(\"sun.security.pkcs11.SunPKCS11\").getConstructor(InputStream.class);\n                    String pkcs11Config = \"name = SmartCard\\nlibrary = \"+config.getPKCS11Library();\n                    ByteArrayInputStream config = new ByteArrayInputStream(pkcs11Config.getBytes());\n                    Provider p = (Provider)c.newInstance(config);\n                    Security.addProvider(p);\n                    ks = KeyStore.getInstance(\"PKCS11\",p);\n                    pcb = new PasswordCallback(\"PKCS11 Password: \",false);\n                    this.config.getCallbackHandler().handle(new Callback[]{pcb});\n                    ks.load(null,pcb.getPassword());\n                }\n                catch (Exception e) {\n                    ks = null;\n                    pcb = null;\n                }\n            }\n            else if(config.getKeystoreType().equals(\"Apple\")) {\n                ks = KeyStore.getInstance(\"KeychainStore\",\"Apple\");\n                ks.load(null,null);\n                //pcb = new PasswordCallback(\"Apple Keychain\",false);\n                //pcb.setPassword(null);\n            }\n            else {\n                ks = KeyStore.getInstance(config.getKeystoreType());\n                try {\n                    pcb = new PasswordCallback(\"Keystore Password: \",false);\n                    config.getCallbackHandler().handle(new Callback[]{pcb});\n                    ks.load(new FileInputStream(config.getKeystorePath()), pcb.getPassword());\n                }\n                catch(Exception e) {\n                    ks = null;\n                    pcb = null;\n                }\n            }\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n            try {\n                if(pcb == null) {\n                    kmf.init(ks,null);\n                } else {\n                    kmf.init(ks,pcb.getPassword());\n                    pcb.clearPassword();\n                }\n                kms = kmf.getKeyManagers();\n            } catch (NullPointerException npe) {\n                kms = null;\n            }\n        }\n\n        // If the user didn't specify a SSLContext, use the default one\n        if (context == null) {\n            context = SSLContext.getInstance(\"TLS\");\n            context.init(kms, null, new java.security.SecureRandom());\n        }\n        Socket plain = socket;\n        // Secure the plain connection\n        socket = context.getSocketFactory().createSocket(plain,\n                host, plain.getPort(), true);\n\n        final SSLSocket sslSocket = (SSLSocket) socket;\n        // Immediately set the enabled SSL protocols and ciphers. See SMACK-712 why this is\n        // important (at least on certain platforms) and it seems to be a good idea anyways to\n        // prevent an accidental implicit handshake.\n        TLSUtils.setEnabledProtocolsAndCiphers(sslSocket, config.getEnabledSSLProtocols(), config.getEnabledSSLCiphers());\n\n        // Initialize the reader and writer with the new secured version\n        initReaderAndWriter();\n\n        // Proceed to do the handshake\n        sslSocket.startHandshake();\n\n        final HostnameVerifier verifier = getConfiguration().getHostnameVerifier();\n        if (verifier == null) {\n                throw new IllegalStateException(\"No HostnameVerifier set. Use connectionConfiguration.setHostnameVerifier() to configure.\");\n        } else if (!verifier.verify(getServiceName(), sslSocket.getSession())) {\n            throw new CertificateException(\"Hostname verification of certificate failed. Certificate does not authenticate \" + getServiceName());\n        }\n\n        // Set that TLS was successful\n        usingTLS = true;\n    }\n\n    /**\n     * Returns the compression handler that can be used for one compression methods offered by the server.\n     * \n     * @return a instance of XMPPInputOutputStream or null if no suitable instance was found\n     * \n     */\n    private XMPPInputOutputStream maybeGetCompressionHandler() {\n        Compress.Feature compression = getFeature(Compress.Feature.ELEMENT, Compress.NAMESPACE);\n        if (compression == null) {\n            // Server does not support compression\n            return null;\n        }\n        for (XMPPInputOutputStream handler : SmackConfiguration.getCompresionHandlers()) {\n                String method = handler.getCompressionMethod();\n                if (compression.getMethods().contains(method))\n                    return handler;\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isUsingCompression() {\n        return compressionHandler != null && compressSyncPoint.wasSuccessful();\n    }\n\n    /**\n     * <p>\n     * Starts using stream compression that will compress network traffic. Traffic can be\n     * reduced up to 90%. Therefore, stream compression is ideal when using a slow speed network\n     * connection. However, the server and the client will need to use more CPU time in order to\n     * un/compress network data so under high load the server performance might be affected.\n     * </p>\n     * <p>\n     * Stream compression has to have been previously offered by the server. Currently only the\n     * zlib method is supported by the client. Stream compression negotiation has to be done\n     * before authentication took place.\n     * </p>\n     *\n     * @throws NotConnectedException \n     * @throws XMPPException \n     * @throws NoResponseException \n     */\n    private void useCompression() throws NotConnectedException, NoResponseException, XMPPException {\n        maybeCompressFeaturesReceived.checkIfSuccessOrWait();\n        // If stream compression was offered by the server and we want to use\n        // compression then send compression request to the server\n        if ((compressionHandler = maybeGetCompressionHandler()) != null) {\n            compressSyncPoint.sendAndWaitForResponseOrThrow(new Compress(compressionHandler.getCompressionMethod()));\n        } else {\n            LOGGER.warning(\"Could not enable compression because no matching handler/method pair was found\");\n        }\n    }\n\n    /**\n     * Establishes a connection to the XMPP server and performs an automatic login\n     * only if the previous connection state was logged (authenticated). It basically\n     * creates and maintains a socket connection to the server.<p>\n     * <p/>\n     * Listeners will be preserved from a previous connection if the reconnection\n     * occurs after an abrupt termination.\n     *\n     * @throws XMPPException if an error occurs while trying to establish the connection.\n     * @throws SmackException \n     * @throws IOException \n     */\n    @Override\n    protected void connectInternal() throws SmackException, IOException, XMPPException {\n        // Establishes the TCP connection to the server and does setup the reader and writer. Throws an exception if\n        // there is an error establishing the connection\n        connectUsingConfiguration();\n\n        // We connected successfully to the servers TCP port\n        socketClosed = false;\n        initConnection();\n\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        // Make note of the fact that we're now connected.\n        connected = true;\n        callConnectionConnectedListener();\n\n        // Automatically makes the login if the user was previously connected successfully\n        // to the server and the connection was terminated abruptly\n        if (wasAuthenticated) {\n            login();\n            notifyReconnection();\n        }\n    }\n\n    /**\n     * Sends out a notification that there was an error with the connection\n     * and closes the connection. Also prints the stack trace of the given exception\n     *\n     * @param e the exception that causes the connection close event.\n     */\n    private synchronized void notifyConnectionError(Exception e) {\n        // Listeners were already notified of the exception, return right here.\n        if ((packetReader == null || packetReader.done) &&\n                (packetWriter == null || packetWriter.done())) return;\n\n        // Closes the connection temporary. A reconnection is possible\n        instantShutdown();\n\n        // Notify connection listeners of the error.\n        callConnectionClosedOnErrorListener(e);\n    }\n\n    /**\n     * For unit testing purposes\n     *\n     * @param writer\n     */\n    protected void setWriter(Writer writer) {\n        this.writer = writer;\n    }\n\n    @Override\n    protected void afterFeaturesReceived() throws SecurityRequiredException, NotConnectedException {\n        StartTls startTlsFeature = getFeature(StartTls.ELEMENT, StartTls.NAMESPACE);\n        if (startTlsFeature != null) {\n            if (startTlsFeature.required() && config.getSecurityMode() == SecurityMode.disabled) {\n                notifyConnectionError(new SecurityRequiredByServerException());\n                return;\n            }\n\n            if (config.getSecurityMode() != ConnectionConfiguration.SecurityMode.disabled) {\n                send(new StartTls());\n            }\n        }\n        // If TLS is required but the server doesn't offer it, disconnect\n        // from the server and throw an error. First check if we've already negotiated TLS\n        // and are secure, however (features get parsed a second time after TLS is established).\n        if (!isSecureConnection() && startTlsFeature == null\n                        && getConfiguration().getSecurityMode() == SecurityMode.required) {\n            throw new SecurityRequiredByClientException();\n        }\n\n        if (getSASLAuthentication().authenticationSuccessful()) {\n            // If we have received features after the SASL has been successfully completed, then we\n            // have also *maybe* received, as it is an optional feature, the compression feature\n            // from the server.\n            maybeCompressFeaturesReceived.reportSuccess();\n        }\n    }\n\n    /**\n     * Resets the parser using the latest connection's reader. Reseting the parser is necessary\n     * when the plain connection has been secured or when a new opening stream element is going\n     * to be sent by the server.\n     *\n     * @throws SmackException if the parser could not be reset.\n     */\n    void openStream() throws SmackException {\n        // If possible, provide the receiving entity of the stream open tag, i.e. the server, as much information as\n        // possible. The 'to' attribute is *always* available. The 'from' attribute if set by the user and no external\n        // mechanism is used to determine the local entity (user). And the 'id' attribute is available after the first\n        // response from the server (see e.g. RFC 6120 \u00a7 9.1.1 Step 2.)\n        CharSequence to = getServiceName();\n        CharSequence from = null;\n        CharSequence localpart = config.getUsername();\n        if (localpart != null) {\n            from = XmppStringUtils.completeJidFrom(localpart, to);\n        }\n        String id = getStreamId();\n        send(new StreamOpen(to, from, id));\n        try {\n            packetReader.parser = PacketParserUtils.newXmppParser(reader);\n        }\n        catch (XmlPullParserException e) {\n            throw new SmackException(e);\n        }\n    }\n\n    protected class PacketReader {\n\n        XmlPullParser parser;\n\n        private volatile boolean done;\n\n        /**\n         * Initializes the reader in order to be used. The reader is initialized during the\n         * first connection and when reconnecting due to an abruptly disconnection.\n         */\n        void init() {\n            done = false;\n\n            Async.go(new Runnable() {\n                public void run() {\n                    parsePackets();\n                }\n            }, \"Smack Packet Reader (\" + getConnectionCounter() + \")\");\n         }\n\n        /**\n         * Shuts the stanza(/packet) reader down. This method simply sets the 'done' flag to true.\n         */\n        void shutdown() {\n            done = true;\n        }\n\n        /**\n         * Parse top-level packets in order to process them further.\n         *\n         * @param thread the thread that is being used by the reader to parse incoming packets.\n         */\n        private void parsePackets() {\n            try {\n                initalOpenStreamSend.checkIfSuccessOrWait();\n                int eventType = parser.getEventType();\n                while (!done) {\n                    switch (eventType) {\n                    case XmlPullParser.START_TAG:\n                        final String name = parser.getName();\n                        switch (name) {\n                        case Message.ELEMENT:\n                        case IQ.IQ_ELEMENT:\n                        case Presence.ELEMENT:\n                            try {\n                                parseAndProcessStanza(parser);\n                            } finally {\n                                clientHandledStanzasCount = SMUtils.incrementHeight(clientHandledStanzasCount);\n                            }\n                            break;\n                        case \"stream\":\n                            // We found an opening stream.\n                            if (\"jabber:client\".equals(parser.getNamespace(null))) {\n                                streamId = parser.getAttributeValue(\"\", \"id\");\n                                String reportedServiceName = parser.getAttributeValue(\"\", \"from\");\n                                assert(reportedServiceName.equals(config.getServiceName()));\n                            }\n                            break;\n                        case \"error\":\n                            throw new StreamErrorException(PacketParserUtils.parseStreamError(parser));\n                        case \"features\":\n                            parseFeatures(parser);\n                            break;\n                        case \"proceed\":\n                            try {\n                                // Secure the connection by negotiating TLS\n                                proceedTLSReceived();\n                                // Send a new opening stream to the server\n                                openStream();\n                            }\n                            catch (Exception e) {\n                                // We report any failure regarding TLS in the second stage of XMPP\n                                // connection establishment, namely the SASL authentication\n                                saslFeatureReceived.reportFailure(new SmackException(e));\n                                throw e;\n                            }\n                            break;\n                        case \"failure\":\n                            String namespace = parser.getNamespace(null);\n                            switch (namespace) {\n                            case \"urn:ietf:params:xml:ns:xmpp-tls\":\n                                // TLS negotiation has failed. The server will close the connection\n                                // TODO Parse failure stanza\n                                throw new XMPPErrorException(\"TLS negotiation has failed\", null);\n                            case \"http://jabber.org/protocol/compress\":\n                                // Stream compression has been denied. This is a recoverable\n                                // situation. It is still possible to authenticate and\n                                // use the connection but using an uncompressed connection\n                                // TODO Parse failure stanza\n                                compressSyncPoint.reportFailure(new XMPPErrorException(\n                                                \"Could not establish compression\", null));\n                                break;\n                            case SaslStreamElements.NAMESPACE:\n                                // SASL authentication has failed. The server may close the connection\n                                // depending on the number of retries\n                                final SASLFailure failure = PacketParserUtils.parseSASLFailure(parser);\n                                getSASLAuthentication().authenticationFailed(failure);\n                                break;\n                            }\n                            break;\n                        case Challenge.ELEMENT:\n                            // The server is challenging the SASL authentication made by the client\n                            String challengeData = parser.nextText();\n                            getSASLAuthentication().challengeReceived(challengeData);\n                            break;\n                        case Success.ELEMENT:\n                            Success success = new Success(parser.nextText());\n                            // We now need to bind a resource for the connection\n                            // Open a new stream and wait for the response\n                            openStream();\n                            // The SASL authentication with the server was successful. The next step\n                            // will be to bind the resource\n                            getSASLAuthentication().authenticated(success);\n                            break;\n                        case Compressed.ELEMENT:\n                            // Server confirmed that it's possible to use stream compression. Start\n                            // stream compression\n                            // Initialize the reader and writer with the new compressed version\n                            initReaderAndWriter();\n                            // Send a new opening stream to the server\n                            openStream();\n                            // Notify that compression is being used\n                            compressSyncPoint.reportSuccess();\n                            break;\n                        case Enabled.ELEMENT:\n                            Enabled enabled = ParseStreamManagement.enabled(parser);\n                            if (enabled.isResumeSet()) {\n                                smSessionId = enabled.getId();\n                                if (StringUtils.isNullOrEmpty(smSessionId)) {\n                                    XMPPErrorException xmppException = new XMPPErrorException(\n                                                    \"Stream Management 'enabled' element with resume attribute but without session id received\",\n                                                    new XMPPError(\n                                                                    XMPPError.Condition.bad_request));\n                                    smEnabledSyncPoint.reportFailure(xmppException);\n                                    throw xmppException;\n                                }\n                                smServerMaxResumptimTime = enabled.getMaxResumptionTime();\n                            } else {\n                                // Mark this a non-resumable stream by setting smSessionId to null\n                                smSessionId = null;\n                            }\n                            clientHandledStanzasCount = 0;\n                            smWasEnabledAtLeastOnce = true;\n                            smEnabledSyncPoint.reportSuccess();\n                            LOGGER.fine(\"Stream Management (XEP-198): succesfully enabled\");\n                            break;\n                        case Failed.ELEMENT:\n                            Failed failed = ParseStreamManagement.failed(parser);\n                            XMPPError xmppError = new XMPPError(failed.getXMPPErrorCondition());\n                            XMPPException xmppException = new XMPPErrorException(\"Stream Management failed\", xmppError);\n                            // If only XEP-198 would specify different failure elements for the SM\n                            // enable and SM resume failure case. But this is not the case, so we\n                            // need to determine if this is a 'Failed' response for either 'Enable'\n                            // or 'Resume'.\n                            if (smResumedSyncPoint.requestSent()) {\n                                smResumedSyncPoint.reportFailure(xmppException);\n                            }\n                            else {\n                                if (!smEnabledSyncPoint.requestSent()) {\n                                    throw new IllegalStateException(\"Failed element received but SM was not previously enabled\");\n                                }\n                                smEnabledSyncPoint.reportFailure(xmppException);\n                                // Report success for last lastFeaturesReceived so that in case a\n                                // failed resumption, we can continue with normal resource binding.\n                                // See text of XEP-198 5. below Example 11.\n                                lastFeaturesReceived.reportSuccess();\n                            }\n                            break;\n                        case Resumed.ELEMENT:\n                            Resumed resumed = ParseStreamManagement.resumed(parser);\n                            if (!smSessionId.equals(resumed.getPrevId())) {\n                                throw new StreamIdDoesNotMatchException(smSessionId, resumed.getPrevId());\n                            }\n                            // Mark SM as enabled and resumption as successful.\n                            smResumedSyncPoint.reportSuccess();\n                            smEnabledSyncPoint.reportSuccess();\n                            // First, drop the stanzas already handled by the server\n                            processHandledCount(resumed.getHandledCount());\n                            // Then re-send what is left in the unacknowledged queue\n                            List<Stanza> stanzasToResend = new ArrayList<>(unacknowledgedStanzas.size());\n                            unacknowledgedStanzas.drainTo(stanzasToResend);\n                            for (Stanza stanza : stanzasToResend) {\n                                sendStanzaInternal(stanza);\n                            }\n                            // If there where stanzas resent, then request a SM ack for them.\n                            // Writer's sendStreamElement() won't do it automatically based on\n                            // predicates.\n                            if (!stanzasToResend.isEmpty()) {\n                                requestSmAcknowledgementInternal();\n                            }\n                            LOGGER.fine(\"Stream Management (XEP-198): Stream resumed\");\n                            break;\n                        case AckAnswer.ELEMENT:\n                            AckAnswer ackAnswer = ParseStreamManagement.ackAnswer(parser);\n                            processHandledCount(ackAnswer.getHandledCount());\n                            break;\n                        case AckRequest.ELEMENT:\n                            ParseStreamManagement.ackRequest(parser);\n                            if (smEnabledSyncPoint.wasSuccessful()) {\n                                sendSmAcknowledgementInternal();\n                            } else {\n                                LOGGER.warning(\"SM Ack Request received while SM is not enabled\");\n                            }\n                            break;\n                         default:\n                             LOGGER.warning(\"Unknown top level stream element: \" + name);\n                             break;\n                        }\n                        break;\n                    case XmlPullParser.END_TAG:\n                        if (parser.getName().equals(\"stream\")) {\n                            // Disconnect the connection\n                            disconnect();\n                        }\n                        break;\n                    case XmlPullParser.END_DOCUMENT:\n                        // END_DOCUMENT only happens in an error case, as otherwise we would see a\n                        // closing stream element before.\n                        throw new SmackException(\n                                        \"Parser got END_DOCUMENT event. This could happen e.g. if the server closed the connection without sending a closing stream element\");\n                    }\n                    eventType = parser.next();\n                }\n            }\n            catch (Exception e) {\n                // The exception can be ignored if the the connection is 'done'\n                // or if the it was caused because the socket got closed\n                if (!(done || isSocketClosed())) {\n                    // Close the connection and notify connection listeners of the\n                    // error.\n                    notifyConnectionError(e);\n                }\n            }\n        }\n    }\n\n    protected class PacketWriter {\n        public static final int QUEUE_SIZE = XMPPTCPConnection.QUEUE_SIZE;\n\n        private final ArrayBlockingQueueWithShutdown<Element> queue = new ArrayBlockingQueueWithShutdown<Element>(\n                        QUEUE_SIZE, true);\n\n        /**\n         * Needs to be protected for unit testing purposes.\n         */\n        protected SynchronizationPoint<NoResponseException> shutdownDone = new SynchronizationPoint<NoResponseException>(\n                        XMPPTCPConnection.this);\n\n        /**\n         * If set, the stanza(/packet) writer is shut down\n         */\n        protected volatile Long shutdownTimestamp = null;\n\n        private volatile boolean instantShutdown;\n\n        /**\n         * True if some preconditions are given to start the bundle and defer mechanism.\n         * <p>\n         * This will likely get set to true right after the start of the writer thread, because\n         * {@link #nextStreamElement()} will check if {@link queue} is empty, which is probably the case, and then set\n         * this field to true.\n         * </p>\n         */\n        private boolean shouldBundleAndDefer;\n\n        /** \n        * Initializes the writer in order to be used. It is called at the first connection and also \n        * is invoked if the connection is disconnected by an error.\n        */ \n        void init() {\n            shutdownDone.init();\n            shutdownTimestamp = null;\n\n            if (unacknowledgedStanzas != null) {\n                // It's possible that there are new stanzas in the writer queue that\n                // came in while we were disconnected but resumable, drain those into\n                // the unacknowledged queue so that they get resent now\n                drainWriterQueueToUnacknowledgedStanzas();\n            }\n\n            queue.start();\n            Async.go(new Runnable() {\n                @Override\n                public void run() {\n                    writePackets();\n                }\n            }, \"Smack Packet Writer (\" + getConnectionCounter() + \")\");\n        }\n\n        private boolean done() {\n            return shutdownTimestamp != null;\n        }\n\n        protected void throwNotConnectedExceptionIfDoneAndResumptionNotPossible() throws NotConnectedException {\n            if (done() && !isSmResumptionPossible()) {\n                // Don't throw a NotConnectedException is there is an resumable stream available\n                throw new NotConnectedException();\n            }\n        }\n\n        /**\n         * Sends the specified element to the server.\n         *\n         * @param element the element to send.\n         * @throws NotConnectedException \n         */\n        protected void sendStreamElement(Element element) throws NotConnectedException {\n            throwNotConnectedExceptionIfDoneAndResumptionNotPossible();\n\n            boolean enqueued = false;\n            while (!enqueued) {\n                try {\n                    queue.put(element);\n                    enqueued = true;\n                }\n                catch (InterruptedException e) {\n                    throwNotConnectedExceptionIfDoneAndResumptionNotPossible();\n                    // If the method above did not throw, then the sending thread was interrupted\n                    // TODO in a later version of Smack the InterruptedException should be thrown to\n                    // allow users to interrupt a sending thread that is currently blocking because\n                    // the queue is full.\n                    LOGGER.log(Level.WARNING, \"Sending thread was interrupted\", e);\n                }\n            }\n        }\n\n        /**\n         * Shuts down the stanza(/packet) writer. Once this method has been called, no further\n         * packets will be written to the server.\n         */\n        void shutdown(boolean instant) {\n            instantShutdown = instant;\n            shutdownTimestamp = System.currentTimeMillis();\n            queue.shutdown();\n            try {\n                shutdownDone.checkIfSuccessOrWait();\n            }\n            catch (NoResponseException e) {\n                LOGGER.log(Level.WARNING, \"shutdownDone was not marked as successful by the writer thread\", e);\n            }\n        }\n\n        /**\n         * Maybe return the next available element from the queue for writing. If the queue is shut down <b>or</b> a\n         * spurious interrupt occurs, <code>null</code> is returned. So it is important to check the 'done' condition in\n         * that case.\n         *\n         * @return the next element for writing or null.\n         */\n        private Element nextStreamElement() {\n            // It is important the we check if the queue is empty before removing an element from it\n            if (queue.isEmpty()) {\n                shouldBundleAndDefer = true;\n            }\n            Element packet = null;\n            try {\n                packet = queue.take();\n            }\n            catch (InterruptedException e) {\n                if (!queue.isShutdown()) {\n                    // Users shouldn't try to interrupt the packet writer thread\n                    LOGGER.log(Level.WARNING, \"Packet writer thread was interrupted. Don't do that. Use disconnect() instead.\", e);\n                }\n            }\n            return packet;\n        }\n\n        private void writePackets() {\n            try {\n                openStream();\n                initalOpenStreamSend.reportSuccess();\n                // Write out packets from the queue.\n                while (!done()) {\n                    Element element = nextStreamElement();\n                    if (element == null) {\n                        continue;\n                    }\n\n                    // Get a local version of the bundle and defer callback, in case it's unset\n                    // between the null check and the method invocation\n                    final BundleAndDeferCallback localBundleAndDeferCallback = bundleAndDeferCallback;\n                    // If the preconditions are given (e.g. bundleAndDefer callback is set, queue is\n                    // empty), then we could wait a bit for further stanzas attempting to decrease\n                    // our energy consumption\n                    if (localBundleAndDeferCallback != null && isAuthenticated() && shouldBundleAndDefer) {\n                        // Reset shouldBundleAndDefer to false, nextStreamElement() will set it to true once the\n                        // queue is empty again.\n                        shouldBundleAndDefer = false;\n                        final AtomicBoolean bundlingAndDeferringStopped = new AtomicBoolean();\n                        final int bundleAndDeferMillis = localBundleAndDeferCallback.getBundleAndDeferMillis(new BundleAndDefer(\n                                        bundlingAndDeferringStopped));\n                        if (bundleAndDeferMillis > 0) {\n                            long remainingWait = bundleAndDeferMillis;\n                            final long waitStart = System.currentTimeMillis();\n                            synchronized (bundlingAndDeferringStopped) {\n                                while (!bundlingAndDeferringStopped.get() && remainingWait > 0) {\n                                    bundlingAndDeferringStopped.wait(remainingWait);\n                                    remainingWait = bundleAndDeferMillis\n                                                    - (System.currentTimeMillis() - waitStart);\n                                }\n                            }\n                        }\n                    }\n\n                    Stanza packet = null;\n                    if (element instanceof Stanza) {\n                        packet = (Stanza) element;\n                    }\n                    else if (element instanceof Enable) {\n                        // The client needs to add messages to the unacknowledged stanzas queue\n                        // right after it sent 'enabled'. Stanza will be added once\n                        // unacknowledgedStanzas is not null.\n                        unacknowledgedStanzas = new ArrayBlockingQueue<>(QUEUE_SIZE);\n                    }\n                    // Check if the stream element should be put to the unacknowledgedStanza\n                    // queue. Note that we can not do the put() in sendStanzaInternal() and the\n                    // packet order is not stable at this point (sendStanzaInternal() can be\n                    // called concurrently).\n                    if (unacknowledgedStanzas != null && packet != null) {\n                        // If the unacknowledgedStanza queue is nearly full, request an new ack\n                        // from the server in order to drain it\n                        if (unacknowledgedStanzas.size() == 0.8 * XMPPTCPConnection.QUEUE_SIZE) {\n                            writer.write(AckRequest.INSTANCE.toXML().toString());\n                            writer.flush();\n                        }\n                        try {\n                            // It is important the we put the stanza in the unacknowledged stanza\n                            // queue before we put it on the wire\n                            unacknowledgedStanzas.put(packet);\n                        }\n                        catch (InterruptedException e) {\n                            throw new IllegalStateException(e);\n                        }\n                    }\n                    writer.write(element.toXML().toString());\n                    if (queue.isEmpty()) {\n                        writer.flush();\n                    }\n                    if (packet != null) {\n                        firePacketSendingListeners(packet);\n                    }\n                }\n                if (!instantShutdown) {\n                    // Flush out the rest of the queue.\n                    try {\n                        while (!queue.isEmpty()) {\n                            Element packet = queue.remove();\n                            writer.write(packet.toXML().toString());\n                        }\n                        writer.flush();\n                    }\n                    catch (Exception e) {\n                        LOGGER.log(Level.WARNING,\n                                        \"Exception flushing queue during shutdown, ignore and continue\",\n                                        e);\n                    }\n\n                    // Close the stream.\n                    try {\n                        writer.write(\"</stream:stream>\");\n                        writer.flush();\n                    }\n                    catch (Exception e) {\n                        LOGGER.log(Level.WARNING, \"Exception writing closing stream element\", e);\n                    }\n                    // Delete the queue contents (hopefully nothing is left).\n                    queue.clear();\n                } else if (instantShutdown && isSmEnabled()) {\n                    // This was an instantShutdown and SM is enabled, drain all remaining stanzas\n                    // into the unacknowledgedStanzas queue\n                    drainWriterQueueToUnacknowledgedStanzas();\n                }\n\n                try {\n                    writer.close();\n                }\n                catch (Exception e) {\n                    // Do nothing\n                }\n\n            }\n            catch (Exception e) {\n                // The exception can be ignored if the the connection is 'done'\n                // or if the it was caused because the socket got closed\n                if (!(done() || isSocketClosed())) {\n                    notifyConnectionError(e);\n                } else {\n                    LOGGER.log(Level.FINE, \"Ignoring Exception in writePackets()\", e);\n                }\n            } finally {\n                LOGGER.fine(\"Reporting shutdownDone success in writer thread\");\n                shutdownDone.reportSuccess();\n            }\n        }\n\n        private void drainWriterQueueToUnacknowledgedStanzas() {\n            List<Element> elements = new ArrayList<Element>(queue.size());\n            queue.drainTo(elements);\n            for (Element element : elements) {\n                if (element instanceof Stanza) {\n                    unacknowledgedStanzas.add((Stanza) element);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set if Stream Management should be used by default for new connections.\n     * \n     * @param useSmDefault true to use Stream Management for new connections.\n     */\n    public static void setUseStreamManagementDefault(boolean useSmDefault) {\n        XMPPTCPConnection.useSmDefault = useSmDefault;\n    }\n\n    /**\n     * Set if Stream Management resumption should be used by default for new connections.\n     * \n     * @param useSmResumptionDefault true to use Stream Management resumption for new connections.\n     * @deprecated use {@link #setUseStreamManagementResumptionDefault(boolean)} instead.\n     */\n    @Deprecated\n    public static void setUseStreamManagementResumptiodDefault(boolean useSmResumptionDefault) {\n        setUseStreamManagementResumptionDefault(useSmResumptionDefault);\n    }\n\n    /**\n     * Set if Stream Management resumption should be used by default for new connections.\n     *\n     * @param useSmResumptionDefault true to use Stream Management resumption for new connections.\n     */\n    public static void setUseStreamManagementResumptionDefault(boolean useSmResumptionDefault) {\n        if (useSmResumptionDefault) {\n            // Also enable SM is resumption is enabled\n            setUseStreamManagementDefault(useSmResumptionDefault);\n        }\n        XMPPTCPConnection.useSmResumptionDefault = useSmResumptionDefault;\n    }\n\n    /**\n     * Set if Stream Management should be used if supported by the server.\n     * \n     * @param useSm true to use Stream Management.\n     */\n    public void setUseStreamManagement(boolean useSm) {\n        this.useSm = useSm;\n    }\n\n    /**\n     * Set if Stream Management resumption should be used if supported by the server.\n     *\n     * @param useSmResumption true to use Stream Management resumption.\n     */\n    public void setUseStreamManagementResumption(boolean useSmResumption) {\n        if (useSmResumption) {\n            // Also enable SM is resumption is enabled\n            setUseStreamManagement(useSmResumption);\n        }\n        this.useSmResumption = useSmResumption;\n    }\n\n    /**\n     * Set the preferred resumption time in seconds.\n     * @param resumptionTime the preferred resumption time in seconds\n     */\n    public void setPreferredResumptionTime(int resumptionTime) {\n        smClientMaxResumptionTime = resumptionTime;\n    }\n\n    /**\n     * Add a predicate for Stream Management acknowledgment requests.\n     * <p>\n     * Those predicates are used to determine when a Stream Management acknowledgement request is send to the server.\n     * Some pre-defined predicates are found in the <code>org.jivesoftware.smack.sm.predicates</code> package.\n     * </p>\n     * <p>\n     * If not predicate is configured, the {@link Predicate#forMessagesOrAfter5Stanzas()} will be used.\n     * </p>\n     * \n     * @param predicate the predicate to add.\n     * @return if the predicate was not already active.\n     */\n    public boolean addRequestAckPredicate(StanzaFilter predicate) {\n        synchronized (requestAckPredicates) {\n            return requestAckPredicates.add(predicate);\n        }\n    }\n\n    /**\n     * Remove the given predicate for Stream Management acknowledgment request.\n     * @param predicate the predicate to remove.\n     * @return true if the predicate was removed.\n     */\n    public boolean removeRequestAckPredicate(StanzaFilter predicate) {\n        synchronized (requestAckPredicates) {\n            return requestAckPredicates.remove(predicate);\n        }\n    }\n\n    /**\n     * Remove all predicates for Stream Management acknowledgment requests.\n     */\n    public void removeAllRequestAckPredicates() {\n        synchronized (requestAckPredicates) {\n            requestAckPredicates.clear();\n        }\n    }\n\n    /**\n     * Send an unconditional Stream Management acknowledgement request to the server.\n     *\n     * @throws StreamManagementNotEnabledException if Stream Mangement is not enabled.\n     * @throws NotConnectedException if the connection is not connected.\n     */\n    public void requestSmAcknowledgement() throws StreamManagementNotEnabledException, NotConnectedException {\n        if (!isSmEnabled()) {\n            throw new StreamManagementException.StreamManagementNotEnabledException();\n        }\n        requestSmAcknowledgementInternal();\n    }\n\n    private void requestSmAcknowledgementInternal() throws NotConnectedException {\n        packetWriter.sendStreamElement(AckRequest.INSTANCE);\n    }\n\n    /**\n     * Send a unconditional Stream Management acknowledgment to the server.\n     * <p>\n     * See <a href=\"http://xmpp.org/extensions/xep-0198.html#acking\">XEP-198: Stream Management \u00a7 4. Acks</a>:\n     * \"Either party MAY send an <a/> element at any time (e.g., after it has received a certain number of stanzas,\n     * or after a certain period of time), even if it has not received an <r/> element from the other party.\"\n     * </p>\n     * \n     * @throws StreamManagementNotEnabledException if Stream Management is not enabled.\n     * @throws NotConnectedException if the connection is not connected.\n     */\n    public void sendSmAcknowledgement() throws StreamManagementNotEnabledException, NotConnectedException {\n        if (!isSmEnabled()) {\n            throw new StreamManagementException.StreamManagementNotEnabledException();\n        }\n        sendSmAcknowledgementInternal();\n    }\n\n    private void sendSmAcknowledgementInternal() throws NotConnectedException {\n        packetWriter.sendStreamElement(new AckAnswer(clientHandledStanzasCount));\n    }\n\n    /**\n     * Add a Stanza acknowledged listener.\n     * <p>\n     * Those listeners will be invoked every time a Stanza has been acknowledged by the server. The will not get\n     * automatically removed. Consider using {@link #addStanzaIdAcknowledgedListener(String, StanzaListener)} when\n     * possible.\n     * </p>\n     * \n     * @param listener the listener to add.\n     */\n    public void addStanzaAcknowledgedListener(StanzaListener listener) {\n        stanzaAcknowledgedListeners.add(listener);\n    }\n\n    /**\n     * Remove the given Stanza acknowledged listener.\n     *\n     * @param listener the listener.\n     * @return true if the listener was removed.\n     */\n    public boolean removeStanzaAcknowledgedListener(StanzaListener listener) {\n        return stanzaAcknowledgedListeners.remove(listener);\n    }\n\n    /**\n     * Remove all stanza acknowledged listeners.\n     */\n    public void removeAllStanzaAcknowledgedListeners() {\n        stanzaAcknowledgedListeners.clear();\n    }\n\n    /**\n     * Add a new Stanza ID acknowledged listener for the given ID.\n     * <p>\n     * The listener will be invoked if the stanza with the given ID was acknowledged by the server. It will\n     * automatically be removed after the listener was run.\n     * </p>\n     * \n     * @param id the stanza ID.\n     * @param listener the listener to invoke.\n     * @return the previous listener for this stanza ID or null.\n     * @throws StreamManagementNotEnabledException if Stream Management is not enabled.\n     */\n    public StanzaListener addStanzaIdAcknowledgedListener(final String id, StanzaListener listener) throws StreamManagementNotEnabledException {\n        // Prevent users from adding callbacks that will never get removed\n        if (!smWasEnabledAtLeastOnce) {\n            throw new StreamManagementException.StreamManagementNotEnabledException();\n        }\n        // Remove the listener after max. 12 hours\n        final int removeAfterSeconds = Math.min(getMaxSmResumptionTime(), 12 * 60 * 60);\n        schedule(new Runnable() {\n            @Override\n            public void run() {\n                stanzaIdAcknowledgedListeners.remove(id);\n            }\n        }, removeAfterSeconds, TimeUnit.SECONDS);\n        return stanzaIdAcknowledgedListeners.put(id, listener);\n    }\n\n    /**\n     * Remove the Stanza ID acknowledged listener for the given ID.\n     * \n     * @param id the stanza ID.\n     * @return true if the listener was found and removed, false otherwise.\n     */\n    public StanzaListener removeStanzaIdAcknowledgedListener(String id) {\n        return stanzaIdAcknowledgedListeners.remove(id);\n    }\n\n    /**\n     * Removes all Stanza ID acknowledged listeners.\n     */\n    public void removeAllStanzaIdAcknowledgedListeners() {\n        stanzaIdAcknowledgedListeners.clear();\n    }\n\n    /**\n     * Returns true if Stream Management is supported by the server.\n     *\n     * @return true if Stream Management is supported by the server.\n     */\n    public boolean isSmAvailable() {\n        return hasFeature(StreamManagementFeature.ELEMENT, StreamManagement.NAMESPACE);\n    }\n\n    /**\n     * Returns true if Stream Management was successfully negotiated with the server.\n     *\n     * @return true if Stream Management was negotiated.\n     */\n    public boolean isSmEnabled() {\n        return smEnabledSyncPoint.wasSuccessful();\n    }\n\n    /**\n     * Returns true if the stream was successfully resumed with help of Stream Management.\n     * \n     * @return true if the stream was resumed.\n     */\n    public boolean streamWasResumed() {\n        return smResumedSyncPoint.wasSuccessful();\n    }\n\n    /**\n     * Returns true if the connection is disconnected by a Stream resumption via Stream Management is possible.\n     * \n     * @return true if disconnected but resumption possible.\n     */\n    public boolean isDisconnectedButSmResumptionPossible() {\n        return disconnectedButResumeable && isSmResumptionPossible();\n    }\n\n    /**\n     * Returns true if the stream is resumable.\n     *\n     * @return true if the stream is resumable.\n     */\n    public boolean isSmResumptionPossible() {\n        // There is no resumable stream available\n        if (smSessionId == null)\n            return false;\n\n        final Long shutdownTimestamp = packetWriter.shutdownTimestamp;\n        // Seems like we are already reconnected, report true\n        if (shutdownTimestamp == null) {\n            return true;\n        }\n\n        // See if resumption time is over\n        long current = System.currentTimeMillis();\n        long maxResumptionMillies = ((long) getMaxSmResumptionTime()) * 1000;\n        if (current > shutdownTimestamp + maxResumptionMillies) {\n            // Stream resumption is *not* possible if the current timestamp is greater then the greatest timestamp where\n            // resumption is possible\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Drop the stream management state. Sets {@link #smSessionId} and\n     * {@link #unacknowledgedStanzas} to <code>null</code>.\n     */\n    private void dropSmState() {\n        // clientHandledCount and serverHandledCount will be reset on <enable/> and <enabled/>\n        // respective. No need to reset them here.\n        smSessionId = null;\n        unacknowledgedStanzas = null;\n    }\n\n    /**\n     * Get the maximum resumption time in seconds after which a managed stream can be resumed.\n     * <p>\n     * This method will return {@link Integer#MAX_VALUE} if neither the client nor the server specify a maximum\n     * resumption time. Be aware of integer overflows when using this value, e.g. do not add arbitrary values to it\n     * without checking for overflows before.\n     * </p>\n     *\n     * @return the maximum resumption time in seconds or {@link Integer#MAX_VALUE} if none set.\n     */\n    public int getMaxSmResumptionTime() {\n        int clientResumptionTime = smClientMaxResumptionTime > 0 ? smClientMaxResumptionTime : Integer.MAX_VALUE;\n        int serverResumptionTime = smServerMaxResumptimTime > 0 ? smServerMaxResumptimTime : Integer.MAX_VALUE;\n        return Math.min(clientResumptionTime, serverResumptionTime);\n    }\n\n    private void processHandledCount(long handledCount) throws StreamManagementCounterError {\n        long ackedStanzasCount = SMUtils.calculateDelta(handledCount, serverHandledStanzasCount);\n        final List<Stanza> ackedStanzas = new ArrayList<Stanza>(\n                        ackedStanzasCount <= Integer.MAX_VALUE ? (int) ackedStanzasCount\n                                        : Integer.MAX_VALUE);\n        for (long i = 0; i < ackedStanzasCount; i++) {\n            Stanza ackedStanza = unacknowledgedStanzas.poll();\n            // If the server ack'ed a stanza, then it must be in the\n            // unacknowledged stanza queue. There can be no exception.\n            if (ackedStanza == null) {\n                throw new StreamManagementCounterError(handledCount, serverHandledStanzasCount,\n                                ackedStanzasCount, ackedStanzas);\n            }\n            ackedStanzas.add(ackedStanza);\n        }\n\n        boolean atLeastOneStanzaAcknowledgedListener = false;\n        if (!stanzaAcknowledgedListeners.isEmpty()) {\n            // If stanzaAcknowledgedListeners is not empty, the we have at least one\n            atLeastOneStanzaAcknowledgedListener = true;\n        }\n        else {\n            // Otherwise we look for a matching id in the stanza *id* acknowledged listeners\n            for (Stanza ackedStanza : ackedStanzas) {\n                String id = ackedStanza.getStanzaId();\n                if (id != null && stanzaIdAcknowledgedListeners.containsKey(id)) {\n                    atLeastOneStanzaAcknowledgedListener = true;\n                    break;\n                }\n            }\n        }\n\n        // Only spawn a new thread if there is a chance that some listener is invoked\n        if (atLeastOneStanzaAcknowledgedListener) {\n            asyncGo(new Runnable() {\n                @Override\n                public void run() {\n                    for (Stanza ackedStanza : ackedStanzas) {\n                        for (StanzaListener listener : stanzaAcknowledgedListeners) {\n                            try {\n                                listener.processPacket(ackedStanza);\n                            }\n                            catch (NotConnectedException e) {\n                                LOGGER.log(Level.FINER, \"Received not connected exception\", e);\n                            }\n                        }\n                        String id = ackedStanza.getStanzaId();\n                        if (StringUtils.isNullOrEmpty(id)) {\n                            continue;\n                        }\n                        StanzaListener listener = stanzaIdAcknowledgedListeners.remove(id);\n                        if (listener != null) {\n                            try {\n                                listener.processPacket(ackedStanza);\n                            }\n                            catch (NotConnectedException e) {\n                                LOGGER.log(Level.FINER, \"Received not connected exception\", e);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n\n        serverHandledStanzasCount = handledCount;\n    }\n\n    /**\n     * Set the default bundle and defer callback used for new connections.\n     *\n     * @param defaultBundleAndDeferCallback\n     * @see BundleAndDeferCallback\n     * @since 4.1\n     */\n    public static void setDefaultBundleAndDeferCallback(BundleAndDeferCallback defaultBundleAndDeferCallback) {\n        XMPPTCPConnection.defaultBundleAndDeferCallback = defaultBundleAndDeferCallback;\n    }\n\n    /**\n     * Set the bundle and defer callback used for this connection.\n     * <p>\n     * You can use <code>null</code> as argument to reset the callback. Outgoing stanzas will then\n     * no longer get deferred.\n     * </p>\n     *\n     * @param bundleAndDeferCallback the callback or <code>null</code>.\n     * @see BundleAndDeferCallback\n     * @since 4.1\n     */\n    public void setBundleandDeferCallback(BundleAndDeferCallback bundleAndDeferCallback) {\n        this.bundleAndDeferCallback = bundleAndDeferCallback;\n    }\n\n}\n"], "fixing_code": ["/**\n *\n * Copyright 2009 Jive Software.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.smack;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;\nimport org.jivesoftware.smack.SmackException.AlreadyConnectedException;\nimport org.jivesoftware.smack.SmackException.AlreadyLoggedInException;\nimport org.jivesoftware.smack.SmackException.NoResponseException;\nimport org.jivesoftware.smack.SmackException.NotConnectedException;\nimport org.jivesoftware.smack.SmackException.ConnectionException;\nimport org.jivesoftware.smack.SmackException.ResourceBindingNotOfferedException;\nimport org.jivesoftware.smack.SmackException.SecurityRequiredException;\nimport org.jivesoftware.smack.XMPPException.XMPPErrorException;\nimport org.jivesoftware.smack.compress.packet.Compress;\nimport org.jivesoftware.smack.compression.XMPPInputOutputStream;\nimport org.jivesoftware.smack.debugger.SmackDebugger;\nimport org.jivesoftware.smack.filter.IQReplyFilter;\nimport org.jivesoftware.smack.filter.StanzaFilter;\nimport org.jivesoftware.smack.filter.StanzaIdFilter;\nimport org.jivesoftware.smack.iqrequest.IQRequestHandler;\nimport org.jivesoftware.smack.packet.Bind;\nimport org.jivesoftware.smack.packet.ErrorIQ;\nimport org.jivesoftware.smack.packet.IQ;\nimport org.jivesoftware.smack.packet.Mechanisms;\nimport org.jivesoftware.smack.packet.Stanza;\nimport org.jivesoftware.smack.packet.ExtensionElement;\nimport org.jivesoftware.smack.packet.Presence;\nimport org.jivesoftware.smack.packet.Session;\nimport org.jivesoftware.smack.packet.StartTls;\nimport org.jivesoftware.smack.packet.PlainStreamElement;\nimport org.jivesoftware.smack.packet.XMPPError;\nimport org.jivesoftware.smack.parsing.ParsingExceptionCallback;\nimport org.jivesoftware.smack.parsing.UnparsablePacket;\nimport org.jivesoftware.smack.provider.ExtensionElementProvider;\nimport org.jivesoftware.smack.provider.ProviderManager;\nimport org.jivesoftware.smack.util.BoundedThreadPoolExecutor;\nimport org.jivesoftware.smack.util.DNSUtil;\nimport org.jivesoftware.smack.util.Objects;\nimport org.jivesoftware.smack.util.PacketParserUtils;\nimport org.jivesoftware.smack.util.ParserUtils;\nimport org.jivesoftware.smack.util.SmackExecutorThreadFactory;\nimport org.jivesoftware.smack.util.StringUtils;\nimport org.jivesoftware.smack.util.dns.HostAddress;\nimport org.jxmpp.util.XmppStringUtils;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\n\npublic abstract class AbstractXMPPConnection implements XMPPConnection {\n    private static final Logger LOGGER = Logger.getLogger(AbstractXMPPConnection.class.getName());\n\n    /** \n     * Counter to uniquely identify connections that are created.\n     */\n    private final static AtomicInteger connectionCounter = new AtomicInteger(0);\n\n    static {\n        // Ensure the SmackConfiguration class is loaded by calling a method in it.\n        SmackConfiguration.getVersion();\n    }\n\n    /**\n     * Get the collection of listeners that are interested in connection creation events.\n     * \n     * @return a collection of listeners interested on new connections.\n     */\n    protected static Collection<ConnectionCreationListener> getConnectionCreationListeners() {\n        return XMPPConnectionRegistry.getConnectionCreationListeners();\n    }\n \n    /**\n     * A collection of ConnectionListeners which listen for connection closing\n     * and reconnection events.\n     */\n    protected final Set<ConnectionListener> connectionListeners =\n            new CopyOnWriteArraySet<ConnectionListener>();\n\n    /**\n     * A collection of PacketCollectors which collects packets for a specified filter\n     * and perform blocking and polling operations on the result queue.\n     * <p>\n     * We use a ConcurrentLinkedQueue here, because its Iterator is weakly\n     * consistent and we want {@link #invokePacketCollectors(Stanza)} for-each\n     * loop to be lock free. As drawback, removing a PacketCollector is O(n).\n     * The alternative would be a synchronized HashSet, but this would mean a\n     * synchronized block around every usage of <code>collectors</code>.\n     * </p>\n     */\n    private final Collection<PacketCollector> collectors = new ConcurrentLinkedQueue<PacketCollector>();\n\n    /**\n     * List of PacketListeners that will be notified synchronously when a new stanza(/packet) was received.\n     */\n    private final Map<StanzaListener, ListenerWrapper> syncRecvListeners = new LinkedHashMap<>();\n\n    /**\n     * List of PacketListeners that will be notified asynchronously when a new stanza(/packet) was received.\n     */\n    private final Map<StanzaListener, ListenerWrapper> asyncRecvListeners = new LinkedHashMap<>();\n\n    /**\n     * List of PacketListeners that will be notified when a new stanza(/packet) was sent.\n     */\n    private final Map<StanzaListener, ListenerWrapper> sendListeners =\n            new HashMap<StanzaListener, ListenerWrapper>();\n\n    /**\n     * List of PacketListeners that will be notified when a new stanza(/packet) is about to be\n     * sent to the server. These interceptors may modify the stanza(/packet) before it is being\n     * actually sent to the server.\n     */\n    private final Map<StanzaListener, InterceptorWrapper> interceptors =\n            new HashMap<StanzaListener, InterceptorWrapper>();\n\n    protected final Lock connectionLock = new ReentrantLock();\n\n    protected final Map<String, ExtensionElement> streamFeatures = new HashMap<String, ExtensionElement>();\n\n    /**\n     * The full JID of the authenticated user, as returned by the resource binding response of the server.\n     * <p>\n     * It is important that we don't infer the user from the login() arguments and the configurations service name, as,\n     * for example, when SASL External is used, the username is not given to login but taken from the 'external'\n     * certificate.\n     * </p>\n     */\n    protected String user;\n\n    protected boolean connected = false;\n\n    /**\n     * The stream ID, see RFC 6120 \u00a7 4.7.3\n     */\n    protected String streamId;\n\n    /**\n     * \n     */\n    private long packetReplyTimeout = SmackConfiguration.getDefaultPacketReplyTimeout();\n\n    /**\n     * The SmackDebugger allows to log and debug XML traffic.\n     */\n    protected SmackDebugger debugger = null;\n\n    /**\n     * The Reader which is used for the debugger.\n     */\n    protected Reader reader;\n\n    /**\n     * The Writer which is used for the debugger.\n     */\n    protected Writer writer;\n\n    /**\n     * Set to success if the last features stanza from the server has been parsed. A XMPP connection\n     * handshake can invoke multiple features stanzas, e.g. when TLS is activated a second feature\n     * stanza is send by the server. This is set to true once the last feature stanza has been\n     * parsed.\n     */\n    protected final SynchronizationPoint<Exception> lastFeaturesReceived = new SynchronizationPoint<Exception>(\n                    AbstractXMPPConnection.this);\n\n    /**\n     * Set to success if the sasl feature has been received.\n     */\n    protected final SynchronizationPoint<SmackException> saslFeatureReceived = new SynchronizationPoint<SmackException>(\n                    AbstractXMPPConnection.this);\n \n    /**\n     * The SASLAuthentication manager that is responsible for authenticating with the server.\n     */\n    protected SASLAuthentication saslAuthentication = new SASLAuthentication(this);\n\n    /**\n     * A number to uniquely identify connections that are created. This is distinct from the\n     * connection ID, which is a value sent by the server once a connection is made.\n     */\n    protected final int connectionCounterValue = connectionCounter.getAndIncrement();\n\n    /**\n     * Holds the initial configuration used while creating the connection.\n     */\n    protected final ConnectionConfiguration config;\n\n    /**\n     * Defines how the from attribute of outgoing stanzas should be handled.\n     */\n    private FromMode fromMode = FromMode.OMITTED;\n\n    protected XMPPInputOutputStream compressionHandler;\n\n    private ParsingExceptionCallback parsingExceptionCallback = SmackConfiguration.getDefaultParsingExceptionCallback();\n\n    /**\n     * ExecutorService used to invoke the PacketListeners on newly arrived and parsed stanzas. It is\n     * important that we use a <b>single threaded ExecutorService</b> in order to guarantee that the\n     * PacketListeners are invoked in the same order the stanzas arrived.\n     */\n    private final BoundedThreadPoolExecutor executorService = new BoundedThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS,\n                    100, new SmackExecutorThreadFactory(connectionCounterValue, \"Incoming Processor\"));\n\n    /**\n     * This scheduled thread pool executor is used to remove pending callbacks.\n     */\n    private final ScheduledExecutorService removeCallbacksService = Executors.newSingleThreadScheduledExecutor(\n                    new SmackExecutorThreadFactory(connectionCounterValue, \"Remove Callbacks\"));\n\n    /**\n     * A cached thread pool executor service with custom thread factory to set meaningful names on the threads and set\n     * them 'daemon'.\n     */\n    private final ExecutorService cachedExecutorService = Executors.newCachedThreadPool(\n                    // @formatter:off\n                    new SmackExecutorThreadFactory(    // threadFactory\n                                    connectionCounterValue,\n                                    \"Cached Executor\"\n                                    )\n                    // @formatter:on\n                    );\n\n    /**\n     * A executor service used to invoke the callbacks of synchronous stanza(/packet) listeners. We use a executor service to\n     * decouple incoming stanza processing from callback invocation. It is important that order of callback invocation\n     * is the same as the order of the incoming stanzas. Therefore we use a <i>single</i> threaded executor service.\n     */\n    private final ExecutorService singleThreadedExecutorService = Executors.newSingleThreadExecutor(new SmackExecutorThreadFactory(\n                    getConnectionCounter(), \"Single Threaded Executor\"));\n\n    /**\n     * The used host to establish the connection to\n     */\n    protected String host;\n\n    /**\n     * The used port to establish the connection to\n     */\n    protected int port;\n\n    /**\n     * Flag that indicates if the user is currently authenticated with the server.\n     */\n    protected boolean authenticated = false;\n\n    /**\n     * Flag that indicates if the user was authenticated with the server when the connection\n     * to the server was closed (abruptly or not).\n     */\n    protected boolean wasAuthenticated = false;\n\n    private final Map<String, IQRequestHandler> setIqRequestHandler = new HashMap<>();\n    private final Map<String, IQRequestHandler> getIqRequestHandler = new HashMap<>();\n\n    /**\n     * Create a new XMPPConnection to an XMPP server.\n     * \n     * @param configuration The configuration which is used to establish the connection.\n     */\n    protected AbstractXMPPConnection(ConnectionConfiguration configuration) {\n        config = configuration;\n    }\n\n    /**\n     * Get the connection configuration used by this connection.\n     *\n     * @return the connection configuration.\n     */\n    public ConnectionConfiguration getConfiguration() {\n        return config;\n    }\n\n    @Override\n    public String getServiceName() {\n        if (serviceName != null) {\n            return serviceName;\n        }\n        return config.getServiceName();\n    }\n\n    @Override\n    public String getHost() {\n        return host;\n    }\n\n    @Override\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public abstract boolean isSecureConnection();\n\n    protected abstract void sendStanzaInternal(Stanza packet) throws NotConnectedException;\n\n    @Override\n    public abstract void send(PlainStreamElement element) throws NotConnectedException;\n\n    @Override\n    public abstract boolean isUsingCompression();\n\n    /**\n     * Establishes a connection to the XMPP server and performs an automatic login\n     * only if the previous connection state was logged (authenticated). It basically\n     * creates and maintains a connection to the server.\n     * <p>\n     * Listeners will be preserved from a previous connection.\n     * \n     * @throws XMPPException if an error occurs on the XMPP protocol level.\n     * @throws SmackException if an error occurs somewhere else besides XMPP protocol level.\n     * @throws IOException \n     * @throws ConnectionException with detailed information about the failed connection.\n     * @return a reference to this object, to chain <code>connect()</code> with <code>login()</code>.\n     */\n    public synchronized AbstractXMPPConnection connect() throws SmackException, IOException, XMPPException {\n        // Check if not already connected\n        throwAlreadyConnectedExceptionIfAppropriate();\n\n        // Reset the connection state\n        saslAuthentication.init();\n        saslFeatureReceived.init();\n        lastFeaturesReceived.init();\n        streamId = null;\n\n        // Perform the actual connection to the XMPP service\n        connectInternal();\n\n        return this;\n    }\n\n    /**\n     * Abstract method that concrete subclasses of XMPPConnection need to implement to perform their\n     * way of XMPP connection establishment. Implementations are required to perform an automatic\n     * login if the previous connection state was logged (authenticated).\n     * \n     * @throws SmackException\n     * @throws IOException\n     * @throws XMPPException\n     */\n    protected abstract void connectInternal() throws SmackException, IOException, XMPPException;\n\n    private String usedUsername, usedPassword, usedResource;\n\n    /**\n     * Logs in to the server using the strongest SASL mechanism supported by\n     * the server. If more than the connection's default stanza(/packet) timeout elapses in each step of the \n     * authentication process without a response from the server, a\n     * {@link SmackException.NoResponseException} will be thrown.\n     * <p>\n     * Before logging in (i.e. authenticate) to the server the connection must be connected\n     * by calling {@link #connect}.\n     * </p>\n     * <p>\n     * It is possible to log in without sending an initial available presence by using\n     * {@link ConnectionConfiguration.Builder#setSendPresence(boolean)}.\n     * Finally, if you want to not pass a password and instead use a more advanced mechanism\n     * while using SASL then you may be interested in using\n     * {@link ConnectionConfiguration.Builder#setCallbackHandler(javax.security.auth.callback.CallbackHandler)}.\n     * For more advanced login settings see {@link ConnectionConfiguration}.\n     * </p>\n     * \n     * @throws XMPPException if an error occurs on the XMPP protocol level.\n     * @throws SmackException if an error occurs somewhere else besides XMPP protocol level.\n     * @throws IOException if an I/O error occurs during login.\n     */\n    public synchronized void login() throws XMPPException, SmackException, IOException {\n        if (isAnonymous()) {\n            throwNotConnectedExceptionIfAppropriate(\"Did you call connect() before login()?\");\n            throwAlreadyLoggedInExceptionIfAppropriate();\n            loginAnonymously();\n        } else {\n            // The previously used username, password and resource take over precedence over the\n            // ones from the connection configuration\n            CharSequence username = usedUsername != null ? usedUsername : config.getUsername();\n            String password = usedPassword != null ? usedPassword : config.getPassword();\n            String resource = usedResource != null ? usedResource : config.getResource();\n            login(username, password, resource);\n        }\n    }\n\n    /**\n     * Same as {@link #login(CharSequence, String, String)}, but takes the resource from the connection\n     * configuration.\n     * \n     * @param username\n     * @param password\n     * @throws XMPPException\n     * @throws SmackException\n     * @throws IOException\n     * @see #login\n     */\n    public synchronized void login(CharSequence username, String password) throws XMPPException, SmackException,\n                    IOException {\n        login(username, password, config.getResource());\n    }\n\n    /**\n     * Login with the given username (authorization identity). You may omit the password if a callback handler is used.\n     * If resource is null, then the server will generate one.\n     * \n     * @param username\n     * @param password\n     * @param resource\n     * @throws XMPPException\n     * @throws SmackException\n     * @throws IOException\n     * @see #login\n     */\n    public synchronized void login(CharSequence username, String password, String resource) throws XMPPException,\n                    SmackException, IOException {\n        if (!config.allowNullOrEmptyUsername) {\n            StringUtils.requireNotNullOrEmpty(username, \"Username must not be null or empty\");\n        }\n        throwNotConnectedExceptionIfAppropriate();\n        throwAlreadyLoggedInExceptionIfAppropriate();\n        usedUsername = username != null ? username.toString() : null;\n        usedPassword = password;\n        usedResource = resource;\n        loginNonAnonymously(usedUsername, usedPassword, usedResource);\n    }\n\n    protected abstract void loginNonAnonymously(String username, String password, String resource)\n                    throws XMPPException, SmackException, IOException;\n\n    protected abstract void loginAnonymously() throws XMPPException, SmackException, IOException;\n\n    @Override\n    public final boolean isConnected() {\n        return connected;\n    }\n\n    @Override\n    public final boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    @Override\n    public final String getUser() {\n        return user;\n    }\n\n    @Override\n    public String getStreamId() {\n        if (!isConnected()) {\n            return null;\n        }\n        return streamId;\n    }\n\n    // TODO remove this suppression once \"disable legacy session\" code has been removed from Smack\n    @SuppressWarnings(\"deprecation\")\n    protected void bindResourceAndEstablishSession(String resource) throws XMPPErrorException,\n                    IOException, SmackException {\n\n        // Wait until either:\n        // - the servers last features stanza has been parsed\n        // - the timeout occurs\n        LOGGER.finer(\"Waiting for last features to be received before continuing with resource binding\");\n        lastFeaturesReceived.checkIfSuccessOrWait();\n\n\n        if (!hasFeature(Bind.ELEMENT, Bind.NAMESPACE)) {\n            // Server never offered resource binding, which is REQURIED in XMPP client and\n            // server implementations as per RFC6120 7.2\n            throw new ResourceBindingNotOfferedException();\n        }\n\n        // Resource binding, see RFC6120 7.\n        // Note that we can not use IQReplyFilter here, since the users full JID is not yet\n        // available. It will become available right after the resource has been successfully bound.\n        Bind bindResource = Bind.newSet(resource);\n        PacketCollector packetCollector = createPacketCollectorAndSend(new StanzaIdFilter(bindResource), bindResource);\n        Bind response = packetCollector.nextResultOrThrow();\n        // Set the connections user to the result of resource binding. It is important that we don't infer the user\n        // from the login() arguments and the configurations service name, as, for example, when SASL External is used,\n        // the username is not given to login but taken from the 'external' certificate.\n        user = response.getJid();\n        serviceName = XmppStringUtils.parseDomain(user);\n\n        Session.Feature sessionFeature = getFeature(Session.ELEMENT, Session.NAMESPACE);\n        // Only bind the session if it's announced as stream feature by the server, is not optional and not disabled\n        // For more information see http://tools.ietf.org/html/draft-cridland-xmpp-session-01\n        if (sessionFeature != null && !sessionFeature.isOptional() && !getConfiguration().isLegacySessionDisabled()) {\n            Session session = new Session();\n            packetCollector = createPacketCollectorAndSend(new StanzaIdFilter(session), session);\n            packetCollector.nextResultOrThrow();\n        }\n    }\n\n    protected void afterSuccessfulLogin(final boolean resumed) throws NotConnectedException {\n        // Indicate that we're now authenticated.\n        this.authenticated = true;\n\n        // If debugging is enabled, change the the debug window title to include the\n        // name we are now logged-in as.\n        // If DEBUG was set to true AFTER the connection was created the debugger\n        // will be null\n        if (config.isDebuggerEnabled() && debugger != null) {\n            debugger.userHasLogged(user);\n        }\n        callConnectionAuthenticatedListener(resumed);\n\n        // Set presence to online. It is important that this is done after\n        // callConnectionAuthenticatedListener(), as this call will also\n        // eventually load the roster. And we should load the roster before we\n        // send the initial presence.\n        if (config.isSendPresence() && !resumed) {\n            sendStanza(new Presence(Presence.Type.available));\n        }\n    }\n\n    @Override\n    public final boolean isAnonymous() {\n        return config.getUsername() == null && usedUsername == null\n                        && !config.allowNullOrEmptyUsername;\n    }\n\n    private String serviceName;\n\n    protected List<HostAddress> hostAddresses;\n\n    /**\n     * Populates {@link #hostAddresses} with at least one host address.\n     *\n     * @return a list of host addresses where DNS (SRV) RR resolution failed.\n     */\n    protected List<HostAddress> populateHostAddresses() {\n        List<HostAddress> failedAddresses = new LinkedList<>();\n        // N.B.: Important to use config.serviceName and not AbstractXMPPConnection.serviceName\n        if (config.host != null) {\n            hostAddresses = new ArrayList<HostAddress>(1);\n            HostAddress hostAddress;\n            hostAddress = new HostAddress(config.host, config.port);\n            hostAddresses.add(hostAddress);\n        } else {\n            hostAddresses = DNSUtil.resolveXMPPDomain(config.serviceName, failedAddresses);\n        }\n        // If we reach this, then hostAddresses *must not* be empty, i.e. there is at least one host added, either the\n        // config.host one or the host representing the service name by DNSUtil\n        assert(!hostAddresses.isEmpty());\n        return failedAddresses;\n    }\n\n    protected Lock getConnectionLock() {\n        return connectionLock;\n    }\n\n    protected void throwNotConnectedExceptionIfAppropriate() throws NotConnectedException {\n        throwNotConnectedExceptionIfAppropriate(null);\n    }\n\n    protected void throwNotConnectedExceptionIfAppropriate(String optionalHint) throws NotConnectedException {\n        if (!isConnected()) {\n            throw new NotConnectedException(optionalHint);\n        }\n    }\n\n    protected void throwAlreadyConnectedExceptionIfAppropriate() throws AlreadyConnectedException {\n        if (isConnected()) {\n            throw new AlreadyConnectedException();\n        }\n    }\n\n    protected void throwAlreadyLoggedInExceptionIfAppropriate() throws AlreadyLoggedInException {\n        if (isAuthenticated()) {\n            throw new AlreadyLoggedInException();\n        }\n    }\n\n    @Deprecated\n    @Override\n    public void sendPacket(Stanza packet) throws NotConnectedException {\n        sendStanza(packet);\n    }\n\n    @Override\n    public void sendStanza(Stanza packet) throws NotConnectedException {\n        Objects.requireNonNull(packet, \"Packet must not be null\");\n\n        throwNotConnectedExceptionIfAppropriate();\n        switch (fromMode) {\n        case OMITTED:\n            packet.setFrom(null);\n            break;\n        case USER:\n            packet.setFrom(getUser());\n            break;\n        case UNCHANGED:\n        default:\n            break;\n        }\n        // Invoke interceptors for the new packet that is about to be sent. Interceptors may modify\n        // the content of the packet.\n        firePacketInterceptors(packet);\n        sendStanzaInternal(packet);\n    }\n\n    /**\n     * Returns the SASLAuthentication manager that is responsible for authenticating with\n     * the server.\n     * \n     * @return the SASLAuthentication manager that is responsible for authenticating with\n     *         the server.\n     */\n    protected SASLAuthentication getSASLAuthentication() {\n        return saslAuthentication;\n    }\n\n    /**\n     * Closes the connection by setting presence to unavailable then closing the connection to\n     * the XMPP server. The XMPPConnection can still be used for connecting to the server\n     * again.\n     *\n     */\n    public void disconnect() {\n        try {\n            disconnect(new Presence(Presence.Type.unavailable));\n        }\n        catch (NotConnectedException e) {\n            LOGGER.log(Level.FINEST, \"Connection is already disconnected\", e);\n        }\n    }\n\n    /**\n     * Closes the connection. A custom unavailable presence is sent to the server, followed\n     * by closing the stream. The XMPPConnection can still be used for connecting to the server\n     * again. A custom unavailable presence is useful for communicating offline presence\n     * information such as \"On vacation\". Typically, just the status text of the presence\n     * stanza(/packet) is set with online information, but most XMPP servers will deliver the full\n     * presence stanza(/packet) with whatever data is set.\n     * \n     * @param unavailablePresence the presence stanza(/packet) to send during shutdown.\n     * @throws NotConnectedException \n     */\n    public synchronized void disconnect(Presence unavailablePresence) throws NotConnectedException {\n        sendStanza(unavailablePresence);\n        shutdown();\n        callConnectionClosedListener();\n    }\n\n    /**\n     * Shuts the current connection down.\n     */\n    protected abstract void shutdown();\n\n    @Override\n    public void addConnectionListener(ConnectionListener connectionListener) {\n        if (connectionListener == null) {\n            return;\n        }\n        connectionListeners.add(connectionListener);\n    }\n\n    @Override\n    public void removeConnectionListener(ConnectionListener connectionListener) {\n        connectionListeners.remove(connectionListener);\n    }\n\n    @Override\n    public PacketCollector createPacketCollectorAndSend(IQ packet) throws NotConnectedException {\n        StanzaFilter packetFilter = new IQReplyFilter(packet, this);\n        // Create the packet collector before sending the packet\n        PacketCollector packetCollector = createPacketCollectorAndSend(packetFilter, packet);\n        return packetCollector;\n    }\n\n    @Override\n    public PacketCollector createPacketCollectorAndSend(StanzaFilter packetFilter, Stanza packet)\n                    throws NotConnectedException {\n        // Create the packet collector before sending the packet\n        PacketCollector packetCollector = createPacketCollector(packetFilter);\n        try {\n            // Now we can send the packet as the collector has been created\n            sendStanza(packet);\n        }\n        catch (NotConnectedException | RuntimeException e) {\n            packetCollector.cancel();\n            throw e;\n        }\n        return packetCollector;\n    }\n\n    @Override\n    public PacketCollector createPacketCollector(StanzaFilter packetFilter) {\n        PacketCollector.Configuration configuration = PacketCollector.newConfiguration().setStanzaFilter(packetFilter);\n        return createPacketCollector(configuration);\n    }\n\n    @Override\n    public PacketCollector createPacketCollector(PacketCollector.Configuration configuration) {\n        PacketCollector collector = new PacketCollector(this, configuration);\n        // Add the collector to the list of active collectors.\n        collectors.add(collector);\n        return collector;\n    }\n\n    @Override\n    public void removePacketCollector(PacketCollector collector) {\n        collectors.remove(collector);\n    }\n\n    @Override\n    @Deprecated\n    public void addPacketListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        addAsyncStanzaListener(packetListener, packetFilter);\n    }\n\n    @Override\n    @Deprecated\n    public boolean removePacketListener(StanzaListener packetListener) {\n        return removeAsyncStanzaListener(packetListener);\n    }\n\n    @Override\n    public void addSyncStanzaListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        if (packetListener == null) {\n            throw new NullPointerException(\"Packet listener is null.\");\n        }\n        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);\n        synchronized (syncRecvListeners) {\n            syncRecvListeners.put(packetListener, wrapper);\n        }\n    }\n\n    @Override\n    public boolean removeSyncStanzaListener(StanzaListener packetListener) {\n        synchronized (syncRecvListeners) {\n            return syncRecvListeners.remove(packetListener) != null;\n        }\n    }\n\n    @Override\n    public void addAsyncStanzaListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        if (packetListener == null) {\n            throw new NullPointerException(\"Packet listener is null.\");\n        }\n        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);\n        synchronized (asyncRecvListeners) {\n            asyncRecvListeners.put(packetListener, wrapper);\n        }\n    }\n\n    @Override\n    public boolean removeAsyncStanzaListener(StanzaListener packetListener) {\n        synchronized (asyncRecvListeners) {\n            return asyncRecvListeners.remove(packetListener) != null;\n        }\n    }\n\n    @Override\n    public void addPacketSendingListener(StanzaListener packetListener, StanzaFilter packetFilter) {\n        if (packetListener == null) {\n            throw new NullPointerException(\"Packet listener is null.\");\n        }\n        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);\n        synchronized (sendListeners) {\n            sendListeners.put(packetListener, wrapper);\n        }\n    }\n\n    @Override\n    public void removePacketSendingListener(StanzaListener packetListener) {\n        synchronized (sendListeners) {\n            sendListeners.remove(packetListener);\n        }\n    }\n\n    /**\n     * Process all stanza(/packet) listeners for sending packets.\n     * <p>\n     * Compared to {@link #firePacketInterceptors(Stanza)}, the listeners will be invoked in a new thread.\n     * </p>\n     * \n     * @param packet the stanza(/packet) to process.\n     */\n    @SuppressWarnings(\"javadoc\")\n    protected void firePacketSendingListeners(final Stanza packet) {\n        final List<StanzaListener> listenersToNotify = new LinkedList<StanzaListener>();\n        synchronized (sendListeners) {\n            for (ListenerWrapper listenerWrapper : sendListeners.values()) {\n                if (listenerWrapper.filterMatches(packet)) {\n                    listenersToNotify.add(listenerWrapper.getListener());\n                }\n            }\n        }\n        if (listenersToNotify.isEmpty()) {\n            return;\n        }\n        // Notify in a new thread, because we can\n        asyncGo(new Runnable() {\n            @Override\n            public void run() {\n                for (StanzaListener listener : listenersToNotify) {\n                    try {\n                        listener.processPacket(packet);\n                    }\n                    catch (Exception e) {\n                        LOGGER.log(Level.WARNING, \"Sending listener threw exception\", e);\n                        continue;\n                    }\n                }\n            }});\n    }\n\n    @Override\n    public void addPacketInterceptor(StanzaListener packetInterceptor,\n            StanzaFilter packetFilter) {\n        if (packetInterceptor == null) {\n            throw new NullPointerException(\"Packet interceptor is null.\");\n        }\n        InterceptorWrapper interceptorWrapper = new InterceptorWrapper(packetInterceptor, packetFilter);\n        synchronized (interceptors) {\n            interceptors.put(packetInterceptor, interceptorWrapper);\n        }\n    }\n\n    @Override\n    public void removePacketInterceptor(StanzaListener packetInterceptor) {\n        synchronized (interceptors) {\n            interceptors.remove(packetInterceptor);\n        }\n    }\n\n    /**\n     * Process interceptors. Interceptors may modify the stanza(/packet) that is about to be sent.\n     * Since the thread that requested to send the stanza(/packet) will invoke all interceptors, it\n     * is important that interceptors perform their work as soon as possible so that the\n     * thread does not remain blocked for a long period.\n     * \n     * @param packet the stanza(/packet) that is going to be sent to the server\n     */\n    private void firePacketInterceptors(Stanza packet) {\n        List<StanzaListener> interceptorsToInvoke = new LinkedList<StanzaListener>();\n        synchronized (interceptors) {\n            for (InterceptorWrapper interceptorWrapper : interceptors.values()) {\n                if (interceptorWrapper.filterMatches(packet)) {\n                    interceptorsToInvoke.add(interceptorWrapper.getInterceptor());\n                }\n            }\n        }\n        for (StanzaListener interceptor : interceptorsToInvoke) {\n            try {\n                interceptor.processPacket(packet);\n            } catch (Exception e) {\n                LOGGER.log(Level.SEVERE, \"Packet interceptor threw exception\", e);\n            }\n        }\n    }\n\n    /**\n     * Initialize the {@link #debugger}. You can specify a customized {@link SmackDebugger}\n     * by setup the system property <code>smack.debuggerClass</code> to the implementation.\n     * \n     * @throws IllegalStateException if the reader or writer isn't yet initialized.\n     * @throws IllegalArgumentException if the SmackDebugger can't be loaded.\n     */\n    protected void initDebugger() {\n        if (reader == null || writer == null) {\n            throw new NullPointerException(\"Reader or writer isn't initialized.\");\n        }\n        // If debugging is enabled, we open a window and write out all network traffic.\n        if (config.isDebuggerEnabled()) {\n            if (debugger == null) {\n                debugger = SmackConfiguration.createDebugger(this, writer, reader);\n            }\n\n            if (debugger == null) {\n                LOGGER.severe(\"Debugging enabled but could not find debugger class\");\n            } else {\n                // Obtain new reader and writer from the existing debugger\n                reader = debugger.newConnectionReader(reader);\n                writer = debugger.newConnectionWriter(writer);\n            }\n        }\n    }\n\n    @Override\n    public long getPacketReplyTimeout() {\n        return packetReplyTimeout;\n    }\n\n    @Override\n    public void setPacketReplyTimeout(long timeout) {\n        packetReplyTimeout = timeout;\n    }\n\n    private static boolean replyToUnknownIqDefault = true;\n\n    /**\n     * Set the default value used to determine if new connection will reply to unknown IQ requests. The pre-configured\n     * default is 'true'.\n     *\n     * @param replyToUnkownIqDefault\n     * @see #setReplyToUnknownIq(boolean)\n     */\n    public static void setReplyToUnknownIqDefault(boolean replyToUnkownIqDefault) {\n        AbstractXMPPConnection.replyToUnknownIqDefault = replyToUnkownIqDefault;\n    }\n\n    private boolean replyToUnkownIq = replyToUnknownIqDefault;\n\n    /**\n     * Set if Smack will automatically send\n     * {@link org.jivesoftware.smack.packet.XMPPError.Condition#feature_not_implemented} when a request IQ without a\n     * registered {@link IQRequestHandler} is received.\n     *\n     * @param replyToUnknownIq\n     */\n    public void setReplyToUnknownIq(boolean replyToUnknownIq) {\n        this.replyToUnkownIq = replyToUnknownIq;\n    }\n\n    protected void parseAndProcessStanza(XmlPullParser parser) throws Exception {\n        ParserUtils.assertAtStartTag(parser);\n        int parserDepth = parser.getDepth();\n        Stanza stanza = null;\n        try {\n            stanza = PacketParserUtils.parseStanza(parser);\n        }\n        catch (Exception e) {\n            CharSequence content = PacketParserUtils.parseContentDepth(parser,\n                            parserDepth);\n            UnparsablePacket message = new UnparsablePacket(content, e);\n            ParsingExceptionCallback callback = getParsingExceptionCallback();\n            if (callback != null) {\n                callback.handleUnparsablePacket(message);\n            }\n        }\n        ParserUtils.assertAtEndTag(parser);\n        if (stanza != null) {\n            processPacket(stanza);\n        }\n    }\n\n    /**\n     * Processes a stanza(/packet) after it's been fully parsed by looping through the installed\n     * stanza(/packet) collectors and listeners and letting them examine the stanza(/packet) to see if\n     * they are a match with the filter.\n     *\n     * @param packet the stanza(/packet) to process.\n     * @throws InterruptedException\n     */\n    protected void processPacket(Stanza packet) throws InterruptedException {\n        assert(packet != null);\n        lastStanzaReceived = System.currentTimeMillis();\n        // Deliver the incoming packet to listeners.\n        executorService.executeBlocking(new ListenerNotification(packet));\n    }\n\n    /**\n     * A runnable to notify all listeners and stanza(/packet) collectors of a packet.\n     */\n    private class ListenerNotification implements Runnable {\n\n        private final Stanza packet;\n\n        public ListenerNotification(Stanza packet) {\n            this.packet = packet;\n        }\n\n        public void run() {\n            invokePacketCollectorsAndNotifyRecvListeners(packet);\n        }\n    }\n\n    /**\n     * Invoke {@link PacketCollector#processPacket(Stanza)} for every\n     * PacketCollector with the given packet. Also notify the receive listeners with a matching stanza(/packet) filter about the packet.\n     *\n     * @param packet the stanza(/packet) to notify the PacketCollectors and receive listeners about.\n     */\n    protected void invokePacketCollectorsAndNotifyRecvListeners(final Stanza packet) {\n        if (packet instanceof IQ) {\n            final IQ iq = (IQ) packet;\n            final IQ.Type type = iq.getType();\n            switch (type) {\n            case set:\n            case get:\n                final String key = XmppStringUtils.generateKey(iq.getChildElementName(), iq.getChildElementNamespace());\n                IQRequestHandler iqRequestHandler = null;\n                switch (type) {\n                case set:\n                    synchronized (setIqRequestHandler) {\n                        iqRequestHandler = setIqRequestHandler.get(key);\n                    }\n                    break;\n                case get:\n                    synchronized (getIqRequestHandler) {\n                        iqRequestHandler = getIqRequestHandler.get(key);\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException(\"Should only encounter IQ type 'get' or 'set'\");\n                }\n                if (iqRequestHandler == null) {\n                    if (!replyToUnkownIq) {\n                        return;\n                    }\n                    // If the IQ stanza is of type \"get\" or \"set\" with no registered IQ request handler, then answer an\n                    // IQ of type \"error\" with code 501 (\"feature-not-implemented\")\n                    ErrorIQ errorIQ = IQ.createErrorResponse(iq, new XMPPError(\n                                    XMPPError.Condition.feature_not_implemented));\n                    try {\n                        sendStanza(errorIQ);\n                    }\n                    catch (NotConnectedException e) {\n                        LOGGER.log(Level.WARNING, \"NotConnectedException while sending error IQ to unkown IQ request\", e);\n                    }\n                } else {\n                    ExecutorService executorService = null;\n                    switch (iqRequestHandler.getMode()) {\n                    case sync:\n                        executorService = singleThreadedExecutorService;\n                        break;\n                    case async:\n                        executorService = cachedExecutorService;\n                        break;\n                    }\n                    final IQRequestHandler finalIqRequestHandler = iqRequestHandler;\n                    executorService.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            IQ response = finalIqRequestHandler.handleIQRequest(iq);\n                            if (response == null) {\n                                // It is not ideal if the IQ request handler does not return an IQ response, because RFC\n                                // 6120 \u00a7 8.1.2 does specify that a response is mandatory. But some APIs, mostly the\n                                // file transfer one, does not always return a result, so we need to handle this case.\n                                // Also sometimes a request handler may decide that it's better to not send a response,\n                                // e.g. to avoid presence leaks.\n                                return;\n                            }\n                            try {\n                                sendStanza(response);\n                            }\n                            catch (NotConnectedException e) {\n                                LOGGER.log(Level.WARNING, \"NotConnectedException while sending response to IQ request\", e);\n                            }\n                        }\n                    });\n                    // The following returns makes it impossible for packet listeners and collectors to\n                    // filter for IQ request stanzas, i.e. IQs of type 'set' or 'get'. This is the\n                    // desired behavior.\n                    return;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        // First handle the async recv listeners. Note that this code is very similar to what follows a few lines below,\n        // the only difference is that asyncRecvListeners is used here and that the packet listeners are started in\n        // their own thread.\n        final Collection<StanzaListener> listenersToNotify = new LinkedList<StanzaListener>();\n        synchronized (asyncRecvListeners) {\n            for (ListenerWrapper listenerWrapper : asyncRecvListeners.values()) {\n                if (listenerWrapper.filterMatches(packet)) {\n                    listenersToNotify.add(listenerWrapper.getListener());\n                }\n            }\n        }\n\n        for (final StanzaListener listener : listenersToNotify) {\n            asyncGo(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        listener.processPacket(packet);\n                    } catch (Exception e) {\n                        LOGGER.log(Level.SEVERE, \"Exception in async packet listener\", e);\n                    }\n                }\n            });\n        }\n\n        // Loop through all collectors and notify the appropriate ones.\n        for (PacketCollector collector: collectors) {\n            collector.processPacket(packet);\n        }\n\n        // Notify the receive listeners interested in the packet\n        listenersToNotify.clear();\n        synchronized (syncRecvListeners) {\n            for (ListenerWrapper listenerWrapper : syncRecvListeners.values()) {\n                if (listenerWrapper.filterMatches(packet)) {\n                    listenersToNotify.add(listenerWrapper.getListener());\n                }\n            }\n        }\n\n        // Decouple incoming stanza processing from listener invocation. Unlike async listeners, this uses a single\n        // threaded executor service and therefore keeps the order.\n        singleThreadedExecutorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                for (StanzaListener listener : listenersToNotify) {\n                    try {\n                        listener.processPacket(packet);\n                    } catch(NotConnectedException e) {\n                        LOGGER.log(Level.WARNING, \"Got not connected exception, aborting\", e);\n                        break;\n                    } catch (Exception e) {\n                        LOGGER.log(Level.SEVERE, \"Exception in packet listener\", e);\n                    }\n                }\n            }\n        });\n\n    }\n\n    /**\n     * Sets whether the connection has already logged in the server. This method assures that the\n     * {@link #wasAuthenticated} flag is never reset once it has ever been set.\n     * \n     */\n    protected void setWasAuthenticated() {\n        // Never reset the flag if the connection has ever been authenticated\n        if (!wasAuthenticated) {\n            wasAuthenticated = authenticated;\n        }\n    }\n\n    protected void callConnectionConnectedListener() {\n        for (ConnectionListener listener : connectionListeners) {\n            listener.connected(this);\n        }\n    }\n\n    protected void callConnectionAuthenticatedListener(boolean resumed) {\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.authenticated(this, resumed);\n            } catch (Exception e) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener and finish the shutdown process\n                LOGGER.log(Level.SEVERE, \"Exception in authenticated listener\", e);\n            }\n        }\n    }\n\n    void callConnectionClosedListener() {\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.connectionClosed();\n            }\n            catch (Exception e) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener and finish the shutdown process\n                LOGGER.log(Level.SEVERE, \"Error in listener while closing connection\", e);\n            }\n        }\n    }\n\n    protected void callConnectionClosedOnErrorListener(Exception e) {\n        LOGGER.log(Level.WARNING, \"Connection closed with error\", e);\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.connectionClosedOnError(e);\n            }\n            catch (Exception e2) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener\n                LOGGER.log(Level.SEVERE, \"Error in listener while closing connection\", e2);\n            }\n        }\n    }\n\n    /**\n     * Sends a notification indicating that the connection was reconnected successfully.\n     */\n    protected void notifyReconnection() {\n        // Notify connection listeners of the reconnection.\n        for (ConnectionListener listener : connectionListeners) {\n            try {\n                listener.reconnectionSuccessful();\n            }\n            catch (Exception e) {\n                // Catch and print any exception so we can recover\n                // from a faulty listener\n                LOGGER.log(Level.WARNING, \"notifyReconnection()\", e);\n            }\n        }\n    }\n\n    /**\n     * A wrapper class to associate a stanza(/packet) filter with a listener.\n     */\n    protected static class ListenerWrapper {\n\n        private final StanzaListener packetListener;\n        private final StanzaFilter packetFilter;\n\n        /**\n         * Create a class which associates a stanza(/packet) filter with a listener.\n         * \n         * @param packetListener the stanza(/packet) listener.\n         * @param packetFilter the associated filter or null if it listen for all packets.\n         */\n        public ListenerWrapper(StanzaListener packetListener, StanzaFilter packetFilter) {\n            this.packetListener = packetListener;\n            this.packetFilter = packetFilter;\n        }\n\n        public boolean filterMatches(Stanza packet) {\n            return packetFilter == null || packetFilter.accept(packet);\n        }\n\n        public StanzaListener getListener() {\n            return packetListener;\n        }\n    }\n\n    /**\n     * A wrapper class to associate a stanza(/packet) filter with an interceptor.\n     */\n    protected static class InterceptorWrapper {\n\n        private final StanzaListener packetInterceptor;\n        private final StanzaFilter packetFilter;\n\n        /**\n         * Create a class which associates a stanza(/packet) filter with an interceptor.\n         * \n         * @param packetInterceptor the interceptor.\n         * @param packetFilter the associated filter or null if it intercepts all packets.\n         */\n        public InterceptorWrapper(StanzaListener packetInterceptor, StanzaFilter packetFilter) {\n            this.packetInterceptor = packetInterceptor;\n            this.packetFilter = packetFilter;\n        }\n\n        public boolean filterMatches(Stanza packet) {\n            return packetFilter == null || packetFilter.accept(packet);\n        }\n\n        public StanzaListener getInterceptor() {\n            return packetInterceptor;\n        }\n    }\n\n    @Override\n    public int getConnectionCounter() {\n        return connectionCounterValue;\n    }\n\n    @Override\n    public void setFromMode(FromMode fromMode) {\n        this.fromMode = fromMode;\n    }\n\n    @Override\n    public FromMode getFromMode() {\n        return this.fromMode;\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        LOGGER.fine(\"finalizing XMPPConnection ( \" + getConnectionCounter()\n                        + \"): Shutting down executor services\");\n        try {\n            // It's usually not a good idea to rely on finalize. But this is the easiest way to\n            // avoid the \"Smack Listener Processor\" leaking. The thread(s) of the executor have a\n            // reference to their ExecutorService which prevents the ExecutorService from being\n            // gc'ed. It is possible that the XMPPConnection instance is gc'ed while the\n            // listenerExecutor ExecutorService call not be gc'ed until it got shut down.\n            executorService.shutdownNow();\n            cachedExecutorService.shutdown();\n            removeCallbacksService.shutdownNow();\n            singleThreadedExecutorService.shutdownNow();\n        } catch (Throwable t) {\n            LOGGER.log(Level.WARNING, \"finalize() threw trhowable\", t);\n        }\n        finally {\n            super.finalize();\n        }\n    }\n\n    protected final void parseFeatures(XmlPullParser parser) throws XmlPullParserException,\n                    IOException, SmackException {\n        streamFeatures.clear();\n        final int initialDepth = parser.getDepth();\n        while (true) {\n            int eventType = parser.next();\n\n            if (eventType == XmlPullParser.START_TAG && parser.getDepth() == initialDepth + 1) {\n                ExtensionElement streamFeature = null;\n                String name = parser.getName();\n                String namespace = parser.getNamespace();\n                switch (name) {\n                case StartTls.ELEMENT:\n                    streamFeature = PacketParserUtils.parseStartTlsFeature(parser);\n                    break;\n                case Mechanisms.ELEMENT:\n                    streamFeature = new Mechanisms(PacketParserUtils.parseMechanisms(parser));\n                    break;\n                case Bind.ELEMENT:\n                    streamFeature = Bind.Feature.INSTANCE;\n                    break;\n                case Session.ELEMENT:\n                    streamFeature = PacketParserUtils.parseSessionFeature(parser);\n                    break;\n                case Compress.Feature.ELEMENT:\n                    streamFeature = PacketParserUtils.parseCompressionFeature(parser);\n                    break;\n                default:\n                    ExtensionElementProvider<ExtensionElement> provider = ProviderManager.getStreamFeatureProvider(name, namespace);\n                    if (provider != null) {\n                        streamFeature = provider.parse(parser);\n                    }\n                    break;\n                }\n                if (streamFeature != null) {\n                    addStreamFeature(streamFeature);\n                }\n            }\n            else if (eventType == XmlPullParser.END_TAG && parser.getDepth() == initialDepth) {\n                break;\n            }\n        }\n\n        if (hasFeature(Mechanisms.ELEMENT, Mechanisms.NAMESPACE)) {\n            // Only proceed with SASL auth if TLS is disabled or if the server doesn't announce it\n            if (!hasFeature(StartTls.ELEMENT, StartTls.NAMESPACE)\n                            || config.getSecurityMode() == SecurityMode.disabled) {\n                saslFeatureReceived.reportSuccess();\n            }\n        }\n\n        // If the server reported the bind feature then we are that that we did SASL and maybe\n        // STARTTLS. We can then report that the last 'stream:features' have been parsed\n        if (hasFeature(Bind.ELEMENT, Bind.NAMESPACE)) {\n            if (!hasFeature(Compress.Feature.ELEMENT, Compress.NAMESPACE)\n                            || !config.isCompressionEnabled()) {\n                // This was was last features from the server is either it did not contain\n                // compression or if we disabled it\n                lastFeaturesReceived.reportSuccess();\n            }\n        }\n        afterFeaturesReceived();\n    }\n\n    protected void afterFeaturesReceived() throws SecurityRequiredException, NotConnectedException {\n        // Default implementation does nothing\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <F extends ExtensionElement> F getFeature(String element, String namespace) {\n        return (F) streamFeatures.get(XmppStringUtils.generateKey(element, namespace));\n    }\n\n    @Override\n    public boolean hasFeature(String element, String namespace) {\n        return getFeature(element, namespace) != null;\n    }\n\n    private void addStreamFeature(ExtensionElement feature) {\n        String key = XmppStringUtils.generateKey(feature.getElementName(), feature.getNamespace());\n        streamFeatures.put(key, feature);\n    }\n\n    @Override\n    public void sendStanzaWithResponseCallback(Stanza stanza, StanzaFilter replyFilter,\n                    StanzaListener callback) throws NotConnectedException {\n        sendStanzaWithResponseCallback(stanza, replyFilter, callback, null);\n    }\n\n    @Override\n    public void sendStanzaWithResponseCallback(Stanza stanza, StanzaFilter replyFilter,\n                    StanzaListener callback, ExceptionCallback exceptionCallback)\n                    throws NotConnectedException {\n        sendStanzaWithResponseCallback(stanza, replyFilter, callback, exceptionCallback,\n                        getPacketReplyTimeout());\n    }\n\n    @Override\n    public void sendStanzaWithResponseCallback(Stanza stanza, final StanzaFilter replyFilter,\n                    final StanzaListener callback, final ExceptionCallback exceptionCallback,\n                    long timeout) throws NotConnectedException {\n        Objects.requireNonNull(stanza, \"stanza must not be null\");\n        // While Smack allows to add PacketListeners with a PacketFilter value of 'null', we\n        // disallow it here in the async API as it makes no sense\n        Objects.requireNonNull(replyFilter, \"replyFilter must not be null\");\n        Objects.requireNonNull(callback, \"callback must not be null\");\n\n        final StanzaListener packetListener = new StanzaListener() {\n            @Override\n            public void processPacket(Stanza packet) throws NotConnectedException {\n                try {\n                    XMPPErrorException.ifHasErrorThenThrow(packet);\n                    callback.processPacket(packet);\n                }\n                catch (XMPPErrorException e) {\n                    if (exceptionCallback != null) {\n                        exceptionCallback.processException(e);\n                    }\n                }\n                finally {\n                    removeAsyncStanzaListener(this);\n                }\n            }\n        };\n        removeCallbacksService.schedule(new Runnable() {\n            @Override\n            public void run() {\n                boolean removed = removeAsyncStanzaListener(packetListener);\n                // If the packetListener got removed, then it was never run and\n                // we never received a response, inform the exception callback\n                if (removed && exceptionCallback != null) {\n                    exceptionCallback.processException(NoResponseException.newWith(AbstractXMPPConnection.this, replyFilter));\n                }\n            }\n        }, timeout, TimeUnit.MILLISECONDS);\n        addAsyncStanzaListener(packetListener, replyFilter);\n        sendStanza(stanza);\n    }\n\n    @Override\n    public void sendIqWithResponseCallback(IQ iqRequest, StanzaListener callback)\n                    throws NotConnectedException {\n        sendIqWithResponseCallback(iqRequest, callback, null);\n    }\n\n    @Override\n    public void sendIqWithResponseCallback(IQ iqRequest, StanzaListener callback,\n                    ExceptionCallback exceptionCallback) throws NotConnectedException {\n        sendIqWithResponseCallback(iqRequest, callback, exceptionCallback, getPacketReplyTimeout());\n    }\n\n    @Override\n    public void sendIqWithResponseCallback(IQ iqRequest, final StanzaListener callback,\n                    final ExceptionCallback exceptionCallback, long timeout)\n                    throws NotConnectedException {\n        StanzaFilter replyFilter = new IQReplyFilter(iqRequest, this);\n        sendStanzaWithResponseCallback(iqRequest, replyFilter, callback, exceptionCallback, timeout);\n    }\n\n    @Override\n    public void addOneTimeSyncCallback(final StanzaListener callback, final StanzaFilter packetFilter) {\n        final StanzaListener packetListener = new StanzaListener() {\n            @Override\n            public void processPacket(Stanza packet) throws NotConnectedException {\n                try {\n                    callback.processPacket(packet);\n                } finally {\n                    removeSyncStanzaListener(this);\n                }\n            }\n        };\n        addSyncStanzaListener(packetListener, packetFilter);\n        removeCallbacksService.schedule(new Runnable() {\n            @Override\n            public void run() {\n                removeSyncStanzaListener(packetListener);\n            }\n        }, getPacketReplyTimeout(), TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public IQRequestHandler registerIQRequestHandler(final IQRequestHandler iqRequestHandler) {\n        final String key = XmppStringUtils.generateKey(iqRequestHandler.getElement(), iqRequestHandler.getNamespace());\n        switch (iqRequestHandler.getType()) {\n        case set:\n            synchronized (setIqRequestHandler) {\n                return setIqRequestHandler.put(key, iqRequestHandler);\n            }\n        case get:\n            synchronized (getIqRequestHandler) {\n                return getIqRequestHandler.put(key, iqRequestHandler);\n            }\n        default:\n            throw new IllegalArgumentException(\"Only IQ type of 'get' and 'set' allowed\");\n        }\n    }\n\n    @Override\n    public final IQRequestHandler unregisterIQRequestHandler(IQRequestHandler iqRequestHandler) {\n        return unregisterIQRequestHandler(iqRequestHandler.getElement(), iqRequestHandler.getNamespace(),\n                        iqRequestHandler.getType());\n    }\n\n    @Override\n    public IQRequestHandler unregisterIQRequestHandler(String element, String namespace, IQ.Type type) {\n        final String key = XmppStringUtils.generateKey(element, namespace);\n        switch (type) {\n        case set:\n            synchronized (setIqRequestHandler) {\n                return setIqRequestHandler.remove(key);\n            }\n        case get:\n            synchronized (getIqRequestHandler) {\n                return getIqRequestHandler.remove(key);\n            }\n        default:\n            throw new IllegalArgumentException(\"Only IQ type of 'get' and 'set' allowed\");\n        }\n    }\n\n    private long lastStanzaReceived;\n\n    public long getLastStanzaReceived() {\n        return lastStanzaReceived;\n    }\n\n    /**\n     * Install a parsing exception callback, which will be invoked once an exception is encountered while parsing a\n     * stanza\n     * \n     * @param callback the callback to install\n     */\n    public void setParsingExceptionCallback(ParsingExceptionCallback callback) {\n        parsingExceptionCallback = callback;\n    }\n\n    /**\n     * Get the current active parsing exception callback.\n     *  \n     * @return the active exception callback or null if there is none\n     */\n    public ParsingExceptionCallback getParsingExceptionCallback() {\n        return parsingExceptionCallback;\n    }\n\n    protected final void asyncGo(Runnable runnable) {\n        cachedExecutorService.execute(runnable);\n    }\n\n    protected final ScheduledFuture<?> schedule(Runnable runnable, long delay, TimeUnit unit) {\n        return removeCallbacksService.schedule(runnable, delay, unit);\n    }\n}\n", "/**\n *\n * Copyright 2003-2007 Jive Software.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.smack.tcp;\n\nimport org.jivesoftware.smack.AbstractConnectionListener;\nimport org.jivesoftware.smack.AbstractXMPPConnection;\nimport org.jivesoftware.smack.ConnectionConfiguration;\nimport org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;\nimport org.jivesoftware.smack.ConnectionCreationListener;\nimport org.jivesoftware.smack.StanzaListener;\nimport org.jivesoftware.smack.SmackConfiguration;\nimport org.jivesoftware.smack.SmackException;\nimport org.jivesoftware.smack.SmackException.AlreadyConnectedException;\nimport org.jivesoftware.smack.SmackException.AlreadyLoggedInException;\nimport org.jivesoftware.smack.SmackException.NoResponseException;\nimport org.jivesoftware.smack.SmackException.NotConnectedException;\nimport org.jivesoftware.smack.SmackException.SecurityRequiredByClientException;\nimport org.jivesoftware.smack.SmackException.ConnectionException;\nimport org.jivesoftware.smack.SmackException.SecurityRequiredByServerException;\nimport org.jivesoftware.smack.SynchronizationPoint;\nimport org.jivesoftware.smack.XMPPException.StreamErrorException;\nimport org.jivesoftware.smack.XMPPConnection;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.XMPPException.XMPPErrorException;\nimport org.jivesoftware.smack.compress.packet.Compressed;\nimport org.jivesoftware.smack.compression.XMPPInputOutputStream;\nimport org.jivesoftware.smack.filter.StanzaFilter;\nimport org.jivesoftware.smack.compress.packet.Compress;\nimport org.jivesoftware.smack.packet.Element;\nimport org.jivesoftware.smack.packet.IQ;\nimport org.jivesoftware.smack.packet.Message;\nimport org.jivesoftware.smack.packet.StreamOpen;\nimport org.jivesoftware.smack.packet.Stanza;\nimport org.jivesoftware.smack.packet.Presence;\nimport org.jivesoftware.smack.packet.StartTls;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements.Challenge;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements.SASLFailure;\nimport org.jivesoftware.smack.sasl.packet.SaslStreamElements.Success;\nimport org.jivesoftware.smack.sm.SMUtils;\nimport org.jivesoftware.smack.sm.StreamManagementException;\nimport org.jivesoftware.smack.sm.StreamManagementException.StreamIdDoesNotMatchException;\nimport org.jivesoftware.smack.sm.StreamManagementException.StreamManagementCounterError;\nimport org.jivesoftware.smack.sm.StreamManagementException.StreamManagementNotEnabledException;\nimport org.jivesoftware.smack.sm.packet.StreamManagement;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.AckAnswer;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.AckRequest;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Enable;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Enabled;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Failed;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Resume;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.Resumed;\nimport org.jivesoftware.smack.sm.packet.StreamManagement.StreamManagementFeature;\nimport org.jivesoftware.smack.sm.predicates.Predicate;\nimport org.jivesoftware.smack.sm.provider.ParseStreamManagement;\nimport org.jivesoftware.smack.packet.PlainStreamElement;\nimport org.jivesoftware.smack.packet.XMPPError;\nimport org.jivesoftware.smack.util.ArrayBlockingQueueWithShutdown;\nimport org.jivesoftware.smack.util.Async;\nimport org.jivesoftware.smack.util.PacketParserUtils;\nimport org.jivesoftware.smack.util.StringUtils;\nimport org.jivesoftware.smack.util.TLSUtils;\nimport org.jivesoftware.smack.util.dns.HostAddress;\nimport org.jxmpp.util.XmppStringUtils;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.PasswordCallback;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.Provider;\nimport java.security.Security;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Creates a socket connection to an XMPP server. This is the default connection\n * to an XMPP server and is specified in the XMPP Core (RFC 6120).\n * \n * @see XMPPConnection\n * @author Matt Tucker\n */\npublic class XMPPTCPConnection extends AbstractXMPPConnection {\n\n    private static final int QUEUE_SIZE = 500;\n    private static final Logger LOGGER = Logger.getLogger(XMPPTCPConnection.class.getName());\n\n    /**\n     * The socket which is used for this connection.\n     */\n    private Socket socket;\n\n    /**\n     * \n     */\n    private boolean disconnectedButResumeable = false;\n\n    /**\n     * Flag to indicate if the socket was closed intentionally by Smack.\n     * <p>\n     * This boolean flag is used concurrently, therefore it is marked volatile.\n     * </p>\n     */\n    private volatile boolean socketClosed = false;\n\n    private boolean usingTLS = false;\n\n    /**\n     * Protected access level because of unit test purposes\n     */\n    protected PacketWriter packetWriter;\n\n    /**\n     * Protected access level because of unit test purposes\n     */\n    protected PacketReader packetReader;\n\n    private final SynchronizationPoint<Exception> initalOpenStreamSend = new SynchronizationPoint<Exception>(this);\n\n    /**\n     * \n     */\n    private final SynchronizationPoint<XMPPException> maybeCompressFeaturesReceived = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    /**\n     * \n     */\n    private final SynchronizationPoint<XMPPException> compressSyncPoint = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    /**\n     * The default bundle and defer callback, used for new connections.\n     * @see bundleAndDeferCallback\n     */\n    private static BundleAndDeferCallback defaultBundleAndDeferCallback;\n\n    /**\n     * The used bundle and defer callback.\n     * <p>\n     * Although this field may be set concurrently, the 'volatile' keyword was deliberately not added, in order to avoid\n     * having a 'volatile' read within the writer threads loop.\n     * </p>\n     */\n    private BundleAndDeferCallback bundleAndDeferCallback = defaultBundleAndDeferCallback;\n\n    private static boolean useSmDefault = false;\n\n    private static boolean useSmResumptionDefault = true;\n\n    /**\n     * The stream ID of the stream that is currently resumable, ie. the stream we hold the state\n     * for in {@link #clientHandledStanzasCount}, {@link #serverHandledStanzasCount} and\n     * {@link #unacknowledgedStanzas}.\n     */\n    private String smSessionId;\n\n    private final SynchronizationPoint<XMPPException> smResumedSyncPoint = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    private final SynchronizationPoint<XMPPException> smEnabledSyncPoint = new SynchronizationPoint<XMPPException>(\n                    this);\n\n    /**\n     * The client's preferred maximum resumption time in seconds.\n     */\n    private int smClientMaxResumptionTime = -1;\n\n    /**\n     * The server's preferred maximum resumption time in seconds.\n     */\n    private int smServerMaxResumptimTime = -1;\n\n    /**\n     * Indicates whether Stream Management (XEP-198) should be used if it's supported by the server.\n     */\n    private boolean useSm = useSmDefault;\n    private boolean useSmResumption = useSmResumptionDefault;\n\n    /**\n     * The counter that the server sends the client about it's current height. For example, if the server sends\n     * {@code <a h='42'/>}, then this will be set to 42 (while also handling the {@link #unacknowledgedStanzas} queue).\n     */\n    private long serverHandledStanzasCount = 0;\n\n    /**\n     * The counter for stanzas handled (\"received\") by the client.\n     * <p>\n     * Note that we don't need to synchronize this counter. Although JLS 17.7 states that reads and writes to longs are\n     * not atomic, it guarantees that there are at most 2 separate writes, one to each 32-bit half. And since\n     * {@link SMUtils#incrementHeight(long)} masks the lower 32 bit, we only operate on one half of the long and\n     * therefore have no concurrency problem because the read/write operations on one half are guaranteed to be atomic.\n     * </p>\n     */\n    private long clientHandledStanzasCount = 0;\n\n    private BlockingQueue<Stanza> unacknowledgedStanzas;\n\n    /**\n     * Set to true if Stream Management was at least once enabled for this connection.\n     */\n    private boolean smWasEnabledAtLeastOnce = false;\n\n    /**\n     * This listeners are invoked for every stanza that got acknowledged.\n     * <p>\n     * We use a {@link ConccurrentLinkedQueue} here in order to allow the listeners to remove\n     * themselves after they have been invoked.\n     * </p>\n     */\n    private final Collection<StanzaListener> stanzaAcknowledgedListeners = new ConcurrentLinkedQueue<StanzaListener>();\n\n    /**\n     * This listeners are invoked for a acknowledged stanza that has the given stanza ID. They will\n     * only be invoked once and automatically removed after that.\n     */\n    private final Map<String, StanzaListener> stanzaIdAcknowledgedListeners = new ConcurrentHashMap<String, StanzaListener>();\n\n    /**\n     * Predicates that determine if an stream management ack should be requested from the server.\n     * <p>\n     * We use a linked hash set here, so that the order how the predicates are added matches the\n     * order in which they are invoked in order to determine if an ack request should be send or not.\n     * </p>\n     */\n    private final Set<StanzaFilter> requestAckPredicates = new LinkedHashSet<StanzaFilter>();\n\n    private final XMPPTCPConnectionConfiguration config;\n\n    /**\n     * Creates a new XMPP connection over TCP (optionally using proxies).\n     * <p>\n     * Note that XMPPTCPConnection constructors do not establish a connection to the server\n     * and you must call {@link #connect()}.\n     * </p>\n     *\n     * @param config the connection configuration.\n     */\n    public XMPPTCPConnection(XMPPTCPConnectionConfiguration config) {\n        super(config);\n        this.config = config;\n        addConnectionListener(new AbstractConnectionListener() {\n            @Override\n            public void connectionClosedOnError(Exception e) {\n                if (e instanceof XMPPException.StreamErrorException) {\n                    dropSmState();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates a new XMPP connection over TCP.\n     * <p>\n     * Note that {@code jid} must be the bare JID, e.g. \"user@example.org\". More fine-grained control over the\n     * connection settings is available using the {@link #XMPPTCPConnection(XMPPTCPConnectionConfiguration)}\n     * constructor.\n     * </p>\n     * \n     * @param jid the bare JID used by the client.\n     * @param password the password or authentication token.\n     */\n    public XMPPTCPConnection(CharSequence jid, String password) {\n        this(XmppStringUtils.parseLocalpart(jid.toString()), password, XmppStringUtils.parseDomain(jid.toString()));\n    }\n\n    /**\n     * Creates a new XMPP connection over TCP.\n     * <p>\n     * This is the simplest constructor for connecting to an XMPP server. Alternatively,\n     * you can get fine-grained control over connection settings using the\n     * {@link #XMPPTCPConnection(XMPPTCPConnectionConfiguration)} constructor.\n     * </p>\n     * @param username\n     * @param password\n     * @param serviceName\n     */\n    public XMPPTCPConnection(CharSequence username, String password, String serviceName) {\n        this(XMPPTCPConnectionConfiguration.builder().setUsernameAndPassword(username, password).setServiceName(\n                                        serviceName).build());\n    }\n\n    @Override\n    protected void throwNotConnectedExceptionIfAppropriate() throws NotConnectedException {\n        if (packetWriter == null) {\n            throw new NotConnectedException();\n        }\n        packetWriter.throwNotConnectedExceptionIfDoneAndResumptionNotPossible();\n    }\n\n    @Override\n    protected void throwAlreadyConnectedExceptionIfAppropriate() throws AlreadyConnectedException {\n        if (isConnected() && !disconnectedButResumeable) {\n            throw new AlreadyConnectedException();\n        }\n    }\n\n    @Override\n    protected void throwAlreadyLoggedInExceptionIfAppropriate() throws AlreadyLoggedInException {\n        if (isAuthenticated() && !disconnectedButResumeable) {\n            throw new AlreadyLoggedInException();\n        }\n    }\n\n    @Override\n    protected void afterSuccessfulLogin(final boolean resumed) throws NotConnectedException {\n        // Reset the flag in case it was set\n        disconnectedButResumeable = false;\n        super.afterSuccessfulLogin(resumed);\n    }\n\n    @Override\n    protected synchronized void loginNonAnonymously(String username, String password, String resource) throws XMPPException, SmackException, IOException {\n        if (saslAuthentication.hasNonAnonymousAuthentication()) {\n            // Authenticate using SASL\n            if (password != null) {\n                saslAuthentication.authenticate(username, password, resource);\n            }\n            else {\n                saslAuthentication.authenticate(resource, config.getCallbackHandler());\n            }\n        } else {\n            throw new SmackException(\"No non-anonymous SASL authentication mechanism available\");\n        }\n\n        // If compression is enabled then request the server to use stream compression. XEP-170\n        // recommends to perform stream compression before resource binding.\n        if (config.isCompressionEnabled()) {\n            useCompression();\n        }\n\n        if (isSmResumptionPossible()) {\n            smResumedSyncPoint.sendAndWaitForResponse(new Resume(clientHandledStanzasCount, smSessionId));\n            if (smResumedSyncPoint.wasSuccessful()) {\n                // We successfully resumed the stream, be done here\n                afterSuccessfulLogin(true);\n                return;\n            }\n            // SM resumption failed, what Smack does here is to report success of\n            // lastFeaturesReceived in case of sm resumption was answered with 'failed' so that\n            // normal resource binding can be tried.\n            LOGGER.fine(\"Stream resumption failed, continuing with normal stream establishment process\");\n        }\n\n        List<Stanza> previouslyUnackedStanzas = new LinkedList<Stanza>();\n        if (unacknowledgedStanzas != null) {\n            // There was a previous connection with SM enabled but that was either not resumable or\n            // failed to resume. Make sure that we (re-)send the unacknowledged stanzas.\n            unacknowledgedStanzas.drainTo(previouslyUnackedStanzas);\n            // Reset unacknowledged stanzas to 'null' to signal that we never send 'enable' in this\n            // XMPP session (There maybe was an enabled in a previous XMPP session of this\n            // connection instance though). This is used in writePackets to decide if stanzas should\n            // be added to the unacknowledged stanzas queue, because they have to be added right\n            // after the 'enable' stream element has been sent.\n            dropSmState();\n        }\n\n        // Now bind the resource. It is important to do this *after* we dropped an eventually\n        // existing Stream Management state. As otherwise <bind/> and <session/> may end up in\n        // unacknowledgedStanzas and become duplicated on reconnect. See SMACK-706.\n        bindResourceAndEstablishSession(resource);\n\n        if (isSmAvailable() && useSm) {\n            // Remove what is maybe left from previously stream managed sessions\n            serverHandledStanzasCount = 0;\n            // XEP-198 3. Enabling Stream Management. If the server response to 'Enable' is 'Failed'\n            // then this is a non recoverable error and we therefore throw an exception.\n            smEnabledSyncPoint.sendAndWaitForResponseOrThrow(new Enable(useSmResumption, smClientMaxResumptionTime));\n            synchronized (requestAckPredicates) {\n                if (requestAckPredicates.isEmpty()) {\n                    // Assure that we have at lest one predicate set up that so that we request acks\n                    // for the server and eventually flush some stanzas from the unacknowledged\n                    // stanza queue\n                    requestAckPredicates.add(Predicate.forMessagesOrAfter5Stanzas());\n                }\n            }\n        }\n        // (Re-)send the stanzas *after* we tried to enable SM\n        for (Stanza stanza : previouslyUnackedStanzas) {\n            sendStanzaInternal(stanza);\n        }\n\n        afterSuccessfulLogin(false);\n    }\n\n    @Override\n    public synchronized void loginAnonymously() throws XMPPException, SmackException, IOException {\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        if (saslAuthentication.hasAnonymousAuthentication()) {\n            saslAuthentication.authenticateAnonymously();\n        }\n        else {\n            throw new SmackException(\"No anonymous SASL authentication mechanism available\");\n        }\n\n        // If compression is enabled then request the server to use stream compression\n        if (config.isCompressionEnabled()) {\n            useCompression();\n        }\n\n        bindResourceAndEstablishSession(null);\n\n        afterSuccessfulLogin(false);\n    }\n\n    @Override\n    public boolean isSecureConnection() {\n        return usingTLS;\n    }\n\n    public boolean isSocketClosed() {\n        return socketClosed;\n    }\n\n    /**\n     * Shuts the current connection down. After this method returns, the connection must be ready\n     * for re-use by connect.\n     */\n    @Override\n    protected void shutdown() {\n        if (isSmEnabled()) {\n            try {\n                // Try to send a last SM Acknowledgement. Most servers won't find this information helpful, as the SM\n                // state is dropped after a clean disconnect anyways. OTOH it doesn't hurt much either.\n                sendSmAcknowledgementInternal();\n            } catch (NotConnectedException e) {\n                LOGGER.log(Level.FINE, \"Can not send final SM ack as connection is not connected\", e);\n            }\n        }\n        shutdown(false);\n    }\n\n    /**\n     * Performs an unclean disconnect and shutdown of the connection. Does not send a closing stream stanza.\n     */\n    public synchronized void instantShutdown() {\n        shutdown(true);\n    }\n\n    private void shutdown(boolean instant) {\n        if (disconnectedButResumeable) {\n            return;\n        }\n        if (packetReader != null) {\n                packetReader.shutdown();\n        }\n        if (packetWriter != null) {\n                packetWriter.shutdown(instant);\n        }\n\n        // Set socketClosed to true. This will cause the PacketReader\n        // and PacketWriter to ignore any Exceptions that are thrown\n        // because of a read/write from/to a closed stream.\n        // It is *important* that this is done before socket.close()!\n        socketClosed = true;\n        try {\n                socket.close();\n        } catch (Exception e) {\n                LOGGER.log(Level.WARNING, \"shutdown\", e);\n        }\n\n        setWasAuthenticated();\n        // If we are able to resume the stream, then don't set\n        // connected/authenticated/usingTLS to false since we like behave like we are still\n        // connected (e.g. sendStanza should not throw a NotConnectedException).\n        if (isSmResumptionPossible() && instant) {\n            disconnectedButResumeable = true;\n        } else {\n            disconnectedButResumeable = false;\n            // Reset the stream management session id to null, since if the stream is cleanly closed, i.e. sending a closing\n            // stream tag, there is no longer a stream to resume.\n            smSessionId = null;\n        }\n        authenticated = false;\n        connected = false;\n        usingTLS = false;\n        reader = null;\n        writer = null;\n\n        maybeCompressFeaturesReceived.init();\n        compressSyncPoint.init();\n        smResumedSyncPoint.init();\n        smEnabledSyncPoint.init();\n        initalOpenStreamSend.init();\n    }\n\n    @Override\n    public void send(PlainStreamElement element) throws NotConnectedException {\n        packetWriter.sendStreamElement(element);\n    }\n\n    @Override\n    protected void sendStanzaInternal(Stanza packet) throws NotConnectedException {\n        packetWriter.sendStreamElement(packet);\n        if (isSmEnabled()) {\n            for (StanzaFilter requestAckPredicate : requestAckPredicates) {\n                if (requestAckPredicate.accept(packet)) {\n                    requestSmAcknowledgementInternal();\n                    break;\n                }\n            }\n        }\n    }\n\n    private void connectUsingConfiguration() throws IOException, ConnectionException {\n        List<HostAddress> failedAddresses = populateHostAddresses();\n        SocketFactory socketFactory = config.getSocketFactory();\n        if (socketFactory == null) {\n            socketFactory = SocketFactory.getDefault();\n        }\n        for (HostAddress hostAddress : hostAddresses) {\n            String host = hostAddress.getFQDN();\n            int port = hostAddress.getPort();\n            socket = socketFactory.createSocket();\n            try {\n                Iterator<InetAddress> inetAddresses = Arrays.asList(InetAddress.getAllByName(host)).iterator();\n                if (!inetAddresses.hasNext()) {\n                    // This should not happen\n                    LOGGER.warning(\"InetAddress.getAllByName() returned empty result array.\");\n                    throw new UnknownHostException(host);\n                }\n                innerloop: while (inetAddresses.hasNext()) {\n                    // Create a *new* Socket before every connection attempt, i.e. connect() call, since Sockets are not\n                    // re-usable after a failed connection attempt. See also SMACK-724.\n                    socket = socketFactory.createSocket();\n\n                    final InetAddress inetAddress = inetAddresses.next();\n                    final String inetAddressAndPort = inetAddress + \" at port \" + port;\n                    LOGGER.finer(\"Trying to establish TCP connection to \" + inetAddressAndPort);\n                    try {\n                        socket.connect(new InetSocketAddress(inetAddress, port), config.getConnectTimeout());\n                    } catch (Exception e) {\n                        if (inetAddresses.hasNext()) {\n                            continue innerloop;\n                        } else {\n                            throw e;\n                        }\n                    }\n                    LOGGER.finer(\"Established TCP connection to \" + inetAddressAndPort);\n                    // We found a host to connect to, return here\n                    this.host = host;\n                    this.port = port;\n                    return;\n                }\n            }\n            catch (Exception e) {\n                hostAddress.setException(e);\n                failedAddresses.add(hostAddress);\n            }\n        }\n        // There are no more host addresses to try\n        // throw an exception and report all tried\n        // HostAddresses in the exception\n        throw ConnectionException.from(failedAddresses);\n    }\n\n    /**\n     * Initializes the connection by creating a stanza(/packet) reader and writer and opening a\n     * XMPP stream to the server.\n     *\n     * @throws XMPPException if establishing a connection to the server fails.\n     * @throws SmackException if the server failes to respond back or if there is anther error.\n     * @throws IOException \n     */\n    private void initConnection() throws IOException {\n        boolean isFirstInitialization = packetReader == null || packetWriter == null;\n        compressionHandler = null;\n\n        // Set the reader and writer instance variables\n        initReaderAndWriter();\n\n        if (isFirstInitialization) {\n            packetWriter = new PacketWriter();\n            packetReader = new PacketReader();\n\n            // If debugging is enabled, we should start the thread that will listen for\n            // all packets and then log them.\n            if (config.isDebuggerEnabled()) {\n                addAsyncStanzaListener(debugger.getReaderListener(), null);\n                if (debugger.getWriterListener() != null) {\n                    addPacketSendingListener(debugger.getWriterListener(), null);\n                }\n            }\n        }\n        // Start the packet writer. This will open an XMPP stream to the server\n        packetWriter.init();\n        // Start the packet reader. The startup() method will block until we\n        // get an opening stream packet back from server\n        packetReader.init();\n\n        if (isFirstInitialization) {\n            // Notify listeners that a new connection has been established\n            for (ConnectionCreationListener listener : getConnectionCreationListeners()) {\n                listener.connectionCreated(this);\n            }\n        }\n    }\n\n    private void initReaderAndWriter() throws IOException {\n        InputStream is = socket.getInputStream();\n        OutputStream os = socket.getOutputStream();\n        if (compressionHandler != null) {\n            is = compressionHandler.getInputStream(is);\n            os = compressionHandler.getOutputStream(os);\n        }\n        // OutputStreamWriter is already buffered, no need to wrap it into a BufferedWriter\n        writer = new OutputStreamWriter(os, \"UTF-8\");\n        reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n\n        // If debugging is enabled, we open a window and write out all network traffic.\n        initDebugger();\n    }\n\n    /**\n     * The server has indicated that TLS negotiation can start. We now need to secure the\n     * existing plain connection and perform a handshake. This method won't return until the\n     * connection has finished the handshake or an error occurred while securing the connection.\n     * @throws IOException \n     * @throws CertificateException \n     * @throws NoSuchAlgorithmException \n     * @throws NoSuchProviderException \n     * @throws KeyStoreException \n     * @throws UnrecoverableKeyException \n     * @throws KeyManagementException \n     * @throws SmackException \n     * @throws Exception if an exception occurs.\n     */\n    private void proceedTLSReceived() throws NoSuchAlgorithmException, CertificateException, IOException, KeyStoreException, NoSuchProviderException, UnrecoverableKeyException, KeyManagementException, SmackException {\n        SSLContext context = this.config.getCustomSSLContext();\n        KeyStore ks = null;\n        KeyManager[] kms = null;\n        PasswordCallback pcb = null;\n\n        if(config.getCallbackHandler() == null) {\n           ks = null;\n        } else if (context == null) {\n            if(config.getKeystoreType().equals(\"NONE\")) {\n                ks = null;\n                pcb = null;\n            }\n            else if(config.getKeystoreType().equals(\"PKCS11\")) {\n                try {\n                    Constructor<?> c = Class.forName(\"sun.security.pkcs11.SunPKCS11\").getConstructor(InputStream.class);\n                    String pkcs11Config = \"name = SmartCard\\nlibrary = \"+config.getPKCS11Library();\n                    ByteArrayInputStream config = new ByteArrayInputStream(pkcs11Config.getBytes());\n                    Provider p = (Provider)c.newInstance(config);\n                    Security.addProvider(p);\n                    ks = KeyStore.getInstance(\"PKCS11\",p);\n                    pcb = new PasswordCallback(\"PKCS11 Password: \",false);\n                    this.config.getCallbackHandler().handle(new Callback[]{pcb});\n                    ks.load(null,pcb.getPassword());\n                }\n                catch (Exception e) {\n                    ks = null;\n                    pcb = null;\n                }\n            }\n            else if(config.getKeystoreType().equals(\"Apple\")) {\n                ks = KeyStore.getInstance(\"KeychainStore\",\"Apple\");\n                ks.load(null,null);\n                //pcb = new PasswordCallback(\"Apple Keychain\",false);\n                //pcb.setPassword(null);\n            }\n            else {\n                ks = KeyStore.getInstance(config.getKeystoreType());\n                try {\n                    pcb = new PasswordCallback(\"Keystore Password: \",false);\n                    config.getCallbackHandler().handle(new Callback[]{pcb});\n                    ks.load(new FileInputStream(config.getKeystorePath()), pcb.getPassword());\n                }\n                catch(Exception e) {\n                    ks = null;\n                    pcb = null;\n                }\n            }\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n            try {\n                if(pcb == null) {\n                    kmf.init(ks,null);\n                } else {\n                    kmf.init(ks,pcb.getPassword());\n                    pcb.clearPassword();\n                }\n                kms = kmf.getKeyManagers();\n            } catch (NullPointerException npe) {\n                kms = null;\n            }\n        }\n\n        // If the user didn't specify a SSLContext, use the default one\n        if (context == null) {\n            context = SSLContext.getInstance(\"TLS\");\n            context.init(kms, null, new java.security.SecureRandom());\n        }\n        Socket plain = socket;\n        // Secure the plain connection\n        socket = context.getSocketFactory().createSocket(plain,\n                host, plain.getPort(), true);\n\n        final SSLSocket sslSocket = (SSLSocket) socket;\n        // Immediately set the enabled SSL protocols and ciphers. See SMACK-712 why this is\n        // important (at least on certain platforms) and it seems to be a good idea anyways to\n        // prevent an accidental implicit handshake.\n        TLSUtils.setEnabledProtocolsAndCiphers(sslSocket, config.getEnabledSSLProtocols(), config.getEnabledSSLCiphers());\n\n        // Initialize the reader and writer with the new secured version\n        initReaderAndWriter();\n\n        // Proceed to do the handshake\n        sslSocket.startHandshake();\n\n        final HostnameVerifier verifier = getConfiguration().getHostnameVerifier();\n        if (verifier == null) {\n                throw new IllegalStateException(\"No HostnameVerifier set. Use connectionConfiguration.setHostnameVerifier() to configure.\");\n        } else if (!verifier.verify(getServiceName(), sslSocket.getSession())) {\n            throw new CertificateException(\"Hostname verification of certificate failed. Certificate does not authenticate \" + getServiceName());\n        }\n\n        // Set that TLS was successful\n        usingTLS = true;\n    }\n\n    /**\n     * Returns the compression handler that can be used for one compression methods offered by the server.\n     * \n     * @return a instance of XMPPInputOutputStream or null if no suitable instance was found\n     * \n     */\n    private XMPPInputOutputStream maybeGetCompressionHandler() {\n        Compress.Feature compression = getFeature(Compress.Feature.ELEMENT, Compress.NAMESPACE);\n        if (compression == null) {\n            // Server does not support compression\n            return null;\n        }\n        for (XMPPInputOutputStream handler : SmackConfiguration.getCompresionHandlers()) {\n                String method = handler.getCompressionMethod();\n                if (compression.getMethods().contains(method))\n                    return handler;\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isUsingCompression() {\n        return compressionHandler != null && compressSyncPoint.wasSuccessful();\n    }\n\n    /**\n     * <p>\n     * Starts using stream compression that will compress network traffic. Traffic can be\n     * reduced up to 90%. Therefore, stream compression is ideal when using a slow speed network\n     * connection. However, the server and the client will need to use more CPU time in order to\n     * un/compress network data so under high load the server performance might be affected.\n     * </p>\n     * <p>\n     * Stream compression has to have been previously offered by the server. Currently only the\n     * zlib method is supported by the client. Stream compression negotiation has to be done\n     * before authentication took place.\n     * </p>\n     *\n     * @throws NotConnectedException \n     * @throws XMPPException \n     * @throws NoResponseException \n     */\n    private void useCompression() throws NotConnectedException, NoResponseException, XMPPException {\n        maybeCompressFeaturesReceived.checkIfSuccessOrWait();\n        // If stream compression was offered by the server and we want to use\n        // compression then send compression request to the server\n        if ((compressionHandler = maybeGetCompressionHandler()) != null) {\n            compressSyncPoint.sendAndWaitForResponseOrThrow(new Compress(compressionHandler.getCompressionMethod()));\n        } else {\n            LOGGER.warning(\"Could not enable compression because no matching handler/method pair was found\");\n        }\n    }\n\n    /**\n     * Establishes a connection to the XMPP server and performs an automatic login\n     * only if the previous connection state was logged (authenticated). It basically\n     * creates and maintains a socket connection to the server.<p>\n     * <p/>\n     * Listeners will be preserved from a previous connection if the reconnection\n     * occurs after an abrupt termination.\n     *\n     * @throws XMPPException if an error occurs while trying to establish the connection.\n     * @throws SmackException \n     * @throws IOException \n     */\n    @Override\n    protected void connectInternal() throws SmackException, IOException, XMPPException {\n        // Establishes the TCP connection to the server and does setup the reader and writer. Throws an exception if\n        // there is an error establishing the connection\n        connectUsingConfiguration();\n\n        // We connected successfully to the servers TCP port\n        socketClosed = false;\n        initConnection();\n\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        // If TLS is required but the server doesn't offer it, disconnect\n        // from the server and throw an error. First check if we've already negotiated TLS\n        // and are secure, however (features get parsed a second time after TLS is established).\n        if (!isSecureConnection() && getConfiguration().getSecurityMode() == SecurityMode.required) {\n            shutdown();\n            throw new SecurityRequiredByClientException();\n        }\n\n        // Make note of the fact that we're now connected.\n        connected = true;\n        callConnectionConnectedListener();\n\n        // Automatically makes the login if the user was previously connected successfully\n        // to the server and the connection was terminated abruptly\n        if (wasAuthenticated) {\n            login();\n            notifyReconnection();\n        }\n    }\n\n    /**\n     * Sends out a notification that there was an error with the connection\n     * and closes the connection. Also prints the stack trace of the given exception\n     *\n     * @param e the exception that causes the connection close event.\n     */\n    private synchronized void notifyConnectionError(Exception e) {\n        // Listeners were already notified of the exception, return right here.\n        if ((packetReader == null || packetReader.done) &&\n                (packetWriter == null || packetWriter.done())) return;\n\n        // Closes the connection temporary. A reconnection is possible\n        instantShutdown();\n\n        // Notify connection listeners of the error.\n        callConnectionClosedOnErrorListener(e);\n    }\n\n    /**\n     * For unit testing purposes\n     *\n     * @param writer\n     */\n    protected void setWriter(Writer writer) {\n        this.writer = writer;\n    }\n\n    @Override\n    protected void afterFeaturesReceived() throws NotConnectedException {\n        StartTls startTlsFeature = getFeature(StartTls.ELEMENT, StartTls.NAMESPACE);\n        if (startTlsFeature != null) {\n            if (startTlsFeature.required() && config.getSecurityMode() == SecurityMode.disabled) {\n                notifyConnectionError(new SecurityRequiredByServerException());\n                return;\n            }\n\n            if (config.getSecurityMode() != ConnectionConfiguration.SecurityMode.disabled) {\n                send(new StartTls());\n            }\n        }\n\n        if (getSASLAuthentication().authenticationSuccessful()) {\n            // If we have received features after the SASL has been successfully completed, then we\n            // have also *maybe* received, as it is an optional feature, the compression feature\n            // from the server.\n            maybeCompressFeaturesReceived.reportSuccess();\n        }\n    }\n\n    /**\n     * Resets the parser using the latest connection's reader. Reseting the parser is necessary\n     * when the plain connection has been secured or when a new opening stream element is going\n     * to be sent by the server.\n     *\n     * @throws SmackException if the parser could not be reset.\n     */\n    void openStream() throws SmackException {\n        // If possible, provide the receiving entity of the stream open tag, i.e. the server, as much information as\n        // possible. The 'to' attribute is *always* available. The 'from' attribute if set by the user and no external\n        // mechanism is used to determine the local entity (user). And the 'id' attribute is available after the first\n        // response from the server (see e.g. RFC 6120 \u00a7 9.1.1 Step 2.)\n        CharSequence to = getServiceName();\n        CharSequence from = null;\n        CharSequence localpart = config.getUsername();\n        if (localpart != null) {\n            from = XmppStringUtils.completeJidFrom(localpart, to);\n        }\n        String id = getStreamId();\n        send(new StreamOpen(to, from, id));\n        try {\n            packetReader.parser = PacketParserUtils.newXmppParser(reader);\n        }\n        catch (XmlPullParserException e) {\n            throw new SmackException(e);\n        }\n    }\n\n    protected class PacketReader {\n\n        XmlPullParser parser;\n\n        private volatile boolean done;\n\n        /**\n         * Initializes the reader in order to be used. The reader is initialized during the\n         * first connection and when reconnecting due to an abruptly disconnection.\n         */\n        void init() {\n            done = false;\n\n            Async.go(new Runnable() {\n                public void run() {\n                    parsePackets();\n                }\n            }, \"Smack Packet Reader (\" + getConnectionCounter() + \")\");\n         }\n\n        /**\n         * Shuts the stanza(/packet) reader down. This method simply sets the 'done' flag to true.\n         */\n        void shutdown() {\n            done = true;\n        }\n\n        /**\n         * Parse top-level packets in order to process them further.\n         *\n         * @param thread the thread that is being used by the reader to parse incoming packets.\n         */\n        private void parsePackets() {\n            try {\n                initalOpenStreamSend.checkIfSuccessOrWait();\n                int eventType = parser.getEventType();\n                while (!done) {\n                    switch (eventType) {\n                    case XmlPullParser.START_TAG:\n                        final String name = parser.getName();\n                        switch (name) {\n                        case Message.ELEMENT:\n                        case IQ.IQ_ELEMENT:\n                        case Presence.ELEMENT:\n                            try {\n                                parseAndProcessStanza(parser);\n                            } finally {\n                                clientHandledStanzasCount = SMUtils.incrementHeight(clientHandledStanzasCount);\n                            }\n                            break;\n                        case \"stream\":\n                            // We found an opening stream.\n                            if (\"jabber:client\".equals(parser.getNamespace(null))) {\n                                streamId = parser.getAttributeValue(\"\", \"id\");\n                                String reportedServiceName = parser.getAttributeValue(\"\", \"from\");\n                                assert(reportedServiceName.equals(config.getServiceName()));\n                            }\n                            break;\n                        case \"error\":\n                            throw new StreamErrorException(PacketParserUtils.parseStreamError(parser));\n                        case \"features\":\n                            parseFeatures(parser);\n                            break;\n                        case \"proceed\":\n                            try {\n                                // Secure the connection by negotiating TLS\n                                proceedTLSReceived();\n                                // Send a new opening stream to the server\n                                openStream();\n                            }\n                            catch (Exception e) {\n                                // We report any failure regarding TLS in the second stage of XMPP\n                                // connection establishment, namely the SASL authentication\n                                saslFeatureReceived.reportFailure(new SmackException(e));\n                                throw e;\n                            }\n                            break;\n                        case \"failure\":\n                            String namespace = parser.getNamespace(null);\n                            switch (namespace) {\n                            case \"urn:ietf:params:xml:ns:xmpp-tls\":\n                                // TLS negotiation has failed. The server will close the connection\n                                // TODO Parse failure stanza\n                                throw new XMPPErrorException(\"TLS negotiation has failed\", null);\n                            case \"http://jabber.org/protocol/compress\":\n                                // Stream compression has been denied. This is a recoverable\n                                // situation. It is still possible to authenticate and\n                                // use the connection but using an uncompressed connection\n                                // TODO Parse failure stanza\n                                compressSyncPoint.reportFailure(new XMPPErrorException(\n                                                \"Could not establish compression\", null));\n                                break;\n                            case SaslStreamElements.NAMESPACE:\n                                // SASL authentication has failed. The server may close the connection\n                                // depending on the number of retries\n                                final SASLFailure failure = PacketParserUtils.parseSASLFailure(parser);\n                                getSASLAuthentication().authenticationFailed(failure);\n                                break;\n                            }\n                            break;\n                        case Challenge.ELEMENT:\n                            // The server is challenging the SASL authentication made by the client\n                            String challengeData = parser.nextText();\n                            getSASLAuthentication().challengeReceived(challengeData);\n                            break;\n                        case Success.ELEMENT:\n                            Success success = new Success(parser.nextText());\n                            // We now need to bind a resource for the connection\n                            // Open a new stream and wait for the response\n                            openStream();\n                            // The SASL authentication with the server was successful. The next step\n                            // will be to bind the resource\n                            getSASLAuthentication().authenticated(success);\n                            break;\n                        case Compressed.ELEMENT:\n                            // Server confirmed that it's possible to use stream compression. Start\n                            // stream compression\n                            // Initialize the reader and writer with the new compressed version\n                            initReaderAndWriter();\n                            // Send a new opening stream to the server\n                            openStream();\n                            // Notify that compression is being used\n                            compressSyncPoint.reportSuccess();\n                            break;\n                        case Enabled.ELEMENT:\n                            Enabled enabled = ParseStreamManagement.enabled(parser);\n                            if (enabled.isResumeSet()) {\n                                smSessionId = enabled.getId();\n                                if (StringUtils.isNullOrEmpty(smSessionId)) {\n                                    XMPPErrorException xmppException = new XMPPErrorException(\n                                                    \"Stream Management 'enabled' element with resume attribute but without session id received\",\n                                                    new XMPPError(\n                                                                    XMPPError.Condition.bad_request));\n                                    smEnabledSyncPoint.reportFailure(xmppException);\n                                    throw xmppException;\n                                }\n                                smServerMaxResumptimTime = enabled.getMaxResumptionTime();\n                            } else {\n                                // Mark this a non-resumable stream by setting smSessionId to null\n                                smSessionId = null;\n                            }\n                            clientHandledStanzasCount = 0;\n                            smWasEnabledAtLeastOnce = true;\n                            smEnabledSyncPoint.reportSuccess();\n                            LOGGER.fine(\"Stream Management (XEP-198): succesfully enabled\");\n                            break;\n                        case Failed.ELEMENT:\n                            Failed failed = ParseStreamManagement.failed(parser);\n                            XMPPError xmppError = new XMPPError(failed.getXMPPErrorCondition());\n                            XMPPException xmppException = new XMPPErrorException(\"Stream Management failed\", xmppError);\n                            // If only XEP-198 would specify different failure elements for the SM\n                            // enable and SM resume failure case. But this is not the case, so we\n                            // need to determine if this is a 'Failed' response for either 'Enable'\n                            // or 'Resume'.\n                            if (smResumedSyncPoint.requestSent()) {\n                                smResumedSyncPoint.reportFailure(xmppException);\n                            }\n                            else {\n                                if (!smEnabledSyncPoint.requestSent()) {\n                                    throw new IllegalStateException(\"Failed element received but SM was not previously enabled\");\n                                }\n                                smEnabledSyncPoint.reportFailure(xmppException);\n                                // Report success for last lastFeaturesReceived so that in case a\n                                // failed resumption, we can continue with normal resource binding.\n                                // See text of XEP-198 5. below Example 11.\n                                lastFeaturesReceived.reportSuccess();\n                            }\n                            break;\n                        case Resumed.ELEMENT:\n                            Resumed resumed = ParseStreamManagement.resumed(parser);\n                            if (!smSessionId.equals(resumed.getPrevId())) {\n                                throw new StreamIdDoesNotMatchException(smSessionId, resumed.getPrevId());\n                            }\n                            // Mark SM as enabled and resumption as successful.\n                            smResumedSyncPoint.reportSuccess();\n                            smEnabledSyncPoint.reportSuccess();\n                            // First, drop the stanzas already handled by the server\n                            processHandledCount(resumed.getHandledCount());\n                            // Then re-send what is left in the unacknowledged queue\n                            List<Stanza> stanzasToResend = new ArrayList<>(unacknowledgedStanzas.size());\n                            unacknowledgedStanzas.drainTo(stanzasToResend);\n                            for (Stanza stanza : stanzasToResend) {\n                                sendStanzaInternal(stanza);\n                            }\n                            // If there where stanzas resent, then request a SM ack for them.\n                            // Writer's sendStreamElement() won't do it automatically based on\n                            // predicates.\n                            if (!stanzasToResend.isEmpty()) {\n                                requestSmAcknowledgementInternal();\n                            }\n                            LOGGER.fine(\"Stream Management (XEP-198): Stream resumed\");\n                            break;\n                        case AckAnswer.ELEMENT:\n                            AckAnswer ackAnswer = ParseStreamManagement.ackAnswer(parser);\n                            processHandledCount(ackAnswer.getHandledCount());\n                            break;\n                        case AckRequest.ELEMENT:\n                            ParseStreamManagement.ackRequest(parser);\n                            if (smEnabledSyncPoint.wasSuccessful()) {\n                                sendSmAcknowledgementInternal();\n                            } else {\n                                LOGGER.warning(\"SM Ack Request received while SM is not enabled\");\n                            }\n                            break;\n                         default:\n                             LOGGER.warning(\"Unknown top level stream element: \" + name);\n                             break;\n                        }\n                        break;\n                    case XmlPullParser.END_TAG:\n                        if (parser.getName().equals(\"stream\")) {\n                            // Disconnect the connection\n                            disconnect();\n                        }\n                        break;\n                    case XmlPullParser.END_DOCUMENT:\n                        // END_DOCUMENT only happens in an error case, as otherwise we would see a\n                        // closing stream element before.\n                        throw new SmackException(\n                                        \"Parser got END_DOCUMENT event. This could happen e.g. if the server closed the connection without sending a closing stream element\");\n                    }\n                    eventType = parser.next();\n                }\n            }\n            catch (Exception e) {\n                // The exception can be ignored if the the connection is 'done'\n                // or if the it was caused because the socket got closed\n                if (!(done || isSocketClosed())) {\n                    // Close the connection and notify connection listeners of the\n                    // error.\n                    notifyConnectionError(e);\n                }\n            }\n        }\n    }\n\n    protected class PacketWriter {\n        public static final int QUEUE_SIZE = XMPPTCPConnection.QUEUE_SIZE;\n\n        private final ArrayBlockingQueueWithShutdown<Element> queue = new ArrayBlockingQueueWithShutdown<Element>(\n                        QUEUE_SIZE, true);\n\n        /**\n         * Needs to be protected for unit testing purposes.\n         */\n        protected SynchronizationPoint<NoResponseException> shutdownDone = new SynchronizationPoint<NoResponseException>(\n                        XMPPTCPConnection.this);\n\n        /**\n         * If set, the stanza(/packet) writer is shut down\n         */\n        protected volatile Long shutdownTimestamp = null;\n\n        private volatile boolean instantShutdown;\n\n        /**\n         * True if some preconditions are given to start the bundle and defer mechanism.\n         * <p>\n         * This will likely get set to true right after the start of the writer thread, because\n         * {@link #nextStreamElement()} will check if {@link queue} is empty, which is probably the case, and then set\n         * this field to true.\n         * </p>\n         */\n        private boolean shouldBundleAndDefer;\n\n        /** \n        * Initializes the writer in order to be used. It is called at the first connection and also \n        * is invoked if the connection is disconnected by an error.\n        */ \n        void init() {\n            shutdownDone.init();\n            shutdownTimestamp = null;\n\n            if (unacknowledgedStanzas != null) {\n                // It's possible that there are new stanzas in the writer queue that\n                // came in while we were disconnected but resumable, drain those into\n                // the unacknowledged queue so that they get resent now\n                drainWriterQueueToUnacknowledgedStanzas();\n            }\n\n            queue.start();\n            Async.go(new Runnable() {\n                @Override\n                public void run() {\n                    writePackets();\n                }\n            }, \"Smack Packet Writer (\" + getConnectionCounter() + \")\");\n        }\n\n        private boolean done() {\n            return shutdownTimestamp != null;\n        }\n\n        protected void throwNotConnectedExceptionIfDoneAndResumptionNotPossible() throws NotConnectedException {\n            if (done() && !isSmResumptionPossible()) {\n                // Don't throw a NotConnectedException is there is an resumable stream available\n                throw new NotConnectedException();\n            }\n        }\n\n        /**\n         * Sends the specified element to the server.\n         *\n         * @param element the element to send.\n         * @throws NotConnectedException \n         */\n        protected void sendStreamElement(Element element) throws NotConnectedException {\n            throwNotConnectedExceptionIfDoneAndResumptionNotPossible();\n\n            boolean enqueued = false;\n            while (!enqueued) {\n                try {\n                    queue.put(element);\n                    enqueued = true;\n                }\n                catch (InterruptedException e) {\n                    throwNotConnectedExceptionIfDoneAndResumptionNotPossible();\n                    // If the method above did not throw, then the sending thread was interrupted\n                    // TODO in a later version of Smack the InterruptedException should be thrown to\n                    // allow users to interrupt a sending thread that is currently blocking because\n                    // the queue is full.\n                    LOGGER.log(Level.WARNING, \"Sending thread was interrupted\", e);\n                }\n            }\n        }\n\n        /**\n         * Shuts down the stanza(/packet) writer. Once this method has been called, no further\n         * packets will be written to the server.\n         */\n        void shutdown(boolean instant) {\n            instantShutdown = instant;\n            shutdownTimestamp = System.currentTimeMillis();\n            queue.shutdown();\n            try {\n                shutdownDone.checkIfSuccessOrWait();\n            }\n            catch (NoResponseException e) {\n                LOGGER.log(Level.WARNING, \"shutdownDone was not marked as successful by the writer thread\", e);\n            }\n        }\n\n        /**\n         * Maybe return the next available element from the queue for writing. If the queue is shut down <b>or</b> a\n         * spurious interrupt occurs, <code>null</code> is returned. So it is important to check the 'done' condition in\n         * that case.\n         *\n         * @return the next element for writing or null.\n         */\n        private Element nextStreamElement() {\n            // It is important the we check if the queue is empty before removing an element from it\n            if (queue.isEmpty()) {\n                shouldBundleAndDefer = true;\n            }\n            Element packet = null;\n            try {\n                packet = queue.take();\n            }\n            catch (InterruptedException e) {\n                if (!queue.isShutdown()) {\n                    // Users shouldn't try to interrupt the packet writer thread\n                    LOGGER.log(Level.WARNING, \"Packet writer thread was interrupted. Don't do that. Use disconnect() instead.\", e);\n                }\n            }\n            return packet;\n        }\n\n        private void writePackets() {\n            try {\n                openStream();\n                initalOpenStreamSend.reportSuccess();\n                // Write out packets from the queue.\n                while (!done()) {\n                    Element element = nextStreamElement();\n                    if (element == null) {\n                        continue;\n                    }\n\n                    // Get a local version of the bundle and defer callback, in case it's unset\n                    // between the null check and the method invocation\n                    final BundleAndDeferCallback localBundleAndDeferCallback = bundleAndDeferCallback;\n                    // If the preconditions are given (e.g. bundleAndDefer callback is set, queue is\n                    // empty), then we could wait a bit for further stanzas attempting to decrease\n                    // our energy consumption\n                    if (localBundleAndDeferCallback != null && isAuthenticated() && shouldBundleAndDefer) {\n                        // Reset shouldBundleAndDefer to false, nextStreamElement() will set it to true once the\n                        // queue is empty again.\n                        shouldBundleAndDefer = false;\n                        final AtomicBoolean bundlingAndDeferringStopped = new AtomicBoolean();\n                        final int bundleAndDeferMillis = localBundleAndDeferCallback.getBundleAndDeferMillis(new BundleAndDefer(\n                                        bundlingAndDeferringStopped));\n                        if (bundleAndDeferMillis > 0) {\n                            long remainingWait = bundleAndDeferMillis;\n                            final long waitStart = System.currentTimeMillis();\n                            synchronized (bundlingAndDeferringStopped) {\n                                while (!bundlingAndDeferringStopped.get() && remainingWait > 0) {\n                                    bundlingAndDeferringStopped.wait(remainingWait);\n                                    remainingWait = bundleAndDeferMillis\n                                                    - (System.currentTimeMillis() - waitStart);\n                                }\n                            }\n                        }\n                    }\n\n                    Stanza packet = null;\n                    if (element instanceof Stanza) {\n                        packet = (Stanza) element;\n                    }\n                    else if (element instanceof Enable) {\n                        // The client needs to add messages to the unacknowledged stanzas queue\n                        // right after it sent 'enabled'. Stanza will be added once\n                        // unacknowledgedStanzas is not null.\n                        unacknowledgedStanzas = new ArrayBlockingQueue<>(QUEUE_SIZE);\n                    }\n                    // Check if the stream element should be put to the unacknowledgedStanza\n                    // queue. Note that we can not do the put() in sendStanzaInternal() and the\n                    // packet order is not stable at this point (sendStanzaInternal() can be\n                    // called concurrently).\n                    if (unacknowledgedStanzas != null && packet != null) {\n                        // If the unacknowledgedStanza queue is nearly full, request an new ack\n                        // from the server in order to drain it\n                        if (unacknowledgedStanzas.size() == 0.8 * XMPPTCPConnection.QUEUE_SIZE) {\n                            writer.write(AckRequest.INSTANCE.toXML().toString());\n                            writer.flush();\n                        }\n                        try {\n                            // It is important the we put the stanza in the unacknowledged stanza\n                            // queue before we put it on the wire\n                            unacknowledgedStanzas.put(packet);\n                        }\n                        catch (InterruptedException e) {\n                            throw new IllegalStateException(e);\n                        }\n                    }\n                    writer.write(element.toXML().toString());\n                    if (queue.isEmpty()) {\n                        writer.flush();\n                    }\n                    if (packet != null) {\n                        firePacketSendingListeners(packet);\n                    }\n                }\n                if (!instantShutdown) {\n                    // Flush out the rest of the queue.\n                    try {\n                        while (!queue.isEmpty()) {\n                            Element packet = queue.remove();\n                            writer.write(packet.toXML().toString());\n                        }\n                        writer.flush();\n                    }\n                    catch (Exception e) {\n                        LOGGER.log(Level.WARNING,\n                                        \"Exception flushing queue during shutdown, ignore and continue\",\n                                        e);\n                    }\n\n                    // Close the stream.\n                    try {\n                        writer.write(\"</stream:stream>\");\n                        writer.flush();\n                    }\n                    catch (Exception e) {\n                        LOGGER.log(Level.WARNING, \"Exception writing closing stream element\", e);\n                    }\n                    // Delete the queue contents (hopefully nothing is left).\n                    queue.clear();\n                } else if (instantShutdown && isSmEnabled()) {\n                    // This was an instantShutdown and SM is enabled, drain all remaining stanzas\n                    // into the unacknowledgedStanzas queue\n                    drainWriterQueueToUnacknowledgedStanzas();\n                }\n\n                try {\n                    writer.close();\n                }\n                catch (Exception e) {\n                    // Do nothing\n                }\n\n            }\n            catch (Exception e) {\n                // The exception can be ignored if the the connection is 'done'\n                // or if the it was caused because the socket got closed\n                if (!(done() || isSocketClosed())) {\n                    notifyConnectionError(e);\n                } else {\n                    LOGGER.log(Level.FINE, \"Ignoring Exception in writePackets()\", e);\n                }\n            } finally {\n                LOGGER.fine(\"Reporting shutdownDone success in writer thread\");\n                shutdownDone.reportSuccess();\n            }\n        }\n\n        private void drainWriterQueueToUnacknowledgedStanzas() {\n            List<Element> elements = new ArrayList<Element>(queue.size());\n            queue.drainTo(elements);\n            for (Element element : elements) {\n                if (element instanceof Stanza) {\n                    unacknowledgedStanzas.add((Stanza) element);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set if Stream Management should be used by default for new connections.\n     * \n     * @param useSmDefault true to use Stream Management for new connections.\n     */\n    public static void setUseStreamManagementDefault(boolean useSmDefault) {\n        XMPPTCPConnection.useSmDefault = useSmDefault;\n    }\n\n    /**\n     * Set if Stream Management resumption should be used by default for new connections.\n     * \n     * @param useSmResumptionDefault true to use Stream Management resumption for new connections.\n     * @deprecated use {@link #setUseStreamManagementResumptionDefault(boolean)} instead.\n     */\n    @Deprecated\n    public static void setUseStreamManagementResumptiodDefault(boolean useSmResumptionDefault) {\n        setUseStreamManagementResumptionDefault(useSmResumptionDefault);\n    }\n\n    /**\n     * Set if Stream Management resumption should be used by default for new connections.\n     *\n     * @param useSmResumptionDefault true to use Stream Management resumption for new connections.\n     */\n    public static void setUseStreamManagementResumptionDefault(boolean useSmResumptionDefault) {\n        if (useSmResumptionDefault) {\n            // Also enable SM is resumption is enabled\n            setUseStreamManagementDefault(useSmResumptionDefault);\n        }\n        XMPPTCPConnection.useSmResumptionDefault = useSmResumptionDefault;\n    }\n\n    /**\n     * Set if Stream Management should be used if supported by the server.\n     * \n     * @param useSm true to use Stream Management.\n     */\n    public void setUseStreamManagement(boolean useSm) {\n        this.useSm = useSm;\n    }\n\n    /**\n     * Set if Stream Management resumption should be used if supported by the server.\n     *\n     * @param useSmResumption true to use Stream Management resumption.\n     */\n    public void setUseStreamManagementResumption(boolean useSmResumption) {\n        if (useSmResumption) {\n            // Also enable SM is resumption is enabled\n            setUseStreamManagement(useSmResumption);\n        }\n        this.useSmResumption = useSmResumption;\n    }\n\n    /**\n     * Set the preferred resumption time in seconds.\n     * @param resumptionTime the preferred resumption time in seconds\n     */\n    public void setPreferredResumptionTime(int resumptionTime) {\n        smClientMaxResumptionTime = resumptionTime;\n    }\n\n    /**\n     * Add a predicate for Stream Management acknowledgment requests.\n     * <p>\n     * Those predicates are used to determine when a Stream Management acknowledgement request is send to the server.\n     * Some pre-defined predicates are found in the <code>org.jivesoftware.smack.sm.predicates</code> package.\n     * </p>\n     * <p>\n     * If not predicate is configured, the {@link Predicate#forMessagesOrAfter5Stanzas()} will be used.\n     * </p>\n     * \n     * @param predicate the predicate to add.\n     * @return if the predicate was not already active.\n     */\n    public boolean addRequestAckPredicate(StanzaFilter predicate) {\n        synchronized (requestAckPredicates) {\n            return requestAckPredicates.add(predicate);\n        }\n    }\n\n    /**\n     * Remove the given predicate for Stream Management acknowledgment request.\n     * @param predicate the predicate to remove.\n     * @return true if the predicate was removed.\n     */\n    public boolean removeRequestAckPredicate(StanzaFilter predicate) {\n        synchronized (requestAckPredicates) {\n            return requestAckPredicates.remove(predicate);\n        }\n    }\n\n    /**\n     * Remove all predicates for Stream Management acknowledgment requests.\n     */\n    public void removeAllRequestAckPredicates() {\n        synchronized (requestAckPredicates) {\n            requestAckPredicates.clear();\n        }\n    }\n\n    /**\n     * Send an unconditional Stream Management acknowledgement request to the server.\n     *\n     * @throws StreamManagementNotEnabledException if Stream Mangement is not enabled.\n     * @throws NotConnectedException if the connection is not connected.\n     */\n    public void requestSmAcknowledgement() throws StreamManagementNotEnabledException, NotConnectedException {\n        if (!isSmEnabled()) {\n            throw new StreamManagementException.StreamManagementNotEnabledException();\n        }\n        requestSmAcknowledgementInternal();\n    }\n\n    private void requestSmAcknowledgementInternal() throws NotConnectedException {\n        packetWriter.sendStreamElement(AckRequest.INSTANCE);\n    }\n\n    /**\n     * Send a unconditional Stream Management acknowledgment to the server.\n     * <p>\n     * See <a href=\"http://xmpp.org/extensions/xep-0198.html#acking\">XEP-198: Stream Management \u00a7 4. Acks</a>:\n     * \"Either party MAY send an <a/> element at any time (e.g., after it has received a certain number of stanzas,\n     * or after a certain period of time), even if it has not received an <r/> element from the other party.\"\n     * </p>\n     * \n     * @throws StreamManagementNotEnabledException if Stream Management is not enabled.\n     * @throws NotConnectedException if the connection is not connected.\n     */\n    public void sendSmAcknowledgement() throws StreamManagementNotEnabledException, NotConnectedException {\n        if (!isSmEnabled()) {\n            throw new StreamManagementException.StreamManagementNotEnabledException();\n        }\n        sendSmAcknowledgementInternal();\n    }\n\n    private void sendSmAcknowledgementInternal() throws NotConnectedException {\n        packetWriter.sendStreamElement(new AckAnswer(clientHandledStanzasCount));\n    }\n\n    /**\n     * Add a Stanza acknowledged listener.\n     * <p>\n     * Those listeners will be invoked every time a Stanza has been acknowledged by the server. The will not get\n     * automatically removed. Consider using {@link #addStanzaIdAcknowledgedListener(String, StanzaListener)} when\n     * possible.\n     * </p>\n     * \n     * @param listener the listener to add.\n     */\n    public void addStanzaAcknowledgedListener(StanzaListener listener) {\n        stanzaAcknowledgedListeners.add(listener);\n    }\n\n    /**\n     * Remove the given Stanza acknowledged listener.\n     *\n     * @param listener the listener.\n     * @return true if the listener was removed.\n     */\n    public boolean removeStanzaAcknowledgedListener(StanzaListener listener) {\n        return stanzaAcknowledgedListeners.remove(listener);\n    }\n\n    /**\n     * Remove all stanza acknowledged listeners.\n     */\n    public void removeAllStanzaAcknowledgedListeners() {\n        stanzaAcknowledgedListeners.clear();\n    }\n\n    /**\n     * Add a new Stanza ID acknowledged listener for the given ID.\n     * <p>\n     * The listener will be invoked if the stanza with the given ID was acknowledged by the server. It will\n     * automatically be removed after the listener was run.\n     * </p>\n     * \n     * @param id the stanza ID.\n     * @param listener the listener to invoke.\n     * @return the previous listener for this stanza ID or null.\n     * @throws StreamManagementNotEnabledException if Stream Management is not enabled.\n     */\n    public StanzaListener addStanzaIdAcknowledgedListener(final String id, StanzaListener listener) throws StreamManagementNotEnabledException {\n        // Prevent users from adding callbacks that will never get removed\n        if (!smWasEnabledAtLeastOnce) {\n            throw new StreamManagementException.StreamManagementNotEnabledException();\n        }\n        // Remove the listener after max. 12 hours\n        final int removeAfterSeconds = Math.min(getMaxSmResumptionTime(), 12 * 60 * 60);\n        schedule(new Runnable() {\n            @Override\n            public void run() {\n                stanzaIdAcknowledgedListeners.remove(id);\n            }\n        }, removeAfterSeconds, TimeUnit.SECONDS);\n        return stanzaIdAcknowledgedListeners.put(id, listener);\n    }\n\n    /**\n     * Remove the Stanza ID acknowledged listener for the given ID.\n     * \n     * @param id the stanza ID.\n     * @return true if the listener was found and removed, false otherwise.\n     */\n    public StanzaListener removeStanzaIdAcknowledgedListener(String id) {\n        return stanzaIdAcknowledgedListeners.remove(id);\n    }\n\n    /**\n     * Removes all Stanza ID acknowledged listeners.\n     */\n    public void removeAllStanzaIdAcknowledgedListeners() {\n        stanzaIdAcknowledgedListeners.clear();\n    }\n\n    /**\n     * Returns true if Stream Management is supported by the server.\n     *\n     * @return true if Stream Management is supported by the server.\n     */\n    public boolean isSmAvailable() {\n        return hasFeature(StreamManagementFeature.ELEMENT, StreamManagement.NAMESPACE);\n    }\n\n    /**\n     * Returns true if Stream Management was successfully negotiated with the server.\n     *\n     * @return true if Stream Management was negotiated.\n     */\n    public boolean isSmEnabled() {\n        return smEnabledSyncPoint.wasSuccessful();\n    }\n\n    /**\n     * Returns true if the stream was successfully resumed with help of Stream Management.\n     * \n     * @return true if the stream was resumed.\n     */\n    public boolean streamWasResumed() {\n        return smResumedSyncPoint.wasSuccessful();\n    }\n\n    /**\n     * Returns true if the connection is disconnected by a Stream resumption via Stream Management is possible.\n     * \n     * @return true if disconnected but resumption possible.\n     */\n    public boolean isDisconnectedButSmResumptionPossible() {\n        return disconnectedButResumeable && isSmResumptionPossible();\n    }\n\n    /**\n     * Returns true if the stream is resumable.\n     *\n     * @return true if the stream is resumable.\n     */\n    public boolean isSmResumptionPossible() {\n        // There is no resumable stream available\n        if (smSessionId == null)\n            return false;\n\n        final Long shutdownTimestamp = packetWriter.shutdownTimestamp;\n        // Seems like we are already reconnected, report true\n        if (shutdownTimestamp == null) {\n            return true;\n        }\n\n        // See if resumption time is over\n        long current = System.currentTimeMillis();\n        long maxResumptionMillies = ((long) getMaxSmResumptionTime()) * 1000;\n        if (current > shutdownTimestamp + maxResumptionMillies) {\n            // Stream resumption is *not* possible if the current timestamp is greater then the greatest timestamp where\n            // resumption is possible\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Drop the stream management state. Sets {@link #smSessionId} and\n     * {@link #unacknowledgedStanzas} to <code>null</code>.\n     */\n    private void dropSmState() {\n        // clientHandledCount and serverHandledCount will be reset on <enable/> and <enabled/>\n        // respective. No need to reset them here.\n        smSessionId = null;\n        unacknowledgedStanzas = null;\n    }\n\n    /**\n     * Get the maximum resumption time in seconds after which a managed stream can be resumed.\n     * <p>\n     * This method will return {@link Integer#MAX_VALUE} if neither the client nor the server specify a maximum\n     * resumption time. Be aware of integer overflows when using this value, e.g. do not add arbitrary values to it\n     * without checking for overflows before.\n     * </p>\n     *\n     * @return the maximum resumption time in seconds or {@link Integer#MAX_VALUE} if none set.\n     */\n    public int getMaxSmResumptionTime() {\n        int clientResumptionTime = smClientMaxResumptionTime > 0 ? smClientMaxResumptionTime : Integer.MAX_VALUE;\n        int serverResumptionTime = smServerMaxResumptimTime > 0 ? smServerMaxResumptimTime : Integer.MAX_VALUE;\n        return Math.min(clientResumptionTime, serverResumptionTime);\n    }\n\n    private void processHandledCount(long handledCount) throws StreamManagementCounterError {\n        long ackedStanzasCount = SMUtils.calculateDelta(handledCount, serverHandledStanzasCount);\n        final List<Stanza> ackedStanzas = new ArrayList<Stanza>(\n                        ackedStanzasCount <= Integer.MAX_VALUE ? (int) ackedStanzasCount\n                                        : Integer.MAX_VALUE);\n        for (long i = 0; i < ackedStanzasCount; i++) {\n            Stanza ackedStanza = unacknowledgedStanzas.poll();\n            // If the server ack'ed a stanza, then it must be in the\n            // unacknowledged stanza queue. There can be no exception.\n            if (ackedStanza == null) {\n                throw new StreamManagementCounterError(handledCount, serverHandledStanzasCount,\n                                ackedStanzasCount, ackedStanzas);\n            }\n            ackedStanzas.add(ackedStanza);\n        }\n\n        boolean atLeastOneStanzaAcknowledgedListener = false;\n        if (!stanzaAcknowledgedListeners.isEmpty()) {\n            // If stanzaAcknowledgedListeners is not empty, the we have at least one\n            atLeastOneStanzaAcknowledgedListener = true;\n        }\n        else {\n            // Otherwise we look for a matching id in the stanza *id* acknowledged listeners\n            for (Stanza ackedStanza : ackedStanzas) {\n                String id = ackedStanza.getStanzaId();\n                if (id != null && stanzaIdAcknowledgedListeners.containsKey(id)) {\n                    atLeastOneStanzaAcknowledgedListener = true;\n                    break;\n                }\n            }\n        }\n\n        // Only spawn a new thread if there is a chance that some listener is invoked\n        if (atLeastOneStanzaAcknowledgedListener) {\n            asyncGo(new Runnable() {\n                @Override\n                public void run() {\n                    for (Stanza ackedStanza : ackedStanzas) {\n                        for (StanzaListener listener : stanzaAcknowledgedListeners) {\n                            try {\n                                listener.processPacket(ackedStanza);\n                            }\n                            catch (NotConnectedException e) {\n                                LOGGER.log(Level.FINER, \"Received not connected exception\", e);\n                            }\n                        }\n                        String id = ackedStanza.getStanzaId();\n                        if (StringUtils.isNullOrEmpty(id)) {\n                            continue;\n                        }\n                        StanzaListener listener = stanzaIdAcknowledgedListeners.remove(id);\n                        if (listener != null) {\n                            try {\n                                listener.processPacket(ackedStanza);\n                            }\n                            catch (NotConnectedException e) {\n                                LOGGER.log(Level.FINER, \"Received not connected exception\", e);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n\n        serverHandledStanzasCount = handledCount;\n    }\n\n    /**\n     * Set the default bundle and defer callback used for new connections.\n     *\n     * @param defaultBundleAndDeferCallback\n     * @see BundleAndDeferCallback\n     * @since 4.1\n     */\n    public static void setDefaultBundleAndDeferCallback(BundleAndDeferCallback defaultBundleAndDeferCallback) {\n        XMPPTCPConnection.defaultBundleAndDeferCallback = defaultBundleAndDeferCallback;\n    }\n\n    /**\n     * Set the bundle and defer callback used for this connection.\n     * <p>\n     * You can use <code>null</code> as argument to reset the callback. Outgoing stanzas will then\n     * no longer get deferred.\n     * </p>\n     *\n     * @param bundleAndDeferCallback the callback or <code>null</code>.\n     * @see BundleAndDeferCallback\n     * @since 4.1\n     */\n    public void setBundleandDeferCallback(BundleAndDeferCallback bundleAndDeferCallback) {\n        this.bundleAndDeferCallback = bundleAndDeferCallback;\n    }\n\n}\n"], "filenames": ["smack-core/src/main/java/org/jivesoftware/smack/AbstractXMPPConnection.java", "smack-tcp/src/main/java/org/jivesoftware/smack/tcp/XMPPTCPConnection.java"], "buggy_code_start_loc": [364, 30], "buggy_code_end_loc": [364, 918], "fixing_code_start_loc": [365, 31], "fixing_code_end_loc": [366, 917], "type": "CWE-362", "message": "Race condition in the XMPP library in Smack before 4.1.9, when the SecurityMode.required TLS setting has been set, allows man-in-the-middle attackers to bypass TLS protections and trigger use of cleartext for client authentication by stripping the \"starttls\" feature from a server response.", "other": {"cve": {"id": "CVE-2016-10027", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-12T23:59:00.197", "lastModified": "2021-02-23T16:13:32.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in the XMPP library in Smack before 4.1.9, when the SecurityMode.required TLS setting has been set, allows man-in-the-middle attackers to bypass TLS protections and trigger use of cleartext for client authentication by stripping the \"starttls\" feature from a server response."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la librer\u00eda XMPP en Smack en versiones anteriores a 4.1.9, cuando se ha establecido la configuraci\u00f3n TLS SecurityMode.required, permite a atacantes man-in-the-middle eludir las protecciones TLS y desencadenar el uso de texto plano para la autenticaci\u00f3n del cliente eliminando la funci\u00f3n \"starttls\" de una respuesta del servidor."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:igniterealtime:smack:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.9", "matchCriteriaId": "0D1D4629-7401-416F-AE64-F7ACC12E8E29"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/12/22/12", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95129", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://community.igniterealtime.org/blogs/ignite/2016/11/22/smack-security-advisory-2016-11-22", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/igniterealtime/Smack/commit/059ee99ba0d5ff7758829acf5a9aeede09ec820b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/igniterealtime/Smack/commit/a9d5cd4a611f47123f9561bc5a81a4555fe7cb04", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://issues.igniterealtime.org/projects/SMACK/issues/SMACK-739", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/J4WXAZ4JVJXHMEDDXJVWJHPVBF5QCTZF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/igniterealtime/Smack/commit/059ee99ba0d5ff7758829acf5a9aeede09ec820b"}}