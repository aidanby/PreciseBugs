{"buggy_code": ["/**********************************************************************\n * $Id$\n *\n * Project:  MapServer\n * Purpose:  OGC Filter Encoding implementation\n * Author:   Y. Assefa, DM Solutions Group (assefa@dmsolutions.ca)\n *\n **********************************************************************\n * Copyright (c) 2003, Y. Assefa, DM Solutions Group Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies of this Software or works derived from this Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n ****************************************************************************/\n\n\n#define _GNU_SOURCE\n#include \"mapserver-config.h\"\n\n#ifdef USE_OGR\n#include \"cpl_minixml.h\"\n#include \"cpl_string.h\"\n#endif\n\n#include \"mapogcfilter.h\"\n#include \"mapserver.h\"\n#include \"mapowscommon.h\"\n#include \"maptime.h\"\n#include \"mapows.h\"\n#include <ctype.h>\n\n#if 0\nstatic int FLTHasUniqueTopLevelDuringFilter(FilterEncodingNode *psFilterNode);\n#endif\n\nint FLTIsNumeric(const char *pszValue)\n{\n  if (pszValue != NULL && *pszValue != '\\0' && !isspace(*pszValue)) {\n    /*the regex seems to have a problem on windows when mapserver is built using\n      PHP regex*/\n#if defined(_WIN32) && !defined(__CYGWIN__)\n    int i = 0, nLength=0, bString=0;\n\n    nLength = strlen(pszValue);\n    for (i=0; i<nLength; i++) {\n      if (i == 0) {\n        if (!isdigit(pszValue[i]) &&  pszValue[i] != '-') {\n          bString = 1;\n          break;\n        }\n      } else if (!isdigit(pszValue[i]) &&  pszValue[i] != '.') {\n        bString = 1;\n        break;\n      }\n    }\n    if (!bString)\n      return MS_TRUE;\n#else\n    char * p;\n    strtod(pszValue, &p);\n    if ( p != pszValue && *p == '\\0') return MS_TRUE;\n#endif\n  }\n\n  return MS_FALSE;\n}\n\n/*\n** Apply an expression to the layer's filter element.\n**\n*/\nint FLTApplyExpressionToLayer(layerObj *lp, const char *pszExpression)\n{\n  char *pszFinalExpression=NULL, *pszBuffer = NULL;\n  /*char *escapedTextString=NULL;*/\n  int bConcatWhere=0, bHasAWhere=0;\n\n  if (lp && pszExpression) {\n    if (lp->connectiontype == MS_POSTGIS || lp->connectiontype ==  MS_ORACLESPATIAL ||\n        lp->connectiontype == MS_PLUGIN) {\n      pszFinalExpression = msStrdup(\"(\");\n      pszFinalExpression = msStringConcatenate(pszFinalExpression, pszExpression);\n      pszFinalExpression = msStringConcatenate(pszFinalExpression, \")\");\n    } else if (lp->connectiontype == MS_OGR) {\n      pszFinalExpression = msStrdup(pszExpression);\n      if (lp->filter.type != MS_EXPRESSION) {\n        bConcatWhere = 1;\n      } else {\n        if (lp->filter.string && EQUALN(lp->filter.string,\"WHERE \",6)) {\n          bHasAWhere = 1;\n          bConcatWhere =1;\n        }\n      }\n\n    } else\n      pszFinalExpression = msStrdup(pszExpression);\n\n    if (bConcatWhere)\n      pszBuffer = msStringConcatenate(pszBuffer, \"WHERE \");\n    /* if the filter is set and it's an expression type, concatenate it with\n                this filter. If not just free it */\n    if (lp->filter.string && lp->filter.type == MS_EXPRESSION) {\n      pszBuffer = msStringConcatenate(pszBuffer, \"((\");\n      if (bHasAWhere)\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string+6);\n      else\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string);\n      pszBuffer = msStringConcatenate(pszBuffer, \") and \");\n    } else if (lp->filter.string)\n      msFreeExpression(&lp->filter);\n\n    pszBuffer = msStringConcatenate(pszBuffer, pszFinalExpression);\n\n    if(lp->filter.string && lp->filter.type == MS_EXPRESSION)\n      pszBuffer = msStringConcatenate(pszBuffer, \")\");\n\n    /*assuming that expression was properly escaped\n          escapedTextString = msStringEscape(pszBuffer);\n          msLoadExpressionString(&lp->filter,\n                                 (char*)CPLSPrintf(\"%s\", escapedTextString));\n          msFree(escapedTextString);\n    */\n    msLoadExpressionString(&lp->filter, pszBuffer);\n\n\n    msFree(pszFinalExpression);\n\n    if (pszBuffer)\n      msFree(pszBuffer);\n\n    return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\nchar *FLTGetExpressionForValuesRanges(layerObj *lp, const char *item, const char *value,  int forcecharcter)\n{\n  int bIscharacter, bSqlLayer=MS_FALSE;\n  char *pszExpression = NULL, *pszEscapedStr=NULL, *pszTmpExpression=NULL;\n  char **paszElements = NULL, **papszRangeElements=NULL;\n  int numelements,i,nrangeelements;\n\n  /* TODO: remove the bSqlLayer checks since we want to write MapServer expressions only. */\n\n  /* double minval, maxval; */\n  if (lp && item && value) {\n    if (strstr(value, \"/\") == NULL) {\n      /*value(s)*/\n      paszElements = msStringSplit (value, ',', &numelements);\n      if (paszElements && numelements > 0) {\n        if (forcecharcter)\n          bIscharacter = MS_TRUE;\n        bIscharacter= !FLTIsNumeric(paszElements[0]);\n\n        pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n        for (i=0; i<numelements; i++) {\n          pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n          if (bSqlLayer)\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n          else {\n            if (bIscharacter)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"\\\"\");\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n            if (bIscharacter)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"\\\"\");\n          }\n          if (bIscharacter) {\n            if (bSqlLayer)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = '\");\n            else\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = \\\"\");\n          } else\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = \");\n\n          pszEscapedStr = msLayerEscapeSQLParam(lp, paszElements[i]);\n          pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n\n          if (bIscharacter) {\n            if (bSqlLayer)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"'\");\n            else\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"\\\"\");\n          }\n          pszTmpExpression = msStringConcatenate(pszTmpExpression, \")\");\n\n          msFree(pszEscapedStr);\n          pszEscapedStr=NULL;\n\n          if (pszExpression != NULL)\n            pszExpression = msStringConcatenate(pszExpression, \" OR \");\n\n          pszExpression =  msStringConcatenate(pszExpression, pszTmpExpression);\n\n          msFree(pszTmpExpression);\n          pszTmpExpression = NULL;\n        }\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n      }\n      msFreeCharArray(paszElements, numelements);\n    } else {\n      /*range(s)*/\n      paszElements = msStringSplit (value, ',', &numelements);\n      if (paszElements && numelements > 0) {\n        pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n        for (i=0; i<numelements; i++) {\n          papszRangeElements = msStringSplit (paszElements[i], '/', &nrangeelements);\n          if (papszRangeElements && nrangeelements > 0) {\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n            if (nrangeelements == 2 || nrangeelements == 3) {\n              /*\n              minval = atof(papszRangeElements[0]);\n              maxval = atof(papszRangeElements[1]);\n              */\n              if (bSqlLayer)\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n              else {\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n              }\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" >= \");\n\n              pszEscapedStr = msLayerEscapeSQLParam(lp, papszRangeElements[0]);\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n              msFree(pszEscapedStr);\n              pszEscapedStr=NULL;\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" AND \");\n\n              if (bSqlLayer)\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n              else {\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n              }\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" <= \");\n\n              pszEscapedStr = msLayerEscapeSQLParam(lp, papszRangeElements[1]);\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n              msFree(pszEscapedStr);\n              pszEscapedStr=NULL;\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \")\");\n            } else if (nrangeelements == 1) {\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n              if (bSqlLayer)\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n              else {\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n              }\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = \");\n\n              pszEscapedStr = msLayerEscapeSQLParam(lp, papszRangeElements[0]);\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n              msFree(pszEscapedStr);\n              pszEscapedStr=NULL;\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \")\");\n            }\n\n            if (pszExpression != NULL)\n              pszExpression = msStringConcatenate(pszExpression, \" OR \");\n\n            pszExpression =  msStringConcatenate(pszExpression, pszTmpExpression);\n            msFree(pszTmpExpression);\n            pszTmpExpression = NULL;\n\n          }\n          msFreeCharArray(papszRangeElements, nrangeelements);\n        }\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n      }\n      msFreeCharArray(paszElements, numelements);\n    }\n  }\n  msFree(pszTmpExpression);\n  return pszExpression;\n}\n\n#ifdef USE_OGR\n\n\nint FLTogrConvertGeometry(OGRGeometryH hGeometry, shapeObj *psShape,\n                          OGRwkbGeometryType nType)\n{\n  return msOGRGeometryToShape(hGeometry, psShape, nType);\n}\n\nstatic\nint FLTShapeFromGMLTree(CPLXMLNode *psTree, shapeObj *psShape , char **ppszSRS)\n{\n  const char *pszSRS = NULL;\n  if (psTree && psShape) {\n    CPLXMLNode *psNext = psTree->psNext;\n    OGRGeometryH hGeometry = NULL;\n\n    psTree->psNext = NULL;\n    hGeometry = OGR_G_CreateFromGMLTree(psTree );\n    psTree->psNext = psNext;\n\n    if (hGeometry) {\n      OGRwkbGeometryType nType;\n      nType = OGR_G_GetGeometryType(hGeometry);\n      if (nType == wkbPolygon25D || nType == wkbMultiPolygon25D)\n        nType = wkbPolygon;\n      else if (nType == wkbLineString25D || nType == wkbMultiLineString25D)\n        nType = wkbLineString;\n      else if (nType == wkbPoint25D  || nType ==  wkbMultiPoint25D)\n        nType = wkbPoint;\n      FLTogrConvertGeometry(hGeometry, psShape, nType);\n\n      OGR_G_DestroyGeometry(hGeometry);\n\n      pszSRS = CPLGetXMLValue(psTree, \"srsName\", NULL);\n      if (ppszSRS && pszSRS)\n        *ppszSRS = msStrdup(pszSRS);\n\n      return MS_TRUE;\n    }\n  }\n\n  return MS_FALSE;\n}\n\nint FLTGetGeosOperator(char *pszValue)\n{\n  if (!pszValue)\n    return -1;\n\n  if (strcasecmp(pszValue, \"Equals\") == 0)\n    return MS_GEOS_EQUALS;\n  else if (strcasecmp(pszValue, \"Intersect\") == 0 ||\n           strcasecmp(pszValue, \"Intersects\") == 0)\n    return MS_GEOS_INTERSECTS;\n  else if (strcasecmp(pszValue, \"Disjoint\") == 0)\n    return MS_GEOS_DISJOINT;\n  else if (strcasecmp(pszValue, \"Touches\") == 0)\n    return MS_GEOS_TOUCHES;\n  else if (strcasecmp(pszValue, \"Crosses\") == 0)\n    return MS_GEOS_CROSSES;\n  else if (strcasecmp(pszValue, \"Within\") == 0)\n    return MS_GEOS_WITHIN;\n  else if (strcasecmp(pszValue, \"Contains\") == 0)\n    return MS_GEOS_CONTAINS;\n  else if (strcasecmp(pszValue, \"Overlaps\") == 0)\n    return MS_GEOS_OVERLAPS;\n  else if (strcasecmp(pszValue, \"Beyond\") == 0)\n    return MS_GEOS_BEYOND;\n  else if (strcasecmp(pszValue, \"DWithin\") == 0)\n    return MS_GEOS_DWITHIN;\n\n  return -1;\n}\n\nint FLTIsGeosNode(char *pszValue)\n{\n  if (FLTGetGeosOperator(pszValue) == -1)\n    return MS_FALSE;\n\n  return MS_TRUE;\n}\n\n/************************************************************************/\n/*                        FLTIsSimpleFilterNoSpatial                    */\n/*                                                                      */\n/*      Filter encoding with only attribute queries                     */\n/************************************************************************/\nint FLTIsSimpleFilterNoSpatial(FilterEncodingNode *psNode)\n{\n  if (FLTIsSimpleFilter(psNode) && FLTNumberOfFilterType(psNode, \"BBOX\") == 0)\n    return MS_TRUE;\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*                      FLTApplySimpleSQLFilter()                       */\n/************************************************************************/\n\nint FLTApplySimpleSQLFilter(FilterEncodingNode *psNode, mapObj *map, int iLayerIndex)\n{\n  layerObj *lp = NULL;\n  char *szExpression = NULL;\n  rectObj sQueryRect = map->extent;\n  const char *szEPSG = NULL;\n  projectionObj sProjTmp;\n  char *pszBuffer = NULL;\n  int bConcatWhere = 0;\n  int bHasAWhere =0;\n  char *pszTmp = NULL, *pszTmp2 = NULL;\n  char *tmpfilename = NULL;\n  const char* pszTimeField = NULL;\n  const char* pszTimeValue = NULL;\n\n  lp = (GET_LAYER(map, iLayerIndex));\n\n  /* if there is a bbox use it */\n  szEPSG = FLTGetBBOX(psNode, &sQueryRect);\n  if(szEPSG && map->projection.numargs > 0) {\n    msInitProjection(&sProjTmp);\n    /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n    if (msLoadProjectionString(&sProjTmp, szEPSG) == 0) {\n      msProjectRect(&sProjTmp, &map->projection, &sQueryRect);\n    }\n    msFreeProjection(&sProjTmp);\n  }\n  \n  if( lp->connectiontype == MS_OGR ) {\n    pszTimeValue = FLTGetDuring(psNode, &pszTimeField);\n  }\n\n  /* make sure that the layer can be queried*/\n  if (!lp->template) lp->template = msStrdup(\"ttt.html\");\n\n  /* if there is no class, create at least one, so that query by rect would work */\n  if (lp->numclasses == 0) {\n    if (msGrowLayerClasses(lp) == NULL)\n      return MS_FAILURE;\n    initClass(lp->class[0]);\n  }\n\n  bConcatWhere = 0;\n  bHasAWhere = 0;\n  if (lp->connectiontype == MS_POSTGIS || lp->connectiontype ==  MS_ORACLESPATIAL ||\n      lp->connectiontype == MS_PLUGIN) {\n    szExpression = FLTGetSQLExpression(psNode, lp);\n    if (szExpression) {\n      pszTmp = msStrdup(\"(\");\n      pszTmp = msStringConcatenate(pszTmp, szExpression);\n      pszTmp = msStringConcatenate(pszTmp, \")\");\n      msFree(szExpression);\n      szExpression = pszTmp;\n    }\n  }\n  /* concatenates the WHERE clause for OGR layers. This only applies if\n     the expression was empty or not of an expression string. If there\n     is an sql type expression, it is assumed to have the WHERE clause.\n     If it is an expression and does not have a WHERE it is assumed to be a mapserver\n     type expression*/\n  else if (lp->connectiontype == MS_OGR) {\n    if (lp->filter.type != MS_EXPRESSION) {\n      szExpression = FLTGetSQLExpression(psNode, lp);\n      bConcatWhere = 1;\n    } else {\n      if (lp->filter.string && EQUALN(lp->filter.string,\"WHERE \",6)) {\n        szExpression = FLTGetSQLExpression(psNode, lp);\n        bHasAWhere = 1;\n        bConcatWhere =1;\n      } else {\n        szExpression = FLTGetCommonExpression(psNode, lp);\n      }\n    }\n  } else {\n    szExpression = FLTGetCommonExpression(psNode, lp);\n\n  }\n\n  if (szExpression) {\n    if (bConcatWhere)\n      pszBuffer = msStringConcatenate(pszBuffer, \"WHERE \");\n\n    /* if the filter is set and it's an expression type, concatenate it with\n                 this filter. If not just free it */\n    if (lp->filter.string && lp->filter.type == MS_EXPRESSION) {\n      pszBuffer = msStringConcatenate(pszBuffer, \"((\");\n      if (bHasAWhere)\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string+6);\n      else\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string);\n      pszBuffer = msStringConcatenate(pszBuffer, \") and \");\n    } else if (lp->filter.string)\n      msFreeExpression(&lp->filter);\n\n    pszBuffer = msStringConcatenate(pszBuffer, szExpression);\n\n    if(lp->filter.string && lp->filter.type == MS_EXPRESSION)\n      pszBuffer = msStringConcatenate(pszBuffer, \")\");\n\n    msLoadExpressionString(&lp->filter, pszBuffer);\n    free(szExpression);\n  }\n  \n  if (pszTimeField && pszTimeValue)\n      msLayerSetTimeFilter(lp, pszTimeValue, pszTimeField);\n\n  if (pszBuffer)\n    free(pszBuffer);\n\n  map->query.type = MS_QUERY_BY_RECT;\n  map->query.mode = MS_QUERY_MULTIPLE;\n  map->query.layer = lp->index;\n  map->query.rect = sQueryRect;\n\n  if(map->debug == MS_DEBUGLEVEL_VVV) {\n    tmpfilename = msTmpFile(map, map->mappath, NULL, \"_filter.map\");\n    if (tmpfilename == NULL) {\n      tmpfilename = msTmpFile(map, NULL, NULL, \"_filter.map\" );\n    }\n    if (tmpfilename) {\n      msSaveMap(map,tmpfilename);\n      msDebug(\"FLTApplySimpleSQLFilter(): Map file after Filter was applied %s\\n\", tmpfilename);\n      msFree(tmpfilename);\n    }\n  }\n\n  /*for oracle connection, if we have a simple filter with no spatial constraints\n    we should set the connection function to NONE to have a better performance\n    (#2725)*/\n\n  if (lp->connectiontype ==  MS_ORACLESPATIAL && FLTIsSimpleFilterNoSpatial(psNode)) {\n    if (strcasestr(lp->data, \"USING\") == 0)\n      lp->data = msStringConcatenate(lp->data, \" USING NONE\");\n    else if (strcasestr(lp->data, \"NONE\") == 0) {\n      /*if one of the functions is used, just replace it with NONE*/\n      if (strcasestr(lp->data, \"FILTER\"))\n        lp->data = msCaseReplaceSubstring(lp->data, \"FILTER\", \"NONE\");\n      else if (strcasestr(lp->data, \"GEOMRELATE\"))\n        lp->data = msCaseReplaceSubstring(lp->data, \"GEOMRELATE\", \"NONE\");\n      else if (strcasestr(lp->data, \"RELATE\"))\n        lp->data = msCaseReplaceSubstring(lp->data, \"RELATE\", \"NONE\");\n      else if (strcasestr(lp->data, \"VERSION\")) {\n        /*should add NONE just before the VERSION. Cases are:\n          DATA \"ORA_GEOMETRY FROM data USING VERSION 10g\n          DATA \"ORA_GEOMETRY FROM data  USING UNIQUE FID VERSION 10g\"\n         */\n        pszTmp = (char *)strcasestr(lp->data, \"VERSION\");\n        pszTmp2 = msStringConcatenate(pszTmp2, \" NONE \");\n        pszTmp2 = msStringConcatenate(pszTmp2, pszTmp);\n\n        lp->data = msCaseReplaceSubstring(lp->data, pszTmp, pszTmp2);\n\n        msFree(pszTmp2);\n\n      } else if (strcasestr(lp->data, \"SRID\")) {\n        lp->data = msStringConcatenate(lp->data, \" NONE\");\n      }\n    }\n  }\n\n  return msQueryByRect(map);\n\n  /* return MS_SUCCESS; */\n}\n\n/************************************************************************/\n/*                            FLTIsSimpleFilter                         */\n/*                                                                      */\n/*      Filter encoding with only attribute queries and only one bbox.  */\n/************************************************************************/\nint FLTIsSimpleFilter(FilterEncodingNode *psNode)\n{\n  if (FLTValidForBBoxFilter(psNode)) {\n    if (FLTNumberOfFilterType(psNode, \"DWithin\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Intersect\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Intersects\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Equals\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Disjoint\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Touches\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Crosses\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Within\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Contains\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Overlaps\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Beyond\") == 0)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n/************************************************************************/\n/*                          FLTApplyFilterToLayer                       */\n/*                                                                      */\n/*      Use the filter encoding node to create mapserver expressions    */\n/*      and apply it to the layer.                                      */\n/************************************************************************/\nint FLTApplyFilterToLayer(FilterEncodingNode *psNode, mapObj *map, int iLayerIndex)\n{\n  layerObj *layer = GET_LAYER(map, iLayerIndex);\n\n  if ( ! layer->vtable) {\n    int rv =  msInitializeVirtualTable(layer);\n    if (rv != MS_SUCCESS)\n      return rv;\n  }\n  return layer->vtable->LayerApplyFilterToLayer(psNode, map,  iLayerIndex);\n}\n\n/************************************************************************/\n/*               FLTLayerApplyCondSQLFilterToLayer                       */\n/*                                                                      */\n/* Helper function for layer virtual table architecture                 */\n/************************************************************************/\nint FLTLayerApplyCondSQLFilterToLayer(FilterEncodingNode *psNode, mapObj *map, int iLayerIndex)\n{\n  return FLTLayerApplyPlainFilterToLayer(psNode, map, iLayerIndex);\n}\n\n\n/************************************************************************/\n/*                           FLTGetTopBBOX                              */\n/*                                                                      */\n/* Return the \"top\" BBOX if there's a unique one.                       */\n/************************************************************************/\nstatic int FLTGetTopBBOXInternal(FilterEncodingNode *psNode, FilterEncodingNode** ppsTopBBOX, int *pnCount)\n{\n  if (psNode->pszValue && strcasecmp(psNode->pszValue, \"BBOX\") == 0) {\n    (*pnCount) ++;\n    if( *pnCount == 1 )\n    {\n      *ppsTopBBOX = psNode;\n      return TRUE;\n    }\n    *ppsTopBBOX = NULL;\n    return FALSE;\n  }\n  else if (psNode->pszValue && strcasecmp(psNode->pszValue, \"AND\") == 0) {\n    return FLTGetTopBBOXInternal(psNode->psLeftNode, ppsTopBBOX, pnCount) &&\n           FLTGetTopBBOXInternal(psNode->psRightNode, ppsTopBBOX, pnCount);\n  }\n  else\n  {\n    return TRUE;\n  }\n}\n\nstatic FilterEncodingNode* FLTGetTopBBOX(FilterEncodingNode *psNode)\n{\n  int nCount = 0;\n  FilterEncodingNode* psTopBBOX = NULL;\n  FLTGetTopBBOXInternal(psNode, &psTopBBOX, &nCount);\n  return psTopBBOX;\n}\n\n/************************************************************************/\n/*                   FLTLayerApplyPlainFilterToLayer                    */\n/*                                                                      */\n/* Helper function for layer virtual table architecture                 */\n/************************************************************************/\nint FLTLayerApplyPlainFilterToLayer(FilterEncodingNode *psNode, mapObj *map,\n                                    int iLayerIndex)\n{\n  char *pszExpression  =NULL;\n  int status =MS_FALSE;\n  layerObj* lp = GET_LAYER(map, iLayerIndex);\n\n  pszExpression = FLTGetCommonExpression(psNode,  lp);\n  if (pszExpression) {\n    const char* pszUseDefaultExtent;\n    FilterEncodingNode* psTopBBOX;\n    rectObj rect = map->extent;\n\n    pszUseDefaultExtent = msOWSLookupMetadata(&(lp->metadata), \"F\",\n                                              \"use_default_extent_for_getfeature\");\n    if( pszUseDefaultExtent && !CSLTestBoolean(pszUseDefaultExtent) &&\n        lp->connectiontype == MS_OGR )\n    {\n        const rectObj rectInvalid = MS_INIT_INVALID_RECT;\n        rect = rectInvalid;\n    }\n\n    psTopBBOX = FLTGetTopBBOX(psNode);\n    if( psTopBBOX )\n    {\n      int can_remove_expression = MS_TRUE;\n      const char* pszEPSG = FLTGetBBOX(psNode, &rect);\n      if(pszEPSG && map->projection.numargs > 0) {\n        projectionObj sProjTmp;\n        msInitProjection(&sProjTmp);\n        /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n        if (msLoadProjectionString(&sProjTmp, pszEPSG) == 0) {\n          rectObj oldRect = rect;\n          msProjectRect(&sProjTmp, &map->projection, &rect);\n          /* If reprojection is involved, do not remove the expression */\n          if( rect.minx != oldRect.minx ||\n              rect.miny != oldRect.miny ||\n              rect.maxx != oldRect.maxx ||\n              rect.maxy != oldRect.maxy )\n          {\n            can_remove_expression = MS_FALSE;\n          }\n        }\n        msFreeProjection(&sProjTmp);\n      }\n\n      /* Small optimization: if the query is just a BBOX, then do a */\n      /* msQueryByRect() */\n      if( psTopBBOX == psNode && can_remove_expression )\n      {\n        msFree(pszExpression);\n        pszExpression = NULL;\n      }\n    }\n\n    if(map->debug == MS_DEBUGLEVEL_VVV)\n    {\n      if( pszExpression )\n        msDebug(\"FLTLayerApplyPlainFilterToLayer(): %s, rect=%.15g,%.15g,%.15g,%.15g\\n\", pszExpression, rect.minx, rect.miny, rect.maxx, rect.maxy);\n      else\n        msDebug(\"FLTLayerApplyPlainFilterToLayer(): rect=%.15g,%.15g,%.15g,%.15g\\n\", rect.minx, rect.miny, rect.maxx, rect.maxy);\n    }\n\n    status = FLTApplyFilterToLayerCommonExpressionWithRect(map, iLayerIndex,\n                                                           pszExpression, rect);\n    msFree(pszExpression);\n  }\n\n  return status;\n}\n\n\n\n/************************************************************************/\n/*            FilterNode *FLTPaserFilterEncoding(char *szXMLString)     */\n/*                                                                      */\n/*      Parses an Filter Encoding XML string and creates a              */\n/*      FilterEncodingNodes corresponding to the string.                */\n/*      Returns a pointer to the first node or NULL if                  */\n/*      unsuccessfull.                                                  */\n/*      Calling function should use FreeFilterEncodingNode function     */\n/*      to free memeory.                                                */\n/************************************************************************/\nFilterEncodingNode *FLTParseFilterEncoding(const char *szXMLString)\n{\n  CPLXMLNode *psRoot = NULL, *psChild=NULL, *psFilter=NULL;\n  FilterEncodingNode *psFilterNode = NULL;\n\n  if (szXMLString == NULL || strlen(szXMLString) <= 0 ||\n      (strstr(szXMLString, \"Filter\") == NULL))\n    return NULL;\n\n  psRoot = CPLParseXMLString(szXMLString);\n\n  if( psRoot == NULL)\n    return NULL;\n\n  /* strip namespaces. We srtip all name spaces (#1350)*/\n  CPLStripXMLNamespace(psRoot, NULL, 1);\n\n  /* -------------------------------------------------------------------- */\n  /*      get the root element (Filter).                                  */\n  /* -------------------------------------------------------------------- */\n  psFilter = CPLGetXMLNode(psRoot, \"=Filter\");\n  if (!psFilter)\n  {\n    CPLDestroyXMLNode( psRoot );\n    return NULL;\n  }\n\n  psChild = psFilter->psChild;\n  while (psChild) {\n    if (FLTIsSupportedFilterType(psChild)) {\n      psFilterNode = FLTCreateFilterEncodingNode();\n      FLTInsertElementInNode(psFilterNode, psChild);\n      break;\n    } else\n      psChild = psChild->psNext;\n  }\n\n  CPLDestroyXMLNode( psRoot );\n\n  /* -------------------------------------------------------------------- */\n  /*      validate the node tree to make sure that all the nodes are valid.*/\n  /* -------------------------------------------------------------------- */\n  if (!FLTValidFilterNode(psFilterNode)) {\n    FLTFreeFilterEncodingNode(psFilterNode);\n    return NULL;\n  }\n\n\n  return psFilterNode;\n}\n\n\n/************************************************************************/\n/*      int FLTValidFilterNode(FilterEncodingNode *psFilterNode)        */\n/*                                                                      */\n/*      Validate that all the nodes are filled properly. We could       */\n/*      have parts of the nodes that are correct and part which         */\n/*      could be incorrect if the filter string sent is corrupted       */\n/*      (eg missing a value :<PropertyName><PropertyName>)              */\n/************************************************************************/\nint FLTValidFilterNode(FilterEncodingNode *psFilterNode)\n{\n  int  bReturn = 0;\n\n  if (!psFilterNode)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_UNDEFINED)\n    return 0;\n\n  if (psFilterNode->psLeftNode) {\n    bReturn = FLTValidFilterNode(psFilterNode->psLeftNode);\n    if (bReturn == 0)\n      return 0;\n    else if (psFilterNode->psRightNode)\n      return FLTValidFilterNode(psFilterNode->psRightNode);\n  }\n\n  return 1;\n}\n\n/************************************************************************/\n/*                       FLTIsGeometryFilterNodeType                    */\n/************************************************************************/\n\nstatic int FLTIsGeometryFilterNodeType(int eType)\n{\n    return (eType == FILTER_NODE_TYPE_GEOMETRY_POINT ||\n            eType == FILTER_NODE_TYPE_GEOMETRY_LINE ||\n            eType == FILTER_NODE_TYPE_GEOMETRY_POLYGON);\n}\n\n/************************************************************************/\n/*                          FLTFreeFilterEncodingNode                   */\n/*                                                                      */\n/*      recursive freeing of Filer Encoding nodes.                      */\n/************************************************************************/\nvoid FLTFreeFilterEncodingNode(FilterEncodingNode *psFilterNode)\n{\n  if (psFilterNode) {\n    if (psFilterNode->psLeftNode) {\n      FLTFreeFilterEncodingNode(psFilterNode->psLeftNode);\n      psFilterNode->psLeftNode = NULL;\n    }\n    if (psFilterNode->psRightNode) {\n      FLTFreeFilterEncodingNode(psFilterNode->psRightNode);\n      psFilterNode->psRightNode = NULL;\n    }\n\n    if (psFilterNode->pszSRS)\n      free( psFilterNode->pszSRS);\n\n    if( psFilterNode->pOther ) {\n      if (psFilterNode->pszValue != NULL &&\n          strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0) {\n        FEPropertyIsLike* propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n        if( propIsLike->pszWildCard )\n          free( propIsLike->pszWildCard );\n        if( propIsLike->pszSingleChar )\n          free( propIsLike->pszSingleChar );\n        if( propIsLike->pszEscapeChar )\n          free( propIsLike->pszEscapeChar );\n      } else if (FLTIsGeometryFilterNodeType(psFilterNode->eType)) {\n        msFreeShape((shapeObj *)(psFilterNode->pOther));\n      }\n      /* else */\n      /* TODO free pOther special fields */\n      free( psFilterNode->pOther );\n    }\n\n    /* Cannot free pszValue before, 'cause we are testing it above */\n    if( psFilterNode->pszValue )\n      free( psFilterNode->pszValue );\n\n    free(psFilterNode);\n  }\n}\n\n\n/************************************************************************/\n/*                         FLTCreateFilterEncodingNode                  */\n/*                                                                      */\n/*      return a FilerEncoding node.                                    */\n/************************************************************************/\nFilterEncodingNode *FLTCreateFilterEncodingNode(void)\n{\n  FilterEncodingNode *psFilterNode = NULL;\n\n  psFilterNode =\n  (FilterEncodingNode *)malloc(sizeof (FilterEncodingNode));\n  psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n  psFilterNode->pszValue = NULL;\n  psFilterNode->pOther = NULL;\n  psFilterNode->pszSRS = NULL;\n  psFilterNode->psLeftNode = NULL;\n  psFilterNode->psRightNode = NULL;\n\n  return psFilterNode;\n}\n\nFilterEncodingNode *FLTCreateBinaryCompFilterEncodingNode(void)\n{\n  FilterEncodingNode *psFilterNode = NULL;\n\n  psFilterNode = FLTCreateFilterEncodingNode();\n  /* used to store case sensitivity flag. Default is 0 meaning the\n     comparing is case sensititive */\n  psFilterNode->pOther = (int *)malloc(sizeof(int));\n  (*(int *)(psFilterNode->pOther)) = 0;\n\n  return psFilterNode;\n}\n\n\n/************************************************************************/\n/*                           FLTFindGeometryNode                        */\n/*                                                                      */\n/************************************************************************/\n\nstatic CPLXMLNode* FLTFindGeometryNode(CPLXMLNode* psXMLNode,\n                                       int* pbPoint,\n                                       int* pbLine,\n                                       int* pbPolygon)\n{\n    CPLXMLNode *psGMLElement = NULL;\n\n    psGMLElement = CPLGetXMLNode(psXMLNode, \"Point\");\n    if (!psGMLElement)\n        psGMLElement =  CPLGetXMLNode(psXMLNode, \"PointType\");\n    if (psGMLElement)\n        *pbPoint =1;\n    else {\n      psGMLElement= CPLGetXMLNode(psXMLNode, \"Polygon\");\n      if (psGMLElement)\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiPolygon\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"Surface\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiSurface\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"Box\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"LineString\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiLineString\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"Curve\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiCurve\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiPoint\")))\n        *pbPoint = 1;\n    }\n    return psGMLElement;\n}\n\n/************************************************************************/\n/*                           FLTGetPropertyName                         */\n/************************************************************************/\nstatic const char* FLTGetPropertyName(CPLXMLNode* psXMLNode)\n{\n    const char* pszPropertyName;\n\n    pszPropertyName = CPLGetXMLValue(psXMLNode, \"PropertyName\", NULL);\n    if( pszPropertyName == NULL ) /* FE 2.0 ? */\n        pszPropertyName = CPLGetXMLValue(psXMLNode, \"ValueReference\", NULL);\n    return pszPropertyName;\n}\n\n/************************************************************************/\n/*                          FLTGetFirstChildNode                        */\n/************************************************************************/\nstatic CPLXMLNode* FLTGetFirstChildNode(CPLXMLNode* psXMLNode)\n{\n    if( psXMLNode == NULL )\n        return NULL;\n    psXMLNode = psXMLNode->psChild;\n    while( psXMLNode != NULL )\n    {\n        if( psXMLNode->eType == CXT_Element )\n            return psXMLNode;\n        psXMLNode = psXMLNode->psNext;\n    }\n    return NULL;\n}\n\n/************************************************************************/\n/*                        FLTGetNextSibblingNode                        */\n/************************************************************************/\nstatic CPLXMLNode* FLTGetNextSibblingNode(CPLXMLNode* psXMLNode)\n{\n    if( psXMLNode == NULL )\n        return NULL;\n    psXMLNode = psXMLNode->psNext;\n    while( psXMLNode != NULL )\n    {\n        if( psXMLNode->eType == CXT_Element )\n            return psXMLNode;\n        psXMLNode = psXMLNode->psNext;\n    }\n    return NULL;\n}\n\n/************************************************************************/\n/*                           FLTInsertElementInNode                     */\n/*                                                                      */\n/*      Utility function to parse an XML node and transfter the         */\n/*      contennts into the Filer Encoding node structure.               */\n/************************************************************************/\nvoid FLTInsertElementInNode(FilterEncodingNode *psFilterNode,\n                            CPLXMLNode *psXMLNode)\n{\n  int nStrLength = 0;\n  char *pszTmp = NULL;\n  FilterEncodingNode *psCurFilNode= NULL;\n  CPLXMLNode *psCurXMLNode = NULL;\n  CPLXMLNode *psTmpNode = NULL;\n  CPLXMLNode *psFeatureIdNode = NULL;\n  const char *pszFeatureId=NULL;\n  char *pszFeatureIdList=NULL;\n\n  if (psFilterNode && psXMLNode && psXMLNode->pszValue) {\n    psFilterNode->pszValue = msStrdup(psXMLNode->pszValue);\n    psFilterNode->psLeftNode = NULL;\n    psFilterNode->psRightNode = NULL;\n\n    /* -------------------------------------------------------------------- */\n    /*      Logical filter. AND, OR and NOT are supported. Example of       */\n    /*      filer using logical filters :                                   */\n    /*      <Filter>                                                        */\n    /*        <And>                                                         */\n    /*          <PropertyIsGreaterThan>                                     */\n    /*            <PropertyName>Person/Age</PropertyName>                   */\n    /*            <Literal>50</Literal>                                     */\n    /*          </PropertyIsGreaterThan>                                    */\n    /*          <PropertyIsEqualTo>                                         */\n    /*             <PropertyName>Person/Address/City</PropertyName>         */\n    /*             <Literal>Toronto</Literal>                               */\n    /*          </PropertyIsEqualTo>                                        */\n    /*        </And>                                                        */\n    /*      </Filter>                                                       */\n    /* -------------------------------------------------------------------- */\n    if (FLTIsLogicalFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_LOGICAL;\n      if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n          strcasecmp(psFilterNode->pszValue, \"OR\") == 0) {\n        CPLXMLNode* psFirstNode = FLTGetFirstChildNode(psXMLNode);\n        CPLXMLNode* psSecondNode = FLTGetNextSibblingNode(psFirstNode);\n        if (psFirstNode && psSecondNode) {\n          /*2 operators */\n          CPLXMLNode* psNextNode = FLTGetNextSibblingNode(psSecondNode);\n          if (psNextNode == NULL) {\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            FLTInsertElementInNode(psFilterNode->psLeftNode, psFirstNode);\n            psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n            FLTInsertElementInNode(psFilterNode->psRightNode, psSecondNode);\n          } else {\n            psCurXMLNode = psFirstNode;\n            psCurFilNode = psFilterNode;\n            while(psCurXMLNode) {\n              psNextNode = FLTGetNextSibblingNode(psCurXMLNode);\n              if (FLTGetNextSibblingNode(psNextNode)) {\n                psCurFilNode->psLeftNode = FLTCreateFilterEncodingNode();\n                FLTInsertElementInNode(psCurFilNode->psLeftNode, psCurXMLNode);\n                psCurFilNode->psRightNode = FLTCreateFilterEncodingNode();\n                psCurFilNode->psRightNode->eType = FILTER_NODE_TYPE_LOGICAL;\n                psCurFilNode->psRightNode->pszValue = msStrdup(psFilterNode->pszValue);\n\n                psCurFilNode = psCurFilNode->psRightNode;\n                psCurXMLNode = psNextNode;\n              } else { /*last 2 operators*/\n                psCurFilNode->psLeftNode = FLTCreateFilterEncodingNode();\n                FLTInsertElementInNode(psCurFilNode->psLeftNode, psCurXMLNode);\n\n                psCurFilNode->psRightNode = FLTCreateFilterEncodingNode();\n                FLTInsertElementInNode(psCurFilNode->psRightNode, psNextNode);\n                break;\n              }\n            }\n          }\n        }\n        else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else if (strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n        CPLXMLNode* psFirstNode = FLTGetFirstChildNode(psXMLNode);\n        if (psFirstNode) {\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          FLTInsertElementInNode(psFilterNode->psLeftNode,\n                                 psFirstNode);\n        }\n        else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else\n        psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n    }/* end if is logical */\n    /* -------------------------------------------------------------------- */\n    /*      Spatial Filter.                                                 */\n    /*      BBOX :                                                          */\n    /*      <Filter>                                                        */\n    /*       <BBOX>                                                         */\n    /*        <PropertyName>Geometry</PropertyName>                         */\n    /*        <gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">*/\n    /*          <gml:coordinates>13.0983,31.5899 35.5472,42.8143</gml:coordinates>*/\n    /*        </gml:Box>                                                    */\n    /*       </BBOX>                                                        */\n    /*      </Filter>                                                       */\n    /*                                                                      */\n    /*       DWithin                                                        */\n    /*                                                                      */\n    /*      <xsd:element name=\"DWithin\"                                     */\n    /*      type=\"ogc:DistanceBufferType\"                                   */\n    /*      substitutionGroup=\"ogc:spatialOps\"/>                            */\n    /*                                                                      */\n    /*      <xsd:complexType name=\"DistanceBufferType\">                     */\n    /*         <xsd:complexContent>                                         */\n    /*            <xsd:extension base=\"ogc:SpatialOpsType\">                 */\n    /*               <xsd:sequence>                                         */\n    /*                  <xsd:element ref=\"ogc:PropertyName\"/>               */\n    /*                  <xsd:element ref=\"gml:_Geometry\"/>                  */\n    /*                  <xsd:element name=\"Distance\" type=\"ogc:DistanceType\"/>*/\n    /*               </xsd:sequence>                                        */\n    /*            </xsd:extension>                                          */\n    /*         </xsd:complexContent>                                        */\n    /*      </xsd:complexType>                                              */\n    /*                                                                      */\n    /*                                                                      */\n    /*       <Filter>                                                       */\n    /*       <DWithin>                                                      */\n    /*        <PropertyName>Geometry</PropertyName>                         */\n    /*        <gml:Point>                                                   */\n    /*          <gml:coordinates>13.0983,31.5899</gml:coordinates>          */\n    /*        </gml:Point>                                                  */\n    /*        <Distance units=\"url#m\">10</Distance>                         */\n    /*       </DWithin>                                                     */\n    /*      </Filter>                                                       */\n    /*                                                                      */\n    /*       Intersect                                                      */\n    /*                                                                      */\n    /*       type=\"ogc:BinarySpatialOpType\" substitutionGroup=\"ogc:spatialOps\"/>*/\n    /*      <xsd:element name=\"Intersects\"                                  */\n    /*      type=\"ogc:BinarySpatialOpType\"                                  */\n    /*      substitutionGroup=\"ogc:spatialOps\"/>                            */\n    /*                                                                      */\n    /*      <xsd:complexType name=\"BinarySpatialOpType\">                    */\n    /*      <xsd:complexContent>                                            */\n    /*      <xsd:extension base=\"ogc:SpatialOpsType\">                       */\n    /*      <xsd:sequence>                                                  */\n    /*      <xsd:element ref=\"ogc:PropertyName\"/>                           */\n    /*      <xsd:choice>                                                    */\n    /*      <xsd:element ref=\"gml:_Geometry\"/>                              */\n    /*      <xsd:element ref=\"gml:Box\"/>                                    */\n    /*      </xsd:sequence>                                                 */\n    /*      </xsd:extension>                                                */\n    /*      </xsd:complexContent>                                           */\n    /*      </xsd:complexType>                                              */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsSpatialFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_SPATIAL;\n\n      if (strcasecmp(psXMLNode->pszValue, \"BBOX\") == 0) {\n        char *pszSRS = NULL;\n        const char* pszPropertyName = NULL;\n        CPLXMLNode *psBox = NULL, *psEnvelope=NULL;\n        rectObj sBox;\n\n        int bCoordinatesValid = 0;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n        psBox = CPLGetXMLNode(psXMLNode, \"Box\");\n        if (!psBox)\n          psBox = CPLGetXMLNode(psXMLNode, \"BoxType\");\n\n        /*FE 1.0 used box FE1.1 uses envelop*/\n        if (psBox)\n          bCoordinatesValid = FLTParseGMLBox(psBox, &sBox, &pszSRS);\n        else if ((psEnvelope = CPLGetXMLNode(psXMLNode, \"Envelope\")))\n          bCoordinatesValid = FLTParseGMLEnvelope(psEnvelope, &sBox, &pszSRS);\n\n        if (bCoordinatesValid) {\n          /*set the srs if available*/\n          if (pszSRS)\n            psFilterNode->pszSRS = pszSRS;\n\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psLeftNode->eType =  FILTER_NODE_TYPE_PROPERTYNAME;\n          /* PropertyName is optional since FE 1.1.0, in which case */\n          /* the BBOX must apply to all geometry fields. As we support */\n          /* currently only one geometry field, this doesn't make much */\n          /* difference to further processing. */\n          if( pszPropertyName != NULL ) {\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n          }\n\n          /* coordinates */\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_BBOX;\n          psFilterNode->psRightNode->pOther =\n          (rectObj *)msSmallMalloc(sizeof(rectObj));\n          ((rectObj *)psFilterNode->psRightNode->pOther)->minx = sBox.minx;\n          ((rectObj *)psFilterNode->psRightNode->pOther)->miny = sBox.miny;\n          ((rectObj *)psFilterNode->psRightNode->pOther)->maxx = sBox.maxx;\n          ((rectObj *)psFilterNode->psRightNode->pOther)->maxy =  sBox.maxy;\n        } else {\n          msFree(pszSRS);\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n        }\n      } else if (strcasecmp(psXMLNode->pszValue, \"DWithin\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Beyond\") == 0)\n\n      {\n        shapeObj *psShape = NULL;\n        int bPoint = 0, bLine = 0, bPolygon = 0;\n        const char *pszUnits = NULL;\n        const char* pszDistance = NULL;\n        const char* pszPropertyName;\n        char *pszSRS = NULL;\n\n        CPLXMLNode *psGMLElement = NULL, *psDistance=NULL;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n\n        psGMLElement = FLTFindGeometryNode(psXMLNode, &bPoint, &bLine, &bPolygon);\n\n        psDistance = CPLGetXMLNode(psXMLNode, \"Distance\");\n        if( psDistance != NULL )\n            pszDistance = CPLGetXMLValue(psDistance, NULL, NULL );\n        if (pszPropertyName != NULL && psGMLElement && psDistance != NULL ) {\n          pszUnits = CPLGetXMLValue(psDistance, \"units\", NULL);\n          if( pszUnits == NULL ) /* FE 2.0 */\n              pszUnits = CPLGetXMLValue(psDistance, \"uom\", NULL);\n          psShape = (shapeObj *)msSmallMalloc(sizeof(shapeObj));\n          msInitShape(psShape);\n          if (FLTShapeFromGMLTree(psGMLElement, psShape, &pszSRS))\n          {\n            /*set the srs if available*/\n            if (pszSRS)\n              psFilterNode->pszSRS = pszSRS;\n\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n            psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n            if (bPoint)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POINT;\n            else if (bLine)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_LINE;\n            else if (bPolygon)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POLYGON;\n            psFilterNode->psRightNode->pOther = (shapeObj *)psShape;\n            /*the value will be distance;units*/\n            psFilterNode->psRightNode->pszValue = msStrdup(pszDistance);\n            if (pszUnits) {\n              psFilterNode->psRightNode->pszValue= msStringConcatenate(psFilterNode->psRightNode->pszValue, \";\");\n              psFilterNode->psRightNode->pszValue= msStringConcatenate(psFilterNode->psRightNode->pszValue, pszUnits);\n            }\n          }\n          else\n          {\n              free(psShape);\n              msFree(pszSRS);\n              psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n          }\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else if (strcasecmp(psXMLNode->pszValue, \"Intersect\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Intersects\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Equals\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Disjoint\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Touches\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Crosses\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Within\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Contains\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Overlaps\") == 0) {\n        shapeObj *psShape = NULL;\n        int  bLine = 0, bPolygon = 0, bPoint=0;\n        char *pszSRS = NULL;\n        const char* pszPropertyName;\n\n        CPLXMLNode *psGMLElement = NULL;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n\n        psGMLElement = FLTFindGeometryNode(psXMLNode, &bPoint, &bLine, &bPolygon);\n\n        if (pszPropertyName != NULL && psGMLElement) {\n          psShape = (shapeObj *)msSmallMalloc(sizeof(shapeObj));\n          msInitShape(psShape);\n          if (FLTShapeFromGMLTree(psGMLElement, psShape, &pszSRS))\n          {\n            /*set the srs if available*/\n            if (pszSRS)\n              psFilterNode->pszSRS = pszSRS;\n\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n            psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n            if (bPoint)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POINT;\n            else if (bLine)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_LINE;\n            else if (bPolygon)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POLYGON;\n            psFilterNode->psRightNode->pOther = (shapeObj *)psShape;\n\n          }\n          else\n          {\n              free(psShape);\n              msFree(pszSRS);\n              psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n          }\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n\n    }/* end of is spatial */\n\n\n    /* -------------------------------------------------------------------- */\n    /*      Comparison Filter                                               */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsComparisonFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_COMPARISON;\n      /* -------------------------------------------------------------------- */\n      /*      binary comaparison types. Example :                             */\n      /*                                                                      */\n      /*      <Filter>                                                        */\n      /*        <PropertyIsEqualTo>                                           */\n      /*          <PropertyName>SomeProperty</PropertyName>                   */\n      /*          <Literal>100</Literal>                                      */\n      /*        </PropertyIsEqualTo>                                          */\n      /*      </Filter>                                                       */\n      /* -------------------------------------------------------------------- */\n      if (FLTIsBinaryComparisonFilterType(psXMLNode->pszValue)) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        if (pszPropertyName != NULL ) {\n\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n          psTmpNode = CPLSearchXMLNode(psXMLNode,  \"Literal\");\n          if (psTmpNode) {\n            const char* pszLiteral = CPLGetXMLValue(psTmpNode, NULL, NULL);\n\n            psFilterNode->psRightNode = FLTCreateBinaryCompFilterEncodingNode();\n            psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_LITERAL;\n\n            if (pszLiteral != NULL) {\n              const char* pszMatchCase;\n\n              psFilterNode->psRightNode->pszValue = msStrdup(pszLiteral);\n              \n              pszMatchCase = CPLGetXMLValue(psXMLNode, \"matchCase\", NULL);\n\n              /*check if the matchCase attribute is set*/\n              if( pszMatchCase != NULL && strcasecmp( pszMatchCase, \"false\") == 0) {\n                (*(int *)psFilterNode->psRightNode->pOther) = 1;\n              }\n\n            }\n            /* special case where the user puts an empty value */\n            /* for the Literal so it can end up as an empty  */\n            /* string query in the expression */\n            else\n              psFilterNode->psRightNode->pszValue = NULL;\n          }\n        }\n        if (psFilterNode->psLeftNode == NULL || psFilterNode->psRightNode == NULL)\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n      /* -------------------------------------------------------------------- */\n      /*      PropertyIsBetween filter : extract property name and boudary    */\n      /*      values. The boundary  values are stored in the right            */\n      /*      node. The values are separated by a semi-column (;)             */\n      /*      Eg of Filter :                                                  */\n      /*      <PropertyIsBetween>                                             */\n      /*         <PropertyName>DEPTH</PropertyName>                           */\n      /*         <LowerBoundary><Literal>400</Literal></LowerBoundary>        */\n      /*         <UpperBoundary><Literal>800</Literal></UpperBoundary>        */\n      /*      </PropertyIsBetween>                                            */\n      /*                                                                      */\n      /*      Or                                                              */\n      /*      <PropertyIsBetween>                                             */\n      /*         <PropertyName>DEPTH</PropertyName>                           */\n      /*         <LowerBoundary>400</LowerBoundary>                           */\n      /*         <UpperBoundary>800</UpperBoundary>                           */\n      /*      </PropertyIsBetween>                                            */\n      /* -------------------------------------------------------------------- */\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsBetween\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        CPLXMLNode* psLowerBoundary = CPLGetXMLNode(psXMLNode, \"LowerBoundary\");\n        CPLXMLNode* psUpperBoundary = CPLGetXMLNode(psXMLNode, \"UpperBoundary\");\n        const char* pszLowerNode = NULL;\n        const char* pszUpperNode = NULL;\n        if( psLowerBoundary != NULL )\n        {\n          /* check if the <Literal> is there */\n          if (CPLGetXMLNode(psLowerBoundary, \"Literal\") != NULL)\n            pszLowerNode = CPLGetXMLValue(psLowerBoundary, \"Literal\", NULL);\n          else\n            pszLowerNode = CPLGetXMLValue(psLowerBoundary, NULL, NULL);\n        }\n        if( psUpperBoundary != NULL )\n        {\n           if (CPLGetXMLNode(psUpperBoundary, \"Literal\") != NULL)\n            pszUpperNode = CPLGetXMLValue(psUpperBoundary, \"Literal\", NULL);\n          else\n            pszUpperNode = CPLGetXMLValue(psUpperBoundary, NULL, NULL);\n        }\n        if (pszPropertyName != NULL && pszLowerNode != NULL && pszUpperNode != NULL) {\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n\n          psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_BOUNDARY;\n\n          /* adding a ; between bounary values */\n          nStrLength = strlen(pszLowerNode) + strlen(pszUpperNode) + 2;\n\n          psFilterNode->psRightNode->pszValue =\n              (char *)malloc(sizeof(char)*(nStrLength));\n          strcpy( psFilterNode->psRightNode->pszValue, pszLowerNode);\n          strlcat(psFilterNode->psRightNode->pszValue, \";\", nStrLength);\n          strlcat(psFilterNode->psRightNode->pszValue, pszUpperNode, nStrLength);\n\n\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n\n      }/* end of PropertyIsBetween  */\n      /* -------------------------------------------------------------------- */\n      /*      PropertyIsLike                                                  */\n      /*                                                                      */\n      /*      <Filter>                                                        */\n      /*      <PropertyIsLike wildCard=\"*\" singleChar=\"#\" escape=\"!\">         */\n      /*      <PropertyName>LAST_NAME</PropertyName>                          */\n      /*      <Literal>JOHN*</Literal>                                        */\n      /*      </PropertyIsLike>                                               */\n      /*      </Filter>                                                       */\n      /* -------------------------------------------------------------------- */\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsLike\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        const char* pszLiteral = CPLGetXMLValue(psXMLNode, \"Literal\", NULL);\n        const char* pszWildCard = CPLGetXMLValue(psXMLNode, \"wildCard\", NULL);\n        const char* pszSingleChar = CPLGetXMLValue(psXMLNode, \"singleChar\", NULL);\n        const char* pszEscapeChar = CPLGetXMLValue(psXMLNode, \"escape\", NULL);\n        if( pszEscapeChar == NULL )\n            pszEscapeChar = CPLGetXMLValue(psXMLNode, \"escapeChar\", NULL);\n        if (pszPropertyName != NULL && pszLiteral != NULL &&\n            pszWildCard != NULL && pszSingleChar != NULL && pszEscapeChar != NULL)\n        {\n          FEPropertyIsLike* propIsLike;\n\n          propIsLike = (FEPropertyIsLike *)malloc(sizeof(FEPropertyIsLike));\n\n          psFilterNode->pOther = propIsLike;\n          propIsLike->bCaseInsensitive = 0;\n          propIsLike->pszWildCard = msStrdup(pszWildCard);\n          propIsLike->pszSingleChar = msStrdup(pszSingleChar);\n          propIsLike->pszEscapeChar = msStrdup(pszEscapeChar);\n\n          pszTmp = (char *)CPLGetXMLValue(psXMLNode, \"matchCase\", NULL);\n          if (pszTmp && strcasecmp(pszTmp, \"false\") == 0) {\n            propIsLike->bCaseInsensitive =1;\n          }\n          /* -------------------------------------------------------------------- */\n          /*      Create left and right node for the attribute and the value.     */\n          /* -------------------------------------------------------------------- */\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n          psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n\n          psFilterNode->psRightNode->pszValue = msStrdup(pszLiteral);\n\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_LITERAL;\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n\n      }\n\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsNull\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        if( pszPropertyName != NULL )\n        {\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n        }  else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsNil\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        if( pszPropertyName != NULL )\n        {\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n        }  else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n    }\n    /* -------------------------------------------------------------------- */\n    /*      FeatureId Filter                                                */\n    /*                                                                      */\n    /*      <ogc:Filter>                                                    */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.1013\"/>                         */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.10\"/>                           */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.13\"/>                           */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.140\"/>                          */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.5001\"/>                         */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.2001\"/>                         */\n    /*      </ogc:Filter>                                                   */\n    /*                                                                      */\n    /*                                                                      */\n    /*      Note that for FES1.1.0 the featureid has been depricated in     */\n    /*      favor of GmlObjectId                                            */\n    /*      <GmlObjectId gml:id=\"TREESA_1M.1234\"/>                          */\n    /*                                                                      */\n    /*      And in FES 2.0, in favor of <fes:ResourceId rid=\"foo.1234\"/>    */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsFeatureIdFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_FEATUREID;\n      pszFeatureId = CPLGetXMLValue(psXMLNode, \"fid\", NULL);\n      /*for FE 1.1.0 GmlObjectId */\n      if (pszFeatureId == NULL)\n        pszFeatureId = CPLGetXMLValue(psXMLNode, \"id\", NULL);\n      /*for FE 2.0 ResourceId */\n      if (pszFeatureId == NULL)\n        pszFeatureId = CPLGetXMLValue(psXMLNode, \"rid\", NULL);\n      pszFeatureIdList = NULL;\n\n      psFeatureIdNode = psXMLNode;\n      while (psFeatureIdNode) {\n        pszFeatureId = CPLGetXMLValue(psFeatureIdNode, \"fid\", NULL);\n        if (!pszFeatureId)\n          pszFeatureId = CPLGetXMLValue(psFeatureIdNode, \"id\", NULL);\n        if (!pszFeatureId)\n          pszFeatureId = CPLGetXMLValue(psFeatureIdNode, \"rid\", NULL);\n\n        if (pszFeatureId) {\n          if (pszFeatureIdList)\n            pszFeatureIdList = msStringConcatenate(pszFeatureIdList, \",\");\n\n          pszFeatureIdList = msStringConcatenate(pszFeatureIdList, pszFeatureId);\n        }\n        psFeatureIdNode = psFeatureIdNode->psNext;\n      }\n\n      if (pszFeatureIdList) {\n        msFree(psFilterNode->pszValue);\n        psFilterNode->pszValue =  msStrdup(pszFeatureIdList);\n        msFree(pszFeatureIdList);\n      } else\n        psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n    }\n    \n    /* -------------------------------------------------------------------- */\n    /*      Temporal Filter.                                                */\n    /*\n    <fes:During>\n    <fes:ValueReference>gml:TimeInstant</fes:ValueReference>\n    <gml:TimePeriod gml:id=\"TP1\">\n    <gml:begin>\n    <gml:TimeInstant gml:id=\"TI1\">\n    <gml:timePosition>2005-05-17T00:00:00Z</gml:timePosition>\n    </gml:TimeInstant>\n    </gml:begin>\n    <gml:end>\n    <gml:TimeInstant gml:id=\"TI2\">\n    <gml:timePosition>2005-05-23T00:00:00Z</gml:timePosition>\n    </gml:TimeInstant>\n    </gml:end>\n    </gml:TimePeriod>\n    </fes:During>\n    */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsTemporalFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_TEMPORAL;\n\n      if (strcasecmp(psXMLNode->pszValue, \"During\") == 0) {\n        const char* pszPropertyName = NULL;\n        const char* pszBeginTime;\n        const char* pszEndTime;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n        pszBeginTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.begin.TimeInstant.timePosition\", NULL);\n        if( pszBeginTime == NULL )\n            pszBeginTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.beginPosition\", NULL);\n        pszEndTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.end.TimeInstant.timePosition\", NULL);\n        if( pszEndTime == NULL )\n            pszEndTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.endPosition\", NULL);\n\n        if (pszPropertyName && pszBeginTime && pszEndTime &&\n            strchr(pszBeginTime, '\\'') == NULL && strchr(pszBeginTime, '\\\\') == NULL &&\n            strchr(pszEndTime, '\\'') == NULL && strchr(pszEndTime, '\\\\') == NULL &&\n            msTimeGetResolution(pszBeginTime) >= 0 &&\n            msTimeGetResolution(pszEndTime) >= 0) {\n\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psLeftNode->eType =  FILTER_NODE_TYPE_PROPERTYNAME;\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_TIME_PERIOD;\n          psFilterNode->psRightNode->pszValue = msSmallMalloc( strlen(pszBeginTime) + strlen(pszEndTime) + 2 );\n          sprintf(psFilterNode->psRightNode->pszValue, \"%s/%s\", pszBeginTime, pszEndTime);\n        }\n        else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else {\n        psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n    }/* end of is temporal */\n\n\n\n  }\n}\n\n\n/************************************************************************/\n/*            int FLTIsLogicalFilterType((char *pszValue)                  */\n/*                                                                      */\n/*      return TRUE if the value of the node is of logical filter       */\n/*       encoding type.                                                 */\n/************************************************************************/\nint FLTIsLogicalFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if (strcasecmp(pszValue, \"AND\") == 0 ||\n        strcasecmp(pszValue, \"OR\") == 0 ||\n        strcasecmp(pszValue, \"NOT\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*         int FLTIsBinaryComparisonFilterType(char *pszValue)             */\n/*                                                                      */\n/*      Binary comparison filter type.                                  */\n/************************************************************************/\nint FLTIsBinaryComparisonFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if (strcasecmp(pszValue, \"PropertyIsEqualTo\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNotEqualTo\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsLessThan\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsGreaterThan\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsLessThanOrEqualTo\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsGreaterThanOrEqualTo\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsComparisonFilterType(char *pszValue)                */\n/*                                                                      */\n/*      return TRUE if the value of the node is of comparison filter    */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsComparisonFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if (FLTIsBinaryComparisonFilterType(pszValue) ||\n        strcasecmp(pszValue, \"PropertyIsLike\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsBetween\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNull\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNil\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsFeatureIdFilterType(char *pszValue)              */\n/*                                                                      */\n/*      return TRUE if the value of the node is of featureid filter     */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsFeatureIdFilterType(const char *pszValue)\n{\n  if (pszValue && (strcasecmp(pszValue, \"FeatureId\") == 0 ||\n                   strcasecmp(pszValue, \"GmlObjectId\") == 0 ||\n                   strcasecmp(pszValue, \"ResourceId\") == 0))\n\n    return MS_TRUE;\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsSpatialFilterType(char *pszValue)                */\n/*                                                                      */\n/*      return TRUE if the value of the node is of spatial filter       */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsSpatialFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if ( strcasecmp(pszValue, \"BBOX\") == 0 ||\n         strcasecmp(pszValue, \"DWithin\") == 0 ||\n         strcasecmp(pszValue, \"Intersect\") == 0 ||\n         strcasecmp(pszValue, \"Intersects\") == 0 ||\n         strcasecmp(pszValue, \"Equals\") == 0 ||\n         strcasecmp(pszValue, \"Disjoint\") == 0 ||\n         strcasecmp(pszValue, \"Touches\") == 0 ||\n         strcasecmp(pszValue, \"Crosses\") == 0 ||\n         strcasecmp(pszValue, \"Within\") == 0 ||\n         strcasecmp(pszValue, \"Contains\") == 0 ||\n         strcasecmp(pszValue, \"Overlaps\") == 0 ||\n         strcasecmp(pszValue, \"Beyond\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsTemportalFilterType(char *pszValue)              */\n/*                                                                      */\n/*      return TRUE if the value of the node is of temporal filter      */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsTemporalFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if ( strcasecmp(pszValue, \"During\") == 0 )\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*           int FLTIsSupportedFilterType(CPLXMLNode *psXMLNode)           */\n/*                                                                      */\n/*      Verfify if the value of the node is one of the supported        */\n/*      filter type.                                                    */\n/************************************************************************/\nint FLTIsSupportedFilterType(CPLXMLNode *psXMLNode)\n{\n  if (psXMLNode) {\n    if (FLTIsLogicalFilterType(psXMLNode->pszValue) ||\n        FLTIsSpatialFilterType(psXMLNode->pszValue) ||\n        FLTIsComparisonFilterType(psXMLNode->pszValue) ||\n        FLTIsFeatureIdFilterType(psXMLNode->pszValue) ||\n        FLTIsTemporalFilterType(psXMLNode->pszValue))\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*                          FLTNumberOfFilterType                       */\n/*                                                                      */\n/*      Loop trhough the nodes and return the number of nodes of        */\n/*      specified value.                                                */\n/************************************************************************/\nint FLTNumberOfFilterType(FilterEncodingNode *psFilterNode, const char *szType)\n{\n  int nCount = 0;\n  int nLeftNode=0 , nRightNode = 0;\n\n  if (!psFilterNode || !szType || !psFilterNode->pszValue)\n    return 0;\n\n  if (strcasecmp(psFilterNode->pszValue, (char*)szType) == 0)\n    nCount++;\n\n  if (psFilterNode->psLeftNode)\n    nLeftNode = FLTNumberOfFilterType(psFilterNode->psLeftNode, szType);\n\n  nCount += nLeftNode;\n\n  if (psFilterNode->psRightNode)\n    nRightNode = FLTNumberOfFilterType(psFilterNode->psRightNode, szType);\n  nCount += nRightNode;\n\n  return nCount;\n}\n\n\n\n\n/************************************************************************/\n/*                          FLTValidForBBoxFilter                       */\n/*                                                                      */\n/*      Validate if there is only one BBOX filter node. Here is waht    */\n/*      is supported (is valid) :                                       */\n/*        - one node which is a BBOX                                    */\n/*        - a logical AND with a valid BBOX                             */\n/*                                                                      */\n/*      eg 1: <Filter>                                                  */\n/*            <BBOX>                                                    */\n/*              <PropertyName>Geometry</PropertyName>                   */\n/*              <gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">*/\n/*                <gml:coordinates>13.0983,31.5899 35.5472,42.8143</gml:coordinates>*/\n/*              </gml:Box>                                              */\n/*            </BBOX>                                                   */\n/*          </Filter>                                                   */\n/*                                                                      */\n/*      eg 2 :<Filter>                                                  */\n/*              <AND>                                                   */\n/*               <BBOX>                                                 */\n/*                <PropertyName>Geometry</PropertyName>                  */\n/*                <gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">*/\n/*                  <gml:coordinates>13.0983,31.5899 35.5472,42.8143</gml:coordinates>*/\n/*                </gml:Box>                                            */\n/*               </BBOX>                                                */\n/*               <PropertyIsEqualTo>                                    */\n/*               <PropertyName>SomeProperty</PropertyName>              */\n/*                <Literal>100</Literal>                                */\n/*              </PropertyIsEqualTo>                                    */\n/*             </AND>                                                   */\n/*           </Filter>                                                  */\n/*                                                                      */\n/************************************************************************/\nint FLTValidForBBoxFilter(FilterEncodingNode *psFilterNode)\n{\n  int nCount = 0;\n\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 1;\n\n  nCount = FLTNumberOfFilterType(psFilterNode, \"BBOX\");\n\n  if (nCount > 1)\n    return 0;\n  else if (nCount == 0)\n    return 1;\n\n  /* nCount ==1  */\n  if (strcasecmp(psFilterNode->pszValue, \"BBOX\") == 0)\n    return 1;\n\n  if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0) {\n    return FLTValidForBBoxFilter(psFilterNode->psLeftNode) &&\n           FLTValidForBBoxFilter(psFilterNode->psRightNode);\n  }\n\n  return 0;\n}\n\n#if 0\nstatic int FLTHasUniqueTopLevelDuringFilter(FilterEncodingNode *psFilterNode)\n{\n  int nCount = 0;\n\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 1;\n\n  nCount = FLTNumberOfFilterType(psFilterNode, \"During\");\n\n  if (nCount > 1)\n    return 0;\n  else if (nCount == 0)\n    return 1;\n\n  /* nCount ==1  */\n  if (strcasecmp(psFilterNode->pszValue, \"During\") == 0)\n    return 1;\n\n  if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0) {\n    return FLTHasUniqueTopLevelDuringFilter(psFilterNode->psLeftNode) &&\n           FLTHasUniqueTopLevelDuringFilter(psFilterNode->psRightNode);\n  }\n\n  return 0;\n}\n#endif\n\nint FLTIsLineFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n      psFilterNode->psRightNode &&\n      psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_GEOMETRY_LINE)\n    return 1;\n\n  return 0;\n}\n\nint FLTIsPolygonFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n      psFilterNode->psRightNode &&\n      psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_GEOMETRY_POLYGON)\n    return 1;\n\n  return 0;\n}\n\nint FLTIsPointFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n      psFilterNode->psRightNode &&\n      psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_GEOMETRY_POINT)\n    return 1;\n\n  return 0;\n}\n\nint FLTIsBBoxFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (strcasecmp(psFilterNode->pszValue, \"BBOX\") == 0)\n    return 1;\n\n  return 0;\n}\n\nshapeObj *FLTGetShape(FilterEncodingNode *psFilterNode, double *pdfDistance,\n                      int *pnUnit)\n{\n  char **tokens = NULL;\n  int nTokens = 0;\n  FilterEncodingNode *psNode = psFilterNode;\n  char *szUnitStr = NULL;\n  char *szUnit = NULL;\n\n  if (psNode) {\n    if (psNode->eType == FILTER_NODE_TYPE_SPATIAL && psNode->psRightNode)\n      psNode = psNode->psRightNode;\n\n    if (FLTIsGeometryFilterNodeType(psNode->eType)) {\n\n      if (psNode->pszValue && pdfDistance) {\n        /*\n        sytnax expected is \"distance;unit\" or just \"distance\"\n        if unit is there syntax is \"URI#unit\" (eg http://..../#m)\n        or just \"unit\"\n        */\n        tokens = msStringSplit(psNode->pszValue,';', &nTokens);\n        if (tokens && nTokens >= 1) {\n          *pdfDistance = atof(tokens[0]);\n\n          if (nTokens == 2 && pnUnit) {\n            szUnitStr = msStrdup(tokens[1]);\n            msFreeCharArray(tokens, nTokens);\n            nTokens = 0;\n            tokens = msStringSplit(szUnitStr,'#', &nTokens);\n            msFree(szUnitStr);\n            if (tokens && nTokens >= 1) {\n              if (nTokens ==1)\n                szUnit = tokens[0];\n              else\n                szUnit = tokens[1];\n\n              if (strcasecmp(szUnit,\"m\") == 0 ||\n                  strcasecmp(szUnit,\"meters\") == 0 )\n                *pnUnit = MS_METERS;\n              else if (strcasecmp(szUnit,\"km\") == 0 ||\n                       strcasecmp(szUnit,\"kilometers\") == 0)\n                *pnUnit = MS_KILOMETERS;\n              else if (strcasecmp(szUnit,\"NM\") == 0 ||\n                       strcasecmp(szUnit,\"nauticalmiles\") == 0)\n                *pnUnit = MS_NAUTICALMILES;\n              else if (strcasecmp(szUnit,\"mi\") == 0 ||\n                       strcasecmp(szUnit,\"miles\") == 0)\n                *pnUnit = MS_MILES;\n              else if (strcasecmp(szUnit,\"in\") == 0 ||\n                       strcasecmp(szUnit,\"inches\") == 0)\n                *pnUnit = MS_INCHES;\n              else if (strcasecmp(szUnit,\"ft\") == 0 ||\n                       strcasecmp(szUnit,\"feet\") == 0)\n                *pnUnit = MS_FEET;\n              else if (strcasecmp(szUnit,\"deg\") == 0 ||\n                       strcasecmp(szUnit,\"dd\") == 0)\n                *pnUnit = MS_DD;\n              else if (strcasecmp(szUnit,\"px\") == 0)\n                *pnUnit = MS_PIXELS;\n\n            }\n          }\n        } \n        msFreeCharArray(tokens, nTokens);\n      }\n\n      return (shapeObj *)psNode->pOther;\n    }\n  }\n  return NULL;\n}\n\n/************************************************************************/\n/*                                FLTGetBBOX                            */\n/*                                                                      */\n/*      Loop through the nodes are return the coordinates of the        */\n/*      first bbox node found. The retrun value is the epsg code of     */\n/*      the bbox.                                                       */\n/************************************************************************/\nconst char *FLTGetBBOX(FilterEncodingNode *psFilterNode, rectObj *psRect)\n{\n  const char *pszReturn = NULL;\n\n  if (!psFilterNode || !psRect)\n    return NULL;\n\n  if (psFilterNode->pszValue && strcasecmp(psFilterNode->pszValue, \"BBOX\") == 0) {\n    if (psFilterNode->psRightNode && psFilterNode->psRightNode->pOther) {\n      rectObj* pRect= (rectObj *)psFilterNode->psRightNode->pOther;\n      psRect->minx = pRect->minx;\n      psRect->miny = pRect->miny;\n      psRect->maxx = pRect->maxx;\n      psRect->maxy = pRect->maxy;\n\n      return psFilterNode->pszSRS;\n\n    }\n  } else {\n    pszReturn = FLTGetBBOX(psFilterNode->psLeftNode, psRect);\n    if (pszReturn)\n      return pszReturn;\n    else\n      return  FLTGetBBOX(psFilterNode->psRightNode, psRect);\n  }\n\n  return pszReturn;\n}\n\nconst char* FLTGetDuring(FilterEncodingNode *psFilterNode, const char** ppszTimeField)\n{\n  const char *pszReturn = NULL;\n\n  if (!psFilterNode || !ppszTimeField)\n    return NULL;\n\n  if (psFilterNode->pszValue && strcasecmp(psFilterNode->pszValue, \"During\") == 0) {\n    *ppszTimeField = psFilterNode->psLeftNode->pszValue;\n    return psFilterNode->psRightNode->pszValue;\n  } else {\n    pszReturn = FLTGetDuring(psFilterNode->psLeftNode, ppszTimeField);\n    if (pszReturn)\n      return pszReturn;\n    else\n      return  FLTGetDuring(psFilterNode->psRightNode, ppszTimeField);\n  }\n\n  return pszReturn;\n}\n\n/************************************************************************/\n/*                          GetMapserverExpression                      */\n/*                                                                      */\n/*      Return a mapserver expression base on the Filer encoding nodes. */\n/************************************************************************/\nchar *FLTGetMapserverExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  const char *pszAttribute = NULL;\n  char szTmp[256];\n  char **tokens = NULL;\n  int nTokens = 0, i=0,bString=0;\n\n  if (!psFilterNode)\n    return NULL;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON) {\n    if ( psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n      if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue)) {\n        pszExpression = FLTGetBinaryComparisonExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsBetween\") == 0) {\n        pszExpression = FLTGetIsBetweenComparisonExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsLike\") == 0) {\n        pszExpression = FLTGetIsLikeComparisonExpression(psFilterNode);\n      }\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n        strcasecmp(psFilterNode->pszValue, \"OR\") == 0) {\n      pszExpression = FLTGetLogicalComparisonExpresssion(psFilterNode, lp);\n    } else if (strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n      pszExpression = FLTGetLogicalComparisonExpresssion(psFilterNode, lp);\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL) {\n    /* TODO */\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_FEATUREID) {\n#if defined(USE_WMS_SVR) || defined (USE_WFS_SVR) || defined (USE_WCS_SVR) || defined(USE_SOS_SVR)\n    if (psFilterNode->pszValue) {\n      pszAttribute = msOWSLookupMetadata(&(lp->metadata), \"OFG\", \"featureid\");\n      if (pszAttribute) {\n        tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n        if (tokens && nTokens > 0) {\n          for (i=0; i<nTokens; i++) {\n            const char* pszId = tokens[i];\n            const char* pszDot = strchr(pszId, '.');\n            if( pszDot )\n                pszId = pszDot + 1;\n            if (i == 0) {\n              if(FLTIsNumeric(pszId) == MS_FALSE)\n                bString = 1;\n            }\n            if (bString)\n              snprintf(szTmp, sizeof(szTmp), \"('[%s]' = '%s')\" , pszAttribute, pszId);\n            else\n              snprintf(szTmp, sizeof(szTmp), \"([%s] = %s)\" , pszAttribute, pszId);\n\n            if (pszExpression != NULL)\n              pszExpression = msStringConcatenate(pszExpression, \" OR \");\n            else\n              pszExpression = msStringConcatenate(pszExpression, \"(\");\n            pszExpression = msStringConcatenate(pszExpression, szTmp);\n          }\n\n          msFreeCharArray(tokens, nTokens);\n        }\n      }\n      /*opening and closing brackets are needed for mapserver expressions*/\n      if (pszExpression)\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n    }\n#else\n    msSetError(MS_MISCERR, \"OWS support is not available.\",\n               \"FLTGetMapserverExpression()\");\n    return(MS_FAILURE);\n#endif\n\n  }\n  return pszExpression;\n}\n\n\n/************************************************************************/\n/*                           FLTGetSQLExpression                        */\n/*                                                                      */\n/*      Build SQL expressions from the mapserver nodes.                 */\n/************************************************************************/\nchar *FLTGetSQLExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  const char *pszAttribute = NULL;\n  char szTmp[256];\n  char **tokens = NULL;\n  int nTokens = 0, i=0, bString=0;\n\n  if (psFilterNode == NULL || lp == NULL)\n    return NULL;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON) {\n    if ( psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n      if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue)) {\n        pszExpression =\n          FLTGetBinaryComparisonSQLExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsBetween\") == 0) {\n        pszExpression =\n          FLTGetIsBetweenComparisonSQLExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsLike\") == 0) {\n        pszExpression =\n          FLTGetIsLikeComparisonSQLExpression(psFilterNode, lp);\n\n      }\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n        strcasecmp(psFilterNode->pszValue, \"OR\") == 0) {\n      pszExpression =\n        FLTGetLogicalComparisonSQLExpresssion(psFilterNode, lp);\n\n    } else if (strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n      pszExpression =\n        FLTGetLogicalComparisonSQLExpresssion(psFilterNode, lp);\n\n    }\n  }\n\n  else if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL) {\n    /* TODO */\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_FEATUREID) {\n#if defined(USE_WMS_SVR) || defined (USE_WFS_SVR) || defined (USE_WCS_SVR) || defined(USE_SOS_SVR)\n    if (psFilterNode->pszValue) {\n      pszAttribute = msOWSLookupMetadata(&(lp->metadata), \"OFG\", \"featureid\");\n      if (pszAttribute) {\n        tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n        bString = 0;\n        if (tokens && nTokens > 0) {\n          for (i=0; i<nTokens; i++) {\n            char *pszEscapedStr = NULL;\n            const char* pszId = tokens[i];\n            const char* pszDot = strchr(pszId, '.');\n            if( pszDot )\n                pszId = pszDot + 1;\n\n            if (strlen(pszId) <= 0)\n              continue;\n\n            if (FLTIsNumeric(pszId) == MS_FALSE)\n              bString = 1;\n\n            pszEscapedStr = msLayerEscapeSQLParam(lp, pszId);\n            if (bString)\n            {\n              if( lp->connectiontype == MS_OGR || lp->connectiontype == MS_POSTGIS )\n                snprintf(szTmp, sizeof(szTmp), \"(CAST(%s AS CHARACTER(255)) = '%s')\" , pszAttribute, pszEscapedStr);\n              else\n                snprintf(szTmp, sizeof(szTmp), \"(%s = '%s')\" , pszAttribute, pszEscapedStr);\n            }\n            else\n              snprintf(szTmp, sizeof(szTmp), \"(%s = %s)\" , pszAttribute, pszEscapedStr);\n\n            msFree(pszEscapedStr);\n            pszEscapedStr=NULL;\n\n            if (pszExpression != NULL)\n              pszExpression = msStringConcatenate(pszExpression, \" OR \");\n            else\n              /*opening and closing brackets*/\n              pszExpression = msStringConcatenate(pszExpression, \"(\");\n\n            pszExpression = msStringConcatenate(pszExpression, szTmp);\n          }\n\n          msFreeCharArray(tokens, nTokens);\n        }\n      }\n      /*opening and closing brackets*/\n      if (pszExpression)\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n    }\n#else\n    msSetError(MS_MISCERR, \"OWS support is not available.\",\n               \"FLTGetSQLExpression()\");\n    return(MS_FAILURE);\n#endif\n\n  }\n  else if ( lp->connectiontype != MS_OGR &&\n            psFilterNode->eType == FILTER_NODE_TYPE_TEMPORAL )\n    pszExpression = FLTGetTimeExpression(psFilterNode, lp);\n\n  return pszExpression;\n}\n\n/************************************************************************/\n/*                            FLTGetNodeExpression                      */\n/*                                                                      */\n/*      Return the expresion for a specific node.                       */\n/************************************************************************/\nchar *FLTGetNodeExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  if (!psFilterNode)\n    return NULL;\n\n  if (FLTIsLogicalFilterType(psFilterNode->pszValue))\n    pszExpression = FLTGetLogicalComparisonExpresssion(psFilterNode, lp);\n  else if (FLTIsComparisonFilterType(psFilterNode->pszValue)) {\n    if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n      pszExpression = FLTGetBinaryComparisonExpresssion(psFilterNode, lp);\n    else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0)\n      pszExpression = FLTGetIsBetweenComparisonExpresssion(psFilterNode, lp);\n    else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n      pszExpression = FLTGetIsLikeComparisonExpression(psFilterNode);\n  }\n\n  return pszExpression;\n}\n\n\n/************************************************************************/\n/*                     FLTGetLogicalComparisonSQLExpresssion            */\n/*                                                                      */\n/*      Return the expression for logical comparison expression.        */\n/************************************************************************/\nchar *FLTGetLogicalComparisonSQLExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  char *pszBuffer = NULL;\n  char *pszTmp = NULL;\n  int nTmp = 0;\n\n  if (lp == NULL)\n    return NULL;\n\n  /* ==================================================================== */\n  /*      special case for BBOX node.                                     */\n  /* ==================================================================== */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode &&\n      ((strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") == 0) ||\n       (strcasecmp(psFilterNode->psRightNode->pszValue, \"BBOX\") == 0))) {\n    if (strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") != 0)\n      pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    else\n      pszTmp = FLTGetSQLExpression(psFilterNode->psRightNode, lp);\n\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) + 1));\n    sprintf(pszBuffer, \"%s\", pszTmp);\n  }\n\n  /* ==================================================================== */\n  /*      special case for temporal filter node (OGR layer only)          */\n  /* ==================================================================== */\n  else if (lp->connectiontype == MS_OGR &&\n      psFilterNode->psLeftNode && psFilterNode->psRightNode &&\n      (psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_TEMPORAL ||\n       psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_TEMPORAL) ) {\n    if (psFilterNode->psLeftNode->eType != FILTER_NODE_TYPE_TEMPORAL)\n      pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    else\n      pszTmp = FLTGetSQLExpression(psFilterNode->psRightNode, lp);\n\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) + 1));\n    sprintf(pszBuffer, \"%s\", pszTmp);\n  }\n  \n  /* -------------------------------------------------------------------- */\n  /*      OR and AND                                                      */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n    pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) *\n                               (strlen(pszTmp) +\n                                strlen(psFilterNode->pszValue) + 5));\n    pszBuffer[0] = '\\0';\n    strcat(pszBuffer, \" (\");\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \" \");\n    strcat(pszBuffer, psFilterNode->pszValue);\n    strcat(pszBuffer, \" \");\n\n    free( pszTmp );\n\n    nTmp = strlen(pszBuffer);\n    pszTmp = FLTGetSQLExpression(psFilterNode->psRightNode, lp);\n    if (!pszTmp) {\n      free(pszBuffer);\n      return NULL;\n    }\n\n    pszBuffer = (char *)realloc(pszBuffer,\n                                sizeof(char) * (strlen(pszTmp) + nTmp +3));\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n  }\n  /* -------------------------------------------------------------------- */\n  /*      NOT                                                             */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode &&\n           strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n    pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) +  9));\n    pszBuffer[0] = '\\0';\n\n    strcat(pszBuffer, \" (NOT \");\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n  } else\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Cleanup.                                                        */\n  /* -------------------------------------------------------------------- */\n  if( pszTmp != NULL )\n    free( pszTmp );\n  return pszBuffer;\n\n}\n\n/************************************************************************/\n/*                     FLTGetLogicalComparisonExpresssion               */\n/*                                                                      */\n/*      Return the expression for logical comparison expression.        */\n/************************************************************************/\nchar *FLTGetLogicalComparisonExpresssion(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszTmp = NULL;\n  char *pszBuffer = NULL;\n  int nTmp = 0;\n\n  if (!psFilterNode || !FLTIsLogicalFilterType(psFilterNode->pszValue))\n    return NULL;\n\n\n  /* ==================================================================== */\n  /*      special case for BBOX node.                                     */\n  /* ==================================================================== */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode &&\n      (strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") == 0 ||\n       strcasecmp(psFilterNode->psRightNode->pszValue, \"BBOX\") == 0 ||\n       FLTIsGeosNode(psFilterNode->psLeftNode->pszValue) ||\n       FLTIsGeosNode(psFilterNode->psRightNode->pszValue)))\n\n\n  {\n\n    /*strcat(szBuffer, \" (\");*/\n    if (strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") != 0 &&\n        strcasecmp(psFilterNode->psLeftNode->pszValue, \"DWithin\") != 0 &&\n        FLTIsGeosNode(psFilterNode->psLeftNode->pszValue) == MS_FALSE)\n      pszTmp = FLTGetNodeExpression(psFilterNode->psLeftNode, lp);\n    else\n      pszTmp = FLTGetNodeExpression(psFilterNode->psRightNode, lp);\n\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) + 3));\n    pszBuffer[0] = '\\0';\n    /*\n    if (strcasecmp(psFilterNode->psLeftNode->pszValue, \"PropertyIsLike\") == 0 ||\n        strcasecmp(psFilterNode->psRightNode->pszValue, \"PropertyIsLike\") == 0)\n      sprintf(pszBuffer, \"%s\", pszTmp);\n    else\n    */\n    sprintf(pszBuffer, \"(%s)\", pszTmp);\n\n    free(pszTmp);\n\n    return pszBuffer;\n  }\n\n\n  /* -------------------------------------------------------------------- */\n  /*      OR and AND                                                      */\n  /* -------------------------------------------------------------------- */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n    pszTmp = FLTGetNodeExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) *\n                               (strlen(pszTmp) + strlen(psFilterNode->pszValue) + 5));\n    pszBuffer[0] = '\\0';\n    strcat(pszBuffer, \" (\");\n\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \" \");\n    strcat(pszBuffer, psFilterNode->pszValue);\n    strcat(pszBuffer, \" \");\n    free(pszTmp);\n\n    pszTmp = FLTGetNodeExpression(psFilterNode->psRightNode, lp);\n    if (!pszTmp) {\n      msFree(pszBuffer);\n      return NULL;\n    }\n\n    nTmp = strlen(pszBuffer);\n    pszBuffer = (char *)realloc(pszBuffer,\n                                sizeof(char) * (strlen(pszTmp) + nTmp +3));\n\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n    free(pszTmp);\n  }\n  /* -------------------------------------------------------------------- */\n  /*      NOT                                                             */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode &&\n           strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n    pszTmp = FLTGetNodeExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) *\n                               (strlen(pszTmp) +  9));\n    pszBuffer[0] = '\\0';\n    strcat(pszBuffer, \" (NOT \");\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n\n    free(pszTmp);\n  } else\n    return NULL;\n\n  return pszBuffer;\n\n}\n\n\n\n/************************************************************************/\n/*                      FLTGetBinaryComparisonExpresssion               */\n/*                                                                      */\n/*      Return the expression for a binary comparison filter node.      */\n/************************************************************************/\nchar *FLTGetBinaryComparisonExpresssion(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  int bString=0;\n  char szTmp[256];\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode || !FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (psFilterNode->psRightNode->pszValue) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n    else if (FLTIsNumeric(psFilterNode->psRightNode->pszValue) == MS_FALSE)\n      bString = 1;\n  }\n\n  /* specical case to be able to have empty strings in the expression. */\n  if (psFilterNode->psRightNode->pszValue == NULL)\n    bString = 1;\n\n\n  if (bString)\n    strlcat(szBuffer, \" (\\\"[\", bufferSize);\n  else\n    strlcat(szBuffer, \" ([\", bufferSize);\n  /* attribute */\n\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  if (bString)\n    strlcat(szBuffer, \"]\\\" \", bufferSize);\n  else\n    strlcat(szBuffer, \"] \", bufferSize);\n\n\n  /* logical operator */\n  if (strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0) {\n    /*case insensitive set ? */\n    if (psFilterNode->psRightNode->pOther &&\n        (*(int *)psFilterNode->psRightNode->pOther) == 1) {\n      strlcat(szBuffer, \"IEQ\", bufferSize);\n    } else\n      strlcat(szBuffer, \"=\", bufferSize);\n  } else if (strcasecmp(psFilterNode->pszValue,\n                        \"PropertyIsNotEqualTo\") == 0)\n    strlcat(szBuffer, \"!=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThan\") == 0)\n    strlcat(szBuffer, \"<\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThan\") == 0)\n    strlcat(szBuffer, \">\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \"<=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \">=\", bufferSize);\n\n  strlcat(szBuffer, \" \", bufferSize);\n\n  /* value */\n  if (bString)\n    strlcat(szBuffer, \"\\\"\", bufferSize);\n\n  if (psFilterNode->psRightNode->pszValue)\n    strlcat(szBuffer, psFilterNode->psRightNode->pszValue, bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \"\\\"\", bufferSize);\n\n  strlcat(szBuffer, \") \", bufferSize);\n\n  return msStrdup(szBuffer);\n}\n\n\n\n\n/************************************************************************/\n/*                      FLTGetBinaryComparisonSQLExpresssion            */\n/*                                                                      */\n/*      Return the expression for a binary comparison filter node.      */\n/************************************************************************/\nchar *FLTGetBinaryComparisonSQLExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  int bString=0;\n  char szTmp[256];\n  char* pszEscapedStr = NULL;\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode || !\n      FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (psFilterNode->psRightNode->pszValue) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n\n    else if (FLTIsNumeric(psFilterNode->psRightNode->pszValue) == MS_FALSE)\n      bString = 1;\n  }\n\n  /* specical case to be able to have empty strings in the expression. */\n  if (psFilterNode->psRightNode->pszValue == NULL)\n    bString = 1;\n\n\n  /*opening bracket*/\n  strlcat(szBuffer, \" (\", bufferSize);\n\n  pszEscapedStr = msLayerEscapePropertyName(lp, psFilterNode->psLeftNode->pszValue);\n\n\n  /* attribute */\n  /*case insensitive set ? */\n  if (bString &&\n      strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0 &&\n      psFilterNode->psRightNode->pOther &&\n      (*(int *)psFilterNode->psRightNode->pOther) == 1) {\n    snprintf(szTmp, sizeof(szTmp), \"lower(%s) \",  pszEscapedStr);\n    strlcat(szBuffer, szTmp, bufferSize);\n  } else\n    strlcat(szBuffer, pszEscapedStr, bufferSize);\n\n  msFree(pszEscapedStr);\n  pszEscapedStr = NULL;\n\n\n  /* logical operator */\n  if (strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0)\n    strlcat(szBuffer, \"=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsNotEqualTo\") == 0)\n    strlcat(szBuffer, \"<>\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThan\") == 0)\n    strlcat(szBuffer, \"<\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThan\") == 0)\n    strlcat(szBuffer, \">\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \"<=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \">=\", bufferSize);\n\n  strlcat(szBuffer, \" \", bufferSize);\n\n  /* value */\n\n  if (bString &&\n      psFilterNode->psRightNode->pszValue &&\n      strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0 &&\n      psFilterNode->psRightNode->pOther &&\n      (*(int *)psFilterNode->psRightNode->pOther) == 1) {\n    char* pszEscapedStr;\n    pszEscapedStr = msLayerEscapeSQLParam(lp, psFilterNode->psRightNode->pszValue);\n    snprintf(szTmp, sizeof(szTmp), \"lower('%s') \", pszEscapedStr);\n    msFree(pszEscapedStr);\n    strlcat(szBuffer, szTmp, bufferSize);\n  } else {\n    if (bString)\n      strlcat(szBuffer, \"'\", bufferSize);\n\n    if (psFilterNode->psRightNode->pszValue) {\n      if (bString) {\n        char* pszEscapedStr;\n        pszEscapedStr = msLayerEscapeSQLParam(lp, psFilterNode->psRightNode->pszValue);\n        strlcat(szBuffer, pszEscapedStr, bufferSize);\n        msFree(pszEscapedStr);\n        pszEscapedStr=NULL;\n      } else\n        strlcat(szBuffer, psFilterNode->psRightNode->pszValue, bufferSize);\n    }\n\n    if (bString)\n      strlcat(szBuffer, \"'\", bufferSize);\n\n  }\n  /*closing bracket*/\n  strlcat(szBuffer, \") \", bufferSize);\n\n  return msStrdup(szBuffer);\n}\n\n\n/************************************************************************/\n/*                    FLTGetIsBetweenComparisonSQLExpresssion           */\n/*                                                                      */\n/*      Build an SQL expresssion for IsBteween Filter.                  */\n/************************************************************************/\nchar *FLTGetIsBetweenComparisonSQLExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char **aszBounds = NULL;\n  int nBounds = 0;\n  int bString=0;\n  char szTmp[256];\n  char* pszEscapedStr;\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode ||\n      !(strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0))\n    return NULL;\n\n  if (!psFilterNode->psLeftNode || !psFilterNode->psRightNode )\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Get the bounds value which are stored like boundmin;boundmax    */\n  /* -------------------------------------------------------------------- */\n  aszBounds = msStringSplit(psFilterNode->psRightNode->pszValue, ';', &nBounds);\n  if (nBounds != 2) {\n    msFreeCharArray(aszBounds, nBounds);\n    return NULL;\n  }\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (aszBounds[0]) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n    else if (FLTIsNumeric(aszBounds[0]) == MS_FALSE)\n      bString = 1;\n  }\n  if (!bString) {\n    if (aszBounds[1]) {\n      if (FLTIsNumeric(aszBounds[1]) == MS_FALSE)\n        bString = 1;\n    }\n  }\n\n\n  /* -------------------------------------------------------------------- */\n  /*      build expresssion.                                              */\n  /* -------------------------------------------------------------------- */\n  /*opening paranthesis */\n  strlcat(szBuffer, \" (\", bufferSize);\n\n  /* attribute */\n  pszEscapedStr = msLayerEscapePropertyName(lp, psFilterNode->psLeftNode->pszValue);\n\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr = NULL;\n\n  /*between*/\n  strlcat(szBuffer, \" BETWEEN \", bufferSize);\n\n  /*bound 1*/\n  if (bString)\n    strlcat(szBuffer,\"'\", bufferSize);\n  pszEscapedStr = msLayerEscapeSQLParam( lp, aszBounds[0]);\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr=NULL;\n\n  if (bString)\n    strlcat(szBuffer,\"'\", bufferSize);\n\n  strlcat(szBuffer, \" AND \", bufferSize);\n\n  /*bound 2*/\n  if (bString)\n    strlcat(szBuffer, \"'\", bufferSize);\n  pszEscapedStr = msLayerEscapeSQLParam( lp, aszBounds[1]);\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr=NULL;\n\n  if (bString)\n    strlcat(szBuffer,\"'\", bufferSize);\n\n  /*closing paranthesis*/\n  strlcat(szBuffer, \")\", bufferSize);\n\n  msFreeCharArray(aszBounds, nBounds);\n\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                    FLTGetIsBetweenComparisonExpresssion              */\n/*                                                                      */\n/*      Build expresssion for IsBteween Filter.                         */\n/************************************************************************/\nchar *FLTGetIsBetweenComparisonExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char **aszBounds = NULL;\n  int nBounds = 0;\n  int bString=0;\n  char szTmp[256];\n\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode ||\n      !(strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0))\n    return NULL;\n\n  if (!psFilterNode->psLeftNode || !psFilterNode->psRightNode )\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Get the bounds value which are stored like boundmin;boundmax    */\n  /* -------------------------------------------------------------------- */\n  aszBounds = msStringSplit(psFilterNode->psRightNode->pszValue, ';', &nBounds);\n  if (nBounds != 2) {\n    msFreeCharArray(aszBounds, nBounds);\n    return NULL;\n  }\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (aszBounds[0]) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n    else if (FLTIsNumeric(aszBounds[0]) == MS_FALSE)\n      bString = 1;\n  }\n  if (!bString) {\n    if (aszBounds[1]) {\n      if (FLTIsNumeric(aszBounds[1]) == MS_FALSE)\n        bString = 1;\n    }\n  }\n\n\n  /* -------------------------------------------------------------------- */\n  /*      build expresssion.                                              */\n  /* -------------------------------------------------------------------- */\n  if (bString)\n    strlcat(szBuffer, \" (\\\"[\", bufferSize);\n  else\n    strlcat(szBuffer, \" ([\", bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \"]\\\" \", bufferSize);\n  else\n    strlcat(szBuffer, \"] \", bufferSize);\n\n\n  strlcat(szBuffer, \" >= \", bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n  strlcat(szBuffer, aszBounds[0], bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n\n  strlcat(szBuffer, \" AND \", bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \" \\\"[\", bufferSize);\n  else\n    strlcat(szBuffer, \" [\", bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \"]\\\" \", bufferSize);\n  else\n    strlcat(szBuffer, \"] \", bufferSize);\n\n  strlcat(szBuffer, \" <= \", bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n  strlcat(szBuffer, aszBounds[1], bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n\n  msFreeCharArray(aszBounds, nBounds);\n\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                      FLTGetIsLikeComparisonExpression               */\n/*                                                                      */\n/*      Build expression for IsLike filter.                             */\n/************************************************************************/\nchar *FLTGetIsLikeComparisonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n\n  int nLength=0, i=0, iTmp=0;\n  FEPropertyIsLike* propIsLike;\n\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode ||\n      !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 ||\n      !pszSingle || strlen(pszSingle) == 0 ||\n      !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \" (\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /*#3521 */\n  if(bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* /\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" =~ /\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] &&\n      pszValue[0] != pszSingle[0] &&\n      pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] &&\n        pszValue[i] != pszSingle[0] &&\n        pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if  (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if  (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n\n    } else if (pszValue[i] == pszWild[0]) {\n      /* strcat(szBuffer, \"[0-9,a-z,A-Z,\\\\s]*\"); */\n      /* iBuffer+=17; */\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '/';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                      FLTGetIsLikeComparisonSQLExpression             */\n/*                                                                      */\n/*      Build an sql expression for IsLike filter.                      */\n/************************************************************************/\nchar *FLTGetIsLikeComparisonSQLExpression(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  char szTmp[4];\n\n  int nLength=0, i=0, j=0;\n  int  bCaseInsensitive = 0;\n\n  char *pszEscapedStr = NULL;\n  FEPropertyIsLike* propIsLike;\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode ||\n      !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 ||\n      !pszSingle || strlen(pszSingle) == 0 ||\n      !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  if (pszEscape[0] == '\\'') {\n    /* This might be valid, but the risk of SQL injection is too high */\n    /* and the below code is not ready for that */\n    /* Someone who does this has clearly suspect intentions ! */\n    msSetError(MS_MISCERR, \"Single quote character is not allowed as an escaping character.\",\n               \"FLTGetIsLikeComparisonSQLExpression()\");\n    return NULL;\n  }\n\n\n  szBuffer[0] = '\\0';\n  /*opening bracket*/\n  strlcat(szBuffer, \" (\", bufferSize);\n\n  /* attribute name */\n  pszEscapedStr = msLayerEscapePropertyName(lp, psFilterNode->psLeftNode->pszValue);\n\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr = NULL;\n\n  if (lp->connectiontype == MS_POSTGIS) {\n    if (bCaseInsensitive == 1)\n      strlcat(szBuffer, \"::text ilike '\", bufferSize);\n    else\n      strlcat(szBuffer, \"::text like '\", bufferSize);\n  } else\n    strlcat(szBuffer, \" like '\", bufferSize);\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n\n  pszEscapedStr = (char*) msSmallMalloc( 3 * nLength + 1);\n\n  for (i=0, j=0; i<nLength; i++) {\n    char c = pszValue[i];\n    if (c != pszWild[0] &&\n        c != pszSingle[0] &&\n        c != pszEscape[0]) {\n      if (c == '\\'') {\n        pszEscapedStr[j++] = '\\'';\n        pszEscapedStr[j++] = '\\'';\n      } else if (c == '\\\\') {\n        pszEscapedStr[j++] = '\\\\';\n        pszEscapedStr[j++] = '\\\\';\n      } else\n        pszEscapedStr[j++] = c;\n    } else if  (c == pszSingle[0]) {\n      pszEscapedStr[j++] = '_';\n    } else if  (c == pszEscape[0]) {\n      pszEscapedStr[j++] = pszEscape[0];\n      if (i+1<nLength) {\n        char nextC = pszValue[i+1];\n        i++;\n        if (nextC == '\\'') {\n          pszEscapedStr[j++] = '\\'';\n          pszEscapedStr[j++] = '\\'';\n        } else\n          pszEscapedStr[j++] = nextC;\n      }\n    } else if (c == pszWild[0]) {\n      pszEscapedStr[j++] = '%';\n    }\n  }\n  pszEscapedStr[j++] = 0;\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n\n  strlcat(szBuffer, \"'\", bufferSize);\n  if (lp->connectiontype != MS_OGR) {\n    if (lp->connectiontype == MS_POSTGIS && pszEscape[0] == '\\\\')\n        strlcat(szBuffer, \" escape E'\", bufferSize);\n    else\n        strlcat(szBuffer, \" escape '\", bufferSize);\n    szTmp[0] = pszEscape[0];\n    if (pszEscape[0] == '\\\\') {\n      szTmp[1] = '\\\\';\n      szTmp[2] = '\\'';\n      szTmp[3] = '\\0';\n    } else {\n      szTmp[1] = '\\'';\n      szTmp[2] = '\\0';\n    }\n\n    strlcat(szBuffer,  szTmp, bufferSize);\n  }\n  strlcat(szBuffer,  \") \", bufferSize);\n\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                           FLTHasSpatialFilter                        */\n/*                                                                      */\n/*      Utility function to see if a spatial filter is included in      */\n/*      the node.                                                       */\n/************************************************************************/\nint FLTHasSpatialFilter(FilterEncodingNode *psNode)\n{\n  int bResult = MS_FALSE;\n\n  if (!psNode)\n    return MS_FALSE;\n\n  if (psNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    if (psNode->psLeftNode)\n      bResult = FLTHasSpatialFilter(psNode->psLeftNode);\n\n    if (bResult)\n      return MS_TRUE;\n\n    if (psNode->psRightNode)\n      bResult = FLTHasSpatialFilter(psNode->psRightNode);\n\n    if (bResult)\n      return MS_TRUE;\n  } else if (FLTIsBBoxFilter(psNode) || FLTIsPointFilter(psNode) ||\n             FLTIsLineFilter(psNode) || FLTIsPolygonFilter(psNode))\n    return MS_TRUE;\n\n\n  return MS_FALSE;\n}\n\n\n/************************************************************************/\n/*                     FLTCreateFeatureIdFilterEncoding                 */\n/*                                                                      */\n/*      Utility function to create a filter node of FeatureId type.     */\n/************************************************************************/\nFilterEncodingNode *FLTCreateFeatureIdFilterEncoding(const char *pszString)\n{\n  FilterEncodingNode *psFilterNode = NULL;\n\n  if (pszString) {\n    psFilterNode = FLTCreateFilterEncodingNode();\n    psFilterNode->eType = FILTER_NODE_TYPE_FEATUREID;\n    psFilterNode->pszValue =  msStrdup(pszString);\n    return psFilterNode;\n  }\n  return NULL;\n}\n\n\n/************************************************************************/\n/*                              FLTParseGMLBox                          */\n/*                                                                      */\n/*      Parse gml box. Used for FE 1.0                                  */\n/************************************************************************/\nint FLTParseGMLBox(CPLXMLNode *psBox, rectObj *psBbox, char **ppszSRS)\n{\n  int bCoordinatesValid = 0;\n  CPLXMLNode *psCoordinates = NULL;\n  CPLXMLNode *psCoord1 = NULL, *psCoord2 = NULL;\n  char **papszCoords=NULL, **papszMin=NULL, **papszMax = NULL;\n  int nCoords = 0, nCoordsMin = 0, nCoordsMax = 0;\n  const char *pszTmpCoord = NULL;\n  const char *pszSRS = NULL;\n  const char *pszTS = NULL;\n  const char *pszCS = NULL;\n  double minx = 0.0, miny = 0.0, maxx = 0.0, maxy = 0.0;\n\n  if (psBox) {\n    pszSRS = CPLGetXMLValue(psBox, \"srsName\", NULL);\n    if (ppszSRS && pszSRS)\n      *ppszSRS = msStrdup(pszSRS);\n\n    psCoordinates = CPLGetXMLNode(psBox, \"coordinates\");\n    pszTS = CPLGetXMLValue(psCoordinates, \"ts\", NULL);\n    if( pszTS == NULL )\n        pszTS = \" \";\n    pszCS = CPLGetXMLValue(psCoordinates, \"cs\", NULL);\n    if( pszCS == NULL )\n        pszCS = \",\";\n    pszTmpCoord = CPLGetXMLValue(psCoordinates, NULL, NULL);\n\n    if (pszTmpCoord) {\n      papszCoords = msStringSplit(pszTmpCoord, pszTS[0], &nCoords);\n      if (papszCoords && nCoords == 2) {\n        papszMin = msStringSplit(papszCoords[0], pszCS[0], &nCoordsMin);\n        if (papszMin && nCoordsMin == 2) {\n          papszMax = msStringSplit(papszCoords[1], pszCS[0], &nCoordsMax);\n        }\n        if (papszMax && nCoordsMax == 2) {\n          bCoordinatesValid =1;\n          minx =  atof(papszMin[0]);\n          miny =  atof(papszMin[1]);\n          maxx =  atof(papszMax[0]);\n          maxy =  atof(papszMax[1]);\n        }\n\n        msFreeCharArray(papszMin, nCoordsMin);\n        msFreeCharArray(papszMax, nCoordsMax);\n      }\n\n      msFreeCharArray(papszCoords, nCoords);\n    } else {\n      psCoord1 = CPLGetXMLNode(psBox, \"coord\");\n      psCoord2 = FLTGetNextSibblingNode(psCoord1);\n      if (psCoord1 && psCoord2 && strcmp(psCoord2->pszValue, \"coord\") == 0) {\n        const char* pszX = CPLGetXMLValue(psCoord1, \"X\", NULL);\n        const char* pszY = CPLGetXMLValue(psCoord1, \"Y\", NULL);\n        if (pszX && pszY) {\n          minx = atof(pszX);\n          miny = atof(pszY);\n\n          pszX = CPLGetXMLValue(psCoord2, \"X\", NULL);\n          pszY = CPLGetXMLValue(psCoord2, \"Y\", NULL);\n          if (pszX && pszY) {\n            maxx = atof(pszX);\n            maxy = atof(pszY);\n            bCoordinatesValid = 1;\n          }\n        }\n      }\n\n    }\n  }\n\n  if (bCoordinatesValid) {\n    psBbox->minx =  minx;\n    psBbox->miny =  miny;\n\n    psBbox->maxx =  maxx;\n    psBbox->maxy =  maxy;\n  }\n\n  return bCoordinatesValid;\n}\n/************************************************************************/\n/*                           FLTParseGMLEnvelope                        */\n/*                                                                      */\n/*      Utility function to parse a gml:Envelope (used for SOS and FE1.1)*/\n/************************************************************************/\nint FLTParseGMLEnvelope(CPLXMLNode *psRoot, rectObj *psBbox, char **ppszSRS)\n{\n  CPLXMLNode *psUpperCorner=NULL, *psLowerCorner=NULL;\n  const char *pszLowerCorner=NULL, *pszUpperCorner=NULL;\n  int bValid = 0;\n  char **tokens;\n  int n;\n\n  if (psRoot && psBbox && psRoot->eType == CXT_Element &&\n      EQUAL(psRoot->pszValue,\"Envelope\")) {\n    /*Get the srs if available*/\n    if (ppszSRS) {\n      const char* pszSRS = CPLGetXMLValue(psRoot, \"srsName\", NULL);\n      if( pszSRS != NULL )\n          *ppszSRS = msStrdup(pszSRS);\n    }\n    psLowerCorner = CPLSearchXMLNode(psRoot, \"lowerCorner\");\n    psUpperCorner = CPLSearchXMLNode(psRoot, \"upperCorner\");\n\n    if (psLowerCorner && psUpperCorner) {\n      pszLowerCorner = CPLGetXMLValue(psLowerCorner, NULL, NULL);\n      pszUpperCorner = CPLGetXMLValue(psUpperCorner, NULL, NULL);\n\n      if (pszLowerCorner && pszUpperCorner) {\n        tokens = msStringSplit(pszLowerCorner, ' ', &n);\n        if (tokens && n >= 2) {\n          psBbox->minx = atof(tokens[0]);\n          psBbox->miny = atof(tokens[1]);\n\n          msFreeCharArray(tokens, n);\n\n          tokens = msStringSplit(pszUpperCorner, ' ', &n);\n          if (tokens && n >= 2) {\n            psBbox->maxx = atof(tokens[0]);\n            psBbox->maxy = atof(tokens[1]);\n            bValid = 1;\n          }\n        }\n        msFreeCharArray(tokens, n);\n      }\n    }\n  }\n\n  return bValid;\n}\n\n/************************************************************************/\n/*                        FLTNeedSRSSwapping                            */\n/************************************************************************/\n\nstatic int FLTNeedSRSSwapping( const char* pszSRS )\n{\n    int bNeedSwapping = MS_FALSE;\n    projectionObj sProjTmp;\n    msInitProjection(&sProjTmp);\n    if (msLoadProjectionStringEPSG(&sProjTmp, pszSRS) == 0) {\n        bNeedSwapping = msIsAxisInvertedProj(&sProjTmp);\n    }\n    msFreeProjection(&sProjTmp);\n    return bNeedSwapping;\n}\n\n/************************************************************************/\n/*                      FLTDoAxisSwappingIfNecessary                    */\n/*                                                                      */\n/*      Explore all geometries and BBOX to do axis swapping when the    */\n/*      SRS requires it. If no explicit SRS is attached to the geometry */\n/*      the bDefaultSRSNeedsAxisSwapping is taken into account. The     */\n/*      caller will have to determine its value from a more general     */\n/*      context.                                                        */\n/************************************************************************/\nvoid FLTDoAxisSwappingIfNecessary(FilterEncodingNode *psFilterNode,\n                                  int bDefaultSRSNeedsAxisSwapping)\n{\n    if( psFilterNode == NULL )\n        return;\n\n    if( psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n        psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_BBOX )\n    {\n        rectObj* rect = (rectObj *)psFilterNode->psRightNode->pOther;\n        const char* pszSRS = psFilterNode->pszSRS;\n        if( (pszSRS != NULL && FLTNeedSRSSwapping(pszSRS)) ||\n            (pszSRS == NULL && bDefaultSRSNeedsAxisSwapping) )\n        {\n            double tmp;\n\n            tmp = rect->minx;\n            rect->minx = rect->miny;\n            rect->miny = tmp;\n\n            tmp = rect->maxx;\n            rect->maxx = rect->maxy;\n            rect->maxy = tmp;\n        }\n    }\n    else if( psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n             FLTIsGeometryFilterNodeType(psFilterNode->psRightNode->eType) )\n    {\n        shapeObj* shape = (shapeObj *)(psFilterNode->psRightNode->pOther);\n        const char* pszSRS = psFilterNode->pszSRS;\n        if( (pszSRS != NULL && FLTNeedSRSSwapping(pszSRS)) ||\n            (pszSRS == NULL && bDefaultSRSNeedsAxisSwapping) )\n        {\n            msAxisSwapShape(shape);\n        }\n    }\n    else\n    {\n        FLTDoAxisSwappingIfNecessary(psFilterNode->psLeftNode, bDefaultSRSNeedsAxisSwapping);\n        FLTDoAxisSwappingIfNecessary(psFilterNode->psRightNode, bDefaultSRSNeedsAxisSwapping);\n    }\n}\n\n\nstatic void FLTReplacePropertyName(FilterEncodingNode *psFilterNode,\n                                   const char *pszOldName,\n                                   const char *pszNewName)\n{\n  if (psFilterNode && pszOldName && pszNewName) {\n    if (psFilterNode->eType == FILTER_NODE_TYPE_PROPERTYNAME) {\n      if (psFilterNode->pszValue &&\n          strcasecmp(psFilterNode->pszValue, pszOldName) == 0) {\n        msFree(psFilterNode->pszValue);\n        psFilterNode->pszValue = msStrdup(pszNewName);\n      }\n    }\n    if (psFilterNode->psLeftNode)\n      FLTReplacePropertyName(psFilterNode->psLeftNode, pszOldName,\n                             pszNewName);\n    if (psFilterNode->psRightNode)\n      FLTReplacePropertyName(psFilterNode->psRightNode, pszOldName,\n                             pszNewName);\n  }\n}\n\n\nstatic int FLTIsGMLDefaultProperty(const char* pszName)\n{\n    return (strcmp(pszName, \"gml:name\") == 0 ||\n            strcmp(pszName, \"gml:description\") == 0 ||\n            strcmp(pszName, \"gml:descriptionReference\") == 0 ||\n            strcmp(pszName, \"gml:identifier\") == 0 ||\n            strcmp(pszName, \"gml:boundedBy\") == 0 ||\n            strcmp(pszName, \"@gml:id\") == 0);\n}\n\nstatic void FLTStripNameSpacesFromPropertyName(FilterEncodingNode *psFilterNode)\n{\n  char **tokens=NULL;\n  int n=0;\n\n  if (psFilterNode) {\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME &&\n        FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) )\n    {\n        return;\n    }\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_PROPERTYNAME) {\n      if (psFilterNode->pszValue &&\n          strstr(psFilterNode->pszValue, \":\")) {\n        tokens = msStringSplit(psFilterNode->pszValue, ':', &n);\n        if (tokens && n==2) {\n          msFree(psFilterNode->pszValue);\n          psFilterNode->pszValue = msStrdup(tokens[1]);\n        }\n        msFreeCharArray(tokens, n);\n      }\n    }\n    if (psFilterNode->psLeftNode)\n      FLTStripNameSpacesFromPropertyName(psFilterNode->psLeftNode);\n    if (psFilterNode->psRightNode)\n      FLTStripNameSpacesFromPropertyName(psFilterNode->psRightNode);\n  }\n\n}\n\nstatic void FLTRemoveGroupName(FilterEncodingNode *psFilterNode,\n                               gmlGroupListObj* groupList)\n{\n  int i;\n\n  if (psFilterNode) {\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_PROPERTYNAME) {\n      if( psFilterNode->pszValue != NULL )\n      {\n        const char* pszPropertyName = psFilterNode->pszValue;\n        const char* pszSlash = strchr(pszPropertyName, '/');\n        if( pszSlash != NULL ) {\n          const char* pszColon = strchr(pszPropertyName, ':');\n          if( pszColon != NULL && pszColon < pszSlash )\n              pszPropertyName = pszColon + 1;\n          for(i=0;i<groupList->numgroups;i++) {\n            const char* pszGroupName = groupList->groups[i].name;\n            size_t nGroupNameLen = strlen(pszGroupName);\n            if(strncasecmp(pszPropertyName, pszGroupName, nGroupNameLen) == 0 &&\n                            pszPropertyName[nGroupNameLen] == '/') {\n              char* pszTmp;\n              pszPropertyName = pszPropertyName + nGroupNameLen + 1;\n              pszColon = strchr(pszPropertyName, ':');\n              if( pszColon != NULL )\n                pszPropertyName = pszColon + 1;\n              pszTmp = msStrdup(pszPropertyName);\n              msFree(psFilterNode->pszValue);\n              psFilterNode->pszValue = pszTmp;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (psFilterNode->psLeftNode)\n      FLTRemoveGroupName(psFilterNode->psLeftNode, groupList);\n    if (psFilterNode->psRightNode)\n      FLTRemoveGroupName(psFilterNode->psRightNode, groupList);\n  }\n\n}\n\n/************************************************************************/\n/*                    FLTPreParseFilterForAliasAndGroup                 */\n/*                                                                      */\n/*      Utility function to replace aliased' and grouped attributes     */\n/*      with their internal name.                                       */\n/************************************************************************/\nvoid FLTPreParseFilterForAliasAndGroup(FilterEncodingNode *psFilterNode,\n                               mapObj *map, int i, const char *namespaces)\n{\n  layerObj *lp=NULL;\n  char szTmp[256];\n  const char *pszFullName = NULL;\n  int layerWasOpened =  MS_FALSE;\n\n#if defined(USE_WMS_SVR) || defined (USE_WFS_SVR) || defined (USE_WCS_SVR) || defined(USE_SOS_SVR)\n\n  if (psFilterNode && map && i>=0 && i<map->numlayers) {\n    /*strip name spaces before hand*/\n    FLTStripNameSpacesFromPropertyName(psFilterNode);\n\n    lp = GET_LAYER(map, i);\n    layerWasOpened = msLayerIsOpen(lp);\n    if (msLayerOpen(lp) == MS_SUCCESS && msLayerGetItems(lp) == MS_SUCCESS) {\n\n      /* Remove group names from property names if using groupname/itemname syntax */\n      gmlGroupListObj* groupList = msGMLGetGroups(lp, namespaces);\n      if( groupList && groupList->numgroups > 0 )\n        FLTRemoveGroupName(psFilterNode, groupList);\n      msGMLFreeGroups(groupList);\n\n      for(i=0; i<lp->numitems; i++) {\n        if (!lp->items[i] || strlen(lp->items[i]) <= 0)\n          continue;\n        snprintf(szTmp, sizeof(szTmp), \"%s_alias\", lp->items[i]);\n        pszFullName = msOWSLookupMetadata(&(lp->metadata), namespaces, szTmp);\n        if (pszFullName) {\n          FLTReplacePropertyName(psFilterNode, pszFullName,\n                                 lp->items[i]);\n        }\n      }\n      if (!layerWasOpened) /* do not close the layer if it has been opened somewhere else (paging?) */\n        msLayerClose(lp);\n    }\n  }\n#else\n  msSetError(MS_MISCERR, \"OWS support is not available.\",\n             \"FLTPreParseFilterForAlias()\");\n\n#endif\n}\n\n/************************************************************************/\n/*                        FLTCheckFeatureIdFilters                      */\n/*                                                                      */\n/*      Check that FeatureId filters match features in the active       */\n/*      layer.                                                          */\n/************************************************************************/\nint FLTCheckFeatureIdFilters(FilterEncodingNode *psFilterNode,\n                             mapObj *map, int i)\n{\n    int status = MS_SUCCESS;\n    \n    if (psFilterNode->eType ==  FILTER_NODE_TYPE_FEATUREID)\n    {\n        char** tokens;\n        int nTokens = 0;\n        layerObj* lp;\n        int j;\n\n        lp = GET_LAYER(map, i);\n        tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n        for (j=0; j<nTokens; j++) {\n            const char* pszId = tokens[j];\n            const char* pszDot = strchr(pszId, '.');\n            if( pszDot )\n            {\n                if( pszDot - pszId != strlen(lp->name) ||\n                    strncasecmp(pszId, lp->name, strlen(lp->name)) != 0 )\n                {\n                    msSetError(MS_MISCERR, \"Feature id %s not consistent with feature type name %s.\",\n                               \"FLTPreParseFilterForAlias()\", pszId, lp->name);\n                    status = MS_FAILURE;\n                    break;\n                }\n            }\n        }\n        msFreeCharArray(tokens, nTokens);\n    }\n\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTCheckFeatureIdFilters(psFilterNode->psLeftNode, map, i);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTCheckFeatureIdFilters(psFilterNode->psRightNode, map, i);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                        FLTCheckInvalidOperand                        */\n/*                                                                      */\n/*      Check that the operand of a comparison operator is valid        */\n/*      Currently only detects use of boundedBy in a binary comparison  */\n/************************************************************************/\nint FLTCheckInvalidOperand(FilterEncodingNode *psFilterNode)\n{\n    int status = MS_SUCCESS;\n\n    if (psFilterNode->eType ==  FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME)\n    {\n        if( strcmp(psFilterNode->psLeftNode->pszValue, \"gml:boundedBy\") == 0 &&\n            strcmp(psFilterNode->pszValue, \"PropertyIsNull\") != 0 &&\n            strcmp(psFilterNode->pszValue, \"PropertyIsNil\") != 0 )\n        {\n            msSetError(MS_MISCERR, \"Operand '%s' is invalid in comparison.\",\n                       \"FLTCheckInvalidOperand()\", psFilterNode->psLeftNode->pszValue);\n            return MS_FAILURE;\n        }\n    }\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTCheckInvalidOperand(psFilterNode->psLeftNode);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTCheckInvalidOperand(psFilterNode->psRightNode);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                       FLTProcessPropertyIsNull                       */\n/*                                                                      */\n/*      HACK for PropertyIsNull processing. PostGIS & Spatialite only   */\n/*      for now.                                                        */\n/************************************************************************/\nint FLTProcessPropertyIsNull(FilterEncodingNode *psFilterNode,\n                            mapObj *map, int i)\n{\n    int status = MS_SUCCESS;\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME &&\n        strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 &&\n        !FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) )\n    {\n        layerObj* lp;\n        int layerWasOpened;\n\n        lp = GET_LAYER(map, i);\n        layerWasOpened = msLayerIsOpen(lp);\n\n        /* Horrible HACK to compensate for the lack of null testing in MapServer */\n        if( (lp->connectiontype == MS_POSTGIS ||\n             (lp->connectiontype == MS_OGR && msOGRIsSpatialite(lp))) &&\n            strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 )\n        {\n            msFree(psFilterNode->pszValue);\n            psFilterNode->pszValue = msStrdup(\"PropertyIsEqualTo\");\n            psFilterNode->psRightNode = FLTCreateBinaryCompFilterEncodingNode();\n            psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_LITERAL;\n            psFilterNode->psRightNode->pszValue = msStrdup(\"_MAPSERVER_NULL_\");\n        }\n\n        if (!layerWasOpened) /* do not close the layer if it has been opened somewhere else (paging?) */\n          msLayerClose(lp);\n    }\n\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTProcessPropertyIsNull(psFilterNode->psLeftNode, map, i);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTProcessPropertyIsNull(psFilterNode->psRightNode, map, i);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                        FLTCheckInvalidProperty                       */\n/*                                                                      */\n/*      Check that property names are known                             */\n/************************************************************************/\nint FLTCheckInvalidProperty(FilterEncodingNode *psFilterNode,\n                            mapObj *map, int i)\n{\n    int status = MS_SUCCESS;\n\n    if (psFilterNode->eType ==  FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME)\n    {\n        layerObj* lp;\n        int layerWasOpened;\n        int bFound = MS_FALSE;\n\n        if ((strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 ||\n             strcmp(psFilterNode->pszValue, \"PropertyIsNil\") == 0) && \n             FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) )\n        {\n            return MS_SUCCESS;\n        }\n\n        lp = GET_LAYER(map, i);\n        layerWasOpened = msLayerIsOpen(lp);\n        if ((layerWasOpened || msLayerOpen(lp) == MS_SUCCESS) \n             && msLayerGetItems(lp) == MS_SUCCESS) {\n          int i;\n          gmlItemListObj* items = msGMLGetItems(lp, \"G\");\n          for(i=0; i<items->numitems; i++) {\n            if (!items->items[i].name || strlen(items->items[i].name) <= 0 ||\n                !items->items[i].visible)\n              continue;\n            if (strcasecmp(items->items[i].name, psFilterNode->psLeftNode->pszValue) == 0) {\n                bFound = MS_TRUE;\n                break;\n            }\n          }\n          msGMLFreeItems(items);\n        }\n\n        if (!layerWasOpened) /* do not close the layer if it has been opened somewhere else (paging?) */\n          msLayerClose(lp);\n\n        if( !bFound )\n        {\n            msSetError(MS_MISCERR, \"Property '%s' is unknown.\",\n                       \"FLTCheckInvalidProperty()\", psFilterNode->psLeftNode->pszValue);\n            return MS_FAILURE;\n        }\n    }\n\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTCheckInvalidProperty(psFilterNode->psLeftNode, map, i);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTCheckInvalidProperty(psFilterNode->psRightNode, map, i);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                           FLTSimplify                                */\n/*                                                                      */\n/*      Simplify the expression by removing parts that evaluate to      */\n/*      constants.                                                      */\n/*      The passed psFilterNode is potentially consumed by the function */\n/*      and replaced by the returned value.                             */\n/*      If the function returns NULL, *pnEvaluation = MS_FALSE means    */\n/*      that  the filter evaluates to FALSE, or MS_TRUE that it         */\n/*      evaluates to TRUE                                               */\n/************************************************************************/\nFilterEncodingNode* FLTSimplify(FilterEncodingNode *psFilterNode,\n                                int* pnEvaluation)\n{\n    *pnEvaluation = -1;\n\n    /* There are no nullable or nillable property in WFS currently */\n    /* except gml:name or gml:description that are null */\n    if( psFilterNode->eType ==  FILTER_NODE_TYPE_COMPARISON &&\n        (strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 ||\n         strcmp(psFilterNode->pszValue, \"PropertyIsNil\") == 0 ) &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME )\n    {\n        if( strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 &&\n            FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) &&\n            strcmp(psFilterNode->psLeftNode->pszValue, \"@gml:id\") != 0  &&\n            strcmp(psFilterNode->psLeftNode->pszValue, \"gml:boundedBy\") != 0)\n            *pnEvaluation = MS_TRUE;\n        else\n            *pnEvaluation = MS_FALSE;\n        FLTFreeFilterEncodingNode(psFilterNode);\n        return NULL;\n    }\n\n    if( psFilterNode->eType ==  FILTER_NODE_TYPE_LOGICAL &&\n        strcasecmp(psFilterNode->pszValue, \"NOT\") == 0 &&\n        psFilterNode->psLeftNode != NULL )\n    {\n        int nEvaluation;\n        psFilterNode->psLeftNode = FLTSimplify(psFilterNode->psLeftNode,\n                                               &nEvaluation);\n        if( psFilterNode->psLeftNode == NULL )\n        {\n            *pnEvaluation = 1 - nEvaluation;\n            FLTFreeFilterEncodingNode(psFilterNode);\n            return NULL;\n        }\n    }\n\n    if( psFilterNode->eType ==  FILTER_NODE_TYPE_LOGICAL &&\n        (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n         strcasecmp(psFilterNode->pszValue, \"OR\") == 0) &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psRightNode != NULL )\n    {\n        FilterEncodingNode* psOtherNode;\n        int nEvaluation;\n        int nExpectedValForFastExit;\n        psFilterNode->psLeftNode = FLTSimplify(psFilterNode->psLeftNode,\n                                               &nEvaluation);\n\n        if( strcasecmp(psFilterNode->pszValue, \"AND\") == 0 )\n            nExpectedValForFastExit = MS_FALSE;\n        else\n            nExpectedValForFastExit = MS_TRUE;\n\n        if( psFilterNode->psLeftNode == NULL )\n        {\n            if( nEvaluation == nExpectedValForFastExit )\n            {\n                *pnEvaluation = nEvaluation;\n                FLTFreeFilterEncodingNode(psFilterNode);\n                return NULL;\n            }\n            psOtherNode = psFilterNode->psRightNode;\n            psFilterNode->psRightNode = NULL;\n            FLTFreeFilterEncodingNode(psFilterNode);\n            return FLTSimplify(psOtherNode, pnEvaluation);\n        }\n \n        psFilterNode->psRightNode = FLTSimplify(psFilterNode->psRightNode,\n                                                &nEvaluation);\n        if( psFilterNode->psRightNode == NULL )\n        {\n            if( nEvaluation == nExpectedValForFastExit )\n            {\n                *pnEvaluation = nEvaluation;\n                FLTFreeFilterEncodingNode(psFilterNode);\n                return NULL;\n            }\n            psOtherNode = psFilterNode->psLeftNode;\n            psFilterNode->psLeftNode = NULL;\n            FLTFreeFilterEncodingNode(psFilterNode);\n            return FLTSimplify(psOtherNode, pnEvaluation);\n        }\n    }\n\n    return psFilterNode;\n}\n\n\n#ifdef USE_LIBXML2\n\nxmlNodePtr FLTGetCapabilities(xmlNsPtr psNsParent, xmlNsPtr psNsOgc, int bTemporal)\n{\n  xmlNodePtr psRootNode = NULL, psNode = NULL, psSubNode = NULL, psSubSubNode = NULL;\n\n  psRootNode = xmlNewNode(psNsParent, BAD_CAST \"Filter_Capabilities\");\n\n  psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Spatial_Capabilities\", NULL);\n\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"GeometryOperands\", NULL);\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:Point\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:LineString\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:Polygon\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:Envelope\");\n\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"SpatialOperators\", NULL);\n#ifdef USE_GEOS\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Equals\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Disjoint\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Touches\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Within\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Overlaps\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Crosses\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Intersects\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Contains\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"DWithin\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Beyond\");\n#endif\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"BBOX\");\n\n  if (bTemporal) {\n    psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Temporal_Capabilities\", NULL);\n    psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"TemporalOperands\", NULL);\n    psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"TemporalOperand\", BAD_CAST \"gml:TimePeriod\");\n    psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"TemporalOperand\", BAD_CAST \"gml:TimeInstant\");\n\n    psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"TemporalOperators\", NULL);\n    psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"TemporalOperator\", NULL);\n    xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"TM_Equals\");\n  }\n  psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Scalar_Capabilities\", NULL);\n  xmlNewChild(psNode, psNsOgc, BAD_CAST \"LogicalOperators\", NULL);\n  psNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperators\", NULL);\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"LessThan\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"GreaterThan\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"LessThanEqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"GreaterThanEqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"EqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"NotEqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"Like\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"Between\");\n\n  psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Id_Capabilities\", NULL);\n  xmlNewChild(psNode, psNsOgc, BAD_CAST \"EID\", NULL);\n  xmlNewChild(psNode, psNsOgc, BAD_CAST \"FID\", NULL);\n  return psRootNode;\n}\n#endif\n#endif\n", "/**********************************************************************\n * $Id$\n *\n * Project:  MapServer\n * Purpose:  OGC Filter Encoding implementation\n * Author:   Y. Assefa, DM Solutions Group (assefa@dmsolutions.ca)\n *\n **********************************************************************\n * Copyright (c) 2003, Y. Assefa, DM Solutions Group Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies of this Software or works derived from this Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n ****************************************************************************/\n\n#ifdef USE_OGR\n#include \"cpl_minixml.h\"\n#endif\n\n#include \"mapogcfilter.h\"\n#include \"mapserver.h\"\n#include \"mapows.h\"\n#include \"mapowscommon.h\"\n\n#ifdef USE_OGR\n\nchar *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n  FEPropertyIsLike* propIsLike;\n\n  int nLength=0, i=0, iTmp=0;\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \"(\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /* #3521 */\n  if (bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* \\\"\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" ~ \\\"\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] && pszValue[i] != pszSingle[0] && pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszWild[0]) {\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '\"';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}\n\nchar *FLTGetIsBetweenComparisonCommonExpresssion(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char **aszBounds = NULL;\n  int nBounds = 0;\n  int bString=0;\n  int bDateTime = 0;\n  char *pszExpression=NULL, *pszTmpEscaped;\n\n  if (!psFilterNode || !(strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0))\n    return NULL;\n\n  if (psFilterNode->psLeftNode == NULL || psFilterNode->psRightNode == NULL )\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Get the bounds value which are stored like boundmin;boundmax    */\n  /* -------------------------------------------------------------------- */\n  aszBounds = msStringSplit(psFilterNode->psRightNode->pszValue, ';', &nBounds);\n  if (nBounds != 2) {\n    msFreeCharArray(aszBounds, nBounds);\n    return NULL;\n  }\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (aszBounds[0]) {\n    const char* pszType;\n    snprintf(szBuffer,  bufferSize, \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szBuffer);\n    if (pszType != NULL && (strcasecmp(pszType, \"Character\") == 0))\n      bString = 1;\n    else if (pszType != NULL && (strcasecmp(pszType, \"Date\") == 0))\n      bDateTime = 1;\n    else if (FLTIsNumeric(aszBounds[0]) == MS_FALSE)\n      bString = 1;\n  }\n  if (!bString && !bDateTime) {\n    if (aszBounds[1]) {\n      if (FLTIsNumeric(aszBounds[1]) == MS_FALSE)\n        bString = 1;\n    }\n  }\n\n  /* -------------------------------------------------------------------- */\n  /*      build expresssion.                                              */\n  /* -------------------------------------------------------------------- */\n  /* attribute */\n  if (bString)\n    sprintf(szBuffer, \"%s\", \"(\\\"[\");\n  else\n    sprintf(szBuffer, \"%s\", \"([\");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n  \n  pszExpression = msStringConcatenate(pszExpression, psFilterNode->psLeftNode->pszValue);\n\n  if (bString)\n    sprintf(szBuffer, \"%s\", \"]\\\" \");\n  else\n    sprintf(szBuffer, \"%s\", \"] \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  sprintf(szBuffer, \"%s\", \" >= \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n\n  pszTmpEscaped = msStringEscape(aszBounds[0]);\n  snprintf(szBuffer, bufferSize, \"%s\", pszTmpEscaped);\n  if(pszTmpEscaped != aszBounds[0] ) msFree(pszTmpEscaped);\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n\n  sprintf(szBuffer, \"%s\", \" AND \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  if (bString)\n    sprintf(szBuffer, \"%s\", \" \\\"[\");\n  else\n    sprintf(szBuffer, \"%s\", \" [\");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  /* attribute */\n  pszExpression = msStringConcatenate(pszExpression, psFilterNode->psLeftNode->pszValue);\n\n  if (bString)\n    sprintf(szBuffer, \"%s\", \"]\\\" \");\n  else\n    sprintf(szBuffer, \"%s\", \"] \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  sprintf(szBuffer, \"%s\", \" <= \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n  pszTmpEscaped = msStringEscape(aszBounds[1]);\n  snprintf(szBuffer, bufferSize, \"%s\", pszTmpEscaped);\n  if (pszTmpEscaped != aszBounds[1]) msFree(pszTmpEscaped);\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n  sprintf(szBuffer, \"%s\", \")\");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  msFreeCharArray(aszBounds, nBounds);\n\n  return pszExpression;\n}\n\nchar *FLTGetBinaryComparisonCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char szTmp[1024];\n  char *pszExpression = NULL, *pszTmpEscaped;\n  int bString;\n  int bDateTime;\n\n  if (psFilterNode == NULL)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  bDateTime = 0;\n  if (psFilterNode->psRightNode->pszValue) {\n    const char* pszType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszType!= NULL && (strcasecmp(pszType, \"Character\") == 0))\n      bString = 1;\n    else if (pszType!= NULL && (strcasecmp(pszType, \"Date\") == 0))\n      bDateTime = 1;\n    else if (FLTIsNumeric(psFilterNode->psRightNode->pszValue) == MS_FALSE)\n      bString = 1;\n  }\n\n  /* specical case to be able to have empty strings in the expression. */\n  /* propertyislike is always treated as string */\n  if (psFilterNode->psRightNode->pszValue == NULL || strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n    bString = 1;\n\n  /* attribute */\n  if (bString)\n    sprintf(szTmp, \"%s\", \"(\\\"[\");\n  else\n    sprintf(szTmp,  \"%s\",\"([\");\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n  pszExpression = msStringConcatenate(pszExpression, psFilterNode->psLeftNode->pszValue);\n  \n  if (bString)\n    sprintf(szTmp,  \"%s\",\"]\\\" \");\n  else\n    sprintf(szTmp,  \"%s\", \"] \");\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n\n  if (strcasecmp(psFilterNode->pszValue, \"PropertyIsEqualTo\") == 0) {\n    /* case insensitive set ? */\n    if (psFilterNode->psRightNode->pOther && (*(int *)psFilterNode->psRightNode->pOther) == 1)\n      sprintf(szTmp,  \"%s\", \"=*\");\n    else\n      sprintf(szTmp,  \"%s\", \"=\");\n  } else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsNotEqualTo\") == 0)\n    sprintf(szTmp,  \"%s\", \"!=\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLessThan\") == 0)\n    sprintf(szTmp,  \"%s\", \"<\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsGreaterThan\") == 0)\n    sprintf(szTmp,  \"%s\", \">\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLessThanOrEqualTo\") == 0)\n    sprintf(szTmp,  \"%s\", \"<=\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsGreaterThanOrEqualTo\") == 0)\n    sprintf(szTmp,  \"%s\", \">=\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n    sprintf(szTmp,  \"%s\", \"~\");\n\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n  pszExpression = msStringConcatenate(pszExpression, \" \");\n\n  /* value */\n  if (bString) {\n    sprintf(szTmp,  \"%s\", \"\\\"\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n  else if (bDateTime) {\n    sprintf(szTmp,  \"%s\", \"`\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n\n  if (psFilterNode->psRightNode->pszValue) {\n    pszTmpEscaped = msStringEscape(psFilterNode->psRightNode->pszValue);\n    pszExpression = msStringConcatenate(pszExpression, pszTmpEscaped);\n    if(pszTmpEscaped != psFilterNode->psRightNode->pszValue ) msFree(pszTmpEscaped);\n  }\n\n  if (bString) {\n    sprintf(szTmp,  \"%s\", \"\\\"\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n  else if (bDateTime) {\n    sprintf(szTmp,  \"%s\", \"`\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n\n  sprintf(szTmp,  \"%s\", \")\");\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n\n  return pszExpression;\n}\n\nchar *FLTGetLogicalComparisonCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  char *pszTmp = NULL;\n\n  if (!psFilterNode || !FLTIsLogicalFilterType(psFilterNode->pszValue))\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      OR and AND                                                      */\n  /* -------------------------------------------------------------------- */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n    pszTmp = FLTGetCommonExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszExpression = msStringConcatenate(pszExpression, \"(\");\n\n    pszExpression = msStringConcatenate(pszExpression, pszTmp);\n    msFree(pszTmp);\n\n    pszExpression = msStringConcatenate(pszExpression, \" \");\n\n    pszExpression = msStringConcatenate(pszExpression, psFilterNode->pszValue);\n\n    pszExpression = msStringConcatenate(pszExpression, \" \");\n\n    pszTmp = FLTGetCommonExpression(psFilterNode->psRightNode, lp);\n    if (!pszTmp) {\n      msFree(pszExpression);\n      return NULL;\n    }\n\n    pszExpression = msStringConcatenate(pszExpression, pszTmp);\n    msFree(pszTmp);\n\n    pszExpression = msStringConcatenate(pszExpression, \")\");\n  }\n  /* -------------------------------------------------------------------- */\n  /*      NOT                                                             */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode && strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n    pszTmp = FLTGetCommonExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszExpression = msStringConcatenate(pszExpression, \"(NOT \");\n\n    pszExpression = msStringConcatenate(pszExpression, pszTmp);\n    msFree(pszTmp);\n\n    pszExpression = msStringConcatenate(pszExpression, \")\");\n  }\n\n  return pszExpression;\n}\n\nchar *FLTGetSpatialComparisonCommonExpression(FilterEncodingNode *psNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  shapeObj *psQueryShape = NULL;\n  double dfDistance = -1;\n  int nUnit = -1, nLayerUnit = -1;\n  char *pszWktText = NULL;\n  char szBuffer[256];\n  char *pszTmp=NULL;\n  projectionObj sProjTmp;\n  rectObj sQueryRect;\n  shapeObj *psTmpShape=NULL;\n  int bBBoxQuery = 0;\n  int bAlreadyReprojected = 0;\n\n  if (psNode == NULL || lp == NULL)\n    return NULL;\n\n  if (psNode->eType != FILTER_NODE_TYPE_SPATIAL)\n    return NULL;\n\n  /* get the shape */\n  if (FLTIsBBoxFilter(psNode)) {\n    char szPolygon[512];\n    FLTGetBBOX(psNode, &sQueryRect);\n\n    snprintf(szPolygon, sizeof(szPolygon),\n             \"POLYGON((%.18f %.18f,%.18f %.18f,%.18f %.18f,%.18f %.18f,%.18f %.18f))\",\n             sQueryRect.minx, sQueryRect.miny,\n             sQueryRect.minx, sQueryRect.maxy,\n             sQueryRect.maxx, sQueryRect.maxy,\n             sQueryRect.maxx, sQueryRect.miny,\n             sQueryRect.minx, sQueryRect.miny);\n\n    psTmpShape = msShapeFromWKT(szPolygon);\n\n    /* \n    ** This is a horrible hack to deal with world-extent requests and\n    ** reprojection. msProjectRect() detects if reprojection from longlat to \n    ** projected SRS, and in that case it transforms the bbox to -1e-15,-1e-15,1e15,1e15\n    ** to ensure that all features are returned.\n    **\n    ** Make wfs_200_cite_filter_bbox_world.xml and wfs_200_cite_postgis_bbox_world.xml pass\n    */\n    if (fabs(sQueryRect.minx - -180.0) < 1e-5 &&\n        fabs(sQueryRect.miny - -90.0) < 1e-5 &&\n        fabs(sQueryRect.maxx - 180.0) < 1e-5 &&\n        fabs(sQueryRect.maxy - 90.0) < 1e-5)\n    {\n      if (lp->projection.numargs > 0) {\n        if (psNode->pszSRS)\n          msInitProjection(&sProjTmp);\n        if (psNode->pszSRS) {\n          /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n          if (msLoadProjectionString(&sProjTmp, psNode->pszSRS) == 0) {\n            msProjectRect(&sProjTmp, &lp->projection, &sQueryRect);\n          }\n        } else if (lp->map->projection.numargs > 0)\n          msProjectRect(&lp->map->projection, &lp->projection, &sQueryRect);\n        if (psNode->pszSRS)\n          msFreeProjection(&sProjTmp);\n      }\n      if (sQueryRect.minx <= -1e14) {\n        msFreeShape(psTmpShape);\n        msFree(psTmpShape);\n        psTmpShape = (shapeObj*) msSmallMalloc(sizeof(shapeObj));\n        msInitShape(psTmpShape);\n        msRectToPolygon(sQueryRect, psTmpShape);\n        bAlreadyReprojected = 1;\n      }\n    }\n\n    bBBoxQuery = 1;\n  } else {\n    /* other geos type operations */\n\n    /* project shape to layer projection. If the proj is not part of the filter query,\n      assume that the cooredinates are in the map projection */\n\n    psQueryShape = FLTGetShape(psNode, &dfDistance, &nUnit);\n\n    if ((strcasecmp(psNode->pszValue, \"DWithin\") == 0 || strcasecmp(psNode->pszValue, \"Beyond\") == 0 ) && dfDistance > 0) {\n      nLayerUnit = lp->units;\n      if(nLayerUnit == -1) nLayerUnit = GetMapserverUnitUsingProj(&lp->projection);\n      if(nLayerUnit == -1) nLayerUnit = lp->map->units;\n      if(nLayerUnit == -1) nLayerUnit = GetMapserverUnitUsingProj(&lp->map->projection);\n\n      if (nUnit >= 0 && nUnit != nLayerUnit)\n        dfDistance *= msInchesPerUnit(nUnit,0)/msInchesPerUnit(nLayerUnit,0); /* target is layer units */\n    }\n\n    psTmpShape = psQueryShape;\n  }\n\n  if (psTmpShape) {\n\n    /*\n    ** target is layer projection\n    */\n    if (!bAlreadyReprojected && lp->projection.numargs > 0) {\n      if (psNode->pszSRS)\n        msInitProjection(&sProjTmp);\n      if (psNode->pszSRS) {\n        /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n        if (msLoadProjectionString(&sProjTmp, psNode->pszSRS) == 0) {\n          msProjectShape(&sProjTmp, &lp->projection, psTmpShape);\n        }\n      } else if (lp->map->projection.numargs > 0)\n        msProjectShape(&lp->map->projection, &lp->projection, psTmpShape);\n      if (psNode->pszSRS)\n        msFreeProjection(&sProjTmp);\n    }\n\n    /* function name */\n    if (bBBoxQuery) {\n      sprintf(szBuffer, \"%s\", \"intersects\");\n    } else {\n      if (strncasecmp(psNode->pszValue, \"intersect\", 9) == 0)\n        sprintf(szBuffer, \"%s\", \"intersects\");\n      else {\n        pszTmp = msStrdup(psNode->pszValue);\n        msStringToLower(pszTmp);\n        sprintf(szBuffer, \"%s\", pszTmp);\n        msFree(pszTmp);\n      }\n    }\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    pszExpression = msStringConcatenate(pszExpression, \"(\");\n\n    /* geometry binding */\n    sprintf(szBuffer, \"%s\", \"[shape]\");\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    pszExpression = msStringConcatenate(pszExpression, \",\");\n\n    /* filter geometry */\n    pszWktText = msGEOSShapeToWKT(psTmpShape);\n    sprintf(szBuffer, \"%s\", \"fromText('\");\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    pszExpression = msStringConcatenate(pszExpression, pszWktText);\n    sprintf(szBuffer, \"%s\", \"')\");\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    msGEOSFreeWKT(pszWktText);\n\n    /* (optional) beyond/dwithin distance, always 0.0 since we apply the distance as a buffer earlier */\n    if ((strcasecmp(psNode->pszValue, \"DWithin\") == 0 || strcasecmp(psNode->pszValue, \"Beyond\") == 0)) {\n      // pszExpression = msStringConcatenate(pszExpression, \",0.0\");\n      sprintf(szBuffer, \",%g\", dfDistance);\n      pszExpression = msStringConcatenate(pszExpression, szBuffer);      \n    }\n\n    /* terminate the function */\n    pszExpression = msStringConcatenate(pszExpression, \") = TRUE\");\n  }\n\n  /*\n  ** Cleanup\n  */\n  if (bBBoxQuery) {\n    msFreeShape(psTmpShape);\n    msFree(psTmpShape);\n  }\n\n  return pszExpression;\n}\n\nchar *FLTGetFeatureIdCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  int nTokens = 0, i=0, bString=0;\n  char **tokens = NULL;\n  const char *pszAttribute=NULL;\n\n#if defined(USE_WMS_SVR) || defined(USE_WFS_SVR) || defined(USE_WCS_SVR) || defined(USE_SOS_SVR)\n  if (psFilterNode->pszValue) {\n    pszAttribute = msOWSLookupMetadata(&(lp->metadata), \"OFG\", \"featureid\");\n    if (pszAttribute) {\n      tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n      if (tokens && nTokens > 0) {\n        for (i=0; i<nTokens; i++) {\n          char *pszTmp = NULL;\n          int bufferSize = 0;\n          const char* pszId = tokens[i];\n          const char* pszDot = strchr(pszId, '.');\n          if( pszDot )\n            pszId = pszDot + 1;\n\n          if (i == 0) {\n            if(FLTIsNumeric(pszId) == MS_FALSE)\n              bString = 1;\n          }\n\n          if (bString) {\n            bufferSize = 11+strlen(pszId)+strlen(pszAttribute)+1;\n            pszTmp = (char *)msSmallMalloc(bufferSize);\n            snprintf(pszTmp, bufferSize, \"(\\\"[%s]\\\" ==\\\"%s\\\")\" , pszAttribute, pszId);\n          } else {\n            bufferSize = 8+strlen(pszId)+strlen(pszAttribute)+1;\n            pszTmp = (char *)msSmallMalloc(bufferSize);\n            snprintf(pszTmp, bufferSize, \"([%s] == %s)\" , pszAttribute, pszId);\n          }\n\n          if (pszExpression != NULL)\n            pszExpression = msStringConcatenate(pszExpression, \" OR \");\n          else\n            pszExpression = msStringConcatenate(pszExpression, \"(\");\n          pszExpression = msStringConcatenate(pszExpression, pszTmp);\n          msFree(pszTmp);\n        }\n\n        msFreeCharArray(tokens, nTokens);\n      }\n    }\n\n    /* opening and closing brackets are needed for mapserver expressions */\n    if (pszExpression)\n      pszExpression = msStringConcatenate(pszExpression, \")\");\n  }\n#endif\n\n  return pszExpression;\n}\n\nchar* FLTGetTimeExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char* pszExpression = NULL;\n  const char* pszTimeField;\n  const char* pszTimeValue;\n\n  if (psFilterNode == NULL || lp == NULL)\n    return NULL;\n\n  if (psFilterNode->eType != FILTER_NODE_TYPE_TEMPORAL)\n    return NULL;\n\n  pszTimeValue = FLTGetDuring(psFilterNode, &pszTimeField);\n  if (pszTimeField && pszTimeValue) {\n    expressionObj old_filter;\n    msInitExpression(&old_filter);\n    msCopyExpression(&old_filter, &lp->filter); /* save existing filter */\n    msFreeExpression(&lp->filter);\n    if (msLayerSetTimeFilter(lp, pszTimeValue, pszTimeField) == MS_TRUE) {\n      pszExpression = msStrdup(lp->filter.string);\n    }\n    msCopyExpression(&lp->filter, &old_filter); /* restore old filter */\n    msFreeExpression(&old_filter);\n  }\n  return pszExpression;\n}\n\nchar *FLTGetCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n\n  if (!psFilterNode)\n    return NULL;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON) {\n    if ( psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n      if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n        pszExpression = FLTGetBinaryComparisonCommonExpression(psFilterNode, lp);\n      else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n        pszExpression = FLTGetIsLikeComparisonCommonExpression(psFilterNode);\n      else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0)\n        pszExpression = FLTGetIsBetweenComparisonCommonExpresssion(psFilterNode, lp);\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    pszExpression = FLTGetLogicalComparisonCommonExpression(psFilterNode, lp);\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL) {\n    pszExpression = FLTGetSpatialComparisonCommonExpression(psFilterNode, lp);\n  } else if (psFilterNode->eType ==  FILTER_NODE_TYPE_FEATUREID) {\n    pszExpression = FLTGetFeatureIdCommonExpression(psFilterNode, lp);\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_TEMPORAL) {\n    pszExpression = FLTGetTimeExpression(psFilterNode, lp);\n  }\n\n  return pszExpression;\n}\n\nint FLTApplyFilterToLayerCommonExpression(mapObj *map, int iLayerIndex, const char *pszExpression)\n{\n  return FLTApplyFilterToLayerCommonExpressionWithRect(map, iLayerIndex, pszExpression, map->extent);\n}\n\n/* rect must be in map->projection */\nint FLTApplyFilterToLayerCommonExpressionWithRect(mapObj *map, int iLayerIndex, const char *pszExpression, rectObj rect)\n{\n  int retval;\n  int save_startindex;\n  int save_maxfeatures;\n  int save_only_cache_result_count;\n\n  save_startindex = map->query.startindex;\n  save_maxfeatures = map->query.maxfeatures;\n  save_only_cache_result_count = map->query.only_cache_result_count;\n  msInitQuery(&(map->query));\n  map->query.startindex = save_startindex;\n  map->query.maxfeatures = save_maxfeatures;\n  map->query.only_cache_result_count = save_only_cache_result_count;\n\n  map->query.mode = MS_QUERY_MULTIPLE;\n  map->query.layer = iLayerIndex;\n\n  map->query.rect = rect;\n\n  if( pszExpression )\n  {\n    map->query.type = MS_QUERY_BY_FILTER;\n    msInitExpression(&map->query.filter);\n    map->query.filter.string = msStrdup(pszExpression);\n    map->query.filter.type = MS_EXPRESSION; /* a logical expression */\n\n    retval = msQueryByFilter(map);\n  }\n  else\n  {\n    map->query.type = MS_QUERY_BY_RECT;\n    retval = msQueryByRect(map);\n  }\n\n  return retval;\n}\n\n#endif\n"], "fixing_code": ["/**********************************************************************\n * $Id$\n *\n * Project:  MapServer\n * Purpose:  OGC Filter Encoding implementation\n * Author:   Y. Assefa, DM Solutions Group (assefa@dmsolutions.ca)\n *\n **********************************************************************\n * Copyright (c) 2003, Y. Assefa, DM Solutions Group Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies of this Software or works derived from this Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n ****************************************************************************/\n\n\n#define _GNU_SOURCE\n#include \"mapserver-config.h\"\n\n#ifdef USE_OGR\n#include \"cpl_minixml.h\"\n#include \"cpl_string.h\"\n#endif\n\n#include \"mapogcfilter.h\"\n#include \"mapserver.h\"\n#include \"mapowscommon.h\"\n#include \"maptime.h\"\n#include \"mapows.h\"\n#include <ctype.h>\n\n#if 0\nstatic int FLTHasUniqueTopLevelDuringFilter(FilterEncodingNode *psFilterNode);\n#endif\n\nint FLTIsNumeric(const char *pszValue)\n{\n  if (pszValue != NULL && *pszValue != '\\0' && !isspace(*pszValue)) {\n    /*the regex seems to have a problem on windows when mapserver is built using\n      PHP regex*/\n#if defined(_WIN32) && !defined(__CYGWIN__)\n    int i = 0, nLength=0, bString=0;\n\n    nLength = strlen(pszValue);\n    for (i=0; i<nLength; i++) {\n      if (i == 0) {\n        if (!isdigit(pszValue[i]) &&  pszValue[i] != '-') {\n          bString = 1;\n          break;\n        }\n      } else if (!isdigit(pszValue[i]) &&  pszValue[i] != '.') {\n        bString = 1;\n        break;\n      }\n    }\n    if (!bString)\n      return MS_TRUE;\n#else\n    char * p;\n    strtod(pszValue, &p);\n    if ( p != pszValue && *p == '\\0') return MS_TRUE;\n#endif\n  }\n\n  return MS_FALSE;\n}\n\n/*\n** Apply an expression to the layer's filter element.\n**\n*/\nint FLTApplyExpressionToLayer(layerObj *lp, const char *pszExpression)\n{\n  char *pszFinalExpression=NULL, *pszBuffer = NULL;\n  /*char *escapedTextString=NULL;*/\n  int bConcatWhere=0, bHasAWhere=0;\n\n  if (lp && pszExpression) {\n    if (lp->connectiontype == MS_POSTGIS || lp->connectiontype ==  MS_ORACLESPATIAL ||\n        lp->connectiontype == MS_PLUGIN) {\n      pszFinalExpression = msStrdup(\"(\");\n      pszFinalExpression = msStringConcatenate(pszFinalExpression, pszExpression);\n      pszFinalExpression = msStringConcatenate(pszFinalExpression, \")\");\n    } else if (lp->connectiontype == MS_OGR) {\n      pszFinalExpression = msStrdup(pszExpression);\n      if (lp->filter.type != MS_EXPRESSION) {\n        bConcatWhere = 1;\n      } else {\n        if (lp->filter.string && EQUALN(lp->filter.string,\"WHERE \",6)) {\n          bHasAWhere = 1;\n          bConcatWhere =1;\n        }\n      }\n\n    } else\n      pszFinalExpression = msStrdup(pszExpression);\n\n    if (bConcatWhere)\n      pszBuffer = msStringConcatenate(pszBuffer, \"WHERE \");\n    /* if the filter is set and it's an expression type, concatenate it with\n                this filter. If not just free it */\n    if (lp->filter.string && lp->filter.type == MS_EXPRESSION) {\n      pszBuffer = msStringConcatenate(pszBuffer, \"((\");\n      if (bHasAWhere)\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string+6);\n      else\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string);\n      pszBuffer = msStringConcatenate(pszBuffer, \") and \");\n    } else if (lp->filter.string)\n      msFreeExpression(&lp->filter);\n\n    pszBuffer = msStringConcatenate(pszBuffer, pszFinalExpression);\n\n    if(lp->filter.string && lp->filter.type == MS_EXPRESSION)\n      pszBuffer = msStringConcatenate(pszBuffer, \")\");\n\n    /*assuming that expression was properly escaped\n          escapedTextString = msStringEscape(pszBuffer);\n          msLoadExpressionString(&lp->filter,\n                                 (char*)CPLSPrintf(\"%s\", escapedTextString));\n          msFree(escapedTextString);\n    */\n    msLoadExpressionString(&lp->filter, pszBuffer);\n\n\n    msFree(pszFinalExpression);\n\n    if (pszBuffer)\n      msFree(pszBuffer);\n\n    return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\nchar *FLTGetExpressionForValuesRanges(layerObj *lp, const char *item, const char *value,  int forcecharcter)\n{\n  int bIscharacter, bSqlLayer=MS_FALSE;\n  char *pszExpression = NULL, *pszEscapedStr=NULL, *pszTmpExpression=NULL;\n  char **paszElements = NULL, **papszRangeElements=NULL;\n  int numelements,i,nrangeelements;\n\n  /* TODO: remove the bSqlLayer checks since we want to write MapServer expressions only. */\n\n  /* double minval, maxval; */\n  if (lp && item && value) {\n    if (strstr(value, \"/\") == NULL) {\n      /*value(s)*/\n      paszElements = msStringSplit (value, ',', &numelements);\n      if (paszElements && numelements > 0) {\n        if (forcecharcter)\n          bIscharacter = MS_TRUE;\n        bIscharacter= !FLTIsNumeric(paszElements[0]);\n\n        pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n        for (i=0; i<numelements; i++) {\n          pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n          if (bSqlLayer)\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n          else {\n            if (bIscharacter)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"\\\"\");\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n            if (bIscharacter)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"\\\"\");\n          }\n          if (bIscharacter) {\n            if (bSqlLayer)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = '\");\n            else\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = \\\"\");\n          } else\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = \");\n\n          pszEscapedStr = msLayerEscapeSQLParam(lp, paszElements[i]);\n          pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n\n          if (bIscharacter) {\n            if (bSqlLayer)\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"'\");\n            else\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"\\\"\");\n          }\n          pszTmpExpression = msStringConcatenate(pszTmpExpression, \")\");\n\n          msFree(pszEscapedStr);\n          pszEscapedStr=NULL;\n\n          if (pszExpression != NULL)\n            pszExpression = msStringConcatenate(pszExpression, \" OR \");\n\n          pszExpression =  msStringConcatenate(pszExpression, pszTmpExpression);\n\n          msFree(pszTmpExpression);\n          pszTmpExpression = NULL;\n        }\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n      }\n      msFreeCharArray(paszElements, numelements);\n    } else {\n      /*range(s)*/\n      paszElements = msStringSplit (value, ',', &numelements);\n      if (paszElements && numelements > 0) {\n        pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n        for (i=0; i<numelements; i++) {\n          papszRangeElements = msStringSplit (paszElements[i], '/', &nrangeelements);\n          if (papszRangeElements && nrangeelements > 0) {\n            pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n            if (nrangeelements == 2 || nrangeelements == 3) {\n              /*\n              minval = atof(papszRangeElements[0]);\n              maxval = atof(papszRangeElements[1]);\n              */\n              if (bSqlLayer)\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n              else {\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n              }\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" >= \");\n\n              pszEscapedStr = msLayerEscapeSQLParam(lp, papszRangeElements[0]);\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n              msFree(pszEscapedStr);\n              pszEscapedStr=NULL;\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" AND \");\n\n              if (bSqlLayer)\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n              else {\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n              }\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" <= \");\n\n              pszEscapedStr = msLayerEscapeSQLParam(lp, papszRangeElements[1]);\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n              msFree(pszEscapedStr);\n              pszEscapedStr=NULL;\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \")\");\n            } else if (nrangeelements == 1) {\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \"(\");\n              if (bSqlLayer)\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n              else {\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"[\");\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, item);\n                pszTmpExpression = msStringConcatenate(pszTmpExpression, \"]\");\n              }\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \" = \");\n\n              pszEscapedStr = msLayerEscapeSQLParam(lp, papszRangeElements[0]);\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, pszEscapedStr);\n              msFree(pszEscapedStr);\n              pszEscapedStr=NULL;\n\n              pszTmpExpression = msStringConcatenate(pszTmpExpression, \")\");\n            }\n\n            if (pszExpression != NULL)\n              pszExpression = msStringConcatenate(pszExpression, \" OR \");\n\n            pszExpression =  msStringConcatenate(pszExpression, pszTmpExpression);\n            msFree(pszTmpExpression);\n            pszTmpExpression = NULL;\n\n          }\n          msFreeCharArray(papszRangeElements, nrangeelements);\n        }\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n      }\n      msFreeCharArray(paszElements, numelements);\n    }\n  }\n  msFree(pszTmpExpression);\n  return pszExpression;\n}\n\n#ifdef USE_OGR\n\n\nint FLTogrConvertGeometry(OGRGeometryH hGeometry, shapeObj *psShape,\n                          OGRwkbGeometryType nType)\n{\n  return msOGRGeometryToShape(hGeometry, psShape, nType);\n}\n\nstatic\nint FLTShapeFromGMLTree(CPLXMLNode *psTree, shapeObj *psShape , char **ppszSRS)\n{\n  const char *pszSRS = NULL;\n  if (psTree && psShape) {\n    CPLXMLNode *psNext = psTree->psNext;\n    OGRGeometryH hGeometry = NULL;\n\n    psTree->psNext = NULL;\n    hGeometry = OGR_G_CreateFromGMLTree(psTree );\n    psTree->psNext = psNext;\n\n    if (hGeometry) {\n      OGRwkbGeometryType nType;\n      nType = OGR_G_GetGeometryType(hGeometry);\n      if (nType == wkbPolygon25D || nType == wkbMultiPolygon25D)\n        nType = wkbPolygon;\n      else if (nType == wkbLineString25D || nType == wkbMultiLineString25D)\n        nType = wkbLineString;\n      else if (nType == wkbPoint25D  || nType ==  wkbMultiPoint25D)\n        nType = wkbPoint;\n      FLTogrConvertGeometry(hGeometry, psShape, nType);\n\n      OGR_G_DestroyGeometry(hGeometry);\n\n      pszSRS = CPLGetXMLValue(psTree, \"srsName\", NULL);\n      if (ppszSRS && pszSRS)\n        *ppszSRS = msStrdup(pszSRS);\n\n      return MS_TRUE;\n    }\n  }\n\n  return MS_FALSE;\n}\n\nint FLTGetGeosOperator(char *pszValue)\n{\n  if (!pszValue)\n    return -1;\n\n  if (strcasecmp(pszValue, \"Equals\") == 0)\n    return MS_GEOS_EQUALS;\n  else if (strcasecmp(pszValue, \"Intersect\") == 0 ||\n           strcasecmp(pszValue, \"Intersects\") == 0)\n    return MS_GEOS_INTERSECTS;\n  else if (strcasecmp(pszValue, \"Disjoint\") == 0)\n    return MS_GEOS_DISJOINT;\n  else if (strcasecmp(pszValue, \"Touches\") == 0)\n    return MS_GEOS_TOUCHES;\n  else if (strcasecmp(pszValue, \"Crosses\") == 0)\n    return MS_GEOS_CROSSES;\n  else if (strcasecmp(pszValue, \"Within\") == 0)\n    return MS_GEOS_WITHIN;\n  else if (strcasecmp(pszValue, \"Contains\") == 0)\n    return MS_GEOS_CONTAINS;\n  else if (strcasecmp(pszValue, \"Overlaps\") == 0)\n    return MS_GEOS_OVERLAPS;\n  else if (strcasecmp(pszValue, \"Beyond\") == 0)\n    return MS_GEOS_BEYOND;\n  else if (strcasecmp(pszValue, \"DWithin\") == 0)\n    return MS_GEOS_DWITHIN;\n\n  return -1;\n}\n\nint FLTIsGeosNode(char *pszValue)\n{\n  if (FLTGetGeosOperator(pszValue) == -1)\n    return MS_FALSE;\n\n  return MS_TRUE;\n}\n\n/************************************************************************/\n/*                        FLTIsSimpleFilterNoSpatial                    */\n/*                                                                      */\n/*      Filter encoding with only attribute queries                     */\n/************************************************************************/\nint FLTIsSimpleFilterNoSpatial(FilterEncodingNode *psNode)\n{\n  if (FLTIsSimpleFilter(psNode) && FLTNumberOfFilterType(psNode, \"BBOX\") == 0)\n    return MS_TRUE;\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*                      FLTApplySimpleSQLFilter()                       */\n/************************************************************************/\n\nint FLTApplySimpleSQLFilter(FilterEncodingNode *psNode, mapObj *map, int iLayerIndex)\n{\n  layerObj *lp = NULL;\n  char *szExpression = NULL;\n  rectObj sQueryRect = map->extent;\n  const char *szEPSG = NULL;\n  projectionObj sProjTmp;\n  char *pszBuffer = NULL;\n  int bConcatWhere = 0;\n  int bHasAWhere =0;\n  char *pszTmp = NULL, *pszTmp2 = NULL;\n  char *tmpfilename = NULL;\n  const char* pszTimeField = NULL;\n  const char* pszTimeValue = NULL;\n\n  lp = (GET_LAYER(map, iLayerIndex));\n\n  /* if there is a bbox use it */\n  szEPSG = FLTGetBBOX(psNode, &sQueryRect);\n  if(szEPSG && map->projection.numargs > 0) {\n    msInitProjection(&sProjTmp);\n    /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n    if (msLoadProjectionString(&sProjTmp, szEPSG) == 0) {\n      msProjectRect(&sProjTmp, &map->projection, &sQueryRect);\n    }\n    msFreeProjection(&sProjTmp);\n  }\n  \n  if( lp->connectiontype == MS_OGR ) {\n    pszTimeValue = FLTGetDuring(psNode, &pszTimeField);\n  }\n\n  /* make sure that the layer can be queried*/\n  if (!lp->template) lp->template = msStrdup(\"ttt.html\");\n\n  /* if there is no class, create at least one, so that query by rect would work */\n  if (lp->numclasses == 0) {\n    if (msGrowLayerClasses(lp) == NULL)\n      return MS_FAILURE;\n    initClass(lp->class[0]);\n  }\n\n  bConcatWhere = 0;\n  bHasAWhere = 0;\n  if (lp->connectiontype == MS_POSTGIS || lp->connectiontype ==  MS_ORACLESPATIAL ||\n      lp->connectiontype == MS_PLUGIN) {\n    szExpression = FLTGetSQLExpression(psNode, lp);\n    if (szExpression) {\n      pszTmp = msStrdup(\"(\");\n      pszTmp = msStringConcatenate(pszTmp, szExpression);\n      pszTmp = msStringConcatenate(pszTmp, \")\");\n      msFree(szExpression);\n      szExpression = pszTmp;\n    }\n  }\n  /* concatenates the WHERE clause for OGR layers. This only applies if\n     the expression was empty or not of an expression string. If there\n     is an sql type expression, it is assumed to have the WHERE clause.\n     If it is an expression and does not have a WHERE it is assumed to be a mapserver\n     type expression*/\n  else if (lp->connectiontype == MS_OGR) {\n    if (lp->filter.type != MS_EXPRESSION) {\n      szExpression = FLTGetSQLExpression(psNode, lp);\n      bConcatWhere = 1;\n    } else {\n      if (lp->filter.string && EQUALN(lp->filter.string,\"WHERE \",6)) {\n        szExpression = FLTGetSQLExpression(psNode, lp);\n        bHasAWhere = 1;\n        bConcatWhere =1;\n      } else {\n        szExpression = FLTGetCommonExpression(psNode, lp);\n      }\n    }\n  } else {\n    szExpression = FLTGetCommonExpression(psNode, lp);\n\n  }\n\n  if (szExpression) {\n    if (bConcatWhere)\n      pszBuffer = msStringConcatenate(pszBuffer, \"WHERE \");\n\n    /* if the filter is set and it's an expression type, concatenate it with\n                 this filter. If not just free it */\n    if (lp->filter.string && lp->filter.type == MS_EXPRESSION) {\n      pszBuffer = msStringConcatenate(pszBuffer, \"((\");\n      if (bHasAWhere)\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string+6);\n      else\n        pszBuffer = msStringConcatenate(pszBuffer, lp->filter.string);\n      pszBuffer = msStringConcatenate(pszBuffer, \") and \");\n    } else if (lp->filter.string)\n      msFreeExpression(&lp->filter);\n\n    pszBuffer = msStringConcatenate(pszBuffer, szExpression);\n\n    if(lp->filter.string && lp->filter.type == MS_EXPRESSION)\n      pszBuffer = msStringConcatenate(pszBuffer, \")\");\n\n    msLoadExpressionString(&lp->filter, pszBuffer);\n    free(szExpression);\n  }\n  \n  if (pszTimeField && pszTimeValue)\n      msLayerSetTimeFilter(lp, pszTimeValue, pszTimeField);\n\n  if (pszBuffer)\n    free(pszBuffer);\n\n  map->query.type = MS_QUERY_BY_RECT;\n  map->query.mode = MS_QUERY_MULTIPLE;\n  map->query.layer = lp->index;\n  map->query.rect = sQueryRect;\n\n  if(map->debug == MS_DEBUGLEVEL_VVV) {\n    tmpfilename = msTmpFile(map, map->mappath, NULL, \"_filter.map\");\n    if (tmpfilename == NULL) {\n      tmpfilename = msTmpFile(map, NULL, NULL, \"_filter.map\" );\n    }\n    if (tmpfilename) {\n      msSaveMap(map,tmpfilename);\n      msDebug(\"FLTApplySimpleSQLFilter(): Map file after Filter was applied %s\\n\", tmpfilename);\n      msFree(tmpfilename);\n    }\n  }\n\n  /*for oracle connection, if we have a simple filter with no spatial constraints\n    we should set the connection function to NONE to have a better performance\n    (#2725)*/\n\n  if (lp->connectiontype ==  MS_ORACLESPATIAL && FLTIsSimpleFilterNoSpatial(psNode)) {\n    if (strcasestr(lp->data, \"USING\") == 0)\n      lp->data = msStringConcatenate(lp->data, \" USING NONE\");\n    else if (strcasestr(lp->data, \"NONE\") == 0) {\n      /*if one of the functions is used, just replace it with NONE*/\n      if (strcasestr(lp->data, \"FILTER\"))\n        lp->data = msCaseReplaceSubstring(lp->data, \"FILTER\", \"NONE\");\n      else if (strcasestr(lp->data, \"GEOMRELATE\"))\n        lp->data = msCaseReplaceSubstring(lp->data, \"GEOMRELATE\", \"NONE\");\n      else if (strcasestr(lp->data, \"RELATE\"))\n        lp->data = msCaseReplaceSubstring(lp->data, \"RELATE\", \"NONE\");\n      else if (strcasestr(lp->data, \"VERSION\")) {\n        /*should add NONE just before the VERSION. Cases are:\n          DATA \"ORA_GEOMETRY FROM data USING VERSION 10g\n          DATA \"ORA_GEOMETRY FROM data  USING UNIQUE FID VERSION 10g\"\n         */\n        pszTmp = (char *)strcasestr(lp->data, \"VERSION\");\n        pszTmp2 = msStringConcatenate(pszTmp2, \" NONE \");\n        pszTmp2 = msStringConcatenate(pszTmp2, pszTmp);\n\n        lp->data = msCaseReplaceSubstring(lp->data, pszTmp, pszTmp2);\n\n        msFree(pszTmp2);\n\n      } else if (strcasestr(lp->data, \"SRID\")) {\n        lp->data = msStringConcatenate(lp->data, \" NONE\");\n      }\n    }\n  }\n\n  return msQueryByRect(map);\n\n  /* return MS_SUCCESS; */\n}\n\n/************************************************************************/\n/*                            FLTIsSimpleFilter                         */\n/*                                                                      */\n/*      Filter encoding with only attribute queries and only one bbox.  */\n/************************************************************************/\nint FLTIsSimpleFilter(FilterEncodingNode *psNode)\n{\n  if (FLTValidForBBoxFilter(psNode)) {\n    if (FLTNumberOfFilterType(psNode, \"DWithin\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Intersect\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Intersects\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Equals\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Disjoint\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Touches\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Crosses\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Within\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Contains\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Overlaps\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Beyond\") == 0)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n/************************************************************************/\n/*                          FLTApplyFilterToLayer                       */\n/*                                                                      */\n/*      Use the filter encoding node to create mapserver expressions    */\n/*      and apply it to the layer.                                      */\n/************************************************************************/\nint FLTApplyFilterToLayer(FilterEncodingNode *psNode, mapObj *map, int iLayerIndex)\n{\n  layerObj *layer = GET_LAYER(map, iLayerIndex);\n\n  if ( ! layer->vtable) {\n    int rv =  msInitializeVirtualTable(layer);\n    if (rv != MS_SUCCESS)\n      return rv;\n  }\n  return layer->vtable->LayerApplyFilterToLayer(psNode, map,  iLayerIndex);\n}\n\n/************************************************************************/\n/*               FLTLayerApplyCondSQLFilterToLayer                       */\n/*                                                                      */\n/* Helper function for layer virtual table architecture                 */\n/************************************************************************/\nint FLTLayerApplyCondSQLFilterToLayer(FilterEncodingNode *psNode, mapObj *map, int iLayerIndex)\n{\n  return FLTLayerApplyPlainFilterToLayer(psNode, map, iLayerIndex);\n}\n\n\n/************************************************************************/\n/*                           FLTGetTopBBOX                              */\n/*                                                                      */\n/* Return the \"top\" BBOX if there's a unique one.                       */\n/************************************************************************/\nstatic int FLTGetTopBBOXInternal(FilterEncodingNode *psNode, FilterEncodingNode** ppsTopBBOX, int *pnCount)\n{\n  if (psNode->pszValue && strcasecmp(psNode->pszValue, \"BBOX\") == 0) {\n    (*pnCount) ++;\n    if( *pnCount == 1 )\n    {\n      *ppsTopBBOX = psNode;\n      return TRUE;\n    }\n    *ppsTopBBOX = NULL;\n    return FALSE;\n  }\n  else if (psNode->pszValue && strcasecmp(psNode->pszValue, \"AND\") == 0) {\n    return FLTGetTopBBOXInternal(psNode->psLeftNode, ppsTopBBOX, pnCount) &&\n           FLTGetTopBBOXInternal(psNode->psRightNode, ppsTopBBOX, pnCount);\n  }\n  else\n  {\n    return TRUE;\n  }\n}\n\nstatic FilterEncodingNode* FLTGetTopBBOX(FilterEncodingNode *psNode)\n{\n  int nCount = 0;\n  FilterEncodingNode* psTopBBOX = NULL;\n  FLTGetTopBBOXInternal(psNode, &psTopBBOX, &nCount);\n  return psTopBBOX;\n}\n\n/************************************************************************/\n/*                   FLTLayerApplyPlainFilterToLayer                    */\n/*                                                                      */\n/* Helper function for layer virtual table architecture                 */\n/************************************************************************/\nint FLTLayerApplyPlainFilterToLayer(FilterEncodingNode *psNode, mapObj *map,\n                                    int iLayerIndex)\n{\n  char *pszExpression  =NULL;\n  int status =MS_FALSE;\n  layerObj* lp = GET_LAYER(map, iLayerIndex);\n\n  pszExpression = FLTGetCommonExpression(psNode,  lp);\n  if (pszExpression) {\n    const char* pszUseDefaultExtent;\n    FilterEncodingNode* psTopBBOX;\n    rectObj rect = map->extent;\n\n    pszUseDefaultExtent = msOWSLookupMetadata(&(lp->metadata), \"F\",\n                                              \"use_default_extent_for_getfeature\");\n    if( pszUseDefaultExtent && !CSLTestBoolean(pszUseDefaultExtent) &&\n        lp->connectiontype == MS_OGR )\n    {\n        const rectObj rectInvalid = MS_INIT_INVALID_RECT;\n        rect = rectInvalid;\n    }\n\n    psTopBBOX = FLTGetTopBBOX(psNode);\n    if( psTopBBOX )\n    {\n      int can_remove_expression = MS_TRUE;\n      const char* pszEPSG = FLTGetBBOX(psNode, &rect);\n      if(pszEPSG && map->projection.numargs > 0) {\n        projectionObj sProjTmp;\n        msInitProjection(&sProjTmp);\n        /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n        if (msLoadProjectionString(&sProjTmp, pszEPSG) == 0) {\n          rectObj oldRect = rect;\n          msProjectRect(&sProjTmp, &map->projection, &rect);\n          /* If reprojection is involved, do not remove the expression */\n          if( rect.minx != oldRect.minx ||\n              rect.miny != oldRect.miny ||\n              rect.maxx != oldRect.maxx ||\n              rect.maxy != oldRect.maxy )\n          {\n            can_remove_expression = MS_FALSE;\n          }\n        }\n        msFreeProjection(&sProjTmp);\n      }\n\n      /* Small optimization: if the query is just a BBOX, then do a */\n      /* msQueryByRect() */\n      if( psTopBBOX == psNode && can_remove_expression )\n      {\n        msFree(pszExpression);\n        pszExpression = NULL;\n      }\n    }\n\n    if(map->debug == MS_DEBUGLEVEL_VVV)\n    {\n      if( pszExpression )\n        msDebug(\"FLTLayerApplyPlainFilterToLayer(): %s, rect=%.15g,%.15g,%.15g,%.15g\\n\", pszExpression, rect.minx, rect.miny, rect.maxx, rect.maxy);\n      else\n        msDebug(\"FLTLayerApplyPlainFilterToLayer(): rect=%.15g,%.15g,%.15g,%.15g\\n\", rect.minx, rect.miny, rect.maxx, rect.maxy);\n    }\n\n    status = FLTApplyFilterToLayerCommonExpressionWithRect(map, iLayerIndex,\n                                                           pszExpression, rect);\n    msFree(pszExpression);\n  }\n\n  return status;\n}\n\n\n\n/************************************************************************/\n/*            FilterNode *FLTPaserFilterEncoding(char *szXMLString)     */\n/*                                                                      */\n/*      Parses an Filter Encoding XML string and creates a              */\n/*      FilterEncodingNodes corresponding to the string.                */\n/*      Returns a pointer to the first node or NULL if                  */\n/*      unsuccessfull.                                                  */\n/*      Calling function should use FreeFilterEncodingNode function     */\n/*      to free memeory.                                                */\n/************************************************************************/\nFilterEncodingNode *FLTParseFilterEncoding(const char *szXMLString)\n{\n  CPLXMLNode *psRoot = NULL, *psChild=NULL, *psFilter=NULL;\n  FilterEncodingNode *psFilterNode = NULL;\n\n  if (szXMLString == NULL || strlen(szXMLString) <= 0 ||\n      (strstr(szXMLString, \"Filter\") == NULL))\n    return NULL;\n\n  psRoot = CPLParseXMLString(szXMLString);\n\n  if( psRoot == NULL)\n    return NULL;\n\n  /* strip namespaces. We srtip all name spaces (#1350)*/\n  CPLStripXMLNamespace(psRoot, NULL, 1);\n\n  /* -------------------------------------------------------------------- */\n  /*      get the root element (Filter).                                  */\n  /* -------------------------------------------------------------------- */\n  psFilter = CPLGetXMLNode(psRoot, \"=Filter\");\n  if (!psFilter)\n  {\n    CPLDestroyXMLNode( psRoot );\n    return NULL;\n  }\n\n  psChild = psFilter->psChild;\n  while (psChild) {\n    if (FLTIsSupportedFilterType(psChild)) {\n      psFilterNode = FLTCreateFilterEncodingNode();\n      FLTInsertElementInNode(psFilterNode, psChild);\n      break;\n    } else\n      psChild = psChild->psNext;\n  }\n\n  CPLDestroyXMLNode( psRoot );\n\n  /* -------------------------------------------------------------------- */\n  /*      validate the node tree to make sure that all the nodes are valid.*/\n  /* -------------------------------------------------------------------- */\n  if (!FLTValidFilterNode(psFilterNode)) {\n    FLTFreeFilterEncodingNode(psFilterNode);\n    return NULL;\n  }\n\n\n  return psFilterNode;\n}\n\n\n/************************************************************************/\n/*      int FLTValidFilterNode(FilterEncodingNode *psFilterNode)        */\n/*                                                                      */\n/*      Validate that all the nodes are filled properly. We could       */\n/*      have parts of the nodes that are correct and part which         */\n/*      could be incorrect if the filter string sent is corrupted       */\n/*      (eg missing a value :<PropertyName><PropertyName>)              */\n/************************************************************************/\nint FLTValidFilterNode(FilterEncodingNode *psFilterNode)\n{\n  int  bReturn = 0;\n\n  if (!psFilterNode)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_UNDEFINED)\n    return 0;\n\n  if (psFilterNode->psLeftNode) {\n    bReturn = FLTValidFilterNode(psFilterNode->psLeftNode);\n    if (bReturn == 0)\n      return 0;\n    else if (psFilterNode->psRightNode)\n      return FLTValidFilterNode(psFilterNode->psRightNode);\n  }\n\n  return 1;\n}\n\n/************************************************************************/\n/*                       FLTIsGeometryFilterNodeType                    */\n/************************************************************************/\n\nstatic int FLTIsGeometryFilterNodeType(int eType)\n{\n    return (eType == FILTER_NODE_TYPE_GEOMETRY_POINT ||\n            eType == FILTER_NODE_TYPE_GEOMETRY_LINE ||\n            eType == FILTER_NODE_TYPE_GEOMETRY_POLYGON);\n}\n\n/************************************************************************/\n/*                          FLTFreeFilterEncodingNode                   */\n/*                                                                      */\n/*      recursive freeing of Filer Encoding nodes.                      */\n/************************************************************************/\nvoid FLTFreeFilterEncodingNode(FilterEncodingNode *psFilterNode)\n{\n  if (psFilterNode) {\n    if (psFilterNode->psLeftNode) {\n      FLTFreeFilterEncodingNode(psFilterNode->psLeftNode);\n      psFilterNode->psLeftNode = NULL;\n    }\n    if (psFilterNode->psRightNode) {\n      FLTFreeFilterEncodingNode(psFilterNode->psRightNode);\n      psFilterNode->psRightNode = NULL;\n    }\n\n    if (psFilterNode->pszSRS)\n      free( psFilterNode->pszSRS);\n\n    if( psFilterNode->pOther ) {\n      if (psFilterNode->pszValue != NULL &&\n          strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0) {\n        FEPropertyIsLike* propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n        if( propIsLike->pszWildCard )\n          free( propIsLike->pszWildCard );\n        if( propIsLike->pszSingleChar )\n          free( propIsLike->pszSingleChar );\n        if( propIsLike->pszEscapeChar )\n          free( propIsLike->pszEscapeChar );\n      } else if (FLTIsGeometryFilterNodeType(psFilterNode->eType)) {\n        msFreeShape((shapeObj *)(psFilterNode->pOther));\n      }\n      /* else */\n      /* TODO free pOther special fields */\n      free( psFilterNode->pOther );\n    }\n\n    /* Cannot free pszValue before, 'cause we are testing it above */\n    if( psFilterNode->pszValue )\n      free( psFilterNode->pszValue );\n\n    free(psFilterNode);\n  }\n}\n\n\n/************************************************************************/\n/*                         FLTCreateFilterEncodingNode                  */\n/*                                                                      */\n/*      return a FilerEncoding node.                                    */\n/************************************************************************/\nFilterEncodingNode *FLTCreateFilterEncodingNode(void)\n{\n  FilterEncodingNode *psFilterNode = NULL;\n\n  psFilterNode =\n  (FilterEncodingNode *)malloc(sizeof (FilterEncodingNode));\n  psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n  psFilterNode->pszValue = NULL;\n  psFilterNode->pOther = NULL;\n  psFilterNode->pszSRS = NULL;\n  psFilterNode->psLeftNode = NULL;\n  psFilterNode->psRightNode = NULL;\n\n  return psFilterNode;\n}\n\nFilterEncodingNode *FLTCreateBinaryCompFilterEncodingNode(void)\n{\n  FilterEncodingNode *psFilterNode = NULL;\n\n  psFilterNode = FLTCreateFilterEncodingNode();\n  /* used to store case sensitivity flag. Default is 0 meaning the\n     comparing is case sensititive */\n  psFilterNode->pOther = (int *)malloc(sizeof(int));\n  (*(int *)(psFilterNode->pOther)) = 0;\n\n  return psFilterNode;\n}\n\n\n/************************************************************************/\n/*                           FLTFindGeometryNode                        */\n/*                                                                      */\n/************************************************************************/\n\nstatic CPLXMLNode* FLTFindGeometryNode(CPLXMLNode* psXMLNode,\n                                       int* pbPoint,\n                                       int* pbLine,\n                                       int* pbPolygon)\n{\n    CPLXMLNode *psGMLElement = NULL;\n\n    psGMLElement = CPLGetXMLNode(psXMLNode, \"Point\");\n    if (!psGMLElement)\n        psGMLElement =  CPLGetXMLNode(psXMLNode, \"PointType\");\n    if (psGMLElement)\n        *pbPoint =1;\n    else {\n      psGMLElement= CPLGetXMLNode(psXMLNode, \"Polygon\");\n      if (psGMLElement)\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiPolygon\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"Surface\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiSurface\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"Box\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"LineString\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiLineString\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"Curve\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiCurve\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"MultiPoint\")))\n        *pbPoint = 1;\n    }\n    return psGMLElement;\n}\n\n/************************************************************************/\n/*                           FLTGetPropertyName                         */\n/************************************************************************/\nstatic const char* FLTGetPropertyName(CPLXMLNode* psXMLNode)\n{\n    const char* pszPropertyName;\n\n    pszPropertyName = CPLGetXMLValue(psXMLNode, \"PropertyName\", NULL);\n    if( pszPropertyName == NULL ) /* FE 2.0 ? */\n        pszPropertyName = CPLGetXMLValue(psXMLNode, \"ValueReference\", NULL);\n    return pszPropertyName;\n}\n\n/************************************************************************/\n/*                          FLTGetFirstChildNode                        */\n/************************************************************************/\nstatic CPLXMLNode* FLTGetFirstChildNode(CPLXMLNode* psXMLNode)\n{\n    if( psXMLNode == NULL )\n        return NULL;\n    psXMLNode = psXMLNode->psChild;\n    while( psXMLNode != NULL )\n    {\n        if( psXMLNode->eType == CXT_Element )\n            return psXMLNode;\n        psXMLNode = psXMLNode->psNext;\n    }\n    return NULL;\n}\n\n/************************************************************************/\n/*                        FLTGetNextSibblingNode                        */\n/************************************************************************/\nstatic CPLXMLNode* FLTGetNextSibblingNode(CPLXMLNode* psXMLNode)\n{\n    if( psXMLNode == NULL )\n        return NULL;\n    psXMLNode = psXMLNode->psNext;\n    while( psXMLNode != NULL )\n    {\n        if( psXMLNode->eType == CXT_Element )\n            return psXMLNode;\n        psXMLNode = psXMLNode->psNext;\n    }\n    return NULL;\n}\n\n/************************************************************************/\n/*                           FLTInsertElementInNode                     */\n/*                                                                      */\n/*      Utility function to parse an XML node and transfter the         */\n/*      contennts into the Filer Encoding node structure.               */\n/************************************************************************/\nvoid FLTInsertElementInNode(FilterEncodingNode *psFilterNode,\n                            CPLXMLNode *psXMLNode)\n{\n  int nStrLength = 0;\n  char *pszTmp = NULL;\n  FilterEncodingNode *psCurFilNode= NULL;\n  CPLXMLNode *psCurXMLNode = NULL;\n  CPLXMLNode *psTmpNode = NULL;\n  CPLXMLNode *psFeatureIdNode = NULL;\n  const char *pszFeatureId=NULL;\n  char *pszFeatureIdList=NULL;\n\n  if (psFilterNode && psXMLNode && psXMLNode->pszValue) {\n    psFilterNode->pszValue = msStrdup(psXMLNode->pszValue);\n    psFilterNode->psLeftNode = NULL;\n    psFilterNode->psRightNode = NULL;\n\n    /* -------------------------------------------------------------------- */\n    /*      Logical filter. AND, OR and NOT are supported. Example of       */\n    /*      filer using logical filters :                                   */\n    /*      <Filter>                                                        */\n    /*        <And>                                                         */\n    /*          <PropertyIsGreaterThan>                                     */\n    /*            <PropertyName>Person/Age</PropertyName>                   */\n    /*            <Literal>50</Literal>                                     */\n    /*          </PropertyIsGreaterThan>                                    */\n    /*          <PropertyIsEqualTo>                                         */\n    /*             <PropertyName>Person/Address/City</PropertyName>         */\n    /*             <Literal>Toronto</Literal>                               */\n    /*          </PropertyIsEqualTo>                                        */\n    /*        </And>                                                        */\n    /*      </Filter>                                                       */\n    /* -------------------------------------------------------------------- */\n    if (FLTIsLogicalFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_LOGICAL;\n      if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n          strcasecmp(psFilterNode->pszValue, \"OR\") == 0) {\n        CPLXMLNode* psFirstNode = FLTGetFirstChildNode(psXMLNode);\n        CPLXMLNode* psSecondNode = FLTGetNextSibblingNode(psFirstNode);\n        if (psFirstNode && psSecondNode) {\n          /*2 operators */\n          CPLXMLNode* psNextNode = FLTGetNextSibblingNode(psSecondNode);\n          if (psNextNode == NULL) {\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            FLTInsertElementInNode(psFilterNode->psLeftNode, psFirstNode);\n            psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n            FLTInsertElementInNode(psFilterNode->psRightNode, psSecondNode);\n          } else {\n            psCurXMLNode = psFirstNode;\n            psCurFilNode = psFilterNode;\n            while(psCurXMLNode) {\n              psNextNode = FLTGetNextSibblingNode(psCurXMLNode);\n              if (FLTGetNextSibblingNode(psNextNode)) {\n                psCurFilNode->psLeftNode = FLTCreateFilterEncodingNode();\n                FLTInsertElementInNode(psCurFilNode->psLeftNode, psCurXMLNode);\n                psCurFilNode->psRightNode = FLTCreateFilterEncodingNode();\n                psCurFilNode->psRightNode->eType = FILTER_NODE_TYPE_LOGICAL;\n                psCurFilNode->psRightNode->pszValue = msStrdup(psFilterNode->pszValue);\n\n                psCurFilNode = psCurFilNode->psRightNode;\n                psCurXMLNode = psNextNode;\n              } else { /*last 2 operators*/\n                psCurFilNode->psLeftNode = FLTCreateFilterEncodingNode();\n                FLTInsertElementInNode(psCurFilNode->psLeftNode, psCurXMLNode);\n\n                psCurFilNode->psRightNode = FLTCreateFilterEncodingNode();\n                FLTInsertElementInNode(psCurFilNode->psRightNode, psNextNode);\n                break;\n              }\n            }\n          }\n        }\n        else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else if (strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n        CPLXMLNode* psFirstNode = FLTGetFirstChildNode(psXMLNode);\n        if (psFirstNode) {\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          FLTInsertElementInNode(psFilterNode->psLeftNode,\n                                 psFirstNode);\n        }\n        else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else\n        psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n    }/* end if is logical */\n    /* -------------------------------------------------------------------- */\n    /*      Spatial Filter.                                                 */\n    /*      BBOX :                                                          */\n    /*      <Filter>                                                        */\n    /*       <BBOX>                                                         */\n    /*        <PropertyName>Geometry</PropertyName>                         */\n    /*        <gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">*/\n    /*          <gml:coordinates>13.0983,31.5899 35.5472,42.8143</gml:coordinates>*/\n    /*        </gml:Box>                                                    */\n    /*       </BBOX>                                                        */\n    /*      </Filter>                                                       */\n    /*                                                                      */\n    /*       DWithin                                                        */\n    /*                                                                      */\n    /*      <xsd:element name=\"DWithin\"                                     */\n    /*      type=\"ogc:DistanceBufferType\"                                   */\n    /*      substitutionGroup=\"ogc:spatialOps\"/>                            */\n    /*                                                                      */\n    /*      <xsd:complexType name=\"DistanceBufferType\">                     */\n    /*         <xsd:complexContent>                                         */\n    /*            <xsd:extension base=\"ogc:SpatialOpsType\">                 */\n    /*               <xsd:sequence>                                         */\n    /*                  <xsd:element ref=\"ogc:PropertyName\"/>               */\n    /*                  <xsd:element ref=\"gml:_Geometry\"/>                  */\n    /*                  <xsd:element name=\"Distance\" type=\"ogc:DistanceType\"/>*/\n    /*               </xsd:sequence>                                        */\n    /*            </xsd:extension>                                          */\n    /*         </xsd:complexContent>                                        */\n    /*      </xsd:complexType>                                              */\n    /*                                                                      */\n    /*                                                                      */\n    /*       <Filter>                                                       */\n    /*       <DWithin>                                                      */\n    /*        <PropertyName>Geometry</PropertyName>                         */\n    /*        <gml:Point>                                                   */\n    /*          <gml:coordinates>13.0983,31.5899</gml:coordinates>          */\n    /*        </gml:Point>                                                  */\n    /*        <Distance units=\"url#m\">10</Distance>                         */\n    /*       </DWithin>                                                     */\n    /*      </Filter>                                                       */\n    /*                                                                      */\n    /*       Intersect                                                      */\n    /*                                                                      */\n    /*       type=\"ogc:BinarySpatialOpType\" substitutionGroup=\"ogc:spatialOps\"/>*/\n    /*      <xsd:element name=\"Intersects\"                                  */\n    /*      type=\"ogc:BinarySpatialOpType\"                                  */\n    /*      substitutionGroup=\"ogc:spatialOps\"/>                            */\n    /*                                                                      */\n    /*      <xsd:complexType name=\"BinarySpatialOpType\">                    */\n    /*      <xsd:complexContent>                                            */\n    /*      <xsd:extension base=\"ogc:SpatialOpsType\">                       */\n    /*      <xsd:sequence>                                                  */\n    /*      <xsd:element ref=\"ogc:PropertyName\"/>                           */\n    /*      <xsd:choice>                                                    */\n    /*      <xsd:element ref=\"gml:_Geometry\"/>                              */\n    /*      <xsd:element ref=\"gml:Box\"/>                                    */\n    /*      </xsd:sequence>                                                 */\n    /*      </xsd:extension>                                                */\n    /*      </xsd:complexContent>                                           */\n    /*      </xsd:complexType>                                              */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsSpatialFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_SPATIAL;\n\n      if (strcasecmp(psXMLNode->pszValue, \"BBOX\") == 0) {\n        char *pszSRS = NULL;\n        const char* pszPropertyName = NULL;\n        CPLXMLNode *psBox = NULL, *psEnvelope=NULL;\n        rectObj sBox;\n\n        int bCoordinatesValid = 0;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n        psBox = CPLGetXMLNode(psXMLNode, \"Box\");\n        if (!psBox)\n          psBox = CPLGetXMLNode(psXMLNode, \"BoxType\");\n\n        /*FE 1.0 used box FE1.1 uses envelop*/\n        if (psBox)\n          bCoordinatesValid = FLTParseGMLBox(psBox, &sBox, &pszSRS);\n        else if ((psEnvelope = CPLGetXMLNode(psXMLNode, \"Envelope\")))\n          bCoordinatesValid = FLTParseGMLEnvelope(psEnvelope, &sBox, &pszSRS);\n\n        if (bCoordinatesValid) {\n          /*set the srs if available*/\n          if (pszSRS)\n            psFilterNode->pszSRS = pszSRS;\n\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psLeftNode->eType =  FILTER_NODE_TYPE_PROPERTYNAME;\n          /* PropertyName is optional since FE 1.1.0, in which case */\n          /* the BBOX must apply to all geometry fields. As we support */\n          /* currently only one geometry field, this doesn't make much */\n          /* difference to further processing. */\n          if( pszPropertyName != NULL ) {\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n          }\n\n          /* coordinates */\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_BBOX;\n          psFilterNode->psRightNode->pOther =\n          (rectObj *)msSmallMalloc(sizeof(rectObj));\n          ((rectObj *)psFilterNode->psRightNode->pOther)->minx = sBox.minx;\n          ((rectObj *)psFilterNode->psRightNode->pOther)->miny = sBox.miny;\n          ((rectObj *)psFilterNode->psRightNode->pOther)->maxx = sBox.maxx;\n          ((rectObj *)psFilterNode->psRightNode->pOther)->maxy =  sBox.maxy;\n        } else {\n          msFree(pszSRS);\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n        }\n      } else if (strcasecmp(psXMLNode->pszValue, \"DWithin\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Beyond\") == 0)\n\n      {\n        shapeObj *psShape = NULL;\n        int bPoint = 0, bLine = 0, bPolygon = 0;\n        const char *pszUnits = NULL;\n        const char* pszDistance = NULL;\n        const char* pszPropertyName;\n        char *pszSRS = NULL;\n\n        CPLXMLNode *psGMLElement = NULL, *psDistance=NULL;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n\n        psGMLElement = FLTFindGeometryNode(psXMLNode, &bPoint, &bLine, &bPolygon);\n\n        psDistance = CPLGetXMLNode(psXMLNode, \"Distance\");\n        if( psDistance != NULL )\n            pszDistance = CPLGetXMLValue(psDistance, NULL, NULL );\n        if (pszPropertyName != NULL && psGMLElement && psDistance != NULL ) {\n          pszUnits = CPLGetXMLValue(psDistance, \"units\", NULL);\n          if( pszUnits == NULL ) /* FE 2.0 */\n              pszUnits = CPLGetXMLValue(psDistance, \"uom\", NULL);\n          psShape = (shapeObj *)msSmallMalloc(sizeof(shapeObj));\n          msInitShape(psShape);\n          if (FLTShapeFromGMLTree(psGMLElement, psShape, &pszSRS))\n          {\n            /*set the srs if available*/\n            if (pszSRS)\n              psFilterNode->pszSRS = pszSRS;\n\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n            psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n            if (bPoint)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POINT;\n            else if (bLine)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_LINE;\n            else if (bPolygon)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POLYGON;\n            psFilterNode->psRightNode->pOther = (shapeObj *)psShape;\n            /*the value will be distance;units*/\n            psFilterNode->psRightNode->pszValue = msStrdup(pszDistance);\n            if (pszUnits) {\n              psFilterNode->psRightNode->pszValue= msStringConcatenate(psFilterNode->psRightNode->pszValue, \";\");\n              psFilterNode->psRightNode->pszValue= msStringConcatenate(psFilterNode->psRightNode->pszValue, pszUnits);\n            }\n          }\n          else\n          {\n              free(psShape);\n              msFree(pszSRS);\n              psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n          }\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else if (strcasecmp(psXMLNode->pszValue, \"Intersect\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Intersects\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Equals\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Disjoint\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Touches\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Crosses\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Within\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Contains\") == 0 ||\n                 strcasecmp(psXMLNode->pszValue, \"Overlaps\") == 0) {\n        shapeObj *psShape = NULL;\n        int  bLine = 0, bPolygon = 0, bPoint=0;\n        char *pszSRS = NULL;\n        const char* pszPropertyName;\n\n        CPLXMLNode *psGMLElement = NULL;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n\n        psGMLElement = FLTFindGeometryNode(psXMLNode, &bPoint, &bLine, &bPolygon);\n\n        if (pszPropertyName != NULL && psGMLElement) {\n          psShape = (shapeObj *)msSmallMalloc(sizeof(shapeObj));\n          msInitShape(psShape);\n          if (FLTShapeFromGMLTree(psGMLElement, psShape, &pszSRS))\n          {\n            /*set the srs if available*/\n            if (pszSRS)\n              psFilterNode->pszSRS = pszSRS;\n\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n            psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n            if (bPoint)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POINT;\n            else if (bLine)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_LINE;\n            else if (bPolygon)\n              psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_GEOMETRY_POLYGON;\n            psFilterNode->psRightNode->pOther = (shapeObj *)psShape;\n\n          }\n          else\n          {\n              free(psShape);\n              msFree(pszSRS);\n              psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n          }\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n\n    }/* end of is spatial */\n\n\n    /* -------------------------------------------------------------------- */\n    /*      Comparison Filter                                               */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsComparisonFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_COMPARISON;\n      /* -------------------------------------------------------------------- */\n      /*      binary comaparison types. Example :                             */\n      /*                                                                      */\n      /*      <Filter>                                                        */\n      /*        <PropertyIsEqualTo>                                           */\n      /*          <PropertyName>SomeProperty</PropertyName>                   */\n      /*          <Literal>100</Literal>                                      */\n      /*        </PropertyIsEqualTo>                                          */\n      /*      </Filter>                                                       */\n      /* -------------------------------------------------------------------- */\n      if (FLTIsBinaryComparisonFilterType(psXMLNode->pszValue)) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        if (pszPropertyName != NULL ) {\n\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n          psTmpNode = CPLSearchXMLNode(psXMLNode,  \"Literal\");\n          if (psTmpNode) {\n            const char* pszLiteral = CPLGetXMLValue(psTmpNode, NULL, NULL);\n\n            psFilterNode->psRightNode = FLTCreateBinaryCompFilterEncodingNode();\n            psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_LITERAL;\n\n            if (pszLiteral != NULL) {\n              const char* pszMatchCase;\n\n              psFilterNode->psRightNode->pszValue = msStrdup(pszLiteral);\n              \n              pszMatchCase = CPLGetXMLValue(psXMLNode, \"matchCase\", NULL);\n\n              /*check if the matchCase attribute is set*/\n              if( pszMatchCase != NULL && strcasecmp( pszMatchCase, \"false\") == 0) {\n                (*(int *)psFilterNode->psRightNode->pOther) = 1;\n              }\n\n            }\n            /* special case where the user puts an empty value */\n            /* for the Literal so it can end up as an empty  */\n            /* string query in the expression */\n            else\n              psFilterNode->psRightNode->pszValue = NULL;\n          }\n        }\n        if (psFilterNode->psLeftNode == NULL || psFilterNode->psRightNode == NULL)\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n      /* -------------------------------------------------------------------- */\n      /*      PropertyIsBetween filter : extract property name and boudary    */\n      /*      values. The boundary  values are stored in the right            */\n      /*      node. The values are separated by a semi-column (;)             */\n      /*      Eg of Filter :                                                  */\n      /*      <PropertyIsBetween>                                             */\n      /*         <PropertyName>DEPTH</PropertyName>                           */\n      /*         <LowerBoundary><Literal>400</Literal></LowerBoundary>        */\n      /*         <UpperBoundary><Literal>800</Literal></UpperBoundary>        */\n      /*      </PropertyIsBetween>                                            */\n      /*                                                                      */\n      /*      Or                                                              */\n      /*      <PropertyIsBetween>                                             */\n      /*         <PropertyName>DEPTH</PropertyName>                           */\n      /*         <LowerBoundary>400</LowerBoundary>                           */\n      /*         <UpperBoundary>800</UpperBoundary>                           */\n      /*      </PropertyIsBetween>                                            */\n      /* -------------------------------------------------------------------- */\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsBetween\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        CPLXMLNode* psLowerBoundary = CPLGetXMLNode(psXMLNode, \"LowerBoundary\");\n        CPLXMLNode* psUpperBoundary = CPLGetXMLNode(psXMLNode, \"UpperBoundary\");\n        const char* pszLowerNode = NULL;\n        const char* pszUpperNode = NULL;\n        if( psLowerBoundary != NULL )\n        {\n          /* check if the <Literal> is there */\n          if (CPLGetXMLNode(psLowerBoundary, \"Literal\") != NULL)\n            pszLowerNode = CPLGetXMLValue(psLowerBoundary, \"Literal\", NULL);\n          else\n            pszLowerNode = CPLGetXMLValue(psLowerBoundary, NULL, NULL);\n        }\n        if( psUpperBoundary != NULL )\n        {\n           if (CPLGetXMLNode(psUpperBoundary, \"Literal\") != NULL)\n            pszUpperNode = CPLGetXMLValue(psUpperBoundary, \"Literal\", NULL);\n          else\n            pszUpperNode = CPLGetXMLValue(psUpperBoundary, NULL, NULL);\n        }\n        if (pszPropertyName != NULL && pszLowerNode != NULL && pszUpperNode != NULL) {\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n\n          psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_BOUNDARY;\n\n          /* adding a ; between bounary values */\n          nStrLength = strlen(pszLowerNode) + strlen(pszUpperNode) + 2;\n\n          psFilterNode->psRightNode->pszValue =\n              (char *)malloc(sizeof(char)*(nStrLength));\n          strcpy( psFilterNode->psRightNode->pszValue, pszLowerNode);\n          strlcat(psFilterNode->psRightNode->pszValue, \";\", nStrLength);\n          strlcat(psFilterNode->psRightNode->pszValue, pszUpperNode, nStrLength);\n\n\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n\n      }/* end of PropertyIsBetween  */\n      /* -------------------------------------------------------------------- */\n      /*      PropertyIsLike                                                  */\n      /*                                                                      */\n      /*      <Filter>                                                        */\n      /*      <PropertyIsLike wildCard=\"*\" singleChar=\"#\" escape=\"!\">         */\n      /*      <PropertyName>LAST_NAME</PropertyName>                          */\n      /*      <Literal>JOHN*</Literal>                                        */\n      /*      </PropertyIsLike>                                               */\n      /*      </Filter>                                                       */\n      /* -------------------------------------------------------------------- */\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsLike\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        const char* pszLiteral = CPLGetXMLValue(psXMLNode, \"Literal\", NULL);\n        const char* pszWildCard = CPLGetXMLValue(psXMLNode, \"wildCard\", NULL);\n        const char* pszSingleChar = CPLGetXMLValue(psXMLNode, \"singleChar\", NULL);\n        const char* pszEscapeChar = CPLGetXMLValue(psXMLNode, \"escape\", NULL);\n        if( pszEscapeChar == NULL )\n            pszEscapeChar = CPLGetXMLValue(psXMLNode, \"escapeChar\", NULL);\n        if (pszPropertyName != NULL && pszLiteral != NULL &&\n            pszWildCard != NULL && pszSingleChar != NULL && pszEscapeChar != NULL)\n        {\n          FEPropertyIsLike* propIsLike;\n\n          propIsLike = (FEPropertyIsLike *)malloc(sizeof(FEPropertyIsLike));\n\n          psFilterNode->pOther = propIsLike;\n          propIsLike->bCaseInsensitive = 0;\n          propIsLike->pszWildCard = msStrdup(pszWildCard);\n          propIsLike->pszSingleChar = msStrdup(pszSingleChar);\n          propIsLike->pszEscapeChar = msStrdup(pszEscapeChar);\n\n          pszTmp = (char *)CPLGetXMLValue(psXMLNode, \"matchCase\", NULL);\n          if (pszTmp && strcasecmp(pszTmp, \"false\") == 0) {\n            propIsLike->bCaseInsensitive =1;\n          }\n          /* -------------------------------------------------------------------- */\n          /*      Create left and right node for the attribute and the value.     */\n          /* -------------------------------------------------------------------- */\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n          psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n\n          psFilterNode->psRightNode->pszValue = msStrdup(pszLiteral);\n\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_LITERAL;\n        } else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n\n      }\n\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsNull\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        if( pszPropertyName != NULL )\n        {\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n        }  else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n      else if (strcasecmp(psXMLNode->pszValue, \"PropertyIsNil\") == 0) {\n        const char* pszPropertyName = FLTGetPropertyName(psXMLNode);\n        if( pszPropertyName != NULL )\n        {\n            psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n            psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n            psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;\n        }  else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n    }\n    /* -------------------------------------------------------------------- */\n    /*      FeatureId Filter                                                */\n    /*                                                                      */\n    /*      <ogc:Filter>                                                    */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.1013\"/>                         */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.10\"/>                           */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.13\"/>                           */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.140\"/>                          */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.5001\"/>                         */\n    /*      <ogc:FeatureId fid=\"INWATERA_1M.2001\"/>                         */\n    /*      </ogc:Filter>                                                   */\n    /*                                                                      */\n    /*                                                                      */\n    /*      Note that for FES1.1.0 the featureid has been depricated in     */\n    /*      favor of GmlObjectId                                            */\n    /*      <GmlObjectId gml:id=\"TREESA_1M.1234\"/>                          */\n    /*                                                                      */\n    /*      And in FES 2.0, in favor of <fes:ResourceId rid=\"foo.1234\"/>    */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsFeatureIdFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_FEATUREID;\n      pszFeatureId = CPLGetXMLValue(psXMLNode, \"fid\", NULL);\n      /*for FE 1.1.0 GmlObjectId */\n      if (pszFeatureId == NULL)\n        pszFeatureId = CPLGetXMLValue(psXMLNode, \"id\", NULL);\n      /*for FE 2.0 ResourceId */\n      if (pszFeatureId == NULL)\n        pszFeatureId = CPLGetXMLValue(psXMLNode, \"rid\", NULL);\n      pszFeatureIdList = NULL;\n\n      psFeatureIdNode = psXMLNode;\n      while (psFeatureIdNode) {\n        pszFeatureId = CPLGetXMLValue(psFeatureIdNode, \"fid\", NULL);\n        if (!pszFeatureId)\n          pszFeatureId = CPLGetXMLValue(psFeatureIdNode, \"id\", NULL);\n        if (!pszFeatureId)\n          pszFeatureId = CPLGetXMLValue(psFeatureIdNode, \"rid\", NULL);\n\n        if (pszFeatureId) {\n          if (pszFeatureIdList)\n            pszFeatureIdList = msStringConcatenate(pszFeatureIdList, \",\");\n\n          pszFeatureIdList = msStringConcatenate(pszFeatureIdList, pszFeatureId);\n        }\n        psFeatureIdNode = psFeatureIdNode->psNext;\n      }\n\n      if (pszFeatureIdList) {\n        msFree(psFilterNode->pszValue);\n        psFilterNode->pszValue =  msStrdup(pszFeatureIdList);\n        msFree(pszFeatureIdList);\n      } else\n        psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n    }\n    \n    /* -------------------------------------------------------------------- */\n    /*      Temporal Filter.                                                */\n    /*\n    <fes:During>\n    <fes:ValueReference>gml:TimeInstant</fes:ValueReference>\n    <gml:TimePeriod gml:id=\"TP1\">\n    <gml:begin>\n    <gml:TimeInstant gml:id=\"TI1\">\n    <gml:timePosition>2005-05-17T00:00:00Z</gml:timePosition>\n    </gml:TimeInstant>\n    </gml:begin>\n    <gml:end>\n    <gml:TimeInstant gml:id=\"TI2\">\n    <gml:timePosition>2005-05-23T00:00:00Z</gml:timePosition>\n    </gml:TimeInstant>\n    </gml:end>\n    </gml:TimePeriod>\n    </fes:During>\n    */\n    /* -------------------------------------------------------------------- */\n    else if (FLTIsTemporalFilterType(psXMLNode->pszValue)) {\n      psFilterNode->eType = FILTER_NODE_TYPE_TEMPORAL;\n\n      if (strcasecmp(psXMLNode->pszValue, \"During\") == 0) {\n        const char* pszPropertyName = NULL;\n        const char* pszBeginTime;\n        const char* pszEndTime;\n\n        pszPropertyName = FLTGetPropertyName(psXMLNode);\n        pszBeginTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.begin.TimeInstant.timePosition\", NULL);\n        if( pszBeginTime == NULL )\n            pszBeginTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.beginPosition\", NULL);\n        pszEndTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.end.TimeInstant.timePosition\", NULL);\n        if( pszEndTime == NULL )\n            pszEndTime = CPLGetXMLValue(psXMLNode, \"TimePeriod.endPosition\", NULL);\n\n        if (pszPropertyName && pszBeginTime && pszEndTime &&\n            strchr(pszBeginTime, '\\'') == NULL && strchr(pszBeginTime, '\\\\') == NULL &&\n            strchr(pszEndTime, '\\'') == NULL && strchr(pszEndTime, '\\\\') == NULL &&\n            msTimeGetResolution(pszBeginTime) >= 0 &&\n            msTimeGetResolution(pszEndTime) >= 0) {\n\n          psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psLeftNode->eType =  FILTER_NODE_TYPE_PROPERTYNAME;\n          psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);\n\n          psFilterNode->psRightNode = FLTCreateFilterEncodingNode();\n          psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_TIME_PERIOD;\n          psFilterNode->psRightNode->pszValue = msSmallMalloc( strlen(pszBeginTime) + strlen(pszEndTime) + 2 );\n          sprintf(psFilterNode->psRightNode->pszValue, \"%s/%s\", pszBeginTime, pszEndTime);\n        }\n        else\n          psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      } else {\n        psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;\n      }\n\n    }/* end of is temporal */\n\n\n\n  }\n}\n\n\n/************************************************************************/\n/*            int FLTIsLogicalFilterType((char *pszValue)                  */\n/*                                                                      */\n/*      return TRUE if the value of the node is of logical filter       */\n/*       encoding type.                                                 */\n/************************************************************************/\nint FLTIsLogicalFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if (strcasecmp(pszValue, \"AND\") == 0 ||\n        strcasecmp(pszValue, \"OR\") == 0 ||\n        strcasecmp(pszValue, \"NOT\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*         int FLTIsBinaryComparisonFilterType(char *pszValue)             */\n/*                                                                      */\n/*      Binary comparison filter type.                                  */\n/************************************************************************/\nint FLTIsBinaryComparisonFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if (strcasecmp(pszValue, \"PropertyIsEqualTo\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNotEqualTo\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsLessThan\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsGreaterThan\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsLessThanOrEqualTo\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsGreaterThanOrEqualTo\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsComparisonFilterType(char *pszValue)                */\n/*                                                                      */\n/*      return TRUE if the value of the node is of comparison filter    */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsComparisonFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if (FLTIsBinaryComparisonFilterType(pszValue) ||\n        strcasecmp(pszValue, \"PropertyIsLike\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsBetween\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNull\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNil\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsFeatureIdFilterType(char *pszValue)              */\n/*                                                                      */\n/*      return TRUE if the value of the node is of featureid filter     */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsFeatureIdFilterType(const char *pszValue)\n{\n  if (pszValue && (strcasecmp(pszValue, \"FeatureId\") == 0 ||\n                   strcasecmp(pszValue, \"GmlObjectId\") == 0 ||\n                   strcasecmp(pszValue, \"ResourceId\") == 0))\n\n    return MS_TRUE;\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsSpatialFilterType(char *pszValue)                */\n/*                                                                      */\n/*      return TRUE if the value of the node is of spatial filter       */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsSpatialFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if ( strcasecmp(pszValue, \"BBOX\") == 0 ||\n         strcasecmp(pszValue, \"DWithin\") == 0 ||\n         strcasecmp(pszValue, \"Intersect\") == 0 ||\n         strcasecmp(pszValue, \"Intersects\") == 0 ||\n         strcasecmp(pszValue, \"Equals\") == 0 ||\n         strcasecmp(pszValue, \"Disjoint\") == 0 ||\n         strcasecmp(pszValue, \"Touches\") == 0 ||\n         strcasecmp(pszValue, \"Crosses\") == 0 ||\n         strcasecmp(pszValue, \"Within\") == 0 ||\n         strcasecmp(pszValue, \"Contains\") == 0 ||\n         strcasecmp(pszValue, \"Overlaps\") == 0 ||\n         strcasecmp(pszValue, \"Beyond\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*            int FLTIsTemportalFilterType(char *pszValue)              */\n/*                                                                      */\n/*      return TRUE if the value of the node is of temporal filter      */\n/*      encoding type.                                                  */\n/************************************************************************/\nint FLTIsTemporalFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if ( strcasecmp(pszValue, \"During\") == 0 )\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*           int FLTIsSupportedFilterType(CPLXMLNode *psXMLNode)           */\n/*                                                                      */\n/*      Verfify if the value of the node is one of the supported        */\n/*      filter type.                                                    */\n/************************************************************************/\nint FLTIsSupportedFilterType(CPLXMLNode *psXMLNode)\n{\n  if (psXMLNode) {\n    if (FLTIsLogicalFilterType(psXMLNode->pszValue) ||\n        FLTIsSpatialFilterType(psXMLNode->pszValue) ||\n        FLTIsComparisonFilterType(psXMLNode->pszValue) ||\n        FLTIsFeatureIdFilterType(psXMLNode->pszValue) ||\n        FLTIsTemporalFilterType(psXMLNode->pszValue))\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}\n\n/************************************************************************/\n/*                          FLTNumberOfFilterType                       */\n/*                                                                      */\n/*      Loop trhough the nodes and return the number of nodes of        */\n/*      specified value.                                                */\n/************************************************************************/\nint FLTNumberOfFilterType(FilterEncodingNode *psFilterNode, const char *szType)\n{\n  int nCount = 0;\n  int nLeftNode=0 , nRightNode = 0;\n\n  if (!psFilterNode || !szType || !psFilterNode->pszValue)\n    return 0;\n\n  if (strcasecmp(psFilterNode->pszValue, (char*)szType) == 0)\n    nCount++;\n\n  if (psFilterNode->psLeftNode)\n    nLeftNode = FLTNumberOfFilterType(psFilterNode->psLeftNode, szType);\n\n  nCount += nLeftNode;\n\n  if (psFilterNode->psRightNode)\n    nRightNode = FLTNumberOfFilterType(psFilterNode->psRightNode, szType);\n  nCount += nRightNode;\n\n  return nCount;\n}\n\n\n\n\n/************************************************************************/\n/*                          FLTValidForBBoxFilter                       */\n/*                                                                      */\n/*      Validate if there is only one BBOX filter node. Here is waht    */\n/*      is supported (is valid) :                                       */\n/*        - one node which is a BBOX                                    */\n/*        - a logical AND with a valid BBOX                             */\n/*                                                                      */\n/*      eg 1: <Filter>                                                  */\n/*            <BBOX>                                                    */\n/*              <PropertyName>Geometry</PropertyName>                   */\n/*              <gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">*/\n/*                <gml:coordinates>13.0983,31.5899 35.5472,42.8143</gml:coordinates>*/\n/*              </gml:Box>                                              */\n/*            </BBOX>                                                   */\n/*          </Filter>                                                   */\n/*                                                                      */\n/*      eg 2 :<Filter>                                                  */\n/*              <AND>                                                   */\n/*               <BBOX>                                                 */\n/*                <PropertyName>Geometry</PropertyName>                  */\n/*                <gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">*/\n/*                  <gml:coordinates>13.0983,31.5899 35.5472,42.8143</gml:coordinates>*/\n/*                </gml:Box>                                            */\n/*               </BBOX>                                                */\n/*               <PropertyIsEqualTo>                                    */\n/*               <PropertyName>SomeProperty</PropertyName>              */\n/*                <Literal>100</Literal>                                */\n/*              </PropertyIsEqualTo>                                    */\n/*             </AND>                                                   */\n/*           </Filter>                                                  */\n/*                                                                      */\n/************************************************************************/\nint FLTValidForBBoxFilter(FilterEncodingNode *psFilterNode)\n{\n  int nCount = 0;\n\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 1;\n\n  nCount = FLTNumberOfFilterType(psFilterNode, \"BBOX\");\n\n  if (nCount > 1)\n    return 0;\n  else if (nCount == 0)\n    return 1;\n\n  /* nCount ==1  */\n  if (strcasecmp(psFilterNode->pszValue, \"BBOX\") == 0)\n    return 1;\n\n  if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0) {\n    return FLTValidForBBoxFilter(psFilterNode->psLeftNode) &&\n           FLTValidForBBoxFilter(psFilterNode->psRightNode);\n  }\n\n  return 0;\n}\n\n#if 0\nstatic int FLTHasUniqueTopLevelDuringFilter(FilterEncodingNode *psFilterNode)\n{\n  int nCount = 0;\n\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 1;\n\n  nCount = FLTNumberOfFilterType(psFilterNode, \"During\");\n\n  if (nCount > 1)\n    return 0;\n  else if (nCount == 0)\n    return 1;\n\n  /* nCount ==1  */\n  if (strcasecmp(psFilterNode->pszValue, \"During\") == 0)\n    return 1;\n\n  if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0) {\n    return FLTHasUniqueTopLevelDuringFilter(psFilterNode->psLeftNode) &&\n           FLTHasUniqueTopLevelDuringFilter(psFilterNode->psRightNode);\n  }\n\n  return 0;\n}\n#endif\n\nint FLTIsLineFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n      psFilterNode->psRightNode &&\n      psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_GEOMETRY_LINE)\n    return 1;\n\n  return 0;\n}\n\nint FLTIsPolygonFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n      psFilterNode->psRightNode &&\n      psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_GEOMETRY_POLYGON)\n    return 1;\n\n  return 0;\n}\n\nint FLTIsPointFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n      psFilterNode->psRightNode &&\n      psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_GEOMETRY_POINT)\n    return 1;\n\n  return 0;\n}\n\nint FLTIsBBoxFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (strcasecmp(psFilterNode->pszValue, \"BBOX\") == 0)\n    return 1;\n\n  return 0;\n}\n\nshapeObj *FLTGetShape(FilterEncodingNode *psFilterNode, double *pdfDistance,\n                      int *pnUnit)\n{\n  char **tokens = NULL;\n  int nTokens = 0;\n  FilterEncodingNode *psNode = psFilterNode;\n  char *szUnitStr = NULL;\n  char *szUnit = NULL;\n\n  if (psNode) {\n    if (psNode->eType == FILTER_NODE_TYPE_SPATIAL && psNode->psRightNode)\n      psNode = psNode->psRightNode;\n\n    if (FLTIsGeometryFilterNodeType(psNode->eType)) {\n\n      if (psNode->pszValue && pdfDistance) {\n        /*\n        sytnax expected is \"distance;unit\" or just \"distance\"\n        if unit is there syntax is \"URI#unit\" (eg http://..../#m)\n        or just \"unit\"\n        */\n        tokens = msStringSplit(psNode->pszValue,';', &nTokens);\n        if (tokens && nTokens >= 1) {\n          *pdfDistance = atof(tokens[0]);\n\n          if (nTokens == 2 && pnUnit) {\n            szUnitStr = msStrdup(tokens[1]);\n            msFreeCharArray(tokens, nTokens);\n            nTokens = 0;\n            tokens = msStringSplit(szUnitStr,'#', &nTokens);\n            msFree(szUnitStr);\n            if (tokens && nTokens >= 1) {\n              if (nTokens ==1)\n                szUnit = tokens[0];\n              else\n                szUnit = tokens[1];\n\n              if (strcasecmp(szUnit,\"m\") == 0 ||\n                  strcasecmp(szUnit,\"meters\") == 0 )\n                *pnUnit = MS_METERS;\n              else if (strcasecmp(szUnit,\"km\") == 0 ||\n                       strcasecmp(szUnit,\"kilometers\") == 0)\n                *pnUnit = MS_KILOMETERS;\n              else if (strcasecmp(szUnit,\"NM\") == 0 ||\n                       strcasecmp(szUnit,\"nauticalmiles\") == 0)\n                *pnUnit = MS_NAUTICALMILES;\n              else if (strcasecmp(szUnit,\"mi\") == 0 ||\n                       strcasecmp(szUnit,\"miles\") == 0)\n                *pnUnit = MS_MILES;\n              else if (strcasecmp(szUnit,\"in\") == 0 ||\n                       strcasecmp(szUnit,\"inches\") == 0)\n                *pnUnit = MS_INCHES;\n              else if (strcasecmp(szUnit,\"ft\") == 0 ||\n                       strcasecmp(szUnit,\"feet\") == 0)\n                *pnUnit = MS_FEET;\n              else if (strcasecmp(szUnit,\"deg\") == 0 ||\n                       strcasecmp(szUnit,\"dd\") == 0)\n                *pnUnit = MS_DD;\n              else if (strcasecmp(szUnit,\"px\") == 0)\n                *pnUnit = MS_PIXELS;\n\n            }\n          }\n        } \n        msFreeCharArray(tokens, nTokens);\n      }\n\n      return (shapeObj *)psNode->pOther;\n    }\n  }\n  return NULL;\n}\n\n/************************************************************************/\n/*                                FLTGetBBOX                            */\n/*                                                                      */\n/*      Loop through the nodes are return the coordinates of the        */\n/*      first bbox node found. The retrun value is the epsg code of     */\n/*      the bbox.                                                       */\n/************************************************************************/\nconst char *FLTGetBBOX(FilterEncodingNode *psFilterNode, rectObj *psRect)\n{\n  const char *pszReturn = NULL;\n\n  if (!psFilterNode || !psRect)\n    return NULL;\n\n  if (psFilterNode->pszValue && strcasecmp(psFilterNode->pszValue, \"BBOX\") == 0) {\n    if (psFilterNode->psRightNode && psFilterNode->psRightNode->pOther) {\n      rectObj* pRect= (rectObj *)psFilterNode->psRightNode->pOther;\n      psRect->minx = pRect->minx;\n      psRect->miny = pRect->miny;\n      psRect->maxx = pRect->maxx;\n      psRect->maxy = pRect->maxy;\n\n      return psFilterNode->pszSRS;\n\n    }\n  } else {\n    pszReturn = FLTGetBBOX(psFilterNode->psLeftNode, psRect);\n    if (pszReturn)\n      return pszReturn;\n    else\n      return  FLTGetBBOX(psFilterNode->psRightNode, psRect);\n  }\n\n  return pszReturn;\n}\n\nconst char* FLTGetDuring(FilterEncodingNode *psFilterNode, const char** ppszTimeField)\n{\n  const char *pszReturn = NULL;\n\n  if (!psFilterNode || !ppszTimeField)\n    return NULL;\n\n  if (psFilterNode->pszValue && strcasecmp(psFilterNode->pszValue, \"During\") == 0) {\n    *ppszTimeField = psFilterNode->psLeftNode->pszValue;\n    return psFilterNode->psRightNode->pszValue;\n  } else {\n    pszReturn = FLTGetDuring(psFilterNode->psLeftNode, ppszTimeField);\n    if (pszReturn)\n      return pszReturn;\n    else\n      return  FLTGetDuring(psFilterNode->psRightNode, ppszTimeField);\n  }\n\n  return pszReturn;\n}\n\n/************************************************************************/\n/*                          GetMapserverExpression                      */\n/*                                                                      */\n/*      Return a mapserver expression base on the Filer encoding nodes. */\n/************************************************************************/\nchar *FLTGetMapserverExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  const char *pszAttribute = NULL;\n  char szTmp[256];\n  char **tokens = NULL;\n  int nTokens = 0, i=0,bString=0;\n\n  if (!psFilterNode)\n    return NULL;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON) {\n    if ( psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n      if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue)) {\n        pszExpression = FLTGetBinaryComparisonExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsBetween\") == 0) {\n        pszExpression = FLTGetIsBetweenComparisonExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsLike\") == 0) {\n        pszExpression = FLTGetIsLikeComparisonExpression(psFilterNode);\n      }\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n        strcasecmp(psFilterNode->pszValue, \"OR\") == 0) {\n      pszExpression = FLTGetLogicalComparisonExpresssion(psFilterNode, lp);\n    } else if (strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n      pszExpression = FLTGetLogicalComparisonExpresssion(psFilterNode, lp);\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL) {\n    /* TODO */\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_FEATUREID) {\n#if defined(USE_WMS_SVR) || defined (USE_WFS_SVR) || defined (USE_WCS_SVR) || defined(USE_SOS_SVR)\n    if (psFilterNode->pszValue) {\n      pszAttribute = msOWSLookupMetadata(&(lp->metadata), \"OFG\", \"featureid\");\n      if (pszAttribute) {\n        tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n        if (tokens && nTokens > 0) {\n          for (i=0; i<nTokens; i++) {\n            const char* pszId = tokens[i];\n            const char* pszDot = strchr(pszId, '.');\n            if( pszDot )\n                pszId = pszDot + 1;\n            if (i == 0) {\n              if(FLTIsNumeric(pszId) == MS_FALSE)\n                bString = 1;\n            }\n            if (bString)\n              snprintf(szTmp, sizeof(szTmp), \"('[%s]' = '%s')\" , pszAttribute, pszId);\n            else\n              snprintf(szTmp, sizeof(szTmp), \"([%s] = %s)\" , pszAttribute, pszId);\n\n            if (pszExpression != NULL)\n              pszExpression = msStringConcatenate(pszExpression, \" OR \");\n            else\n              pszExpression = msStringConcatenate(pszExpression, \"(\");\n            pszExpression = msStringConcatenate(pszExpression, szTmp);\n          }\n\n          msFreeCharArray(tokens, nTokens);\n        }\n      }\n      /*opening and closing brackets are needed for mapserver expressions*/\n      if (pszExpression)\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n    }\n#else\n    msSetError(MS_MISCERR, \"OWS support is not available.\",\n               \"FLTGetMapserverExpression()\");\n    return(MS_FAILURE);\n#endif\n\n  }\n  return pszExpression;\n}\n\n\n/************************************************************************/\n/*                           FLTGetSQLExpression                        */\n/*                                                                      */\n/*      Build SQL expressions from the mapserver nodes.                 */\n/************************************************************************/\nchar *FLTGetSQLExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  const char *pszAttribute = NULL;\n  char szTmp[256];\n  char **tokens = NULL;\n  int nTokens = 0, i=0, bString=0;\n\n  if (psFilterNode == NULL || lp == NULL)\n    return NULL;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON) {\n    if ( psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n      if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue)) {\n        pszExpression =\n          FLTGetBinaryComparisonSQLExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsBetween\") == 0) {\n        pszExpression =\n          FLTGetIsBetweenComparisonSQLExpresssion(psFilterNode, lp);\n      } else if (strcasecmp(psFilterNode->pszValue,\n                            \"PropertyIsLike\") == 0) {\n        pszExpression =\n          FLTGetIsLikeComparisonSQLExpression(psFilterNode, lp);\n\n      }\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n        strcasecmp(psFilterNode->pszValue, \"OR\") == 0) {\n      pszExpression =\n        FLTGetLogicalComparisonSQLExpresssion(psFilterNode, lp);\n\n    } else if (strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n      pszExpression =\n        FLTGetLogicalComparisonSQLExpresssion(psFilterNode, lp);\n\n    }\n  }\n\n  else if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL) {\n    /* TODO */\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_FEATUREID) {\n#if defined(USE_WMS_SVR) || defined (USE_WFS_SVR) || defined (USE_WCS_SVR) || defined(USE_SOS_SVR)\n    if (psFilterNode->pszValue) {\n      pszAttribute = msOWSLookupMetadata(&(lp->metadata), \"OFG\", \"featureid\");\n      if (pszAttribute) {\n        tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n        bString = 0;\n        if (tokens && nTokens > 0) {\n          for (i=0; i<nTokens; i++) {\n            char *pszEscapedStr = NULL;\n            const char* pszId = tokens[i];\n            const char* pszDot = strchr(pszId, '.');\n            if( pszDot )\n                pszId = pszDot + 1;\n\n            if (strlen(pszId) <= 0)\n              continue;\n\n            if (FLTIsNumeric(pszId) == MS_FALSE)\n              bString = 1;\n\n            pszEscapedStr = msLayerEscapeSQLParam(lp, pszId);\n            if (bString)\n            {\n              if( lp->connectiontype == MS_OGR || lp->connectiontype == MS_POSTGIS )\n                snprintf(szTmp, sizeof(szTmp), \"(CAST(%s AS CHARACTER(255)) = '%s')\" , pszAttribute, pszEscapedStr);\n              else\n                snprintf(szTmp, sizeof(szTmp), \"(%s = '%s')\" , pszAttribute, pszEscapedStr);\n            }\n            else\n              snprintf(szTmp, sizeof(szTmp), \"(%s = %s)\" , pszAttribute, pszEscapedStr);\n\n            msFree(pszEscapedStr);\n            pszEscapedStr=NULL;\n\n            if (pszExpression != NULL)\n              pszExpression = msStringConcatenate(pszExpression, \" OR \");\n            else\n              /*opening and closing brackets*/\n              pszExpression = msStringConcatenate(pszExpression, \"(\");\n\n            pszExpression = msStringConcatenate(pszExpression, szTmp);\n          }\n\n          msFreeCharArray(tokens, nTokens);\n        }\n      }\n      /*opening and closing brackets*/\n      if (pszExpression)\n        pszExpression = msStringConcatenate(pszExpression, \")\");\n    }\n#else\n    msSetError(MS_MISCERR, \"OWS support is not available.\",\n               \"FLTGetSQLExpression()\");\n    return(MS_FAILURE);\n#endif\n\n  }\n  else if ( lp->connectiontype != MS_OGR &&\n            psFilterNode->eType == FILTER_NODE_TYPE_TEMPORAL )\n    pszExpression = FLTGetTimeExpression(psFilterNode, lp);\n\n  return pszExpression;\n}\n\n/************************************************************************/\n/*                            FLTGetNodeExpression                      */\n/*                                                                      */\n/*      Return the expresion for a specific node.                       */\n/************************************************************************/\nchar *FLTGetNodeExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  if (!psFilterNode)\n    return NULL;\n\n  if (FLTIsLogicalFilterType(psFilterNode->pszValue))\n    pszExpression = FLTGetLogicalComparisonExpresssion(psFilterNode, lp);\n  else if (FLTIsComparisonFilterType(psFilterNode->pszValue)) {\n    if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n      pszExpression = FLTGetBinaryComparisonExpresssion(psFilterNode, lp);\n    else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0)\n      pszExpression = FLTGetIsBetweenComparisonExpresssion(psFilterNode, lp);\n    else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n      pszExpression = FLTGetIsLikeComparisonExpression(psFilterNode);\n  }\n\n  return pszExpression;\n}\n\n\n/************************************************************************/\n/*                     FLTGetLogicalComparisonSQLExpresssion            */\n/*                                                                      */\n/*      Return the expression for logical comparison expression.        */\n/************************************************************************/\nchar *FLTGetLogicalComparisonSQLExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  char *pszBuffer = NULL;\n  char *pszTmp = NULL;\n  int nTmp = 0;\n\n  if (lp == NULL)\n    return NULL;\n\n  /* ==================================================================== */\n  /*      special case for BBOX node.                                     */\n  /* ==================================================================== */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode &&\n      ((strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") == 0) ||\n       (strcasecmp(psFilterNode->psRightNode->pszValue, \"BBOX\") == 0))) {\n    if (strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") != 0)\n      pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    else\n      pszTmp = FLTGetSQLExpression(psFilterNode->psRightNode, lp);\n\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) + 1));\n    sprintf(pszBuffer, \"%s\", pszTmp);\n  }\n\n  /* ==================================================================== */\n  /*      special case for temporal filter node (OGR layer only)          */\n  /* ==================================================================== */\n  else if (lp->connectiontype == MS_OGR &&\n      psFilterNode->psLeftNode && psFilterNode->psRightNode &&\n      (psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_TEMPORAL ||\n       psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_TEMPORAL) ) {\n    if (psFilterNode->psLeftNode->eType != FILTER_NODE_TYPE_TEMPORAL)\n      pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    else\n      pszTmp = FLTGetSQLExpression(psFilterNode->psRightNode, lp);\n\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) + 1));\n    sprintf(pszBuffer, \"%s\", pszTmp);\n  }\n  \n  /* -------------------------------------------------------------------- */\n  /*      OR and AND                                                      */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n    pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) *\n                               (strlen(pszTmp) +\n                                strlen(psFilterNode->pszValue) + 5));\n    pszBuffer[0] = '\\0';\n    strcat(pszBuffer, \" (\");\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \" \");\n    strcat(pszBuffer, psFilterNode->pszValue);\n    strcat(pszBuffer, \" \");\n\n    free( pszTmp );\n\n    nTmp = strlen(pszBuffer);\n    pszTmp = FLTGetSQLExpression(psFilterNode->psRightNode, lp);\n    if (!pszTmp) {\n      free(pszBuffer);\n      return NULL;\n    }\n\n    pszBuffer = (char *)realloc(pszBuffer,\n                                sizeof(char) * (strlen(pszTmp) + nTmp +3));\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n  }\n  /* -------------------------------------------------------------------- */\n  /*      NOT                                                             */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode &&\n           strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n    pszTmp = FLTGetSQLExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) +  9));\n    pszBuffer[0] = '\\0';\n\n    strcat(pszBuffer, \" (NOT \");\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n  } else\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Cleanup.                                                        */\n  /* -------------------------------------------------------------------- */\n  if( pszTmp != NULL )\n    free( pszTmp );\n  return pszBuffer;\n\n}\n\n/************************************************************************/\n/*                     FLTGetLogicalComparisonExpresssion               */\n/*                                                                      */\n/*      Return the expression for logical comparison expression.        */\n/************************************************************************/\nchar *FLTGetLogicalComparisonExpresssion(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszTmp = NULL;\n  char *pszBuffer = NULL;\n  int nTmp = 0;\n\n  if (!psFilterNode || !FLTIsLogicalFilterType(psFilterNode->pszValue))\n    return NULL;\n\n\n  /* ==================================================================== */\n  /*      special case for BBOX node.                                     */\n  /* ==================================================================== */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode &&\n      (strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") == 0 ||\n       strcasecmp(psFilterNode->psRightNode->pszValue, \"BBOX\") == 0 ||\n       FLTIsGeosNode(psFilterNode->psLeftNode->pszValue) ||\n       FLTIsGeosNode(psFilterNode->psRightNode->pszValue)))\n\n\n  {\n\n    /*strcat(szBuffer, \" (\");*/\n    if (strcasecmp(psFilterNode->psLeftNode->pszValue, \"BBOX\") != 0 &&\n        strcasecmp(psFilterNode->psLeftNode->pszValue, \"DWithin\") != 0 &&\n        FLTIsGeosNode(psFilterNode->psLeftNode->pszValue) == MS_FALSE)\n      pszTmp = FLTGetNodeExpression(psFilterNode->psLeftNode, lp);\n    else\n      pszTmp = FLTGetNodeExpression(psFilterNode->psRightNode, lp);\n\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) * (strlen(pszTmp) + 3));\n    pszBuffer[0] = '\\0';\n    /*\n    if (strcasecmp(psFilterNode->psLeftNode->pszValue, \"PropertyIsLike\") == 0 ||\n        strcasecmp(psFilterNode->psRightNode->pszValue, \"PropertyIsLike\") == 0)\n      sprintf(pszBuffer, \"%s\", pszTmp);\n    else\n    */\n    sprintf(pszBuffer, \"(%s)\", pszTmp);\n\n    free(pszTmp);\n\n    return pszBuffer;\n  }\n\n\n  /* -------------------------------------------------------------------- */\n  /*      OR and AND                                                      */\n  /* -------------------------------------------------------------------- */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n    pszTmp = FLTGetNodeExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) *\n                               (strlen(pszTmp) + strlen(psFilterNode->pszValue) + 5));\n    pszBuffer[0] = '\\0';\n    strcat(pszBuffer, \" (\");\n\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \" \");\n    strcat(pszBuffer, psFilterNode->pszValue);\n    strcat(pszBuffer, \" \");\n    free(pszTmp);\n\n    pszTmp = FLTGetNodeExpression(psFilterNode->psRightNode, lp);\n    if (!pszTmp) {\n      msFree(pszBuffer);\n      return NULL;\n    }\n\n    nTmp = strlen(pszBuffer);\n    pszBuffer = (char *)realloc(pszBuffer,\n                                sizeof(char) * (strlen(pszTmp) + nTmp +3));\n\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n    free(pszTmp);\n  }\n  /* -------------------------------------------------------------------- */\n  /*      NOT                                                             */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode &&\n           strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n    pszTmp = FLTGetNodeExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszBuffer = (char *)malloc(sizeof(char) *\n                               (strlen(pszTmp) +  9));\n    pszBuffer[0] = '\\0';\n    strcat(pszBuffer, \" (NOT \");\n    strcat(pszBuffer, pszTmp);\n    strcat(pszBuffer, \") \");\n\n    free(pszTmp);\n  } else\n    return NULL;\n\n  return pszBuffer;\n\n}\n\n\n\n/************************************************************************/\n/*                      FLTGetBinaryComparisonExpresssion               */\n/*                                                                      */\n/*      Return the expression for a binary comparison filter node.      */\n/************************************************************************/\nchar *FLTGetBinaryComparisonExpresssion(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  int bString=0;\n  char szTmp[256];\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode || !FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (psFilterNode->psRightNode->pszValue) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n    else if (FLTIsNumeric(psFilterNode->psRightNode->pszValue) == MS_FALSE)\n      bString = 1;\n  }\n\n  /* specical case to be able to have empty strings in the expression. */\n  if (psFilterNode->psRightNode->pszValue == NULL)\n    bString = 1;\n\n\n  if (bString)\n    strlcat(szBuffer, \" (\\\"[\", bufferSize);\n  else\n    strlcat(szBuffer, \" ([\", bufferSize);\n  /* attribute */\n\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  if (bString)\n    strlcat(szBuffer, \"]\\\" \", bufferSize);\n  else\n    strlcat(szBuffer, \"] \", bufferSize);\n\n\n  /* logical operator */\n  if (strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0) {\n    /*case insensitive set ? */\n    if (psFilterNode->psRightNode->pOther &&\n        (*(int *)psFilterNode->psRightNode->pOther) == 1) {\n      strlcat(szBuffer, \"IEQ\", bufferSize);\n    } else\n      strlcat(szBuffer, \"=\", bufferSize);\n  } else if (strcasecmp(psFilterNode->pszValue,\n                        \"PropertyIsNotEqualTo\") == 0)\n    strlcat(szBuffer, \"!=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThan\") == 0)\n    strlcat(szBuffer, \"<\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThan\") == 0)\n    strlcat(szBuffer, \">\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \"<=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \">=\", bufferSize);\n\n  strlcat(szBuffer, \" \", bufferSize);\n\n  /* value */\n  if (bString)\n    strlcat(szBuffer, \"\\\"\", bufferSize);\n\n  if (psFilterNode->psRightNode->pszValue)\n    strlcat(szBuffer, psFilterNode->psRightNode->pszValue, bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \"\\\"\", bufferSize);\n\n  strlcat(szBuffer, \") \", bufferSize);\n\n  return msStrdup(szBuffer);\n}\n\n\n\n\n/************************************************************************/\n/*                      FLTGetBinaryComparisonSQLExpresssion            */\n/*                                                                      */\n/*      Return the expression for a binary comparison filter node.      */\n/************************************************************************/\nchar *FLTGetBinaryComparisonSQLExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  int bString=0;\n  char szTmp[256];\n  char* pszEscapedStr = NULL;\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode || !\n      FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (psFilterNode->psRightNode->pszValue) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n\n    else if (FLTIsNumeric(psFilterNode->psRightNode->pszValue) == MS_FALSE)\n      bString = 1;\n  }\n\n  /* specical case to be able to have empty strings in the expression. */\n  if (psFilterNode->psRightNode->pszValue == NULL)\n    bString = 1;\n\n\n  /*opening bracket*/\n  strlcat(szBuffer, \" (\", bufferSize);\n\n  pszEscapedStr = msLayerEscapePropertyName(lp, psFilterNode->psLeftNode->pszValue);\n\n\n  /* attribute */\n  /*case insensitive set ? */\n  if (bString &&\n      strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0 &&\n      psFilterNode->psRightNode->pOther &&\n      (*(int *)psFilterNode->psRightNode->pOther) == 1) {\n    snprintf(szTmp, sizeof(szTmp), \"lower(%s) \",  pszEscapedStr);\n    strlcat(szBuffer, szTmp, bufferSize);\n  } else\n    strlcat(szBuffer, pszEscapedStr, bufferSize);\n\n  msFree(pszEscapedStr);\n  pszEscapedStr = NULL;\n\n\n  /* logical operator */\n  if (strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0)\n    strlcat(szBuffer, \"=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsNotEqualTo\") == 0)\n    strlcat(szBuffer, \"<>\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThan\") == 0)\n    strlcat(szBuffer, \"<\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThan\") == 0)\n    strlcat(szBuffer, \">\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsLessThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \"<=\", bufferSize);\n  else if (strcasecmp(psFilterNode->pszValue,\n                      \"PropertyIsGreaterThanOrEqualTo\") == 0)\n    strlcat(szBuffer, \">=\", bufferSize);\n\n  strlcat(szBuffer, \" \", bufferSize);\n\n  /* value */\n\n  if (bString &&\n      psFilterNode->psRightNode->pszValue &&\n      strcasecmp(psFilterNode->pszValue,\n                 \"PropertyIsEqualTo\") == 0 &&\n      psFilterNode->psRightNode->pOther &&\n      (*(int *)psFilterNode->psRightNode->pOther) == 1) {\n    char* pszEscapedStr;\n    pszEscapedStr = msLayerEscapeSQLParam(lp, psFilterNode->psRightNode->pszValue);\n    snprintf(szTmp, sizeof(szTmp), \"lower('%s') \", pszEscapedStr);\n    msFree(pszEscapedStr);\n    strlcat(szBuffer, szTmp, bufferSize);\n  } else {\n    if (bString)\n      strlcat(szBuffer, \"'\", bufferSize);\n\n    if (psFilterNode->psRightNode->pszValue) {\n      if (bString) {\n        char* pszEscapedStr;\n        pszEscapedStr = msLayerEscapeSQLParam(lp, psFilterNode->psRightNode->pszValue);\n        strlcat(szBuffer, pszEscapedStr, bufferSize);\n        msFree(pszEscapedStr);\n        pszEscapedStr=NULL;\n      } else\n        strlcat(szBuffer, psFilterNode->psRightNode->pszValue, bufferSize);\n    }\n\n    if (bString)\n      strlcat(szBuffer, \"'\", bufferSize);\n\n  }\n  /*closing bracket*/\n  strlcat(szBuffer, \") \", bufferSize);\n\n  return msStrdup(szBuffer);\n}\n\n\n/************************************************************************/\n/*                    FLTGetIsBetweenComparisonSQLExpresssion           */\n/*                                                                      */\n/*      Build an SQL expresssion for IsBteween Filter.                  */\n/************************************************************************/\nchar *FLTGetIsBetweenComparisonSQLExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char **aszBounds = NULL;\n  int nBounds = 0;\n  int bString=0;\n  char szTmp[256];\n  char* pszEscapedStr;\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode ||\n      !(strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0))\n    return NULL;\n\n  if (!psFilterNode->psLeftNode || !psFilterNode->psRightNode )\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Get the bounds value which are stored like boundmin;boundmax    */\n  /* -------------------------------------------------------------------- */\n  aszBounds = msStringSplit(psFilterNode->psRightNode->pszValue, ';', &nBounds);\n  if (nBounds != 2) {\n    msFreeCharArray(aszBounds, nBounds);\n    return NULL;\n  }\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (aszBounds[0]) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n    else if (FLTIsNumeric(aszBounds[0]) == MS_FALSE)\n      bString = 1;\n  }\n  if (!bString) {\n    if (aszBounds[1]) {\n      if (FLTIsNumeric(aszBounds[1]) == MS_FALSE)\n        bString = 1;\n    }\n  }\n\n\n  /* -------------------------------------------------------------------- */\n  /*      build expresssion.                                              */\n  /* -------------------------------------------------------------------- */\n  /*opening paranthesis */\n  strlcat(szBuffer, \" (\", bufferSize);\n\n  /* attribute */\n  pszEscapedStr = msLayerEscapePropertyName(lp, psFilterNode->psLeftNode->pszValue);\n\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr = NULL;\n\n  /*between*/\n  strlcat(szBuffer, \" BETWEEN \", bufferSize);\n\n  /*bound 1*/\n  if (bString)\n    strlcat(szBuffer,\"'\", bufferSize);\n  pszEscapedStr = msLayerEscapeSQLParam( lp, aszBounds[0]);\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr=NULL;\n\n  if (bString)\n    strlcat(szBuffer,\"'\", bufferSize);\n\n  strlcat(szBuffer, \" AND \", bufferSize);\n\n  /*bound 2*/\n  if (bString)\n    strlcat(szBuffer, \"'\", bufferSize);\n  pszEscapedStr = msLayerEscapeSQLParam( lp, aszBounds[1]);\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr=NULL;\n\n  if (bString)\n    strlcat(szBuffer,\"'\", bufferSize);\n\n  /*closing paranthesis*/\n  strlcat(szBuffer, \")\", bufferSize);\n\n  msFreeCharArray(aszBounds, nBounds);\n\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                    FLTGetIsBetweenComparisonExpresssion              */\n/*                                                                      */\n/*      Build expresssion for IsBteween Filter.                         */\n/************************************************************************/\nchar *FLTGetIsBetweenComparisonExpresssion(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char **aszBounds = NULL;\n  int nBounds = 0;\n  int bString=0;\n  char szTmp[256];\n\n\n  szBuffer[0] = '\\0';\n  if (!psFilterNode ||\n      !(strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0))\n    return NULL;\n\n  if (!psFilterNode->psLeftNode || !psFilterNode->psRightNode )\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Get the bounds value which are stored like boundmin;boundmax    */\n  /* -------------------------------------------------------------------- */\n  aszBounds = msStringSplit(psFilterNode->psRightNode->pszValue, ';', &nBounds);\n  if (nBounds != 2) {\n    msFreeCharArray(aszBounds, nBounds);\n    return NULL;\n  }\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (aszBounds[0]) {\n    const char* pszOFGType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszOFGType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszOFGType!= NULL && strcasecmp(pszOFGType, \"Character\") == 0)\n      bString = 1;\n    else if (FLTIsNumeric(aszBounds[0]) == MS_FALSE)\n      bString = 1;\n  }\n  if (!bString) {\n    if (aszBounds[1]) {\n      if (FLTIsNumeric(aszBounds[1]) == MS_FALSE)\n        bString = 1;\n    }\n  }\n\n\n  /* -------------------------------------------------------------------- */\n  /*      build expresssion.                                              */\n  /* -------------------------------------------------------------------- */\n  if (bString)\n    strlcat(szBuffer, \" (\\\"[\", bufferSize);\n  else\n    strlcat(szBuffer, \" ([\", bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \"]\\\" \", bufferSize);\n  else\n    strlcat(szBuffer, \"] \", bufferSize);\n\n\n  strlcat(szBuffer, \" >= \", bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n  strlcat(szBuffer, aszBounds[0], bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n\n  strlcat(szBuffer, \" AND \", bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \" \\\"[\", bufferSize);\n  else\n    strlcat(szBuffer, \" [\", bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n\n  if (bString)\n    strlcat(szBuffer, \"]\\\" \", bufferSize);\n  else\n    strlcat(szBuffer, \"] \", bufferSize);\n\n  strlcat(szBuffer, \" <= \", bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n  strlcat(szBuffer, aszBounds[1], bufferSize);\n  if (bString)\n    strlcat(szBuffer,\"\\\"\", bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n\n  msFreeCharArray(aszBounds, nBounds);\n\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                      FLTGetIsLikeComparisonExpression               */\n/*                                                                      */\n/*      Build expression for IsLike filter.                             */\n/************************************************************************/\nchar *FLTGetIsLikeComparisonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n\n  int nLength=0, i=0, iTmp=0;\n  FEPropertyIsLike* propIsLike;\n\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode ||\n      !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 ||\n      !pszSingle || strlen(pszSingle) == 0 ||\n      !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \" (\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /*#3521 */\n  if(bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* /\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" =~ /\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n  if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )\n      return NULL;\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] &&\n      pszValue[0] != pszSingle[0] &&\n      pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] &&\n        pszValue[i] != pszSingle[0] &&\n        pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if  (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if  (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n\n    } else if (pszValue[i] == pszWild[0]) {\n      /* strcat(szBuffer, \"[0-9,a-z,A-Z,\\\\s]*\"); */\n      /* iBuffer+=17; */\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '/';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                      FLTGetIsLikeComparisonSQLExpression             */\n/*                                                                      */\n/*      Build an sql expression for IsLike filter.                      */\n/************************************************************************/\nchar *FLTGetIsLikeComparisonSQLExpression(FilterEncodingNode *psFilterNode,\n    layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  char szTmp[4];\n\n  int nLength=0, i=0, j=0;\n  int  bCaseInsensitive = 0;\n\n  char *pszEscapedStr = NULL;\n  FEPropertyIsLike* propIsLike;\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode ||\n      !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 ||\n      !pszSingle || strlen(pszSingle) == 0 ||\n      !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  if (pszEscape[0] == '\\'') {\n    /* This might be valid, but the risk of SQL injection is too high */\n    /* and the below code is not ready for that */\n    /* Someone who does this has clearly suspect intentions ! */\n    msSetError(MS_MISCERR, \"Single quote character is not allowed as an escaping character.\",\n               \"FLTGetIsLikeComparisonSQLExpression()\");\n    return NULL;\n  }\n\n\n  szBuffer[0] = '\\0';\n  /*opening bracket*/\n  strlcat(szBuffer, \" (\", bufferSize);\n\n  /* attribute name */\n  pszEscapedStr = msLayerEscapePropertyName(lp, psFilterNode->psLeftNode->pszValue);\n\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n  pszEscapedStr = NULL;\n\n  if (lp->connectiontype == MS_POSTGIS) {\n    if (bCaseInsensitive == 1)\n      strlcat(szBuffer, \"::text ilike '\", bufferSize);\n    else\n      strlcat(szBuffer, \"::text like '\", bufferSize);\n  } else\n    strlcat(szBuffer, \" like '\", bufferSize);\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n\n  pszEscapedStr = (char*) msSmallMalloc( 3 * nLength + 1);\n\n  for (i=0, j=0; i<nLength; i++) {\n    char c = pszValue[i];\n    if (c != pszWild[0] &&\n        c != pszSingle[0] &&\n        c != pszEscape[0]) {\n      if (c == '\\'') {\n        pszEscapedStr[j++] = '\\'';\n        pszEscapedStr[j++] = '\\'';\n      } else if (c == '\\\\') {\n        pszEscapedStr[j++] = '\\\\';\n        pszEscapedStr[j++] = '\\\\';\n      } else\n        pszEscapedStr[j++] = c;\n    } else if  (c == pszSingle[0]) {\n      pszEscapedStr[j++] = '_';\n    } else if  (c == pszEscape[0]) {\n      pszEscapedStr[j++] = pszEscape[0];\n      if (i+1<nLength) {\n        char nextC = pszValue[i+1];\n        i++;\n        if (nextC == '\\'') {\n          pszEscapedStr[j++] = '\\'';\n          pszEscapedStr[j++] = '\\'';\n        } else\n          pszEscapedStr[j++] = nextC;\n      }\n    } else if (c == pszWild[0]) {\n      pszEscapedStr[j++] = '%';\n    }\n  }\n  pszEscapedStr[j++] = 0;\n  strlcat(szBuffer, pszEscapedStr, bufferSize);\n  msFree(pszEscapedStr);\n\n  strlcat(szBuffer, \"'\", bufferSize);\n  if (lp->connectiontype != MS_OGR) {\n    if (lp->connectiontype == MS_POSTGIS && pszEscape[0] == '\\\\')\n        strlcat(szBuffer, \" escape E'\", bufferSize);\n    else\n        strlcat(szBuffer, \" escape '\", bufferSize);\n    szTmp[0] = pszEscape[0];\n    if (pszEscape[0] == '\\\\') {\n      szTmp[1] = '\\\\';\n      szTmp[2] = '\\'';\n      szTmp[3] = '\\0';\n    } else {\n      szTmp[1] = '\\'';\n      szTmp[2] = '\\0';\n    }\n\n    strlcat(szBuffer,  szTmp, bufferSize);\n  }\n  strlcat(szBuffer,  \") \", bufferSize);\n\n  return msStrdup(szBuffer);\n}\n\n/************************************************************************/\n/*                           FLTHasSpatialFilter                        */\n/*                                                                      */\n/*      Utility function to see if a spatial filter is included in      */\n/*      the node.                                                       */\n/************************************************************************/\nint FLTHasSpatialFilter(FilterEncodingNode *psNode)\n{\n  int bResult = MS_FALSE;\n\n  if (!psNode)\n    return MS_FALSE;\n\n  if (psNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    if (psNode->psLeftNode)\n      bResult = FLTHasSpatialFilter(psNode->psLeftNode);\n\n    if (bResult)\n      return MS_TRUE;\n\n    if (psNode->psRightNode)\n      bResult = FLTHasSpatialFilter(psNode->psRightNode);\n\n    if (bResult)\n      return MS_TRUE;\n  } else if (FLTIsBBoxFilter(psNode) || FLTIsPointFilter(psNode) ||\n             FLTIsLineFilter(psNode) || FLTIsPolygonFilter(psNode))\n    return MS_TRUE;\n\n\n  return MS_FALSE;\n}\n\n\n/************************************************************************/\n/*                     FLTCreateFeatureIdFilterEncoding                 */\n/*                                                                      */\n/*      Utility function to create a filter node of FeatureId type.     */\n/************************************************************************/\nFilterEncodingNode *FLTCreateFeatureIdFilterEncoding(const char *pszString)\n{\n  FilterEncodingNode *psFilterNode = NULL;\n\n  if (pszString) {\n    psFilterNode = FLTCreateFilterEncodingNode();\n    psFilterNode->eType = FILTER_NODE_TYPE_FEATUREID;\n    psFilterNode->pszValue =  msStrdup(pszString);\n    return psFilterNode;\n  }\n  return NULL;\n}\n\n\n/************************************************************************/\n/*                              FLTParseGMLBox                          */\n/*                                                                      */\n/*      Parse gml box. Used for FE 1.0                                  */\n/************************************************************************/\nint FLTParseGMLBox(CPLXMLNode *psBox, rectObj *psBbox, char **ppszSRS)\n{\n  int bCoordinatesValid = 0;\n  CPLXMLNode *psCoordinates = NULL;\n  CPLXMLNode *psCoord1 = NULL, *psCoord2 = NULL;\n  char **papszCoords=NULL, **papszMin=NULL, **papszMax = NULL;\n  int nCoords = 0, nCoordsMin = 0, nCoordsMax = 0;\n  const char *pszTmpCoord = NULL;\n  const char *pszSRS = NULL;\n  const char *pszTS = NULL;\n  const char *pszCS = NULL;\n  double minx = 0.0, miny = 0.0, maxx = 0.0, maxy = 0.0;\n\n  if (psBox) {\n    pszSRS = CPLGetXMLValue(psBox, \"srsName\", NULL);\n    if (ppszSRS && pszSRS)\n      *ppszSRS = msStrdup(pszSRS);\n\n    psCoordinates = CPLGetXMLNode(psBox, \"coordinates\");\n    pszTS = CPLGetXMLValue(psCoordinates, \"ts\", NULL);\n    if( pszTS == NULL )\n        pszTS = \" \";\n    pszCS = CPLGetXMLValue(psCoordinates, \"cs\", NULL);\n    if( pszCS == NULL )\n        pszCS = \",\";\n    pszTmpCoord = CPLGetXMLValue(psCoordinates, NULL, NULL);\n\n    if (pszTmpCoord) {\n      papszCoords = msStringSplit(pszTmpCoord, pszTS[0], &nCoords);\n      if (papszCoords && nCoords == 2) {\n        papszMin = msStringSplit(papszCoords[0], pszCS[0], &nCoordsMin);\n        if (papszMin && nCoordsMin == 2) {\n          papszMax = msStringSplit(papszCoords[1], pszCS[0], &nCoordsMax);\n        }\n        if (papszMax && nCoordsMax == 2) {\n          bCoordinatesValid =1;\n          minx =  atof(papszMin[0]);\n          miny =  atof(papszMin[1]);\n          maxx =  atof(papszMax[0]);\n          maxy =  atof(papszMax[1]);\n        }\n\n        msFreeCharArray(papszMin, nCoordsMin);\n        msFreeCharArray(papszMax, nCoordsMax);\n      }\n\n      msFreeCharArray(papszCoords, nCoords);\n    } else {\n      psCoord1 = CPLGetXMLNode(psBox, \"coord\");\n      psCoord2 = FLTGetNextSibblingNode(psCoord1);\n      if (psCoord1 && psCoord2 && strcmp(psCoord2->pszValue, \"coord\") == 0) {\n        const char* pszX = CPLGetXMLValue(psCoord1, \"X\", NULL);\n        const char* pszY = CPLGetXMLValue(psCoord1, \"Y\", NULL);\n        if (pszX && pszY) {\n          minx = atof(pszX);\n          miny = atof(pszY);\n\n          pszX = CPLGetXMLValue(psCoord2, \"X\", NULL);\n          pszY = CPLGetXMLValue(psCoord2, \"Y\", NULL);\n          if (pszX && pszY) {\n            maxx = atof(pszX);\n            maxy = atof(pszY);\n            bCoordinatesValid = 1;\n          }\n        }\n      }\n\n    }\n  }\n\n  if (bCoordinatesValid) {\n    psBbox->minx =  minx;\n    psBbox->miny =  miny;\n\n    psBbox->maxx =  maxx;\n    psBbox->maxy =  maxy;\n  }\n\n  return bCoordinatesValid;\n}\n/************************************************************************/\n/*                           FLTParseGMLEnvelope                        */\n/*                                                                      */\n/*      Utility function to parse a gml:Envelope (used for SOS and FE1.1)*/\n/************************************************************************/\nint FLTParseGMLEnvelope(CPLXMLNode *psRoot, rectObj *psBbox, char **ppszSRS)\n{\n  CPLXMLNode *psUpperCorner=NULL, *psLowerCorner=NULL;\n  const char *pszLowerCorner=NULL, *pszUpperCorner=NULL;\n  int bValid = 0;\n  char **tokens;\n  int n;\n\n  if (psRoot && psBbox && psRoot->eType == CXT_Element &&\n      EQUAL(psRoot->pszValue,\"Envelope\")) {\n    /*Get the srs if available*/\n    if (ppszSRS) {\n      const char* pszSRS = CPLGetXMLValue(psRoot, \"srsName\", NULL);\n      if( pszSRS != NULL )\n          *ppszSRS = msStrdup(pszSRS);\n    }\n    psLowerCorner = CPLSearchXMLNode(psRoot, \"lowerCorner\");\n    psUpperCorner = CPLSearchXMLNode(psRoot, \"upperCorner\");\n\n    if (psLowerCorner && psUpperCorner) {\n      pszLowerCorner = CPLGetXMLValue(psLowerCorner, NULL, NULL);\n      pszUpperCorner = CPLGetXMLValue(psUpperCorner, NULL, NULL);\n\n      if (pszLowerCorner && pszUpperCorner) {\n        tokens = msStringSplit(pszLowerCorner, ' ', &n);\n        if (tokens && n >= 2) {\n          psBbox->minx = atof(tokens[0]);\n          psBbox->miny = atof(tokens[1]);\n\n          msFreeCharArray(tokens, n);\n\n          tokens = msStringSplit(pszUpperCorner, ' ', &n);\n          if (tokens && n >= 2) {\n            psBbox->maxx = atof(tokens[0]);\n            psBbox->maxy = atof(tokens[1]);\n            bValid = 1;\n          }\n        }\n        msFreeCharArray(tokens, n);\n      }\n    }\n  }\n\n  return bValid;\n}\n\n/************************************************************************/\n/*                        FLTNeedSRSSwapping                            */\n/************************************************************************/\n\nstatic int FLTNeedSRSSwapping( const char* pszSRS )\n{\n    int bNeedSwapping = MS_FALSE;\n    projectionObj sProjTmp;\n    msInitProjection(&sProjTmp);\n    if (msLoadProjectionStringEPSG(&sProjTmp, pszSRS) == 0) {\n        bNeedSwapping = msIsAxisInvertedProj(&sProjTmp);\n    }\n    msFreeProjection(&sProjTmp);\n    return bNeedSwapping;\n}\n\n/************************************************************************/\n/*                      FLTDoAxisSwappingIfNecessary                    */\n/*                                                                      */\n/*      Explore all geometries and BBOX to do axis swapping when the    */\n/*      SRS requires it. If no explicit SRS is attached to the geometry */\n/*      the bDefaultSRSNeedsAxisSwapping is taken into account. The     */\n/*      caller will have to determine its value from a more general     */\n/*      context.                                                        */\n/************************************************************************/\nvoid FLTDoAxisSwappingIfNecessary(FilterEncodingNode *psFilterNode,\n                                  int bDefaultSRSNeedsAxisSwapping)\n{\n    if( psFilterNode == NULL )\n        return;\n\n    if( psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n        psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_BBOX )\n    {\n        rectObj* rect = (rectObj *)psFilterNode->psRightNode->pOther;\n        const char* pszSRS = psFilterNode->pszSRS;\n        if( (pszSRS != NULL && FLTNeedSRSSwapping(pszSRS)) ||\n            (pszSRS == NULL && bDefaultSRSNeedsAxisSwapping) )\n        {\n            double tmp;\n\n            tmp = rect->minx;\n            rect->minx = rect->miny;\n            rect->miny = tmp;\n\n            tmp = rect->maxx;\n            rect->maxx = rect->maxy;\n            rect->maxy = tmp;\n        }\n    }\n    else if( psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n             FLTIsGeometryFilterNodeType(psFilterNode->psRightNode->eType) )\n    {\n        shapeObj* shape = (shapeObj *)(psFilterNode->psRightNode->pOther);\n        const char* pszSRS = psFilterNode->pszSRS;\n        if( (pszSRS != NULL && FLTNeedSRSSwapping(pszSRS)) ||\n            (pszSRS == NULL && bDefaultSRSNeedsAxisSwapping) )\n        {\n            msAxisSwapShape(shape);\n        }\n    }\n    else\n    {\n        FLTDoAxisSwappingIfNecessary(psFilterNode->psLeftNode, bDefaultSRSNeedsAxisSwapping);\n        FLTDoAxisSwappingIfNecessary(psFilterNode->psRightNode, bDefaultSRSNeedsAxisSwapping);\n    }\n}\n\n\nstatic void FLTReplacePropertyName(FilterEncodingNode *psFilterNode,\n                                   const char *pszOldName,\n                                   const char *pszNewName)\n{\n  if (psFilterNode && pszOldName && pszNewName) {\n    if (psFilterNode->eType == FILTER_NODE_TYPE_PROPERTYNAME) {\n      if (psFilterNode->pszValue &&\n          strcasecmp(psFilterNode->pszValue, pszOldName) == 0) {\n        msFree(psFilterNode->pszValue);\n        psFilterNode->pszValue = msStrdup(pszNewName);\n      }\n    }\n    if (psFilterNode->psLeftNode)\n      FLTReplacePropertyName(psFilterNode->psLeftNode, pszOldName,\n                             pszNewName);\n    if (psFilterNode->psRightNode)\n      FLTReplacePropertyName(psFilterNode->psRightNode, pszOldName,\n                             pszNewName);\n  }\n}\n\n\nstatic int FLTIsGMLDefaultProperty(const char* pszName)\n{\n    return (strcmp(pszName, \"gml:name\") == 0 ||\n            strcmp(pszName, \"gml:description\") == 0 ||\n            strcmp(pszName, \"gml:descriptionReference\") == 0 ||\n            strcmp(pszName, \"gml:identifier\") == 0 ||\n            strcmp(pszName, \"gml:boundedBy\") == 0 ||\n            strcmp(pszName, \"@gml:id\") == 0);\n}\n\nstatic void FLTStripNameSpacesFromPropertyName(FilterEncodingNode *psFilterNode)\n{\n  char **tokens=NULL;\n  int n=0;\n\n  if (psFilterNode) {\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME &&\n        FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) )\n    {\n        return;\n    }\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_PROPERTYNAME) {\n      if (psFilterNode->pszValue &&\n          strstr(psFilterNode->pszValue, \":\")) {\n        tokens = msStringSplit(psFilterNode->pszValue, ':', &n);\n        if (tokens && n==2) {\n          msFree(psFilterNode->pszValue);\n          psFilterNode->pszValue = msStrdup(tokens[1]);\n        }\n        msFreeCharArray(tokens, n);\n      }\n    }\n    if (psFilterNode->psLeftNode)\n      FLTStripNameSpacesFromPropertyName(psFilterNode->psLeftNode);\n    if (psFilterNode->psRightNode)\n      FLTStripNameSpacesFromPropertyName(psFilterNode->psRightNode);\n  }\n\n}\n\nstatic void FLTRemoveGroupName(FilterEncodingNode *psFilterNode,\n                               gmlGroupListObj* groupList)\n{\n  int i;\n\n  if (psFilterNode) {\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_PROPERTYNAME) {\n      if( psFilterNode->pszValue != NULL )\n      {\n        const char* pszPropertyName = psFilterNode->pszValue;\n        const char* pszSlash = strchr(pszPropertyName, '/');\n        if( pszSlash != NULL ) {\n          const char* pszColon = strchr(pszPropertyName, ':');\n          if( pszColon != NULL && pszColon < pszSlash )\n              pszPropertyName = pszColon + 1;\n          for(i=0;i<groupList->numgroups;i++) {\n            const char* pszGroupName = groupList->groups[i].name;\n            size_t nGroupNameLen = strlen(pszGroupName);\n            if(strncasecmp(pszPropertyName, pszGroupName, nGroupNameLen) == 0 &&\n                            pszPropertyName[nGroupNameLen] == '/') {\n              char* pszTmp;\n              pszPropertyName = pszPropertyName + nGroupNameLen + 1;\n              pszColon = strchr(pszPropertyName, ':');\n              if( pszColon != NULL )\n                pszPropertyName = pszColon + 1;\n              pszTmp = msStrdup(pszPropertyName);\n              msFree(psFilterNode->pszValue);\n              psFilterNode->pszValue = pszTmp;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (psFilterNode->psLeftNode)\n      FLTRemoveGroupName(psFilterNode->psLeftNode, groupList);\n    if (psFilterNode->psRightNode)\n      FLTRemoveGroupName(psFilterNode->psRightNode, groupList);\n  }\n\n}\n\n/************************************************************************/\n/*                    FLTPreParseFilterForAliasAndGroup                 */\n/*                                                                      */\n/*      Utility function to replace aliased' and grouped attributes     */\n/*      with their internal name.                                       */\n/************************************************************************/\nvoid FLTPreParseFilterForAliasAndGroup(FilterEncodingNode *psFilterNode,\n                               mapObj *map, int i, const char *namespaces)\n{\n  layerObj *lp=NULL;\n  char szTmp[256];\n  const char *pszFullName = NULL;\n  int layerWasOpened =  MS_FALSE;\n\n#if defined(USE_WMS_SVR) || defined (USE_WFS_SVR) || defined (USE_WCS_SVR) || defined(USE_SOS_SVR)\n\n  if (psFilterNode && map && i>=0 && i<map->numlayers) {\n    /*strip name spaces before hand*/\n    FLTStripNameSpacesFromPropertyName(psFilterNode);\n\n    lp = GET_LAYER(map, i);\n    layerWasOpened = msLayerIsOpen(lp);\n    if (msLayerOpen(lp) == MS_SUCCESS && msLayerGetItems(lp) == MS_SUCCESS) {\n\n      /* Remove group names from property names if using groupname/itemname syntax */\n      gmlGroupListObj* groupList = msGMLGetGroups(lp, namespaces);\n      if( groupList && groupList->numgroups > 0 )\n        FLTRemoveGroupName(psFilterNode, groupList);\n      msGMLFreeGroups(groupList);\n\n      for(i=0; i<lp->numitems; i++) {\n        if (!lp->items[i] || strlen(lp->items[i]) <= 0)\n          continue;\n        snprintf(szTmp, sizeof(szTmp), \"%s_alias\", lp->items[i]);\n        pszFullName = msOWSLookupMetadata(&(lp->metadata), namespaces, szTmp);\n        if (pszFullName) {\n          FLTReplacePropertyName(psFilterNode, pszFullName,\n                                 lp->items[i]);\n        }\n      }\n      if (!layerWasOpened) /* do not close the layer if it has been opened somewhere else (paging?) */\n        msLayerClose(lp);\n    }\n  }\n#else\n  msSetError(MS_MISCERR, \"OWS support is not available.\",\n             \"FLTPreParseFilterForAlias()\");\n\n#endif\n}\n\n/************************************************************************/\n/*                        FLTCheckFeatureIdFilters                      */\n/*                                                                      */\n/*      Check that FeatureId filters match features in the active       */\n/*      layer.                                                          */\n/************************************************************************/\nint FLTCheckFeatureIdFilters(FilterEncodingNode *psFilterNode,\n                             mapObj *map, int i)\n{\n    int status = MS_SUCCESS;\n    \n    if (psFilterNode->eType ==  FILTER_NODE_TYPE_FEATUREID)\n    {\n        char** tokens;\n        int nTokens = 0;\n        layerObj* lp;\n        int j;\n\n        lp = GET_LAYER(map, i);\n        tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n        for (j=0; j<nTokens; j++) {\n            const char* pszId = tokens[j];\n            const char* pszDot = strchr(pszId, '.');\n            if( pszDot )\n            {\n                if( pszDot - pszId != strlen(lp->name) ||\n                    strncasecmp(pszId, lp->name, strlen(lp->name)) != 0 )\n                {\n                    msSetError(MS_MISCERR, \"Feature id %s not consistent with feature type name %s.\",\n                               \"FLTPreParseFilterForAlias()\", pszId, lp->name);\n                    status = MS_FAILURE;\n                    break;\n                }\n            }\n        }\n        msFreeCharArray(tokens, nTokens);\n    }\n\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTCheckFeatureIdFilters(psFilterNode->psLeftNode, map, i);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTCheckFeatureIdFilters(psFilterNode->psRightNode, map, i);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                        FLTCheckInvalidOperand                        */\n/*                                                                      */\n/*      Check that the operand of a comparison operator is valid        */\n/*      Currently only detects use of boundedBy in a binary comparison  */\n/************************************************************************/\nint FLTCheckInvalidOperand(FilterEncodingNode *psFilterNode)\n{\n    int status = MS_SUCCESS;\n\n    if (psFilterNode->eType ==  FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME)\n    {\n        if( strcmp(psFilterNode->psLeftNode->pszValue, \"gml:boundedBy\") == 0 &&\n            strcmp(psFilterNode->pszValue, \"PropertyIsNull\") != 0 &&\n            strcmp(psFilterNode->pszValue, \"PropertyIsNil\") != 0 )\n        {\n            msSetError(MS_MISCERR, \"Operand '%s' is invalid in comparison.\",\n                       \"FLTCheckInvalidOperand()\", psFilterNode->psLeftNode->pszValue);\n            return MS_FAILURE;\n        }\n    }\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTCheckInvalidOperand(psFilterNode->psLeftNode);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTCheckInvalidOperand(psFilterNode->psRightNode);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                       FLTProcessPropertyIsNull                       */\n/*                                                                      */\n/*      HACK for PropertyIsNull processing. PostGIS & Spatialite only   */\n/*      for now.                                                        */\n/************************************************************************/\nint FLTProcessPropertyIsNull(FilterEncodingNode *psFilterNode,\n                            mapObj *map, int i)\n{\n    int status = MS_SUCCESS;\n\n    if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME &&\n        strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 &&\n        !FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) )\n    {\n        layerObj* lp;\n        int layerWasOpened;\n\n        lp = GET_LAYER(map, i);\n        layerWasOpened = msLayerIsOpen(lp);\n\n        /* Horrible HACK to compensate for the lack of null testing in MapServer */\n        if( (lp->connectiontype == MS_POSTGIS ||\n             (lp->connectiontype == MS_OGR && msOGRIsSpatialite(lp))) &&\n            strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 )\n        {\n            msFree(psFilterNode->pszValue);\n            psFilterNode->pszValue = msStrdup(\"PropertyIsEqualTo\");\n            psFilterNode->psRightNode = FLTCreateBinaryCompFilterEncodingNode();\n            psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_LITERAL;\n            psFilterNode->psRightNode->pszValue = msStrdup(\"_MAPSERVER_NULL_\");\n        }\n\n        if (!layerWasOpened) /* do not close the layer if it has been opened somewhere else (paging?) */\n          msLayerClose(lp);\n    }\n\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTProcessPropertyIsNull(psFilterNode->psLeftNode, map, i);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTProcessPropertyIsNull(psFilterNode->psRightNode, map, i);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                        FLTCheckInvalidProperty                       */\n/*                                                                      */\n/*      Check that property names are known                             */\n/************************************************************************/\nint FLTCheckInvalidProperty(FilterEncodingNode *psFilterNode,\n                            mapObj *map, int i)\n{\n    int status = MS_SUCCESS;\n\n    if (psFilterNode->eType ==  FILTER_NODE_TYPE_COMPARISON &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME)\n    {\n        layerObj* lp;\n        int layerWasOpened;\n        int bFound = MS_FALSE;\n\n        if ((strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 ||\n             strcmp(psFilterNode->pszValue, \"PropertyIsNil\") == 0) && \n             FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) )\n        {\n            return MS_SUCCESS;\n        }\n\n        lp = GET_LAYER(map, i);\n        layerWasOpened = msLayerIsOpen(lp);\n        if ((layerWasOpened || msLayerOpen(lp) == MS_SUCCESS) \n             && msLayerGetItems(lp) == MS_SUCCESS) {\n          int i;\n          gmlItemListObj* items = msGMLGetItems(lp, \"G\");\n          for(i=0; i<items->numitems; i++) {\n            if (!items->items[i].name || strlen(items->items[i].name) <= 0 ||\n                !items->items[i].visible)\n              continue;\n            if (strcasecmp(items->items[i].name, psFilterNode->psLeftNode->pszValue) == 0) {\n                bFound = MS_TRUE;\n                break;\n            }\n          }\n          msGMLFreeItems(items);\n        }\n\n        if (!layerWasOpened) /* do not close the layer if it has been opened somewhere else (paging?) */\n          msLayerClose(lp);\n\n        if( !bFound )\n        {\n            msSetError(MS_MISCERR, \"Property '%s' is unknown.\",\n                       \"FLTCheckInvalidProperty()\", psFilterNode->psLeftNode->pszValue);\n            return MS_FAILURE;\n        }\n    }\n\n    if (psFilterNode->psLeftNode)\n    {\n      status = FLTCheckInvalidProperty(psFilterNode->psLeftNode, map, i);\n      if( status == MS_SUCCESS )\n      {\n        if (psFilterNode->psRightNode)\n            status = FLTCheckInvalidProperty(psFilterNode->psRightNode, map, i);\n      }\n    }\n    return status;\n}\n\n/************************************************************************/\n/*                           FLTSimplify                                */\n/*                                                                      */\n/*      Simplify the expression by removing parts that evaluate to      */\n/*      constants.                                                      */\n/*      The passed psFilterNode is potentially consumed by the function */\n/*      and replaced by the returned value.                             */\n/*      If the function returns NULL, *pnEvaluation = MS_FALSE means    */\n/*      that  the filter evaluates to FALSE, or MS_TRUE that it         */\n/*      evaluates to TRUE                                               */\n/************************************************************************/\nFilterEncodingNode* FLTSimplify(FilterEncodingNode *psFilterNode,\n                                int* pnEvaluation)\n{\n    *pnEvaluation = -1;\n\n    /* There are no nullable or nillable property in WFS currently */\n    /* except gml:name or gml:description that are null */\n    if( psFilterNode->eType ==  FILTER_NODE_TYPE_COMPARISON &&\n        (strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 ||\n         strcmp(psFilterNode->pszValue, \"PropertyIsNil\") == 0 ) &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psLeftNode->eType == FILTER_NODE_TYPE_PROPERTYNAME )\n    {\n        if( strcmp(psFilterNode->pszValue, \"PropertyIsNull\") == 0 &&\n            FLTIsGMLDefaultProperty(psFilterNode->psLeftNode->pszValue) &&\n            strcmp(psFilterNode->psLeftNode->pszValue, \"@gml:id\") != 0  &&\n            strcmp(psFilterNode->psLeftNode->pszValue, \"gml:boundedBy\") != 0)\n            *pnEvaluation = MS_TRUE;\n        else\n            *pnEvaluation = MS_FALSE;\n        FLTFreeFilterEncodingNode(psFilterNode);\n        return NULL;\n    }\n\n    if( psFilterNode->eType ==  FILTER_NODE_TYPE_LOGICAL &&\n        strcasecmp(psFilterNode->pszValue, \"NOT\") == 0 &&\n        psFilterNode->psLeftNode != NULL )\n    {\n        int nEvaluation;\n        psFilterNode->psLeftNode = FLTSimplify(psFilterNode->psLeftNode,\n                                               &nEvaluation);\n        if( psFilterNode->psLeftNode == NULL )\n        {\n            *pnEvaluation = 1 - nEvaluation;\n            FLTFreeFilterEncodingNode(psFilterNode);\n            return NULL;\n        }\n    }\n\n    if( psFilterNode->eType ==  FILTER_NODE_TYPE_LOGICAL &&\n        (strcasecmp(psFilterNode->pszValue, \"AND\") == 0 ||\n         strcasecmp(psFilterNode->pszValue, \"OR\") == 0) &&\n        psFilterNode->psLeftNode != NULL &&\n        psFilterNode->psRightNode != NULL )\n    {\n        FilterEncodingNode* psOtherNode;\n        int nEvaluation;\n        int nExpectedValForFastExit;\n        psFilterNode->psLeftNode = FLTSimplify(psFilterNode->psLeftNode,\n                                               &nEvaluation);\n\n        if( strcasecmp(psFilterNode->pszValue, \"AND\") == 0 )\n            nExpectedValForFastExit = MS_FALSE;\n        else\n            nExpectedValForFastExit = MS_TRUE;\n\n        if( psFilterNode->psLeftNode == NULL )\n        {\n            if( nEvaluation == nExpectedValForFastExit )\n            {\n                *pnEvaluation = nEvaluation;\n                FLTFreeFilterEncodingNode(psFilterNode);\n                return NULL;\n            }\n            psOtherNode = psFilterNode->psRightNode;\n            psFilterNode->psRightNode = NULL;\n            FLTFreeFilterEncodingNode(psFilterNode);\n            return FLTSimplify(psOtherNode, pnEvaluation);\n        }\n \n        psFilterNode->psRightNode = FLTSimplify(psFilterNode->psRightNode,\n                                                &nEvaluation);\n        if( psFilterNode->psRightNode == NULL )\n        {\n            if( nEvaluation == nExpectedValForFastExit )\n            {\n                *pnEvaluation = nEvaluation;\n                FLTFreeFilterEncodingNode(psFilterNode);\n                return NULL;\n            }\n            psOtherNode = psFilterNode->psLeftNode;\n            psFilterNode->psLeftNode = NULL;\n            FLTFreeFilterEncodingNode(psFilterNode);\n            return FLTSimplify(psOtherNode, pnEvaluation);\n        }\n    }\n\n    return psFilterNode;\n}\n\n\n#ifdef USE_LIBXML2\n\nxmlNodePtr FLTGetCapabilities(xmlNsPtr psNsParent, xmlNsPtr psNsOgc, int bTemporal)\n{\n  xmlNodePtr psRootNode = NULL, psNode = NULL, psSubNode = NULL, psSubSubNode = NULL;\n\n  psRootNode = xmlNewNode(psNsParent, BAD_CAST \"Filter_Capabilities\");\n\n  psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Spatial_Capabilities\", NULL);\n\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"GeometryOperands\", NULL);\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:Point\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:LineString\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:Polygon\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"GeometryOperand\", BAD_CAST \"gml:Envelope\");\n\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"SpatialOperators\", NULL);\n#ifdef USE_GEOS\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Equals\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Disjoint\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Touches\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Within\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Overlaps\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Crosses\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Intersects\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Contains\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"DWithin\");\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"Beyond\");\n#endif\n  psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"SpatialOperator\", NULL);\n  xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"BBOX\");\n\n  if (bTemporal) {\n    psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Temporal_Capabilities\", NULL);\n    psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"TemporalOperands\", NULL);\n    psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"TemporalOperand\", BAD_CAST \"gml:TimePeriod\");\n    psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"TemporalOperand\", BAD_CAST \"gml:TimeInstant\");\n\n    psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"TemporalOperators\", NULL);\n    psSubSubNode = xmlNewChild(psSubNode, psNsOgc, BAD_CAST \"TemporalOperator\", NULL);\n    xmlNewProp(psSubSubNode, BAD_CAST \"name\", BAD_CAST \"TM_Equals\");\n  }\n  psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Scalar_Capabilities\", NULL);\n  xmlNewChild(psNode, psNsOgc, BAD_CAST \"LogicalOperators\", NULL);\n  psNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperators\", NULL);\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"LessThan\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"GreaterThan\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"LessThanEqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"GreaterThanEqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"EqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"NotEqualTo\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"Like\");\n  psSubNode = xmlNewChild(psNode, psNsOgc, BAD_CAST \"ComparisonOperator\", BAD_CAST \"Between\");\n\n  psNode = xmlNewChild(psRootNode, psNsOgc, BAD_CAST \"Id_Capabilities\", NULL);\n  xmlNewChild(psNode, psNsOgc, BAD_CAST \"EID\", NULL);\n  xmlNewChild(psNode, psNsOgc, BAD_CAST \"FID\", NULL);\n  return psRootNode;\n}\n#endif\n#endif\n", "/**********************************************************************\n * $Id$\n *\n * Project:  MapServer\n * Purpose:  OGC Filter Encoding implementation\n * Author:   Y. Assefa, DM Solutions Group (assefa@dmsolutions.ca)\n *\n **********************************************************************\n * Copyright (c) 2003, Y. Assefa, DM Solutions Group Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies of this Software or works derived from this Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n ****************************************************************************/\n\n#ifdef USE_OGR\n#include \"cpl_minixml.h\"\n#endif\n\n#include \"mapogcfilter.h\"\n#include \"mapserver.h\"\n#include \"mapows.h\"\n#include \"mapowscommon.h\"\n\n#ifdef USE_OGR\n\nchar *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n  FEPropertyIsLike* propIsLike;\n\n  int nLength=0, i=0, iTmp=0;\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \"(\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /* #3521 */\n  if (bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* \\\"\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" ~ \\\"\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n  if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )\n      return NULL;\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] && pszValue[i] != pszSingle[0] && pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszWild[0]) {\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '\"';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}\n\nchar *FLTGetIsBetweenComparisonCommonExpresssion(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char **aszBounds = NULL;\n  int nBounds = 0;\n  int bString=0;\n  int bDateTime = 0;\n  char *pszExpression=NULL, *pszTmpEscaped;\n\n  if (!psFilterNode || !(strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0))\n    return NULL;\n\n  if (psFilterNode->psLeftNode == NULL || psFilterNode->psRightNode == NULL )\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Get the bounds value which are stored like boundmin;boundmax    */\n  /* -------------------------------------------------------------------- */\n  aszBounds = msStringSplit(psFilterNode->psRightNode->pszValue, ';', &nBounds);\n  if (nBounds != 2) {\n    msFreeCharArray(aszBounds, nBounds);\n    return NULL;\n  }\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  if (aszBounds[0]) {\n    const char* pszType;\n    snprintf(szBuffer,  bufferSize, \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szBuffer);\n    if (pszType != NULL && (strcasecmp(pszType, \"Character\") == 0))\n      bString = 1;\n    else if (pszType != NULL && (strcasecmp(pszType, \"Date\") == 0))\n      bDateTime = 1;\n    else if (FLTIsNumeric(aszBounds[0]) == MS_FALSE)\n      bString = 1;\n  }\n  if (!bString && !bDateTime) {\n    if (aszBounds[1]) {\n      if (FLTIsNumeric(aszBounds[1]) == MS_FALSE)\n        bString = 1;\n    }\n  }\n\n  /* -------------------------------------------------------------------- */\n  /*      build expresssion.                                              */\n  /* -------------------------------------------------------------------- */\n  /* attribute */\n  if (bString)\n    sprintf(szBuffer, \"%s\", \"(\\\"[\");\n  else\n    sprintf(szBuffer, \"%s\", \"([\");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n  \n  pszExpression = msStringConcatenate(pszExpression, psFilterNode->psLeftNode->pszValue);\n\n  if (bString)\n    sprintf(szBuffer, \"%s\", \"]\\\" \");\n  else\n    sprintf(szBuffer, \"%s\", \"] \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  sprintf(szBuffer, \"%s\", \" >= \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n\n  pszTmpEscaped = msStringEscape(aszBounds[0]);\n  snprintf(szBuffer, bufferSize, \"%s\", pszTmpEscaped);\n  if(pszTmpEscaped != aszBounds[0] ) msFree(pszTmpEscaped);\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n\n  sprintf(szBuffer, \"%s\", \" AND \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  if (bString)\n    sprintf(szBuffer, \"%s\", \" \\\"[\");\n  else\n    sprintf(szBuffer, \"%s\", \" [\");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  /* attribute */\n  pszExpression = msStringConcatenate(pszExpression, psFilterNode->psLeftNode->pszValue);\n\n  if (bString)\n    sprintf(szBuffer, \"%s\", \"]\\\" \");\n  else\n    sprintf(szBuffer, \"%s\", \"] \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  sprintf(szBuffer, \"%s\", \" <= \");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n  pszTmpEscaped = msStringEscape(aszBounds[1]);\n  snprintf(szBuffer, bufferSize, \"%s\", pszTmpEscaped);\n  if (pszTmpEscaped != aszBounds[1]) msFree(pszTmpEscaped);\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  if (bString) {\n    pszExpression = msStringConcatenate(pszExpression, \"\\\"\");\n  }\n  else if (bDateTime) {\n    pszExpression = msStringConcatenate(pszExpression, \"`\");\n  }\n  sprintf(szBuffer, \"%s\", \")\");\n  pszExpression = msStringConcatenate(pszExpression, szBuffer);\n\n  msFreeCharArray(aszBounds, nBounds);\n\n  return pszExpression;\n}\n\nchar *FLTGetBinaryComparisonCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char szTmp[1024];\n  char *pszExpression = NULL, *pszTmpEscaped;\n  int bString;\n  int bDateTime;\n\n  if (psFilterNode == NULL)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      check if the value is a numeric value or alphanumeric. If it    */\n  /*      is alphanumeric, add quotes around attribute and values.        */\n  /* -------------------------------------------------------------------- */\n  bString = 0;\n  bDateTime = 0;\n  if (psFilterNode->psRightNode->pszValue) {\n    const char* pszType;\n    snprintf(szTmp, sizeof(szTmp), \"%s_type\",  psFilterNode->psLeftNode->pszValue);\n    pszType = msOWSLookupMetadata(&(lp->metadata), \"OFG\", szTmp);\n    if (pszType!= NULL && (strcasecmp(pszType, \"Character\") == 0))\n      bString = 1;\n    else if (pszType!= NULL && (strcasecmp(pszType, \"Date\") == 0))\n      bDateTime = 1;\n    else if (FLTIsNumeric(psFilterNode->psRightNode->pszValue) == MS_FALSE)\n      bString = 1;\n  }\n\n  /* specical case to be able to have empty strings in the expression. */\n  /* propertyislike is always treated as string */\n  if (psFilterNode->psRightNode->pszValue == NULL || strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n    bString = 1;\n\n  /* attribute */\n  if (bString)\n    sprintf(szTmp, \"%s\", \"(\\\"[\");\n  else\n    sprintf(szTmp,  \"%s\",\"([\");\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n  pszExpression = msStringConcatenate(pszExpression, psFilterNode->psLeftNode->pszValue);\n  \n  if (bString)\n    sprintf(szTmp,  \"%s\",\"]\\\" \");\n  else\n    sprintf(szTmp,  \"%s\", \"] \");\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n\n  if (strcasecmp(psFilterNode->pszValue, \"PropertyIsEqualTo\") == 0) {\n    /* case insensitive set ? */\n    if (psFilterNode->psRightNode->pOther && (*(int *)psFilterNode->psRightNode->pOther) == 1)\n      sprintf(szTmp,  \"%s\", \"=*\");\n    else\n      sprintf(szTmp,  \"%s\", \"=\");\n  } else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsNotEqualTo\") == 0)\n    sprintf(szTmp,  \"%s\", \"!=\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLessThan\") == 0)\n    sprintf(szTmp,  \"%s\", \"<\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsGreaterThan\") == 0)\n    sprintf(szTmp,  \"%s\", \">\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLessThanOrEqualTo\") == 0)\n    sprintf(szTmp,  \"%s\", \"<=\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsGreaterThanOrEqualTo\") == 0)\n    sprintf(szTmp,  \"%s\", \">=\");\n  else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n    sprintf(szTmp,  \"%s\", \"~\");\n\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n  pszExpression = msStringConcatenate(pszExpression, \" \");\n\n  /* value */\n  if (bString) {\n    sprintf(szTmp,  \"%s\", \"\\\"\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n  else if (bDateTime) {\n    sprintf(szTmp,  \"%s\", \"`\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n\n  if (psFilterNode->psRightNode->pszValue) {\n    pszTmpEscaped = msStringEscape(psFilterNode->psRightNode->pszValue);\n    pszExpression = msStringConcatenate(pszExpression, pszTmpEscaped);\n    if(pszTmpEscaped != psFilterNode->psRightNode->pszValue ) msFree(pszTmpEscaped);\n  }\n\n  if (bString) {\n    sprintf(szTmp,  \"%s\", \"\\\"\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n  else if (bDateTime) {\n    sprintf(szTmp,  \"%s\", \"`\");\n    pszExpression = msStringConcatenate(pszExpression, szTmp);\n  }\n\n  sprintf(szTmp,  \"%s\", \")\");\n  pszExpression = msStringConcatenate(pszExpression, szTmp);\n\n  return pszExpression;\n}\n\nchar *FLTGetLogicalComparisonCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  char *pszTmp = NULL;\n\n  if (!psFilterNode || !FLTIsLogicalFilterType(psFilterNode->pszValue))\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      OR and AND                                                      */\n  /* -------------------------------------------------------------------- */\n  if (psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n    pszTmp = FLTGetCommonExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszExpression = msStringConcatenate(pszExpression, \"(\");\n\n    pszExpression = msStringConcatenate(pszExpression, pszTmp);\n    msFree(pszTmp);\n\n    pszExpression = msStringConcatenate(pszExpression, \" \");\n\n    pszExpression = msStringConcatenate(pszExpression, psFilterNode->pszValue);\n\n    pszExpression = msStringConcatenate(pszExpression, \" \");\n\n    pszTmp = FLTGetCommonExpression(psFilterNode->psRightNode, lp);\n    if (!pszTmp) {\n      msFree(pszExpression);\n      return NULL;\n    }\n\n    pszExpression = msStringConcatenate(pszExpression, pszTmp);\n    msFree(pszTmp);\n\n    pszExpression = msStringConcatenate(pszExpression, \")\");\n  }\n  /* -------------------------------------------------------------------- */\n  /*      NOT                                                             */\n  /* -------------------------------------------------------------------- */\n  else if (psFilterNode->psLeftNode && strcasecmp(psFilterNode->pszValue, \"NOT\") == 0) {\n    pszTmp = FLTGetCommonExpression(psFilterNode->psLeftNode, lp);\n    if (!pszTmp)\n      return NULL;\n\n    pszExpression = msStringConcatenate(pszExpression, \"(NOT \");\n\n    pszExpression = msStringConcatenate(pszExpression, pszTmp);\n    msFree(pszTmp);\n\n    pszExpression = msStringConcatenate(pszExpression, \")\");\n  }\n\n  return pszExpression;\n}\n\nchar *FLTGetSpatialComparisonCommonExpression(FilterEncodingNode *psNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  shapeObj *psQueryShape = NULL;\n  double dfDistance = -1;\n  int nUnit = -1, nLayerUnit = -1;\n  char *pszWktText = NULL;\n  char szBuffer[256];\n  char *pszTmp=NULL;\n  projectionObj sProjTmp;\n  rectObj sQueryRect;\n  shapeObj *psTmpShape=NULL;\n  int bBBoxQuery = 0;\n  int bAlreadyReprojected = 0;\n\n  if (psNode == NULL || lp == NULL)\n    return NULL;\n\n  if (psNode->eType != FILTER_NODE_TYPE_SPATIAL)\n    return NULL;\n\n  /* get the shape */\n  if (FLTIsBBoxFilter(psNode)) {\n    char szPolygon[512];\n    FLTGetBBOX(psNode, &sQueryRect);\n\n    snprintf(szPolygon, sizeof(szPolygon),\n             \"POLYGON((%.18f %.18f,%.18f %.18f,%.18f %.18f,%.18f %.18f,%.18f %.18f))\",\n             sQueryRect.minx, sQueryRect.miny,\n             sQueryRect.minx, sQueryRect.maxy,\n             sQueryRect.maxx, sQueryRect.maxy,\n             sQueryRect.maxx, sQueryRect.miny,\n             sQueryRect.minx, sQueryRect.miny);\n\n    psTmpShape = msShapeFromWKT(szPolygon);\n\n    /* \n    ** This is a horrible hack to deal with world-extent requests and\n    ** reprojection. msProjectRect() detects if reprojection from longlat to \n    ** projected SRS, and in that case it transforms the bbox to -1e-15,-1e-15,1e15,1e15\n    ** to ensure that all features are returned.\n    **\n    ** Make wfs_200_cite_filter_bbox_world.xml and wfs_200_cite_postgis_bbox_world.xml pass\n    */\n    if (fabs(sQueryRect.minx - -180.0) < 1e-5 &&\n        fabs(sQueryRect.miny - -90.0) < 1e-5 &&\n        fabs(sQueryRect.maxx - 180.0) < 1e-5 &&\n        fabs(sQueryRect.maxy - 90.0) < 1e-5)\n    {\n      if (lp->projection.numargs > 0) {\n        if (psNode->pszSRS)\n          msInitProjection(&sProjTmp);\n        if (psNode->pszSRS) {\n          /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n          if (msLoadProjectionString(&sProjTmp, psNode->pszSRS) == 0) {\n            msProjectRect(&sProjTmp, &lp->projection, &sQueryRect);\n          }\n        } else if (lp->map->projection.numargs > 0)\n          msProjectRect(&lp->map->projection, &lp->projection, &sQueryRect);\n        if (psNode->pszSRS)\n          msFreeProjection(&sProjTmp);\n      }\n      if (sQueryRect.minx <= -1e14) {\n        msFreeShape(psTmpShape);\n        msFree(psTmpShape);\n        psTmpShape = (shapeObj*) msSmallMalloc(sizeof(shapeObj));\n        msInitShape(psTmpShape);\n        msRectToPolygon(sQueryRect, psTmpShape);\n        bAlreadyReprojected = 1;\n      }\n    }\n\n    bBBoxQuery = 1;\n  } else {\n    /* other geos type operations */\n\n    /* project shape to layer projection. If the proj is not part of the filter query,\n      assume that the cooredinates are in the map projection */\n\n    psQueryShape = FLTGetShape(psNode, &dfDistance, &nUnit);\n\n    if ((strcasecmp(psNode->pszValue, \"DWithin\") == 0 || strcasecmp(psNode->pszValue, \"Beyond\") == 0 ) && dfDistance > 0) {\n      nLayerUnit = lp->units;\n      if(nLayerUnit == -1) nLayerUnit = GetMapserverUnitUsingProj(&lp->projection);\n      if(nLayerUnit == -1) nLayerUnit = lp->map->units;\n      if(nLayerUnit == -1) nLayerUnit = GetMapserverUnitUsingProj(&lp->map->projection);\n\n      if (nUnit >= 0 && nUnit != nLayerUnit)\n        dfDistance *= msInchesPerUnit(nUnit,0)/msInchesPerUnit(nLayerUnit,0); /* target is layer units */\n    }\n\n    psTmpShape = psQueryShape;\n  }\n\n  if (psTmpShape) {\n\n    /*\n    ** target is layer projection\n    */\n    if (!bAlreadyReprojected && lp->projection.numargs > 0) {\n      if (psNode->pszSRS)\n        msInitProjection(&sProjTmp);\n      if (psNode->pszSRS) {\n        /* Use the non EPSG variant since axis swapping is done in FLTDoAxisSwappingIfNecessary */\n        if (msLoadProjectionString(&sProjTmp, psNode->pszSRS) == 0) {\n          msProjectShape(&sProjTmp, &lp->projection, psTmpShape);\n        }\n      } else if (lp->map->projection.numargs > 0)\n        msProjectShape(&lp->map->projection, &lp->projection, psTmpShape);\n      if (psNode->pszSRS)\n        msFreeProjection(&sProjTmp);\n    }\n\n    /* function name */\n    if (bBBoxQuery) {\n      sprintf(szBuffer, \"%s\", \"intersects\");\n    } else {\n      if (strncasecmp(psNode->pszValue, \"intersect\", 9) == 0)\n        sprintf(szBuffer, \"%s\", \"intersects\");\n      else {\n        pszTmp = msStrdup(psNode->pszValue);\n        msStringToLower(pszTmp);\n        sprintf(szBuffer, \"%s\", pszTmp);\n        msFree(pszTmp);\n      }\n    }\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    pszExpression = msStringConcatenate(pszExpression, \"(\");\n\n    /* geometry binding */\n    sprintf(szBuffer, \"%s\", \"[shape]\");\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    pszExpression = msStringConcatenate(pszExpression, \",\");\n\n    /* filter geometry */\n    pszWktText = msGEOSShapeToWKT(psTmpShape);\n    sprintf(szBuffer, \"%s\", \"fromText('\");\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    pszExpression = msStringConcatenate(pszExpression, pszWktText);\n    sprintf(szBuffer, \"%s\", \"')\");\n    pszExpression = msStringConcatenate(pszExpression, szBuffer);\n    msGEOSFreeWKT(pszWktText);\n\n    /* (optional) beyond/dwithin distance, always 0.0 since we apply the distance as a buffer earlier */\n    if ((strcasecmp(psNode->pszValue, \"DWithin\") == 0 || strcasecmp(psNode->pszValue, \"Beyond\") == 0)) {\n      // pszExpression = msStringConcatenate(pszExpression, \",0.0\");\n      sprintf(szBuffer, \",%g\", dfDistance);\n      pszExpression = msStringConcatenate(pszExpression, szBuffer);      \n    }\n\n    /* terminate the function */\n    pszExpression = msStringConcatenate(pszExpression, \") = TRUE\");\n  }\n\n  /*\n  ** Cleanup\n  */\n  if (bBBoxQuery) {\n    msFreeShape(psTmpShape);\n    msFree(psTmpShape);\n  }\n\n  return pszExpression;\n}\n\nchar *FLTGetFeatureIdCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n  int nTokens = 0, i=0, bString=0;\n  char **tokens = NULL;\n  const char *pszAttribute=NULL;\n\n#if defined(USE_WMS_SVR) || defined(USE_WFS_SVR) || defined(USE_WCS_SVR) || defined(USE_SOS_SVR)\n  if (psFilterNode->pszValue) {\n    pszAttribute = msOWSLookupMetadata(&(lp->metadata), \"OFG\", \"featureid\");\n    if (pszAttribute) {\n      tokens = msStringSplit(psFilterNode->pszValue,',', &nTokens);\n      if (tokens && nTokens > 0) {\n        for (i=0; i<nTokens; i++) {\n          char *pszTmp = NULL;\n          int bufferSize = 0;\n          const char* pszId = tokens[i];\n          const char* pszDot = strchr(pszId, '.');\n          if( pszDot )\n            pszId = pszDot + 1;\n\n          if (i == 0) {\n            if(FLTIsNumeric(pszId) == MS_FALSE)\n              bString = 1;\n          }\n\n          if (bString) {\n            bufferSize = 11+strlen(pszId)+strlen(pszAttribute)+1;\n            pszTmp = (char *)msSmallMalloc(bufferSize);\n            snprintf(pszTmp, bufferSize, \"(\\\"[%s]\\\" ==\\\"%s\\\")\" , pszAttribute, pszId);\n          } else {\n            bufferSize = 8+strlen(pszId)+strlen(pszAttribute)+1;\n            pszTmp = (char *)msSmallMalloc(bufferSize);\n            snprintf(pszTmp, bufferSize, \"([%s] == %s)\" , pszAttribute, pszId);\n          }\n\n          if (pszExpression != NULL)\n            pszExpression = msStringConcatenate(pszExpression, \" OR \");\n          else\n            pszExpression = msStringConcatenate(pszExpression, \"(\");\n          pszExpression = msStringConcatenate(pszExpression, pszTmp);\n          msFree(pszTmp);\n        }\n\n        msFreeCharArray(tokens, nTokens);\n      }\n    }\n\n    /* opening and closing brackets are needed for mapserver expressions */\n    if (pszExpression)\n      pszExpression = msStringConcatenate(pszExpression, \")\");\n  }\n#endif\n\n  return pszExpression;\n}\n\nchar* FLTGetTimeExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char* pszExpression = NULL;\n  const char* pszTimeField;\n  const char* pszTimeValue;\n\n  if (psFilterNode == NULL || lp == NULL)\n    return NULL;\n\n  if (psFilterNode->eType != FILTER_NODE_TYPE_TEMPORAL)\n    return NULL;\n\n  pszTimeValue = FLTGetDuring(psFilterNode, &pszTimeField);\n  if (pszTimeField && pszTimeValue) {\n    expressionObj old_filter;\n    msInitExpression(&old_filter);\n    msCopyExpression(&old_filter, &lp->filter); /* save existing filter */\n    msFreeExpression(&lp->filter);\n    if (msLayerSetTimeFilter(lp, pszTimeValue, pszTimeField) == MS_TRUE) {\n      pszExpression = msStrdup(lp->filter.string);\n    }\n    msCopyExpression(&lp->filter, &old_filter); /* restore old filter */\n    msFreeExpression(&old_filter);\n  }\n  return pszExpression;\n}\n\nchar *FLTGetCommonExpression(FilterEncodingNode *psFilterNode, layerObj *lp)\n{\n  char *pszExpression = NULL;\n\n  if (!psFilterNode)\n    return NULL;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_COMPARISON) {\n    if ( psFilterNode->psLeftNode && psFilterNode->psRightNode) {\n      if (FLTIsBinaryComparisonFilterType(psFilterNode->pszValue))\n        pszExpression = FLTGetBinaryComparisonCommonExpression(psFilterNode, lp);\n      else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsLike\") == 0)\n        pszExpression = FLTGetIsLikeComparisonCommonExpression(psFilterNode);\n      else if (strcasecmp(psFilterNode->pszValue, \"PropertyIsBetween\") == 0)\n        pszExpression = FLTGetIsBetweenComparisonCommonExpresssion(psFilterNode, lp);\n    }\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_LOGICAL) {\n    pszExpression = FLTGetLogicalComparisonCommonExpression(psFilterNode, lp);\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL) {\n    pszExpression = FLTGetSpatialComparisonCommonExpression(psFilterNode, lp);\n  } else if (psFilterNode->eType ==  FILTER_NODE_TYPE_FEATUREID) {\n    pszExpression = FLTGetFeatureIdCommonExpression(psFilterNode, lp);\n  } else if (psFilterNode->eType == FILTER_NODE_TYPE_TEMPORAL) {\n    pszExpression = FLTGetTimeExpression(psFilterNode, lp);\n  }\n\n  return pszExpression;\n}\n\nint FLTApplyFilterToLayerCommonExpression(mapObj *map, int iLayerIndex, const char *pszExpression)\n{\n  return FLTApplyFilterToLayerCommonExpressionWithRect(map, iLayerIndex, pszExpression, map->extent);\n}\n\n/* rect must be in map->projection */\nint FLTApplyFilterToLayerCommonExpressionWithRect(mapObj *map, int iLayerIndex, const char *pszExpression, rectObj rect)\n{\n  int retval;\n  int save_startindex;\n  int save_maxfeatures;\n  int save_only_cache_result_count;\n\n  save_startindex = map->query.startindex;\n  save_maxfeatures = map->query.maxfeatures;\n  save_only_cache_result_count = map->query.only_cache_result_count;\n  msInitQuery(&(map->query));\n  map->query.startindex = save_startindex;\n  map->query.maxfeatures = save_maxfeatures;\n  map->query.only_cache_result_count = save_only_cache_result_count;\n\n  map->query.mode = MS_QUERY_MULTIPLE;\n  map->query.layer = iLayerIndex;\n\n  map->query.rect = rect;\n\n  if( pszExpression )\n  {\n    map->query.type = MS_QUERY_BY_FILTER;\n    msInitExpression(&map->query.filter);\n    map->query.filter.string = msStrdup(pszExpression);\n    map->query.filter.type = MS_EXPRESSION; /* a logical expression */\n\n    retval = msQueryByFilter(map);\n  }\n  else\n  {\n    map->query.type = MS_QUERY_BY_RECT;\n    retval = msQueryByRect(map);\n  }\n\n  return retval;\n}\n\n#endif\n"], "filenames": ["mapogcfilter.c", "mapogcfiltercommon.c"], "buggy_code_start_loc": [3006, 90], "buggy_code_end_loc": [3006, 90], "fixing_code_start_loc": [3007, 91], "fixing_code_end_loc": [3009, 93], "type": "CWE-119", "message": "Stack-based buffer overflow in MapServer before 6.0.6, 6.2.x before 6.2.4, 6.4.x before 6.4.5, and 7.0.x before 7.0.4 allows remote attackers to cause a denial of service (crash) or execute arbitrary code via vectors involving WFS get feature requests.", "other": {"cve": {"id": "CVE-2017-5522", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T16:59:00.283", "lastModified": "2021-06-07T15:56:17.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in MapServer before 6.0.6, 6.2.x before 6.2.4, 6.4.x before 6.4.5, and 7.0.x before 7.0.4 allows remote attackers to cause a denial of service (crash) or execute arbitrary code via vectors involving WFS get feature requests."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en pila en MapServer en versiones anteriores a 6.0.6, 6.2.x en versiones anteriores a 6.2.4, 6.4.x en versiones anteriores a 6.4.5 y 7.0.x en versiones anteriores a 7.0.4 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) o ejecutar c\u00f3digo arbitrario a trav\u00e9s de vectores que implican solicitudes WFS de obtenci\u00f3n de funci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.0.5", "matchCriteriaId": "2616104A-15A1-4EE2-B422-F0A0956029B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "16A7F401-1829-440B-A7D0-08515F73E11A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "EC09B39C-A41A-4024-A5CE-1D8FDFB9C67C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "E25092AC-76DD-495D-9FB6-A6D76A08464D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "C738E019-D602-4E5C-8FB3-64CC5F11EF83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "FFD649DB-1FE8-4973-B329-107A89FD6799"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "4E6833DE-045A-4458-A067-CCFA3A8CE016"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "C6A01342-B989-4134-8692-8BD8A42B93D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "F52DB9E8-C9B0-4513-B181-05A98404C04F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "FC5EA648-9431-45F1-93FE-2D60C08634B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "995FF868-DD52-4625-AD2E-74BB63F4BC72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "CA6FB628-5D34-46DF-BF7F-5D277A51F9F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "2EC08735-4E07-45F2-AE1B-56F6B9291FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "5BB85B09-03A4-4296-8CDC-40338C7F92EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "8A9D9693-6F02-4F21-AD59-A0AEA73D6374"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "7B8EA460-06CF-4175-999C-5C98E9B0DC78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "3905DE6B-14D9-45E0-9A95-9EE131691658"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:6.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "DF6DD7AA-AA71-497E-9BCC-7CDD450EA7B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:7.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "251BBE27-A977-4725-AFCA-22CF96CBD965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:7.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "FB1C2F87-63A3-4D2C-AB84-B7C319058572"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:7.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "46A22D61-588D-476C-8284-EEE3EDC53EBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:7.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "BE7043E9-2FE4-441D-AF8E-139AF97387CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:7.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "131EA02D-E121-4BED-9381-688A2ED16595"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:mapserver:7.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "C53903F5-D572-4CDA-BEC3-EAA5FDBB5A2C"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3766", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mapserver.org/development/changelog/changelog-6-0-6.html#changelog-6-0-6", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.mapserver.org/development/changelog/changelog-6-2-4.html#changelog-6-2-4", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.mapserver.org/development/changelog/changelog-6-4.html#changelog-6-4-5", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.mapserver.org/development/changelog/changelog-7-0.html#changelog-7-0-4", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/mapserver/mapserver/commit/e52a436c0e1c5e9f7ef13428dba83194a800f4df", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.osgeo.org/pipermail/mapserver-dev/2017-January/015007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mapserver/mapserver/commit/e52a436c0e1c5e9f7ef13428dba83194a800f4df"}}