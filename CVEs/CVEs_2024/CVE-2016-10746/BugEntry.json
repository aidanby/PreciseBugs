{"buggy_code": ["/*\n * libvirt-domain.c: entry points for virDomainPtr APIs\n *\n * Copyright (C) 2006-2015 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.  If not, see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <sys/stat.h>\n\n#include \"intprops.h\"\n\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virtypedparam.h\"\n\nVIR_LOG_INIT(\"libvirt.domain\");\n\n#define VIR_FROM_THIS VIR_FROM_DOMAIN\n\n\n/**\n * virConnectListDomains:\n * @conn: pointer to the hypervisor connection\n * @ids: array to collect the list of IDs of active domains\n * @maxids: size of @ids\n *\n * Collect the list of active domains, and store their IDs in array @ids\n *\n * For inactive domains, see virConnectListDefinedDomains().  For more\n * control over the results, see virConnectListAllDomains().\n *\n * Returns the number of domains found or -1 in case of error.  Note that\n * this command is inherently racy; a domain can be started between a\n * call to virConnectNumOfDomains() and this call; you are only guaranteed\n * that all currently active domains were listed if the return is less\n * than @maxids.\n */\nint\nvirConnectListDomains(virConnectPtr conn, int *ids, int maxids)\n{\n    VIR_DEBUG(\"conn=%p, ids=%p, maxids=%d\", conn, ids, maxids);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(ids, error);\n    virCheckNonNegativeArgGoto(maxids, error);\n\n    if (conn->driver->connectListDomains) {\n        int ret = conn->driver->connectListDomains(conn, ids, maxids);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectNumOfDomains:\n * @conn: pointer to the hypervisor connection\n *\n * Provides the number of active domains.\n *\n * Returns the number of domain found or -1 in case of error\n */\nint\nvirConnectNumOfDomains(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectNumOfDomains) {\n        int ret = conn->driver->connectNumOfDomains(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetConnect:\n * @dom: pointer to a domain\n *\n * Provides the connection pointer associated with a domain.  The\n * reference counter on the connection is not increased by this\n * call.\n *\n * WARNING: When writing libvirt bindings in other languages, do\n * not use this function.  Instead, store the connection and\n * the domain object together.\n *\n * Returns the virConnectPtr or NULL in case of failure.\n */\nvirConnectPtr\nvirDomainGetConnect(virDomainPtr dom)\n{\n    VIR_DOMAIN_DEBUG(dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, NULL);\n\n    return dom->conn;\n}\n\n\n/**\n * virDomainCreateXML:\n * @conn: pointer to the hypervisor connection\n * @xmlDesc: string containing an XML description of the domain\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a new guest domain, based on an XML description similar\n * to the one returned by virDomainGetXMLDesc()\n * This function may require privileged access to the hypervisor.\n * The domain is not persistent, so its definition will disappear when it\n * is destroyed, or if the host is restarted (see virDomainDefineXML() to\n * define persistent domains).\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, the guest domain\n * will be started, but its CPUs will remain paused. The CPUs\n * can later be manually started using virDomainResume.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure\n */\nvirDomainPtr\nvirDomainCreateXML(virConnectPtr conn, const char *xmlDesc,\n                   unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xmlDesc=%s, flags=%x\", conn, NULLSTR(xmlDesc), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateXML) {\n        virDomainPtr ret;\n        ret = conn->driver->domainCreateXML(conn, xmlDesc, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainCreateXMLWithFiles:\n * @conn: pointer to the hypervisor connection\n * @xmlDesc: string containing an XML description of the domain\n * @nfiles: number of file descriptors passed\n * @files: list of file descriptors passed\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a new guest domain, based on an XML description similar\n * to the one returned by virDomainGetXMLDesc()\n * This function may require privileged access to the hypervisor.\n * The domain is not persistent, so its definition will disappear when it\n * is destroyed, or if the host is restarted (see virDomainDefineXML() to\n * define persistent domains).\n *\n * @files provides an array of file descriptors which will be\n * made available to the 'init' process of the guest. The file\n * handles exposed to the guest will be renumbered to start\n * from 3 (ie immediately following stderr). This is only\n * supported for guests which use container based virtualization\n * technology.\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, the guest domain\n * will be started, but its CPUs will remain paused. The CPUs\n * can later be manually started using virDomainResume.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure\n */\nvirDomainPtr\nvirDomainCreateXMLWithFiles(virConnectPtr conn, const char *xmlDesc,\n                            unsigned int nfiles,\n                            int *files,\n                            unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xmlDesc=%s, nfiles=%u, files=%p, flags=%x\",\n              conn, NULLSTR(xmlDesc), nfiles, files, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateXMLWithFiles) {\n        virDomainPtr ret;\n        ret = conn->driver->domainCreateXMLWithFiles(conn, xmlDesc,\n                                                     nfiles, files,\n                                                     flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainCreateLinux:\n * @conn: pointer to the hypervisor connection\n * @xmlDesc: string containing an XML description of the domain\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Deprecated after 0.4.6.\n * Renamed to virDomainCreateXML() providing identical functionality.\n * This existing name will be left indefinitely for API compatibility.\n *\n * Returns a new domain object or NULL in case of failure\n */\nvirDomainPtr\nvirDomainCreateLinux(virConnectPtr conn, const char *xmlDesc,\n                     unsigned int flags)\n{\n    return virDomainCreateXML(conn, xmlDesc, flags);\n}\n\n\n/**\n * virDomainLookupByID:\n * @conn: pointer to the hypervisor connection\n * @id: the domain ID number\n *\n * Try to find a domain based on the hypervisor ID number\n * Note that this won't work for inactive domains which have an ID of -1,\n * in that case a lookup based on the Name or UUId need to be done instead.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByID(virConnectPtr conn, int id)\n{\n    VIR_DEBUG(\"conn=%p, id=%d\", conn, id);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNegativeArgGoto(id, error);\n\n    if (conn->driver->domainLookupByID) {\n        virDomainPtr ret;\n        ret = conn->driver->domainLookupByID(conn, id);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainLookupByUUID:\n * @conn: pointer to the hypervisor connection\n * @uuid: the raw UUID for the domain\n *\n * Try to lookup a domain on the given hypervisor based on its UUID.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    VIR_UUID_DEBUG(conn, uuid);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (conn->driver->domainLookupByUUID) {\n        virDomainPtr ret;\n        ret = conn->driver->domainLookupByUUID(conn, uuid);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainLookupByUUIDString:\n * @conn: pointer to the hypervisor connection\n * @uuidstr: the string UUID for the domain\n *\n * Try to lookup a domain on the given hypervisor based on its UUID.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByUUIDString(virConnectPtr conn, const char *uuidstr)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    VIR_DEBUG(\"conn=%p, uuidstr=%s\", conn, NULLSTR(uuidstr));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(uuidstr, error);\n\n    if (virUUIDParse(uuidstr, uuid) < 0) {\n        virReportInvalidArg(uuidstr, \"%s\", _(\"Invalid UUID\"));\n        goto error;\n    }\n\n    return virDomainLookupByUUID(conn, &uuid[0]);\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainLookupByName:\n * @conn: pointer to the hypervisor connection\n * @name: name for the domain\n *\n * Try to lookup a domain on the given hypervisor based on its name.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->driver->domainLookupByName) {\n        virDomainPtr dom;\n        dom = conn->driver->domainLookupByName(conn, name);\n        if (!dom)\n            goto error;\n        return dom;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainDestroy:\n * @domain: a domain object\n *\n * Destroy the domain object. The running instance is shutdown if not down\n * already and all resources used by it are given back to the hypervisor. This\n * does not free the associated virDomainPtr object.\n * This function may require privileged access.\n *\n * virDomainDestroy first requests that a guest terminate\n * (e.g. SIGTERM), then waits for it to comply. After a reasonable\n * timeout, if the guest still exists, virDomainDestroy will\n * forcefully terminate the guest (e.g. SIGKILL) if necessary (which\n * may produce undesirable results, for example unflushed disk cache\n * in the guest). To avoid this possibility, it's recommended to\n * instead call virDomainDestroyFlags, sending the\n * VIR_DOMAIN_DESTROY_GRACEFUL flag.\n *\n * If the domain is transient and has any snapshot metadata (see\n * virDomainSnapshotNum()), then that metadata will automatically\n * be deleted when the domain quits.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainDestroy(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDestroy) {\n        int ret;\n        ret = conn->driver->domainDestroy(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainDestroyFlags:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainDestroyFlagsValues\n *\n * Destroy the domain object. The running instance is shutdown if not down\n * already and all resources used by it are given back to the hypervisor.\n * This does not free the associated virDomainPtr object.\n * This function may require privileged access.\n *\n * Calling this function with no @flags set (equal to zero) is\n * equivalent to calling virDomainDestroy, and after a reasonable\n * timeout will forcefully terminate the guest (e.g. SIGKILL) if\n * necessary (which may produce undesirable results, for example\n * unflushed disk cache in the guest). Including\n * VIR_DOMAIN_DESTROY_GRACEFUL in the flags will prevent the forceful\n * termination of the guest, and virDomainDestroyFlags will instead\n * return an error if the guest doesn't terminate by the end of the\n * timeout; at that time, the management application can decide if\n * calling again without VIR_DOMAIN_DESTROY_GRACEFUL is appropriate.\n *\n * Another alternative which may produce cleaner results for the\n * guest's disks is to use virDomainShutdown() instead, but that\n * depends on guest support (some hypervisor/guest combinations may\n * ignore the shutdown request).\n *\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainDestroyFlags(virDomainPtr domain,\n                      unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDestroyFlags) {\n        int ret;\n        ret = conn->driver->domainDestroyFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainFree:\n * @domain: a domain object\n *\n * Free the domain object. The running instance is kept alive.\n * The data structure is freed and should not be used thereafter.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainFree(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virObjectUnref(domain);\n    return 0;\n}\n\n\n/**\n * virDomainRef:\n * @domain: the domain to hold a reference on\n *\n * Increment the reference count on the domain. For each\n * additional call to this method, there shall be a corresponding\n * call to virDomainFree to release the reference count, once\n * the caller no longer needs the reference to this object.\n *\n * This method is typically useful for applications where multiple\n * threads are using a connection, and it is required that the\n * connection remain open until all threads have finished using\n * it. ie, each new thread using a domain would increment\n * the reference count.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainRef(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain, \"refs=%d\", domain ? domain->object.u.s.refs : 0);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virObjectRef(domain);\n    return 0;\n}\n\n\n/**\n * virDomainSuspend:\n * @domain: a domain object\n *\n * Suspends an active domain, the process is frozen without further access\n * to CPU resources and I/O but the memory used by the domain at the\n * hypervisor level will stay allocated. Use virDomainResume() to reactivate\n * the domain.\n * This function may require privileged access.\n * Moreover, suspend may not be supported if domain is in some\n * special state like VIR_DOMAIN_PMSUSPENDED.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSuspend(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainSuspend) {\n        int ret;\n        ret = conn->driver->domainSuspend(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainResume:\n * @domain: a domain object\n *\n * Resume a suspended domain, the process is restarted from the state where\n * it was frozen by calling virDomainSuspend().\n * This function may require privileged access\n * Moreover, resume may not be supported if domain is in some\n * special state like VIR_DOMAIN_PMSUSPENDED.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainResume(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainResume) {\n        int ret;\n        ret = conn->driver->domainResume(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPMSuspendForDuration:\n * @dom: a domain object\n * @target: a value from virNodeSuspendTarget\n * @duration: duration in seconds to suspend, or 0 for indefinite\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Attempt to have the guest enter the given @target power management\n * suspension level.  If @duration is non-zero, also schedule the guest to\n * resume normal operation after that many seconds, if nothing else has\n * resumed it earlier.  Some hypervisors require that @duration be 0, for\n * an indefinite suspension.\n *\n * Dependent on hypervisor used, this may require a\n * guest agent to be available, e.g. QEMU.\n *\n * Beware that at least for QEMU, the domain's process will be terminated\n * when VIR_NODE_SUSPEND_TARGET_DISK is used and a new process will be\n * launched when libvirt is asked to wake up the domain. As a result of\n * this, any runtime changes, such as device hotplug or memory settings,\n * are lost unless such changes were made with VIR_DOMAIN_AFFECT_CONFIG\n * flag.\n *\n * Returns: 0 on success,\n *          -1 on failure.\n */\nint\nvirDomainPMSuspendForDuration(virDomainPtr dom,\n                              unsigned int target,\n                              unsigned long long duration,\n                              unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"target=%u duration=%llu flags=%x\",\n                     target, duration, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainPMSuspendForDuration) {\n        int ret;\n        ret = conn->driver->domainPMSuspendForDuration(dom, target,\n                                                       duration, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainPMWakeup:\n * @dom: a domain object\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Inject a wakeup into the guest that previously used\n * virDomainPMSuspendForDuration, rather than waiting for the\n * previously requested duration (if any) to elapse.\n *\n * Returns: 0 on success,\n *          -1 on failure.\n */\nint\nvirDomainPMWakeup(virDomainPtr dom,\n                  unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainPMWakeup) {\n        int ret;\n        ret = conn->driver->domainPMWakeup(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainSave:\n * @domain: a domain object\n * @to: path for the output file\n *\n * This method will suspend a domain and save its memory contents to\n * a file on disk. After the call, if successful, the domain is not\n * listed as running anymore (this ends the life of a transient domain).\n * Use virDomainRestore() to restore a domain after saving.\n *\n * See virDomainSaveFlags() for more control.  Also, a save file can\n * be inspected or modified slightly with virDomainSaveImageGetXMLDesc()\n * and virDomainSaveImageDefineXML().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSave(virDomainPtr domain, const char *to)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s\", to);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    if (conn->driver->domainSave) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute output file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSave(domain, absolute_to);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSaveFlags:\n * @domain: a domain object\n * @to: path for the output file\n * @dxml: (optional) XML config for adjusting guest xml used on restore\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This method will suspend a domain and save its memory contents to\n * a file on disk. After the call, if successful, the domain is not\n * listed as running anymore (this ends the life of a transient domain).\n * Use virDomainRestore() to restore a domain after saving.\n *\n * If the hypervisor supports it, @dxml can be used to alter\n * host-specific portions of the domain XML that will be used when\n * restoring an image.  For example, it is possible to alter the\n * backing filename that is associated with a disk device, in order to\n * prepare for file renaming done as part of backing up the disk\n * device while the domain is stopped.\n *\n * If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\n * attempt to bypass the file system cache while creating the file, or\n * fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * Normally, the saved state file will remember whether the domain was\n * running or paused, and restore defaults to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override what state gets saved into the file.  These\n * two flags are mutually exclusive.\n *\n * A save file can be inspected or modified slightly with\n * virDomainSaveImageGetXMLDesc() and virDomainSaveImageDefineXML().\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation; in that case, use virDomainBlockJobAbort()\n * to stop the block copy first.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSaveFlags(virDomainPtr domain, const char *to,\n                   const char *dxml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, dxml=%s, flags=%x\",\n                     to, NULLSTR(dxml), flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainSaveFlags) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute output file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSaveFlags(domain, absolute_to, dxml, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainRestore:\n * @conn: pointer to the hypervisor connection\n * @from: path to the input file\n *\n * This method will restore a domain saved to disk by virDomainSave().\n *\n * See virDomainRestoreFlags() for more control.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainRestore(virConnectPtr conn, const char *from)\n{\n    VIR_DEBUG(\"conn=%p, from=%s\", conn, NULLSTR(from));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(from, error);\n\n    if (conn->driver->domainRestore) {\n        int ret;\n        char *absolute_from;\n\n        /* We must absolutize the file path as the restore is done out of process */\n        if (virFileAbsPath(from, &absolute_from) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainRestore(conn, absolute_from);\n\n        VIR_FREE(absolute_from);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainRestoreFlags:\n * @conn: pointer to the hypervisor connection\n * @from: path to the input file\n * @dxml: (optional) XML config for adjusting guest xml used on restore\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This method will restore a domain saved to disk by virDomainSave().\n *\n * If the hypervisor supports it, @dxml can be used to alter\n * host-specific portions of the domain XML that will be used when\n * restoring an image.  For example, it is possible to alter the\n * backing filename that is associated with a disk device, in order to\n * prepare for file renaming done as part of backing up the disk\n * device while the domain is stopped.\n *\n * If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\n * attempt to bypass the file system cache while restoring the file, or\n * fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing restores from NFS.\n *\n * Normally, the saved state file will remember whether the domain was\n * running or paused, and restore defaults to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override the default read from the file.  These two\n * flags are mutually exclusive.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainRestoreFlags(virConnectPtr conn, const char *from, const char *dxml,\n                      unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, from=%s, dxml=%s, flags=%x\",\n              conn, NULLSTR(from), NULLSTR(dxml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(from, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainRestoreFlags) {\n        int ret;\n        char *absolute_from;\n\n        /* We must absolutize the file path as the restore is done out of process */\n        if (virFileAbsPath(from, &absolute_from) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainRestoreFlags(conn, absolute_from, dxml,\n                                               flags);\n\n        VIR_FREE(absolute_from);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainSaveImageGetXMLDesc:\n * @conn: pointer to the hypervisor connection\n * @file: path to saved state file\n * @flags: bitwise-OR of subset of virDomainXMLFlags\n *\n * This method will extract the XML describing the domain at the time\n * a saved state file was created.  @file must be a file created\n * previously by virDomainSave() or virDomainSaveFlags().\n *\n * No security-sensitive data will be included unless @flags contains\n * VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\n * connections.  For this API, @flags should not contain either\n * VIR_DOMAIN_XML_INACTIVE or VIR_DOMAIN_XML_UPDATE_CPU.\n *\n * Returns a 0 terminated UTF-8 encoded XML instance, or NULL in case of\n * error.  The caller must free() the returned value.\n */\nchar *\nvirDomainSaveImageGetXMLDesc(virConnectPtr conn, const char *file,\n                             unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, file=%s, flags=%x\",\n              conn, NULLSTR(file), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(file, error);\n\n    if ((conn->flags & VIR_CONNECT_RO) && (flags & VIR_DOMAIN_XML_SECURE)) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"virDomainSaveImageGetXMLDesc with secure flag\"));\n        goto error;\n    }\n\n    if (conn->driver->domainSaveImageGetXMLDesc) {\n        char *ret;\n        char *absolute_file;\n\n        /* We must absolutize the file path as the read is done out of process */\n        if (virFileAbsPath(file, &absolute_file) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSaveImageGetXMLDesc(conn, absolute_file,\n                                                      flags);\n\n        VIR_FREE(absolute_file);\n\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainSaveImageDefineXML:\n * @conn: pointer to the hypervisor connection\n * @file: path to saved state file\n * @dxml: XML config for adjusting guest xml used on restore\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This updates the definition of a domain stored in a saved state\n * file.  @file must be a file created previously by virDomainSave()\n * or virDomainSaveFlags().\n *\n * @dxml can be used to alter host-specific portions of the domain XML\n * that will be used when restoring an image.  For example, it is\n * possible to alter the backing filename that is associated with a\n * disk device, to match renaming done as part of backing up the disk\n * device while the domain is stopped.\n *\n * Normally, the saved state file will remember whether the domain was\n * running or paused, and restore defaults to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override the default saved into the file; omitting both\n * leaves the file's default unchanged.  These two flags are mutually\n * exclusive.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSaveImageDefineXML(virConnectPtr conn, const char *file,\n                            const char *dxml, unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, file=%s, dxml=%s, flags=%x\",\n              conn, NULLSTR(file), NULLSTR(dxml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(file, error);\n    virCheckNonNullArgGoto(dxml, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainSaveImageDefineXML) {\n        int ret;\n        char *absolute_file;\n\n        /* We must absolutize the file path as the read is done out of process */\n        if (virFileAbsPath(file, &absolute_file) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSaveImageDefineXML(conn, absolute_file,\n                                                     dxml, flags);\n\n        VIR_FREE(absolute_file);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainCoreDump:\n * @domain: a domain object\n * @to: path for the core file\n * @flags: bitwise-OR of virDomainCoreDumpFlags\n *\n * This method will dump the core of a domain on a given file for analysis.\n * Note that for remote Xen Daemon the file path will be interpreted in\n * the remote host. Hypervisors may require  the user to manually ensure\n * proper permissions on the file named by @to.\n *\n * If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with\n * a crashed state after the dump completes.  If @flags includes\n * VIR_DUMP_LIVE, then make the core dump while continuing to allow\n * the guest to run; otherwise, the guest is suspended during the dump.\n * VIR_DUMP_RESET flag forces reset of the guest after dump.\n * The above three flags are mutually exclusive.\n *\n * Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt\n * will attempt to bypass the file system cache while creating the file,\n * or fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * For more control over the output format, see virDomainCoreDumpWithFormat().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, flags=%x\", to, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);\n\n    if (conn->driver->domainCoreDump) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute core file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainCoreDump(domain, absolute_to, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n/**\n * virDomainCoreDumpWithFormat:\n * @domain: a domain object\n * @to: path for the core file\n * @dumpformat: format of domain memory's dump (one of virDomainCoreDumpFormat enum)\n * @flags: bitwise-OR of virDomainCoreDumpFlags\n *\n * This method will dump the core of a domain on a given file for analysis.\n * Note that for remote Xen Daemon the file path will be interpreted in\n * the remote host. Hypervisors may require  the user to manually ensure\n * proper permissions on the file named by @to.\n *\n * @dumpformat controls which format the dump will have; use of\n * VIR_DOMAIN_CORE_DUMP_FORMAT_RAW mirrors what virDomainCoreDump() will\n * perform.  Not all hypervisors are able to support all formats.\n *\n * If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with\n * a crashed state after the dump completes.  If @flags includes\n * VIR_DUMP_LIVE, then make the core dump while continuing to allow\n * the guest to run; otherwise, the guest is suspended during the dump.\n * VIR_DUMP_RESET flag forces reset of the guest after dump.\n * The above three flags are mutually exclusive.\n *\n * Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt\n * will attempt to bypass the file system cache while creating the file,\n * or fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainCoreDumpWithFormat(virDomainPtr domain, const char *to,\n                            unsigned int dumpformat, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, dumpformat=%u, flags=%x\",\n                     to, dumpformat, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    if (dumpformat >= VIR_DOMAIN_CORE_DUMP_FORMAT_LAST) {\n        virReportInvalidArg(flags, _(\"dumpformat '%d' is not supported\"),\n                            dumpformat);\n        goto error;\n    }\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);\n\n    if (conn->driver->domainCoreDumpWithFormat) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute core file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainCoreDumpWithFormat(domain, absolute_to,\n                                                     dumpformat, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainScreenshot:\n * @domain: a domain object\n * @stream: stream to use as output\n * @screen: monitor ID to take screenshot from\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Take a screenshot of current domain console as a stream. The image format\n * is hypervisor specific. Moreover, some hypervisors supports multiple\n * displays per domain. These can be distinguished by @screen argument.\n *\n * This call sets up a stream; subsequent use of stream API is necessary\n * to transfer actual data, determine how much data is successfully\n * transferred, and detect any errors.\n *\n * The screen ID is the sequential number of screen. In case of multiple\n * graphics cards, heads are enumerated before devices, e.g. having\n * two graphics cards, both with four heads, screen ID 5 addresses\n * the second head on the second card.\n *\n * Returns a string representing the mime-type of the image format, or\n * NULL upon error. The caller must free() the returned value.\n */\nchar *\nvirDomainScreenshot(virDomainPtr domain,\n                    virStreamPtr stream,\n                    unsigned int screen,\n                    unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(domain, \"stream=%p, flags=%x\", stream, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    virCheckStreamGoto(stream, error);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    if (domain->conn != stream->conn) {\n        virReportInvalidArg(stream,\n                            _(\"stream must match connection of domain '%s'\"),\n                            domain->name);\n        goto error;\n    }\n\n    if (domain->conn->driver->domainScreenshot) {\n        char *ret;\n        ret = domain->conn->driver->domainScreenshot(domain, stream,\n                                                     screen, flags);\n\n        if (ret == NULL)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainShutdown:\n * @domain: a domain object\n *\n * Shutdown a domain, the domain object is still usable thereafter, but\n * the domain OS is being stopped. Note that the guest OS may ignore the\n * request. Additionally, the hypervisor may check and support the domain\n * 'on_poweroff' XML setting resulting in a domain that reboots instead of\n * shutting down. For guests that react to a shutdown request, the differences\n * from virDomainDestroy() are that the guests disk storage will be in a\n * stable state rather than having the (virtual) power cord pulled, and\n * this command returns as soon as the shutdown request is issued rather\n * than blocking until the guest is no longer running.\n *\n * If the domain is transient and has any snapshot metadata (see\n * virDomainSnapshotNum()), then that metadata will automatically\n * be deleted when the domain quits.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainShutdown(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainShutdown) {\n        int ret;\n        ret = conn->driver->domainShutdown(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainShutdownFlags:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainShutdownFlagValues\n *\n * Shutdown a domain, the domain object is still usable thereafter but\n * the domain OS is being stopped. Note that the guest OS may ignore the\n * request. Additionally, the hypervisor may check and support the domain\n * 'on_poweroff' XML setting resulting in a domain that reboots instead of\n * shutting down. For guests that react to a shutdown request, the differences\n * from virDomainDestroy() are that the guest's disk storage will be in a\n * stable state rather than having the (virtual) power cord pulled, and\n * this command returns as soon as the shutdown request is issued rather\n * than blocking until the guest is no longer running.\n *\n * If the domain is transient and has any snapshot metadata (see\n * virDomainSnapshotNum()), then that metadata will automatically\n * be deleted when the domain quits.\n *\n * If @flags is set to zero, then the hypervisor will choose the\n * method of shutdown it considers best. To have greater control\n * pass one or more of the virDomainShutdownFlagValues. The order\n * in which the hypervisor tries each shutdown method is undefined,\n * and a hypervisor is not required to support all methods.\n *\n * To use guest agent (VIR_DOMAIN_SHUTDOWN_GUEST_AGENT) the domain XML\n * must have <channel> configured.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainShutdownFlags(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainShutdownFlags) {\n        int ret;\n        ret = conn->driver->domainShutdownFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainReboot:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainRebootFlagValues\n *\n * Reboot a domain, the domain object is still usable thereafter, but\n * the domain OS is being stopped for a restart.\n * Note that the guest OS may ignore the request.\n * Additionally, the hypervisor may check and support the domain\n * 'on_reboot' XML setting resulting in a domain that shuts down instead\n * of rebooting.\n *\n * If @flags is set to zero, then the hypervisor will choose the\n * method of shutdown it considers best. To have greater control\n * pass one or more of the virDomainRebootFlagValues. The order\n * in which the hypervisor tries each shutdown method is undefined,\n * and a hypervisor is not required to support all methods.\n *\n * To use guest agent (VIR_DOMAIN_REBOOT_GUEST_AGENT) the domain XML\n * must have <channel> configured.\n *\n * Due to implementation limitations in some drivers (the qemu driver,\n * for instance) it is not advised to migrate or save a guest that is\n * rebooting as a result of this API. Migrating such a guest can lead\n * to a plain shutdown on the destination.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainReboot(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainReboot) {\n        int ret;\n        ret = conn->driver->domainReboot(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainReset:\n * @domain: a domain object\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Reset a domain immediately without any guest OS shutdown.\n * Reset emulates the power reset button on a machine, where all\n * hardware sees the RST line set and reinitializes internal state.\n *\n * Note that there is a risk of data loss caused by reset without any\n * guest OS shutdown.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainReset(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainReset) {\n        int ret;\n        ret = conn->driver->domainReset(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetName:\n * @domain: a domain object\n *\n * Get the public name for that domain\n *\n * Returns a pointer to the name or NULL, the string need not be deallocated\n * its lifetime will be the same as the domain object.\n */\nconst char *\nvirDomainGetName(virDomainPtr domain)\n{\n    VIR_DEBUG(\"domain=%p\", domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n\n    return domain->name;\n}\n\n\n/**\n * virDomainGetUUID:\n * @domain: a domain object\n * @uuid: pointer to a VIR_UUID_BUFLEN bytes array\n *\n * Get the UUID for a domain\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainGetUUID(virDomainPtr domain, unsigned char *uuid)\n{\n    VIR_DOMAIN_DEBUG(domain, \"uuid=%p\", uuid);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(uuid, error);\n\n    memcpy(uuid, &domain->uuid[0], VIR_UUID_BUFLEN);\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetUUIDString:\n * @domain: a domain object\n * @buf: pointer to a VIR_UUID_STRING_BUFLEN bytes array\n *\n * Get the UUID for a domain as string. For more information about\n * UUID see RFC4122.\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainGetUUIDString(virDomainPtr domain, char *buf)\n{\n    VIR_DOMAIN_DEBUG(domain, \"buf=%p\", buf);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(buf, error);\n\n    virUUIDFormat(domain->uuid, buf);\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetID:\n * @domain: a domain object\n *\n * Get the hypervisor ID number for the domain\n *\n * Returns the domain ID number or (unsigned int) -1 in case of error\n */\nunsigned int\nvirDomainGetID(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, (unsigned int)-1);\n\n    return domain->id;\n}\n\n\n/**\n * virDomainGetOSType:\n * @domain: a domain object\n *\n * Get the type of domain operation system.\n *\n * Returns the new string or NULL in case of error, the string must be\n *         freed by the caller.\n */\nchar *\nvirDomainGetOSType(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetOSType) {\n        char *ret;\n        ret = conn->driver->domainGetOSType(domain);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainGetMaxMemory:\n * @domain: a domain object or NULL\n *\n * Retrieve the maximum amount of physical memory allocated to a\n * domain. If domain is NULL, then this get the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n *\n * Returns the memory size in kibibytes (blocks of 1024 bytes), or 0 in\n * case of error.\n */\nunsigned long\nvirDomainGetMaxMemory(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, 0);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMaxMemory) {\n        unsigned long long ret;\n        ret = conn->driver->domainGetMaxMemory(domain);\n        if (ret == 0)\n            goto error;\n        if ((unsigned long) ret != ret) {\n            virReportError(VIR_ERR_OVERFLOW, _(\"result too large: %llu\"),\n                           ret);\n            goto error;\n        }\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return 0;\n}\n\n\n/**\n * virDomainSetMaxMemory:\n * @domain: a domain object or NULL\n * @memory: the memory size in kibibytes (blocks of 1024 bytes)\n *\n * Dynamically change the maximum amount of physical memory allocated to a\n * domain. If domain is NULL, then this change the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n * This function may require privileged access to the hypervisor.\n *\n * This command is hypervisor-specific for whether active, persistent,\n * or both configurations are changed; for more control, use\n * virDomainSetMemoryFlags().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSetMaxMemory(virDomainPtr domain, unsigned long memory)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"memory=%lu\", memory);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(memory, error);\n\n    if (virMemoryMaxValue(true) / 1024 <= memory) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %lu\"),\n                       memory);\n        goto error;\n    }\n\n    if (conn->driver->domainSetMaxMemory) {\n        int ret;\n        ret = conn->driver->domainSetMaxMemory(domain, memory);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemory:\n * @domain: a domain object or NULL\n * @memory: the memory size in kibibytes (blocks of 1024 bytes)\n *\n * Dynamically change the target amount of physical memory allocated to a\n * domain. If domain is NULL, then this change the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n * This function may require privileged access to the hypervisor.\n *\n * This command is hypervisor-specific for whether active, persistent,\n * or both configurations are changed; for more control, use\n * virDomainSetMemoryFlags().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSetMemory(virDomainPtr domain, unsigned long memory)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"memory=%lu\", memory);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(memory, error);\n\n    if (virMemoryMaxValue(true) / 1024 <= memory) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %lu\"),\n                       memory);\n        goto error;\n    }\n\n    if (conn->driver->domainSetMemory) {\n        int ret;\n        ret = conn->driver->domainSetMemory(domain, memory);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemoryFlags:\n * @domain: a domain object or NULL\n * @memory: the memory size in kibibytes (blocks of 1024 bytes)\n * @flags: bitwise-OR of virDomainMemoryModFlags\n *\n * Dynamically change the target amount of physical memory allocated to a\n * domain. If domain is NULL, then this change the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects\n * a running domain and will fail if domain is not active.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified\n * (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain\n * modifies persistent setup, while an active domain is hypervisor-dependent\n * on whether just live or both live and persistent state is changed.\n * If VIR_DOMAIN_MEM_MAXIMUM is set, the change affects domain's maximum memory\n * size rather than current memory size.\n * Not all hypervisors can support all flag combinations.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetMemoryFlags(virDomainPtr domain, unsigned long memory,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"memory=%lu, flags=%x\", memory, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(memory, error);\n\n    if (virMemoryMaxValue(true) / 1024 <= memory) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %lu\"),\n                       memory);\n        goto error;\n    }\n\n    if (conn->driver->domainSetMemoryFlags) {\n        int ret;\n        ret = conn->driver->domainSetMemoryFlags(domain, memory, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemoryStatsPeriod:\n * @domain: a domain object or NULL\n * @period: the period in seconds for stats collection\n * @flags: bitwise-OR of virDomainMemoryModFlags\n *\n * Dynamically change the domain memory balloon driver statistics collection\n * period. Use 0 to disable and a positive value to enable.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects\n * a running domain and will fail if domain is not active.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified\n * (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain\n * modifies persistent setup, while an active domain is hypervisor-dependent\n * on whether just live or both live and persistent state is changed.\n *\n * Not all hypervisors can support all flag combinations.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetMemoryStatsPeriod(virDomainPtr domain, int period,\n                              unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"period=%d, flags=%x\", period, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    /* This must be positive to set the balloon collection period */\n    virCheckNonNegativeArgGoto(period, error);\n\n    if (conn->driver->domainSetMemoryStatsPeriod) {\n        int ret;\n        ret = conn->driver->domainSetMemoryStatsPeriod(domain, period, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemoryParameters:\n * @domain: pointer to domain object\n * @params: pointer to memory parameter objects\n * @nparams: number of memory parameter (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the memory tunables.\n * This function may require privileged access to the hypervisor.\n *\n * Possible values for all *_limit memory tunables are in range from 0 to\n * VIR_DOMAIN_MEMORY_PARAM_UNLIMITED.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetMemoryParameters(virDomainPtr domain,\n                             virTypedParameterPtr params,\n                             int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckPositiveArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetMemoryParameters) {\n        int ret;\n        ret = conn->driver->domainSetMemoryParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetMemoryParameters:\n * @domain: pointer to domain object\n * @params: pointer to memory parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of memory parameters; input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all memory parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.\n *\n * Here is a sample code snippet:\n *\n *   if (virDomainGetMemoryParameters(dom, NULL, &nparams, 0) == 0 &&\n *       nparams != 0) {\n *       if ((params = malloc(sizeof(*params) * nparams)) == NULL)\n *           goto error;\n *       memset(params, 0, sizeof(*params) * nparams);\n *       if (virDomainGetMemoryParameters(dom, params, &nparams, 0))\n *           goto error;\n *   }\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetMemoryParameters(virDomainPtr domain,\n                             virTypedParameterPtr params,\n                             int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMemoryParameters) {\n        int ret;\n        ret = conn->driver->domainGetMemoryParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetNumaParameters:\n * @domain: pointer to domain object\n * @params: pointer to numa parameter objects\n * @nparams: number of numa parameters (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the numa tunables.\n * This function may require privileged access to the hypervisor.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetNumaParameters(virDomainPtr domain,\n                           virTypedParameterPtr params,\n                           int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckPositiveArgGoto(nparams, error);\n    if (virTypedParameterValidateSet(domain->conn, params, nparams) < 0)\n        goto error;\n\n    conn = domain->conn;\n\n    if (conn->driver->domainSetNumaParameters) {\n        int ret;\n        ret = conn->driver->domainSetNumaParameters(domain, params, nparams,\n                                                    flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetNumaParameters:\n * @domain: pointer to domain object\n * @params: pointer to numa parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of numa parameters\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all numa parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.\n *\n * See virDomainGetMemoryParameters() for an equivalent usage example.\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetNumaParameters(virDomainPtr domain,\n                           virTypedParameterPtr params,\n                           int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetNumaParameters) {\n        int ret;\n        ret = conn->driver->domainGetNumaParameters(domain, params, nparams,\n                                                    flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetBlkioParameters:\n * @domain: pointer to domain object\n * @params: pointer to blkio parameter objects\n * @nparams: number of blkio parameters (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the blkio tunables.\n * This function may require privileged access to the hypervisor.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetBlkioParameters(virDomainPtr domain,\n                            virTypedParameterPtr params,\n                            int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetBlkioParameters) {\n        int ret;\n        ret = conn->driver->domainSetBlkioParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlkioParameters:\n * @domain: pointer to domain object\n * @params: pointer to blkio parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of blkio parameters; input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all blkio parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.\n *\n * See virDomainGetMemoryParameters() for an equivalent usage example.\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetBlkioParameters(virDomainPtr domain,\n                            virTypedParameterPtr params,\n                            int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetBlkioParameters) {\n        int ret;\n        ret = conn->driver->domainGetBlkioParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetInfo:\n * @domain: a domain object\n * @info: pointer to a virDomainInfo structure allocated by the user\n *\n * Extract information about a domain. Note that if the connection\n * used to get the domain is limited only a partial set of the information\n * can be extracted.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetInfo(virDomainPtr domain, virDomainInfoPtr info)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p\", info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetInfo) {\n        int ret;\n        ret = conn->driver->domainGetInfo(domain, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetState:\n * @domain: a domain object\n * @state: returned state of the domain (one of virDomainState)\n * @reason: returned reason which led to @state (one of virDomain*Reason\n * corresponding to the current state); it is allowed to be NULL\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract domain state. Each state can be accompanied with a reason (if known)\n * which led to the state.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetState(virDomainPtr domain,\n                  int *state,\n                  int *reason,\n                  unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"state=%p, reason=%p, flags=%x\",\n                     state, reason, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(state, error);\n\n    conn = domain->conn;\n    if (conn->driver->domainGetState) {\n        int ret;\n        ret = conn->driver->domainGetState(domain, state, reason, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetControlInfo:\n * @domain: a domain object\n * @info: pointer to a virDomainControlInfo structure allocated by the user\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract details about current state of control interface to a domain.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetControlInfo(virDomainPtr domain,\n                        virDomainControlInfoPtr info,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p, flags=%x\", info, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n    if (conn->driver->domainGetControlInfo) {\n        int ret;\n        ret = conn->driver->domainGetControlInfo(domain, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetXMLDesc:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainXMLFlags\n *\n * Provide an XML description of the domain. The description may be reused\n * later to relaunch the domain with virDomainCreateXML().\n *\n * No security-sensitive data will be included unless @flags contains\n * VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\n * connections.  If @flags includes VIR_DOMAIN_XML_INACTIVE, then the\n * XML represents the configuration that will be used on the next boot\n * of a persistent domain; otherwise, the configuration represents the\n * currently running domain.  If @flags contains\n * VIR_DOMAIN_XML_UPDATE_CPU, then the portion of the domain XML\n * describing CPU capabilities is modified to match actual\n * capabilities of the host.\n *\n * Returns a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.\n *         the caller must free() the returned value.\n */\nchar *\nvirDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if ((conn->flags & VIR_CONNECT_RO) &&\n        (flags & (VIR_DOMAIN_XML_SECURE | VIR_DOMAIN_XML_MIGRATABLE))) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"virDomainGetXMLDesc with secure flag\"));\n        goto error;\n    }\n\n    if (conn->driver->domainGetXMLDesc) {\n        char *ret;\n        ret = conn->driver->domainGetXMLDesc(domain, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virConnectDomainXMLFromNative:\n * @conn: a connection object\n * @nativeFormat: configuration format importing from\n * @nativeConfig: the configuration data to import\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Reads native configuration data  describing a domain, and\n * generates libvirt domain XML. The format of the native\n * data is hypervisor dependent.\n *\n * Returns a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.\n *         the caller must free() the returned value.\n */\nchar *\nvirConnectDomainXMLFromNative(virConnectPtr conn,\n                              const char *nativeFormat,\n                              const char *nativeConfig,\n                              unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, format=%s, config=%s, flags=%x\",\n              conn, NULLSTR(nativeFormat), NULLSTR(nativeConfig), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    virCheckNonNullArgGoto(nativeFormat, error);\n    virCheckNonNullArgGoto(nativeConfig, error);\n\n    if (conn->driver->connectDomainXMLFromNative) {\n        char *ret;\n        ret = conn->driver->connectDomainXMLFromNative(conn,\n                                                       nativeFormat,\n                                                       nativeConfig,\n                                                       flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virConnectDomainXMLToNative:\n * @conn: a connection object\n * @nativeFormat: configuration format exporting to\n * @domainXml: the domain configuration to export\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Reads a domain XML configuration document, and generates\n * a native configuration file describing the domain.\n * The format of the native data is hypervisor dependent.\n *\n * Returns a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error.\n *         the caller must free() the returned value.\n */\nchar *\nvirConnectDomainXMLToNative(virConnectPtr conn,\n                            const char *nativeFormat,\n                            const char *domainXml,\n                            unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, format=%s, xml=%s, flags=%x\",\n              conn, NULLSTR(nativeFormat), NULLSTR(domainXml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    virCheckNonNullArgGoto(nativeFormat, error);\n    virCheckNonNullArgGoto(domainXml, error);\n\n    if (conn->driver->connectDomainXMLToNative) {\n        char *ret;\n        ret = conn->driver->connectDomainXMLToNative(conn,\n                                                     nativeFormat,\n                                                     domainXml,\n                                                     flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/*\n * Sequence v1:\n *\n *  Dst: Prepare\n *        - Get ready to accept incoming VM\n *        - Generate optional cookie to pass to src\n *\n *  Src: Perform\n *        - Start migration and wait for send completion\n *        - Kill off VM if successful, resume if failed\n *\n *  Dst: Finish\n *        - Wait for recv completion and check status\n *        - Kill off VM if unsuccessful\n *\n */\nstatic virDomainPtr\nvirDomainMigrateVersion1(virDomainPtr domain,\n                         virConnectPtr dconn,\n                         unsigned long flags,\n                         const char *dname,\n                         const char *uri,\n                         unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    int cookielen = 0, ret;\n    virDomainInfo info;\n    unsigned int destflags;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    ret = virDomainGetInfo(domain, &info);\n    if (ret == 0 && info.state == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    /* Prepare the migration.\n     *\n     * The destination host may return a cookie, or leave cookie as\n     * NULL.\n     *\n     * The destination host MUST set uri_out if uri_in is NULL.\n     *\n     * If uri_in is non-NULL, then the destination host may modify\n     * the URI by setting uri_out.  If it does not wish to modify\n     * the URI, it should leave uri_out as NULL.\n     */\n    if (dconn->driver->domainMigratePrepare\n        (dconn, &cookie, &cookielen, uri, &uri_out, destflags, dname,\n         bandwidth) == -1)\n        goto done;\n\n    if (uri == NULL && uri_out == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare did not set uri\"));\n        goto done;\n    }\n    if (uri_out)\n        uri = uri_out; /* Did domainMigratePrepare change URI? */\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    if (domain->conn->driver->domainMigratePerform\n        (domain, cookie, cookielen, uri, flags, dname, bandwidth) == -1)\n        goto done;\n\n    /* Get the destination domain and return it or error.\n     * 'domain' no longer actually exists at this point\n     * (or so we hope), but we still use the object in memory\n     * in order to get the name.\n     */\n    dname = dname ? dname : domain->name;\n    if (dconn->driver->domainMigrateFinish)\n        ddomain = dconn->driver->domainMigrateFinish\n            (dconn, dname, cookie, cookielen, uri, destflags);\n    else\n        ddomain = virDomainLookupByName(dconn, dname);\n\n done:\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n    return ddomain;\n}\n\n\n/*\n * Sequence v2:\n *\n *  Src: DumpXML\n *        - Generate XML to pass to dst\n *\n *  Dst: Prepare\n *        - Get ready to accept incoming VM\n *        - Generate optional cookie to pass to src\n *\n *  Src: Perform\n *        - Start migration and wait for send completion\n *        - Kill off VM if successful, resume if failed\n *\n *  Dst: Finish\n *        - Wait for recv completion and check status\n *        - Kill off VM if unsuccessful\n *\n */\nstatic virDomainPtr\nvirDomainMigrateVersion2(virDomainPtr domain,\n                         virConnectPtr dconn,\n                         unsigned long flags,\n                         const char *dname,\n                         const char *uri,\n                         unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    char *dom_xml = NULL;\n    int cookielen = 0, ret;\n    virDomainInfo info;\n    virErrorPtr orig_err = NULL;\n    unsigned int getxml_flags = 0;\n    int cancelled;\n    unsigned long destflags;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    /* Prepare the migration.\n     *\n     * The destination host may return a cookie, or leave cookie as\n     * NULL.\n     *\n     * The destination host MUST set uri_out if uri_in is NULL.\n     *\n     * If uri_in is non-NULL, then the destination host may modify\n     * the URI by setting uri_out.  If it does not wish to modify\n     * the URI, it should leave uri_out as NULL.\n     */\n\n    /* In version 2 of the protocol, the prepare step is slightly\n     * different.  We fetch the domain XML of the source domain\n     * and pass it to Prepare2.\n     */\n    if (!domain->conn->driver->domainGetXMLDesc) {\n        virReportUnsupportedError();\n        return NULL;\n    }\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_XML_MIGRATABLE)) {\n        getxml_flags |= VIR_DOMAIN_XML_MIGRATABLE;\n    } else {\n        getxml_flags |= VIR_DOMAIN_XML_SECURE | VIR_DOMAIN_XML_UPDATE_CPU;\n    }\n\n    dom_xml = domain->conn->driver->domainGetXMLDesc(domain, getxml_flags);\n    if (!dom_xml)\n        return NULL;\n\n    ret = virDomainGetInfo(domain, &info);\n    if (ret == 0 && info.state == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare2 %p flags=%lx\", dconn, destflags);\n    ret = dconn->driver->domainMigratePrepare2\n        (dconn, &cookie, &cookielen, uri, &uri_out, destflags, dname,\n         bandwidth, dom_xml);\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto done;\n\n    if (uri == NULL && uri_out == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare2 did not set uri\"));\n        cancelled = 1;\n        /* Make sure Finish doesn't overwrite the error */\n        orig_err = virSaveLastError();\n        goto finish;\n    }\n    if (uri_out)\n        uri = uri_out; /* Did domainMigratePrepare2 change URI? */\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    VIR_DEBUG(\"Perform %p\", domain->conn);\n    ret = domain->conn->driver->domainMigratePerform\n        (domain, cookie, cookielen, uri, flags, dname, bandwidth);\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0)\n        orig_err = virSaveLastError();\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0 ? 1 : 0;\n\n finish:\n    /* In version 2 of the migration protocol, we pass the\n     * status code from the sender to the destination host,\n     * so it can do any cleanup if the migration failed.\n     */\n    dname = dname ? dname : domain->name;\n    VIR_DEBUG(\"Finish2 %p ret=%d\", dconn, ret);\n    ddomain = dconn->driver->domainMigrateFinish2\n        (dconn, dname, cookie, cookielen, uri, destflags, cancelled);\n    if (cancelled && ddomain)\n        VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n\n done:\n    if (orig_err) {\n        virSetError(orig_err);\n        virFreeError(orig_err);\n    }\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n    return ddomain;\n}\n\n\n/*\n * Sequence v3:\n *\n *  Src: Begin\n *        - Generate XML to pass to dst\n *        - Generate optional cookie to pass to dst\n *\n *  Dst: Prepare\n *        - Get ready to accept incoming VM\n *        - Generate optional cookie to pass to src\n *\n *  Src: Perform\n *        - Start migration and wait for send completion\n *        - Generate optional cookie to pass to dst\n *\n *  Dst: Finish\n *        - Wait for recv completion and check status\n *        - Kill off VM if failed, resume if success\n *        - Generate optional cookie to pass to src\n *\n *  Src: Confirm\n *        - Kill off VM if success, resume if failed\n *\n  * If useParams is true, params and nparams contain migration parameters and\n  * we know it's safe to call the API which supports extensible parameters.\n  * Otherwise, we have to use xmlin, dname, uri, and bandwidth and pass them\n  * to the old-style APIs.\n */\nstatic virDomainPtr\nvirDomainMigrateVersion3Full(virDomainPtr domain,\n                             virConnectPtr dconn,\n                             const char *xmlin,\n                             const char *dname,\n                             const char *uri,\n                             unsigned long long bandwidth,\n                             virTypedParameterPtr params,\n                             int nparams,\n                             bool useParams,\n                             unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookiein = NULL;\n    char *cookieout = NULL;\n    char *dom_xml = NULL;\n    int cookieinlen = 0;\n    int cookieoutlen = 0;\n    int ret;\n    virDomainInfo info;\n    virErrorPtr orig_err = NULL;\n    int cancelled = 1;\n    unsigned long protection = 0;\n    bool notify_source = true;\n    unsigned int destflags;\n    int state;\n    virTypedParameterPtr tmp;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, xmlin=%s, dname=%s, uri=%s, bandwidth=%llu, \"\n                     \"params=%p, nparams=%d, useParams=%d, flags=%x\",\n                     dconn, NULLSTR(xmlin), NULLSTR(dname), NULLSTR(uri),\n                     bandwidth, params, nparams, useParams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    if ((!useParams &&\n         (!domain->conn->driver->domainMigrateBegin3 ||\n          !domain->conn->driver->domainMigratePerform3 ||\n          !domain->conn->driver->domainMigrateConfirm3 ||\n          !dconn->driver->domainMigratePrepare3 ||\n          !dconn->driver->domainMigrateFinish3)) ||\n        (useParams &&\n         (!domain->conn->driver->domainMigrateBegin3Params ||\n          !domain->conn->driver->domainMigratePerform3Params ||\n          !domain->conn->driver->domainMigrateConfirm3Params ||\n          !dconn->driver->domainMigratePrepare3Params ||\n          !dconn->driver->domainMigrateFinish3Params))) {\n        virReportUnsupportedError();\n        return NULL;\n    }\n\n    if (virTypedParamsCopy(&tmp, params, nparams) < 0)\n        return NULL;\n    params = tmp;\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION))\n        protection = VIR_MIGRATE_CHANGE_PROTECTION;\n\n    VIR_DEBUG(\"Begin3 %p\", domain->conn);\n    if (useParams) {\n        dom_xml = domain->conn->driver->domainMigrateBegin3Params\n            (domain, params, nparams, &cookieout, &cookieoutlen,\n             flags | protection);\n    } else {\n        dom_xml = domain->conn->driver->domainMigrateBegin3\n            (domain, xmlin, &cookieout, &cookieoutlen,\n             flags | protection, dname, bandwidth);\n    }\n    if (!dom_xml)\n        goto done;\n\n    if (useParams) {\n        /* If source is new enough to support extensible migration parameters,\n         * it's certainly new enough to support virDomainGetState. */\n        ret = virDomainGetState(domain, &state, NULL, 0);\n    } else {\n        ret = virDomainGetInfo(domain, &info);\n        state = info.state;\n    }\n    if (ret == 0 && state == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare3 %p flags=%x\", dconn, destflags);\n    cookiein = cookieout;\n    cookieinlen = cookieoutlen;\n    cookieout = NULL;\n    cookieoutlen = 0;\n    if (useParams) {\n        if (virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_XML,\n                                        dom_xml) < 0)\n            goto done;\n        ret = dconn->driver->domainMigratePrepare3Params\n            (dconn, params, nparams, cookiein, cookieinlen,\n             &cookieout, &cookieoutlen, &uri_out, destflags);\n    } else {\n        ret = dconn->driver->domainMigratePrepare3\n            (dconn, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             uri, &uri_out, destflags, dname, bandwidth, dom_xml);\n    }\n    if (ret == -1) {\n        if (protection) {\n            /* Begin already started a migration job so we need to cancel it by\n             * calling Confirm while making sure it doesn't overwrite the error\n             */\n            orig_err = virSaveLastError();\n            goto confirm;\n        } else {\n            goto done;\n        }\n    }\n\n    /* Did domainMigratePrepare3 change URI? */\n    if (uri_out) {\n        uri = uri_out;\n        if (useParams &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_URI,\n                                        uri_out) < 0) {\n            cancelled = 1;\n            orig_err = virSaveLastError();\n            goto finish;\n        }\n    } else if (!uri &&\n               virTypedParamsGetString(params, nparams,\n                                       VIR_MIGRATE_PARAM_URI, &uri) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare3 did not set uri\"));\n        cancelled = 1;\n        orig_err = virSaveLastError();\n        goto finish;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        VIR_DEBUG(\"Offline migration, skipping Perform phase\");\n        VIR_FREE(cookieout);\n        cookieoutlen = 0;\n        cancelled = 0;\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete. The src VM should remain\n     * running, but in paused state until the destination can\n     * confirm migration completion.\n     */\n    VIR_DEBUG(\"Perform3 %p uri=%s\", domain->conn, uri);\n    VIR_FREE(cookiein);\n    cookiein = cookieout;\n    cookieinlen = cookieoutlen;\n    cookieout = NULL;\n    cookieoutlen = 0;\n    /* dconnuri not relevant in non-P2P modes, so left NULL here */\n    if (useParams) {\n        ret = domain->conn->driver->domainMigratePerform3Params\n            (domain, NULL, params, nparams, cookiein, cookieinlen,\n             &cookieout, &cookieoutlen, flags | protection);\n    } else {\n        ret = domain->conn->driver->domainMigratePerform3\n            (domain, NULL, cookiein, cookieinlen,\n             &cookieout, &cookieoutlen, NULL,\n             uri, flags | protection, dname, bandwidth);\n    }\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0) {\n        orig_err = virSaveLastError();\n        /* Perform failed so we don't need to call confirm to let source know\n         * about the failure.\n         */\n        notify_source = false;\n    }\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0 ? 1 : 0;\n\n finish:\n    /*\n     * The status code from the source is passed to the destination.\n     * The dest can cleanup if the source indicated it failed to\n     * send all migration data. Returns NULL for ddomain if\n     * the dest was unable to complete migration.\n     */\n    VIR_DEBUG(\"Finish3 %p ret=%d\", dconn, ret);\n    VIR_FREE(cookiein);\n    cookiein = cookieout;\n    cookieinlen = cookieoutlen;\n    cookieout = NULL;\n    cookieoutlen = 0;\n    if (useParams) {\n        if (virTypedParamsGetString(params, nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_NAME,\n                                        domain->name) < 0) {\n            ddomain = NULL;\n        } else {\n            ddomain = dconn->driver->domainMigrateFinish3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags, cancelled);\n        }\n    } else {\n        dname = dname ? dname : domain->name;\n        ddomain = dconn->driver->domainMigrateFinish3\n            (dconn, dname, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             NULL, uri, destflags, cancelled);\n    }\n\n    if (cancelled) {\n        if (ddomain) {\n            VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n        } else {\n            /* If Finish reported a useful error, use it instead of the\n             * original \"migration unexpectedly failed\" error.\n             *\n             * This is ugly but we can't do better with the APIs we have. We\n             * only replace the error if Finish was called with cancelled == 1\n             * and reported a real error (old libvirt would report an error\n             * from RPC instead of MIGRATE_FINISH_OK), which only happens when\n             * the domain died on destination. To further reduce a possibility\n             * of false positives we also check that Perform returned\n             * VIR_ERR_OPERATION_FAILED.\n             */\n            if (orig_err &&\n                orig_err->domain == VIR_FROM_QEMU &&\n                orig_err->code == VIR_ERR_OPERATION_FAILED) {\n                virErrorPtr err = virGetLastError();\n                if (err &&\n                    err->domain == VIR_FROM_QEMU &&\n                    err->code != VIR_ERR_MIGRATE_FINISH_OK) {\n                    virFreeError(orig_err);\n                    orig_err = NULL;\n                }\n            }\n        }\n    }\n\n    /* If ddomain is NULL, then we were unable to start\n     * the guest on the target, and must restart on the\n     * source. There is a small chance that the ddomain\n     * is NULL due to an RPC failure, in which case\n     * ddomain could in fact be running on the dest.\n     * The lock manager plugins should take care of\n     * safety in this scenario.\n     */\n    cancelled = ddomain == NULL ? 1 : 0;\n\n    /* If finish3 set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        orig_err = virSaveLastError();\n\n confirm:\n    /*\n     * If cancelled, then src VM will be restarted, else it will be killed.\n     * Don't do this if migration failed on source and thus it was already\n     * cancelled there.\n     */\n    if (notify_source) {\n        VIR_DEBUG(\"Confirm3 %p ret=%d domain=%p\", domain->conn, ret, domain);\n        VIR_FREE(cookiein);\n        cookiein = cookieout;\n        cookieinlen = cookieoutlen;\n        cookieout = NULL;\n        cookieoutlen = 0;\n        if (useParams) {\n            ret = domain->conn->driver->domainMigrateConfirm3Params\n                (domain, params, nparams, cookiein, cookieinlen,\n                 flags | protection, cancelled);\n        } else {\n            ret = domain->conn->driver->domainMigrateConfirm3\n                (domain, cookiein, cookieinlen,\n                 flags | protection, cancelled);\n        }\n        /* If Confirm3 returns -1, there's nothing more we can\n         * do, but fortunately worst case is that there is a\n         * domain left in 'paused' state on source.\n         */\n        if (ret < 0) {\n            VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                     domain->name);\n        }\n    }\n\n done:\n    if (orig_err) {\n        virSetError(orig_err);\n        virFreeError(orig_err);\n    }\n    VIR_FREE(dom_xml);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookiein);\n    VIR_FREE(cookieout);\n    virTypedParamsFree(params, nparams);\n    return ddomain;\n}\n\n\nstatic virDomainPtr\nvirDomainMigrateVersion3(virDomainPtr domain,\n                         virConnectPtr dconn,\n                         const char *xmlin,\n                         unsigned long flags,\n                         const char *dname,\n                         const char *uri,\n                         unsigned long bandwidth)\n{\n    return virDomainMigrateVersion3Full(domain, dconn, xmlin, dname, uri,\n                                        bandwidth, NULL, 0, false, flags);\n}\n\n\nstatic virDomainPtr\nvirDomainMigrateVersion3Params(virDomainPtr domain,\n                               virConnectPtr dconn,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               unsigned int flags)\n{\n    return virDomainMigrateVersion3Full(domain, dconn, NULL, NULL, NULL, 0,\n                                        params, nparams, true, flags);\n}\n\n\nstatic int\nvirDomainMigrateCheckNotLocal(const char *dconnuri)\n{\n    virURIPtr tempuri = NULL;\n    int ret = -1;\n\n    if (!(tempuri = virURIParse(dconnuri)))\n        goto cleanup;\n    if (!tempuri->server || STRPREFIX(tempuri->server, \"localhost\")) {\n        virReportInvalidArg(dconnuri, \"%s\",\n                            _(\"Attempt to migrate guest to the same host\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virURIFree(tempuri);\n    return ret;\n}\n\n\nstatic int\nvirDomainMigrateUnmanagedProto2(virDomainPtr domain,\n                                const char *dconnuri,\n                                virTypedParameterPtr params,\n                                int nparams,\n                                unsigned int flags)\n{\n    /* uri parameter is added for direct case */\n    const char *compatParams[] = { VIR_MIGRATE_PARAM_DEST_NAME,\n                                   VIR_MIGRATE_PARAM_BANDWIDTH,\n                                   VIR_MIGRATE_PARAM_URI };\n    const char *uri = NULL;\n    const char *miguri = NULL;\n    const char *dname = NULL;\n    unsigned long long bandwidth = 0;\n\n    if (!virTypedParamsCheck(params, nparams, compatParams,\n                             ARRAY_CARDINALITY(compatParams))) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Some parameters are not supported by migration \"\n                         \"protocol 2\"));\n        return -1;\n    }\n\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_URI, &miguri) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, &dname) < 0 ||\n        virTypedParamsGetULLong(params, nparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, &bandwidth) < 0) {\n        return -1;\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (miguri) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to override peer2peer migration URI\"));\n            return -1;\n        }\n        uri = dconnuri;\n    } else {\n        uri = miguri;\n    }\n\n    return domain->conn->driver->domainMigratePerform\n            (domain, NULL, 0, uri, flags, dname, bandwidth);\n}\n\n\nstatic int\nvirDomainMigrateUnmanagedProto3(virDomainPtr domain,\n                                const char *dconnuri,\n                                virTypedParameterPtr params,\n                                int nparams,\n                                unsigned int flags)\n{\n    const char *compatParams[] = { VIR_MIGRATE_PARAM_URI,\n                                   VIR_MIGRATE_PARAM_DEST_NAME,\n                                   VIR_MIGRATE_PARAM_DEST_XML,\n                                   VIR_MIGRATE_PARAM_BANDWIDTH };\n    const char *miguri = NULL;\n    const char *dname = NULL;\n    const char *xmlin = NULL;\n    unsigned long long bandwidth = 0;\n\n    if (!virTypedParamsCheck(params, nparams, compatParams,\n                             ARRAY_CARDINALITY(compatParams))) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Some parameters are not supported by migration \"\n                         \"protocol 3\"));\n        return -1;\n    }\n\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_URI, &miguri) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, &dname) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, &xmlin) < 0 ||\n        virTypedParamsGetULLong(params, nparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, &bandwidth) < 0) {\n        return -1;\n    }\n\n    return domain->conn->driver->domainMigratePerform3\n            (domain, xmlin, NULL, 0, NULL, NULL, dconnuri,\n             miguri, flags, dname, bandwidth);\n}\n\n\n/*\n * In normal migration, the libvirt client co-ordinates communication\n * between the 2 libvirtd instances on source & dest hosts.\n *\n * This function encapsulates 2 alternatives to the above case.\n *\n * 1. peer-2-peer migration, the libvirt client only talks to the source\n * libvirtd instance. The source libvirtd then opens its own\n * connection to the destination and co-ordinates migration itself.\n *\n * 2. direct migration, where there is no requirement for a libvirtd instance\n * on the dest host. Eg, XenD can talk direct to XenD, so libvirtd on dest\n * does not need to be involved at all, or even running.\n */\nstatic int\nvirDomainMigrateUnmanagedParams(virDomainPtr domain,\n                                const char *dconnuri,\n                                virTypedParameterPtr params,\n                                int nparams,\n                                unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, params=%p, nparams=%d, flags=%x\",\n                     NULLSTR(dconnuri), params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    if ((flags & VIR_MIGRATE_PEER2PEER) &&\n        virDomainMigrateCheckNotLocal(dconnuri) < 0)\n        return -1;\n\n    if ((flags & VIR_MIGRATE_PEER2PEER) &&\n        VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATION_PARAMS)) {\n        VIR_DEBUG(\"Using migration protocol 3 with extensible parameters\");\n        if (!domain->conn->driver->domainMigratePerform3Params) {\n            virReportUnsupportedError();\n            return -1;\n        }\n        return domain->conn->driver->domainMigratePerform3Params\n                (domain, dconnuri, params, nparams,\n                 NULL, 0, NULL, NULL, flags);\n    } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                        VIR_DRV_FEATURE_MIGRATION_V3)) {\n        VIR_DEBUG(\"Using migration protocol 3\");\n        if (!domain->conn->driver->domainMigratePerform3) {\n            virReportUnsupportedError();\n            return -1;\n        }\n        return virDomainMigrateUnmanagedProto3(domain, dconnuri,\n                                               params, nparams, flags);\n    } else {\n        VIR_DEBUG(\"Using migration protocol 2\");\n        if (!domain->conn->driver->domainMigratePerform) {\n            virReportUnsupportedError();\n            return -1;\n        }\n        return virDomainMigrateUnmanagedProto2(domain, dconnuri,\n                                               params, nparams, flags);\n    }\n}\n\n\nstatic int\nvirDomainMigrateUnmanaged(virDomainPtr domain,\n                          const char *xmlin,\n                          unsigned int flags,\n                          const char *dname,\n                          const char *dconnuri,\n                          const char *miguri,\n                          unsigned long long bandwidth)\n{\n    int ret = -1;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n\n    if (miguri &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_URI, miguri) < 0)\n        goto cleanup;\n    if (dname &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n        goto cleanup;\n    if (xmlin &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, xmlin) < 0)\n        goto cleanup;\n    if (virTypedParamsAddULLong(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, bandwidth) < 0)\n        goto cleanup;\n\n    ret = virDomainMigrateUnmanagedParams(domain, dconnuri, params,\n                                          nparams, flags);\n\n cleanup:\n    virTypedParamsFree(params, nparams);\n\n    return ret;\n}\n\n\n/**\n * virDomainMigrate:\n * @domain: a domain object\n * @dconn: destination host (a connection object)\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dname: (optional) rename domain to this at destination\n * @uri: (optional) dest hostname/URI as seen from the source host\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by dconn (a connection to the destination host).\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n * Applications using the VIR_MIGRATE_PEER2PEER flag will probably\n * prefer to invoke virDomainMigrateToURI, avoiding the need to\n * open connection to the destination host themselves.\n *\n * If a hypervisor supports renaming domains during migration,\n * then you may set the dname parameter to the new name (otherwise\n * it keeps the same name).  If this is not supported by the\n * hypervisor, dname must be NULL or else you will get an error.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the uri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt. If\n * omitted, the dconn connection object will be queried for its\n * current URI.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, the URI parameter\n * takes a hypervisor specific format. The hypervisor capabilities\n * XML includes details of the support URI schemes. If omitted\n * the dconn will be asked for a default URI.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * In either case it is typically only necessary to specify a\n * URI if the destination host has multiple interfaces and a\n * specific interface is required to transmit migration data.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * virDomainFree should be used to free the resources after the\n * returned domain object is no longer needed.\n *\n * Returns the new domain object if the migration was successful,\n *   or NULL in case of error.  Note that the new domain object\n *   exists in the scope of the destination connection (dconn).\n */\nvirDomainPtr\nvirDomainMigrate(virDomainPtr domain,\n                 virConnectPtr dconn,\n                 unsigned long flags,\n                 const char *dname,\n                 const char *uri,\n                 unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, NULL);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    /* Now checkout the destination */\n    virCheckConnectGoto(dconn, error);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MIGRATE_NON_SHARED_DISK,\n                             VIR_MIGRATE_NON_SHARED_INC,\n                             error);\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the source host\"));\n            goto error;\n        }\n        if (!VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the destination host\"));\n            goto error;\n        }\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_P2P)) {\n            char *dstURI = NULL;\n            if (uri == NULL) {\n                dstURI = virConnectGetURI(dconn);\n                if (!dstURI)\n                    return NULL;\n            }\n\n            VIR_DEBUG(\"Using peer2peer migration\");\n            if (virDomainMigrateUnmanaged(domain, NULL, flags, dname,\n                                          uri ? uri : dstURI, NULL, bandwidth) < 0) {\n                VIR_FREE(dstURI);\n                goto error;\n            }\n            VIR_FREE(dstURI);\n\n            ddomain = virDomainLookupByName(dconn, dname ? dname : domain->name);\n        } else {\n            /* This driver does not support peer to peer migration */\n            virReportUnsupportedError();\n            goto error;\n        }\n    } else {\n        /* Change protection requires support only on source side, and\n         * is only needed in v3 migration, which automatically re-adds\n         * the flag for just the source side.  We mask it out for\n         * non-peer2peer to allow migration from newer source to an\n         * older destination that rejects the flag.  */\n        if (flags & VIR_MIGRATE_CHANGE_PROTECTION &&\n            !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"cannot enforce change protection\"));\n            goto error;\n        }\n        flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot perform tunnelled migration without using peer2peer flag\"));\n            goto error;\n        }\n\n        /* Check that migration is supported by both drivers. */\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3) &&\n            VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3)) {\n            VIR_DEBUG(\"Using migration protocol 3\");\n            ddomain = virDomainMigrateVersion3(domain, dconn, NULL,\n                                               flags, dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V2) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                          VIR_DRV_FEATURE_MIGRATION_V2)) {\n            VIR_DEBUG(\"Using migration protocol 2\");\n            ddomain = virDomainMigrateVersion2(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1)) {\n            VIR_DEBUG(\"Using migration protocol 1\");\n            ddomain = virDomainMigrateVersion1(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else {\n            /* This driver does not support any migration method */\n            virReportUnsupportedError();\n            goto error;\n        }\n    }\n\n    if (ddomain == NULL)\n        goto error;\n\n    return ddomain;\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainMigrate2:\n * @domain: a domain object\n * @dconn: destination host (a connection object)\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dxml: (optional) XML config for launching guest on target\n * @dname: (optional) rename domain to this at destination\n * @uri: (optional) dest hostname/URI as seen from the source host\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by dconn (a connection to the destination host).\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n * Applications using the VIR_MIGRATE_PEER2PEER flag will probably\n * prefer to invoke virDomainMigrateToURI, avoiding the need to\n * open connection to the destination host themselves.\n *\n * If a hypervisor supports renaming domains during migration,\n * then you may set the dname parameter to the new name (otherwise\n * it keeps the same name).  If this is not supported by the\n * hypervisor, dname must be NULL or else you will get an error.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the uri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt. If\n * omitted, the dconn connection object will be queried for its\n * current URI.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, the URI parameter\n * takes a hypervisor specific format. The hypervisor capabilities\n * XML includes details of the support URI schemes. If omitted\n * the dconn will be asked for a default URI.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * In either case it is typically only necessary to specify a\n * URI if the destination host has multiple interfaces and a\n * specific interface is required to transmit migration data.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * If the hypervisor supports it, @dxml can be used to alter\n * host-specific portions of the domain XML that will be used on\n * the destination.  For example, it is possible to alter the\n * backing filename that is associated with a disk device, in order\n * to account for naming differences between source and destination\n * in accessing the underlying storage.  The migration will fail\n * if @dxml would cause any guest-visible changes.  Pass NULL\n * if no changes are needed to the XML between source and destination.\n * @dxml cannot be used to rename the domain during migration (use\n * @dname for that purpose).  Domain name in @dxml must match the\n * original domain name.\n *\n * virDomainFree should be used to free the resources after the\n * returned domain object is no longer needed.\n *\n * Returns the new domain object if the migration was successful,\n *   or NULL in case of error.  Note that the new domain object\n *   exists in the scope of the destination connection (dconn).\n */\nvirDomainPtr\nvirDomainMigrate2(virDomainPtr domain,\n                  virConnectPtr dconn,\n                  const char *dxml,\n                  unsigned long flags,\n                  const char *dname,\n                  const char *uri,\n                  unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, NULL);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    /* Now checkout the destination */\n    virCheckConnectGoto(dconn, error);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MIGRATE_NON_SHARED_DISK,\n                             VIR_MIGRATE_NON_SHARED_INC,\n                             error);\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the source host\"));\n            goto error;\n        }\n        if (!VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the destination host\"));\n            goto error;\n        }\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_P2P)) {\n            char *dstURI = virConnectGetURI(dconn);\n            if (!dstURI)\n                return NULL;\n\n            VIR_DEBUG(\"Using peer2peer migration\");\n            if (virDomainMigrateUnmanaged(domain, dxml, flags, dname,\n                                          dstURI, uri, bandwidth) < 0) {\n                VIR_FREE(dstURI);\n                goto error;\n            }\n            VIR_FREE(dstURI);\n\n            ddomain = virDomainLookupByName(dconn, dname ? dname : domain->name);\n        } else {\n            /* This driver does not support peer to peer migration */\n            virReportUnsupportedError();\n            goto error;\n        }\n    } else {\n        /* Change protection requires support only on source side, and\n         * is only needed in v3 migration, which automatically re-adds\n         * the flag for just the source side.  We mask it out for\n         * non-peer2peer to allow migration from newer source to an\n         * older destination that rejects the flag.  */\n        if (flags & VIR_MIGRATE_CHANGE_PROTECTION &&\n            !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"cannot enforce change protection\"));\n            goto error;\n        }\n        flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot perform tunnelled migration without using peer2peer flag\"));\n            goto error;\n        }\n\n        /* Check that migration is supported by both drivers. */\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3) &&\n            VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3)) {\n            VIR_DEBUG(\"Using migration protocol 3\");\n            ddomain = virDomainMigrateVersion3(domain, dconn, dxml,\n                                               flags, dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V2) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                          VIR_DRV_FEATURE_MIGRATION_V2)) {\n            VIR_DEBUG(\"Using migration protocol 2\");\n            if (dxml) {\n                virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                               _(\"Unable to change target guest XML during migration\"));\n                goto error;\n            }\n            ddomain = virDomainMigrateVersion2(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1)) {\n            VIR_DEBUG(\"Using migration protocol 1\");\n            if (dxml) {\n                virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                               _(\"Unable to change target guest XML during migration\"));\n                goto error;\n            }\n            ddomain = virDomainMigrateVersion1(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else {\n            /* This driver does not support any migration method */\n            virReportUnsupportedError();\n            goto error;\n        }\n    }\n\n    if (ddomain == NULL)\n        goto error;\n\n    return ddomain;\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainMigrate3:\n * @domain: a domain object\n * @dconn: destination host (a connection object)\n * @params: (optional) migration parameters\n * @nparams: (optional) number of migration parameters in @params\n * @flags: bitwise-OR of virDomainMigrateFlags\n *\n * Migrate the domain object from its current host to the destination host\n * given by dconn (a connection to the destination host).\n *\n * See virDomainMigrateFlags documentation for description of individual flags.\n *\n * VIR_MIGRATE_TUNNELLED and VIR_MIGRATE_PEER2PEER are not supported by this\n * API, use virDomainMigrateToURI3 instead.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * virDomainFree should be used to free the resources after the\n * returned domain object is no longer needed.\n *\n * Returns the new domain object if the migration was successful,\n *   or NULL in case of error.  Note that the new domain object\n *   exists in the scope of the destination connection (dconn).\n */\nvirDomainPtr\nvirDomainMigrate3(virDomainPtr domain,\n                  virConnectPtr dconn,\n                  virTypedParameterPtr params,\n                  unsigned int nparams,\n                  unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    const char *compatParams[] = { VIR_MIGRATE_PARAM_URI,\n                                   VIR_MIGRATE_PARAM_DEST_NAME,\n                                   VIR_MIGRATE_PARAM_DEST_XML,\n                                   VIR_MIGRATE_PARAM_BANDWIDTH };\n    const char *uri = NULL;\n    const char *dname = NULL;\n    const char *dxml = NULL;\n    unsigned long long bandwidth = 0;\n\n    VIR_DOMAIN_DEBUG(domain, \"dconn=%p, params=%p, nparms=%u flags=%x\",\n                     dconn, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, NULL);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    /* Now checkout the destination */\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MIGRATE_NON_SHARED_DISK,\n                             VIR_MIGRATE_NON_SHARED_INC,\n                             error);\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        virReportInvalidArg(flags, \"%s\",\n                            _(\"use virDomainMigrateToURI3 for peer-to-peer \"\n                              \"migration\"));\n        goto error;\n    }\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        virReportInvalidArg(flags, \"%s\",\n                            _(\"cannot perform tunnelled migration \"\n                              \"without using peer2peer flag\"));\n        goto error;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the source host\"));\n            goto error;\n        }\n        if (!VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the destination host\"));\n            goto error;\n        }\n    }\n\n    /* Change protection requires support only on source side, and\n     * is only needed in v3 migration, which automatically re-adds\n     * the flag for just the source side.  We mask it out to allow\n     * migration from newer source to an older destination that\n     * rejects the flag.  */\n    if (flags & VIR_MIGRATE_CHANGE_PROTECTION &&\n        !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                  VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"cannot enforce change protection\"));\n        goto error;\n    }\n    flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n\n    /* Prefer extensible API but fall back to older migration APIs if params\n     * only contains parameters which were supported by the older API. */\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATION_PARAMS) &&\n        VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                 VIR_DRV_FEATURE_MIGRATION_PARAMS)) {\n        VIR_DEBUG(\"Using migration protocol 3 with extensible parameters\");\n        ddomain = virDomainMigrateVersion3Params(domain, dconn, params,\n                                                 nparams, flags);\n        goto done;\n    }\n\n    if (!virTypedParamsCheck(params, nparams, compatParams,\n                             ARRAY_CARDINALITY(compatParams))) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Migration APIs with extensible parameters are not \"\n                         \"supported but extended parameters were passed\"));\n        goto error;\n    }\n\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_URI, &uri) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, &dname) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, &dxml) < 0 ||\n        virTypedParamsGetULLong(params, nparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, &bandwidth) < 0) {\n        goto error;\n    }\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATION_V3) &&\n        VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                 VIR_DRV_FEATURE_MIGRATION_V3)) {\n        VIR_DEBUG(\"Using migration protocol 3\");\n        ddomain = virDomainMigrateVersion3(domain, dconn, dxml, flags,\n                                           dname, uri, bandwidth);\n    } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                        VIR_DRV_FEATURE_MIGRATION_V2) &&\n               VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_V2)) {\n        VIR_DEBUG(\"Using migration protocol 2\");\n        if (dxml) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"Unable to change target guest XML during \"\n                             \"migration\"));\n            goto error;\n        }\n        ddomain = virDomainMigrateVersion2(domain, dconn, flags,\n                                           dname, uri, bandwidth);\n    } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                        VIR_DRV_FEATURE_MIGRATION_V1) &&\n               VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                        VIR_DRV_FEATURE_MIGRATION_V1)) {\n        VIR_DEBUG(\"Using migration protocol 1\");\n        if (dxml) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"Unable to change target guest XML during \"\n                             \"migration\"));\n            goto error;\n        }\n        ddomain = virDomainMigrateVersion1(domain, dconn, flags,\n                                           dname, uri, bandwidth);\n    } else {\n        /* This driver does not support any migration method */\n        virReportUnsupportedError();\n        goto error;\n    }\n\n done:\n    if (ddomain == NULL)\n        goto error;\n\n    return ddomain;\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\nstatic\nint virDomainMigrateUnmanagedCheckCompat(virDomainPtr domain,\n                                         unsigned int flags)\n{\n    VIR_EXCLUSIVE_FLAGS_RET(VIR_MIGRATE_NON_SHARED_DISK,\n                            VIR_MIGRATE_NON_SHARED_INC,\n                            -1);\n\n    if (flags & VIR_MIGRATE_OFFLINE &&\n        !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                  VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"offline migration is not supported by \"\n                         \"the source host\"));\n        return -1;\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_P2P)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"p2p migration is not supported by \"\n                             \"the source host\"));\n            return -1;\n        }\n    } else {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_DIRECT)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"direct migration is not supported by \"\n                             \"the source host\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\n/**\n * virDomainMigrateToURI:\n * @domain: a domain object\n * @duri: mandatory URI for the destination host\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dname: (optional) rename domain to this at destination\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by duri.\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, the duri parameter\n * takes a hypervisor specific format. The uri_transports element of the\n * hypervisor capabilities XML includes details of the supported URI\n * schemes. Not all hypervisors will support this mode of migration, so\n * if the VIR_MIGRATE_PEER2PEER flag is not set, then it may be necessary\n * to use the alternative virDomainMigrate API providing and explicit\n * virConnectPtr for the destination host.\n *\n * If the VIR_MIGRATE_PEER2PEER flag IS set, the duri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt.\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * If a hypervisor supports renaming domains during migration,\n * the dname parameter specifies the new name for the domain.\n * Setting dname to NULL keeps the domain name the same.  If domain\n * renaming is not supported by the hypervisor, dname must be NULL or\n * else an error will be returned.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * Returns 0 if the migration succeeded, -1 upon error.\n */\nint\nvirDomainMigrateToURI(virDomainPtr domain,\n                      const char *duri,\n                      unsigned long flags,\n                      const char *dname,\n                      unsigned long bandwidth)\n{\n    const char *dconnuri = NULL;\n    const char *miguri = NULL;\n\n    VIR_DOMAIN_DEBUG(domain, \"duri=%p, flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(duri), flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonNullArgGoto(duri, error);\n\n    if (virDomainMigrateUnmanagedCheckCompat(domain, flags) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_PEER2PEER)\n        dconnuri = duri;\n    else\n        miguri = duri;\n\n    if (virDomainMigrateUnmanaged(domain, NULL, flags,\n                                  dname, dconnuri, miguri, bandwidth) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateToURI2:\n * @domain: a domain object\n * @dconnuri: (optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER\n * @miguri: (optional) URI for invoking the migration, not if @flags includs VIR_MIGRATE_TUNNELLED\n * @dxml: (optional) XML config for launching guest on target\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dname: (optional) rename domain to this at destination\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by duri.\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the @dconnuri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt. If the\n * VIR_MIGRATE_PEER2PEER flag is NOT set, then @dconnuri must be\n * NULL.\n *\n * If the VIR_MIGRATE_TUNNELLED flag is NOT set, then the @miguri\n * parameter allows specification of a URI to use to initiate the\n * VM migration. It takes a hypervisor specific format. The uri_transports\n * element of the hypervisor capabilities XML includes details of the\n * supported URI schemes.\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n * As of 1.2.11 disks of some types ('file' and 'volume') are\n * precreated automatically, if there's a pool defined on the\n * destination for the disk path.\n *\n * If a hypervisor supports changing the configuration of the guest\n * during migration, the @dxml parameter specifies the new config\n * for the guest. The configuration must include an identical set\n * of virtual devices, to ensure a stable guest ABI across migration.\n * Only parameters related to host side configuration can be\n * changed in the XML. Hypervisors will validate this and refuse to\n * allow migration if the provided XML would cause a change in the\n * guest ABI,\n *\n * If a hypervisor supports renaming domains during migration,\n * the dname parameter specifies the new name for the domain.\n * Setting dname to NULL keeps the domain name the same.  If domain\n * renaming is not supported by the hypervisor, dname must be NULL or\n * else an error will be returned.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * Returns 0 if the migration succeeded, -1 upon error.\n */\nint\nvirDomainMigrateToURI2(virDomainPtr domain,\n                       const char *dconnuri,\n                       const char *miguri,\n                       const char *dxml,\n                       unsigned long flags,\n                       const char *dname,\n                       unsigned long bandwidth)\n{\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, miguri=%s, dxml=%s, \"\n                     \"flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(dconnuri), NULLSTR(miguri), NULLSTR(dxml),\n                     flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    if (virDomainMigrateUnmanagedCheckCompat(domain, flags) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_PEER2PEER)\n        virCheckNonNullArgGoto(dconnuri, error);\n    else\n        dconnuri = NULL;\n\n    if (virDomainMigrateUnmanaged(domain, dxml, flags,\n                                  dname, dconnuri, miguri, bandwidth) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateToURI3:\n * @domain: a domain object\n * @dconnuri: (optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER\n * @params: (optional) migration parameters\n * @nparams: (optional) number of migration parameters in @params\n * @flags: bitwise-OR of virDomainMigrateFlags\n *\n * Migrate the domain object from its current host to the destination host\n * given by URI.\n *\n * See virDomainMigrateFlags documentation for description of individual flags.\n *\n * The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the @dconnuri parameter must be a\n * valid libvirt connection URI, by which the source libvirt daemon can connect\n * to the destination libvirt.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, then @dconnuri must be NULL\n * and VIR_MIGRATE_PARAM_URI migration parameter must be filled in with\n * hypervisor specific URI used to initiate the migration. This is called\n * \"direct\" migration.\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * Returns 0 if the migration succeeded, -1 upon error.\n */\nint\nvirDomainMigrateToURI3(virDomainPtr domain,\n                       const char *dconnuri,\n                       virTypedParameterPtr params,\n                       unsigned int nparams,\n                       unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, params=%p, nparms=%u flags=%x\",\n                     NULLSTR(dconnuri), params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    if (virDomainMigrateUnmanagedCheckCompat(domain, flags) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_PEER2PEER)\n        virCheckNonNullArgGoto(dconnuri, error);\n    else\n        dconnuri = NULL;\n\n    if (virDomainMigrateUnmanagedParams(domain, dconnuri,\n                                        params, nparams, flags) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare(virConnectPtr dconn,\n                        char **cookie,\n                        int *cookielen,\n                        const char *uri_in,\n                        char **uri_out,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long bandwidth)\n{\n    VIR_DEBUG(\"dconn=%p, cookie=%p, cookielen=%p, uri_in=%s, uri_out=%p, \"\n              \"flags=%lx, dname=%s, bandwidth=%lu\", dconn, cookie, cookielen,\n              NULLSTR(uri_in), uri_out, flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare(dconn, cookie, cookielen,\n                                                  uri_in, uri_out,\n                                                  flags, dname, bandwidth);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePerform(virDomainPtr domain,\n                        const char *cookie,\n                        int cookielen,\n                        const char *uri,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long bandwidth)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cookie=%p, cookielen=%d, uri=%s, flags=%lx, \"\n                     \"dname=%s, bandwidth=%lu\", cookie, cookielen, uri, flags,\n                     NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigratePerform) {\n        int ret;\n        ret = conn->driver->domainMigratePerform(domain, cookie, cookielen,\n                                                 uri,\n                                                 flags, dname, bandwidth);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish(virConnectPtr dconn,\n                       const char *dname,\n                       const char *cookie,\n                       int cookielen,\n                       const char *uri,\n                       unsigned long flags)\n{\n    VIR_DEBUG(\"dconn=%p, dname=%s, cookie=%p, cookielen=%d, uri=%s, \"\n              \"flags=%lx\", dconn, NULLSTR(dname), cookie, cookielen,\n              NULLSTR(uri), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish(dconn, dname,\n                                                 cookie, cookielen,\n                                                 uri, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare2(virConnectPtr dconn,\n                         char **cookie,\n                         int *cookielen,\n                         const char *uri_in,\n                         char **uri_out,\n                         unsigned long flags,\n                         const char *dname,\n                         unsigned long bandwidth,\n                         const char *dom_xml)\n{\n    VIR_DEBUG(\"dconn=%p, cookie=%p, cookielen=%p, uri_in=%s, uri_out=%p,\"\n              \"flags=%lx, dname=%s, bandwidth=%lu, dom_xml=%s\", dconn,\n              cookie, cookielen, NULLSTR(uri_in), uri_out, flags, NULLSTR(dname),\n              bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare2) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare2(dconn, cookie, cookielen,\n                                                   uri_in, uri_out,\n                                                   flags, dname, bandwidth,\n                                                   dom_xml);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish2(virConnectPtr dconn,\n                        const char *dname,\n                        const char *cookie,\n                        int cookielen,\n                        const char *uri,\n                        unsigned long flags,\n                        int retcode)\n{\n    VIR_DEBUG(\"dconn=%p, dname=%s, cookie=%p, cookielen=%d, uri=%s, \"\n              \"flags=%lx, retcode=%d\", dconn, NULLSTR(dname), cookie,\n              cookielen, NULLSTR(uri), flags, retcode);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish2) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish2(dconn, dname,\n                                                  cookie, cookielen,\n                                                  uri, flags,\n                                                  retcode);\n        if (!ret && !retcode)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepareTunnel(virConnectPtr conn,\n                              virStreamPtr st,\n                              unsigned long flags,\n                              const char *dname,\n                              unsigned long bandwidth,\n                              const char *dom_xml)\n{\n    VIR_DEBUG(\"conn=%p, stream=%p, flags=%lx, dname=%s, \"\n              \"bandwidth=%lu, dom_xml=%s\", conn, st, flags,\n              NULLSTR(dname), bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(conn, \"%s\",\n                            _(\"conn must match stream connection\"));\n        goto error;\n    }\n\n    if (conn->driver->domainMigratePrepareTunnel) {\n        int rv = conn->driver->domainMigratePrepareTunnel(conn, st,\n                                                          flags, dname,\n                                                          bandwidth, dom_xml);\n        if (rv < 0)\n            goto error;\n        return rv;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nchar *\nvirDomainMigrateBegin3(virDomainPtr domain,\n                       const char *xmlin,\n                       char **cookieout,\n                       int *cookieoutlen,\n                       unsigned long flags,\n                       const char *dname,\n                       unsigned long bandwidth)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xmlin=%s cookieout=%p, cookieoutlen=%p, \"\n                     \"flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(xmlin), cookieout, cookieoutlen, flags,\n                     NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateBegin3) {\n        char *xml;\n        xml = conn->driver->domainMigrateBegin3(domain, xmlin,\n                                                cookieout, cookieoutlen,\n                                                flags, dname, bandwidth);\n        VIR_DEBUG(\"xml %s\", NULLSTR(xml));\n        if (!xml)\n            goto error;\n        return xml;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare3(virConnectPtr dconn,\n                         const char *cookiein,\n                         int cookieinlen,\n                         char **cookieout,\n                         int *cookieoutlen,\n                         const char *uri_in,\n                         char **uri_out,\n                         unsigned long flags,\n                         const char *dname,\n                         unsigned long bandwidth,\n                         const char *dom_xml)\n{\n    VIR_DEBUG(\"dconn=%p, cookiein=%p, cookieinlen=%d, cookieout=%p, \"\n              \"cookieoutlen=%p, uri_in=%s, uri_out=%p, flags=%lx, dname=%s, \"\n              \"bandwidth=%lu, dom_xml=%s\",\n              dconn, cookiein, cookieinlen, cookieout, cookieoutlen, NULLSTR(uri_in),\n              uri_out, flags, NULLSTR(dname), bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare3) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare3(dconn,\n                                                   cookiein, cookieinlen,\n                                                   cookieout, cookieoutlen,\n                                                   uri_in, uri_out,\n                                                   flags, dname, bandwidth,\n                                                   dom_xml);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepareTunnel3(virConnectPtr conn,\n                               virStreamPtr st,\n                               const char *cookiein,\n                               int cookieinlen,\n                               char **cookieout,\n                               int *cookieoutlen,\n                               unsigned long flags,\n                               const char *dname,\n                               unsigned long bandwidth,\n                               const char *dom_xml)\n{\n    VIR_DEBUG(\"conn=%p, stream=%p, cookiein=%p, cookieinlen=%d, cookieout=%p, \"\n              \"cookieoutlen=%p, flags=%lx, dname=%s, bandwidth=%lu, \"\n              \"dom_xml=%s\",\n              conn, st, cookiein, cookieinlen, cookieout, cookieoutlen, flags,\n              NULLSTR(dname), bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(conn, \"%s\",\n                            _(\"conn must match stream connection\"));\n        goto error;\n    }\n\n    if (conn->driver->domainMigratePrepareTunnel3) {\n        int rv = conn->driver->domainMigratePrepareTunnel3(conn, st,\n                                                           cookiein, cookieinlen,\n                                                           cookieout, cookieoutlen,\n                                                           flags, dname,\n                                                           bandwidth, dom_xml);\n        if (rv < 0)\n            goto error;\n        return rv;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePerform3(virDomainPtr domain,\n                         const char *xmlin,\n                         const char *cookiein,\n                         int cookieinlen,\n                         char **cookieout,\n                         int *cookieoutlen,\n                         const char *dconnuri,\n                         const char *uri,\n                         unsigned long flags,\n                         const char *dname,\n                         unsigned long bandwidth)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xmlin=%s cookiein=%p, cookieinlen=%d, \"\n                     \"cookieout=%p, cookieoutlen=%p, dconnuri=%s, \"\n                     \"uri=%s, flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(xmlin), cookiein, cookieinlen,\n                     cookieout, cookieoutlen, NULLSTR(dconnuri),\n                     NULLSTR(uri), flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigratePerform3) {\n        int ret;\n        ret = conn->driver->domainMigratePerform3(domain, xmlin,\n                                                  cookiein, cookieinlen,\n                                                  cookieout, cookieoutlen,\n                                                  dconnuri, uri,\n                                                  flags, dname, bandwidth);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish3(virConnectPtr dconn,\n                        const char *dname,\n                        const char *cookiein,\n                        int cookieinlen,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        const char *dconnuri,\n                        const char *uri,\n                        unsigned long flags,\n                        int cancelled)\n{\n    VIR_DEBUG(\"dconn=%p, dname=%s, cookiein=%p, cookieinlen=%d, cookieout=%p,\"\n              \"cookieoutlen=%p, dconnuri=%s, uri=%s, flags=%lx, retcode=%d\",\n              dconn, NULLSTR(dname), cookiein, cookieinlen, cookieout,\n              cookieoutlen, NULLSTR(dconnuri), NULLSTR(uri), flags, cancelled);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish3) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish3(dconn, dname,\n                                                  cookiein, cookieinlen,\n                                                  cookieout, cookieoutlen,\n                                                  dconnuri, uri, flags,\n                                                  cancelled);\n        if (!ret && !cancelled)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigrateConfirm3(virDomainPtr domain,\n                         const char *cookiein,\n                         int cookieinlen,\n                         unsigned long flags,\n                         int cancelled)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"cookiein=%p, cookieinlen=%d, flags=%lx, cancelled=%d\",\n                     cookiein, cookieinlen, flags, cancelled);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateConfirm3) {\n        int ret;\n        ret = conn->driver->domainMigrateConfirm3(domain,\n                                                  cookiein, cookieinlen,\n                                                  flags, cancelled);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nchar *\nvirDomainMigrateBegin3Params(virDomainPtr domain,\n                             virTypedParameterPtr params,\n                             int nparams,\n                             char **cookieout,\n                             int *cookieoutlen,\n                             unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, \"\n                     \"cookieout=%p, cookieoutlen=%p, flags=%x\",\n                     params, nparams, cookieout, cookieoutlen, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateBegin3Params) {\n        char *xml;\n        xml = conn->driver->domainMigrateBegin3Params(domain, params, nparams,\n                                                      cookieout, cookieoutlen,\n                                                      flags);\n        VIR_DEBUG(\"xml %s\", NULLSTR(xml));\n        if (!xml)\n            goto error;\n        return xml;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare3Params(virConnectPtr dconn,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               const char *cookiein,\n                               int cookieinlen,\n                               char **cookieout,\n                               int *cookieoutlen,\n                               char **uri_out,\n                               unsigned int flags)\n{\n    VIR_DEBUG(\"dconn=%p, params=%p, nparams=%d, cookiein=%p, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, uri_out=%p, flags=%x\",\n              dconn, params, nparams, cookiein, cookieinlen,\n              cookieout, cookieoutlen, uri_out, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare3Params) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare3Params(dconn, params, nparams,\n                                                         cookiein, cookieinlen,\n                                                         cookieout, cookieoutlen,\n                                                         uri_out, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepareTunnel3Params(virConnectPtr conn,\n                                     virStreamPtr st,\n                                     virTypedParameterPtr params,\n                                     int nparams,\n                                     const char *cookiein,\n                                     int cookieinlen,\n                                     char **cookieout,\n                                     int *cookieoutlen,\n                                     unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, stream=%p, params=%p, nparams=%d, cookiein=%p, \"\n              \"cookieinlen=%d, cookieout=%p, cookieoutlen=%p, flags=%x\",\n              conn, st, params, nparams, cookiein, cookieinlen,\n              cookieout, cookieoutlen, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(conn, \"%s\",\n                            _(\"conn must match stream connection\"));\n        goto error;\n    }\n\n    if (conn->driver->domainMigratePrepareTunnel3Params) {\n        int rv;\n        rv = conn->driver->domainMigratePrepareTunnel3Params(\n                conn, st, params, nparams, cookiein, cookieinlen,\n                cookieout, cookieoutlen, flags);\n        if (rv < 0)\n            goto error;\n        return rv;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePerform3Params(virDomainPtr domain,\n                               const char *dconnuri,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               const char *cookiein,\n                               int cookieinlen,\n                               char **cookieout,\n                               int *cookieoutlen,\n                               unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, params=%p, nparams=%d, cookiein=%p, \"\n                     \"cookieinlen=%d, cookieout=%p, cookieoutlen=%p, flags=%x\",\n                     NULLSTR(dconnuri), params, nparams, cookiein,\n                     cookieinlen, cookieout, cookieoutlen, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigratePerform3Params) {\n        int ret;\n        ret = conn->driver->domainMigratePerform3Params(\n                domain, dconnuri, params, nparams, cookiein, cookieinlen,\n                cookieout, cookieoutlen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish3Params(virConnectPtr dconn,\n                              virTypedParameterPtr params,\n                              int nparams,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned int flags,\n                              int cancelled)\n{\n    VIR_DEBUG(\"dconn=%p, params=%p, nparams=%d, cookiein=%p, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=%x, cancelled=%d\",\n              dconn, params, nparams, cookiein, cookieinlen, cookieout,\n              cookieoutlen, flags, cancelled);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish3Params) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish3Params(\n                dconn, params, nparams, cookiein, cookieinlen,\n                cookieout, cookieoutlen, flags, cancelled);\n        if (!ret && !cancelled)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigrateConfirm3Params(virDomainPtr domain,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               const char *cookiein,\n                               int cookieinlen,\n                               unsigned int flags,\n                               int cancelled)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, cookiein=%p, \"\n                     \"cookieinlen=%d, flags=%x, cancelled=%d\",\n                     params, nparams, cookiein, cookieinlen, flags, cancelled);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateConfirm3Params) {\n        int ret;\n        ret = conn->driver->domainMigrateConfirm3Params(\n                domain, params, nparams,\n                cookiein, cookieinlen, flags, cancelled);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSchedulerType:\n * @domain: pointer to domain object\n * @nparams: pointer to number of scheduler parameters, can be NULL\n *           (return value)\n *\n * Get the scheduler type and the number of scheduler parameters.\n *\n * Returns NULL in case of error. The caller must free the returned string.\n */\nchar *\nvirDomainGetSchedulerType(virDomainPtr domain, int *nparams)\n{\n    virConnectPtr conn;\n    char *schedtype;\n\n    VIR_DOMAIN_DEBUG(domain, \"nparams=%p\", nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSchedulerType) {\n        schedtype = conn->driver->domainGetSchedulerType(domain, nparams);\n        if (!schedtype)\n            goto error;\n        return schedtype;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainGetSchedulerParameters:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter objects\n *          (return value)\n * @nparams: pointer to number of scheduler parameter objects\n *          (this value should generally be as large as the returned value\n *           nparams of virDomainGetSchedulerType()); input and output\n *\n * Get all scheduler parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.  @nparams cannot be 0.\n *\n * It is hypervisor specific whether this returns the live or\n * persistent state; for more control, use\n * virDomainGetSchedulerParametersFlags().\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int *nparams)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%p\", params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckPositiveArgGoto(*nparams, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSchedulerParameters) {\n        int ret;\n        ret = conn->driver->domainGetSchedulerParameters(domain, params, nparams);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSchedulerParametersFlags:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter object\n *          (return value)\n * @nparams: pointer to number of scheduler parameter\n *          (this value should be same than the returned value\n *           nparams of virDomainGetSchedulerType()); input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all scheduler parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.  @nparams cannot be 0.\n *\n * The value of @flags can be exactly VIR_DOMAIN_AFFECT_CURRENT,\n * VIR_DOMAIN_AFFECT_LIVE, or VIR_DOMAIN_AFFECT_CONFIG.\n *\n * Here is a sample code snippet:\n *\n *   char *ret = virDomainGetSchedulerType(dom, &nparams);\n *   if (ret && nparams != 0) {\n *       if ((params = malloc(sizeof(*params) * nparams)) == NULL)\n *           goto error;\n *       memset(params, 0, sizeof(*params) * nparams);\n *       if (virDomainGetSchedulerParametersFlags(dom, params, &nparams, 0))\n *           goto error;\n *   }\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int *nparams,\n                                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%p, flags=%x\",\n                     params, nparams, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckPositiveArgGoto(*nparams, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSchedulerParametersFlags) {\n        int ret;\n        ret = conn->driver->domainGetSchedulerParametersFlags(domain, params,\n                                                              nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetSchedulerParameters:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter objects\n * @nparams: number of scheduler parameter objects\n *          (this value can be the same or less than the returned value\n *           nparams of virDomainGetSchedulerType)\n *\n * Change all or a subset or the scheduler parameters.  It is\n * hypervisor-specific whether this sets live, persistent, or both\n * settings; for more control, use\n * virDomainSetSchedulerParametersFlags.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int nparams)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d\", params, nparams);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetSchedulerParameters) {\n        int ret;\n        ret = conn->driver->domainSetSchedulerParameters(domain, params, nparams);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetSchedulerParametersFlags:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter objects\n * @nparams: number of scheduler parameter objects\n *          (this value can be the same or less than the returned value\n *           nparams of virDomainGetSchedulerType)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change a subset or all scheduler parameters.  The value of @flags\n * should be either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of\n * values from VIR_DOMAIN_AFFECT_LIVE and\n * VIR_DOMAIN_AFFECT_CURRENT, although hypervisors vary in which\n * flags are supported.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params,\n                                     int nparams,\n                                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetSchedulerParametersFlags) {\n        int ret;\n        ret = conn->driver->domainSetSchedulerParametersFlags(domain,\n                                                              params,\n                                                              nparams,\n                                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockStats:\n * @dom: pointer to the domain object\n * @disk: path to the block device, or device shorthand\n * @stats: block device stats (returned)\n * @size: size of stats structure\n *\n * This function returns block device (disk) stats for block\n * devices attached to the domain.\n *\n * The @disk parameter is either the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\"), or (since 0.9.8)\n * an unambiguous source name of the block device (the <source\n * file='...'/> sub-element, such as \"/path/to/image\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk. Some drivers might also\n * accept the empty string for the @disk parameter, and then yield\n * summary stats for the entire domain.\n *\n * Domains may have more than one block device.  To get stats for\n * each you should make multiple calls to this function.\n *\n * Individual fields within the stats structure may be returned\n * as -1, which indicates that the hypervisor does not support\n * that particular statistic.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainBlockStats(virDomainPtr dom, const char *disk,\n                    virDomainBlockStatsPtr stats, size_t size)\n{\n    virConnectPtr conn;\n    virDomainBlockStatsStruct stats2 = { -1, -1, -1, -1, -1 };\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, stats=%p, size=%zi\", disk, stats, size);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(stats, error);\n    if (size > sizeof(stats2)) {\n        virReportInvalidArg(size,\n                            _(\"size must not exceed %zu\"),\n                            sizeof(stats2));\n        goto error;\n    }\n    conn = dom->conn;\n\n    if (conn->driver->domainBlockStats) {\n        if (conn->driver->domainBlockStats(dom, disk, &stats2) == -1)\n            goto error;\n\n        memcpy(stats, &stats2, size);\n        return 0;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockStatsFlags:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @params: pointer to block stats parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of block stats; input and output\n * @flags: bitwise-OR of virTypedParameterFlags\n *\n * This function is to get block stats parameters for block\n * devices attached to the domain.\n *\n * The @disk parameter is either the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\"), or (since 0.9.8)\n * an unambiguous source name of the block device (the <source\n * file='...'/> sub-element, such as \"/path/to/image\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk. Some drivers might also\n * accept the empty string for the @disk parameter, and then yield\n * summary stats for the entire domain.\n *\n * Domains may have more than one block device.  To get stats for\n * each you should make multiple calls to this function.\n *\n * On input, @nparams gives the size of the @params array; on output,\n * @nparams gives how many slots were filled with parameter\n * information, which might be less but will not exceed the input\n * value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. (Note that block devices of different types\n * might support different parameters, so it might be necessary to compute\n * @nparams for each block device). The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again. See virDomainGetMemoryParameters() for more details.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainBlockStatsFlags(virDomainPtr dom,\n                         const char *disk,\n                         virTypedParameterPtr params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, params=%p, nparams=%d, flags=%x\",\n                     disk, params, nparams ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n    conn = dom->conn;\n\n    if (conn->driver->domainBlockStatsFlags) {\n        int ret;\n        ret = conn->driver->domainBlockStatsFlags(dom, disk, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainInterfaceStats:\n * @dom: pointer to the domain object\n * @path: path to the interface\n * @stats: network interface stats (returned)\n * @size: size of stats structure\n *\n * This function returns network interface stats for interfaces\n * attached to the domain.\n *\n * The path parameter is the name of the network interface.\n *\n * Domains may have more than one network interface.  To get stats for\n * each you should make multiple calls to this function.\n *\n * Individual fields within the stats structure may be returned\n * as -1, which indicates that the hypervisor does not support\n * that particular statistic.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainInterfaceStats(virDomainPtr dom, const char *path,\n                        virDomainInterfaceStatsPtr stats, size_t size)\n{\n    virConnectPtr conn;\n    virDomainInterfaceStatsStruct stats2 = { -1, -1, -1, -1,\n                                             -1, -1, -1, -1 };\n\n    VIR_DOMAIN_DEBUG(dom, \"path=%s, stats=%p, size=%zi\",\n                     path, stats, size);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(path, error);\n    virCheckNonNullArgGoto(stats, error);\n    if (size > sizeof(stats2)) {\n        virReportInvalidArg(size,\n                            _(\"size must not exceed %zu\"),\n                            sizeof(stats2));\n        goto error;\n    }\n\n    conn = dom->conn;\n\n    if (conn->driver->domainInterfaceStats) {\n        if (conn->driver->domainInterfaceStats(dom, path, &stats2) == -1)\n            goto error;\n\n        memcpy(stats, &stats2, size);\n        return 0;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetInterfaceParameters:\n * @domain: pointer to domain object\n * @device: the interface name or mac address\n * @params: pointer to interface parameter objects\n * @nparams: number of interface parameter (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change a subset or all parameters of interface; currently this\n * includes bandwidth parameters.  The value of @flags should be\n * either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values\n * VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG, although\n * hypervisors vary in which flags are supported.\n *\n * This function may require privileged access to the hypervisor.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetInterfaceParameters(virDomainPtr domain,\n                                const char *device,\n                                virTypedParameterPtr params,\n                                int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"device=%s, params=%p, nparams=%d, flags=%x\",\n                     device, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckPositiveArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetInterfaceParameters) {\n        int ret;\n        ret = conn->driver->domainSetInterfaceParameters(domain, device,\n                                                         params, nparams,\n                                                         flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetInterfaceParameters:\n * @domain: pointer to domain object\n * @device: the interface name or mac address\n * @params: pointer to interface parameter objects\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of interface parameter; input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all interface parameters. On input, @nparams gives the size of\n * the @params array; on output, @nparams gives how many slots were\n * filled with parameter information, which might be less but will not\n * exceed the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the\n * API again. See virDomainGetMemoryParameters() for an equivalent usage\n * example.\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetInterfaceParameters(virDomainPtr domain,\n                                const char *device,\n                                virTypedParameterPtr params,\n                                int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"device=%s, params=%p, nparams=%d, flags=%x\",\n                     device, params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetInterfaceParameters) {\n        int ret;\n        ret = conn->driver->domainGetInterfaceParameters(domain, device,\n                                                         params, nparams,\n                                                         flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMemoryStats:\n * @dom: pointer to the domain object\n * @stats: nr_stats-sized array of stat structures (returned)\n * @nr_stats: number of memory statistics requested\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * This function provides memory statistics for the domain.\n *\n * Up to 'nr_stats' elements of 'stats' will be populated with memory statistics\n * from the domain.  Only statistics supported by the domain, the driver, and\n * this version of libvirt will be returned.\n *\n * Memory Statistics:\n *\n * VIR_DOMAIN_MEMORY_STAT_SWAP_IN:\n *     The total amount of data read from swap space (in kb).\n * VIR_DOMAIN_MEMORY_STAT_SWAP_OUT:\n *     The total amount of memory written out to swap space (in kb).\n * VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:\n *     The number of page faults that required disk IO to service.\n * VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:\n *     The number of page faults serviced without disk IO.\n * VIR_DOMAIN_MEMORY_STAT_UNUSED:\n *     The amount of memory which is not being used for any purpose (in kb).\n * VIR_DOMAIN_MEMORY_STAT_AVAILABLE:\n *     The total amount of memory available to the domain's OS (in kb).\n * VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON:\n *     Current balloon value (in kb).\n *\n * Returns: The number of stats provided or -1 in case of failure.\n */\nint\nvirDomainMemoryStats(virDomainPtr dom, virDomainMemoryStatPtr stats,\n                     unsigned int nr_stats, unsigned int flags)\n{\n    virConnectPtr conn;\n    unsigned long nr_stats_ret = 0;\n\n    VIR_DOMAIN_DEBUG(dom, \"stats=%p, nr_stats=%u, flags=%x\",\n                     stats, nr_stats, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (!stats || nr_stats == 0)\n        return 0;\n\n    if (nr_stats > VIR_DOMAIN_MEMORY_STAT_NR)\n        nr_stats = VIR_DOMAIN_MEMORY_STAT_NR;\n\n    conn = dom->conn;\n    if (conn->driver->domainMemoryStats) {\n        nr_stats_ret = conn->driver->domainMemoryStats(dom, stats, nr_stats,\n                                                       flags);\n        if (nr_stats_ret == -1)\n            goto error;\n        return nr_stats_ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockPeek:\n * @dom: pointer to the domain object\n * @disk: path to the block device, or device shorthand\n * @offset: offset within block device\n * @size: size to read\n * @buffer: return buffer (must be at least size bytes)\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * This function allows you to read the contents of a domain's\n * disk device.\n *\n * Typical uses for this are to determine if the domain has\n * written a Master Boot Record (indicating that the domain\n * has completed installation), or to try to work out the state\n * of the domain's filesystems.\n *\n * (Note that in the local case you might try to open the\n * block device or file directly, but that won't work in the\n * remote case, nor if you don't have sufficient permission.\n * Hence the need for this call).\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * 'offset' and 'size' represent an area which must lie entirely\n * within the device or file.  'size' may be 0 to test if the\n * call would succeed.\n *\n * 'buffer' is the return buffer and must be at least 'size' bytes.\n *\n * NB. The remote driver imposes a 64K byte limit on 'size'.\n * For your program to be able to work reliably over a remote\n * connection you should split large requests to <= 65536 bytes.\n * However, with 0.9.13 this RPC limit has been raised to 1M byte.\n * Starting with version 1.0.6 the RPC limit has been raised again.\n * Now large requests up to 16M byte are supported.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainBlockPeek(virDomainPtr dom,\n                   const char *disk,\n                   unsigned long long offset /* really 64 bits */,\n                   size_t size,\n                   void *buffer,\n                   unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, offset=%lld, size=%zi, buffer=%p, flags=%x\",\n                     disk, offset, size, buffer, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonEmptyStringArgGoto(disk, error);\n\n    /* Allow size == 0 as an access test. */\n    if (size > 0)\n        virCheckNonNullArgGoto(buffer, error);\n\n    if (conn->driver->domainBlockPeek) {\n        int ret;\n        ret = conn->driver->domainBlockPeek(dom, disk, offset, size,\n                                            buffer, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockResize:\n * @dom: pointer to the domain object\n * @disk: path to the block image, or shorthand\n * @size: new size of the block image, see below for unit\n * @flags: bitwise-OR of virDomainBlockResizeFlags\n *\n * Resize a block device of domain while the domain is running.  If\n * @flags is 0, then @size is in kibibytes (blocks of 1024 bytes);\n * since 0.9.11, if @flags includes VIR_DOMAIN_BLOCK_RESIZE_BYTES,\n * @size is in bytes instead.  @size is taken directly as the new\n * size.  Depending on the file format, the hypervisor may round up\n * to the next alignment boundary.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * Note that this call may fail if the underlying virtualization hypervisor\n * does not support it; this call requires privileged access to the\n * hypervisor.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainBlockResize(virDomainPtr dom,\n                     const char *disk,\n                     unsigned long long size,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, size=%llu, flags=%x\", disk, size, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockResize) {\n        int ret;\n        ret = conn->driver->domainBlockResize(dom, disk, size, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMemoryPeek:\n * @dom: pointer to the domain object\n * @start: start of memory to peek\n * @size: size of memory to peek\n * @buffer: return buffer (must be at least size bytes)\n * @flags: bitwise-OR of virDomainMemoryFlags\n *\n * This function allows you to read the contents of a domain's\n * memory.\n *\n * The memory which is read is controlled by the 'start', 'size'\n * and 'flags' parameters.\n *\n * If 'flags' is VIR_MEMORY_VIRTUAL then the 'start' and 'size'\n * parameters are interpreted as virtual memory addresses for\n * whichever task happens to be running on the domain at the\n * moment.  Although this sounds haphazard it is in fact what\n * you want in order to read Linux kernel state, because it\n * ensures that pointers in the kernel image can be interpreted\n * coherently.\n *\n * 'buffer' is the return buffer and must be at least 'size' bytes.\n * 'size' may be 0 to test if the call would succeed.\n *\n * NB. The remote driver imposes a 64K byte limit on 'size'.\n * For your program to be able to work reliably over a remote\n * connection you should split large requests to <= 65536 bytes.\n * However, with 0.9.13 this RPC limit has been raised to 1M byte.\n * Starting with version 1.0.6 the RPC limit has been raised again.\n * Now large requests up to 16M byte are supported.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainMemoryPeek(virDomainPtr dom,\n                    unsigned long long start /* really 64 bits */,\n                    size_t size,\n                    void *buffer,\n                    unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"start=%lld, size=%zi, buffer=%p, flags=%x\",\n                     start, size, buffer, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    /* Note on access to physical memory: A VIR_MEMORY_PHYSICAL flag is\n     * a possibility.  However it isn't really useful unless the caller\n     * can also access registers, particularly CR3 on x86 in order to\n     * get the Page Table Directory.  Since registers are different on\n     * every architecture, that would imply another call to get the\n     * machine registers.\n     *\n     * The QEMU driver handles VIR_MEMORY_VIRTUAL, mapping it\n     * to the qemu 'memsave' command which does the virtual to physical\n     * mapping inside qemu.\n     *\n     * The QEMU driver also handles VIR_MEMORY_PHYSICAL, mapping it\n     * to the qemu 'pmemsave' command.\n     *\n     * At time of writing there is no Xen driver.  However the Xen\n     * hypervisor only lets you map physical pages from other domains,\n     * and so the Xen driver would have to do the virtual to physical\n     * mapping by chasing 2, 3 or 4-level page tables from the PTD.\n     * There is example code in libxc (xc_translate_foreign_address)\n     * which does this, although we cannot copy this code directly\n     * because of incompatible licensing.\n     */\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MEMORY_VIRTUAL, VIR_MEMORY_PHYSICAL, error);\n\n    /* Allow size == 0 as an access test. */\n    if (size > 0)\n        virCheckNonNullArgGoto(buffer, error);\n\n    if (conn->driver->domainMemoryPeek) {\n        int ret;\n        ret = conn->driver->domainMemoryPeek(dom, start, size,\n                                             buffer, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlockInfo:\n * @domain: a domain object\n * @disk: path to the block device, or device shorthand\n * @info: pointer to a virDomainBlockInfo structure allocated by the user\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract information about a domain's block device.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * For QEMU domains, the allocation and physical virDomainBlockInfo\n * values returned will generally be the same, except when using a\n * non raw, block backing device, such as qcow2 for an active domain.\n * When the persistent domain is not active, QEMU will return the\n * default which is the same value for allocation and physical.\n *\n * Active QEMU domains can return an allocation value which is more\n * representative of the currently used blocks by the device compared\n * to the physical size of the device. Applications can use/monitor\n * the allocation value with the understanding that if the domain\n * becomes inactive during an attempt to get the value, the default\n * values will be returned. Thus, the application should check\n * after the call for the domain being inactive if the values are\n * the same. Optionally, the application could be watching for a\n * shutdown event and then ignore any values received afterwards.\n * This can be an issue when a domain is being migrated and the\n * exact timing of the domain being made inactive and check of\n * the allocation value results the default being returned. For\n * a transient domain in the similar situation, this call will return\n * -1 and an error message indicating the \"domain is not running\".\n *\n * The following is some pseudo code illustrating the call sequence:\n *\n *   ...\n *   virDomainPtr dom;\n *   virDomainBlockInfo info;\n *   char *device;\n *   ...\n *   // Either get a list of all domains or a specific domain\n *   // via a virDomainLookupBy*() call.\n *   //\n *   // It's also required to fill in the device pointer, but that's\n *   // specific to the implementation. For the purposes of this example\n *   // a qcow2 backed device name string would need to be provided.\n *   ...\n *   // If the following call is made on a persistent domain with a\n *   // qcow2 block backed block device, then it's possible the returned\n *   // allocation equals the physical value. In that case, the domain\n *   // that may have been active prior to calling has become inactive,\n *   // such as is the case during a domain migration. Thus once we\n *   // get data returned, check for active domain when the values are\n *   // the same.\n *   if (virDomainGetBlockInfo(dom, device, &info, 0) < 0)\n *       goto failure;\n *   if (info.allocation == info.physical) {\n *       // If the domain is no longer active,\n *       // then the defaults are being returned.\n *       if (!virDomainIsActive())\n *               goto ignore_return;\n *   }\n *   // Do something with the allocation and physical values\n *   ...\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetBlockInfo(virDomainPtr domain, const char *disk,\n                      virDomainBlockInfoPtr info, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p, flags=%x\", info, flags);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonEmptyStringArgGoto(disk, error);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetBlockInfo) {\n        int ret;\n        ret = conn->driver->domainGetBlockInfo(domain, disk, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDefineXML:\n * @conn: pointer to the hypervisor connection\n * @xml: the XML description for the domain, preferably in UTF-8\n *\n * Define a domain, but does not start it.\n * This definition is persistent, until explicitly undefined with\n * virDomainUndefine(). A previous definition for this domain would be\n * overridden if it already exists.\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation on a transient domain with the same id as the\n * domain being defined; in that case, use virDomainBlockJobAbort() to\n * stop the block copy first.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns NULL in case of error, a pointer to the domain otherwise\n */\nvirDomainPtr\nvirDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    VIR_DEBUG(\"conn=%p, xml=%s\", conn, NULLSTR(xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(xml, error);\n\n    if (conn->driver->domainDefineXML) {\n        virDomainPtr ret;\n        ret = conn->driver->domainDefineXML(conn, xml);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainDefineXMLFlags:\n * @conn: pointer to the hypervisor connection\n * @xml: the XML description for the domain, preferably in UTF-8\n * @flags: bitwise OR of the virDomainDefineFlags constants\n *\n * Defines a domain, but does not start it.\n * This definition is persistent, until explicitly undefined with\n * virDomainUndefine(). A previous definition for this domain would be\n * overridden if it already exists.\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation on a transient domain with the same id as the\n * domain being defined; in that case, use virDomainBlockJobAbort() to\n * stop the block copy first.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns NULL in case of error, a pointer to the domain otherwise\n */\nvirDomainPtr\nvirDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xml=%s flags=%x\", conn, NULLSTR(xml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(xml, error);\n\n    if (conn->driver->domainDefineXMLFlags) {\n        virDomainPtr ret;\n        ret = conn->driver->domainDefineXMLFlags(conn, xml, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainUndefine:\n * @domain: pointer to a defined domain\n *\n * Undefine a domain. If the domain is running, it's converted to\n * transient domain, without stopping it. If the domain is inactive,\n * the domain configuration is removed.\n *\n * If the domain has a managed save image (see\n * virDomainHasManagedSaveImage()), or if it is inactive and has any\n * snapshot metadata (see virDomainSnapshotNum()), then the undefine will\n * fail. See virDomainUndefineFlags() for more control.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainUndefine(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainUndefine) {\n        int ret;\n        ret = conn->driver->domainUndefine(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainUndefineFlags:\n * @domain: pointer to a defined domain\n * @flags: bitwise-OR of supported virDomainUndefineFlagsValues\n *\n * Undefine a domain. If the domain is running, it's converted to\n * transient domain, without stopping it. If the domain is inactive,\n * the domain configuration is removed.\n *\n * If the domain has a managed save image (see virDomainHasManagedSaveImage()),\n * then including VIR_DOMAIN_UNDEFINE_MANAGED_SAVE in @flags will also remove\n * that file, and omitting the flag will cause the undefine process to fail.\n *\n * If the domain is inactive and has any snapshot metadata (see\n * virDomainSnapshotNum()), then including\n * VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA in @flags will also remove\n * that metadata.  Omitting the flag will cause the undefine of an\n * inactive domain to fail.  Active snapshots will retain snapshot\n * metadata until the (now-transient) domain halts, regardless of\n * whether this flag is present.  On hypervisors where snapshots do\n * not use libvirt metadata, this flag has no effect.\n *\n * If the domain has any nvram specified, then including\n * VIR_DOMAIN_UNDEFINE_NVRAM will also remove that file, and omitting the flag\n * will cause the undefine process to fail.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainUndefineFlags(virDomainPtr domain,\n                       unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainUndefineFlags) {\n        int ret;\n        ret = conn->driver->domainUndefineFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virConnectNumOfDefinedDomains:\n * @conn: pointer to the hypervisor connection\n *\n * Provides the number of defined but inactive domains.\n *\n * Returns the number of domain found or -1 in case of error\n */\nint\nvirConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectNumOfDefinedDomains) {\n        int ret;\n        ret = conn->driver->connectNumOfDefinedDomains(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectListDefinedDomains:\n * @conn: pointer to the hypervisor connection\n * @names: pointer to an array to store the names\n * @maxnames: size of the array\n *\n * list the defined but inactive domains, stores the pointers to the names\n * in @names\n *\n * For active domains, see virConnectListDomains().  For more control over\n * the results, see virConnectListAllDomains().\n *\n * Returns the number of names provided in the array or -1 in case of error.\n * Note that this command is inherently racy; a domain can be defined between\n * a call to virConnectNumOfDefinedDomains() and this call; you are only\n * guaranteed that all currently defined domains were listed if the return\n * is less than @maxids.  The client must call free() on each returned name.\n */\nint\nvirConnectListDefinedDomains(virConnectPtr conn, char **const names,\n                             int maxnames)\n{\n    VIR_DEBUG(\"conn=%p, names=%p, maxnames=%d\", conn, names, maxnames);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(names, error);\n    virCheckNonNegativeArgGoto(maxnames, error);\n\n    if (conn->driver->connectListDefinedDomains) {\n        int ret;\n        ret = conn->driver->connectListDefinedDomains(conn, names, maxnames);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectListAllDomains:\n * @conn: Pointer to the hypervisor connection.\n * @domains: Pointer to a variable to store the array containing domain objects\n *           or NULL if the list is not required (just returns number of guests).\n * @flags: bitwise-OR of virConnectListAllDomainsFlags\n *\n * Collect a possibly-filtered list of all domains, and return an allocated\n * array of information for each.  This API solves the race inherent in\n * virConnectListDomains() and virConnectListDefinedDomains().\n *\n * Normally, all domains are returned; however, @flags can be used to\n * filter the results for a smaller list of targeted domains.  The valid\n * flags are divided into groups, where each group contains bits that\n * describe mutually exclusive attributes of a domain, and where all bits\n * within a group describe all possible domains.  Some hypervisors might\n * reject explicit bits from a group where the hypervisor cannot make a\n * distinction (for example, not all hypervisors can tell whether domains\n * have snapshots).  For a group supported by a given hypervisor, the\n * behavior when no bits of a group are set is identical to the behavior\n * when all bits in that group are set.  When setting bits from more than\n * one group, it is possible to select an impossible combination (such\n * as an inactive transient domain), in that case a hypervisor may return\n * either 0 or an error.\n *\n * The first group of @flags is VIR_CONNECT_LIST_DOMAINS_ACTIVE (online\n * domains) and VIR_CONNECT_LIST_DOMAINS_INACTIVE (offline domains).\n *\n * The next group of @flags is VIR_CONNECT_LIST_DOMAINS_PERSISTENT (defined\n * domains) and VIR_CONNECT_LIST_DOMAINS_TRANSIENT (running but not defined).\n *\n * The next group of @flags covers various domain states:\n * VIR_CONNECT_LIST_DOMAINS_RUNNING, VIR_CONNECT_LIST_DOMAINS_PAUSED,\n * VIR_CONNECT_LIST_DOMAINS_SHUTOFF, and a catch-all for all other states\n * (such as crashed, this catch-all covers the possibility of adding new\n * states).\n *\n * The remaining groups cover boolean attributes commonly asked about\n * domains; they include VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE and\n * VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE, for filtering based on whether\n * a managed save image exists; VIR_CONNECT_LIST_DOMAINS_AUTOSTART and\n * VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART, for filtering based on autostart;\n * VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT and\n * VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT, for filtering based on whether\n * a domain has snapshots.\n *\n * Example of usage:\n *\n *   virDomainPtr *domains;\n *   size_t i;\n *   int ret;\n *   unsigned int flags = VIR_CONNECT_LIST_DOMAINS_RUNNING |\n *                        VIR_CONNECT_LIST_DOMAINS_PERSISTENT;\n *   ret = virConnectListAllDomains(conn, &domains, flags);\n *   if (ret < 0)\n *       error();\n *   for (i = 0; i < ret; i++) {\n *        do_something_with_domain(domains[i]);\n *        //here or in a separate loop if needed\n *        virDomainFree(domains[i]);\n *   }\n *   free(domains);\n *\n * Returns the number of domains found or -1 and sets domains to NULL in case of\n * error.  On success, the array stored into @domains is guaranteed to have an\n * extra allocated element set to NULL but not included in the return count, to\n * make iteration easier. The caller is responsible for calling virDomainFree()\n * on each array element, then calling free() on @domains.\n */\nint\nvirConnectListAllDomains(virConnectPtr conn,\n                         virDomainPtr **domains,\n                         unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, domains=%p, flags=%x\", conn, domains, flags);\n\n    virResetLastError();\n\n    if (domains)\n        *domains = NULL;\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectListAllDomains) {\n        int ret;\n        ret = conn->driver->connectListAllDomains(conn, domains, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainCreate:\n * @domain: pointer to a defined domain\n *\n * Launch a defined domain. If the call succeeds the domain moves from the\n * defined to the running domains pools.  The domain will be paused only\n * if restoring from managed state created from a paused domain.  For more\n * control, see virDomainCreateWithFlags().\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainCreate(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreate) {\n        int ret;\n        ret = conn->driver->domainCreate(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainCreateWithFlags:\n * @domain: pointer to a defined domain\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a defined domain. If the call succeeds the domain moves from the\n * defined to the running domains pools.\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain\n * has a managed save image that requested paused state (see\n * virDomainManagedSave()) the guest domain will be started, but its\n * CPUs will remain paused. The CPUs can later be manually started\n * using virDomainResume().  In all other cases, the guest domain will\n * be running.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * If the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a\n * managed save file for this domain (created by virDomainManagedSave()),\n * then libvirt will attempt to bypass the file system cache while restoring\n * the file, or fail if it cannot do so for the given system; this can allow\n * less pressure on file system cache, but also risks slowing loads from NFS.\n *\n * If the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save\n * file for this domain is discarded, and the domain boots from scratch.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateWithFlags) {\n        int ret;\n        ret = conn->driver->domainCreateWithFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainCreateWithFiles:\n * @domain: pointer to a defined domain\n * @nfiles: number of file descriptors passed\n * @files: list of file descriptors passed\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a defined domain. If the call succeeds the domain moves from the\n * defined to the running domains pools.\n *\n * @files provides an array of file descriptors which will be\n * made available to the 'init' process of the guest. The file\n * handles exposed to the guest will be renumbered to start\n * from 3 (ie immediately following stderr). This is only\n * supported for guests which use container based virtualization\n * technology.\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain\n * has a managed save image that requested paused state (see\n * virDomainManagedSave()) the guest domain will be started, but its\n * CPUs will remain paused. The CPUs can later be manually started\n * using virDomainResume().  In all other cases, the guest domain will\n * be running.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * If the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a\n * managed save file for this domain (created by virDomainManagedSave()),\n * then libvirt will attempt to bypass the file system cache while restoring\n * the file, or fail if it cannot do so for the given system; this can allow\n * less pressure on file system cache, but also risks slowing loads from NFS.\n *\n * If the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save\n * file for this domain is discarded, and the domain boots from scratch.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainCreateWithFiles(virDomainPtr domain, unsigned int nfiles,\n                         int *files, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"nfiles=%u, files=%p, flags=%x\",\n                     nfiles, files, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateWithFiles) {\n        int ret;\n        ret = conn->driver->domainCreateWithFiles(domain,\n                                                  nfiles, files,\n                                                  flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetAutostart:\n * @domain: a domain object\n * @autostart: the value returned\n *\n * Provides a boolean value indicating whether the domain\n * configured to be automatically started when the host\n * machine boots.\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainGetAutostart(virDomainPtr domain,\n                      int *autostart)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"autostart=%p\", autostart);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(autostart, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetAutostart) {\n        int ret;\n        ret = conn->driver->domainGetAutostart(domain, autostart);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetAutostart:\n * @domain: a domain object\n * @autostart: whether the domain should be automatically started 0 or 1\n *\n * Configure the domain to be automatically started\n * when the host machine boots.\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainSetAutostart(virDomainPtr domain,\n                      int autostart)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"autostart=%d\", autostart);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainSetAutostart) {\n        int ret;\n        ret = conn->driver->domainSetAutostart(domain, autostart);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainInjectNMI:\n * @domain: pointer to domain object, or NULL for Domain0\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Send NMI to the guest\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainInjectNMI(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainInjectNMI) {\n        int ret;\n        ret = conn->driver->domainInjectNMI(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSendKey:\n * @domain:    pointer to domain object, or NULL for Domain0\n * @codeset:   the code set of keycodes, from virKeycodeSet\n * @holdtime:  the duration (in milliseconds) that the keys will be held\n * @keycodes:  array of keycodes\n * @nkeycodes: number of keycodes, up to VIR_DOMAIN_SEND_KEY_MAX_KEYS\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Send key(s) to the guest.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSendKey(virDomainPtr domain,\n                 unsigned int codeset,\n                 unsigned int holdtime,\n                 unsigned int *keycodes,\n                 int nkeycodes,\n                 unsigned int flags)\n{\n    virConnectPtr conn;\n    VIR_DOMAIN_DEBUG(domain, \"codeset=%u, holdtime=%u, nkeycodes=%u, flags=%x\",\n                     codeset, holdtime, nkeycodes, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(keycodes, error);\n    virCheckPositiveArgGoto(nkeycodes, error);\n\n    if (nkeycodes > VIR_DOMAIN_SEND_KEY_MAX_KEYS) {\n        virReportInvalidArg(nkeycodes,\n                            _(\"nkeycodes must be <= %d\"),\n                            VIR_DOMAIN_SEND_KEY_MAX_KEYS);\n        goto error;\n    }\n\n    if (conn->driver->domainSendKey) {\n        int ret;\n        ret = conn->driver->domainSendKey(domain, codeset, holdtime,\n                                          keycodes, nkeycodes, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSendProcessSignal:\n * @domain: pointer to domain object\n * @pid_value: a positive integer process ID, or negative integer process group ID\n * @signum: a signal from the virDomainProcessSignal enum\n * @flags: one of the virDomainProcessSignalFlag values\n *\n * Send a signal to the designated process in the guest\n *\n * The signal numbers must be taken from the virDomainProcessSignal\n * enum. These will be translated to the corresponding signal\n * number for the guest OS, by the guest agent delivering the\n * signal. If there is no mapping from virDomainProcessSignal to\n * the native OS signals, this API will report an error.\n *\n * If @pid_value is an integer greater than zero, it is\n * treated as a process ID. If @pid_value is an integer\n * less than zero, it is treated as a process group ID.\n * All the @pid_value numbers are from the container/guest\n * namespace. The value zero is not valid.\n *\n * Not all hypervisors will support sending signals to\n * arbitrary processes or process groups. If this API is\n * implemented the minimum requirement is to be able to\n * use @pid_value == 1 (i.e. kill init). No other value is\n * required to be supported.\n *\n * If the @signum is VIR_DOMAIN_PROCESS_SIGNAL_NOP then this\n * API will simply report whether the process is running in\n * the container/guest.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSendProcessSignal(virDomainPtr domain,\n                           long long pid_value,\n                           unsigned int signum,\n                           unsigned int flags)\n{\n    virConnectPtr conn;\n    VIR_DOMAIN_DEBUG(domain, \"pid=%lld, signum=%u flags=%x\",\n                     pid_value, signum, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonZeroArgGoto(pid_value, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainSendProcessSignal) {\n        int ret;\n        ret = conn->driver->domainSendProcessSignal(domain,\n                                                    pid_value,\n                                                    signum,\n                                                    flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetVcpus:\n * @domain: pointer to domain object, or NULL for Domain0\n * @nvcpus: the new number of virtual CPUs for this domain\n *\n * Dynamically change the number of virtual CPUs used by the domain.\n * Note that this call may fail if the underlying virtualization hypervisor\n * does not support it or if growing the number is arbitrarily limited.\n * This function may require privileged access to the hypervisor.\n *\n * Note that if this call is executed before the guest has finished booting,\n * the guest may fail to process the change.\n *\n * This command only changes the runtime configuration of the domain,\n * so can only be called on an active domain.  It is hypervisor-dependent\n * whether it also affects persistent configuration; for more control,\n * use virDomainSetVcpusFlags().\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetVcpus(virDomainPtr domain, unsigned int nvcpus)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"nvcpus=%u\", nvcpus);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(nvcpus, error);\n\n    if (conn->driver->domainSetVcpus) {\n        int ret;\n        ret = conn->driver->domainSetVcpus(domain, nvcpus);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetVcpusFlags:\n * @domain: pointer to domain object, or NULL for Domain0\n * @nvcpus: the new number of virtual CPUs for this domain, must be at least 1\n * @flags: bitwise-OR of virDomainVcpuFlags\n *\n * Dynamically change the number of virtual CPUs used by the domain.\n * Note that this call may fail if the underlying virtualization hypervisor\n * does not support it or if growing the number is arbitrarily limited.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE to affect a running\n * domain (which may fail if domain is not active), or\n * VIR_DOMAIN_AFFECT_CONFIG to affect the next boot via the XML\n * description of the domain.  Both flags may be set.\n * If neither flag is specified (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT),\n * then an inactive domain modifies persistent setup, while an active domain\n * is hypervisor-dependent on whether just live or both live and persistent\n * state is changed.\n *\n * Note that if this call is executed before the guest has finished booting,\n * the guest may fail to process the change.\n *\n * If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then\n * VIR_DOMAIN_AFFECT_LIVE must be clear, and only the maximum virtual\n * CPU limit is altered; generally, this value must be less than or\n * equal to virConnectGetMaxVcpus().  Otherwise, this call affects the\n * current virtual CPU limit, which must be less than or equal to the\n * maximum limit.\n *\n * If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of processors is\n * modified inside the guest instead of the hypervisor. This flag can only\n * be used with live guests and is incompatible with VIR_DOMAIN_VCPU_MAXIMUM.\n * The usage of this flag may require a guest agent configured.\n *\n * Not all hypervisors can support all flag combinations.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetVcpusFlags(virDomainPtr domain, unsigned int nvcpus,\n                       unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"nvcpus=%u, flags=%x\", nvcpus, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    VIR_REQUIRE_FLAG_GOTO(VIR_DOMAIN_VCPU_MAXIMUM,\n                          VIR_DOMAIN_AFFECT_CONFIG,\n                          error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_VCPU_GUEST,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    virCheckNonZeroArgGoto(nvcpus, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainSetVcpusFlags) {\n        int ret;\n        ret = conn->driver->domainSetVcpusFlags(domain, nvcpus, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetVcpusFlags:\n * @domain: pointer to domain object, or NULL for Domain0\n * @flags: bitwise-OR of virDomainVcpuFlags\n *\n * Query the number of virtual CPUs used by the domain.  Note that\n * this call may fail if the underlying virtualization hypervisor does\n * not support it.  This function may require privileged access to the\n * hypervisor.\n *\n * If @flags includes VIR_DOMAIN_AFFECT_LIVE, this will query a\n * running domain (which will fail if domain is not active); if\n * it includes VIR_DOMAIN_AFFECT_CONFIG, this will query the XML\n * description of the domain.  It is an error to set both flags.\n * If neither flag is set (that is, VIR_DOMAIN_AFFECT_CURRENT),\n * then the configuration queried depends on whether the domain\n * is currently running.\n *\n * If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum\n * virtual CPU limit is queried.  Otherwise, this call queries the\n * current virtual CPU count.\n *\n * If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of the processors\n * is queried in the guest instead of the hypervisor. This flag is only usable\n * on live domains. Guest agent may be needed for this flag to be available.\n *\n * Returns the number of vCPUs in case of success, -1 in case of failure.\n */\nint\nvirDomainGetVcpusFlags(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    if (flags & VIR_DOMAIN_VCPU_GUEST)\n        virCheckReadOnlyGoto(conn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    if (conn->driver->domainGetVcpusFlags) {\n        int ret;\n        ret = conn->driver->domainGetVcpusFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPinVcpu:\n * @domain: pointer to domain object, or NULL for Domain0\n * @vcpu: virtual CPU number\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n *\n * Dynamically change the real CPUs which can be allocated to a virtual CPU.\n * This function may require privileged access to the hypervisor.\n *\n * This command only changes the runtime configuration of the domain,\n * so can only be called on an active domain.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainPinVcpu(virDomainPtr domain, unsigned int vcpu,\n                 unsigned char *cpumap, int maplen)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"vcpu=%u, cpumap=%p, maplen=%d\",\n                     vcpu, cpumap, maplen);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinVcpu) {\n        int ret;\n        ret = conn->driver->domainPinVcpu(domain, vcpu, cpumap, maplen);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPinVcpuFlags:\n * @domain: pointer to domain object, or NULL for Domain0\n * @vcpu: virtual CPU number\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically change the real CPUs which can be allocated to a virtual CPU.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n * Not all hypervisors can support all flag combinations.\n *\n * See also virDomainGetVcpuPinInfo for querying this information.\n *\n * Returns 0 in case of success, -1 in case of failure.\n *\n */\nint\nvirDomainPinVcpuFlags(virDomainPtr domain, unsigned int vcpu,\n                      unsigned char *cpumap, int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"vcpu=%u, cpumap=%p, maplen=%d, flags=%x\",\n                     vcpu, cpumap, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinVcpuFlags) {\n        int ret;\n        ret = conn->driver->domainPinVcpuFlags(domain, vcpu, cpumap, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetVcpuPinInfo:\n * @domain: pointer to domain object, or NULL for Domain0\n * @ncpumaps: the number of cpumap (listed first to match virDomainGetVcpus)\n * @cpumaps: pointer to a bit map of real CPUs for all vcpus of this\n *     domain (in 8-bit bytes) (OUT)\n *     It's assumed there is <ncpumaps> cpumap in cpumaps array.\n *     The memory allocated to cpumaps must be (ncpumaps * maplen) bytes\n *     (ie: calloc(ncpumaps, maplen)).\n *     One cpumap inside cpumaps has the format described in\n *     virDomainPinVcpu() API.\n *     Must not be NULL.\n * @maplen: the number of bytes in one cpumap, from 1 up to size of CPU map.\n *     Must be positive.\n * @flags: bitwise-OR of virDomainModificationImpact\n *     Must not be VIR_DOMAIN_AFFECT_LIVE and\n *     VIR_DOMAIN_AFFECT_CONFIG concurrently.\n *\n * Query the CPU affinity setting of all virtual CPUs of domain, store it\n * in cpumaps.\n *\n * Returns the number of virtual CPUs in case of success,\n * -1 in case of failure.\n */\nint\nvirDomainGetVcpuPinInfo(virDomainPtr domain, int ncpumaps,\n                        unsigned char *cpumaps, int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"ncpumaps=%d, cpumaps=%p, maplen=%d, flags=%x\",\n                     ncpumaps, cpumaps, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(cpumaps, error);\n    virCheckPositiveArgGoto(ncpumaps, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (INT_MULTIPLY_OVERFLOW(ncpumaps, maplen)) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %d * %d\"),\n                       ncpumaps, maplen);\n        goto error;\n    }\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    if (conn->driver->domainGetVcpuPinInfo) {\n        int ret;\n        ret = conn->driver->domainGetVcpuPinInfo(domain, ncpumaps,\n                                                 cpumaps, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPinEmulator:\n * @domain: pointer to domain object, or NULL for Domain0\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically change the real CPUs which can be allocated to all emulator\n * threads. This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n * Not all hypervisors can support all flag combinations.\n *\n * See also virDomainGetEmulatorPinInfo for querying this information.\n *\n * Returns 0 in case of success, -1 in case of failure.\n *\n */\nint\nvirDomainPinEmulator(virDomainPtr domain, unsigned char *cpumap,\n                     int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cpumap=%p, maplen=%d, flags=%x\",\n                     cpumap, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinEmulator) {\n        int ret;\n        ret = conn->driver->domainPinEmulator(domain, cpumap, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetEmulatorPinInfo:\n * @domain: pointer to domain object, or NULL for Domain0\n * @cpumap: pointer to a bit map of real CPUs for all emulator threads of\n *     this domain (in 8-bit bytes) (OUT)\n *     There is only one cpumap for all emulator threads.\n *     Must not be NULL.\n * @maplen: the number of bytes in one cpumap, from 1 up to size of CPU map.\n *     Must be positive.\n * @flags: bitwise-OR of virDomainModificationImpact\n *     Must not be VIR_DOMAIN_AFFECT_LIVE and\n *     VIR_DOMAIN_AFFECT_CONFIG concurrently.\n *\n * Query the CPU affinity setting of all emulator threads of domain, store\n * it in cpumap.\n *\n * Returns 1 in case of success,\n * 0 in case of no emulator threads are pined to pcpus,\n * -1 in case of failure.\n */\nint\nvirDomainGetEmulatorPinInfo(virDomainPtr domain, unsigned char *cpumap,\n                            int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cpumap=%p, maplen=%d, flags=%x\",\n                     cpumap, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetEmulatorPinInfo) {\n        int ret;\n        ret = conn->driver->domainGetEmulatorPinInfo(domain, cpumap,\n                                                     maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetVcpus:\n * @domain: pointer to domain object, or NULL for Domain0\n * @info: pointer to an array of virVcpuInfo structures (OUT)\n * @maxinfo: number of structures in info array\n * @cpumaps: pointer to a bit map of real CPUs for all vcpus of this\n *      domain (in 8-bit bytes) (OUT)\n *      If cpumaps is NULL, then no cpumap information is returned by the API.\n *      It's assumed there is <maxinfo> cpumap in cpumaps array.\n *      The memory allocated to cpumaps must be (maxinfo * maplen) bytes\n *      (ie: calloc(maxinfo, maplen)).\n *      One cpumap inside cpumaps has the format described in\n *      virDomainPinVcpu() API.\n * @maplen: number of bytes in one cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      Must be zero when cpumaps is NULL and positive when it is non-NULL.\n *\n * Extract information about virtual CPUs of domain, store it in info array\n * and also in cpumaps if this pointer isn't NULL.  This call may fail\n * on an inactive domain.\n *\n * See also virDomainGetVcpuPinInfo for querying just cpumaps, including on\n * an inactive domain.\n *\n * Returns the number of info filled in case of success, -1 in case of failure.\n */\nint\nvirDomainGetVcpus(virDomainPtr domain, virVcpuInfoPtr info, int maxinfo,\n                  unsigned char *cpumaps, int maplen)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p, maxinfo=%d, cpumaps=%p, maplen=%d\",\n                     info, maxinfo, cpumaps, maplen);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n    virCheckPositiveArgGoto(maxinfo, error);\n\n    /* Ensure that domainGetVcpus (aka remoteDomainGetVcpus) does not\n       try to memcpy anything into a NULL pointer.  */\n    if (cpumaps)\n        virCheckPositiveArgGoto(maplen, error);\n    else\n        virCheckZeroArgGoto(maplen, error);\n\n    if (cpumaps && INT_MULTIPLY_OVERFLOW(maxinfo, maplen)) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %d * %d\"),\n                       maxinfo, maplen);\n        goto error;\n    }\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetVcpus) {\n        int ret;\n        ret = conn->driver->domainGetVcpus(domain, info, maxinfo,\n                                           cpumaps, maplen);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetMaxVcpus:\n * @domain: pointer to domain object\n *\n * Provides the maximum number of virtual CPUs supported for\n * the guest VM. If the guest is inactive, this is basically\n * the same as virConnectGetMaxVcpus(). If the guest is running\n * this will reflect the maximum number of virtual CPUs the\n * guest was booted with.  For more details, see virDomainGetVcpusFlags().\n *\n * Returns the maximum of virtual CPU or -1 in case of error.\n */\nint\nvirDomainGetMaxVcpus(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMaxVcpus) {\n        int ret;\n        ret = conn->driver->domainGetMaxVcpus(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetIOThreadInfo:\n * @dom: a domain object\n * @info: pointer to an array of virDomainIOThreadInfo structures (OUT)\n * @flags: bitwise-OR of virDomainModificationImpact\n *     Must not be VIR_DOMAIN_AFFECT_LIVE and\n *     VIR_DOMAIN_AFFECT_CONFIG concurrently.\n *\n * Fetch IOThreads of an active domain including the cpumap information to\n * determine on which CPU the IOThread has affinity to run.\n *\n * Returns the number of IOThreads or -1 in case of error.\n * On success, the array of information is stored into @info. The caller is\n * responsible for calling virDomainIOThreadInfoFree() on each array element,\n * then calling free() on @info. On error, @info is set to NULL.\n */\nint\nvirDomainGetIOThreadInfo(virDomainPtr dom,\n                         virDomainIOThreadInfoPtr **info,\n                         unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"info=%p flags=%x\", info, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(info, error);\n    *info = NULL;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    if (dom->conn->driver->domainGetIOThreadInfo) {\n        int ret;\n        ret = dom->conn->driver->domainGetIOThreadInfo(dom, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainIOThreadInfoFree:\n * @info: pointer to a virDomainIOThreadInfo object\n *\n * Frees the memory used by @info.\n */\nvoid\nvirDomainIOThreadInfoFree(virDomainIOThreadInfoPtr info)\n{\n    if (!info)\n        return;\n\n    VIR_FREE(info->cpumap);\n    VIR_FREE(info);\n}\n\n\n/**\n * virDomainPinIOThread:\n * @domain: a domain object\n * @iothread_id: the IOThread ID to set the CPU affinity\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically change the real CPUs which can be allocated to an IOThread.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n * Not all hypervisors can support all flag combinations.\n *\n * See also virDomainGetIOThreadInfo for querying this information.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainPinIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned char *cpumap,\n                     int maplen,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, cpumap=%p, maplen=%d\",\n                     iothread_id, cpumap, maplen);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinIOThread) {\n        int ret;\n        ret = conn->driver->domainPinIOThread(domain, iothread_id,\n                                              cpumap, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainAddIOThread:\n * @domain: a domain object\n * @iothread_id: the specific IOThread ID value to add\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically add an IOThread to the domain. It is left up to the\n * underlying virtual hypervisor to determine the valid range for an\n * @iothread_id and determining whether the @iothread_id already exists.\n *\n * Note that this call can fail if the underlying virtualization hypervisor\n * does not support it or if growing the number is arbitrarily limited.\n * This function requires privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainAddIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=%x\",\n                     iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainAddIOThread) {\n        int ret;\n        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDelIOThread:\n * @domain: a domain object\n * @iothread_id: the specific IOThread ID value to delete\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically delete an IOThread from the domain. The @iothread_id to be\n * deleted must not have a resource associated with it and can be any of\n * the currently valid IOThread ID's.\n *\n * Note that this call can fail if the underlying virtualization hypervisor\n * does not support it or if reducing the number is arbitrarily limited.\n * This function requires privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSecurityLabel:\n * @domain: a domain object\n * @seclabel: pointer to a virSecurityLabel structure\n *\n * Extract security label of an active domain. The 'label' field\n * in the @seclabel argument will be initialized to the empty\n * string if the domain is not running under a security model.\n *\n * Returns 0 in case of success, -1 in case of failure\n */\nint\nvirDomainGetSecurityLabel(virDomainPtr domain, virSecurityLabelPtr seclabel)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"seclabel=%p\", seclabel);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(seclabel, error);\n\n    if (conn->driver->domainGetSecurityLabel) {\n        int ret;\n        ret = conn->driver->domainGetSecurityLabel(domain, seclabel);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSecurityLabelList:\n * @domain: a domain object\n * @seclabels: will be auto-allocated and filled with domains' security labels.\n * Caller must free memory on return.\n *\n * Extract the security labels of an active domain. The 'label' field\n * in the @seclabels argument will be initialized to the empty\n * string if the domain is not running under a security model.\n *\n * Returns number of elemnets in @seclabels on success, -1 in case of failure.\n */\nint\nvirDomainGetSecurityLabelList(virDomainPtr domain,\n                              virSecurityLabelPtr* seclabels)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"seclabels=%p\", seclabels);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(seclabels, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSecurityLabelList) {\n        int ret;\n        ret = conn->driver->domainGetSecurityLabelList(domain, seclabels);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMetadata:\n * @domain: a domain object\n * @type: type of metadata, from virDomainMetadataType\n * @metadata: new metadata text\n * @key: XML namespace key, or NULL\n * @uri: XML namespace URI, or NULL\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Sets the appropriate domain element given by @type to the\n * value of @metadata.  A @type of VIR_DOMAIN_METADATA_DESCRIPTION\n * is free-form text; VIR_DOMAIN_METADATA_TITLE is free-form, but no\n * newlines are permitted, and should be short (although the length is\n * not enforced). For these two options @key and @uri are irrelevant and\n * must be set to NULL.\n *\n * For type VIR_DOMAIN_METADATA_ELEMENT @metadata  must be well-formed\n * XML belonging to namespace defined by @uri with local name @key.\n *\n * Passing NULL for @metadata says to remove that element from the\n * domain XML (passing the empty string leaves the element present).\n *\n * The resulting metadata will be present in virDomainGetXMLDesc(),\n * as well as quick access through virDomainGetMetadata().\n *\n * @flags controls whether the live domain, persistent configuration,\n * or both will be modified.\n *\n * Returns 0 on success, -1 in case of failure.\n */\nint\nvirDomainSetMetadata(virDomainPtr domain,\n                     int type,\n                     const char *metadata,\n                     const char *key,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"type=%d, metadata='%s', key='%s', uri='%s', flags=%x\",\n                     type, NULLSTR(metadata), NULLSTR(key), NULLSTR(uri),\n                     flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    switch (type) {\n    case VIR_DOMAIN_METADATA_TITLE:\n        if (metadata && strchr(metadata, '\\n')) {\n            virReportInvalidArg(metadata, \"%s\",\n                                _(\"metadata title can't contain \"\n                                  \"newlines\"));\n            goto error;\n        }\n        /* fallthrough */\n    case VIR_DOMAIN_METADATA_DESCRIPTION:\n        virCheckNullArgGoto(uri, error);\n        virCheckNullArgGoto(key, error);\n        break;\n    case VIR_DOMAIN_METADATA_ELEMENT:\n        virCheckNonNullArgGoto(uri, error);\n        if (metadata)\n            virCheckNonNullArgGoto(key, error);\n        break;\n    default:\n        /* For future expansion */\n        break;\n    }\n\n    if (conn->driver->domainSetMetadata) {\n        int ret;\n        ret = conn->driver->domainSetMetadata(domain, type, metadata, key, uri,\n                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetMetadata:\n * @domain: a domain object\n * @type: type of metadata, from virDomainMetadataType\n * @uri: XML namespace identifier\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Retrieves the appropriate domain element given by @type.\n * If VIR_DOMAIN_METADATA_ELEMENT is requested parameter @uri\n * must be set to the name of the namespace the requested elements\n * belong to, otherwise must be NULL.\n *\n * If an element of the domain XML is not present, the resulting\n * error will be VIR_ERR_NO_DOMAIN_METADATA.  This method forms\n * a shortcut for seeing information from virDomainSetMetadata()\n * without having to go through virDomainGetXMLDesc().\n *\n * @flags controls whether the live domain or persistent\n * configuration will be queried.\n *\n * Returns the metadata string on success (caller must free),\n * or NULL in case of failure.\n */\nchar *\nvirDomainGetMetadata(virDomainPtr domain,\n                     int type,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"type=%d, uri='%s', flags=%x\",\n                     type, NULLSTR(uri), flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    switch (type) {\n    case VIR_DOMAIN_METADATA_TITLE:\n    case VIR_DOMAIN_METADATA_DESCRIPTION:\n        virCheckNullArgGoto(uri, error);\n        break;\n    case VIR_DOMAIN_METADATA_ELEMENT:\n        virCheckNonNullArgGoto(uri, error);\n        break;\n    default:\n        /* For future expansion */\n        break;\n    }\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMetadata) {\n        char *ret;\n        if (!(ret = conn->driver->domainGetMetadata(domain, type, uri, flags)))\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainAttachDevice:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n *\n * Create a virtual device attachment to backend.  This function,\n * having hotplug semantics, is only allowed on an active domain.\n *\n * For compatibility, this method can also be used to change the media\n * in an existing CDROM/Floppy device, however, applications are\n * recommended to use the virDomainUpdateDeviceFlag method instead.\n *\n * Be aware that hotplug changes might not persist across a domain going\n * into S4 state (also known as hibernation) unless you also modify the\n * persistent domain definition.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainAttachDevice(virDomainPtr domain, const char *xml)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s\", xml);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainAttachDevice) {\n       int ret;\n       ret = conn->driver->domainAttachDevice(domain, xml);\n       if (ret < 0)\n          goto error;\n       return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainAttachDeviceFlags:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n * @flags: bitwise-OR of virDomainDeviceModifyFlags\n *\n * Attach a virtual device to a domain, using the flags parameter\n * to control how the device is attached.  VIR_DOMAIN_AFFECT_CURRENT\n * specifies that the device allocation is made based on current domain\n * state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\n * allocated to the active domain instance only and is not added to the\n * persisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG\n * specifies that the device shall be allocated to the persisted domain\n * configuration only.  Note that the target hypervisor must return an\n * error if unable to satisfy flags.  E.g. the hypervisor driver will\n * return failure if LIVE is specified but it only supports modifying the\n * persisted device allocation.\n *\n * For compatibility, this method can also be used to change the media\n * in an existing CDROM/Floppy device, however, applications are\n * recommended to use the virDomainUpdateDeviceFlag method instead.\n *\n * Be aware that hotplug changes might not persist across a domain going\n * into S4 state (also known as hibernation) unless you also modify the\n * persistent domain definition.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainAttachDeviceFlags(virDomainPtr domain,\n                           const char *xml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s, flags=%x\", xml, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainAttachDeviceFlags) {\n        int ret;\n        ret = conn->driver->domainAttachDeviceFlags(domain, xml, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDetachDevice:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n *\n * This is an equivalent of virDomainDetachDeviceFlags() when called with\n * @flags parameter set to VIR_DOMAIN_AFFECT_LIVE.\n *\n * See virDomainDetachDeviceFlags() for more details.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainDetachDevice(virDomainPtr domain, const char *xml)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s\", xml);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDetachDevice) {\n        int ret;\n        ret = conn->driver->domainDetachDevice(domain, xml);\n         if (ret < 0)\n             goto error;\n         return ret;\n     }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDetachDeviceFlags:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n * @flags: bitwise-OR of virDomainDeviceModifyFlags\n *\n * Detach a virtual device from a domain, using the flags parameter\n * to control how the device is detached.  VIR_DOMAIN_AFFECT_CURRENT\n * specifies that the device allocation is removed based on current domain\n * state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\n * deallocated from the active domain instance only and is not from the\n * persisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG\n * specifies that the device shall be deallocated from the persisted domain\n * configuration only.  Note that the target hypervisor must return an\n * error if unable to satisfy flags.  E.g. the hypervisor driver will\n * return failure if LIVE is specified but it only supports removing the\n * persisted device allocation.\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation on the device being detached; in that case,\n * use virDomainBlockJobAbort() to stop the block copy first.\n *\n * Beware that depending on the hypervisor and device type, detaching a device\n * from a running domain may be asynchronous. That is, calling\n * virDomainDetachDeviceFlags may just request device removal while the device\n * is actually removed later (in cooperation with a guest OS). Previously,\n * this fact was ignored and the device could have been removed from domain\n * configuration before it was actually removed by the hypervisor causing\n * various failures on subsequent operations. To check whether the device was\n * successfully removed, either recheck domain configuration using\n * virDomainGetXMLDesc() or add a handler for the VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED\n * event. In case the device is already gone when virDomainDetachDeviceFlags\n * returns, the event is delivered before this API call ends. To help existing\n * clients work better in most cases, this API will try to transform an\n * asynchronous device removal that finishes shortly after the request into\n * a synchronous removal. In other words, this API may wait a bit for the\n * removal to complete in case it was not synchronous.\n *\n * Be aware that hotplug changes might not persist across a domain going\n * into S4 state (also known as hibernation) unless you also modify the\n * persistent domain definition.\n *\n * The supplied XML description of the device should be as specific\n * as its definition in the domain XML. The set of attributes used\n * to match the device are internal to the drivers. Using a partial definition,\n * or attempting to detach a device that is not present in the domain XML,\n * but shares some specific attributes with one that is present,\n * may lead to unexpected results.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainDetachDeviceFlags(virDomainPtr domain,\n                           const char *xml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s, flags=%x\", xml, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDetachDeviceFlags) {\n        int ret;\n        ret = conn->driver->domainDetachDeviceFlags(domain, xml, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainUpdateDeviceFlags:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n * @flags: bitwise-OR of virDomainDeviceModifyFlags\n *\n * Change a virtual device on a domain, using the flags parameter\n * to control how the device is changed.  VIR_DOMAIN_AFFECT_CURRENT\n * specifies that the device change is made based on current domain\n * state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\n * changed on the active domain instance only and is not added to the\n * persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG\n * specifies that the device shall be changed on the persisted domain\n * configuration only.  Note that the target hypervisor must return an\n * error if unable to satisfy flags.  E.g. the hypervisor driver will\n * return failure if LIVE is specified but it only supports modifying the\n * persisted device allocation.\n *\n * This method is used for actions such changing CDROM/Floppy device\n * media, altering the graphics configuration such as password,\n * reconfiguring the NIC device backend connectivity, etc.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainUpdateDeviceFlags(virDomainPtr domain,\n                           const char *xml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s, flags=%x\", xml, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainUpdateDeviceFlags) {\n        int ret;\n        ret = conn->driver->domainUpdateDeviceFlags(domain, xml, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventRegister:\n * @conn: pointer to the connection\n * @cb: callback to the function handling domain events\n * @opaque: opaque data to pass on to the callback\n * @freecb: optional function to deallocate opaque when not used anymore\n *\n * Adds a callback to receive notifications of domain lifecycle events\n * occurring on a connection.  This function requires that an event loop\n * has been previously registered with virEventRegisterImpl() or\n * virEventRegisterDefaultImpl().\n *\n * Use of this method is no longer recommended. Instead applications\n * should try virConnectDomainEventRegisterAny() which has a more flexible\n * API contract.\n *\n * The virDomainPtr object handle passed into the callback upon delivery\n * of an event is only valid for the duration of execution of the callback.\n * If the callback wishes to keep the domain object after the callback returns,\n * it shall take a reference to it, by calling virDomainRef.\n * The reference can be released once the object is no longer required\n * by calling virDomainFree.\n *\n * Returns 0 on success, -1 on failure.  Older versions of some hypervisors\n * sometimes returned a positive number on success, but without any reliable\n * semantics on what that number represents.\n */\nint\nvirConnectDomainEventRegister(virConnectPtr conn,\n                              virConnectDomainEventCallback cb,\n                              void *opaque,\n                              virFreeCallback freecb)\n{\n    VIR_DEBUG(\"conn=%p, cb=%p, opaque=%p, freecb=%p\", conn, cb, opaque, freecb);\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver && conn->driver->connectDomainEventRegister) {\n        int ret;\n        ret = conn->driver->connectDomainEventRegister(conn, cb, opaque, freecb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventDeregister:\n * @conn: pointer to the connection\n * @cb: callback to the function handling domain events\n *\n * Removes a callback previously registered with the\n * virConnectDomainEventRegister() function.\n *\n * Use of this method is no longer recommended. Instead applications\n * should try virConnectDomainEventDeregisterAny() which has a more flexible\n * API contract\n *\n * Returns 0 on success, -1 on failure.  Older versions of some hypervisors\n * sometimes returned a positive number on success, but without any reliable\n * semantics on what that number represents.\n */\nint\nvirConnectDomainEventDeregister(virConnectPtr conn,\n                                virConnectDomainEventCallback cb)\n{\n    VIR_DEBUG(\"conn=%p, cb=%p\", conn, cb);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver && conn->driver->connectDomainEventDeregister) {\n        int ret;\n        ret = conn->driver->connectDomainEventDeregister(conn, cb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainIsActive:\n * @dom: pointer to the domain object\n *\n * Determine if the domain is currently running\n *\n * Returns 1 if running, 0 if inactive, -1 on error\n */\nint\nvirDomainIsActive(virDomainPtr dom)\n{\n    VIR_DEBUG(\"dom=%p\", dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainIsActive) {\n        int ret;\n        ret = dom->conn->driver->domainIsActive(dom);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainIsPersistent:\n * @dom: pointer to the domain object\n *\n * Determine if the domain has a persistent configuration\n * which means it will still exist after shutting down\n *\n * Returns 1 if persistent, 0 if transient, -1 on error\n */\nint\nvirDomainIsPersistent(virDomainPtr dom)\n{\n    VIR_DOMAIN_DEBUG(dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainIsPersistent) {\n        int ret;\n        ret = dom->conn->driver->domainIsPersistent(dom);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainRename:\n * @dom: pointer to the domain object\n * @new_name: new domain name\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Rename a domain. New domain name is specified in the second\n * argument. Depending on each driver implementation it may be\n * required that domain is in a specific state.\n *\n * There might be some attributes and/or elements in domain XML that if no\n * value provided at XML defining time, libvirt will derive their value from\n * the domain name. These are not updated by this API. Users are strongly\n * advised to change these after the rename was successful.\n *\n * Returns 0 if successfully renamed, -1 on error\n */\nint\nvirDomainRename(virDomainPtr dom,\n                const char *new_name,\n                unsigned int flags)\n{\n    VIR_DEBUG(\"dom=%p, new_name=%s\", dom, NULLSTR(new_name));\n\n    virResetLastError();\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(new_name, error);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainRename) {\n        int ret = dom->conn->driver->domainRename(dom, new_name, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainIsUpdated:\n * @dom: pointer to the domain object\n *\n * Determine if the domain has been updated.\n *\n * Returns 1 if updated, 0 if not, -1 on error\n */\nint\nvirDomainIsUpdated(virDomainPtr dom)\n{\n    VIR_DOMAIN_DEBUG(dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainIsUpdated) {\n        int ret;\n        ret = dom->conn->driver->domainIsUpdated(dom);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetJobInfo:\n * @domain: a domain object\n * @info: pointer to a virDomainJobInfo structure allocated by the user\n *\n * Extract information about progress of a background job on a domain.\n * Will return an error if the domain is not active.\n *\n * This function returns a limited amount of information in comparison\n * to virDomainGetJobStats().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p\", info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetJobInfo) {\n        int ret;\n        ret = conn->driver->domainGetJobInfo(domain, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetJobStats:\n * @domain: a domain object\n * @type: where to store the job type (one of virDomainJobType)\n * @params: where to store job statistics\n * @nparams: number of items in @params\n * @flags: bitwise-OR of virDomainGetJobStatsFlags\n *\n * Extract information about progress of a background job on a domain.\n * Will return an error if the domain is not active. The function returns\n * a superset of progress information provided by virDomainGetJobInfo.\n * Possible fields returned in @params are defined by VIR_DOMAIN_JOB_*\n * macros and new fields will likely be introduced in the future so callers\n * may receive fields that they do not understand in case they talk to a\n * newer server.\n *\n * When @flags contains VIR_DOMAIN_JOB_STATS_COMPLETED, the function will\n * return statistics about a recently completed job. Specifically, this\n * flag may be used to query statistics of a completed incoming migration.\n * Statistics of a completed job are automatically destroyed once read or\n * when libvirtd is restarted. Note that time information returned for\n * completed migrations may be completely irrelevant unless both source and\n * destination hosts have synchronized time (i.e., NTP daemon is running on\n * both of them).\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetJobStats(virDomainPtr domain,\n                     int *type,\n                     virTypedParameterPtr *params,\n                     int *nparams,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"type=%p, params=%p, nparams=%p, flags=%x\",\n                     type, params, nparams, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(type, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNullArgGoto(nparams, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetJobStats) {\n        int ret;\n        ret = conn->driver->domainGetJobStats(domain, type, params,\n                                              nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainAbortJob:\n * @domain: a domain object\n *\n * Requests that the current background job be aborted at the\n * soonest opportunity.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainAbortJob(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainAbortJob) {\n        int ret;\n        ret = conn->driver->domainAbortJob(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateSetMaxDowntime:\n * @domain: a domain object\n * @downtime: maximum tolerable downtime for live migration, in milliseconds\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Sets maximum tolerable time for which the domain is allowed to be paused\n * at the end of live migration. It's supposed to be called while the domain is\n * being live-migrated as a reaction to migration progress.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateSetMaxDowntime(virDomainPtr domain,\n                               unsigned long long downtime,\n                               unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"downtime=%llu, flags=%x\", downtime, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateSetMaxDowntime) {\n        if (conn->driver->domainMigrateSetMaxDowntime(domain, downtime, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateGetCompressionCache:\n * @domain: a domain object\n * @cacheSize: return value of current size of the cache (in bytes)\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Gets current size of the cache (in bytes) used for compressing repeatedly\n * transferred memory pages during live migration.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateGetCompressionCache(virDomainPtr domain,\n                                    unsigned long long *cacheSize,\n                                    unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cacheSize=%p, flags=%x\", cacheSize, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(cacheSize, error);\n\n    if (conn->driver->domainMigrateGetCompressionCache) {\n        if (conn->driver->domainMigrateGetCompressionCache(domain, cacheSize,\n                                                           flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateSetCompressionCache:\n * @domain: a domain object\n * @cacheSize: size of the cache (in bytes) used for compression\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Sets size of the cache (in bytes) used for compressing repeatedly\n * transferred memory pages during live migration. It's supposed to be called\n * while the domain is being live-migrated as a reaction to migration progress\n * and increasing number of compression cache misses obtained from\n * virDomainGetJobStats.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateSetCompressionCache(virDomainPtr domain,\n                                    unsigned long long cacheSize,\n                                    unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cacheSize=%llu, flags=%x\", cacheSize, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateSetCompressionCache) {\n        if (conn->driver->domainMigrateSetCompressionCache(domain, cacheSize,\n                                                           flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateSetMaxSpeed:\n * @domain: a domain object\n * @bandwidth: migration bandwidth limit in MiB/s\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter. Not all hypervisors\n * will support a bandwidth cap\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateSetMaxSpeed(virDomainPtr domain,\n                            unsigned long bandwidth,\n                            unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"bandwidth=%lu, flags=%x\", bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateSetMaxSpeed) {\n        if (conn->driver->domainMigrateSetMaxSpeed(domain, bandwidth, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateGetMaxSpeed:\n * @domain: a domain object\n * @bandwidth: return value of current migration bandwidth limit in MiB/s\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Get the current maximum bandwidth (in MiB/s) that will be used if the\n * domain is migrated.  Not all hypervisors will support a bandwidth limit.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateGetMaxSpeed(virDomainPtr domain,\n                            unsigned long *bandwidth,\n                            unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"bandwidth = %p, flags=%x\", bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(bandwidth, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateGetMaxSpeed) {\n        if (conn->driver->domainMigrateGetMaxSpeed(domain, bandwidth, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventRegisterAny:\n * @conn: pointer to the connection\n * @dom: pointer to the domain\n * @eventID: the event type to receive\n * @cb: callback to the function handling domain events\n * @opaque: opaque data to pass on to the callback\n * @freecb: optional function to deallocate opaque when not used anymore\n *\n * Adds a callback to receive notifications of arbitrary domain events\n * occurring on a domain.  This function requires that an event loop\n * has been previously registered with virEventRegisterImpl() or\n * virEventRegisterDefaultImpl().\n *\n * If @dom is NULL, then events will be monitored for any domain. If @dom\n * is non-NULL, then only the specific domain will be monitored.\n *\n * Most types of event have a callback providing a custom set of parameters\n * for the event. When registering an event, it is thus necessary to use\n * the VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer\n * to match the signature of this method.\n *\n * The virDomainPtr object handle passed into the callback upon delivery\n * of an event is only valid for the duration of execution of the callback.\n * If the callback wishes to keep the domain object after the callback returns,\n * it shall take a reference to it, by calling virDomainRef().\n * The reference can be released once the object is no longer required\n * by calling virDomainFree().\n *\n * The return value from this method is a positive integer identifier\n * for the callback. To unregister a callback, this callback ID should\n * be passed to the virConnectDomainEventDeregisterAny() method.\n *\n * Returns a callback identifier on success, -1 on failure.\n */\nint\nvirConnectDomainEventRegisterAny(virConnectPtr conn,\n                                 virDomainPtr dom,\n                                 int eventID,\n                                 virConnectDomainEventGenericCallback cb,\n                                 void *opaque,\n                                 virFreeCallback freecb)\n{\n    VIR_DOMAIN_DEBUG(dom, \"conn=%p, eventID=%d, cb=%p, opaque=%p, freecb=%p\",\n                     conn, eventID, cb, opaque, freecb);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (dom) {\n        virCheckDomainGoto(dom, error);\n        if (dom->conn != conn) {\n            virReportInvalidArg(dom,\n                                _(\"domain '%s' must match connection\"),\n                                dom->name);\n            goto error;\n        }\n    }\n    virCheckNonNullArgGoto(cb, error);\n    virCheckNonNegativeArgGoto(eventID, error);\n    if (eventID >= VIR_DOMAIN_EVENT_ID_LAST) {\n        virReportInvalidArg(eventID,\n                            _(\"eventID must be less than %d\"),\n                            VIR_DOMAIN_EVENT_ID_LAST);\n        goto error;\n    }\n\n    if (conn->driver && conn->driver->connectDomainEventRegisterAny) {\n        int ret;\n        ret = conn->driver->connectDomainEventRegisterAny(conn, dom, eventID, cb, opaque, freecb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventDeregisterAny:\n * @conn: pointer to the connection\n * @callbackID: the callback identifier\n *\n * Removes an event callback. The callbackID parameter should be the\n * value obtained from a previous virConnectDomainEventRegisterAny() method.\n *\n * Returns 0 on success, -1 on failure.  Older versions of some hypervisors\n * sometimes returned a positive number on success, but without any reliable\n * semantics on what that number represents. */\nint\nvirConnectDomainEventDeregisterAny(virConnectPtr conn,\n                                   int callbackID)\n{\n    VIR_DEBUG(\"conn=%p, callbackID=%d\", conn, callbackID);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNegativeArgGoto(callbackID, error);\n\n    if (conn->driver && conn->driver->connectDomainEventDeregisterAny) {\n        int ret;\n        ret = conn->driver->connectDomainEventDeregisterAny(conn, callbackID);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainManagedSave:\n * @dom: pointer to the domain\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This method will suspend a domain and save its memory contents to\n * a file on disk. After the call, if successful, the domain is not\n * listed as running anymore.\n * The difference from virDomainSave() is that libvirt is keeping track of\n * the saved state itself, and will reuse it once the domain is being\n * restarted (automatically or via an explicit libvirt call).\n * As a result any running domain is sure to not have a managed saved image.\n * This also implies that managed save only works on persistent domains,\n * since the domain must still exist in order to use virDomainCreate() to\n * restart it.\n *\n * If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\n * attempt to bypass the file system cache while creating the file, or\n * fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * Normally, the managed saved state will remember whether the domain\n * was running or paused, and start will resume to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override the default saved into the file.  These two\n * flags are mutually exclusive.\n *\n * Returns 0 in case of success or -1 in case of failure\n */\nint\nvirDomainManagedSave(virDomainPtr dom, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainManagedSave) {\n        int ret;\n\n        ret = conn->driver->domainManagedSave(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainHasManagedSaveImage:\n * @dom: pointer to the domain\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Check if a domain has a managed save image as created by\n * virDomainManagedSave(). Note that any running domain should not have\n * such an image, as it should have been removed on restart.\n *\n * Returns 0 if no image is present, 1 if an image is present, and\n *         -1 in case of error\n */\nint\nvirDomainHasManagedSaveImage(virDomainPtr dom, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    if (conn->driver->domainHasManagedSaveImage) {\n        int ret;\n\n        ret = conn->driver->domainHasManagedSaveImage(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainManagedSaveRemove:\n * @dom: pointer to the domain\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Remove any managed save image for this domain.\n *\n * Returns 0 in case of success, and -1 in case of error\n */\nint\nvirDomainManagedSaveRemove(virDomainPtr dom, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainManagedSaveRemove) {\n        int ret;\n\n        ret = conn->driver->domainManagedSaveRemove(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n\n/**\n * virDomainOpenConsole:\n * @dom: a domain object\n * @dev_name: the console, serial or parallel port device alias, or NULL\n * @st: a stream to associate with the console\n * @flags: bitwise-OR of virDomainConsoleFlags\n *\n * This opens the backend associated with a console, serial or\n * parallel port device on a guest, if the backend is supported.\n * If the @dev_name is omitted, then the first console or serial\n * device is opened. The console is associated with the passed\n * in @st stream, which should have been opened in non-blocking\n * mode for bi-directional I/O.\n *\n * By default, when @flags is 0, the open will fail if libvirt\n * detects that the console is already in use by another client;\n * passing VIR_DOMAIN_CONSOLE_FORCE will cause libvirt to forcefully\n * remove the other client prior to opening this console.\n *\n * If flag VIR_DOMAIN_CONSOLE_SAFE the console is opened only in the\n * case where the hypervisor driver supports safe (mutually exclusive)\n * console handling.\n *\n * Older servers did not support either flag, and also did not forbid\n * simultaneous clients on a console, with potentially confusing results.\n * When passing @flags of 0 in order to support a wider range of server\n * versions, it is up to the client to ensure mutual exclusion.\n *\n * Returns 0 if the console was opened, -1 on error\n */\nint\nvirDomainOpenConsole(virDomainPtr dom,\n                     const char *dev_name,\n                     virStreamPtr st,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"dev_name=%s, st=%p, flags=%x\",\n                     NULLSTR(dev_name), st, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckStreamGoto(st, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(st,\n                            _(\"stream must match connection of domain '%s'\"),\n                            dom->name);\n        goto error;\n    }\n\n    if (conn->driver->domainOpenConsole) {\n        int ret;\n        ret = conn->driver->domainOpenConsole(dom, dev_name, st, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainOpenChannel:\n * @dom: a domain object\n * @name: the channel name, or NULL\n * @st: a stream to associate with the channel\n * @flags: bitwise-OR of virDomainChannelFlags\n *\n * This opens the host interface associated with a channel device on a\n * guest, if the host interface is supported.  If @name is given, it\n * can match either the device alias (e.g. \"channel0\"), or the virtio\n * target name (e.g. \"org.qemu.guest_agent.0\").  If @name is omitted,\n * then the first channel is opened. The channel is associated with\n * the passed in @st stream, which should have been opened in\n * non-blocking mode for bi-directional I/O.\n *\n * By default, when @flags is 0, the open will fail if libvirt detects\n * that the channel is already in use by another client; passing\n * VIR_DOMAIN_CHANNEL_FORCE will cause libvirt to forcefully remove the\n * other client prior to opening this channel.\n *\n * Returns 0 if the channel was opened, -1 on error\n */\nint\nvirDomainOpenChannel(virDomainPtr dom,\n                     const char *name,\n                     virStreamPtr st,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"name=%s, st=%p, flags=%x\",\n                     NULLSTR(name), st, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckStreamGoto(st, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(st,\n                            _(\"stream must match connection of domain '%s'\"),\n                            dom->name);\n        goto error;\n    }\n\n    if (conn->driver->domainOpenChannel) {\n        int ret;\n        ret = conn->driver->domainOpenChannel(dom, name, st, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockJobAbort:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @flags: bitwise-OR of virDomainBlockJobAbortFlags\n *\n * Cancel the active block job on the given disk.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, then\n * by default, this function performs a synchronous operation and the caller\n * may assume that the operation has completed when 0 is returned.  However,\n * BlockJob operations may take a long time to cancel, and during this time\n * further domain interactions may be unresponsive.  To avoid this problem,\n * pass VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC in the @flags argument to enable\n * asynchronous behavior, returning as soon as possible.  When the job has\n * been canceled, a BlockJob event will be emitted, with status\n * VIR_DOMAIN_BLOCK_JOB_CANCELED (even if the ABORT_ASYNC flag was not\n * used); it is also possible to poll virDomainBlockJobInfo() to see if\n * the job cancellation is still pending.  This type of job can be restarted\n * to pick up from where it left off.\n *\n * If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_COPY, then\n * the default is to abort the mirroring and revert to the source disk;\n * likewise, if the current job is VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT,\n * the default is to abort without changing the active layer of @disk.\n * Adding @flags of VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT causes this call to\n * fail with VIR_ERR_BLOCK_COPY_ACTIVE if the copy or commit is not yet\n * ready; otherwise it will swap the disk over to the new active image\n * to end the mirroring or active commit.  An event will be issued when the\n * job is ended, and it is possible to use VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC\n * to control whether this command waits for the completion of the job.\n * Restarting a copy or active commit job requires starting over from the\n * beginning of the first phase.\n *\n * Returns -1 in case of failure, 0 when successful.\n */\nint\nvirDomainBlockJobAbort(virDomainPtr dom, const char *disk,\n                       unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, flags=%x\", disk, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockJobAbort) {\n        int ret;\n        ret = conn->driver->domainBlockJobAbort(dom, disk, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlockJobInfo:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @info: pointer to a virDomainBlockJobInfo structure\n * @flags: bitwise-OR of virDomainBlockJobInfoFlags\n *\n * Request block job information for the given disk.  If an operation is active\n * @info will be updated with the current progress.  The units used for the\n * bandwidth field of @info depends on @flags.  If @flags includes\n * VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES, bandwidth is in bytes/second\n * (although this mode can risk failure due to overflow, depending on both\n * client and server word size); otherwise, the value is rounded up to MiB/s.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * Returns -1 in case of failure, 0 when nothing found, 1 when info was found.\n */\nint\nvirDomainGetBlockJobInfo(virDomainPtr dom, const char *disk,\n                         virDomainBlockJobInfoPtr info, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, info=%p, flags=%x\", disk, info, flags);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(info, error);\n\n    if (conn->driver->domainGetBlockJobInfo) {\n        int ret;\n        ret = conn->driver->domainGetBlockJobInfo(dom, disk, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockJobSetSpeed:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @bandwidth: specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockJobSetSpeedFlags\n *\n * Set the maximimum allowable bandwidth that a block job may consume.  If\n * bandwidth is 0, the limit will revert to the hypervisor default of\n * unlimited.\n *\n * If @flags contains VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES, @bandwidth\n * is in bytes/second; otherwise, it is in MiB/second.  Values larger than\n * 2^52 bytes/sec may be rejected due to overflow considerations based on\n * the word size of both client and server, and values larger than 2^31\n * bytes/sec may cause overflow problems if later queried by\n * virDomainGetBlockJobInfo() without scaling.  Hypervisors may further\n * restrict the range of valid bandwidth values.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * Returns -1 in case of failure, 0 when successful.\n */\nint\nvirDomainBlockJobSetSpeed(virDomainPtr dom, const char *disk,\n                          unsigned long bandwidth, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, bandwidth=%lu, flags=%x\",\n                     disk, bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockJobSetSpeed) {\n        int ret;\n        ret = conn->driver->domainBlockJobSetSpeed(dom, disk, bandwidth, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockPull:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @bandwidth: (optional) specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockPullFlags\n *\n * Populate a disk image with data from its backing image.  Once all data from\n * its backing image has been pulled, the disk no longer depends on a backing\n * image.  This function pulls data for the entire device in the background.\n * Progress of the operation can be checked with virDomainGetBlockJobInfo() and\n * the operation can be aborted with virDomainBlockJobAbort().  When finished,\n * an asynchronous event is raised to indicate the final status.  To move\n * data in the opposite direction, see virDomainBlockCommit().\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The maximum bandwidth that will be used to do the copy can be\n * specified with the @bandwidth parameter.  If set to 0, there is no\n * limit.  If @flags includes VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES,\n * @bandwidth is in bytes/second; otherwise, it is in MiB/second.\n * Values larger than 2^52 bytes/sec may be rejected due to overflow\n * considerations based on the word size of both client and server,\n * and values larger than 2^31 bytes/sec may cause overflow problems\n * if later queried by virDomainGetBlockJobInfo() without scaling.\n * Hypervisors may further restrict the range of valid bandwidth\n * values.  Some hypervisors do not support this feature and will\n * return an error if bandwidth is not 0; in this case, it might still\n * be possible for a later call to virDomainBlockJobSetSpeed() to\n * succeed.  The actual speed can be determined with\n * virDomainGetBlockJobInfo().\n *\n * This is shorthand for virDomainBlockRebase() with a NULL base.\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockPull(virDomainPtr dom, const char *disk,\n                   unsigned long bandwidth, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, bandwidth=%lu, flags=%x\",\n                     disk, bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockPull) {\n        int ret;\n        ret = conn->driver->domainBlockPull(dom, disk, bandwidth, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockRebase:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @base: path to backing file to keep, or device shorthand,\n *        or NULL for no backing file\n * @bandwidth: (optional) specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockRebaseFlags\n *\n * Populate a disk image with data from its backing image chain, and\n * setting the backing image to @base, or alternatively copy an entire\n * backing chain to a new file @base.\n *\n * When @flags is 0, this starts a pull, where @base must be the absolute\n * path of one of the backing images further up the chain, or NULL to\n * convert the disk image so that it has no backing image.  Once all\n * data from its backing image chain has been pulled, the disk no\n * longer depends on those intermediate backing images.  This function\n * pulls data for the entire device in the background.  Progress of\n * the operation can be checked with virDomainGetBlockJobInfo() with a\n * job type of VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, and the operation can be\n * aborted with virDomainBlockJobAbort().  When finished, an asynchronous\n * event is raised to indicate the final status, and the job no longer\n * exists.  If the job is aborted, a new one can be started later to\n * resume from the same point.\n *\n * If @flags contains VIR_DOMAIN_BLOCK_REBASE_RELATIVE, the name recorded\n * into the active disk as the location for @base will be kept relative.\n * The operation will fail if libvirt can't infer the name.\n *\n * When @flags includes VIR_DOMAIN_BLOCK_REBASE_COPY, this starts a copy,\n * where @base must be the name of a new file to copy the chain to.  By\n * default, the copy will pull the entire source chain into the destination\n * file, but if @flags also contains VIR_DOMAIN_BLOCK_REBASE_SHALLOW, then\n * only the top of the source chain will be copied (the source and\n * destination have a common backing file).  By default, @base will be\n * created with the same file format as the source, but this can be altered\n * by adding VIR_DOMAIN_BLOCK_REBASE_COPY_RAW to force the copy to be raw\n * (does not make sense with the shallow flag unless the source is also raw),\n * or by using VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT to reuse an existing file\n * which was pre-created with the correct format and metadata and sufficient\n * size to hold the copy. In case the VIR_DOMAIN_BLOCK_REBASE_SHALLOW flag\n * is used the pre-created file has to exhibit the same guest visible contents\n * as the backing file of the original image. This allows a management app to\n * pre-create files with relative backing file names, rather than the default\n * of absolute backing file names; as a security precaution, you should\n * generally only use reuse_ext with the shallow flag and a non-raw\n * destination file.  By default, the copy destination will be treated as\n * type='file', but using VIR_DOMAIN_BLOCK_REBASE_COPY_DEV treats the\n * destination as type='block' (affecting how virDomainGetBlockInfo() will\n * report allocation after pivoting).\n *\n * A copy job has two parts; in the first phase, the @bandwidth parameter\n * affects how fast the source is pulled into the destination, and the job\n * can only be canceled by reverting to the source file; progress in this\n * phase can be tracked via the virDomainBlockJobInfo() command, with a\n * job type of VIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the\n * second phase when the job info states cur == end, and remains alive to\n * mirror all further changes to both source and destination.  The user\n * must call virDomainBlockJobAbort() to end the mirroring while choosing\n * whether to revert to source or pivot to the destination.  An event is\n * issued when the job ends, and depending on the hypervisor, an event may\n * also be issued when the job transitions from pulling to mirroring.  If\n * the job is aborted, a new job will have to start over from the beginning\n * of the first phase.\n *\n * Some hypervisors will restrict certain actions, such as virDomainSave()\n * or virDomainDetachDevice(), while a copy job is active; they may\n * also restrict a copy job to transient domains.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The @base parameter can be either a path to a file within the backing\n * chain, or the device target shorthand (the <target dev='...'/>\n * sub-element, such as \"vda\") followed by an index to the backing chain\n * enclosed in square brackets. Backing chain indexes can be found by\n * inspecting //disk//backingStore/@index in the domain XML. Thus, for\n * example, \"vda[3]\" refers to the backing store with index equal to \"3\"\n * in the chain of disk \"vda\".\n *\n * The maximum bandwidth that will be used to do the copy can be\n * specified with the @bandwidth parameter.  If set to 0, there is no\n * limit.  If @flags includes VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES,\n * @bandwidth is in bytes/second; otherwise, it is in MiB/second.\n * Values larger than 2^52 bytes/sec may be rejected due to overflow\n * considerations based on the word size of both client and server,\n * and values larger than 2^31 bytes/sec may cause overflow problems\n * if later queried by virDomainGetBlockJobInfo() without scaling.\n * Hypervisors may further restrict the range of valid bandwidth\n * values.  Some hypervisors do not support this feature and will\n * return an error if bandwidth is not 0; in this case, it might still\n * be possible for a later call to virDomainBlockJobSetSpeed() to\n * succeed.  The actual speed can be determined with\n * virDomainGetBlockJobInfo().\n *\n * When @base is NULL and @flags is 0, this is identical to\n * virDomainBlockPull().  When @flags contains VIR_DOMAIN_BLOCK_REBASE_COPY,\n * this command is shorthand for virDomainBlockCopy() where the destination\n * XML encodes @base as a <disk type='file'>, @bandwidth is properly scaled\n * and passed as a typed parameter, the shallow and reuse external flags\n * are preserved, and remaining flags control whether the XML encodes a\n * destination format of raw instead of leaving the destination identical\n * to the source format or probed from the reused file.\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockRebase(virDomainPtr dom, const char *disk,\n                     const char *base, unsigned long bandwidth,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, base=%s, bandwidth=%lu, flags=%x\",\n                     disk, NULLSTR(base), bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (flags & VIR_DOMAIN_BLOCK_REBASE_COPY) {\n        virCheckNonNullArgGoto(base, error);\n    } else if (flags & (VIR_DOMAIN_BLOCK_REBASE_SHALLOW |\n                        VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT |\n                        VIR_DOMAIN_BLOCK_REBASE_COPY_RAW |\n                        VIR_DOMAIN_BLOCK_REBASE_COPY_DEV)) {\n        virReportInvalidArg(flags, \"%s\",\n                            _(\"use of flags requires a copy job\"));\n        goto error;\n    }\n\n    if (conn->driver->domainBlockRebase) {\n        int ret;\n        ret = conn->driver->domainBlockRebase(dom, disk, base, bandwidth,\n                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockCopy:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @destxml: XML description of the copy destination\n * @params: Pointer to block copy parameter objects, or NULL\n * @nparams: Number of block copy parameters (this value can be the same or\n *           less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainBlockCopyFlags\n *\n * Copy the guest-visible contents of a disk image to a new file described\n * by @destxml.  The destination XML has a top-level element of <disk>, and\n * resembles what is used when hot-plugging a disk via virDomainAttachDevice(),\n * except that only sub-elements related to describing the new host resource\n * are necessary (sub-elements related to the guest view, such as <target>,\n * are ignored).  It is strongly recommended to include a <driver type='...'/>\n * format designation for the destination, to avoid the potential of any\n * security problem that might be caused by probing a file for its format.\n *\n * This command starts a long-running copy.  By default, the copy will pull\n * the entire source chain into the destination file, but if @flags also\n * contains VIR_DOMAIN_BLOCK_COPY_SHALLOW, then only the top of the source\n * chain will be copied (the source and destination have a common backing\n * file).  The format of the destination file is controlled by the <driver>\n * sub-element of the XML.  The destination will be created unless the\n * VIR_DOMAIN_BLOCK_COPY_REUSE_EXT flag is present stating that the file\n * was pre-created with the correct format and metadata and sufficient\n * size to hold the copy. In case the VIR_DOMAIN_BLOCK_COPY_SHALLOW flag\n * is used the pre-created file has to exhibit the same guest visible contents\n * as the backing file of the original image. This allows a management app to\n * pre-create files with relative backing file names, rather than the default\n * of absolute backing file names.\n *\n * A copy job has two parts; in the first phase, the source is copied into\n * the destination, and the job can only be canceled by reverting to the\n * source file; progress in this phase can be tracked via the\n * virDomainBlockJobInfo() command, with a job type of\n * VIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the second\n * phase when the job info states cur == end, and remains alive to mirror\n * all further changes to both source and destination.  The user must\n * call virDomainBlockJobAbort() to end the mirroring while choosing\n * whether to revert to source or pivot to the destination.  An event is\n * issued when the job ends, and depending on the hypervisor, an event may\n * also be issued when the job transitions from pulling to mirroring.  If\n * the job is aborted, a new job will have to start over from the beginning\n * of the first phase.\n *\n * Some hypervisors will restrict certain actions, such as virDomainSave()\n * or virDomainDetachDevice(), while a copy job is active; they may\n * also restrict a copy job to transient domains.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The @params and @nparams arguments can be used to set hypervisor-specific\n * tuning parameters, such as maximum bandwidth or granularity.  For a\n * parameter that the hypervisor understands, explicitly specifying 0\n * behaves the same as omitting the parameter, to use the hypervisor\n * default; however, omitting a parameter is less likely to fail.\n *\n * This command is a superset of the older virDomainBlockRebase() when used\n * with the VIR_DOMAIN_BLOCK_REBASE_COPY flag, and offers better control\n * over the destination format, the ability to copy to a destination that\n * is not a local file, and the possibility of additional tuning parameters.\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockCopy(virDomainPtr dom, const char *disk,\n                   const char *destxml,\n                   virTypedParameterPtr params,\n                   int nparams,\n                   unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom,\n                     \"disk=%s, destxml=%s, params=%p, nparams=%d, flags=%x\",\n                     disk, destxml, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(destxml, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n    if (nparams)\n        virCheckNonNullArgGoto(params, error);\n\n    if (conn->driver->domainBlockCopy) {\n        int ret;\n        ret = conn->driver->domainBlockCopy(dom, disk, destxml,\n                                            params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockCommit:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @base: path to backing file to merge into, or device shorthand,\n *        or NULL for default\n * @top: path to file within backing chain that contains data to be merged,\n *       or device shorthand, or NULL to merge all possible data\n * @bandwidth: (optional) specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockCommitFlags\n *\n * Commit changes that were made to temporary top-level files within a disk\n * image backing file chain into a lower-level base file.  In other words,\n * take all the difference between @base and @top, and update @base to contain\n * that difference; after the commit, any portion of the chain that previously\n * depended on @top will now depend on @base, and all files after @base up\n * to and including @top will now be invalidated.  A typical use of this\n * command is to reduce the length of a backing file chain after taking an\n * external disk snapshot.  To move data in the opposite direction, see\n * virDomainBlockPull().\n *\n * This command starts a long-running commit block job, whose status may\n * be tracked by virDomainBlockJobInfo() with a job type of\n * VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT, and the operation can be aborted with\n * virDomainBlockJobAbort().  When finished, an asynchronous event is\n * raised to indicate the final status, and the job no longer exists.  If\n * the job is aborted, it is up to the hypervisor whether starting a new\n * job will resume from the same point, or start over.\n *\n * As a special case, if @top is the active image (or NULL), and @flags\n * includes VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, the block job will have a type\n * of VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT, and operates in two phases.\n * In the first phase, the contents are being committed into @base, and the\n * job can only be canceled.  The job transitions to the second phase when\n * the job info states cur == end, and remains alive to keep all further\n * changes to @top synchronized into @base; an event with status\n * VIR_DOMAIN_BLOCK_JOB_READY is also issued to mark the job transition.\n * Once in the second phase, the user must choose whether to cancel the job\n * (keeping @top as the active image, but now containing only the changes\n * since the time the job ended) or to pivot the job (adjusting to @base as\n * the active image, and invalidating @top).\n *\n * Be aware that this command may invalidate files even if it is aborted;\n * the user is cautioned against relying on the contents of invalidated\n * intermediate files such as @top (when @top is not the active image)\n * without manually rebasing those files to use a backing file of a\n * read-only copy of @base prior to the point where the commit operation\n * was started (and such a rebase cannot be safely done until the commit\n * has successfully completed).  However, the domain itself will not have\n * any issues; the active layer remains valid throughout the entire commit\n * operation.\n *\n * Some hypervisors may support a shortcut where if @flags contains\n * VIR_DOMAIN_BLOCK_COMMIT_DELETE, then this command will unlink all files\n * that were invalidated, after the commit successfully completes.\n *\n * If @flags contains VIR_DOMAIN_BLOCK_COMMIT_RELATIVE, the name recorded\n * into the overlay of the @top image (if there is such image) as the\n * path to the new backing file will be kept relative to other images.\n * The operation will fail if libvirt can't infer the name.\n *\n * By default, if @base is NULL, the commit target will be the bottom of\n * the backing chain; if @flags contains VIR_DOMAIN_BLOCK_COMMIT_SHALLOW,\n * then the immediate backing file of @top will be used instead.  If @top\n * is NULL, the active image at the top of the chain will be used.  Some\n * hypervisors place restrictions on how much can be committed, and might\n * fail if @base is not the immediate backing file of @top, or if @top is\n * the active layer in use by a running domain but @flags did not include\n * VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, or if @top is not the top-most file;\n * restrictions may differ for online vs. offline domains.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The @base and @top parameters can be either paths to files within the\n * backing chain, or the device target shorthand (the <target dev='...'/>\n * sub-element, such as \"vda\") followed by an index to the backing chain\n * enclosed in square brackets. Backing chain indexes can be found by\n * inspecting //disk//backingStore/@index in the domain XML. Thus, for\n * example, \"vda[3]\" refers to the backing store with index equal to \"3\"\n * in the chain of disk \"vda\".\n *\n * The maximum bandwidth that will be used to do the commit can be\n * specified with the @bandwidth parameter.  If set to 0, there is no\n * limit.  If @flags includes VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES,\n * @bandwidth is in bytes/second; otherwise, it is in MiB/second.\n * Values larger than 2^52 bytes/sec may be rejected due to overflow\n * considerations based on the word size of both client and server,\n * and values larger than 2^31 bytes/sec may cause overflow problems\n * if later queried by virDomainGetBlockJobInfo() without scaling.\n * Hypervisors may further restrict the range of valid bandwidth\n * values.  Some hypervisors do not support this feature and will\n * return an error if bandwidth is not 0; in this case, it might still\n * be possible for a later call to virDomainBlockJobSetSpeed() to\n * succeed.  The actual speed can be determined with\n * virDomainGetBlockJobInfo().\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockCommit(virDomainPtr dom, const char *disk,\n                     const char *base, const char *top,\n                     unsigned long bandwidth, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, base=%s, top=%s, bandwidth=%lu, flags=%x\",\n                     disk, NULLSTR(base), NULLSTR(top), bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockCommit) {\n        int ret;\n        ret = conn->driver->domainBlockCommit(dom, disk, base, top, bandwidth,\n                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainOpenGraphics:\n * @dom: pointer to domain object\n * @idx: index of graphics config to open\n * @fd: file descriptor to attach graphics to\n * @flags: bitwise-OR of virDomainOpenGraphicsFlags\n *\n * This will attempt to connect the file descriptor @fd, to\n * the graphics backend of @dom. If @dom has multiple graphics\n * backends configured, then @idx will determine which one is\n * opened, starting from @idx 0.\n *\n * To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH\n * constant for @flags.\n *\n * The caller should use an anonymous socketpair to open\n * @fd before invocation.\n *\n * This method can only be used when connected to a local\n * libvirt hypervisor, over a UNIX domain socket. Attempts\n * to use this method over a TCP connection will always fail\n *\n * Returns 0 on success, -1 on failure\n */\nint\nvirDomainOpenGraphics(virDomainPtr dom,\n                      unsigned int idx,\n                      int fd,\n                      unsigned int flags)\n{\n    struct stat sb;\n    VIR_DOMAIN_DEBUG(dom, \"idx=%u, fd=%d, flags=%x\",\n                     idx, fd, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNegativeArgGoto(fd, error);\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access file descriptor %d\"), fd);\n        goto error;\n    }\n\n    if (!S_ISSOCK(sb.st_mode)) {\n        virReportInvalidArg(fd,\n                            _(\"fd %d must be a socket\"),\n                            fd);\n        goto error;\n    }\n\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (!VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                  VIR_DRV_FEATURE_FD_PASSING)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"fd passing is not supported by this connection\"));\n        goto error;\n    }\n\n    if (dom->conn->driver->domainOpenGraphics) {\n        int ret;\n        ret = dom->conn->driver->domainOpenGraphics(dom, idx, fd, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainOpenGraphicsFD:\n * @dom: pointer to domain object\n * @idx: index of graphics config to open\n * @flags: bitwise-OR of virDomainOpenGraphicsFlags\n *\n * This will create a socket pair connected to the graphics backend of @dom.\n * One end of the socket will be returned on success, and the other end is\n * handed to the hypervisor.\n * If @dom has multiple graphics backends configured, then @idx will determine\n * which one is opened, starting from @idx 0.\n *\n * To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH\n * constant for @flags.\n *\n * This method can only be used when connected to a local\n * libvirt hypervisor, over a UNIX domain socket. Attempts\n * to use this method over a TCP connection will always fail.\n *\n * Returns an fd on success, -1 on failure\n */\nint\nvirDomainOpenGraphicsFD(virDomainPtr dom,\n                        unsigned int idx,\n                        unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"idx=%u, flags=%x\", idx, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (!VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                  VIR_DRV_FEATURE_FD_PASSING)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"fd passing is not supported by this connection\"));\n        goto error;\n    }\n\n    if (dom->conn->driver->domainOpenGraphicsFD) {\n        int ret;\n        ret = dom->conn->driver->domainOpenGraphicsFD(dom, idx, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetBlockIoTune:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @params: Pointer to blkio parameter objects\n * @nparams: Number of blkio parameters (this value can be the same or\n *           less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the per-device block IO tunables.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the <target\n * dev='...'/> sub-element, such as \"xvda\").  Valid names can be found\n * by calling virDomainGetXMLDesc() and inspecting elements\n * within //domain/devices/disk.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetBlockIoTune(virDomainPtr dom,\n                        const char *disk,\n                        virTypedParameterPtr params,\n                        int nparams,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, params=%p, nparams=%d, flags=%x\",\n                     disk, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckPositiveArgGoto(nparams, error);\n    virCheckNonNullArgGoto(params, error);\n\n    if (virTypedParameterValidateSet(dom->conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetBlockIoTune) {\n        int ret;\n        ret = conn->driver->domainSetBlockIoTune(dom, disk, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlockIoTune:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @params: Pointer to blkio parameter object\n *          (return value, allocated by the caller)\n * @nparams: Pointer to number of blkio parameters\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all block IO tunable parameters for a given device.  On input,\n * @nparams gives the size of the @params array; on output, @nparams\n * gives how many slots were filled with parameter information, which\n * might be less but will not exceed the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0\n * on input will cause @nparams on output to contain the number of\n * parameters supported by the hypervisor, either for the given @disk\n * (note that block devices of different types might support different\n * parameters), or if @disk is NULL, for all possible disks. The\n * caller should then allocate @params array,\n * i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.  See virDomainGetMemoryParameters() for more details.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the <target\n * dev='...'/> sub-element, such as \"xvda\").  Valid names can be found\n * by calling virDomainGetXMLDesc() and inspecting elements\n * within //domain/devices/disk.  This parameter cannot be NULL\n * unless @nparams is 0 on input.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetBlockIoTune(virDomainPtr dom,\n                        const char *disk,\n                        virTypedParameterPtr params,\n                        int *nparams,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, params=%p, nparams=%d, flags=%x\",\n                     NULLSTR(disk), params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0) {\n        virCheckNonNullArgGoto(params, error);\n        virCheckNonNullArgGoto(disk, error);\n    }\n\n    if (VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = dom->conn;\n\n    if (conn->driver->domainGetBlockIoTune) {\n        int ret;\n        ret = conn->driver->domainGetBlockIoTune(dom, disk, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetCPUStats:\n * @domain: domain to query\n * @params: array to populate on output\n * @nparams: number of parameters per cpu\n * @start_cpu: which cpu to start with, or -1 for summary\n * @ncpus: how many cpus to query\n * @flags: bitwise-OR of virTypedParameterFlags\n *\n * Get statistics relating to CPU usage attributable to a single\n * domain (in contrast to the statistics returned by\n * virNodeGetCPUStats() for all processes on the host).  @dom\n * must be running (an inactive domain has no attributable cpu\n * usage).  On input, @params must contain at least @nparams * @ncpus\n * entries, allocated by the caller.\n *\n * If @start_cpu is -1, then @ncpus must be 1, and the returned\n * results reflect the statistics attributable to the entire\n * domain (such as user and system time for the process as a\n * whole).  Otherwise, @start_cpu represents which cpu to start\n * with, and @ncpus represents how many consecutive processors to\n * query, with statistics attributable per processor (such as\n * per-cpu usage).  If @ncpus is larger than the number of cpus\n * available to query, then the trailing part of the array will\n * be unpopulated.\n *\n * The remote driver imposes a limit of 128 @ncpus and 16 @nparams;\n * the number of parameters per cpu should not exceed 16, but if you\n * have a host with more than 128 CPUs, your program should split\n * the request into multiple calls.\n *\n * As special cases, if @params is NULL and @nparams is 0 and\n * @ncpus is 1, and the return value will be how many\n * statistics are available for the given @start_cpu.  This number\n * may be different for @start_cpu of -1 than for any non-negative\n * value, but will be the same for all non-negative @start_cpu.\n * Likewise, if @params is NULL and @nparams is 0 and @ncpus is 0,\n * the number of cpus available to query is returned.  From the\n * host perspective, this would typically match the cpus member\n * of virNodeGetInfo(), but might be less due to host cpu hotplug.\n *\n * For now, @flags is unused, and the statistics all relate to the\n * usage from the host perspective.  It is possible that a future\n * version will support a flag that queries the cpu usage from the\n * guest's perspective, where the maximum cpu to query would be\n * related to virDomainGetVcpusFlags() rather than virNodeGetInfo().\n * An individual guest vcpu cannot be reliably mapped back to a\n * specific host cpu unless a single-processor vcpu pinning was used,\n * but when @start_cpu is -1, any difference in usage between a host\n * and guest perspective would serve as a measure of hypervisor overhead.\n *\n * Typical use sequence is below.\n *\n * getting total stats: set start_cpu as -1, ncpus 1\n *\n *   virDomainGetCPUStats(dom, NULL, 0, -1, 1, 0); // nparams\n *   params = calloc(nparams, sizeof(virTypedParameter))\n *   virDomainGetCPUStats(dom, params, nparams, -1, 1, 0); // total stats.\n *\n * getting per-cpu stats:\n *\n *   virDomainGetCPUStats(dom, NULL, 0, 0, 0, 0); // ncpus\n *   virDomainGetCPUStats(dom, NULL, 0, 0, 1, 0); // nparams\n *   params = calloc(ncpus * nparams, sizeof(virTypedParameter));\n *   virDomainGetCPUStats(dom, params, nparams, 0, ncpus, 0); // per-cpu stats\n *\n * Returns -1 on failure, or the number of statistics that were\n * populated per cpu on success (this will be less than the total\n * number of populated @params, unless @ncpus was 1; and may be\n * less than @nparams).  The populated parameters start at each\n * stride of @nparams, which means the results may be discontiguous;\n * any unpopulated parameters will be zeroed on success (this includes\n * skipped elements if @nparams is too large, and tail elements if\n * @ncpus is too large).  The caller is responsible for freeing any\n * returned string parameters.\n */\nint\nvirDomainGetCPUStats(virDomainPtr domain,\n                     virTypedParameterPtr params,\n                     unsigned int nparams,\n                     int start_cpu,\n                     unsigned int ncpus,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"params=%p, nparams=%d, start_cpu=%d, ncpus=%u, flags=%x\",\n                     params, nparams, start_cpu, ncpus, flags);\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    /* Special cases:\n     * start_cpu must be non-negative, or else -1\n     * if start_cpu is -1, ncpus must be 1\n     * params == NULL must match nparams == 0\n     * ncpus must be non-zero unless params == NULL\n     * nparams * ncpus must not overflow (RPC may restrict it even more)\n     */\n    if (start_cpu == -1) {\n        if (ncpus != 1) {\n            virReportInvalidArg(start_cpu, \"%s\",\n                                _(\"ncpus must be 1 when start_cpu is -1\"));\n            goto error;\n        }\n    } else {\n        virCheckNonNegativeArgGoto(start_cpu, error);\n    }\n    if (nparams)\n        virCheckNonNullArgGoto(params, error);\n    else\n        virCheckNullArgGoto(params, error);\n    if (ncpus == 0)\n        virCheckNullArgGoto(params, error);\n\n    if (nparams && ncpus > UINT_MAX / nparams) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %u * %u\"),\n                       nparams, ncpus);\n        goto error;\n    }\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    if (conn->driver->domainGetCPUStats) {\n        int ret;\n\n        ret = conn->driver->domainGetCPUStats(domain, params, nparams,\n                                              start_cpu, ncpus, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetDiskErrors:\n * @dom: a domain object\n * @errors: array to populate on output\n * @maxerrors: size of @errors array\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * The function populates @errors array with all disks that encountered an\n * I/O error.  Disks with no error will not be returned in the @errors array.\n * Each disk is identified by its target (the dev attribute of target\n * subelement in domain XML), such as \"vda\", and accompanied with the error\n * that was seen on it.  The caller is also responsible for calling free()\n * on each disk name returned.\n *\n * In a special case when @errors is NULL and @maxerrors is 0, the function\n * returns preferred size of @errors that the caller should use to get all\n * disk errors.\n *\n * Since calling virDomainGetDiskErrors(dom, NULL, 0, 0) to get preferred size\n * of @errors array and getting the errors are two separate operations, new\n * disks may be hotplugged to the domain and new errors may be encountered\n * between the two calls.  Thus, this function may not return all disk errors\n * because the supplied array is not large enough.  Such errors may, however,\n * be detected by listening to domain events.\n *\n * Returns number of disks with errors filled in the @errors array or -1 on\n * error.\n */\nint\nvirDomainGetDiskErrors(virDomainPtr dom,\n                       virDomainDiskErrorPtr errors,\n                       unsigned int maxerrors,\n                       unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"errors=%p, maxerrors=%u, flags=%x\",\n                     errors, maxerrors, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (maxerrors)\n        virCheckNonNullArgGoto(errors, error);\n    else\n        virCheckNullArgGoto(errors, error);\n\n    if (dom->conn->driver->domainGetDiskErrors) {\n        int ret = dom->conn->driver->domainGetDiskErrors(dom, errors,\n                                                         maxerrors, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetHostname:\n * @domain: a domain object\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Get the hostname for that domain.\n *\n * Dependent on hypervisor used, this may require a guest agent to be\n * available.\n *\n * Returns the hostname which must be freed by the caller, or\n * NULL if there was an error.\n */\nchar *\nvirDomainGetHostname(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetHostname) {\n        char *ret;\n        ret = conn->driver->domainGetHostname(domain, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainFSTrim:\n * @dom: a domain object\n * @mountPoint: which mount point to trim\n * @minimum: Minimum contiguous free range to discard in bytes\n * @flags: extra flags, not used yet, so callers should always pass 0\n *\n * Calls FITRIM within the guest (hence guest agent may be\n * required depending on hypervisor used). Either call it on each\n * mounted filesystem (@mountPoint is NULL) or just on specified\n * @mountPoint. @minimum hints that free ranges smaller than this\n * may be ignored (this is a hint and the guest may not respect\n * it).  By increasing this value, the fstrim operation will\n * complete more quickly for filesystems with badly fragmented\n * free space, although not all blocks will be discarded.\n * If @minimum is not zero, the command may fail.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainFSTrim(virDomainPtr dom,\n                const char *mountPoint,\n                unsigned long long minimum,\n                unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"mountPoint=%s, minimum=%llu, flags=%x\",\n                     mountPoint, minimum, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainFSTrim) {\n        int ret = dom->conn->driver->domainFSTrim(dom, mountPoint,\n                                                  minimum, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainFSFreeze:\n * @dom: a domain object\n * @mountpoints: list of mount points to be frozen\n * @nmountpoints: the number of mount points specified in @mountpoints\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Freeze specified filesystems within the guest (hence guest agent\n * may be required depending on hypervisor used). If @mountpoints is NULL and\n * @nmountpoints is 0, every mounted filesystem on the guest is frozen.\n * In some environments (e.g. QEMU guest with guest agent which doesn't\n * support mountpoints argument), @mountpoints may need to be NULL.\n *\n * Returns the number of frozen filesystems on success, -1 otherwise.\n */\nint\nvirDomainFSFreeze(virDomainPtr dom,\n                  const char **mountpoints,\n                  unsigned int nmountpoints,\n                  unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"mountpoints=%p, nmountpoints=%d, flags=%x\",\n                     mountpoints, nmountpoints, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    if (nmountpoints)\n        virCheckNonNullArgGoto(mountpoints, error);\n    else\n        virCheckNullArgGoto(mountpoints, error);\n\n    if (dom->conn->driver->domainFSFreeze) {\n        int ret = dom->conn->driver->domainFSFreeze(\n            dom, mountpoints, nmountpoints, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainFSThaw:\n * @dom: a domain object\n * @mountpoints: list of mount points to be thawed\n * @nmountpoints: the number of mount points specified in @mountpoints\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Thaw specified filesystems within the guest. If @mountpoints is NULL and\n * @nmountpoints is 0, every mounted filesystem on the guest is thawed.\n * In some drivers (e.g. QEMU driver), @mountpoints may need to be NULL.\n *\n * Returns the number of thawed filesystems on success, -1 otherwise.\n */\nint\nvirDomainFSThaw(virDomainPtr dom,\n                const char **mountpoints,\n                unsigned int nmountpoints,\n                unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    if (nmountpoints)\n        virCheckNonNullArgGoto(mountpoints, error);\n    else\n        virCheckNullArgGoto(mountpoints, error);\n\n    if (dom->conn->driver->domainFSThaw) {\n        int ret = dom->conn->driver->domainFSThaw(\n            dom, mountpoints, nmountpoints, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainGetTime:\n * @dom: a domain object\n * @seconds: domain's time in seconds\n * @nseconds: the nanoscond part of @seconds\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract information about guest time and store it into\n * @seconds and @nseconds. The @seconds represents the number of\n * seconds since the UNIX Epoch of 1970-01-01 00:00:00 in UTC.\n *\n * Please note that some hypervisors may require guest agent to\n * be configured and running in order to run this API.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainSetTime:\n * @dom: a domain object\n * @seconds: time to set\n * @nseconds: the nanosecond part of @seconds\n * @flags: bitwise-OR of virDomainSetTimeFlags\n *\n * When a domain is suspended or restored from a file the\n * domain's OS has no idea that there was a big gap in the time.\n * Depending on how long the gap was, NTP might not be able to\n * resynchronize the guest.\n *\n * This API tries to set guest time to the given value. The time\n * to set (@seconds and @nseconds) should be in seconds relative\n * to the Epoch of 1970-01-01 00:00:00 in UTC.\n *\n * Please note that some hypervisors may require guest agent to\n * be configured and running in order to be able to run this API.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainSetTime(virDomainPtr dom,\n                 long long seconds,\n                 unsigned int nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%lld, nseconds=%u, flags=%x\",\n                     seconds, nseconds, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainSetTime) {\n        int ret = dom->conn->driver->domainSetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetUserPassword:\n * @dom: a domain object\n * @user: the username that will get a new password\n * @password: the password to set\n * @flags: bitwise-OR of virDomainSetUserPasswordFlags\n *\n * Sets the @user password to the value specified by @password.\n * If @flags contain VIR_DOMAIN_PASSWORD_ENCRYPTED, the password\n * is assumed to be encrypted by the method required by the guest OS.\n *\n * Please note that some hypervisors may require guest agent to\n * be configured and running in order to be able to run this API.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainSetUserPassword(virDomainPtr dom,\n                         const char *user,\n                         const char *password,\n                         unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"user=%s, password=%s, flags=%x\",\n                     NULLSTR(user), NULLSTR(password), flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    virCheckNonNullArgGoto(user, error);\n    virCheckNonNullArgGoto(password, error);\n\n    if (dom->conn->driver->domainSetUserPassword) {\n        int ret = dom->conn->driver->domainSetUserPassword(dom, user, password,\n                                                           flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virConnectGetDomainCapabilities:\n * @conn: pointer to the hypervisor connection\n * @emulatorbin: path to emulator\n * @arch: domain architecture\n * @machine: machine type\n * @virttype: virtualization type\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Prior creating a domain (for instance via virDomainCreateXML\n * or virDomainDefineXML) it may be suitable to know what the\n * underlying emulator and/or libvirt is capable of. For\n * instance, if host, libvirt and qemu is capable of VFIO\n * passthrough and so on.\n *\n * Returns NULL in case of error or an XML string\n * defining the capabilities.\n */\nchar *\nvirConnectGetDomainCapabilities(virConnectPtr conn,\n                                const char *emulatorbin,\n                                const char *arch,\n                                const char *machine,\n                                const char *virttype,\n                                unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, emulatorbin=%s, arch=%s, \"\n              \"machine=%s, virttype=%s, flags=%x\",\n              conn, NULLSTR(emulatorbin), NULLSTR(arch),\n              NULLSTR(machine), NULLSTR(virttype), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    if (conn->driver->connectGetDomainCapabilities) {\n        char *ret;\n        ret = conn->driver->connectGetDomainCapabilities(conn, emulatorbin,\n                                                         arch, machine,\n                                                         virttype, flags);\n        if (!ret)\n            goto error;\n        VIR_DEBUG(\"conn=%p, ret=%s\", conn, ret);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virConnectGetAllDomainStats:\n * @conn: pointer to the hypervisor connection\n * @stats: stats to return, binary-OR of virDomainStatsTypes\n * @retStats: Pointer that will be filled with the array of returned stats\n * @flags: extra flags; binary-OR of virConnectGetAllDomainStatsFlags\n *\n * Query statistics for all domains on a given connection.\n *\n * Report statistics of various parameters for a running VM according to @stats\n * field. The statistics are returned as an array of structures for each queried\n * domain. The structure contains an array of typed parameters containing the\n * individual statistics. The typed parameter name for each statistic field\n * consists of a dot-separated string containing name of the requested group\n * followed by a group specific description of the statistic value.\n *\n * The statistic groups are enabled using the @stats parameter which is a\n * binary-OR of enum virDomainStatsTypes. The following groups are available\n * (although not necessarily implemented for each hypervisor):\n *\n * VIR_DOMAIN_STATS_STATE: Return domain state and reason for entering that\n * state. The typed parameter keys are in this format:\n * \"state.state\" - state of the VM, returned as int from virDomainState enum\n * \"state.reason\" - reason for entering given state, returned as int from\n *                  virDomain*Reason enum corresponding to given state.\n *\n * VIR_DOMAIN_STATS_CPU_TOTAL: Return CPU statistics and usage information.\n * The typed parameter keys are in this format:\n * \"cpu.time\" - total cpu time spent for this domain in nanoseconds\n *              as unsigned long long.\n * \"cpu.user\" - user cpu time spent in nanoseconds as unsigned long long.\n * \"cpu.system\" - system cpu time spent in nanoseconds as unsigned long long.\n *\n * VIR_DOMAIN_STATS_BALLOON: Return memory balloon device information.\n * The typed parameter keys are in this format:\n * \"balloon.current\" - the memory in kiB currently used\n *                     as unsigned long long.\n * \"balloon.maximum\" - the maximum memory in kiB allowed\n *                     as unsigned long long.\n *\n * VIR_DOMAIN_STATS_VCPU: Return virtual CPU statistics.\n * Due to VCPU hotplug, the vcpu.<num>.* array could be sparse.\n * The actual size of the array corresponds to \"vcpu.current\".\n * The array size will never exceed \"vcpu.maximum\".\n * The typed parameter keys are in this format:\n * \"vcpu.current\" - current number of online virtual CPUs as unsigned int.\n * \"vcpu.maximum\" - maximum number of online virtual CPUs as unsigned int.\n * \"vcpu.<num>.state\" - state of the virtual CPU <num>, as int\n *                      from virVcpuState enum.\n * \"vcpu.<num>.time\" - virtual cpu time spent by virtual CPU <num>\n *                     as unsigned long long.\n *\n * VIR_DOMAIN_STATS_INTERFACE: Return network interface statistics.\n * The typed parameter keys are in this format:\n * \"net.count\" - number of network interfaces on this domain\n *               as unsigned int.\n * \"net.<num>.name\" - name of the interface <num> as string.\n * \"net.<num>.rx.bytes\" - bytes received as unsigned long long.\n * \"net.<num>.rx.pkts\" - packets received as unsigned long long.\n * \"net.<num>.rx.errs\" - receive errors as unsigned long long.\n * \"net.<num>.rx.drop\" - receive packets dropped as unsigned long long.\n * \"net.<num>.tx.bytes\" - bytes transmitted as unsigned long long.\n * \"net.<num>.tx.pkts\" - packets transmitted as unsigned long long.\n * \"net.<num>.tx.errs\" - transmission errors as unsigned long long.\n * \"net.<num>.tx.drop\" - transmit packets dropped as unsigned long long.\n *\n * VIR_DOMAIN_STATS_BLOCK: Return block devices statistics.  By default,\n * this information is limited to the active layer of each <disk> of the\n * domain (where block.count is equal to the number of disks), but adding\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING to @flags will expand the\n * array to cover backing chains (block.count corresponds to the number\n * of host resources used together to provide the guest disks).\n * The typed parameter keys are in this format:\n * \"block.count\" - number of block devices in the subsequent list,\n *                 as unsigned int.\n * \"block.<num>.name\" - name of the block device <num> as string.\n *                      matches the target name (vda/sda/hda) of the\n *                      block device.  If the backing chain is listed,\n *                      this name is the same for all host resources tied\n *                      to the same guest device.\n * \"block.<num>.backingIndex\" - unsigned int giving the <backingStore> index,\n *                              only used when backing images are listed.\n * \"block.<num>.path\" - string describing the source of block device <num>,\n *                      if it is a file or block device (omitted for network\n *                      sources and drives with no media inserted).\n * \"block.<num>.rd.reqs\" - number of read requests as unsigned long long.\n * \"block.<num>.rd.bytes\" - number of read bytes as unsigned long long.\n * \"block.<num>.rd.times\" - total time (ns) spent on reads as\n *                          unsigned long long.\n * \"block.<num>.wr.reqs\" - number of write requests as unsigned long long.\n * \"block.<num>.wr.bytes\" - number of written bytes as unsigned long long.\n * \"block.<num>.wr.times\" - total time (ns) spent on writes as\n *                          unsigned long long.\n * \"block.<num>.fl.reqs\" - total flush requests as unsigned long long.\n * \"block.<num>.fl.times\" - total time (ns) spent on cache flushing as\n *                          unsigned long long.\n * \"block.<num>.errors\" - Xen only: the 'oo_req' value as\n *                        unsigned long long.\n * \"block.<num>.allocation\" - offset of the highest written sector\n *                            as unsigned long long.\n * \"block.<num>.capacity\" - logical size in bytes of the block device backing\n *                          image as unsigned long long.\n * \"block.<num>.physical\" - physical size in bytes of the container of the\n *                          backing image as unsigned long long.\n *\n * Note that entire stats groups or individual stat fields may be missing from\n * the output in case they are not supported by the given hypervisor, are not\n * applicable for the current state of the guest domain, or their retrieval\n * was not successful.\n *\n * Using 0 for @stats returns all stats groups supported by the given\n * hypervisor.\n *\n * Specifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes\n * the function return error in case some of the stat types in @stats were\n * not recognized by the daemon.  However, even with this flag, a hypervisor\n * may omit individual fields within a known group if the information is not\n * available; as an extreme example, a supported group may produce zero\n * fields for offline domains if the statistics are meaningful only for a\n * running domain.\n *\n * Similarly to virConnectListAllDomains, @flags can contain various flags to\n * filter the list of domains to provide stats for.\n *\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE selects online domains while\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE selects offline ones.\n *\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT and\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT allow to filter the list\n * according to their persistence.\n *\n * To filter the list of VMs by domain state @flags can contain\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING,\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED,\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF and/or\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER for all other states.\n *\n * Returns the count of returned statistics structures on success, -1 on error.\n * The requested data are returned in the @retStats parameter. The returned\n * array should be freed by the caller. See virDomainStatsRecordListFree.\n */\nint\nvirConnectGetAllDomainStats(virConnectPtr conn,\n                            unsigned int stats,\n                            virDomainStatsRecordPtr **retStats,\n                            unsigned int flags)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"conn=%p, stats=0x%x, retStats=%p, flags=0x%x\",\n              conn, stats, retStats, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(retStats, cleanup);\n\n    if (!conn->driver->connectGetAllDomainStats) {\n        virReportUnsupportedError();\n        goto cleanup;\n    }\n\n    ret = conn->driver->connectGetAllDomainStats(conn, NULL, 0, stats,\n                                                 retStats, flags);\n\n cleanup:\n    if (ret < 0)\n        virDispatchError(conn);\n\n    return ret;\n}\n\n\n/**\n * virDomainListGetStats:\n * @doms: NULL terminated array of domains\n * @stats: stats to return, binary-OR of virDomainStatsTypes\n * @retStats: Pointer that will be filled with the array of returned stats\n * @flags: extra flags; binary-OR of virConnectGetAllDomainStatsFlags\n *\n * Query statistics for domains provided by @doms. Note that all domains in\n * @doms must share the same connection.\n *\n * Report statistics of various parameters for a running VM according to @stats\n * field. The statistics are returned as an array of structures for each queried\n * domain. The structure contains an array of typed parameters containing the\n * individual statistics. The typed parameter name for each statistic field\n * consists of a dot-separated string containing name of the requested group\n * followed by a group specific description of the statistic value.\n *\n * The statistic groups are enabled using the @stats parameter which is a\n * binary-OR of enum virDomainStatsTypes. The stats groups are documented\n * in virConnectGetAllDomainStats.\n *\n * Using 0 for @stats returns all stats groups supported by the given\n * hypervisor.\n *\n * Specifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes\n * the function return error in case some of the stat types in @stats were\n * not recognized by the daemon.  However, even with this flag, a hypervisor\n * may omit individual fields within a known group if the information is not\n * available; as an extreme example, a supported group may produce zero\n * fields for offline domains if the statistics are meaningful only for a\n * running domain.\n *\n * Note that any of the domain list filtering flags in @flags may be rejected\n * by this function.\n *\n * Returns the count of returned statistics structures on success, -1 on error.\n * The requested data are returned in the @retStats parameter. The returned\n * array should be freed by the caller. See virDomainStatsRecordListFree.\n * Note that the count of returned stats may be less than the domain count\n * provided via @doms.\n */\nint\nvirDomainListGetStats(virDomainPtr *doms,\n                      unsigned int stats,\n                      virDomainStatsRecordPtr **retStats,\n                      unsigned int flags)\n{\n    virConnectPtr conn = NULL;\n    virDomainPtr *nextdom = doms;\n    unsigned int ndoms = 0;\n    int ret = -1;\n\n    VIR_DEBUG(\"doms=%p, stats=0x%x, retStats=%p, flags=0x%x\",\n              doms, stats, retStats, flags);\n\n    virResetLastError();\n\n    virCheckNonNullArgGoto(doms, cleanup);\n    virCheckNonNullArgGoto(retStats, cleanup);\n\n    if (!*doms) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"doms array in %s must contain at least one domain\"),\n                       __FUNCTION__);\n        goto cleanup;\n    }\n\n    conn = doms[0]->conn;\n    virCheckConnectReturn(conn, -1);\n\n    if (!conn->driver->connectGetAllDomainStats) {\n        virReportUnsupportedError();\n        goto cleanup;\n    }\n\n    while (*nextdom) {\n        virDomainPtr dom = *nextdom;\n\n        virCheckDomainGoto(dom, cleanup);\n\n        if (dom->conn != conn) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"domains in 'doms' array must belong to a \"\n                             \"single connection\"));\n            goto cleanup;\n        }\n\n        ndoms++;\n        nextdom++;\n    }\n\n    ret = conn->driver->connectGetAllDomainStats(conn, doms, ndoms,\n                                                 stats, retStats, flags);\n\n cleanup:\n    if (ret < 0)\n        virDispatchError(conn);\n    return ret;\n}\n\n\n/**\n * virDomainStatsRecordListFree:\n * @stats: NULL terminated array of virDomainStatsRecords to free\n *\n * Convenience function to free a list of domain stats returned by\n * virDomainListGetStats and virConnectGetAllDomainStats.\n */\nvoid\nvirDomainStatsRecordListFree(virDomainStatsRecordPtr *stats)\n{\n    virDomainStatsRecordPtr *next;\n\n    if (!stats)\n        return;\n\n    for (next = stats; *next; next++) {\n        virTypedParamsFree((*next)->params, (*next)->nparams);\n        virDomainFree((*next)->dom);\n        VIR_FREE(*next);\n    }\n\n    VIR_FREE(stats);\n}\n\n\n/**\n * virDomainGetFSInfo:\n * @dom: a domain object\n * @info: a pointer to a variable to store an array of mount points information\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Get a list of mapping information for each mounted file systems within the\n * specified guest and the disks.\n *\n * Returns the number of returned mount points, or -1 in case of error.\n * On success, the array of the information is stored into @info. The caller is\n * responsible for calling virDomainFSInfoFree() on each array element, then\n * calling free() on @info. On error, @info is set to NULL.\n */\nint\nvirDomainGetFSInfo(virDomainPtr dom,\n                   virDomainFSInfoPtr **info,\n                   unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"info=%p, flags=%x\", info, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    virCheckNonNullArgGoto(info, error);\n    *info = NULL;\n\n    if (dom->conn->driver->domainGetFSInfo) {\n        int ret = dom->conn->driver->domainGetFSInfo(dom, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainFSInfoFree:\n * @info: pointer to a FSInfo object\n *\n * Frees all the memory occupied by @info.\n */\nvoid\nvirDomainFSInfoFree(virDomainFSInfoPtr info)\n{\n    size_t i;\n\n    if (!info)\n        return;\n\n    VIR_FREE(info->mountpoint);\n    VIR_FREE(info->name);\n    VIR_FREE(info->fstype);\n\n    for (i = 0; i < info->ndevAlias; i++)\n        VIR_FREE(info->devAlias[i]);\n    VIR_FREE(info->devAlias);\n\n    VIR_FREE(info);\n}\n\n/**\n * virDomainInterfaceAddresses:\n * @dom: domain object\n * @ifaces: pointer to an array of pointers pointing to interface objects\n * @source: one of the virDomainInterfaceAddressesSource constants\n * @flags: currently unused, pass zero\n *\n * Return a pointer to the allocated array of pointers to interfaces\n * present in given domain along with their IP and MAC addresses. Note that\n * single interface can have multiple or even 0 IP addresses.\n *\n * This API dynamically allocates the virDomainInterfacePtr struct based on\n * how many interfaces domain @dom has, usually there's 1:1 correlation. The\n * count of the interfaces is returned as the return value.\n *\n * If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE, the DHCP lease\n * file associated with any virtual networks will be examined to obtain\n * the interface addresses. This only returns data for interfaces which\n * are connected to virtual networks managed by libvirt.\n *\n * If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT, a configured\n * guest agent is needed for successful return from this API. Moreover, if\n * guest agent is used then the interface name is the one seen by guest OS.\n * To match such interface with the one from @dom XML use MAC address or IP\n * range.\n *\n * @ifaces->name and @ifaces->hwaddr are never NULL.\n *\n * The caller *must* free @ifaces when no longer needed. Usual use case\n * looks like this:\n *\n *  virDomainInterfacePtr *ifaces = NULL;\n *  int ifaces_count = 0;\n *  size_t i, j;\n *  virDomainPtr dom = ... obtain a domain here ...;\n *\n *  if ((ifaces_count = virDomainInterfaceAddresses(dom, &ifaces,\n *           VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE)) < 0)\n *      goto cleanup;\n *\n *  ... do something with returned values, for example:\n *  for (i = 0; i < ifaces_count; i++) {\n *      printf(\"name: %s\", ifaces[i]->name);\n *      if (ifaces[i]->hwaddr)\n *          printf(\" hwaddr: %s\", ifaces[i]->hwaddr);\n *\n *      for (j = 0; j < ifaces[i]->naddrs; j++) {\n *          virDomainIPAddressPtr ip_addr = ifaces[i]->addrs + j;\n *          printf(\"[addr: %s prefix: %d type: %d]\",\n *                 ip_addr->addr, ip_addr->prefix, ip_addr->type);\n *      }\n *      printf(\"\\n\");\n *  }\n *\n *  cleanup:\n *      if (ifaces && ifaces_count > 0)\n *          for (i = 0; i < ifaces_count; i++)\n *              virDomainInterfaceFree(ifaces[i]);\n *      free(ifaces);\n *\n * Returns the number of interfaces on success, -1 in case of error.\n */\nint\nvirDomainInterfaceAddresses(virDomainPtr dom,\n                            virDomainInterfacePtr **ifaces,\n                            unsigned int source,\n                            unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"ifaces=%p, source=%d, flags=%x\", ifaces, source, flags);\n\n    virResetLastError();\n\n    if (ifaces)\n        *ifaces = NULL;\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(ifaces, error);\n    if (source == VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT)\n        virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainInterfaceAddresses) {\n        int ret;\n        ret = dom->conn->driver->domainInterfaceAddresses(dom, ifaces, source, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportError(VIR_ERR_NO_SUPPORT, __FUNCTION__);\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainInterfaceFree:\n * @iface: an interface object\n *\n * Free the interface object. The data structure is\n * freed and should not be used thereafter. If @iface\n * is NULL, then this method has no effect.\n */\nvoid\nvirDomainInterfaceFree(virDomainInterfacePtr iface)\n{\n    size_t i;\n\n    if (!iface)\n        return;\n\n    VIR_FREE(iface->name);\n    VIR_FREE(iface->hwaddr);\n\n    for (i = 0; i < iface->naddrs; i++)\n        VIR_FREE(iface->addrs[i].addr);\n    VIR_FREE(iface->addrs);\n\n    VIR_FREE(iface);\n}\n"], "fixing_code": ["/*\n * libvirt-domain.c: entry points for virDomainPtr APIs\n *\n * Copyright (C) 2006-2015 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.  If not, see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <sys/stat.h>\n\n#include \"intprops.h\"\n\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virtypedparam.h\"\n\nVIR_LOG_INIT(\"libvirt.domain\");\n\n#define VIR_FROM_THIS VIR_FROM_DOMAIN\n\n\n/**\n * virConnectListDomains:\n * @conn: pointer to the hypervisor connection\n * @ids: array to collect the list of IDs of active domains\n * @maxids: size of @ids\n *\n * Collect the list of active domains, and store their IDs in array @ids\n *\n * For inactive domains, see virConnectListDefinedDomains().  For more\n * control over the results, see virConnectListAllDomains().\n *\n * Returns the number of domains found or -1 in case of error.  Note that\n * this command is inherently racy; a domain can be started between a\n * call to virConnectNumOfDomains() and this call; you are only guaranteed\n * that all currently active domains were listed if the return is less\n * than @maxids.\n */\nint\nvirConnectListDomains(virConnectPtr conn, int *ids, int maxids)\n{\n    VIR_DEBUG(\"conn=%p, ids=%p, maxids=%d\", conn, ids, maxids);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(ids, error);\n    virCheckNonNegativeArgGoto(maxids, error);\n\n    if (conn->driver->connectListDomains) {\n        int ret = conn->driver->connectListDomains(conn, ids, maxids);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectNumOfDomains:\n * @conn: pointer to the hypervisor connection\n *\n * Provides the number of active domains.\n *\n * Returns the number of domain found or -1 in case of error\n */\nint\nvirConnectNumOfDomains(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectNumOfDomains) {\n        int ret = conn->driver->connectNumOfDomains(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetConnect:\n * @dom: pointer to a domain\n *\n * Provides the connection pointer associated with a domain.  The\n * reference counter on the connection is not increased by this\n * call.\n *\n * WARNING: When writing libvirt bindings in other languages, do\n * not use this function.  Instead, store the connection and\n * the domain object together.\n *\n * Returns the virConnectPtr or NULL in case of failure.\n */\nvirConnectPtr\nvirDomainGetConnect(virDomainPtr dom)\n{\n    VIR_DOMAIN_DEBUG(dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, NULL);\n\n    return dom->conn;\n}\n\n\n/**\n * virDomainCreateXML:\n * @conn: pointer to the hypervisor connection\n * @xmlDesc: string containing an XML description of the domain\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a new guest domain, based on an XML description similar\n * to the one returned by virDomainGetXMLDesc()\n * This function may require privileged access to the hypervisor.\n * The domain is not persistent, so its definition will disappear when it\n * is destroyed, or if the host is restarted (see virDomainDefineXML() to\n * define persistent domains).\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, the guest domain\n * will be started, but its CPUs will remain paused. The CPUs\n * can later be manually started using virDomainResume.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure\n */\nvirDomainPtr\nvirDomainCreateXML(virConnectPtr conn, const char *xmlDesc,\n                   unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xmlDesc=%s, flags=%x\", conn, NULLSTR(xmlDesc), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateXML) {\n        virDomainPtr ret;\n        ret = conn->driver->domainCreateXML(conn, xmlDesc, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainCreateXMLWithFiles:\n * @conn: pointer to the hypervisor connection\n * @xmlDesc: string containing an XML description of the domain\n * @nfiles: number of file descriptors passed\n * @files: list of file descriptors passed\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a new guest domain, based on an XML description similar\n * to the one returned by virDomainGetXMLDesc()\n * This function may require privileged access to the hypervisor.\n * The domain is not persistent, so its definition will disappear when it\n * is destroyed, or if the host is restarted (see virDomainDefineXML() to\n * define persistent domains).\n *\n * @files provides an array of file descriptors which will be\n * made available to the 'init' process of the guest. The file\n * handles exposed to the guest will be renumbered to start\n * from 3 (ie immediately following stderr). This is only\n * supported for guests which use container based virtualization\n * technology.\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, the guest domain\n * will be started, but its CPUs will remain paused. The CPUs\n * can later be manually started using virDomainResume.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure\n */\nvirDomainPtr\nvirDomainCreateXMLWithFiles(virConnectPtr conn, const char *xmlDesc,\n                            unsigned int nfiles,\n                            int *files,\n                            unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xmlDesc=%s, nfiles=%u, files=%p, flags=%x\",\n              conn, NULLSTR(xmlDesc), nfiles, files, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateXMLWithFiles) {\n        virDomainPtr ret;\n        ret = conn->driver->domainCreateXMLWithFiles(conn, xmlDesc,\n                                                     nfiles, files,\n                                                     flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainCreateLinux:\n * @conn: pointer to the hypervisor connection\n * @xmlDesc: string containing an XML description of the domain\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Deprecated after 0.4.6.\n * Renamed to virDomainCreateXML() providing identical functionality.\n * This existing name will be left indefinitely for API compatibility.\n *\n * Returns a new domain object or NULL in case of failure\n */\nvirDomainPtr\nvirDomainCreateLinux(virConnectPtr conn, const char *xmlDesc,\n                     unsigned int flags)\n{\n    return virDomainCreateXML(conn, xmlDesc, flags);\n}\n\n\n/**\n * virDomainLookupByID:\n * @conn: pointer to the hypervisor connection\n * @id: the domain ID number\n *\n * Try to find a domain based on the hypervisor ID number\n * Note that this won't work for inactive domains which have an ID of -1,\n * in that case a lookup based on the Name or UUId need to be done instead.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByID(virConnectPtr conn, int id)\n{\n    VIR_DEBUG(\"conn=%p, id=%d\", conn, id);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNegativeArgGoto(id, error);\n\n    if (conn->driver->domainLookupByID) {\n        virDomainPtr ret;\n        ret = conn->driver->domainLookupByID(conn, id);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainLookupByUUID:\n * @conn: pointer to the hypervisor connection\n * @uuid: the raw UUID for the domain\n *\n * Try to lookup a domain on the given hypervisor based on its UUID.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    VIR_UUID_DEBUG(conn, uuid);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (conn->driver->domainLookupByUUID) {\n        virDomainPtr ret;\n        ret = conn->driver->domainLookupByUUID(conn, uuid);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainLookupByUUIDString:\n * @conn: pointer to the hypervisor connection\n * @uuidstr: the string UUID for the domain\n *\n * Try to lookup a domain on the given hypervisor based on its UUID.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByUUIDString(virConnectPtr conn, const char *uuidstr)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    VIR_DEBUG(\"conn=%p, uuidstr=%s\", conn, NULLSTR(uuidstr));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(uuidstr, error);\n\n    if (virUUIDParse(uuidstr, uuid) < 0) {\n        virReportInvalidArg(uuidstr, \"%s\", _(\"Invalid UUID\"));\n        goto error;\n    }\n\n    return virDomainLookupByUUID(conn, &uuid[0]);\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainLookupByName:\n * @conn: pointer to the hypervisor connection\n * @name: name for the domain\n *\n * Try to lookup a domain on the given hypervisor based on its name.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns a new domain object or NULL in case of failure.  If the\n * domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.\n */\nvirDomainPtr\nvirDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->driver->domainLookupByName) {\n        virDomainPtr dom;\n        dom = conn->driver->domainLookupByName(conn, name);\n        if (!dom)\n            goto error;\n        return dom;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainDestroy:\n * @domain: a domain object\n *\n * Destroy the domain object. The running instance is shutdown if not down\n * already and all resources used by it are given back to the hypervisor. This\n * does not free the associated virDomainPtr object.\n * This function may require privileged access.\n *\n * virDomainDestroy first requests that a guest terminate\n * (e.g. SIGTERM), then waits for it to comply. After a reasonable\n * timeout, if the guest still exists, virDomainDestroy will\n * forcefully terminate the guest (e.g. SIGKILL) if necessary (which\n * may produce undesirable results, for example unflushed disk cache\n * in the guest). To avoid this possibility, it's recommended to\n * instead call virDomainDestroyFlags, sending the\n * VIR_DOMAIN_DESTROY_GRACEFUL flag.\n *\n * If the domain is transient and has any snapshot metadata (see\n * virDomainSnapshotNum()), then that metadata will automatically\n * be deleted when the domain quits.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainDestroy(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDestroy) {\n        int ret;\n        ret = conn->driver->domainDestroy(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainDestroyFlags:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainDestroyFlagsValues\n *\n * Destroy the domain object. The running instance is shutdown if not down\n * already and all resources used by it are given back to the hypervisor.\n * This does not free the associated virDomainPtr object.\n * This function may require privileged access.\n *\n * Calling this function with no @flags set (equal to zero) is\n * equivalent to calling virDomainDestroy, and after a reasonable\n * timeout will forcefully terminate the guest (e.g. SIGKILL) if\n * necessary (which may produce undesirable results, for example\n * unflushed disk cache in the guest). Including\n * VIR_DOMAIN_DESTROY_GRACEFUL in the flags will prevent the forceful\n * termination of the guest, and virDomainDestroyFlags will instead\n * return an error if the guest doesn't terminate by the end of the\n * timeout; at that time, the management application can decide if\n * calling again without VIR_DOMAIN_DESTROY_GRACEFUL is appropriate.\n *\n * Another alternative which may produce cleaner results for the\n * guest's disks is to use virDomainShutdown() instead, but that\n * depends on guest support (some hypervisor/guest combinations may\n * ignore the shutdown request).\n *\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainDestroyFlags(virDomainPtr domain,\n                      unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDestroyFlags) {\n        int ret;\n        ret = conn->driver->domainDestroyFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainFree:\n * @domain: a domain object\n *\n * Free the domain object. The running instance is kept alive.\n * The data structure is freed and should not be used thereafter.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainFree(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virObjectUnref(domain);\n    return 0;\n}\n\n\n/**\n * virDomainRef:\n * @domain: the domain to hold a reference on\n *\n * Increment the reference count on the domain. For each\n * additional call to this method, there shall be a corresponding\n * call to virDomainFree to release the reference count, once\n * the caller no longer needs the reference to this object.\n *\n * This method is typically useful for applications where multiple\n * threads are using a connection, and it is required that the\n * connection remain open until all threads have finished using\n * it. ie, each new thread using a domain would increment\n * the reference count.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainRef(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain, \"refs=%d\", domain ? domain->object.u.s.refs : 0);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virObjectRef(domain);\n    return 0;\n}\n\n\n/**\n * virDomainSuspend:\n * @domain: a domain object\n *\n * Suspends an active domain, the process is frozen without further access\n * to CPU resources and I/O but the memory used by the domain at the\n * hypervisor level will stay allocated. Use virDomainResume() to reactivate\n * the domain.\n * This function may require privileged access.\n * Moreover, suspend may not be supported if domain is in some\n * special state like VIR_DOMAIN_PMSUSPENDED.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSuspend(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainSuspend) {\n        int ret;\n        ret = conn->driver->domainSuspend(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainResume:\n * @domain: a domain object\n *\n * Resume a suspended domain, the process is restarted from the state where\n * it was frozen by calling virDomainSuspend().\n * This function may require privileged access\n * Moreover, resume may not be supported if domain is in some\n * special state like VIR_DOMAIN_PMSUSPENDED.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainResume(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainResume) {\n        int ret;\n        ret = conn->driver->domainResume(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPMSuspendForDuration:\n * @dom: a domain object\n * @target: a value from virNodeSuspendTarget\n * @duration: duration in seconds to suspend, or 0 for indefinite\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Attempt to have the guest enter the given @target power management\n * suspension level.  If @duration is non-zero, also schedule the guest to\n * resume normal operation after that many seconds, if nothing else has\n * resumed it earlier.  Some hypervisors require that @duration be 0, for\n * an indefinite suspension.\n *\n * Dependent on hypervisor used, this may require a\n * guest agent to be available, e.g. QEMU.\n *\n * Beware that at least for QEMU, the domain's process will be terminated\n * when VIR_NODE_SUSPEND_TARGET_DISK is used and a new process will be\n * launched when libvirt is asked to wake up the domain. As a result of\n * this, any runtime changes, such as device hotplug or memory settings,\n * are lost unless such changes were made with VIR_DOMAIN_AFFECT_CONFIG\n * flag.\n *\n * Returns: 0 on success,\n *          -1 on failure.\n */\nint\nvirDomainPMSuspendForDuration(virDomainPtr dom,\n                              unsigned int target,\n                              unsigned long long duration,\n                              unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"target=%u duration=%llu flags=%x\",\n                     target, duration, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainPMSuspendForDuration) {\n        int ret;\n        ret = conn->driver->domainPMSuspendForDuration(dom, target,\n                                                       duration, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainPMWakeup:\n * @dom: a domain object\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Inject a wakeup into the guest that previously used\n * virDomainPMSuspendForDuration, rather than waiting for the\n * previously requested duration (if any) to elapse.\n *\n * Returns: 0 on success,\n *          -1 on failure.\n */\nint\nvirDomainPMWakeup(virDomainPtr dom,\n                  unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainPMWakeup) {\n        int ret;\n        ret = conn->driver->domainPMWakeup(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainSave:\n * @domain: a domain object\n * @to: path for the output file\n *\n * This method will suspend a domain and save its memory contents to\n * a file on disk. After the call, if successful, the domain is not\n * listed as running anymore (this ends the life of a transient domain).\n * Use virDomainRestore() to restore a domain after saving.\n *\n * See virDomainSaveFlags() for more control.  Also, a save file can\n * be inspected or modified slightly with virDomainSaveImageGetXMLDesc()\n * and virDomainSaveImageDefineXML().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSave(virDomainPtr domain, const char *to)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s\", to);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    if (conn->driver->domainSave) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute output file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSave(domain, absolute_to);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSaveFlags:\n * @domain: a domain object\n * @to: path for the output file\n * @dxml: (optional) XML config for adjusting guest xml used on restore\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This method will suspend a domain and save its memory contents to\n * a file on disk. After the call, if successful, the domain is not\n * listed as running anymore (this ends the life of a transient domain).\n * Use virDomainRestore() to restore a domain after saving.\n *\n * If the hypervisor supports it, @dxml can be used to alter\n * host-specific portions of the domain XML that will be used when\n * restoring an image.  For example, it is possible to alter the\n * backing filename that is associated with a disk device, in order to\n * prepare for file renaming done as part of backing up the disk\n * device while the domain is stopped.\n *\n * If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\n * attempt to bypass the file system cache while creating the file, or\n * fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * Normally, the saved state file will remember whether the domain was\n * running or paused, and restore defaults to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override what state gets saved into the file.  These\n * two flags are mutually exclusive.\n *\n * A save file can be inspected or modified slightly with\n * virDomainSaveImageGetXMLDesc() and virDomainSaveImageDefineXML().\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation; in that case, use virDomainBlockJobAbort()\n * to stop the block copy first.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSaveFlags(virDomainPtr domain, const char *to,\n                   const char *dxml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, dxml=%s, flags=%x\",\n                     to, NULLSTR(dxml), flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainSaveFlags) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute output file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSaveFlags(domain, absolute_to, dxml, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainRestore:\n * @conn: pointer to the hypervisor connection\n * @from: path to the input file\n *\n * This method will restore a domain saved to disk by virDomainSave().\n *\n * See virDomainRestoreFlags() for more control.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainRestore(virConnectPtr conn, const char *from)\n{\n    VIR_DEBUG(\"conn=%p, from=%s\", conn, NULLSTR(from));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(from, error);\n\n    if (conn->driver->domainRestore) {\n        int ret;\n        char *absolute_from;\n\n        /* We must absolutize the file path as the restore is done out of process */\n        if (virFileAbsPath(from, &absolute_from) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainRestore(conn, absolute_from);\n\n        VIR_FREE(absolute_from);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainRestoreFlags:\n * @conn: pointer to the hypervisor connection\n * @from: path to the input file\n * @dxml: (optional) XML config for adjusting guest xml used on restore\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This method will restore a domain saved to disk by virDomainSave().\n *\n * If the hypervisor supports it, @dxml can be used to alter\n * host-specific portions of the domain XML that will be used when\n * restoring an image.  For example, it is possible to alter the\n * backing filename that is associated with a disk device, in order to\n * prepare for file renaming done as part of backing up the disk\n * device while the domain is stopped.\n *\n * If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\n * attempt to bypass the file system cache while restoring the file, or\n * fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing restores from NFS.\n *\n * Normally, the saved state file will remember whether the domain was\n * running or paused, and restore defaults to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override the default read from the file.  These two\n * flags are mutually exclusive.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainRestoreFlags(virConnectPtr conn, const char *from, const char *dxml,\n                      unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, from=%s, dxml=%s, flags=%x\",\n              conn, NULLSTR(from), NULLSTR(dxml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(from, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainRestoreFlags) {\n        int ret;\n        char *absolute_from;\n\n        /* We must absolutize the file path as the restore is done out of process */\n        if (virFileAbsPath(from, &absolute_from) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainRestoreFlags(conn, absolute_from, dxml,\n                                               flags);\n\n        VIR_FREE(absolute_from);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainSaveImageGetXMLDesc:\n * @conn: pointer to the hypervisor connection\n * @file: path to saved state file\n * @flags: bitwise-OR of subset of virDomainXMLFlags\n *\n * This method will extract the XML describing the domain at the time\n * a saved state file was created.  @file must be a file created\n * previously by virDomainSave() or virDomainSaveFlags().\n *\n * No security-sensitive data will be included unless @flags contains\n * VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\n * connections.  For this API, @flags should not contain either\n * VIR_DOMAIN_XML_INACTIVE or VIR_DOMAIN_XML_UPDATE_CPU.\n *\n * Returns a 0 terminated UTF-8 encoded XML instance, or NULL in case of\n * error.  The caller must free() the returned value.\n */\nchar *\nvirDomainSaveImageGetXMLDesc(virConnectPtr conn, const char *file,\n                             unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, file=%s, flags=%x\",\n              conn, NULLSTR(file), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(file, error);\n\n    if ((conn->flags & VIR_CONNECT_RO) && (flags & VIR_DOMAIN_XML_SECURE)) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"virDomainSaveImageGetXMLDesc with secure flag\"));\n        goto error;\n    }\n\n    if (conn->driver->domainSaveImageGetXMLDesc) {\n        char *ret;\n        char *absolute_file;\n\n        /* We must absolutize the file path as the read is done out of process */\n        if (virFileAbsPath(file, &absolute_file) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSaveImageGetXMLDesc(conn, absolute_file,\n                                                      flags);\n\n        VIR_FREE(absolute_file);\n\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainSaveImageDefineXML:\n * @conn: pointer to the hypervisor connection\n * @file: path to saved state file\n * @dxml: XML config for adjusting guest xml used on restore\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This updates the definition of a domain stored in a saved state\n * file.  @file must be a file created previously by virDomainSave()\n * or virDomainSaveFlags().\n *\n * @dxml can be used to alter host-specific portions of the domain XML\n * that will be used when restoring an image.  For example, it is\n * possible to alter the backing filename that is associated with a\n * disk device, to match renaming done as part of backing up the disk\n * device while the domain is stopped.\n *\n * Normally, the saved state file will remember whether the domain was\n * running or paused, and restore defaults to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override the default saved into the file; omitting both\n * leaves the file's default unchanged.  These two flags are mutually\n * exclusive.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSaveImageDefineXML(virConnectPtr conn, const char *file,\n                            const char *dxml, unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, file=%s, dxml=%s, flags=%x\",\n              conn, NULLSTR(file), NULLSTR(dxml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(file, error);\n    virCheckNonNullArgGoto(dxml, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainSaveImageDefineXML) {\n        int ret;\n        char *absolute_file;\n\n        /* We must absolutize the file path as the read is done out of process */\n        if (virFileAbsPath(file, &absolute_file) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute input file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainSaveImageDefineXML(conn, absolute_file,\n                                                     dxml, flags);\n\n        VIR_FREE(absolute_file);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainCoreDump:\n * @domain: a domain object\n * @to: path for the core file\n * @flags: bitwise-OR of virDomainCoreDumpFlags\n *\n * This method will dump the core of a domain on a given file for analysis.\n * Note that for remote Xen Daemon the file path will be interpreted in\n * the remote host. Hypervisors may require  the user to manually ensure\n * proper permissions on the file named by @to.\n *\n * If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with\n * a crashed state after the dump completes.  If @flags includes\n * VIR_DUMP_LIVE, then make the core dump while continuing to allow\n * the guest to run; otherwise, the guest is suspended during the dump.\n * VIR_DUMP_RESET flag forces reset of the guest after dump.\n * The above three flags are mutually exclusive.\n *\n * Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt\n * will attempt to bypass the file system cache while creating the file,\n * or fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * For more control over the output format, see virDomainCoreDumpWithFormat().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, flags=%x\", to, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);\n\n    if (conn->driver->domainCoreDump) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute core file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainCoreDump(domain, absolute_to, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n/**\n * virDomainCoreDumpWithFormat:\n * @domain: a domain object\n * @to: path for the core file\n * @dumpformat: format of domain memory's dump (one of virDomainCoreDumpFormat enum)\n * @flags: bitwise-OR of virDomainCoreDumpFlags\n *\n * This method will dump the core of a domain on a given file for analysis.\n * Note that for remote Xen Daemon the file path will be interpreted in\n * the remote host. Hypervisors may require  the user to manually ensure\n * proper permissions on the file named by @to.\n *\n * @dumpformat controls which format the dump will have; use of\n * VIR_DOMAIN_CORE_DUMP_FORMAT_RAW mirrors what virDomainCoreDump() will\n * perform.  Not all hypervisors are able to support all formats.\n *\n * If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with\n * a crashed state after the dump completes.  If @flags includes\n * VIR_DUMP_LIVE, then make the core dump while continuing to allow\n * the guest to run; otherwise, the guest is suspended during the dump.\n * VIR_DUMP_RESET flag forces reset of the guest after dump.\n * The above three flags are mutually exclusive.\n *\n * Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt\n * will attempt to bypass the file system cache while creating the file,\n * or fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainCoreDumpWithFormat(virDomainPtr domain, const char *to,\n                            unsigned int dumpformat, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, dumpformat=%u, flags=%x\",\n                     to, dumpformat, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    if (dumpformat >= VIR_DOMAIN_CORE_DUMP_FORMAT_LAST) {\n        virReportInvalidArg(flags, _(\"dumpformat '%d' is not supported\"),\n                            dumpformat);\n        goto error;\n    }\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);\n\n    if (conn->driver->domainCoreDumpWithFormat) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute core file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainCoreDumpWithFormat(domain, absolute_to,\n                                                     dumpformat, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainScreenshot:\n * @domain: a domain object\n * @stream: stream to use as output\n * @screen: monitor ID to take screenshot from\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Take a screenshot of current domain console as a stream. The image format\n * is hypervisor specific. Moreover, some hypervisors supports multiple\n * displays per domain. These can be distinguished by @screen argument.\n *\n * This call sets up a stream; subsequent use of stream API is necessary\n * to transfer actual data, determine how much data is successfully\n * transferred, and detect any errors.\n *\n * The screen ID is the sequential number of screen. In case of multiple\n * graphics cards, heads are enumerated before devices, e.g. having\n * two graphics cards, both with four heads, screen ID 5 addresses\n * the second head on the second card.\n *\n * Returns a string representing the mime-type of the image format, or\n * NULL upon error. The caller must free() the returned value.\n */\nchar *\nvirDomainScreenshot(virDomainPtr domain,\n                    virStreamPtr stream,\n                    unsigned int screen,\n                    unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(domain, \"stream=%p, flags=%x\", stream, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    virCheckStreamGoto(stream, error);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    if (domain->conn != stream->conn) {\n        virReportInvalidArg(stream,\n                            _(\"stream must match connection of domain '%s'\"),\n                            domain->name);\n        goto error;\n    }\n\n    if (domain->conn->driver->domainScreenshot) {\n        char *ret;\n        ret = domain->conn->driver->domainScreenshot(domain, stream,\n                                                     screen, flags);\n\n        if (ret == NULL)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainShutdown:\n * @domain: a domain object\n *\n * Shutdown a domain, the domain object is still usable thereafter, but\n * the domain OS is being stopped. Note that the guest OS may ignore the\n * request. Additionally, the hypervisor may check and support the domain\n * 'on_poweroff' XML setting resulting in a domain that reboots instead of\n * shutting down. For guests that react to a shutdown request, the differences\n * from virDomainDestroy() are that the guests disk storage will be in a\n * stable state rather than having the (virtual) power cord pulled, and\n * this command returns as soon as the shutdown request is issued rather\n * than blocking until the guest is no longer running.\n *\n * If the domain is transient and has any snapshot metadata (see\n * virDomainSnapshotNum()), then that metadata will automatically\n * be deleted when the domain quits.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainShutdown(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainShutdown) {\n        int ret;\n        ret = conn->driver->domainShutdown(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainShutdownFlags:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainShutdownFlagValues\n *\n * Shutdown a domain, the domain object is still usable thereafter but\n * the domain OS is being stopped. Note that the guest OS may ignore the\n * request. Additionally, the hypervisor may check and support the domain\n * 'on_poweroff' XML setting resulting in a domain that reboots instead of\n * shutting down. For guests that react to a shutdown request, the differences\n * from virDomainDestroy() are that the guest's disk storage will be in a\n * stable state rather than having the (virtual) power cord pulled, and\n * this command returns as soon as the shutdown request is issued rather\n * than blocking until the guest is no longer running.\n *\n * If the domain is transient and has any snapshot metadata (see\n * virDomainSnapshotNum()), then that metadata will automatically\n * be deleted when the domain quits.\n *\n * If @flags is set to zero, then the hypervisor will choose the\n * method of shutdown it considers best. To have greater control\n * pass one or more of the virDomainShutdownFlagValues. The order\n * in which the hypervisor tries each shutdown method is undefined,\n * and a hypervisor is not required to support all methods.\n *\n * To use guest agent (VIR_DOMAIN_SHUTDOWN_GUEST_AGENT) the domain XML\n * must have <channel> configured.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainShutdownFlags(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainShutdownFlags) {\n        int ret;\n        ret = conn->driver->domainShutdownFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainReboot:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainRebootFlagValues\n *\n * Reboot a domain, the domain object is still usable thereafter, but\n * the domain OS is being stopped for a restart.\n * Note that the guest OS may ignore the request.\n * Additionally, the hypervisor may check and support the domain\n * 'on_reboot' XML setting resulting in a domain that shuts down instead\n * of rebooting.\n *\n * If @flags is set to zero, then the hypervisor will choose the\n * method of shutdown it considers best. To have greater control\n * pass one or more of the virDomainRebootFlagValues. The order\n * in which the hypervisor tries each shutdown method is undefined,\n * and a hypervisor is not required to support all methods.\n *\n * To use guest agent (VIR_DOMAIN_REBOOT_GUEST_AGENT) the domain XML\n * must have <channel> configured.\n *\n * Due to implementation limitations in some drivers (the qemu driver,\n * for instance) it is not advised to migrate or save a guest that is\n * rebooting as a result of this API. Migrating such a guest can lead\n * to a plain shutdown on the destination.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainReboot(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainReboot) {\n        int ret;\n        ret = conn->driver->domainReboot(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainReset:\n * @domain: a domain object\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Reset a domain immediately without any guest OS shutdown.\n * Reset emulates the power reset button on a machine, where all\n * hardware sees the RST line set and reinitializes internal state.\n *\n * Note that there is a risk of data loss caused by reset without any\n * guest OS shutdown.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainReset(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainReset) {\n        int ret;\n        ret = conn->driver->domainReset(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetName:\n * @domain: a domain object\n *\n * Get the public name for that domain\n *\n * Returns a pointer to the name or NULL, the string need not be deallocated\n * its lifetime will be the same as the domain object.\n */\nconst char *\nvirDomainGetName(virDomainPtr domain)\n{\n    VIR_DEBUG(\"domain=%p\", domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n\n    return domain->name;\n}\n\n\n/**\n * virDomainGetUUID:\n * @domain: a domain object\n * @uuid: pointer to a VIR_UUID_BUFLEN bytes array\n *\n * Get the UUID for a domain\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainGetUUID(virDomainPtr domain, unsigned char *uuid)\n{\n    VIR_DOMAIN_DEBUG(domain, \"uuid=%p\", uuid);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(uuid, error);\n\n    memcpy(uuid, &domain->uuid[0], VIR_UUID_BUFLEN);\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetUUIDString:\n * @domain: a domain object\n * @buf: pointer to a VIR_UUID_STRING_BUFLEN bytes array\n *\n * Get the UUID for a domain as string. For more information about\n * UUID see RFC4122.\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainGetUUIDString(virDomainPtr domain, char *buf)\n{\n    VIR_DOMAIN_DEBUG(domain, \"buf=%p\", buf);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(buf, error);\n\n    virUUIDFormat(domain->uuid, buf);\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetID:\n * @domain: a domain object\n *\n * Get the hypervisor ID number for the domain\n *\n * Returns the domain ID number or (unsigned int) -1 in case of error\n */\nunsigned int\nvirDomainGetID(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, (unsigned int)-1);\n\n    return domain->id;\n}\n\n\n/**\n * virDomainGetOSType:\n * @domain: a domain object\n *\n * Get the type of domain operation system.\n *\n * Returns the new string or NULL in case of error, the string must be\n *         freed by the caller.\n */\nchar *\nvirDomainGetOSType(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetOSType) {\n        char *ret;\n        ret = conn->driver->domainGetOSType(domain);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainGetMaxMemory:\n * @domain: a domain object or NULL\n *\n * Retrieve the maximum amount of physical memory allocated to a\n * domain. If domain is NULL, then this get the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n *\n * Returns the memory size in kibibytes (blocks of 1024 bytes), or 0 in\n * case of error.\n */\nunsigned long\nvirDomainGetMaxMemory(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, 0);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMaxMemory) {\n        unsigned long long ret;\n        ret = conn->driver->domainGetMaxMemory(domain);\n        if (ret == 0)\n            goto error;\n        if ((unsigned long) ret != ret) {\n            virReportError(VIR_ERR_OVERFLOW, _(\"result too large: %llu\"),\n                           ret);\n            goto error;\n        }\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return 0;\n}\n\n\n/**\n * virDomainSetMaxMemory:\n * @domain: a domain object or NULL\n * @memory: the memory size in kibibytes (blocks of 1024 bytes)\n *\n * Dynamically change the maximum amount of physical memory allocated to a\n * domain. If domain is NULL, then this change the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n * This function may require privileged access to the hypervisor.\n *\n * This command is hypervisor-specific for whether active, persistent,\n * or both configurations are changed; for more control, use\n * virDomainSetMemoryFlags().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSetMaxMemory(virDomainPtr domain, unsigned long memory)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"memory=%lu\", memory);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(memory, error);\n\n    if (virMemoryMaxValue(true) / 1024 <= memory) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %lu\"),\n                       memory);\n        goto error;\n    }\n\n    if (conn->driver->domainSetMaxMemory) {\n        int ret;\n        ret = conn->driver->domainSetMaxMemory(domain, memory);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemory:\n * @domain: a domain object or NULL\n * @memory: the memory size in kibibytes (blocks of 1024 bytes)\n *\n * Dynamically change the target amount of physical memory allocated to a\n * domain. If domain is NULL, then this change the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n * This function may require privileged access to the hypervisor.\n *\n * This command is hypervisor-specific for whether active, persistent,\n * or both configurations are changed; for more control, use\n * virDomainSetMemoryFlags().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainSetMemory(virDomainPtr domain, unsigned long memory)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"memory=%lu\", memory);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(memory, error);\n\n    if (virMemoryMaxValue(true) / 1024 <= memory) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %lu\"),\n                       memory);\n        goto error;\n    }\n\n    if (conn->driver->domainSetMemory) {\n        int ret;\n        ret = conn->driver->domainSetMemory(domain, memory);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemoryFlags:\n * @domain: a domain object or NULL\n * @memory: the memory size in kibibytes (blocks of 1024 bytes)\n * @flags: bitwise-OR of virDomainMemoryModFlags\n *\n * Dynamically change the target amount of physical memory allocated to a\n * domain. If domain is NULL, then this change the amount of memory reserved\n * to Domain0 i.e. the domain where the application runs.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects\n * a running domain and will fail if domain is not active.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified\n * (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain\n * modifies persistent setup, while an active domain is hypervisor-dependent\n * on whether just live or both live and persistent state is changed.\n * If VIR_DOMAIN_MEM_MAXIMUM is set, the change affects domain's maximum memory\n * size rather than current memory size.\n * Not all hypervisors can support all flag combinations.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetMemoryFlags(virDomainPtr domain, unsigned long memory,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"memory=%lu, flags=%x\", memory, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(memory, error);\n\n    if (virMemoryMaxValue(true) / 1024 <= memory) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %lu\"),\n                       memory);\n        goto error;\n    }\n\n    if (conn->driver->domainSetMemoryFlags) {\n        int ret;\n        ret = conn->driver->domainSetMemoryFlags(domain, memory, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemoryStatsPeriod:\n * @domain: a domain object or NULL\n * @period: the period in seconds for stats collection\n * @flags: bitwise-OR of virDomainMemoryModFlags\n *\n * Dynamically change the domain memory balloon driver statistics collection\n * period. Use 0 to disable and a positive value to enable.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects\n * a running domain and will fail if domain is not active.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified\n * (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain\n * modifies persistent setup, while an active domain is hypervisor-dependent\n * on whether just live or both live and persistent state is changed.\n *\n * Not all hypervisors can support all flag combinations.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetMemoryStatsPeriod(virDomainPtr domain, int period,\n                              unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"period=%d, flags=%x\", period, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    /* This must be positive to set the balloon collection period */\n    virCheckNonNegativeArgGoto(period, error);\n\n    if (conn->driver->domainSetMemoryStatsPeriod) {\n        int ret;\n        ret = conn->driver->domainSetMemoryStatsPeriod(domain, period, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMemoryParameters:\n * @domain: pointer to domain object\n * @params: pointer to memory parameter objects\n * @nparams: number of memory parameter (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the memory tunables.\n * This function may require privileged access to the hypervisor.\n *\n * Possible values for all *_limit memory tunables are in range from 0 to\n * VIR_DOMAIN_MEMORY_PARAM_UNLIMITED.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetMemoryParameters(virDomainPtr domain,\n                             virTypedParameterPtr params,\n                             int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckPositiveArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetMemoryParameters) {\n        int ret;\n        ret = conn->driver->domainSetMemoryParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetMemoryParameters:\n * @domain: pointer to domain object\n * @params: pointer to memory parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of memory parameters; input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all memory parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.\n *\n * Here is a sample code snippet:\n *\n *   if (virDomainGetMemoryParameters(dom, NULL, &nparams, 0) == 0 &&\n *       nparams != 0) {\n *       if ((params = malloc(sizeof(*params) * nparams)) == NULL)\n *           goto error;\n *       memset(params, 0, sizeof(*params) * nparams);\n *       if (virDomainGetMemoryParameters(dom, params, &nparams, 0))\n *           goto error;\n *   }\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetMemoryParameters(virDomainPtr domain,\n                             virTypedParameterPtr params,\n                             int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMemoryParameters) {\n        int ret;\n        ret = conn->driver->domainGetMemoryParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetNumaParameters:\n * @domain: pointer to domain object\n * @params: pointer to numa parameter objects\n * @nparams: number of numa parameters (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the numa tunables.\n * This function may require privileged access to the hypervisor.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetNumaParameters(virDomainPtr domain,\n                           virTypedParameterPtr params,\n                           int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckPositiveArgGoto(nparams, error);\n    if (virTypedParameterValidateSet(domain->conn, params, nparams) < 0)\n        goto error;\n\n    conn = domain->conn;\n\n    if (conn->driver->domainSetNumaParameters) {\n        int ret;\n        ret = conn->driver->domainSetNumaParameters(domain, params, nparams,\n                                                    flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetNumaParameters:\n * @domain: pointer to domain object\n * @params: pointer to numa parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of numa parameters\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all numa parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.\n *\n * See virDomainGetMemoryParameters() for an equivalent usage example.\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetNumaParameters(virDomainPtr domain,\n                           virTypedParameterPtr params,\n                           int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetNumaParameters) {\n        int ret;\n        ret = conn->driver->domainGetNumaParameters(domain, params, nparams,\n                                                    flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetBlkioParameters:\n * @domain: pointer to domain object\n * @params: pointer to blkio parameter objects\n * @nparams: number of blkio parameters (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the blkio tunables.\n * This function may require privileged access to the hypervisor.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetBlkioParameters(virDomainPtr domain,\n                            virTypedParameterPtr params,\n                            int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetBlkioParameters) {\n        int ret;\n        ret = conn->driver->domainSetBlkioParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlkioParameters:\n * @domain: pointer to domain object\n * @params: pointer to blkio parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of blkio parameters; input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all blkio parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.\n *\n * See virDomainGetMemoryParameters() for an equivalent usage example.\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetBlkioParameters(virDomainPtr domain,\n                            virTypedParameterPtr params,\n                            int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetBlkioParameters) {\n        int ret;\n        ret = conn->driver->domainGetBlkioParameters(domain, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetInfo:\n * @domain: a domain object\n * @info: pointer to a virDomainInfo structure allocated by the user\n *\n * Extract information about a domain. Note that if the connection\n * used to get the domain is limited only a partial set of the information\n * can be extracted.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetInfo(virDomainPtr domain, virDomainInfoPtr info)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p\", info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetInfo) {\n        int ret;\n        ret = conn->driver->domainGetInfo(domain, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetState:\n * @domain: a domain object\n * @state: returned state of the domain (one of virDomainState)\n * @reason: returned reason which led to @state (one of virDomain*Reason\n * corresponding to the current state); it is allowed to be NULL\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract domain state. Each state can be accompanied with a reason (if known)\n * which led to the state.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetState(virDomainPtr domain,\n                  int *state,\n                  int *reason,\n                  unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"state=%p, reason=%p, flags=%x\",\n                     state, reason, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(state, error);\n\n    conn = domain->conn;\n    if (conn->driver->domainGetState) {\n        int ret;\n        ret = conn->driver->domainGetState(domain, state, reason, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetControlInfo:\n * @domain: a domain object\n * @info: pointer to a virDomainControlInfo structure allocated by the user\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract details about current state of control interface to a domain.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetControlInfo(virDomainPtr domain,\n                        virDomainControlInfoPtr info,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p, flags=%x\", info, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n    if (conn->driver->domainGetControlInfo) {\n        int ret;\n        ret = conn->driver->domainGetControlInfo(domain, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetXMLDesc:\n * @domain: a domain object\n * @flags: bitwise-OR of virDomainXMLFlags\n *\n * Provide an XML description of the domain. The description may be reused\n * later to relaunch the domain with virDomainCreateXML().\n *\n * No security-sensitive data will be included unless @flags contains\n * VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\n * connections.  If @flags includes VIR_DOMAIN_XML_INACTIVE, then the\n * XML represents the configuration that will be used on the next boot\n * of a persistent domain; otherwise, the configuration represents the\n * currently running domain.  If @flags contains\n * VIR_DOMAIN_XML_UPDATE_CPU, then the portion of the domain XML\n * describing CPU capabilities is modified to match actual\n * capabilities of the host.\n *\n * Returns a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.\n *         the caller must free() the returned value.\n */\nchar *\nvirDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if ((conn->flags & VIR_CONNECT_RO) &&\n        (flags & (VIR_DOMAIN_XML_SECURE | VIR_DOMAIN_XML_MIGRATABLE))) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"virDomainGetXMLDesc with secure flag\"));\n        goto error;\n    }\n\n    if (conn->driver->domainGetXMLDesc) {\n        char *ret;\n        ret = conn->driver->domainGetXMLDesc(domain, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virConnectDomainXMLFromNative:\n * @conn: a connection object\n * @nativeFormat: configuration format importing from\n * @nativeConfig: the configuration data to import\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Reads native configuration data  describing a domain, and\n * generates libvirt domain XML. The format of the native\n * data is hypervisor dependent.\n *\n * Returns a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.\n *         the caller must free() the returned value.\n */\nchar *\nvirConnectDomainXMLFromNative(virConnectPtr conn,\n                              const char *nativeFormat,\n                              const char *nativeConfig,\n                              unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, format=%s, config=%s, flags=%x\",\n              conn, NULLSTR(nativeFormat), NULLSTR(nativeConfig), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    virCheckNonNullArgGoto(nativeFormat, error);\n    virCheckNonNullArgGoto(nativeConfig, error);\n\n    if (conn->driver->connectDomainXMLFromNative) {\n        char *ret;\n        ret = conn->driver->connectDomainXMLFromNative(conn,\n                                                       nativeFormat,\n                                                       nativeConfig,\n                                                       flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virConnectDomainXMLToNative:\n * @conn: a connection object\n * @nativeFormat: configuration format exporting to\n * @domainXml: the domain configuration to export\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Reads a domain XML configuration document, and generates\n * a native configuration file describing the domain.\n * The format of the native data is hypervisor dependent.\n *\n * Returns a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error.\n *         the caller must free() the returned value.\n */\nchar *\nvirConnectDomainXMLToNative(virConnectPtr conn,\n                            const char *nativeFormat,\n                            const char *domainXml,\n                            unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, format=%s, xml=%s, flags=%x\",\n              conn, NULLSTR(nativeFormat), NULLSTR(domainXml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    virCheckNonNullArgGoto(nativeFormat, error);\n    virCheckNonNullArgGoto(domainXml, error);\n\n    if (conn->driver->connectDomainXMLToNative) {\n        char *ret;\n        ret = conn->driver->connectDomainXMLToNative(conn,\n                                                     nativeFormat,\n                                                     domainXml,\n                                                     flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/*\n * Sequence v1:\n *\n *  Dst: Prepare\n *        - Get ready to accept incoming VM\n *        - Generate optional cookie to pass to src\n *\n *  Src: Perform\n *        - Start migration and wait for send completion\n *        - Kill off VM if successful, resume if failed\n *\n *  Dst: Finish\n *        - Wait for recv completion and check status\n *        - Kill off VM if unsuccessful\n *\n */\nstatic virDomainPtr\nvirDomainMigrateVersion1(virDomainPtr domain,\n                         virConnectPtr dconn,\n                         unsigned long flags,\n                         const char *dname,\n                         const char *uri,\n                         unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    int cookielen = 0, ret;\n    virDomainInfo info;\n    unsigned int destflags;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    ret = virDomainGetInfo(domain, &info);\n    if (ret == 0 && info.state == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    /* Prepare the migration.\n     *\n     * The destination host may return a cookie, or leave cookie as\n     * NULL.\n     *\n     * The destination host MUST set uri_out if uri_in is NULL.\n     *\n     * If uri_in is non-NULL, then the destination host may modify\n     * the URI by setting uri_out.  If it does not wish to modify\n     * the URI, it should leave uri_out as NULL.\n     */\n    if (dconn->driver->domainMigratePrepare\n        (dconn, &cookie, &cookielen, uri, &uri_out, destflags, dname,\n         bandwidth) == -1)\n        goto done;\n\n    if (uri == NULL && uri_out == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare did not set uri\"));\n        goto done;\n    }\n    if (uri_out)\n        uri = uri_out; /* Did domainMigratePrepare change URI? */\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    if (domain->conn->driver->domainMigratePerform\n        (domain, cookie, cookielen, uri, flags, dname, bandwidth) == -1)\n        goto done;\n\n    /* Get the destination domain and return it or error.\n     * 'domain' no longer actually exists at this point\n     * (or so we hope), but we still use the object in memory\n     * in order to get the name.\n     */\n    dname = dname ? dname : domain->name;\n    if (dconn->driver->domainMigrateFinish)\n        ddomain = dconn->driver->domainMigrateFinish\n            (dconn, dname, cookie, cookielen, uri, destflags);\n    else\n        ddomain = virDomainLookupByName(dconn, dname);\n\n done:\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n    return ddomain;\n}\n\n\n/*\n * Sequence v2:\n *\n *  Src: DumpXML\n *        - Generate XML to pass to dst\n *\n *  Dst: Prepare\n *        - Get ready to accept incoming VM\n *        - Generate optional cookie to pass to src\n *\n *  Src: Perform\n *        - Start migration and wait for send completion\n *        - Kill off VM if successful, resume if failed\n *\n *  Dst: Finish\n *        - Wait for recv completion and check status\n *        - Kill off VM if unsuccessful\n *\n */\nstatic virDomainPtr\nvirDomainMigrateVersion2(virDomainPtr domain,\n                         virConnectPtr dconn,\n                         unsigned long flags,\n                         const char *dname,\n                         const char *uri,\n                         unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    char *dom_xml = NULL;\n    int cookielen = 0, ret;\n    virDomainInfo info;\n    virErrorPtr orig_err = NULL;\n    unsigned int getxml_flags = 0;\n    int cancelled;\n    unsigned long destflags;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    /* Prepare the migration.\n     *\n     * The destination host may return a cookie, or leave cookie as\n     * NULL.\n     *\n     * The destination host MUST set uri_out if uri_in is NULL.\n     *\n     * If uri_in is non-NULL, then the destination host may modify\n     * the URI by setting uri_out.  If it does not wish to modify\n     * the URI, it should leave uri_out as NULL.\n     */\n\n    /* In version 2 of the protocol, the prepare step is slightly\n     * different.  We fetch the domain XML of the source domain\n     * and pass it to Prepare2.\n     */\n    if (!domain->conn->driver->domainGetXMLDesc) {\n        virReportUnsupportedError();\n        return NULL;\n    }\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_XML_MIGRATABLE)) {\n        getxml_flags |= VIR_DOMAIN_XML_MIGRATABLE;\n    } else {\n        getxml_flags |= VIR_DOMAIN_XML_SECURE | VIR_DOMAIN_XML_UPDATE_CPU;\n    }\n\n    dom_xml = domain->conn->driver->domainGetXMLDesc(domain, getxml_flags);\n    if (!dom_xml)\n        return NULL;\n\n    ret = virDomainGetInfo(domain, &info);\n    if (ret == 0 && info.state == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare2 %p flags=%lx\", dconn, destflags);\n    ret = dconn->driver->domainMigratePrepare2\n        (dconn, &cookie, &cookielen, uri, &uri_out, destflags, dname,\n         bandwidth, dom_xml);\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto done;\n\n    if (uri == NULL && uri_out == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare2 did not set uri\"));\n        cancelled = 1;\n        /* Make sure Finish doesn't overwrite the error */\n        orig_err = virSaveLastError();\n        goto finish;\n    }\n    if (uri_out)\n        uri = uri_out; /* Did domainMigratePrepare2 change URI? */\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    VIR_DEBUG(\"Perform %p\", domain->conn);\n    ret = domain->conn->driver->domainMigratePerform\n        (domain, cookie, cookielen, uri, flags, dname, bandwidth);\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0)\n        orig_err = virSaveLastError();\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0 ? 1 : 0;\n\n finish:\n    /* In version 2 of the migration protocol, we pass the\n     * status code from the sender to the destination host,\n     * so it can do any cleanup if the migration failed.\n     */\n    dname = dname ? dname : domain->name;\n    VIR_DEBUG(\"Finish2 %p ret=%d\", dconn, ret);\n    ddomain = dconn->driver->domainMigrateFinish2\n        (dconn, dname, cookie, cookielen, uri, destflags, cancelled);\n    if (cancelled && ddomain)\n        VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n\n done:\n    if (orig_err) {\n        virSetError(orig_err);\n        virFreeError(orig_err);\n    }\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n    return ddomain;\n}\n\n\n/*\n * Sequence v3:\n *\n *  Src: Begin\n *        - Generate XML to pass to dst\n *        - Generate optional cookie to pass to dst\n *\n *  Dst: Prepare\n *        - Get ready to accept incoming VM\n *        - Generate optional cookie to pass to src\n *\n *  Src: Perform\n *        - Start migration and wait for send completion\n *        - Generate optional cookie to pass to dst\n *\n *  Dst: Finish\n *        - Wait for recv completion and check status\n *        - Kill off VM if failed, resume if success\n *        - Generate optional cookie to pass to src\n *\n *  Src: Confirm\n *        - Kill off VM if success, resume if failed\n *\n  * If useParams is true, params and nparams contain migration parameters and\n  * we know it's safe to call the API which supports extensible parameters.\n  * Otherwise, we have to use xmlin, dname, uri, and bandwidth and pass them\n  * to the old-style APIs.\n */\nstatic virDomainPtr\nvirDomainMigrateVersion3Full(virDomainPtr domain,\n                             virConnectPtr dconn,\n                             const char *xmlin,\n                             const char *dname,\n                             const char *uri,\n                             unsigned long long bandwidth,\n                             virTypedParameterPtr params,\n                             int nparams,\n                             bool useParams,\n                             unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookiein = NULL;\n    char *cookieout = NULL;\n    char *dom_xml = NULL;\n    int cookieinlen = 0;\n    int cookieoutlen = 0;\n    int ret;\n    virDomainInfo info;\n    virErrorPtr orig_err = NULL;\n    int cancelled = 1;\n    unsigned long protection = 0;\n    bool notify_source = true;\n    unsigned int destflags;\n    int state;\n    virTypedParameterPtr tmp;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, xmlin=%s, dname=%s, uri=%s, bandwidth=%llu, \"\n                     \"params=%p, nparams=%d, useParams=%d, flags=%x\",\n                     dconn, NULLSTR(xmlin), NULLSTR(dname), NULLSTR(uri),\n                     bandwidth, params, nparams, useParams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    if ((!useParams &&\n         (!domain->conn->driver->domainMigrateBegin3 ||\n          !domain->conn->driver->domainMigratePerform3 ||\n          !domain->conn->driver->domainMigrateConfirm3 ||\n          !dconn->driver->domainMigratePrepare3 ||\n          !dconn->driver->domainMigrateFinish3)) ||\n        (useParams &&\n         (!domain->conn->driver->domainMigrateBegin3Params ||\n          !domain->conn->driver->domainMigratePerform3Params ||\n          !domain->conn->driver->domainMigrateConfirm3Params ||\n          !dconn->driver->domainMigratePrepare3Params ||\n          !dconn->driver->domainMigrateFinish3Params))) {\n        virReportUnsupportedError();\n        return NULL;\n    }\n\n    if (virTypedParamsCopy(&tmp, params, nparams) < 0)\n        return NULL;\n    params = tmp;\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION))\n        protection = VIR_MIGRATE_CHANGE_PROTECTION;\n\n    VIR_DEBUG(\"Begin3 %p\", domain->conn);\n    if (useParams) {\n        dom_xml = domain->conn->driver->domainMigrateBegin3Params\n            (domain, params, nparams, &cookieout, &cookieoutlen,\n             flags | protection);\n    } else {\n        dom_xml = domain->conn->driver->domainMigrateBegin3\n            (domain, xmlin, &cookieout, &cookieoutlen,\n             flags | protection, dname, bandwidth);\n    }\n    if (!dom_xml)\n        goto done;\n\n    if (useParams) {\n        /* If source is new enough to support extensible migration parameters,\n         * it's certainly new enough to support virDomainGetState. */\n        ret = virDomainGetState(domain, &state, NULL, 0);\n    } else {\n        ret = virDomainGetInfo(domain, &info);\n        state = info.state;\n    }\n    if (ret == 0 && state == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare3 %p flags=%x\", dconn, destflags);\n    cookiein = cookieout;\n    cookieinlen = cookieoutlen;\n    cookieout = NULL;\n    cookieoutlen = 0;\n    if (useParams) {\n        if (virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_XML,\n                                        dom_xml) < 0)\n            goto done;\n        ret = dconn->driver->domainMigratePrepare3Params\n            (dconn, params, nparams, cookiein, cookieinlen,\n             &cookieout, &cookieoutlen, &uri_out, destflags);\n    } else {\n        ret = dconn->driver->domainMigratePrepare3\n            (dconn, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             uri, &uri_out, destflags, dname, bandwidth, dom_xml);\n    }\n    if (ret == -1) {\n        if (protection) {\n            /* Begin already started a migration job so we need to cancel it by\n             * calling Confirm while making sure it doesn't overwrite the error\n             */\n            orig_err = virSaveLastError();\n            goto confirm;\n        } else {\n            goto done;\n        }\n    }\n\n    /* Did domainMigratePrepare3 change URI? */\n    if (uri_out) {\n        uri = uri_out;\n        if (useParams &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_URI,\n                                        uri_out) < 0) {\n            cancelled = 1;\n            orig_err = virSaveLastError();\n            goto finish;\n        }\n    } else if (!uri &&\n               virTypedParamsGetString(params, nparams,\n                                       VIR_MIGRATE_PARAM_URI, &uri) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare3 did not set uri\"));\n        cancelled = 1;\n        orig_err = virSaveLastError();\n        goto finish;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        VIR_DEBUG(\"Offline migration, skipping Perform phase\");\n        VIR_FREE(cookieout);\n        cookieoutlen = 0;\n        cancelled = 0;\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete. The src VM should remain\n     * running, but in paused state until the destination can\n     * confirm migration completion.\n     */\n    VIR_DEBUG(\"Perform3 %p uri=%s\", domain->conn, uri);\n    VIR_FREE(cookiein);\n    cookiein = cookieout;\n    cookieinlen = cookieoutlen;\n    cookieout = NULL;\n    cookieoutlen = 0;\n    /* dconnuri not relevant in non-P2P modes, so left NULL here */\n    if (useParams) {\n        ret = domain->conn->driver->domainMigratePerform3Params\n            (domain, NULL, params, nparams, cookiein, cookieinlen,\n             &cookieout, &cookieoutlen, flags | protection);\n    } else {\n        ret = domain->conn->driver->domainMigratePerform3\n            (domain, NULL, cookiein, cookieinlen,\n             &cookieout, &cookieoutlen, NULL,\n             uri, flags | protection, dname, bandwidth);\n    }\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0) {\n        orig_err = virSaveLastError();\n        /* Perform failed so we don't need to call confirm to let source know\n         * about the failure.\n         */\n        notify_source = false;\n    }\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0 ? 1 : 0;\n\n finish:\n    /*\n     * The status code from the source is passed to the destination.\n     * The dest can cleanup if the source indicated it failed to\n     * send all migration data. Returns NULL for ddomain if\n     * the dest was unable to complete migration.\n     */\n    VIR_DEBUG(\"Finish3 %p ret=%d\", dconn, ret);\n    VIR_FREE(cookiein);\n    cookiein = cookieout;\n    cookieinlen = cookieoutlen;\n    cookieout = NULL;\n    cookieoutlen = 0;\n    if (useParams) {\n        if (virTypedParamsGetString(params, nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_NAME,\n                                        domain->name) < 0) {\n            ddomain = NULL;\n        } else {\n            ddomain = dconn->driver->domainMigrateFinish3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags, cancelled);\n        }\n    } else {\n        dname = dname ? dname : domain->name;\n        ddomain = dconn->driver->domainMigrateFinish3\n            (dconn, dname, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             NULL, uri, destflags, cancelled);\n    }\n\n    if (cancelled) {\n        if (ddomain) {\n            VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n        } else {\n            /* If Finish reported a useful error, use it instead of the\n             * original \"migration unexpectedly failed\" error.\n             *\n             * This is ugly but we can't do better with the APIs we have. We\n             * only replace the error if Finish was called with cancelled == 1\n             * and reported a real error (old libvirt would report an error\n             * from RPC instead of MIGRATE_FINISH_OK), which only happens when\n             * the domain died on destination. To further reduce a possibility\n             * of false positives we also check that Perform returned\n             * VIR_ERR_OPERATION_FAILED.\n             */\n            if (orig_err &&\n                orig_err->domain == VIR_FROM_QEMU &&\n                orig_err->code == VIR_ERR_OPERATION_FAILED) {\n                virErrorPtr err = virGetLastError();\n                if (err &&\n                    err->domain == VIR_FROM_QEMU &&\n                    err->code != VIR_ERR_MIGRATE_FINISH_OK) {\n                    virFreeError(orig_err);\n                    orig_err = NULL;\n                }\n            }\n        }\n    }\n\n    /* If ddomain is NULL, then we were unable to start\n     * the guest on the target, and must restart on the\n     * source. There is a small chance that the ddomain\n     * is NULL due to an RPC failure, in which case\n     * ddomain could in fact be running on the dest.\n     * The lock manager plugins should take care of\n     * safety in this scenario.\n     */\n    cancelled = ddomain == NULL ? 1 : 0;\n\n    /* If finish3 set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        orig_err = virSaveLastError();\n\n confirm:\n    /*\n     * If cancelled, then src VM will be restarted, else it will be killed.\n     * Don't do this if migration failed on source and thus it was already\n     * cancelled there.\n     */\n    if (notify_source) {\n        VIR_DEBUG(\"Confirm3 %p ret=%d domain=%p\", domain->conn, ret, domain);\n        VIR_FREE(cookiein);\n        cookiein = cookieout;\n        cookieinlen = cookieoutlen;\n        cookieout = NULL;\n        cookieoutlen = 0;\n        if (useParams) {\n            ret = domain->conn->driver->domainMigrateConfirm3Params\n                (domain, params, nparams, cookiein, cookieinlen,\n                 flags | protection, cancelled);\n        } else {\n            ret = domain->conn->driver->domainMigrateConfirm3\n                (domain, cookiein, cookieinlen,\n                 flags | protection, cancelled);\n        }\n        /* If Confirm3 returns -1, there's nothing more we can\n         * do, but fortunately worst case is that there is a\n         * domain left in 'paused' state on source.\n         */\n        if (ret < 0) {\n            VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                     domain->name);\n        }\n    }\n\n done:\n    if (orig_err) {\n        virSetError(orig_err);\n        virFreeError(orig_err);\n    }\n    VIR_FREE(dom_xml);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookiein);\n    VIR_FREE(cookieout);\n    virTypedParamsFree(params, nparams);\n    return ddomain;\n}\n\n\nstatic virDomainPtr\nvirDomainMigrateVersion3(virDomainPtr domain,\n                         virConnectPtr dconn,\n                         const char *xmlin,\n                         unsigned long flags,\n                         const char *dname,\n                         const char *uri,\n                         unsigned long bandwidth)\n{\n    return virDomainMigrateVersion3Full(domain, dconn, xmlin, dname, uri,\n                                        bandwidth, NULL, 0, false, flags);\n}\n\n\nstatic virDomainPtr\nvirDomainMigrateVersion3Params(virDomainPtr domain,\n                               virConnectPtr dconn,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               unsigned int flags)\n{\n    return virDomainMigrateVersion3Full(domain, dconn, NULL, NULL, NULL, 0,\n                                        params, nparams, true, flags);\n}\n\n\nstatic int\nvirDomainMigrateCheckNotLocal(const char *dconnuri)\n{\n    virURIPtr tempuri = NULL;\n    int ret = -1;\n\n    if (!(tempuri = virURIParse(dconnuri)))\n        goto cleanup;\n    if (!tempuri->server || STRPREFIX(tempuri->server, \"localhost\")) {\n        virReportInvalidArg(dconnuri, \"%s\",\n                            _(\"Attempt to migrate guest to the same host\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virURIFree(tempuri);\n    return ret;\n}\n\n\nstatic int\nvirDomainMigrateUnmanagedProto2(virDomainPtr domain,\n                                const char *dconnuri,\n                                virTypedParameterPtr params,\n                                int nparams,\n                                unsigned int flags)\n{\n    /* uri parameter is added for direct case */\n    const char *compatParams[] = { VIR_MIGRATE_PARAM_DEST_NAME,\n                                   VIR_MIGRATE_PARAM_BANDWIDTH,\n                                   VIR_MIGRATE_PARAM_URI };\n    const char *uri = NULL;\n    const char *miguri = NULL;\n    const char *dname = NULL;\n    unsigned long long bandwidth = 0;\n\n    if (!virTypedParamsCheck(params, nparams, compatParams,\n                             ARRAY_CARDINALITY(compatParams))) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Some parameters are not supported by migration \"\n                         \"protocol 2\"));\n        return -1;\n    }\n\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_URI, &miguri) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, &dname) < 0 ||\n        virTypedParamsGetULLong(params, nparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, &bandwidth) < 0) {\n        return -1;\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (miguri) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to override peer2peer migration URI\"));\n            return -1;\n        }\n        uri = dconnuri;\n    } else {\n        uri = miguri;\n    }\n\n    return domain->conn->driver->domainMigratePerform\n            (domain, NULL, 0, uri, flags, dname, bandwidth);\n}\n\n\nstatic int\nvirDomainMigrateUnmanagedProto3(virDomainPtr domain,\n                                const char *dconnuri,\n                                virTypedParameterPtr params,\n                                int nparams,\n                                unsigned int flags)\n{\n    const char *compatParams[] = { VIR_MIGRATE_PARAM_URI,\n                                   VIR_MIGRATE_PARAM_DEST_NAME,\n                                   VIR_MIGRATE_PARAM_DEST_XML,\n                                   VIR_MIGRATE_PARAM_BANDWIDTH };\n    const char *miguri = NULL;\n    const char *dname = NULL;\n    const char *xmlin = NULL;\n    unsigned long long bandwidth = 0;\n\n    if (!virTypedParamsCheck(params, nparams, compatParams,\n                             ARRAY_CARDINALITY(compatParams))) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Some parameters are not supported by migration \"\n                         \"protocol 3\"));\n        return -1;\n    }\n\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_URI, &miguri) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, &dname) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, &xmlin) < 0 ||\n        virTypedParamsGetULLong(params, nparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, &bandwidth) < 0) {\n        return -1;\n    }\n\n    return domain->conn->driver->domainMigratePerform3\n            (domain, xmlin, NULL, 0, NULL, NULL, dconnuri,\n             miguri, flags, dname, bandwidth);\n}\n\n\n/*\n * In normal migration, the libvirt client co-ordinates communication\n * between the 2 libvirtd instances on source & dest hosts.\n *\n * This function encapsulates 2 alternatives to the above case.\n *\n * 1. peer-2-peer migration, the libvirt client only talks to the source\n * libvirtd instance. The source libvirtd then opens its own\n * connection to the destination and co-ordinates migration itself.\n *\n * 2. direct migration, where there is no requirement for a libvirtd instance\n * on the dest host. Eg, XenD can talk direct to XenD, so libvirtd on dest\n * does not need to be involved at all, or even running.\n */\nstatic int\nvirDomainMigrateUnmanagedParams(virDomainPtr domain,\n                                const char *dconnuri,\n                                virTypedParameterPtr params,\n                                int nparams,\n                                unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, params=%p, nparams=%d, flags=%x\",\n                     NULLSTR(dconnuri), params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    if ((flags & VIR_MIGRATE_PEER2PEER) &&\n        virDomainMigrateCheckNotLocal(dconnuri) < 0)\n        return -1;\n\n    if ((flags & VIR_MIGRATE_PEER2PEER) &&\n        VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATION_PARAMS)) {\n        VIR_DEBUG(\"Using migration protocol 3 with extensible parameters\");\n        if (!domain->conn->driver->domainMigratePerform3Params) {\n            virReportUnsupportedError();\n            return -1;\n        }\n        return domain->conn->driver->domainMigratePerform3Params\n                (domain, dconnuri, params, nparams,\n                 NULL, 0, NULL, NULL, flags);\n    } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                        VIR_DRV_FEATURE_MIGRATION_V3)) {\n        VIR_DEBUG(\"Using migration protocol 3\");\n        if (!domain->conn->driver->domainMigratePerform3) {\n            virReportUnsupportedError();\n            return -1;\n        }\n        return virDomainMigrateUnmanagedProto3(domain, dconnuri,\n                                               params, nparams, flags);\n    } else {\n        VIR_DEBUG(\"Using migration protocol 2\");\n        if (!domain->conn->driver->domainMigratePerform) {\n            virReportUnsupportedError();\n            return -1;\n        }\n        return virDomainMigrateUnmanagedProto2(domain, dconnuri,\n                                               params, nparams, flags);\n    }\n}\n\n\nstatic int\nvirDomainMigrateUnmanaged(virDomainPtr domain,\n                          const char *xmlin,\n                          unsigned int flags,\n                          const char *dname,\n                          const char *dconnuri,\n                          const char *miguri,\n                          unsigned long long bandwidth)\n{\n    int ret = -1;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n\n    if (miguri &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_URI, miguri) < 0)\n        goto cleanup;\n    if (dname &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n        goto cleanup;\n    if (xmlin &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, xmlin) < 0)\n        goto cleanup;\n    if (virTypedParamsAddULLong(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, bandwidth) < 0)\n        goto cleanup;\n\n    ret = virDomainMigrateUnmanagedParams(domain, dconnuri, params,\n                                          nparams, flags);\n\n cleanup:\n    virTypedParamsFree(params, nparams);\n\n    return ret;\n}\n\n\n/**\n * virDomainMigrate:\n * @domain: a domain object\n * @dconn: destination host (a connection object)\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dname: (optional) rename domain to this at destination\n * @uri: (optional) dest hostname/URI as seen from the source host\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by dconn (a connection to the destination host).\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n * Applications using the VIR_MIGRATE_PEER2PEER flag will probably\n * prefer to invoke virDomainMigrateToURI, avoiding the need to\n * open connection to the destination host themselves.\n *\n * If a hypervisor supports renaming domains during migration,\n * then you may set the dname parameter to the new name (otherwise\n * it keeps the same name).  If this is not supported by the\n * hypervisor, dname must be NULL or else you will get an error.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the uri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt. If\n * omitted, the dconn connection object will be queried for its\n * current URI.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, the URI parameter\n * takes a hypervisor specific format. The hypervisor capabilities\n * XML includes details of the support URI schemes. If omitted\n * the dconn will be asked for a default URI.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * In either case it is typically only necessary to specify a\n * URI if the destination host has multiple interfaces and a\n * specific interface is required to transmit migration data.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * virDomainFree should be used to free the resources after the\n * returned domain object is no longer needed.\n *\n * Returns the new domain object if the migration was successful,\n *   or NULL in case of error.  Note that the new domain object\n *   exists in the scope of the destination connection (dconn).\n */\nvirDomainPtr\nvirDomainMigrate(virDomainPtr domain,\n                 virConnectPtr dconn,\n                 unsigned long flags,\n                 const char *dname,\n                 const char *uri,\n                 unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, NULL);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    /* Now checkout the destination */\n    virCheckConnectGoto(dconn, error);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MIGRATE_NON_SHARED_DISK,\n                             VIR_MIGRATE_NON_SHARED_INC,\n                             error);\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the source host\"));\n            goto error;\n        }\n        if (!VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the destination host\"));\n            goto error;\n        }\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_P2P)) {\n            char *dstURI = NULL;\n            if (uri == NULL) {\n                dstURI = virConnectGetURI(dconn);\n                if (!dstURI)\n                    return NULL;\n            }\n\n            VIR_DEBUG(\"Using peer2peer migration\");\n            if (virDomainMigrateUnmanaged(domain, NULL, flags, dname,\n                                          uri ? uri : dstURI, NULL, bandwidth) < 0) {\n                VIR_FREE(dstURI);\n                goto error;\n            }\n            VIR_FREE(dstURI);\n\n            ddomain = virDomainLookupByName(dconn, dname ? dname : domain->name);\n        } else {\n            /* This driver does not support peer to peer migration */\n            virReportUnsupportedError();\n            goto error;\n        }\n    } else {\n        /* Change protection requires support only on source side, and\n         * is only needed in v3 migration, which automatically re-adds\n         * the flag for just the source side.  We mask it out for\n         * non-peer2peer to allow migration from newer source to an\n         * older destination that rejects the flag.  */\n        if (flags & VIR_MIGRATE_CHANGE_PROTECTION &&\n            !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"cannot enforce change protection\"));\n            goto error;\n        }\n        flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot perform tunnelled migration without using peer2peer flag\"));\n            goto error;\n        }\n\n        /* Check that migration is supported by both drivers. */\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3) &&\n            VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3)) {\n            VIR_DEBUG(\"Using migration protocol 3\");\n            ddomain = virDomainMigrateVersion3(domain, dconn, NULL,\n                                               flags, dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V2) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                          VIR_DRV_FEATURE_MIGRATION_V2)) {\n            VIR_DEBUG(\"Using migration protocol 2\");\n            ddomain = virDomainMigrateVersion2(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1)) {\n            VIR_DEBUG(\"Using migration protocol 1\");\n            ddomain = virDomainMigrateVersion1(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else {\n            /* This driver does not support any migration method */\n            virReportUnsupportedError();\n            goto error;\n        }\n    }\n\n    if (ddomain == NULL)\n        goto error;\n\n    return ddomain;\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainMigrate2:\n * @domain: a domain object\n * @dconn: destination host (a connection object)\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dxml: (optional) XML config for launching guest on target\n * @dname: (optional) rename domain to this at destination\n * @uri: (optional) dest hostname/URI as seen from the source host\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by dconn (a connection to the destination host).\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n * Applications using the VIR_MIGRATE_PEER2PEER flag will probably\n * prefer to invoke virDomainMigrateToURI, avoiding the need to\n * open connection to the destination host themselves.\n *\n * If a hypervisor supports renaming domains during migration,\n * then you may set the dname parameter to the new name (otherwise\n * it keeps the same name).  If this is not supported by the\n * hypervisor, dname must be NULL or else you will get an error.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the uri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt. If\n * omitted, the dconn connection object will be queried for its\n * current URI.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, the URI parameter\n * takes a hypervisor specific format. The hypervisor capabilities\n * XML includes details of the support URI schemes. If omitted\n * the dconn will be asked for a default URI.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * In either case it is typically only necessary to specify a\n * URI if the destination host has multiple interfaces and a\n * specific interface is required to transmit migration data.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * If the hypervisor supports it, @dxml can be used to alter\n * host-specific portions of the domain XML that will be used on\n * the destination.  For example, it is possible to alter the\n * backing filename that is associated with a disk device, in order\n * to account for naming differences between source and destination\n * in accessing the underlying storage.  The migration will fail\n * if @dxml would cause any guest-visible changes.  Pass NULL\n * if no changes are needed to the XML between source and destination.\n * @dxml cannot be used to rename the domain during migration (use\n * @dname for that purpose).  Domain name in @dxml must match the\n * original domain name.\n *\n * virDomainFree should be used to free the resources after the\n * returned domain object is no longer needed.\n *\n * Returns the new domain object if the migration was successful,\n *   or NULL in case of error.  Note that the new domain object\n *   exists in the scope of the destination connection (dconn).\n */\nvirDomainPtr\nvirDomainMigrate2(virDomainPtr domain,\n                  virConnectPtr dconn,\n                  const char *dxml,\n                  unsigned long flags,\n                  const char *dname,\n                  const char *uri,\n                  unsigned long bandwidth)\n{\n    virDomainPtr ddomain = NULL;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"dconn=%p, flags=%lx, dname=%s, uri=%s, bandwidth=%lu\",\n                     dconn, flags, NULLSTR(dname), NULLSTR(uri), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, NULL);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    /* Now checkout the destination */\n    virCheckConnectGoto(dconn, error);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MIGRATE_NON_SHARED_DISK,\n                             VIR_MIGRATE_NON_SHARED_INC,\n                             error);\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the source host\"));\n            goto error;\n        }\n        if (!VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the destination host\"));\n            goto error;\n        }\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_P2P)) {\n            char *dstURI = virConnectGetURI(dconn);\n            if (!dstURI)\n                return NULL;\n\n            VIR_DEBUG(\"Using peer2peer migration\");\n            if (virDomainMigrateUnmanaged(domain, dxml, flags, dname,\n                                          dstURI, uri, bandwidth) < 0) {\n                VIR_FREE(dstURI);\n                goto error;\n            }\n            VIR_FREE(dstURI);\n\n            ddomain = virDomainLookupByName(dconn, dname ? dname : domain->name);\n        } else {\n            /* This driver does not support peer to peer migration */\n            virReportUnsupportedError();\n            goto error;\n        }\n    } else {\n        /* Change protection requires support only on source side, and\n         * is only needed in v3 migration, which automatically re-adds\n         * the flag for just the source side.  We mask it out for\n         * non-peer2peer to allow migration from newer source to an\n         * older destination that rejects the flag.  */\n        if (flags & VIR_MIGRATE_CHANGE_PROTECTION &&\n            !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"cannot enforce change protection\"));\n            goto error;\n        }\n        flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot perform tunnelled migration without using peer2peer flag\"));\n            goto error;\n        }\n\n        /* Check that migration is supported by both drivers. */\n        if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3) &&\n            VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                     VIR_DRV_FEATURE_MIGRATION_V3)) {\n            VIR_DEBUG(\"Using migration protocol 3\");\n            ddomain = virDomainMigrateVersion3(domain, dconn, dxml,\n                                               flags, dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V2) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                          VIR_DRV_FEATURE_MIGRATION_V2)) {\n            VIR_DEBUG(\"Using migration protocol 2\");\n            if (dxml) {\n                virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                               _(\"Unable to change target guest XML during migration\"));\n                goto error;\n            }\n            ddomain = virDomainMigrateVersion2(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1) &&\n                   VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                            VIR_DRV_FEATURE_MIGRATION_V1)) {\n            VIR_DEBUG(\"Using migration protocol 1\");\n            if (dxml) {\n                virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                               _(\"Unable to change target guest XML during migration\"));\n                goto error;\n            }\n            ddomain = virDomainMigrateVersion1(domain, dconn, flags,\n                                               dname, uri, bandwidth);\n        } else {\n            /* This driver does not support any migration method */\n            virReportUnsupportedError();\n            goto error;\n        }\n    }\n\n    if (ddomain == NULL)\n        goto error;\n\n    return ddomain;\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainMigrate3:\n * @domain: a domain object\n * @dconn: destination host (a connection object)\n * @params: (optional) migration parameters\n * @nparams: (optional) number of migration parameters in @params\n * @flags: bitwise-OR of virDomainMigrateFlags\n *\n * Migrate the domain object from its current host to the destination host\n * given by dconn (a connection to the destination host).\n *\n * See virDomainMigrateFlags documentation for description of individual flags.\n *\n * VIR_MIGRATE_TUNNELLED and VIR_MIGRATE_PEER2PEER are not supported by this\n * API, use virDomainMigrateToURI3 instead.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * virDomainFree should be used to free the resources after the\n * returned domain object is no longer needed.\n *\n * Returns the new domain object if the migration was successful,\n *   or NULL in case of error.  Note that the new domain object\n *   exists in the scope of the destination connection (dconn).\n */\nvirDomainPtr\nvirDomainMigrate3(virDomainPtr domain,\n                  virConnectPtr dconn,\n                  virTypedParameterPtr params,\n                  unsigned int nparams,\n                  unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    const char *compatParams[] = { VIR_MIGRATE_PARAM_URI,\n                                   VIR_MIGRATE_PARAM_DEST_NAME,\n                                   VIR_MIGRATE_PARAM_DEST_XML,\n                                   VIR_MIGRATE_PARAM_BANDWIDTH };\n    const char *uri = NULL;\n    const char *dname = NULL;\n    const char *dxml = NULL;\n    unsigned long long bandwidth = 0;\n\n    VIR_DOMAIN_DEBUG(domain, \"dconn=%p, params=%p, nparms=%u flags=%x\",\n                     dconn, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, NULL);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    /* Now checkout the destination */\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MIGRATE_NON_SHARED_DISK,\n                             VIR_MIGRATE_NON_SHARED_INC,\n                             error);\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        virReportInvalidArg(flags, \"%s\",\n                            _(\"use virDomainMigrateToURI3 for peer-to-peer \"\n                              \"migration\"));\n        goto error;\n    }\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        virReportInvalidArg(flags, \"%s\",\n                            _(\"cannot perform tunnelled migration \"\n                              \"without using peer2peer flag\"));\n        goto error;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the source host\"));\n            goto error;\n        }\n        if (!VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"offline migration is not supported by \"\n                             \"the destination host\"));\n            goto error;\n        }\n    }\n\n    /* Change protection requires support only on source side, and\n     * is only needed in v3 migration, which automatically re-adds\n     * the flag for just the source side.  We mask it out to allow\n     * migration from newer source to an older destination that\n     * rejects the flag.  */\n    if (flags & VIR_MIGRATE_CHANGE_PROTECTION &&\n        !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                  VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"cannot enforce change protection\"));\n        goto error;\n    }\n    flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n\n    /* Prefer extensible API but fall back to older migration APIs if params\n     * only contains parameters which were supported by the older API. */\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATION_PARAMS) &&\n        VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                 VIR_DRV_FEATURE_MIGRATION_PARAMS)) {\n        VIR_DEBUG(\"Using migration protocol 3 with extensible parameters\");\n        ddomain = virDomainMigrateVersion3Params(domain, dconn, params,\n                                                 nparams, flags);\n        goto done;\n    }\n\n    if (!virTypedParamsCheck(params, nparams, compatParams,\n                             ARRAY_CARDINALITY(compatParams))) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Migration APIs with extensible parameters are not \"\n                         \"supported but extended parameters were passed\"));\n        goto error;\n    }\n\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_URI, &uri) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, &dname) < 0 ||\n        virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, &dxml) < 0 ||\n        virTypedParamsGetULLong(params, nparams,\n                                VIR_MIGRATE_PARAM_BANDWIDTH, &bandwidth) < 0) {\n        goto error;\n    }\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_MIGRATION_V3) &&\n        VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                 VIR_DRV_FEATURE_MIGRATION_V3)) {\n        VIR_DEBUG(\"Using migration protocol 3\");\n        ddomain = virDomainMigrateVersion3(domain, dconn, dxml, flags,\n                                           dname, uri, bandwidth);\n    } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                        VIR_DRV_FEATURE_MIGRATION_V2) &&\n               VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                      VIR_DRV_FEATURE_MIGRATION_V2)) {\n        VIR_DEBUG(\"Using migration protocol 2\");\n        if (dxml) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"Unable to change target guest XML during \"\n                             \"migration\"));\n            goto error;\n        }\n        ddomain = virDomainMigrateVersion2(domain, dconn, flags,\n                                           dname, uri, bandwidth);\n    } else if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                        VIR_DRV_FEATURE_MIGRATION_V1) &&\n               VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                        VIR_DRV_FEATURE_MIGRATION_V1)) {\n        VIR_DEBUG(\"Using migration protocol 1\");\n        if (dxml) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"Unable to change target guest XML during \"\n                             \"migration\"));\n            goto error;\n        }\n        ddomain = virDomainMigrateVersion1(domain, dconn, flags,\n                                           dname, uri, bandwidth);\n    } else {\n        /* This driver does not support any migration method */\n        virReportUnsupportedError();\n        goto error;\n    }\n\n done:\n    if (ddomain == NULL)\n        goto error;\n\n    return ddomain;\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\nstatic\nint virDomainMigrateUnmanagedCheckCompat(virDomainPtr domain,\n                                         unsigned int flags)\n{\n    VIR_EXCLUSIVE_FLAGS_RET(VIR_MIGRATE_NON_SHARED_DISK,\n                            VIR_MIGRATE_NON_SHARED_INC,\n                            -1);\n\n    if (flags & VIR_MIGRATE_OFFLINE &&\n        !VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                  VIR_DRV_FEATURE_MIGRATION_OFFLINE)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"offline migration is not supported by \"\n                         \"the source host\"));\n        return -1;\n    }\n\n    if (flags & VIR_MIGRATE_PEER2PEER) {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_P2P)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"p2p migration is not supported by \"\n                             \"the source host\"));\n            return -1;\n        }\n    } else {\n        if (!VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                      VIR_DRV_FEATURE_MIGRATION_DIRECT)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                           _(\"direct migration is not supported by \"\n                             \"the source host\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\n/**\n * virDomainMigrateToURI:\n * @domain: a domain object\n * @duri: mandatory URI for the destination host\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dname: (optional) rename domain to this at destination\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by duri.\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, the duri parameter\n * takes a hypervisor specific format. The uri_transports element of the\n * hypervisor capabilities XML includes details of the supported URI\n * schemes. Not all hypervisors will support this mode of migration, so\n * if the VIR_MIGRATE_PEER2PEER flag is not set, then it may be necessary\n * to use the alternative virDomainMigrate API providing and explicit\n * virConnectPtr for the destination host.\n *\n * If the VIR_MIGRATE_PEER2PEER flag IS set, the duri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt.\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * If a hypervisor supports renaming domains during migration,\n * the dname parameter specifies the new name for the domain.\n * Setting dname to NULL keeps the domain name the same.  If domain\n * renaming is not supported by the hypervisor, dname must be NULL or\n * else an error will be returned.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * Returns 0 if the migration succeeded, -1 upon error.\n */\nint\nvirDomainMigrateToURI(virDomainPtr domain,\n                      const char *duri,\n                      unsigned long flags,\n                      const char *dname,\n                      unsigned long bandwidth)\n{\n    const char *dconnuri = NULL;\n    const char *miguri = NULL;\n\n    VIR_DOMAIN_DEBUG(domain, \"duri=%p, flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(duri), flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonNullArgGoto(duri, error);\n\n    if (virDomainMigrateUnmanagedCheckCompat(domain, flags) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_PEER2PEER)\n        dconnuri = duri;\n    else\n        miguri = duri;\n\n    if (virDomainMigrateUnmanaged(domain, NULL, flags,\n                                  dname, dconnuri, miguri, bandwidth) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateToURI2:\n * @domain: a domain object\n * @dconnuri: (optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER\n * @miguri: (optional) URI for invoking the migration, not if @flags includs VIR_MIGRATE_TUNNELLED\n * @dxml: (optional) XML config for launching guest on target\n * @flags: bitwise-OR of virDomainMigrateFlags\n * @dname: (optional) rename domain to this at destination\n * @bandwidth: (optional) specify migration bandwidth limit in MiB/s\n *\n * Migrate the domain object from its current host to the destination\n * host given by duri.\n *\n * Flags may be one of more of the following:\n *   VIR_MIGRATE_LIVE      Do not pause the VM during migration\n *   VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts\n *   VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel\n *   VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain\n *                            on the destination host.\n *   VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the\n *                               domain on the source host.\n *   VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.\n *   VIR_MIGRATE_NON_SHARED_DISK Migration with non-shared storage with full\n *                               disk copy\n *   VIR_MIGRATE_NON_SHARED_INC  Migration with non-shared storage with\n *                               incremental disk copy\n *   VIR_MIGRATE_CHANGE_PROTECTION Protect against domain configuration\n *                                 changes during the migration process (set\n *                                 automatically when supported).\n *   VIR_MIGRATE_UNSAFE    Force migration even if it is considered unsafe.\n *   VIR_MIGRATE_OFFLINE Migrate offline\n *\n * The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the @dconnuri parameter\n * must be a valid libvirt connection URI, by which the source\n * libvirt driver can connect to the destination libvirt. If the\n * VIR_MIGRATE_PEER2PEER flag is NOT set, then @dconnuri must be\n * NULL.\n *\n * If the VIR_MIGRATE_TUNNELLED flag is NOT set, then the @miguri\n * parameter allows specification of a URI to use to initiate the\n * VM migration. It takes a hypervisor specific format. The uri_transports\n * element of the hypervisor capabilities XML includes details of the\n * supported URI schemes.\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n * As of 1.2.11 disks of some types ('file' and 'volume') are\n * precreated automatically, if there's a pool defined on the\n * destination for the disk path.\n *\n * If a hypervisor supports changing the configuration of the guest\n * during migration, the @dxml parameter specifies the new config\n * for the guest. The configuration must include an identical set\n * of virtual devices, to ensure a stable guest ABI across migration.\n * Only parameters related to host side configuration can be\n * changed in the XML. Hypervisors will validate this and refuse to\n * allow migration if the provided XML would cause a change in the\n * guest ABI,\n *\n * If a hypervisor supports renaming domains during migration,\n * the dname parameter specifies the new name for the domain.\n * Setting dname to NULL keeps the domain name the same.  If domain\n * renaming is not supported by the hypervisor, dname must be NULL or\n * else an error will be returned.\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter.  If set to 0,\n * libvirt will choose a suitable default.  Some hypervisors do\n * not support this feature and will return an error if bandwidth\n * is not 0.\n *\n * To see which features are supported by the current hypervisor,\n * see virConnectGetCapabilities, /capabilities/host/migration_features.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * Returns 0 if the migration succeeded, -1 upon error.\n */\nint\nvirDomainMigrateToURI2(virDomainPtr domain,\n                       const char *dconnuri,\n                       const char *miguri,\n                       const char *dxml,\n                       unsigned long flags,\n                       const char *dname,\n                       unsigned long bandwidth)\n{\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, miguri=%s, dxml=%s, \"\n                     \"flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(dconnuri), NULLSTR(miguri), NULLSTR(dxml),\n                     flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    if (virDomainMigrateUnmanagedCheckCompat(domain, flags) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_PEER2PEER)\n        virCheckNonNullArgGoto(dconnuri, error);\n    else\n        dconnuri = NULL;\n\n    if (virDomainMigrateUnmanaged(domain, dxml, flags,\n                                  dname, dconnuri, miguri, bandwidth) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateToURI3:\n * @domain: a domain object\n * @dconnuri: (optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER\n * @params: (optional) migration parameters\n * @nparams: (optional) number of migration parameters in @params\n * @flags: bitwise-OR of virDomainMigrateFlags\n *\n * Migrate the domain object from its current host to the destination host\n * given by URI.\n *\n * See virDomainMigrateFlags documentation for description of individual flags.\n *\n * The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is set, the @dconnuri parameter must be a\n * valid libvirt connection URI, by which the source libvirt daemon can connect\n * to the destination libvirt.\n *\n * If the VIR_MIGRATE_PEER2PEER flag is NOT set, then @dconnuri must be NULL\n * and VIR_MIGRATE_PARAM_URI migration parameter must be filled in with\n * hypervisor specific URI used to initiate the migration. This is called\n * \"direct\" migration.\n *\n * VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.\n *\n * If you want to copy non-shared storage within migration you\n * can use either VIR_MIGRATE_NON_SHARED_DISK or\n * VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.\n *\n * There are many limitations on migration imposed by the underlying\n * technology - for example it may not be possible to migrate between\n * different processors even with the same architecture, or between\n * different types of hypervisor.\n *\n * Returns 0 if the migration succeeded, -1 upon error.\n */\nint\nvirDomainMigrateToURI3(virDomainPtr domain,\n                       const char *dconnuri,\n                       virTypedParameterPtr params,\n                       unsigned int nparams,\n                       unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, params=%p, nparms=%u flags=%x\",\n                     NULLSTR(dconnuri), params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    /* First checkout the source */\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    if (virDomainMigrateUnmanagedCheckCompat(domain, flags) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_PEER2PEER)\n        virCheckNonNullArgGoto(dconnuri, error);\n    else\n        dconnuri = NULL;\n\n    if (virDomainMigrateUnmanagedParams(domain, dconnuri,\n                                        params, nparams, flags) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare(virConnectPtr dconn,\n                        char **cookie,\n                        int *cookielen,\n                        const char *uri_in,\n                        char **uri_out,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long bandwidth)\n{\n    VIR_DEBUG(\"dconn=%p, cookie=%p, cookielen=%p, uri_in=%s, uri_out=%p, \"\n              \"flags=%lx, dname=%s, bandwidth=%lu\", dconn, cookie, cookielen,\n              NULLSTR(uri_in), uri_out, flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare(dconn, cookie, cookielen,\n                                                  uri_in, uri_out,\n                                                  flags, dname, bandwidth);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePerform(virDomainPtr domain,\n                        const char *cookie,\n                        int cookielen,\n                        const char *uri,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long bandwidth)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cookie=%p, cookielen=%d, uri=%s, flags=%lx, \"\n                     \"dname=%s, bandwidth=%lu\", cookie, cookielen, uri, flags,\n                     NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigratePerform) {\n        int ret;\n        ret = conn->driver->domainMigratePerform(domain, cookie, cookielen,\n                                                 uri,\n                                                 flags, dname, bandwidth);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish(virConnectPtr dconn,\n                       const char *dname,\n                       const char *cookie,\n                       int cookielen,\n                       const char *uri,\n                       unsigned long flags)\n{\n    VIR_DEBUG(\"dconn=%p, dname=%s, cookie=%p, cookielen=%d, uri=%s, \"\n              \"flags=%lx\", dconn, NULLSTR(dname), cookie, cookielen,\n              NULLSTR(uri), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish(dconn, dname,\n                                                 cookie, cookielen,\n                                                 uri, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare2(virConnectPtr dconn,\n                         char **cookie,\n                         int *cookielen,\n                         const char *uri_in,\n                         char **uri_out,\n                         unsigned long flags,\n                         const char *dname,\n                         unsigned long bandwidth,\n                         const char *dom_xml)\n{\n    VIR_DEBUG(\"dconn=%p, cookie=%p, cookielen=%p, uri_in=%s, uri_out=%p,\"\n              \"flags=%lx, dname=%s, bandwidth=%lu, dom_xml=%s\", dconn,\n              cookie, cookielen, NULLSTR(uri_in), uri_out, flags, NULLSTR(dname),\n              bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare2) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare2(dconn, cookie, cookielen,\n                                                   uri_in, uri_out,\n                                                   flags, dname, bandwidth,\n                                                   dom_xml);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish2(virConnectPtr dconn,\n                        const char *dname,\n                        const char *cookie,\n                        int cookielen,\n                        const char *uri,\n                        unsigned long flags,\n                        int retcode)\n{\n    VIR_DEBUG(\"dconn=%p, dname=%s, cookie=%p, cookielen=%d, uri=%s, \"\n              \"flags=%lx, retcode=%d\", dconn, NULLSTR(dname), cookie,\n              cookielen, NULLSTR(uri), flags, retcode);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish2) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish2(dconn, dname,\n                                                  cookie, cookielen,\n                                                  uri, flags,\n                                                  retcode);\n        if (!ret && !retcode)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepareTunnel(virConnectPtr conn,\n                              virStreamPtr st,\n                              unsigned long flags,\n                              const char *dname,\n                              unsigned long bandwidth,\n                              const char *dom_xml)\n{\n    VIR_DEBUG(\"conn=%p, stream=%p, flags=%lx, dname=%s, \"\n              \"bandwidth=%lu, dom_xml=%s\", conn, st, flags,\n              NULLSTR(dname), bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(conn, \"%s\",\n                            _(\"conn must match stream connection\"));\n        goto error;\n    }\n\n    if (conn->driver->domainMigratePrepareTunnel) {\n        int rv = conn->driver->domainMigratePrepareTunnel(conn, st,\n                                                          flags, dname,\n                                                          bandwidth, dom_xml);\n        if (rv < 0)\n            goto error;\n        return rv;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nchar *\nvirDomainMigrateBegin3(virDomainPtr domain,\n                       const char *xmlin,\n                       char **cookieout,\n                       int *cookieoutlen,\n                       unsigned long flags,\n                       const char *dname,\n                       unsigned long bandwidth)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xmlin=%s cookieout=%p, cookieoutlen=%p, \"\n                     \"flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(xmlin), cookieout, cookieoutlen, flags,\n                     NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateBegin3) {\n        char *xml;\n        xml = conn->driver->domainMigrateBegin3(domain, xmlin,\n                                                cookieout, cookieoutlen,\n                                                flags, dname, bandwidth);\n        VIR_DEBUG(\"xml %s\", NULLSTR(xml));\n        if (!xml)\n            goto error;\n        return xml;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare3(virConnectPtr dconn,\n                         const char *cookiein,\n                         int cookieinlen,\n                         char **cookieout,\n                         int *cookieoutlen,\n                         const char *uri_in,\n                         char **uri_out,\n                         unsigned long flags,\n                         const char *dname,\n                         unsigned long bandwidth,\n                         const char *dom_xml)\n{\n    VIR_DEBUG(\"dconn=%p, cookiein=%p, cookieinlen=%d, cookieout=%p, \"\n              \"cookieoutlen=%p, uri_in=%s, uri_out=%p, flags=%lx, dname=%s, \"\n              \"bandwidth=%lu, dom_xml=%s\",\n              dconn, cookiein, cookieinlen, cookieout, cookieoutlen, NULLSTR(uri_in),\n              uri_out, flags, NULLSTR(dname), bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare3) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare3(dconn,\n                                                   cookiein, cookieinlen,\n                                                   cookieout, cookieoutlen,\n                                                   uri_in, uri_out,\n                                                   flags, dname, bandwidth,\n                                                   dom_xml);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepareTunnel3(virConnectPtr conn,\n                               virStreamPtr st,\n                               const char *cookiein,\n                               int cookieinlen,\n                               char **cookieout,\n                               int *cookieoutlen,\n                               unsigned long flags,\n                               const char *dname,\n                               unsigned long bandwidth,\n                               const char *dom_xml)\n{\n    VIR_DEBUG(\"conn=%p, stream=%p, cookiein=%p, cookieinlen=%d, cookieout=%p, \"\n              \"cookieoutlen=%p, flags=%lx, dname=%s, bandwidth=%lu, \"\n              \"dom_xml=%s\",\n              conn, st, cookiein, cookieinlen, cookieout, cookieoutlen, flags,\n              NULLSTR(dname), bandwidth, NULLSTR(dom_xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(conn, \"%s\",\n                            _(\"conn must match stream connection\"));\n        goto error;\n    }\n\n    if (conn->driver->domainMigratePrepareTunnel3) {\n        int rv = conn->driver->domainMigratePrepareTunnel3(conn, st,\n                                                           cookiein, cookieinlen,\n                                                           cookieout, cookieoutlen,\n                                                           flags, dname,\n                                                           bandwidth, dom_xml);\n        if (rv < 0)\n            goto error;\n        return rv;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePerform3(virDomainPtr domain,\n                         const char *xmlin,\n                         const char *cookiein,\n                         int cookieinlen,\n                         char **cookieout,\n                         int *cookieoutlen,\n                         const char *dconnuri,\n                         const char *uri,\n                         unsigned long flags,\n                         const char *dname,\n                         unsigned long bandwidth)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xmlin=%s cookiein=%p, cookieinlen=%d, \"\n                     \"cookieout=%p, cookieoutlen=%p, dconnuri=%s, \"\n                     \"uri=%s, flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(xmlin), cookiein, cookieinlen,\n                     cookieout, cookieoutlen, NULLSTR(dconnuri),\n                     NULLSTR(uri), flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigratePerform3) {\n        int ret;\n        ret = conn->driver->domainMigratePerform3(domain, xmlin,\n                                                  cookiein, cookieinlen,\n                                                  cookieout, cookieoutlen,\n                                                  dconnuri, uri,\n                                                  flags, dname, bandwidth);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish3(virConnectPtr dconn,\n                        const char *dname,\n                        const char *cookiein,\n                        int cookieinlen,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        const char *dconnuri,\n                        const char *uri,\n                        unsigned long flags,\n                        int cancelled)\n{\n    VIR_DEBUG(\"dconn=%p, dname=%s, cookiein=%p, cookieinlen=%d, cookieout=%p,\"\n              \"cookieoutlen=%p, dconnuri=%s, uri=%s, flags=%lx, retcode=%d\",\n              dconn, NULLSTR(dname), cookiein, cookieinlen, cookieout,\n              cookieoutlen, NULLSTR(dconnuri), NULLSTR(uri), flags, cancelled);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish3) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish3(dconn, dname,\n                                                  cookiein, cookieinlen,\n                                                  cookieout, cookieoutlen,\n                                                  dconnuri, uri, flags,\n                                                  cancelled);\n        if (!ret && !cancelled)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigrateConfirm3(virDomainPtr domain,\n                         const char *cookiein,\n                         int cookieinlen,\n                         unsigned long flags,\n                         int cancelled)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"cookiein=%p, cookieinlen=%d, flags=%lx, cancelled=%d\",\n                     cookiein, cookieinlen, flags, cancelled);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateConfirm3) {\n        int ret;\n        ret = conn->driver->domainMigrateConfirm3(domain,\n                                                  cookiein, cookieinlen,\n                                                  flags, cancelled);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nchar *\nvirDomainMigrateBegin3Params(virDomainPtr domain,\n                             virTypedParameterPtr params,\n                             int nparams,\n                             char **cookieout,\n                             int *cookieoutlen,\n                             unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, \"\n                     \"cookieout=%p, cookieoutlen=%p, flags=%x\",\n                     params, nparams, cookieout, cookieoutlen, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateBegin3Params) {\n        char *xml;\n        xml = conn->driver->domainMigrateBegin3Params(domain, params, nparams,\n                                                      cookieout, cookieoutlen,\n                                                      flags);\n        VIR_DEBUG(\"xml %s\", NULLSTR(xml));\n        if (!xml)\n            goto error;\n        return xml;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepare3Params(virConnectPtr dconn,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               const char *cookiein,\n                               int cookieinlen,\n                               char **cookieout,\n                               int *cookieoutlen,\n                               char **uri_out,\n                               unsigned int flags)\n{\n    VIR_DEBUG(\"dconn=%p, params=%p, nparams=%d, cookiein=%p, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, uri_out=%p, flags=%x\",\n              dconn, params, nparams, cookiein, cookieinlen,\n              cookieout, cookieoutlen, uri_out, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, -1);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigratePrepare3Params) {\n        int ret;\n        ret = dconn->driver->domainMigratePrepare3Params(dconn, params, nparams,\n                                                         cookiein, cookieinlen,\n                                                         cookieout, cookieoutlen,\n                                                         uri_out, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePrepareTunnel3Params(virConnectPtr conn,\n                                     virStreamPtr st,\n                                     virTypedParameterPtr params,\n                                     int nparams,\n                                     const char *cookiein,\n                                     int cookieinlen,\n                                     char **cookieout,\n                                     int *cookieoutlen,\n                                     unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, stream=%p, params=%p, nparams=%d, cookiein=%p, \"\n              \"cookieinlen=%d, cookieout=%p, cookieoutlen=%p, flags=%x\",\n              conn, st, params, nparams, cookiein, cookieinlen,\n              cookieout, cookieoutlen, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(conn, \"%s\",\n                            _(\"conn must match stream connection\"));\n        goto error;\n    }\n\n    if (conn->driver->domainMigratePrepareTunnel3Params) {\n        int rv;\n        rv = conn->driver->domainMigratePrepareTunnel3Params(\n                conn, st, params, nparams, cookiein, cookieinlen,\n                cookieout, cookieoutlen, flags);\n        if (rv < 0)\n            goto error;\n        return rv;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigratePerform3Params(virDomainPtr domain,\n                               const char *dconnuri,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               const char *cookiein,\n                               int cookieinlen,\n                               char **cookieout,\n                               int *cookieoutlen,\n                               unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"dconnuri=%s, params=%p, nparams=%d, cookiein=%p, \"\n                     \"cookieinlen=%d, cookieout=%p, cookieoutlen=%p, flags=%x\",\n                     NULLSTR(dconnuri), params, nparams, cookiein,\n                     cookieinlen, cookieout, cookieoutlen, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigratePerform3Params) {\n        int ret;\n        ret = conn->driver->domainMigratePerform3Params(\n                domain, dconnuri, params, nparams, cookiein, cookieinlen,\n                cookieout, cookieoutlen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nvirDomainPtr\nvirDomainMigrateFinish3Params(virConnectPtr dconn,\n                              virTypedParameterPtr params,\n                              int nparams,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned int flags,\n                              int cancelled)\n{\n    VIR_DEBUG(\"dconn=%p, params=%p, nparams=%d, cookiein=%p, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=%x, cancelled=%d\",\n              dconn, params, nparams, cookiein, cookieinlen, cookieout,\n              cookieoutlen, flags, cancelled);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckConnectReturn(dconn, NULL);\n    virCheckReadOnlyGoto(dconn->flags, error);\n\n    if (dconn->driver->domainMigrateFinish3Params) {\n        virDomainPtr ret;\n        ret = dconn->driver->domainMigrateFinish3Params(\n                dconn, params, nparams, cookiein, cookieinlen,\n                cookieout, cookieoutlen, flags, cancelled);\n        if (!ret && !cancelled)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dconn);\n    return NULL;\n}\n\n\n/*\n * Not for public use.  This function is part of the internal\n * implementation of migration in the remote case.\n */\nint\nvirDomainMigrateConfirm3Params(virDomainPtr domain,\n                               virTypedParameterPtr params,\n                               int nparams,\n                               const char *cookiein,\n                               int cookieinlen,\n                               unsigned int flags,\n                               int cancelled)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, cookiein=%p, \"\n                     \"cookieinlen=%d, flags=%x, cancelled=%d\",\n                     params, nparams, cookiein, cookieinlen, flags, cancelled);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateConfirm3Params) {\n        int ret;\n        ret = conn->driver->domainMigrateConfirm3Params(\n                domain, params, nparams,\n                cookiein, cookieinlen, flags, cancelled);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSchedulerType:\n * @domain: pointer to domain object\n * @nparams: pointer to number of scheduler parameters, can be NULL\n *           (return value)\n *\n * Get the scheduler type and the number of scheduler parameters.\n *\n * Returns NULL in case of error. The caller must free the returned string.\n */\nchar *\nvirDomainGetSchedulerType(virDomainPtr domain, int *nparams)\n{\n    virConnectPtr conn;\n    char *schedtype;\n\n    VIR_DOMAIN_DEBUG(domain, \"nparams=%p\", nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSchedulerType) {\n        schedtype = conn->driver->domainGetSchedulerType(domain, nparams);\n        if (!schedtype)\n            goto error;\n        return schedtype;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainGetSchedulerParameters:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter objects\n *          (return value)\n * @nparams: pointer to number of scheduler parameter objects\n *          (this value should generally be as large as the returned value\n *           nparams of virDomainGetSchedulerType()); input and output\n *\n * Get all scheduler parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.  @nparams cannot be 0.\n *\n * It is hypervisor specific whether this returns the live or\n * persistent state; for more control, use\n * virDomainGetSchedulerParametersFlags().\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int *nparams)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%p\", params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckPositiveArgGoto(*nparams, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSchedulerParameters) {\n        int ret;\n        ret = conn->driver->domainGetSchedulerParameters(domain, params, nparams);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSchedulerParametersFlags:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter object\n *          (return value)\n * @nparams: pointer to number of scheduler parameter\n *          (this value should be same than the returned value\n *           nparams of virDomainGetSchedulerType()); input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all scheduler parameters.  On input, @nparams gives the size of the\n * @params array; on output, @nparams gives how many slots were filled\n * with parameter information, which might be less but will not exceed\n * the input value.  @nparams cannot be 0.\n *\n * The value of @flags can be exactly VIR_DOMAIN_AFFECT_CURRENT,\n * VIR_DOMAIN_AFFECT_LIVE, or VIR_DOMAIN_AFFECT_CONFIG.\n *\n * Here is a sample code snippet:\n *\n *   char *ret = virDomainGetSchedulerType(dom, &nparams);\n *   if (ret && nparams != 0) {\n *       if ((params = malloc(sizeof(*params) * nparams)) == NULL)\n *           goto error;\n *       memset(params, 0, sizeof(*params) * nparams);\n *       if (virDomainGetSchedulerParametersFlags(dom, params, &nparams, 0))\n *           goto error;\n *   }\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int *nparams,\n                                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%p, flags=%x\",\n                     params, nparams, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckPositiveArgGoto(*nparams, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSchedulerParametersFlags) {\n        int ret;\n        ret = conn->driver->domainGetSchedulerParametersFlags(domain, params,\n                                                              nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetSchedulerParameters:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter objects\n * @nparams: number of scheduler parameter objects\n *          (this value can be the same or less than the returned value\n *           nparams of virDomainGetSchedulerType)\n *\n * Change all or a subset or the scheduler parameters.  It is\n * hypervisor-specific whether this sets live, persistent, or both\n * settings; for more control, use\n * virDomainSetSchedulerParametersFlags.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int nparams)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d\", params, nparams);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetSchedulerParameters) {\n        int ret;\n        ret = conn->driver->domainSetSchedulerParameters(domain, params, nparams);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetSchedulerParametersFlags:\n * @domain: pointer to domain object\n * @params: pointer to scheduler parameter objects\n * @nparams: number of scheduler parameter objects\n *          (this value can be the same or less than the returned value\n *           nparams of virDomainGetSchedulerType)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change a subset or all scheduler parameters.  The value of @flags\n * should be either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of\n * values from VIR_DOMAIN_AFFECT_LIVE and\n * VIR_DOMAIN_AFFECT_CURRENT, although hypervisors vary in which\n * flags are supported.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params,\n                                     int nparams,\n                                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"params=%p, nparams=%d, flags=%x\",\n                     params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetSchedulerParametersFlags) {\n        int ret;\n        ret = conn->driver->domainSetSchedulerParametersFlags(domain,\n                                                              params,\n                                                              nparams,\n                                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockStats:\n * @dom: pointer to the domain object\n * @disk: path to the block device, or device shorthand\n * @stats: block device stats (returned)\n * @size: size of stats structure\n *\n * This function returns block device (disk) stats for block\n * devices attached to the domain.\n *\n * The @disk parameter is either the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\"), or (since 0.9.8)\n * an unambiguous source name of the block device (the <source\n * file='...'/> sub-element, such as \"/path/to/image\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk. Some drivers might also\n * accept the empty string for the @disk parameter, and then yield\n * summary stats for the entire domain.\n *\n * Domains may have more than one block device.  To get stats for\n * each you should make multiple calls to this function.\n *\n * Individual fields within the stats structure may be returned\n * as -1, which indicates that the hypervisor does not support\n * that particular statistic.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainBlockStats(virDomainPtr dom, const char *disk,\n                    virDomainBlockStatsPtr stats, size_t size)\n{\n    virConnectPtr conn;\n    virDomainBlockStatsStruct stats2 = { -1, -1, -1, -1, -1 };\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, stats=%p, size=%zi\", disk, stats, size);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(stats, error);\n    if (size > sizeof(stats2)) {\n        virReportInvalidArg(size,\n                            _(\"size must not exceed %zu\"),\n                            sizeof(stats2));\n        goto error;\n    }\n    conn = dom->conn;\n\n    if (conn->driver->domainBlockStats) {\n        if (conn->driver->domainBlockStats(dom, disk, &stats2) == -1)\n            goto error;\n\n        memcpy(stats, &stats2, size);\n        return 0;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockStatsFlags:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @params: pointer to block stats parameter object\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of block stats; input and output\n * @flags: bitwise-OR of virTypedParameterFlags\n *\n * This function is to get block stats parameters for block\n * devices attached to the domain.\n *\n * The @disk parameter is either the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\"), or (since 0.9.8)\n * an unambiguous source name of the block device (the <source\n * file='...'/> sub-element, such as \"/path/to/image\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk. Some drivers might also\n * accept the empty string for the @disk parameter, and then yield\n * summary stats for the entire domain.\n *\n * Domains may have more than one block device.  To get stats for\n * each you should make multiple calls to this function.\n *\n * On input, @nparams gives the size of the @params array; on output,\n * @nparams gives how many slots were filled with parameter\n * information, which might be less but will not exceed the input\n * value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. (Note that block devices of different types\n * might support different parameters, so it might be necessary to compute\n * @nparams for each block device). The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again. See virDomainGetMemoryParameters() for more details.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainBlockStatsFlags(virDomainPtr dom,\n                         const char *disk,\n                         virTypedParameterPtr params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, params=%p, nparams=%d, flags=%x\",\n                     disk, params, nparams ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n    conn = dom->conn;\n\n    if (conn->driver->domainBlockStatsFlags) {\n        int ret;\n        ret = conn->driver->domainBlockStatsFlags(dom, disk, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainInterfaceStats:\n * @dom: pointer to the domain object\n * @path: path to the interface\n * @stats: network interface stats (returned)\n * @size: size of stats structure\n *\n * This function returns network interface stats for interfaces\n * attached to the domain.\n *\n * The path parameter is the name of the network interface.\n *\n * Domains may have more than one network interface.  To get stats for\n * each you should make multiple calls to this function.\n *\n * Individual fields within the stats structure may be returned\n * as -1, which indicates that the hypervisor does not support\n * that particular statistic.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainInterfaceStats(virDomainPtr dom, const char *path,\n                        virDomainInterfaceStatsPtr stats, size_t size)\n{\n    virConnectPtr conn;\n    virDomainInterfaceStatsStruct stats2 = { -1, -1, -1, -1,\n                                             -1, -1, -1, -1 };\n\n    VIR_DOMAIN_DEBUG(dom, \"path=%s, stats=%p, size=%zi\",\n                     path, stats, size);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(path, error);\n    virCheckNonNullArgGoto(stats, error);\n    if (size > sizeof(stats2)) {\n        virReportInvalidArg(size,\n                            _(\"size must not exceed %zu\"),\n                            sizeof(stats2));\n        goto error;\n    }\n\n    conn = dom->conn;\n\n    if (conn->driver->domainInterfaceStats) {\n        if (conn->driver->domainInterfaceStats(dom, path, &stats2) == -1)\n            goto error;\n\n        memcpy(stats, &stats2, size);\n        return 0;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetInterfaceParameters:\n * @domain: pointer to domain object\n * @device: the interface name or mac address\n * @params: pointer to interface parameter objects\n * @nparams: number of interface parameter (this value can be the same or\n *          less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change a subset or all parameters of interface; currently this\n * includes bandwidth parameters.  The value of @flags should be\n * either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values\n * VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG, although\n * hypervisors vary in which flags are supported.\n *\n * This function may require privileged access to the hypervisor.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetInterfaceParameters(virDomainPtr domain,\n                                const char *device,\n                                virTypedParameterPtr params,\n                                int nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"device=%s, params=%p, nparams=%d, flags=%x\",\n                     device, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckPositiveArgGoto(nparams, error);\n\n    if (virTypedParameterValidateSet(conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetInterfaceParameters) {\n        int ret;\n        ret = conn->driver->domainSetInterfaceParameters(domain, device,\n                                                         params, nparams,\n                                                         flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetInterfaceParameters:\n * @domain: pointer to domain object\n * @device: the interface name or mac address\n * @params: pointer to interface parameter objects\n *          (return value, allocated by the caller)\n * @nparams: pointer to number of interface parameter; input and output\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all interface parameters. On input, @nparams gives the size of\n * the @params array; on output, @nparams gives how many slots were\n * filled with parameter information, which might be less but will not\n * exceed the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0 on\n * input will cause @nparams on output to contain the number of parameters\n * supported by the hypervisor. The caller should then allocate @params\n * array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the\n * API again. See virDomainGetMemoryParameters() for an equivalent usage\n * example.\n *\n * This function may require privileged access to the hypervisor. This function\n * expects the caller to allocate the @params.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetInterfaceParameters(virDomainPtr domain,\n                                const char *device,\n                                virTypedParameterPtr params,\n                                int *nparams, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"device=%s, params=%p, nparams=%d, flags=%x\",\n                     device, params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0)\n        virCheckNonNullArgGoto(params, error);\n\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetInterfaceParameters) {\n        int ret;\n        ret = conn->driver->domainGetInterfaceParameters(domain, device,\n                                                         params, nparams,\n                                                         flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMemoryStats:\n * @dom: pointer to the domain object\n * @stats: nr_stats-sized array of stat structures (returned)\n * @nr_stats: number of memory statistics requested\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * This function provides memory statistics for the domain.\n *\n * Up to 'nr_stats' elements of 'stats' will be populated with memory statistics\n * from the domain.  Only statistics supported by the domain, the driver, and\n * this version of libvirt will be returned.\n *\n * Memory Statistics:\n *\n * VIR_DOMAIN_MEMORY_STAT_SWAP_IN:\n *     The total amount of data read from swap space (in kb).\n * VIR_DOMAIN_MEMORY_STAT_SWAP_OUT:\n *     The total amount of memory written out to swap space (in kb).\n * VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:\n *     The number of page faults that required disk IO to service.\n * VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:\n *     The number of page faults serviced without disk IO.\n * VIR_DOMAIN_MEMORY_STAT_UNUSED:\n *     The amount of memory which is not being used for any purpose (in kb).\n * VIR_DOMAIN_MEMORY_STAT_AVAILABLE:\n *     The total amount of memory available to the domain's OS (in kb).\n * VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON:\n *     Current balloon value (in kb).\n *\n * Returns: The number of stats provided or -1 in case of failure.\n */\nint\nvirDomainMemoryStats(virDomainPtr dom, virDomainMemoryStatPtr stats,\n                     unsigned int nr_stats, unsigned int flags)\n{\n    virConnectPtr conn;\n    unsigned long nr_stats_ret = 0;\n\n    VIR_DOMAIN_DEBUG(dom, \"stats=%p, nr_stats=%u, flags=%x\",\n                     stats, nr_stats, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (!stats || nr_stats == 0)\n        return 0;\n\n    if (nr_stats > VIR_DOMAIN_MEMORY_STAT_NR)\n        nr_stats = VIR_DOMAIN_MEMORY_STAT_NR;\n\n    conn = dom->conn;\n    if (conn->driver->domainMemoryStats) {\n        nr_stats_ret = conn->driver->domainMemoryStats(dom, stats, nr_stats,\n                                                       flags);\n        if (nr_stats_ret == -1)\n            goto error;\n        return nr_stats_ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockPeek:\n * @dom: pointer to the domain object\n * @disk: path to the block device, or device shorthand\n * @offset: offset within block device\n * @size: size to read\n * @buffer: return buffer (must be at least size bytes)\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * This function allows you to read the contents of a domain's\n * disk device.\n *\n * Typical uses for this are to determine if the domain has\n * written a Master Boot Record (indicating that the domain\n * has completed installation), or to try to work out the state\n * of the domain's filesystems.\n *\n * (Note that in the local case you might try to open the\n * block device or file directly, but that won't work in the\n * remote case, nor if you don't have sufficient permission.\n * Hence the need for this call).\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * 'offset' and 'size' represent an area which must lie entirely\n * within the device or file.  'size' may be 0 to test if the\n * call would succeed.\n *\n * 'buffer' is the return buffer and must be at least 'size' bytes.\n *\n * NB. The remote driver imposes a 64K byte limit on 'size'.\n * For your program to be able to work reliably over a remote\n * connection you should split large requests to <= 65536 bytes.\n * However, with 0.9.13 this RPC limit has been raised to 1M byte.\n * Starting with version 1.0.6 the RPC limit has been raised again.\n * Now large requests up to 16M byte are supported.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainBlockPeek(virDomainPtr dom,\n                   const char *disk,\n                   unsigned long long offset /* really 64 bits */,\n                   size_t size,\n                   void *buffer,\n                   unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, offset=%lld, size=%zi, buffer=%p, flags=%x\",\n                     disk, offset, size, buffer, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonEmptyStringArgGoto(disk, error);\n\n    /* Allow size == 0 as an access test. */\n    if (size > 0)\n        virCheckNonNullArgGoto(buffer, error);\n\n    if (conn->driver->domainBlockPeek) {\n        int ret;\n        ret = conn->driver->domainBlockPeek(dom, disk, offset, size,\n                                            buffer, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockResize:\n * @dom: pointer to the domain object\n * @disk: path to the block image, or shorthand\n * @size: new size of the block image, see below for unit\n * @flags: bitwise-OR of virDomainBlockResizeFlags\n *\n * Resize a block device of domain while the domain is running.  If\n * @flags is 0, then @size is in kibibytes (blocks of 1024 bytes);\n * since 0.9.11, if @flags includes VIR_DOMAIN_BLOCK_RESIZE_BYTES,\n * @size is in bytes instead.  @size is taken directly as the new\n * size.  Depending on the file format, the hypervisor may round up\n * to the next alignment boundary.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * Note that this call may fail if the underlying virtualization hypervisor\n * does not support it; this call requires privileged access to the\n * hypervisor.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainBlockResize(virDomainPtr dom,\n                     const char *disk,\n                     unsigned long long size,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, size=%llu, flags=%x\", disk, size, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockResize) {\n        int ret;\n        ret = conn->driver->domainBlockResize(dom, disk, size, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainMemoryPeek:\n * @dom: pointer to the domain object\n * @start: start of memory to peek\n * @size: size of memory to peek\n * @buffer: return buffer (must be at least size bytes)\n * @flags: bitwise-OR of virDomainMemoryFlags\n *\n * This function allows you to read the contents of a domain's\n * memory.\n *\n * The memory which is read is controlled by the 'start', 'size'\n * and 'flags' parameters.\n *\n * If 'flags' is VIR_MEMORY_VIRTUAL then the 'start' and 'size'\n * parameters are interpreted as virtual memory addresses for\n * whichever task happens to be running on the domain at the\n * moment.  Although this sounds haphazard it is in fact what\n * you want in order to read Linux kernel state, because it\n * ensures that pointers in the kernel image can be interpreted\n * coherently.\n *\n * 'buffer' is the return buffer and must be at least 'size' bytes.\n * 'size' may be 0 to test if the call would succeed.\n *\n * NB. The remote driver imposes a 64K byte limit on 'size'.\n * For your program to be able to work reliably over a remote\n * connection you should split large requests to <= 65536 bytes.\n * However, with 0.9.13 this RPC limit has been raised to 1M byte.\n * Starting with version 1.0.6 the RPC limit has been raised again.\n * Now large requests up to 16M byte are supported.\n *\n * Returns: 0 in case of success or -1 in case of failure.\n */\nint\nvirDomainMemoryPeek(virDomainPtr dom,\n                    unsigned long long start /* really 64 bits */,\n                    size_t size,\n                    void *buffer,\n                    unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"start=%lld, size=%zi, buffer=%p, flags=%x\",\n                     start, size, buffer, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    /* Note on access to physical memory: A VIR_MEMORY_PHYSICAL flag is\n     * a possibility.  However it isn't really useful unless the caller\n     * can also access registers, particularly CR3 on x86 in order to\n     * get the Page Table Directory.  Since registers are different on\n     * every architecture, that would imply another call to get the\n     * machine registers.\n     *\n     * The QEMU driver handles VIR_MEMORY_VIRTUAL, mapping it\n     * to the qemu 'memsave' command which does the virtual to physical\n     * mapping inside qemu.\n     *\n     * The QEMU driver also handles VIR_MEMORY_PHYSICAL, mapping it\n     * to the qemu 'pmemsave' command.\n     *\n     * At time of writing there is no Xen driver.  However the Xen\n     * hypervisor only lets you map physical pages from other domains,\n     * and so the Xen driver would have to do the virtual to physical\n     * mapping by chasing 2, 3 or 4-level page tables from the PTD.\n     * There is example code in libxc (xc_translate_foreign_address)\n     * which does this, although we cannot copy this code directly\n     * because of incompatible licensing.\n     */\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_MEMORY_VIRTUAL, VIR_MEMORY_PHYSICAL, error);\n\n    /* Allow size == 0 as an access test. */\n    if (size > 0)\n        virCheckNonNullArgGoto(buffer, error);\n\n    if (conn->driver->domainMemoryPeek) {\n        int ret;\n        ret = conn->driver->domainMemoryPeek(dom, start, size,\n                                             buffer, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlockInfo:\n * @domain: a domain object\n * @disk: path to the block device, or device shorthand\n * @info: pointer to a virDomainBlockInfo structure allocated by the user\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract information about a domain's block device.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * For QEMU domains, the allocation and physical virDomainBlockInfo\n * values returned will generally be the same, except when using a\n * non raw, block backing device, such as qcow2 for an active domain.\n * When the persistent domain is not active, QEMU will return the\n * default which is the same value for allocation and physical.\n *\n * Active QEMU domains can return an allocation value which is more\n * representative of the currently used blocks by the device compared\n * to the physical size of the device. Applications can use/monitor\n * the allocation value with the understanding that if the domain\n * becomes inactive during an attempt to get the value, the default\n * values will be returned. Thus, the application should check\n * after the call for the domain being inactive if the values are\n * the same. Optionally, the application could be watching for a\n * shutdown event and then ignore any values received afterwards.\n * This can be an issue when a domain is being migrated and the\n * exact timing of the domain being made inactive and check of\n * the allocation value results the default being returned. For\n * a transient domain in the similar situation, this call will return\n * -1 and an error message indicating the \"domain is not running\".\n *\n * The following is some pseudo code illustrating the call sequence:\n *\n *   ...\n *   virDomainPtr dom;\n *   virDomainBlockInfo info;\n *   char *device;\n *   ...\n *   // Either get a list of all domains or a specific domain\n *   // via a virDomainLookupBy*() call.\n *   //\n *   // It's also required to fill in the device pointer, but that's\n *   // specific to the implementation. For the purposes of this example\n *   // a qcow2 backed device name string would need to be provided.\n *   ...\n *   // If the following call is made on a persistent domain with a\n *   // qcow2 block backed block device, then it's possible the returned\n *   // allocation equals the physical value. In that case, the domain\n *   // that may have been active prior to calling has become inactive,\n *   // such as is the case during a domain migration. Thus once we\n *   // get data returned, check for active domain when the values are\n *   // the same.\n *   if (virDomainGetBlockInfo(dom, device, &info, 0) < 0)\n *       goto failure;\n *   if (info.allocation == info.physical) {\n *       // If the domain is no longer active,\n *       // then the defaults are being returned.\n *       if (!virDomainIsActive())\n *               goto ignore_return;\n *   }\n *   // Do something with the allocation and physical values\n *   ...\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetBlockInfo(virDomainPtr domain, const char *disk,\n                      virDomainBlockInfoPtr info, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p, flags=%x\", info, flags);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonEmptyStringArgGoto(disk, error);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetBlockInfo) {\n        int ret;\n        ret = conn->driver->domainGetBlockInfo(domain, disk, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDefineXML:\n * @conn: pointer to the hypervisor connection\n * @xml: the XML description for the domain, preferably in UTF-8\n *\n * Define a domain, but does not start it.\n * This definition is persistent, until explicitly undefined with\n * virDomainUndefine(). A previous definition for this domain would be\n * overridden if it already exists.\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation on a transient domain with the same id as the\n * domain being defined; in that case, use virDomainBlockJobAbort() to\n * stop the block copy first.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns NULL in case of error, a pointer to the domain otherwise\n */\nvirDomainPtr\nvirDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    VIR_DEBUG(\"conn=%p, xml=%s\", conn, NULLSTR(xml));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(xml, error);\n\n    if (conn->driver->domainDefineXML) {\n        virDomainPtr ret;\n        ret = conn->driver->domainDefineXML(conn, xml);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainDefineXMLFlags:\n * @conn: pointer to the hypervisor connection\n * @xml: the XML description for the domain, preferably in UTF-8\n * @flags: bitwise OR of the virDomainDefineFlags constants\n *\n * Defines a domain, but does not start it.\n * This definition is persistent, until explicitly undefined with\n * virDomainUndefine(). A previous definition for this domain would be\n * overridden if it already exists.\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation on a transient domain with the same id as the\n * domain being defined; in that case, use virDomainBlockJobAbort() to\n * stop the block copy first.\n *\n * virDomainFree should be used to free the resources after the\n * domain object is no longer needed.\n *\n * Returns NULL in case of error, a pointer to the domain otherwise\n */\nvirDomainPtr\nvirDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xml=%s flags=%x\", conn, NULLSTR(xml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(xml, error);\n\n    if (conn->driver->domainDefineXMLFlags) {\n        virDomainPtr ret;\n        ret = conn->driver->domainDefineXMLFlags(conn, xml, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virDomainUndefine:\n * @domain: pointer to a defined domain\n *\n * Undefine a domain. If the domain is running, it's converted to\n * transient domain, without stopping it. If the domain is inactive,\n * the domain configuration is removed.\n *\n * If the domain has a managed save image (see\n * virDomainHasManagedSaveImage()), or if it is inactive and has any\n * snapshot metadata (see virDomainSnapshotNum()), then the undefine will\n * fail. See virDomainUndefineFlags() for more control.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainUndefine(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainUndefine) {\n        int ret;\n        ret = conn->driver->domainUndefine(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainUndefineFlags:\n * @domain: pointer to a defined domain\n * @flags: bitwise-OR of supported virDomainUndefineFlagsValues\n *\n * Undefine a domain. If the domain is running, it's converted to\n * transient domain, without stopping it. If the domain is inactive,\n * the domain configuration is removed.\n *\n * If the domain has a managed save image (see virDomainHasManagedSaveImage()),\n * then including VIR_DOMAIN_UNDEFINE_MANAGED_SAVE in @flags will also remove\n * that file, and omitting the flag will cause the undefine process to fail.\n *\n * If the domain is inactive and has any snapshot metadata (see\n * virDomainSnapshotNum()), then including\n * VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA in @flags will also remove\n * that metadata.  Omitting the flag will cause the undefine of an\n * inactive domain to fail.  Active snapshots will retain snapshot\n * metadata until the (now-transient) domain halts, regardless of\n * whether this flag is present.  On hypervisors where snapshots do\n * not use libvirt metadata, this flag has no effect.\n *\n * If the domain has any nvram specified, then including\n * VIR_DOMAIN_UNDEFINE_NVRAM will also remove that file, and omitting the flag\n * will cause the undefine process to fail.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainUndefineFlags(virDomainPtr domain,\n                       unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainUndefineFlags) {\n        int ret;\n        ret = conn->driver->domainUndefineFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virConnectNumOfDefinedDomains:\n * @conn: pointer to the hypervisor connection\n *\n * Provides the number of defined but inactive domains.\n *\n * Returns the number of domain found or -1 in case of error\n */\nint\nvirConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectNumOfDefinedDomains) {\n        int ret;\n        ret = conn->driver->connectNumOfDefinedDomains(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectListDefinedDomains:\n * @conn: pointer to the hypervisor connection\n * @names: pointer to an array to store the names\n * @maxnames: size of the array\n *\n * list the defined but inactive domains, stores the pointers to the names\n * in @names\n *\n * For active domains, see virConnectListDomains().  For more control over\n * the results, see virConnectListAllDomains().\n *\n * Returns the number of names provided in the array or -1 in case of error.\n * Note that this command is inherently racy; a domain can be defined between\n * a call to virConnectNumOfDefinedDomains() and this call; you are only\n * guaranteed that all currently defined domains were listed if the return\n * is less than @maxids.  The client must call free() on each returned name.\n */\nint\nvirConnectListDefinedDomains(virConnectPtr conn, char **const names,\n                             int maxnames)\n{\n    VIR_DEBUG(\"conn=%p, names=%p, maxnames=%d\", conn, names, maxnames);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(names, error);\n    virCheckNonNegativeArgGoto(maxnames, error);\n\n    if (conn->driver->connectListDefinedDomains) {\n        int ret;\n        ret = conn->driver->connectListDefinedDomains(conn, names, maxnames);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectListAllDomains:\n * @conn: Pointer to the hypervisor connection.\n * @domains: Pointer to a variable to store the array containing domain objects\n *           or NULL if the list is not required (just returns number of guests).\n * @flags: bitwise-OR of virConnectListAllDomainsFlags\n *\n * Collect a possibly-filtered list of all domains, and return an allocated\n * array of information for each.  This API solves the race inherent in\n * virConnectListDomains() and virConnectListDefinedDomains().\n *\n * Normally, all domains are returned; however, @flags can be used to\n * filter the results for a smaller list of targeted domains.  The valid\n * flags are divided into groups, where each group contains bits that\n * describe mutually exclusive attributes of a domain, and where all bits\n * within a group describe all possible domains.  Some hypervisors might\n * reject explicit bits from a group where the hypervisor cannot make a\n * distinction (for example, not all hypervisors can tell whether domains\n * have snapshots).  For a group supported by a given hypervisor, the\n * behavior when no bits of a group are set is identical to the behavior\n * when all bits in that group are set.  When setting bits from more than\n * one group, it is possible to select an impossible combination (such\n * as an inactive transient domain), in that case a hypervisor may return\n * either 0 or an error.\n *\n * The first group of @flags is VIR_CONNECT_LIST_DOMAINS_ACTIVE (online\n * domains) and VIR_CONNECT_LIST_DOMAINS_INACTIVE (offline domains).\n *\n * The next group of @flags is VIR_CONNECT_LIST_DOMAINS_PERSISTENT (defined\n * domains) and VIR_CONNECT_LIST_DOMAINS_TRANSIENT (running but not defined).\n *\n * The next group of @flags covers various domain states:\n * VIR_CONNECT_LIST_DOMAINS_RUNNING, VIR_CONNECT_LIST_DOMAINS_PAUSED,\n * VIR_CONNECT_LIST_DOMAINS_SHUTOFF, and a catch-all for all other states\n * (such as crashed, this catch-all covers the possibility of adding new\n * states).\n *\n * The remaining groups cover boolean attributes commonly asked about\n * domains; they include VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE and\n * VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE, for filtering based on whether\n * a managed save image exists; VIR_CONNECT_LIST_DOMAINS_AUTOSTART and\n * VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART, for filtering based on autostart;\n * VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT and\n * VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT, for filtering based on whether\n * a domain has snapshots.\n *\n * Example of usage:\n *\n *   virDomainPtr *domains;\n *   size_t i;\n *   int ret;\n *   unsigned int flags = VIR_CONNECT_LIST_DOMAINS_RUNNING |\n *                        VIR_CONNECT_LIST_DOMAINS_PERSISTENT;\n *   ret = virConnectListAllDomains(conn, &domains, flags);\n *   if (ret < 0)\n *       error();\n *   for (i = 0; i < ret; i++) {\n *        do_something_with_domain(domains[i]);\n *        //here or in a separate loop if needed\n *        virDomainFree(domains[i]);\n *   }\n *   free(domains);\n *\n * Returns the number of domains found or -1 and sets domains to NULL in case of\n * error.  On success, the array stored into @domains is guaranteed to have an\n * extra allocated element set to NULL but not included in the return count, to\n * make iteration easier. The caller is responsible for calling virDomainFree()\n * on each array element, then calling free() on @domains.\n */\nint\nvirConnectListAllDomains(virConnectPtr conn,\n                         virDomainPtr **domains,\n                         unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, domains=%p, flags=%x\", conn, domains, flags);\n\n    virResetLastError();\n\n    if (domains)\n        *domains = NULL;\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectListAllDomains) {\n        int ret;\n        ret = conn->driver->connectListAllDomains(conn, domains, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainCreate:\n * @domain: pointer to a defined domain\n *\n * Launch a defined domain. If the call succeeds the domain moves from the\n * defined to the running domains pools.  The domain will be paused only\n * if restoring from managed state created from a paused domain.  For more\n * control, see virDomainCreateWithFlags().\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainCreate(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreate) {\n        int ret;\n        ret = conn->driver->domainCreate(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainCreateWithFlags:\n * @domain: pointer to a defined domain\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a defined domain. If the call succeeds the domain moves from the\n * defined to the running domains pools.\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain\n * has a managed save image that requested paused state (see\n * virDomainManagedSave()) the guest domain will be started, but its\n * CPUs will remain paused. The CPUs can later be manually started\n * using virDomainResume().  In all other cases, the guest domain will\n * be running.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * If the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a\n * managed save file for this domain (created by virDomainManagedSave()),\n * then libvirt will attempt to bypass the file system cache while restoring\n * the file, or fail if it cannot do so for the given system; this can allow\n * less pressure on file system cache, but also risks slowing loads from NFS.\n *\n * If the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save\n * file for this domain is discarded, and the domain boots from scratch.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateWithFlags) {\n        int ret;\n        ret = conn->driver->domainCreateWithFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainCreateWithFiles:\n * @domain: pointer to a defined domain\n * @nfiles: number of file descriptors passed\n * @files: list of file descriptors passed\n * @flags: bitwise-OR of supported virDomainCreateFlags\n *\n * Launch a defined domain. If the call succeeds the domain moves from the\n * defined to the running domains pools.\n *\n * @files provides an array of file descriptors which will be\n * made available to the 'init' process of the guest. The file\n * handles exposed to the guest will be renumbered to start\n * from 3 (ie immediately following stderr). This is only\n * supported for guests which use container based virtualization\n * technology.\n *\n * If the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain\n * has a managed save image that requested paused state (see\n * virDomainManagedSave()) the guest domain will be started, but its\n * CPUs will remain paused. The CPUs can later be manually started\n * using virDomainResume().  In all other cases, the guest domain will\n * be running.\n *\n * If the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\n * domain will be automatically destroyed when the virConnectPtr\n * object is finally released. This will also happen if the\n * client application crashes / loses its connection to the\n * libvirtd daemon. Any domains marked for auto destroy will\n * block attempts at migration, save-to-file, or snapshots.\n *\n * If the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a\n * managed save file for this domain (created by virDomainManagedSave()),\n * then libvirt will attempt to bypass the file system cache while restoring\n * the file, or fail if it cannot do so for the given system; this can allow\n * less pressure on file system cache, but also risks slowing loads from NFS.\n *\n * If the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save\n * file for this domain is discarded, and the domain boots from scratch.\n *\n * Returns 0 in case of success, -1 in case of error\n */\nint\nvirDomainCreateWithFiles(virDomainPtr domain, unsigned int nfiles,\n                         int *files, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"nfiles=%u, files=%p, flags=%x\",\n                     nfiles, files, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateWithFiles) {\n        int ret;\n        ret = conn->driver->domainCreateWithFiles(domain,\n                                                  nfiles, files,\n                                                  flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetAutostart:\n * @domain: a domain object\n * @autostart: the value returned\n *\n * Provides a boolean value indicating whether the domain\n * configured to be automatically started when the host\n * machine boots.\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainGetAutostart(virDomainPtr domain,\n                      int *autostart)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"autostart=%p\", autostart);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(autostart, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetAutostart) {\n        int ret;\n        ret = conn->driver->domainGetAutostart(domain, autostart);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetAutostart:\n * @domain: a domain object\n * @autostart: whether the domain should be automatically started 0 or 1\n *\n * Configure the domain to be automatically started\n * when the host machine boots.\n *\n * Returns -1 in case of error, 0 in case of success\n */\nint\nvirDomainSetAutostart(virDomainPtr domain,\n                      int autostart)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"autostart=%d\", autostart);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainSetAutostart) {\n        int ret;\n        ret = conn->driver->domainSetAutostart(domain, autostart);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainInjectNMI:\n * @domain: pointer to domain object, or NULL for Domain0\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Send NMI to the guest\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainInjectNMI(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainInjectNMI) {\n        int ret;\n        ret = conn->driver->domainInjectNMI(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSendKey:\n * @domain:    pointer to domain object, or NULL for Domain0\n * @codeset:   the code set of keycodes, from virKeycodeSet\n * @holdtime:  the duration (in milliseconds) that the keys will be held\n * @keycodes:  array of keycodes\n * @nkeycodes: number of keycodes, up to VIR_DOMAIN_SEND_KEY_MAX_KEYS\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Send key(s) to the guest.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSendKey(virDomainPtr domain,\n                 unsigned int codeset,\n                 unsigned int holdtime,\n                 unsigned int *keycodes,\n                 int nkeycodes,\n                 unsigned int flags)\n{\n    virConnectPtr conn;\n    VIR_DOMAIN_DEBUG(domain, \"codeset=%u, holdtime=%u, nkeycodes=%u, flags=%x\",\n                     codeset, holdtime, nkeycodes, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(keycodes, error);\n    virCheckPositiveArgGoto(nkeycodes, error);\n\n    if (nkeycodes > VIR_DOMAIN_SEND_KEY_MAX_KEYS) {\n        virReportInvalidArg(nkeycodes,\n                            _(\"nkeycodes must be <= %d\"),\n                            VIR_DOMAIN_SEND_KEY_MAX_KEYS);\n        goto error;\n    }\n\n    if (conn->driver->domainSendKey) {\n        int ret;\n        ret = conn->driver->domainSendKey(domain, codeset, holdtime,\n                                          keycodes, nkeycodes, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSendProcessSignal:\n * @domain: pointer to domain object\n * @pid_value: a positive integer process ID, or negative integer process group ID\n * @signum: a signal from the virDomainProcessSignal enum\n * @flags: one of the virDomainProcessSignalFlag values\n *\n * Send a signal to the designated process in the guest\n *\n * The signal numbers must be taken from the virDomainProcessSignal\n * enum. These will be translated to the corresponding signal\n * number for the guest OS, by the guest agent delivering the\n * signal. If there is no mapping from virDomainProcessSignal to\n * the native OS signals, this API will report an error.\n *\n * If @pid_value is an integer greater than zero, it is\n * treated as a process ID. If @pid_value is an integer\n * less than zero, it is treated as a process group ID.\n * All the @pid_value numbers are from the container/guest\n * namespace. The value zero is not valid.\n *\n * Not all hypervisors will support sending signals to\n * arbitrary processes or process groups. If this API is\n * implemented the minimum requirement is to be able to\n * use @pid_value == 1 (i.e. kill init). No other value is\n * required to be supported.\n *\n * If the @signum is VIR_DOMAIN_PROCESS_SIGNAL_NOP then this\n * API will simply report whether the process is running in\n * the container/guest.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSendProcessSignal(virDomainPtr domain,\n                           long long pid_value,\n                           unsigned int signum,\n                           unsigned int flags)\n{\n    virConnectPtr conn;\n    VIR_DOMAIN_DEBUG(domain, \"pid=%lld, signum=%u flags=%x\",\n                     pid_value, signum, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonZeroArgGoto(pid_value, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainSendProcessSignal) {\n        int ret;\n        ret = conn->driver->domainSendProcessSignal(domain,\n                                                    pid_value,\n                                                    signum,\n                                                    flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetVcpus:\n * @domain: pointer to domain object, or NULL for Domain0\n * @nvcpus: the new number of virtual CPUs for this domain\n *\n * Dynamically change the number of virtual CPUs used by the domain.\n * Note that this call may fail if the underlying virtualization hypervisor\n * does not support it or if growing the number is arbitrarily limited.\n * This function may require privileged access to the hypervisor.\n *\n * Note that if this call is executed before the guest has finished booting,\n * the guest may fail to process the change.\n *\n * This command only changes the runtime configuration of the domain,\n * so can only be called on an active domain.  It is hypervisor-dependent\n * whether it also affects persistent configuration; for more control,\n * use virDomainSetVcpusFlags().\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetVcpus(virDomainPtr domain, unsigned int nvcpus)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"nvcpus=%u\", nvcpus);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonZeroArgGoto(nvcpus, error);\n\n    if (conn->driver->domainSetVcpus) {\n        int ret;\n        ret = conn->driver->domainSetVcpus(domain, nvcpus);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetVcpusFlags:\n * @domain: pointer to domain object, or NULL for Domain0\n * @nvcpus: the new number of virtual CPUs for this domain, must be at least 1\n * @flags: bitwise-OR of virDomainVcpuFlags\n *\n * Dynamically change the number of virtual CPUs used by the domain.\n * Note that this call may fail if the underlying virtualization hypervisor\n * does not support it or if growing the number is arbitrarily limited.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE to affect a running\n * domain (which may fail if domain is not active), or\n * VIR_DOMAIN_AFFECT_CONFIG to affect the next boot via the XML\n * description of the domain.  Both flags may be set.\n * If neither flag is specified (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT),\n * then an inactive domain modifies persistent setup, while an active domain\n * is hypervisor-dependent on whether just live or both live and persistent\n * state is changed.\n *\n * Note that if this call is executed before the guest has finished booting,\n * the guest may fail to process the change.\n *\n * If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then\n * VIR_DOMAIN_AFFECT_LIVE must be clear, and only the maximum virtual\n * CPU limit is altered; generally, this value must be less than or\n * equal to virConnectGetMaxVcpus().  Otherwise, this call affects the\n * current virtual CPU limit, which must be less than or equal to the\n * maximum limit.\n *\n * If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of processors is\n * modified inside the guest instead of the hypervisor. This flag can only\n * be used with live guests and is incompatible with VIR_DOMAIN_VCPU_MAXIMUM.\n * The usage of this flag may require a guest agent configured.\n *\n * Not all hypervisors can support all flag combinations.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainSetVcpusFlags(virDomainPtr domain, unsigned int nvcpus,\n                       unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"nvcpus=%u, flags=%x\", nvcpus, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    VIR_REQUIRE_FLAG_GOTO(VIR_DOMAIN_VCPU_MAXIMUM,\n                          VIR_DOMAIN_AFFECT_CONFIG,\n                          error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_VCPU_GUEST,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    virCheckNonZeroArgGoto(nvcpus, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainSetVcpusFlags) {\n        int ret;\n        ret = conn->driver->domainSetVcpusFlags(domain, nvcpus, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetVcpusFlags:\n * @domain: pointer to domain object, or NULL for Domain0\n * @flags: bitwise-OR of virDomainVcpuFlags\n *\n * Query the number of virtual CPUs used by the domain.  Note that\n * this call may fail if the underlying virtualization hypervisor does\n * not support it.  This function may require privileged access to the\n * hypervisor.\n *\n * If @flags includes VIR_DOMAIN_AFFECT_LIVE, this will query a\n * running domain (which will fail if domain is not active); if\n * it includes VIR_DOMAIN_AFFECT_CONFIG, this will query the XML\n * description of the domain.  It is an error to set both flags.\n * If neither flag is set (that is, VIR_DOMAIN_AFFECT_CURRENT),\n * then the configuration queried depends on whether the domain\n * is currently running.\n *\n * If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum\n * virtual CPU limit is queried.  Otherwise, this call queries the\n * current virtual CPU count.\n *\n * If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of the processors\n * is queried in the guest instead of the hypervisor. This flag is only usable\n * on live domains. Guest agent may be needed for this flag to be available.\n *\n * Returns the number of vCPUs in case of success, -1 in case of failure.\n */\nint\nvirDomainGetVcpusFlags(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    if (flags & VIR_DOMAIN_VCPU_GUEST)\n        virCheckReadOnlyGoto(conn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    if (conn->driver->domainGetVcpusFlags) {\n        int ret;\n        ret = conn->driver->domainGetVcpusFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPinVcpu:\n * @domain: pointer to domain object, or NULL for Domain0\n * @vcpu: virtual CPU number\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n *\n * Dynamically change the real CPUs which can be allocated to a virtual CPU.\n * This function may require privileged access to the hypervisor.\n *\n * This command only changes the runtime configuration of the domain,\n * so can only be called on an active domain.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainPinVcpu(virDomainPtr domain, unsigned int vcpu,\n                 unsigned char *cpumap, int maplen)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"vcpu=%u, cpumap=%p, maplen=%d\",\n                     vcpu, cpumap, maplen);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinVcpu) {\n        int ret;\n        ret = conn->driver->domainPinVcpu(domain, vcpu, cpumap, maplen);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPinVcpuFlags:\n * @domain: pointer to domain object, or NULL for Domain0\n * @vcpu: virtual CPU number\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically change the real CPUs which can be allocated to a virtual CPU.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n * Not all hypervisors can support all flag combinations.\n *\n * See also virDomainGetVcpuPinInfo for querying this information.\n *\n * Returns 0 in case of success, -1 in case of failure.\n *\n */\nint\nvirDomainPinVcpuFlags(virDomainPtr domain, unsigned int vcpu,\n                      unsigned char *cpumap, int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"vcpu=%u, cpumap=%p, maplen=%d, flags=%x\",\n                     vcpu, cpumap, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinVcpuFlags) {\n        int ret;\n        ret = conn->driver->domainPinVcpuFlags(domain, vcpu, cpumap, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetVcpuPinInfo:\n * @domain: pointer to domain object, or NULL for Domain0\n * @ncpumaps: the number of cpumap (listed first to match virDomainGetVcpus)\n * @cpumaps: pointer to a bit map of real CPUs for all vcpus of this\n *     domain (in 8-bit bytes) (OUT)\n *     It's assumed there is <ncpumaps> cpumap in cpumaps array.\n *     The memory allocated to cpumaps must be (ncpumaps * maplen) bytes\n *     (ie: calloc(ncpumaps, maplen)).\n *     One cpumap inside cpumaps has the format described in\n *     virDomainPinVcpu() API.\n *     Must not be NULL.\n * @maplen: the number of bytes in one cpumap, from 1 up to size of CPU map.\n *     Must be positive.\n * @flags: bitwise-OR of virDomainModificationImpact\n *     Must not be VIR_DOMAIN_AFFECT_LIVE and\n *     VIR_DOMAIN_AFFECT_CONFIG concurrently.\n *\n * Query the CPU affinity setting of all virtual CPUs of domain, store it\n * in cpumaps.\n *\n * Returns the number of virtual CPUs in case of success,\n * -1 in case of failure.\n */\nint\nvirDomainGetVcpuPinInfo(virDomainPtr domain, int ncpumaps,\n                        unsigned char *cpumaps, int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"ncpumaps=%d, cpumaps=%p, maplen=%d, flags=%x\",\n                     ncpumaps, cpumaps, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(cpumaps, error);\n    virCheckPositiveArgGoto(ncpumaps, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (INT_MULTIPLY_OVERFLOW(ncpumaps, maplen)) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %d * %d\"),\n                       ncpumaps, maplen);\n        goto error;\n    }\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    if (conn->driver->domainGetVcpuPinInfo) {\n        int ret;\n        ret = conn->driver->domainGetVcpuPinInfo(domain, ncpumaps,\n                                                 cpumaps, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainPinEmulator:\n * @domain: pointer to domain object, or NULL for Domain0\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically change the real CPUs which can be allocated to all emulator\n * threads. This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n * Not all hypervisors can support all flag combinations.\n *\n * See also virDomainGetEmulatorPinInfo for querying this information.\n *\n * Returns 0 in case of success, -1 in case of failure.\n *\n */\nint\nvirDomainPinEmulator(virDomainPtr domain, unsigned char *cpumap,\n                     int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cpumap=%p, maplen=%d, flags=%x\",\n                     cpumap, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinEmulator) {\n        int ret;\n        ret = conn->driver->domainPinEmulator(domain, cpumap, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetEmulatorPinInfo:\n * @domain: pointer to domain object, or NULL for Domain0\n * @cpumap: pointer to a bit map of real CPUs for all emulator threads of\n *     this domain (in 8-bit bytes) (OUT)\n *     There is only one cpumap for all emulator threads.\n *     Must not be NULL.\n * @maplen: the number of bytes in one cpumap, from 1 up to size of CPU map.\n *     Must be positive.\n * @flags: bitwise-OR of virDomainModificationImpact\n *     Must not be VIR_DOMAIN_AFFECT_LIVE and\n *     VIR_DOMAIN_AFFECT_CONFIG concurrently.\n *\n * Query the CPU affinity setting of all emulator threads of domain, store\n * it in cpumap.\n *\n * Returns 1 in case of success,\n * 0 in case of no emulator threads are pined to pcpus,\n * -1 in case of failure.\n */\nint\nvirDomainGetEmulatorPinInfo(virDomainPtr domain, unsigned char *cpumap,\n                            int maplen, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cpumap=%p, maplen=%d, flags=%x\",\n                     cpumap, maplen, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetEmulatorPinInfo) {\n        int ret;\n        ret = conn->driver->domainGetEmulatorPinInfo(domain, cpumap,\n                                                     maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetVcpus:\n * @domain: pointer to domain object, or NULL for Domain0\n * @info: pointer to an array of virVcpuInfo structures (OUT)\n * @maxinfo: number of structures in info array\n * @cpumaps: pointer to a bit map of real CPUs for all vcpus of this\n *      domain (in 8-bit bytes) (OUT)\n *      If cpumaps is NULL, then no cpumap information is returned by the API.\n *      It's assumed there is <maxinfo> cpumap in cpumaps array.\n *      The memory allocated to cpumaps must be (maxinfo * maplen) bytes\n *      (ie: calloc(maxinfo, maplen)).\n *      One cpumap inside cpumaps has the format described in\n *      virDomainPinVcpu() API.\n * @maplen: number of bytes in one cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      Must be zero when cpumaps is NULL and positive when it is non-NULL.\n *\n * Extract information about virtual CPUs of domain, store it in info array\n * and also in cpumaps if this pointer isn't NULL.  This call may fail\n * on an inactive domain.\n *\n * See also virDomainGetVcpuPinInfo for querying just cpumaps, including on\n * an inactive domain.\n *\n * Returns the number of info filled in case of success, -1 in case of failure.\n */\nint\nvirDomainGetVcpus(virDomainPtr domain, virVcpuInfoPtr info, int maxinfo,\n                  unsigned char *cpumaps, int maplen)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p, maxinfo=%d, cpumaps=%p, maplen=%d\",\n                     info, maxinfo, cpumaps, maplen);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n    virCheckPositiveArgGoto(maxinfo, error);\n\n    /* Ensure that domainGetVcpus (aka remoteDomainGetVcpus) does not\n       try to memcpy anything into a NULL pointer.  */\n    if (cpumaps)\n        virCheckPositiveArgGoto(maplen, error);\n    else\n        virCheckZeroArgGoto(maplen, error);\n\n    if (cpumaps && INT_MULTIPLY_OVERFLOW(maxinfo, maplen)) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %d * %d\"),\n                       maxinfo, maplen);\n        goto error;\n    }\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetVcpus) {\n        int ret;\n        ret = conn->driver->domainGetVcpus(domain, info, maxinfo,\n                                           cpumaps, maplen);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetMaxVcpus:\n * @domain: pointer to domain object\n *\n * Provides the maximum number of virtual CPUs supported for\n * the guest VM. If the guest is inactive, this is basically\n * the same as virConnectGetMaxVcpus(). If the guest is running\n * this will reflect the maximum number of virtual CPUs the\n * guest was booted with.  For more details, see virDomainGetVcpusFlags().\n *\n * Returns the maximum of virtual CPU or -1 in case of error.\n */\nint\nvirDomainGetMaxVcpus(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMaxVcpus) {\n        int ret;\n        ret = conn->driver->domainGetMaxVcpus(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetIOThreadInfo:\n * @dom: a domain object\n * @info: pointer to an array of virDomainIOThreadInfo structures (OUT)\n * @flags: bitwise-OR of virDomainModificationImpact\n *     Must not be VIR_DOMAIN_AFFECT_LIVE and\n *     VIR_DOMAIN_AFFECT_CONFIG concurrently.\n *\n * Fetch IOThreads of an active domain including the cpumap information to\n * determine on which CPU the IOThread has affinity to run.\n *\n * Returns the number of IOThreads or -1 in case of error.\n * On success, the array of information is stored into @info. The caller is\n * responsible for calling virDomainIOThreadInfoFree() on each array element,\n * then calling free() on @info. On error, @info is set to NULL.\n */\nint\nvirDomainGetIOThreadInfo(virDomainPtr dom,\n                         virDomainIOThreadInfoPtr **info,\n                         unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"info=%p flags=%x\", info, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(info, error);\n    *info = NULL;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    if (dom->conn->driver->domainGetIOThreadInfo) {\n        int ret;\n        ret = dom->conn->driver->domainGetIOThreadInfo(dom, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainIOThreadInfoFree:\n * @info: pointer to a virDomainIOThreadInfo object\n *\n * Frees the memory used by @info.\n */\nvoid\nvirDomainIOThreadInfoFree(virDomainIOThreadInfoPtr info)\n{\n    if (!info)\n        return;\n\n    VIR_FREE(info->cpumap);\n    VIR_FREE(info);\n}\n\n\n/**\n * virDomainPinIOThread:\n * @domain: a domain object\n * @iothread_id: the IOThread ID to set the CPU affinity\n * @cpumap: pointer to a bit map of real CPUs (in 8-bit bytes) (IN)\n *      Each bit set to 1 means that corresponding CPU is usable.\n *      Bytes are stored in little-endian order: CPU0-7, 8-15...\n *      In each byte, lowest CPU number is least significant bit.\n * @maplen: number of bytes in cpumap, from 1 up to size of CPU map in\n *      underlying virtualization system (Xen...).\n *      If maplen < size, missing bytes are set to zero.\n *      If maplen > size, failure code is returned.\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically change the real CPUs which can be allocated to an IOThread.\n * This function may require privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n * Not all hypervisors can support all flag combinations.\n *\n * See also virDomainGetIOThreadInfo for querying this information.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainPinIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned char *cpumap,\n                     int maplen,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, cpumap=%p, maplen=%d\",\n                     iothread_id, cpumap, maplen);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(cpumap, error);\n    virCheckPositiveArgGoto(maplen, error);\n\n    if (conn->driver->domainPinIOThread) {\n        int ret;\n        ret = conn->driver->domainPinIOThread(domain, iothread_id,\n                                              cpumap, maplen, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainAddIOThread:\n * @domain: a domain object\n * @iothread_id: the specific IOThread ID value to add\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically add an IOThread to the domain. It is left up to the\n * underlying virtual hypervisor to determine the valid range for an\n * @iothread_id and determining whether the @iothread_id already exists.\n *\n * Note that this call can fail if the underlying virtualization hypervisor\n * does not support it or if growing the number is arbitrarily limited.\n * This function requires privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainAddIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=%x\",\n                     iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainAddIOThread) {\n        int ret;\n        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDelIOThread:\n * @domain: a domain object\n * @iothread_id: the specific IOThread ID value to delete\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Dynamically delete an IOThread from the domain. The @iothread_id to be\n * deleted must not have a resource associated with it and can be any of\n * the currently valid IOThread ID's.\n *\n * Note that this call can fail if the underlying virtualization hypervisor\n * does not support it or if reducing the number is arbitrarily limited.\n * This function requires privileged access to the hypervisor.\n *\n * @flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\n * Both flags may be set.\n * If VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\n * and may fail if domain is not alive.\n * If VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\n * and will fail for transient domains. If neither flag is specified (that is,\n * @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\n * persistent setup, while an active domain is hypervisor-dependent on whether\n * just live or both live and persistent state is changed.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSecurityLabel:\n * @domain: a domain object\n * @seclabel: pointer to a virSecurityLabel structure\n *\n * Extract security label of an active domain. The 'label' field\n * in the @seclabel argument will be initialized to the empty\n * string if the domain is not running under a security model.\n *\n * Returns 0 in case of success, -1 in case of failure\n */\nint\nvirDomainGetSecurityLabel(virDomainPtr domain, virSecurityLabelPtr seclabel)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"seclabel=%p\", seclabel);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(seclabel, error);\n\n    if (conn->driver->domainGetSecurityLabel) {\n        int ret;\n        ret = conn->driver->domainGetSecurityLabel(domain, seclabel);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetSecurityLabelList:\n * @domain: a domain object\n * @seclabels: will be auto-allocated and filled with domains' security labels.\n * Caller must free memory on return.\n *\n * Extract the security labels of an active domain. The 'label' field\n * in the @seclabels argument will be initialized to the empty\n * string if the domain is not running under a security model.\n *\n * Returns number of elemnets in @seclabels on success, -1 in case of failure.\n */\nint\nvirDomainGetSecurityLabelList(virDomainPtr domain,\n                              virSecurityLabelPtr* seclabels)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"seclabels=%p\", seclabels);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virCheckNonNullArgGoto(seclabels, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetSecurityLabelList) {\n        int ret;\n        ret = conn->driver->domainGetSecurityLabelList(domain, seclabels);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetMetadata:\n * @domain: a domain object\n * @type: type of metadata, from virDomainMetadataType\n * @metadata: new metadata text\n * @key: XML namespace key, or NULL\n * @uri: XML namespace URI, or NULL\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Sets the appropriate domain element given by @type to the\n * value of @metadata.  A @type of VIR_DOMAIN_METADATA_DESCRIPTION\n * is free-form text; VIR_DOMAIN_METADATA_TITLE is free-form, but no\n * newlines are permitted, and should be short (although the length is\n * not enforced). For these two options @key and @uri are irrelevant and\n * must be set to NULL.\n *\n * For type VIR_DOMAIN_METADATA_ELEMENT @metadata  must be well-formed\n * XML belonging to namespace defined by @uri with local name @key.\n *\n * Passing NULL for @metadata says to remove that element from the\n * domain XML (passing the empty string leaves the element present).\n *\n * The resulting metadata will be present in virDomainGetXMLDesc(),\n * as well as quick access through virDomainGetMetadata().\n *\n * @flags controls whether the live domain, persistent configuration,\n * or both will be modified.\n *\n * Returns 0 on success, -1 in case of failure.\n */\nint\nvirDomainSetMetadata(virDomainPtr domain,\n                     int type,\n                     const char *metadata,\n                     const char *key,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"type=%d, metadata='%s', key='%s', uri='%s', flags=%x\",\n                     type, NULLSTR(metadata), NULLSTR(key), NULLSTR(uri),\n                     flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    switch (type) {\n    case VIR_DOMAIN_METADATA_TITLE:\n        if (metadata && strchr(metadata, '\\n')) {\n            virReportInvalidArg(metadata, \"%s\",\n                                _(\"metadata title can't contain \"\n                                  \"newlines\"));\n            goto error;\n        }\n        /* fallthrough */\n    case VIR_DOMAIN_METADATA_DESCRIPTION:\n        virCheckNullArgGoto(uri, error);\n        virCheckNullArgGoto(key, error);\n        break;\n    case VIR_DOMAIN_METADATA_ELEMENT:\n        virCheckNonNullArgGoto(uri, error);\n        if (metadata)\n            virCheckNonNullArgGoto(key, error);\n        break;\n    default:\n        /* For future expansion */\n        break;\n    }\n\n    if (conn->driver->domainSetMetadata) {\n        int ret;\n        ret = conn->driver->domainSetMetadata(domain, type, metadata, key, uri,\n                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetMetadata:\n * @domain: a domain object\n * @type: type of metadata, from virDomainMetadataType\n * @uri: XML namespace identifier\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Retrieves the appropriate domain element given by @type.\n * If VIR_DOMAIN_METADATA_ELEMENT is requested parameter @uri\n * must be set to the name of the namespace the requested elements\n * belong to, otherwise must be NULL.\n *\n * If an element of the domain XML is not present, the resulting\n * error will be VIR_ERR_NO_DOMAIN_METADATA.  This method forms\n * a shortcut for seeing information from virDomainSetMetadata()\n * without having to go through virDomainGetXMLDesc().\n *\n * @flags controls whether the live domain or persistent\n * configuration will be queried.\n *\n * Returns the metadata string on success (caller must free),\n * or NULL in case of failure.\n */\nchar *\nvirDomainGetMetadata(virDomainPtr domain,\n                     int type,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"type=%d, uri='%s', flags=%x\",\n                     type, NULLSTR(uri), flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    switch (type) {\n    case VIR_DOMAIN_METADATA_TITLE:\n    case VIR_DOMAIN_METADATA_DESCRIPTION:\n        virCheckNullArgGoto(uri, error);\n        break;\n    case VIR_DOMAIN_METADATA_ELEMENT:\n        virCheckNonNullArgGoto(uri, error);\n        break;\n    default:\n        /* For future expansion */\n        break;\n    }\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetMetadata) {\n        char *ret;\n        if (!(ret = conn->driver->domainGetMetadata(domain, type, uri, flags)))\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainAttachDevice:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n *\n * Create a virtual device attachment to backend.  This function,\n * having hotplug semantics, is only allowed on an active domain.\n *\n * For compatibility, this method can also be used to change the media\n * in an existing CDROM/Floppy device, however, applications are\n * recommended to use the virDomainUpdateDeviceFlag method instead.\n *\n * Be aware that hotplug changes might not persist across a domain going\n * into S4 state (also known as hibernation) unless you also modify the\n * persistent domain definition.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainAttachDevice(virDomainPtr domain, const char *xml)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s\", xml);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainAttachDevice) {\n       int ret;\n       ret = conn->driver->domainAttachDevice(domain, xml);\n       if (ret < 0)\n          goto error;\n       return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainAttachDeviceFlags:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n * @flags: bitwise-OR of virDomainDeviceModifyFlags\n *\n * Attach a virtual device to a domain, using the flags parameter\n * to control how the device is attached.  VIR_DOMAIN_AFFECT_CURRENT\n * specifies that the device allocation is made based on current domain\n * state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\n * allocated to the active domain instance only and is not added to the\n * persisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG\n * specifies that the device shall be allocated to the persisted domain\n * configuration only.  Note that the target hypervisor must return an\n * error if unable to satisfy flags.  E.g. the hypervisor driver will\n * return failure if LIVE is specified but it only supports modifying the\n * persisted device allocation.\n *\n * For compatibility, this method can also be used to change the media\n * in an existing CDROM/Floppy device, however, applications are\n * recommended to use the virDomainUpdateDeviceFlag method instead.\n *\n * Be aware that hotplug changes might not persist across a domain going\n * into S4 state (also known as hibernation) unless you also modify the\n * persistent domain definition.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainAttachDeviceFlags(virDomainPtr domain,\n                           const char *xml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s, flags=%x\", xml, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainAttachDeviceFlags) {\n        int ret;\n        ret = conn->driver->domainAttachDeviceFlags(domain, xml, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDetachDevice:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n *\n * This is an equivalent of virDomainDetachDeviceFlags() when called with\n * @flags parameter set to VIR_DOMAIN_AFFECT_LIVE.\n *\n * See virDomainDetachDeviceFlags() for more details.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainDetachDevice(virDomainPtr domain, const char *xml)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s\", xml);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDetachDevice) {\n        int ret;\n        ret = conn->driver->domainDetachDevice(domain, xml);\n         if (ret < 0)\n             goto error;\n         return ret;\n     }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainDetachDeviceFlags:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n * @flags: bitwise-OR of virDomainDeviceModifyFlags\n *\n * Detach a virtual device from a domain, using the flags parameter\n * to control how the device is detached.  VIR_DOMAIN_AFFECT_CURRENT\n * specifies that the device allocation is removed based on current domain\n * state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\n * deallocated from the active domain instance only and is not from the\n * persisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG\n * specifies that the device shall be deallocated from the persisted domain\n * configuration only.  Note that the target hypervisor must return an\n * error if unable to satisfy flags.  E.g. the hypervisor driver will\n * return failure if LIVE is specified but it only supports removing the\n * persisted device allocation.\n *\n * Some hypervisors may prevent this operation if there is a current\n * block copy operation on the device being detached; in that case,\n * use virDomainBlockJobAbort() to stop the block copy first.\n *\n * Beware that depending on the hypervisor and device type, detaching a device\n * from a running domain may be asynchronous. That is, calling\n * virDomainDetachDeviceFlags may just request device removal while the device\n * is actually removed later (in cooperation with a guest OS). Previously,\n * this fact was ignored and the device could have been removed from domain\n * configuration before it was actually removed by the hypervisor causing\n * various failures on subsequent operations. To check whether the device was\n * successfully removed, either recheck domain configuration using\n * virDomainGetXMLDesc() or add a handler for the VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED\n * event. In case the device is already gone when virDomainDetachDeviceFlags\n * returns, the event is delivered before this API call ends. To help existing\n * clients work better in most cases, this API will try to transform an\n * asynchronous device removal that finishes shortly after the request into\n * a synchronous removal. In other words, this API may wait a bit for the\n * removal to complete in case it was not synchronous.\n *\n * Be aware that hotplug changes might not persist across a domain going\n * into S4 state (also known as hibernation) unless you also modify the\n * persistent domain definition.\n *\n * The supplied XML description of the device should be as specific\n * as its definition in the domain XML. The set of attributes used\n * to match the device are internal to the drivers. Using a partial definition,\n * or attempting to detach a device that is not present in the domain XML,\n * but shares some specific attributes with one that is present,\n * may lead to unexpected results.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainDetachDeviceFlags(virDomainPtr domain,\n                           const char *xml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s, flags=%x\", xml, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDetachDeviceFlags) {\n        int ret;\n        ret = conn->driver->domainDetachDeviceFlags(domain, xml, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainUpdateDeviceFlags:\n * @domain: pointer to domain object\n * @xml: pointer to XML description of one device\n * @flags: bitwise-OR of virDomainDeviceModifyFlags\n *\n * Change a virtual device on a domain, using the flags parameter\n * to control how the device is changed.  VIR_DOMAIN_AFFECT_CURRENT\n * specifies that the device change is made based on current domain\n * state.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\n * changed on the active domain instance only and is not added to the\n * persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG\n * specifies that the device shall be changed on the persisted domain\n * configuration only.  Note that the target hypervisor must return an\n * error if unable to satisfy flags.  E.g. the hypervisor driver will\n * return failure if LIVE is specified but it only supports modifying the\n * persisted device allocation.\n *\n * This method is used for actions such changing CDROM/Floppy device\n * media, altering the graphics configuration such as password,\n * reconfiguring the NIC device backend connectivity, etc.\n *\n * Returns 0 in case of success, -1 in case of failure.\n */\nint\nvirDomainUpdateDeviceFlags(virDomainPtr domain,\n                           const char *xml, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xml=%s, flags=%x\", xml, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(xml, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainUpdateDeviceFlags) {\n        int ret;\n        ret = conn->driver->domainUpdateDeviceFlags(domain, xml, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventRegister:\n * @conn: pointer to the connection\n * @cb: callback to the function handling domain events\n * @opaque: opaque data to pass on to the callback\n * @freecb: optional function to deallocate opaque when not used anymore\n *\n * Adds a callback to receive notifications of domain lifecycle events\n * occurring on a connection.  This function requires that an event loop\n * has been previously registered with virEventRegisterImpl() or\n * virEventRegisterDefaultImpl().\n *\n * Use of this method is no longer recommended. Instead applications\n * should try virConnectDomainEventRegisterAny() which has a more flexible\n * API contract.\n *\n * The virDomainPtr object handle passed into the callback upon delivery\n * of an event is only valid for the duration of execution of the callback.\n * If the callback wishes to keep the domain object after the callback returns,\n * it shall take a reference to it, by calling virDomainRef.\n * The reference can be released once the object is no longer required\n * by calling virDomainFree.\n *\n * Returns 0 on success, -1 on failure.  Older versions of some hypervisors\n * sometimes returned a positive number on success, but without any reliable\n * semantics on what that number represents.\n */\nint\nvirConnectDomainEventRegister(virConnectPtr conn,\n                              virConnectDomainEventCallback cb,\n                              void *opaque,\n                              virFreeCallback freecb)\n{\n    VIR_DEBUG(\"conn=%p, cb=%p, opaque=%p, freecb=%p\", conn, cb, opaque, freecb);\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver && conn->driver->connectDomainEventRegister) {\n        int ret;\n        ret = conn->driver->connectDomainEventRegister(conn, cb, opaque, freecb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventDeregister:\n * @conn: pointer to the connection\n * @cb: callback to the function handling domain events\n *\n * Removes a callback previously registered with the\n * virConnectDomainEventRegister() function.\n *\n * Use of this method is no longer recommended. Instead applications\n * should try virConnectDomainEventDeregisterAny() which has a more flexible\n * API contract\n *\n * Returns 0 on success, -1 on failure.  Older versions of some hypervisors\n * sometimes returned a positive number on success, but without any reliable\n * semantics on what that number represents.\n */\nint\nvirConnectDomainEventDeregister(virConnectPtr conn,\n                                virConnectDomainEventCallback cb)\n{\n    VIR_DEBUG(\"conn=%p, cb=%p\", conn, cb);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver && conn->driver->connectDomainEventDeregister) {\n        int ret;\n        ret = conn->driver->connectDomainEventDeregister(conn, cb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainIsActive:\n * @dom: pointer to the domain object\n *\n * Determine if the domain is currently running\n *\n * Returns 1 if running, 0 if inactive, -1 on error\n */\nint\nvirDomainIsActive(virDomainPtr dom)\n{\n    VIR_DEBUG(\"dom=%p\", dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainIsActive) {\n        int ret;\n        ret = dom->conn->driver->domainIsActive(dom);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainIsPersistent:\n * @dom: pointer to the domain object\n *\n * Determine if the domain has a persistent configuration\n * which means it will still exist after shutting down\n *\n * Returns 1 if persistent, 0 if transient, -1 on error\n */\nint\nvirDomainIsPersistent(virDomainPtr dom)\n{\n    VIR_DOMAIN_DEBUG(dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainIsPersistent) {\n        int ret;\n        ret = dom->conn->driver->domainIsPersistent(dom);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainRename:\n * @dom: pointer to the domain object\n * @new_name: new domain name\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Rename a domain. New domain name is specified in the second\n * argument. Depending on each driver implementation it may be\n * required that domain is in a specific state.\n *\n * There might be some attributes and/or elements in domain XML that if no\n * value provided at XML defining time, libvirt will derive their value from\n * the domain name. These are not updated by this API. Users are strongly\n * advised to change these after the rename was successful.\n *\n * Returns 0 if successfully renamed, -1 on error\n */\nint\nvirDomainRename(virDomainPtr dom,\n                const char *new_name,\n                unsigned int flags)\n{\n    VIR_DEBUG(\"dom=%p, new_name=%s\", dom, NULLSTR(new_name));\n\n    virResetLastError();\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(new_name, error);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainRename) {\n        int ret = dom->conn->driver->domainRename(dom, new_name, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainIsUpdated:\n * @dom: pointer to the domain object\n *\n * Determine if the domain has been updated.\n *\n * Returns 1 if updated, 0 if not, -1 on error\n */\nint\nvirDomainIsUpdated(virDomainPtr dom)\n{\n    VIR_DOMAIN_DEBUG(dom);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainIsUpdated) {\n        int ret;\n        ret = dom->conn->driver->domainIsUpdated(dom);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetJobInfo:\n * @domain: a domain object\n * @info: pointer to a virDomainJobInfo structure allocated by the user\n *\n * Extract information about progress of a background job on a domain.\n * Will return an error if the domain is not active.\n *\n * This function returns a limited amount of information in comparison\n * to virDomainGetJobStats().\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p\", info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetJobInfo) {\n        int ret;\n        ret = conn->driver->domainGetJobInfo(domain, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetJobStats:\n * @domain: a domain object\n * @type: where to store the job type (one of virDomainJobType)\n * @params: where to store job statistics\n * @nparams: number of items in @params\n * @flags: bitwise-OR of virDomainGetJobStatsFlags\n *\n * Extract information about progress of a background job on a domain.\n * Will return an error if the domain is not active. The function returns\n * a superset of progress information provided by virDomainGetJobInfo.\n * Possible fields returned in @params are defined by VIR_DOMAIN_JOB_*\n * macros and new fields will likely be introduced in the future so callers\n * may receive fields that they do not understand in case they talk to a\n * newer server.\n *\n * When @flags contains VIR_DOMAIN_JOB_STATS_COMPLETED, the function will\n * return statistics about a recently completed job. Specifically, this\n * flag may be used to query statistics of a completed incoming migration.\n * Statistics of a completed job are automatically destroyed once read or\n * when libvirtd is restarted. Note that time information returned for\n * completed migrations may be completely irrelevant unless both source and\n * destination hosts have synchronized time (i.e., NTP daemon is running on\n * both of them).\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainGetJobStats(virDomainPtr domain,\n                     int *type,\n                     virTypedParameterPtr *params,\n                     int *nparams,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"type=%p, params=%p, nparams=%p, flags=%x\",\n                     type, params, nparams, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(type, error);\n    virCheckNonNullArgGoto(params, error);\n    virCheckNonNullArgGoto(nparams, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetJobStats) {\n        int ret;\n        ret = conn->driver->domainGetJobStats(domain, type, params,\n                                              nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainAbortJob:\n * @domain: a domain object\n *\n * Requests that the current background job be aborted at the\n * soonest opportunity.\n *\n * Returns 0 in case of success and -1 in case of failure.\n */\nint\nvirDomainAbortJob(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainAbortJob) {\n        int ret;\n        ret = conn->driver->domainAbortJob(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateSetMaxDowntime:\n * @domain: a domain object\n * @downtime: maximum tolerable downtime for live migration, in milliseconds\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Sets maximum tolerable time for which the domain is allowed to be paused\n * at the end of live migration. It's supposed to be called while the domain is\n * being live-migrated as a reaction to migration progress.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateSetMaxDowntime(virDomainPtr domain,\n                               unsigned long long downtime,\n                               unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"downtime=%llu, flags=%x\", downtime, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateSetMaxDowntime) {\n        if (conn->driver->domainMigrateSetMaxDowntime(domain, downtime, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateGetCompressionCache:\n * @domain: a domain object\n * @cacheSize: return value of current size of the cache (in bytes)\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Gets current size of the cache (in bytes) used for compressing repeatedly\n * transferred memory pages during live migration.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateGetCompressionCache(virDomainPtr domain,\n                                    unsigned long long *cacheSize,\n                                    unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cacheSize=%p, flags=%x\", cacheSize, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(cacheSize, error);\n\n    if (conn->driver->domainMigrateGetCompressionCache) {\n        if (conn->driver->domainMigrateGetCompressionCache(domain, cacheSize,\n                                                           flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateSetCompressionCache:\n * @domain: a domain object\n * @cacheSize: size of the cache (in bytes) used for compression\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Sets size of the cache (in bytes) used for compressing repeatedly\n * transferred memory pages during live migration. It's supposed to be called\n * while the domain is being live-migrated as a reaction to migration progress\n * and increasing number of compression cache misses obtained from\n * virDomainGetJobStats.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateSetCompressionCache(virDomainPtr domain,\n                                    unsigned long long cacheSize,\n                                    unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"cacheSize=%llu, flags=%x\", cacheSize, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateSetCompressionCache) {\n        if (conn->driver->domainMigrateSetCompressionCache(domain, cacheSize,\n                                                           flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateSetMaxSpeed:\n * @domain: a domain object\n * @bandwidth: migration bandwidth limit in MiB/s\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * The maximum bandwidth (in MiB/s) that will be used to do migration\n * can be specified with the bandwidth parameter. Not all hypervisors\n * will support a bandwidth cap\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateSetMaxSpeed(virDomainPtr domain,\n                            unsigned long bandwidth,\n                            unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"bandwidth=%lu, flags=%x\", bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateSetMaxSpeed) {\n        if (conn->driver->domainMigrateSetMaxSpeed(domain, bandwidth, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainMigrateGetMaxSpeed:\n * @domain: a domain object\n * @bandwidth: return value of current migration bandwidth limit in MiB/s\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Get the current maximum bandwidth (in MiB/s) that will be used if the\n * domain is migrated.  Not all hypervisors will support a bandwidth limit.\n *\n * Returns 0 in case of success, -1 otherwise.\n */\nint\nvirDomainMigrateGetMaxSpeed(virDomainPtr domain,\n                            unsigned long *bandwidth,\n                            unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"bandwidth = %p, flags=%x\", bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(bandwidth, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateGetMaxSpeed) {\n        if (conn->driver->domainMigrateGetMaxSpeed(domain, bandwidth, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventRegisterAny:\n * @conn: pointer to the connection\n * @dom: pointer to the domain\n * @eventID: the event type to receive\n * @cb: callback to the function handling domain events\n * @opaque: opaque data to pass on to the callback\n * @freecb: optional function to deallocate opaque when not used anymore\n *\n * Adds a callback to receive notifications of arbitrary domain events\n * occurring on a domain.  This function requires that an event loop\n * has been previously registered with virEventRegisterImpl() or\n * virEventRegisterDefaultImpl().\n *\n * If @dom is NULL, then events will be monitored for any domain. If @dom\n * is non-NULL, then only the specific domain will be monitored.\n *\n * Most types of event have a callback providing a custom set of parameters\n * for the event. When registering an event, it is thus necessary to use\n * the VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer\n * to match the signature of this method.\n *\n * The virDomainPtr object handle passed into the callback upon delivery\n * of an event is only valid for the duration of execution of the callback.\n * If the callback wishes to keep the domain object after the callback returns,\n * it shall take a reference to it, by calling virDomainRef().\n * The reference can be released once the object is no longer required\n * by calling virDomainFree().\n *\n * The return value from this method is a positive integer identifier\n * for the callback. To unregister a callback, this callback ID should\n * be passed to the virConnectDomainEventDeregisterAny() method.\n *\n * Returns a callback identifier on success, -1 on failure.\n */\nint\nvirConnectDomainEventRegisterAny(virConnectPtr conn,\n                                 virDomainPtr dom,\n                                 int eventID,\n                                 virConnectDomainEventGenericCallback cb,\n                                 void *opaque,\n                                 virFreeCallback freecb)\n{\n    VIR_DOMAIN_DEBUG(dom, \"conn=%p, eventID=%d, cb=%p, opaque=%p, freecb=%p\",\n                     conn, eventID, cb, opaque, freecb);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (dom) {\n        virCheckDomainGoto(dom, error);\n        if (dom->conn != conn) {\n            virReportInvalidArg(dom,\n                                _(\"domain '%s' must match connection\"),\n                                dom->name);\n            goto error;\n        }\n    }\n    virCheckNonNullArgGoto(cb, error);\n    virCheckNonNegativeArgGoto(eventID, error);\n    if (eventID >= VIR_DOMAIN_EVENT_ID_LAST) {\n        virReportInvalidArg(eventID,\n                            _(\"eventID must be less than %d\"),\n                            VIR_DOMAIN_EVENT_ID_LAST);\n        goto error;\n    }\n\n    if (conn->driver && conn->driver->connectDomainEventRegisterAny) {\n        int ret;\n        ret = conn->driver->connectDomainEventRegisterAny(conn, dom, eventID, cb, opaque, freecb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virConnectDomainEventDeregisterAny:\n * @conn: pointer to the connection\n * @callbackID: the callback identifier\n *\n * Removes an event callback. The callbackID parameter should be the\n * value obtained from a previous virConnectDomainEventRegisterAny() method.\n *\n * Returns 0 on success, -1 on failure.  Older versions of some hypervisors\n * sometimes returned a positive number on success, but without any reliable\n * semantics on what that number represents. */\nint\nvirConnectDomainEventDeregisterAny(virConnectPtr conn,\n                                   int callbackID)\n{\n    VIR_DEBUG(\"conn=%p, callbackID=%d\", conn, callbackID);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNegativeArgGoto(callbackID, error);\n\n    if (conn->driver && conn->driver->connectDomainEventDeregisterAny) {\n        int ret;\n        ret = conn->driver->connectDomainEventDeregisterAny(conn, callbackID);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainManagedSave:\n * @dom: pointer to the domain\n * @flags: bitwise-OR of virDomainSaveRestoreFlags\n *\n * This method will suspend a domain and save its memory contents to\n * a file on disk. After the call, if successful, the domain is not\n * listed as running anymore.\n * The difference from virDomainSave() is that libvirt is keeping track of\n * the saved state itself, and will reuse it once the domain is being\n * restarted (automatically or via an explicit libvirt call).\n * As a result any running domain is sure to not have a managed saved image.\n * This also implies that managed save only works on persistent domains,\n * since the domain must still exist in order to use virDomainCreate() to\n * restart it.\n *\n * If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\n * attempt to bypass the file system cache while creating the file, or\n * fail if it cannot do so for the given system; this can allow less\n * pressure on file system cache, but also risks slowing saves to NFS.\n *\n * Normally, the managed saved state will remember whether the domain\n * was running or paused, and start will resume to the same state.\n * Specifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n * @flags will override the default saved into the file.  These two\n * flags are mutually exclusive.\n *\n * Returns 0 in case of success or -1 in case of failure\n */\nint\nvirDomainManagedSave(virDomainPtr dom, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_SAVE_RUNNING,\n                             VIR_DOMAIN_SAVE_PAUSED,\n                             error);\n\n    if (conn->driver->domainManagedSave) {\n        int ret;\n\n        ret = conn->driver->domainManagedSave(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainHasManagedSaveImage:\n * @dom: pointer to the domain\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Check if a domain has a managed save image as created by\n * virDomainManagedSave(). Note that any running domain should not have\n * such an image, as it should have been removed on restart.\n *\n * Returns 0 if no image is present, 1 if an image is present, and\n *         -1 in case of error\n */\nint\nvirDomainHasManagedSaveImage(virDomainPtr dom, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    if (conn->driver->domainHasManagedSaveImage) {\n        int ret;\n\n        ret = conn->driver->domainHasManagedSaveImage(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainManagedSaveRemove:\n * @dom: pointer to the domain\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Remove any managed save image for this domain.\n *\n * Returns 0 in case of success, and -1 in case of error\n */\nint\nvirDomainManagedSaveRemove(virDomainPtr dom, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainManagedSaveRemove) {\n        int ret;\n\n        ret = conn->driver->domainManagedSaveRemove(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n\n/**\n * virDomainOpenConsole:\n * @dom: a domain object\n * @dev_name: the console, serial or parallel port device alias, or NULL\n * @st: a stream to associate with the console\n * @flags: bitwise-OR of virDomainConsoleFlags\n *\n * This opens the backend associated with a console, serial or\n * parallel port device on a guest, if the backend is supported.\n * If the @dev_name is omitted, then the first console or serial\n * device is opened. The console is associated with the passed\n * in @st stream, which should have been opened in non-blocking\n * mode for bi-directional I/O.\n *\n * By default, when @flags is 0, the open will fail if libvirt\n * detects that the console is already in use by another client;\n * passing VIR_DOMAIN_CONSOLE_FORCE will cause libvirt to forcefully\n * remove the other client prior to opening this console.\n *\n * If flag VIR_DOMAIN_CONSOLE_SAFE the console is opened only in the\n * case where the hypervisor driver supports safe (mutually exclusive)\n * console handling.\n *\n * Older servers did not support either flag, and also did not forbid\n * simultaneous clients on a console, with potentially confusing results.\n * When passing @flags of 0 in order to support a wider range of server\n * versions, it is up to the client to ensure mutual exclusion.\n *\n * Returns 0 if the console was opened, -1 on error\n */\nint\nvirDomainOpenConsole(virDomainPtr dom,\n                     const char *dev_name,\n                     virStreamPtr st,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"dev_name=%s, st=%p, flags=%x\",\n                     NULLSTR(dev_name), st, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckStreamGoto(st, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(st,\n                            _(\"stream must match connection of domain '%s'\"),\n                            dom->name);\n        goto error;\n    }\n\n    if (conn->driver->domainOpenConsole) {\n        int ret;\n        ret = conn->driver->domainOpenConsole(dom, dev_name, st, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainOpenChannel:\n * @dom: a domain object\n * @name: the channel name, or NULL\n * @st: a stream to associate with the channel\n * @flags: bitwise-OR of virDomainChannelFlags\n *\n * This opens the host interface associated with a channel device on a\n * guest, if the host interface is supported.  If @name is given, it\n * can match either the device alias (e.g. \"channel0\"), or the virtio\n * target name (e.g. \"org.qemu.guest_agent.0\").  If @name is omitted,\n * then the first channel is opened. The channel is associated with\n * the passed in @st stream, which should have been opened in\n * non-blocking mode for bi-directional I/O.\n *\n * By default, when @flags is 0, the open will fail if libvirt detects\n * that the channel is already in use by another client; passing\n * VIR_DOMAIN_CHANNEL_FORCE will cause libvirt to forcefully remove the\n * other client prior to opening this channel.\n *\n * Returns 0 if the channel was opened, -1 on error\n */\nint\nvirDomainOpenChannel(virDomainPtr dom,\n                     const char *name,\n                     virStreamPtr st,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"name=%s, st=%p, flags=%x\",\n                     NULLSTR(name), st, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckStreamGoto(st, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn != st->conn) {\n        virReportInvalidArg(st,\n                            _(\"stream must match connection of domain '%s'\"),\n                            dom->name);\n        goto error;\n    }\n\n    if (conn->driver->domainOpenChannel) {\n        int ret;\n        ret = conn->driver->domainOpenChannel(dom, name, st, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockJobAbort:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @flags: bitwise-OR of virDomainBlockJobAbortFlags\n *\n * Cancel the active block job on the given disk.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, then\n * by default, this function performs a synchronous operation and the caller\n * may assume that the operation has completed when 0 is returned.  However,\n * BlockJob operations may take a long time to cancel, and during this time\n * further domain interactions may be unresponsive.  To avoid this problem,\n * pass VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC in the @flags argument to enable\n * asynchronous behavior, returning as soon as possible.  When the job has\n * been canceled, a BlockJob event will be emitted, with status\n * VIR_DOMAIN_BLOCK_JOB_CANCELED (even if the ABORT_ASYNC flag was not\n * used); it is also possible to poll virDomainBlockJobInfo() to see if\n * the job cancellation is still pending.  This type of job can be restarted\n * to pick up from where it left off.\n *\n * If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_COPY, then\n * the default is to abort the mirroring and revert to the source disk;\n * likewise, if the current job is VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT,\n * the default is to abort without changing the active layer of @disk.\n * Adding @flags of VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT causes this call to\n * fail with VIR_ERR_BLOCK_COPY_ACTIVE if the copy or commit is not yet\n * ready; otherwise it will swap the disk over to the new active image\n * to end the mirroring or active commit.  An event will be issued when the\n * job is ended, and it is possible to use VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC\n * to control whether this command waits for the completion of the job.\n * Restarting a copy or active commit job requires starting over from the\n * beginning of the first phase.\n *\n * Returns -1 in case of failure, 0 when successful.\n */\nint\nvirDomainBlockJobAbort(virDomainPtr dom, const char *disk,\n                       unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, flags=%x\", disk, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockJobAbort) {\n        int ret;\n        ret = conn->driver->domainBlockJobAbort(dom, disk, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlockJobInfo:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @info: pointer to a virDomainBlockJobInfo structure\n * @flags: bitwise-OR of virDomainBlockJobInfoFlags\n *\n * Request block job information for the given disk.  If an operation is active\n * @info will be updated with the current progress.  The units used for the\n * bandwidth field of @info depends on @flags.  If @flags includes\n * VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES, bandwidth is in bytes/second\n * (although this mode can risk failure due to overflow, depending on both\n * client and server word size); otherwise, the value is rounded up to MiB/s.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * Returns -1 in case of failure, 0 when nothing found, 1 when info was found.\n */\nint\nvirDomainGetBlockJobInfo(virDomainPtr dom, const char *disk,\n                         virDomainBlockJobInfoPtr info, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, info=%p, flags=%x\", disk, info, flags);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(info, error);\n\n    if (conn->driver->domainGetBlockJobInfo) {\n        int ret;\n        ret = conn->driver->domainGetBlockJobInfo(dom, disk, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockJobSetSpeed:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @bandwidth: specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockJobSetSpeedFlags\n *\n * Set the maximimum allowable bandwidth that a block job may consume.  If\n * bandwidth is 0, the limit will revert to the hypervisor default of\n * unlimited.\n *\n * If @flags contains VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES, @bandwidth\n * is in bytes/second; otherwise, it is in MiB/second.  Values larger than\n * 2^52 bytes/sec may be rejected due to overflow considerations based on\n * the word size of both client and server, and values larger than 2^31\n * bytes/sec may cause overflow problems if later queried by\n * virDomainGetBlockJobInfo() without scaling.  Hypervisors may further\n * restrict the range of valid bandwidth values.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * Returns -1 in case of failure, 0 when successful.\n */\nint\nvirDomainBlockJobSetSpeed(virDomainPtr dom, const char *disk,\n                          unsigned long bandwidth, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, bandwidth=%lu, flags=%x\",\n                     disk, bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockJobSetSpeed) {\n        int ret;\n        ret = conn->driver->domainBlockJobSetSpeed(dom, disk, bandwidth, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockPull:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @bandwidth: (optional) specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockPullFlags\n *\n * Populate a disk image with data from its backing image.  Once all data from\n * its backing image has been pulled, the disk no longer depends on a backing\n * image.  This function pulls data for the entire device in the background.\n * Progress of the operation can be checked with virDomainGetBlockJobInfo() and\n * the operation can be aborted with virDomainBlockJobAbort().  When finished,\n * an asynchronous event is raised to indicate the final status.  To move\n * data in the opposite direction, see virDomainBlockCommit().\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or (since 0.9.5) the device target shorthand\n * (the <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The maximum bandwidth that will be used to do the copy can be\n * specified with the @bandwidth parameter.  If set to 0, there is no\n * limit.  If @flags includes VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES,\n * @bandwidth is in bytes/second; otherwise, it is in MiB/second.\n * Values larger than 2^52 bytes/sec may be rejected due to overflow\n * considerations based on the word size of both client and server,\n * and values larger than 2^31 bytes/sec may cause overflow problems\n * if later queried by virDomainGetBlockJobInfo() without scaling.\n * Hypervisors may further restrict the range of valid bandwidth\n * values.  Some hypervisors do not support this feature and will\n * return an error if bandwidth is not 0; in this case, it might still\n * be possible for a later call to virDomainBlockJobSetSpeed() to\n * succeed.  The actual speed can be determined with\n * virDomainGetBlockJobInfo().\n *\n * This is shorthand for virDomainBlockRebase() with a NULL base.\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockPull(virDomainPtr dom, const char *disk,\n                   unsigned long bandwidth, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, bandwidth=%lu, flags=%x\",\n                     disk, bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockPull) {\n        int ret;\n        ret = conn->driver->domainBlockPull(dom, disk, bandwidth, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockRebase:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @base: path to backing file to keep, or device shorthand,\n *        or NULL for no backing file\n * @bandwidth: (optional) specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockRebaseFlags\n *\n * Populate a disk image with data from its backing image chain, and\n * setting the backing image to @base, or alternatively copy an entire\n * backing chain to a new file @base.\n *\n * When @flags is 0, this starts a pull, where @base must be the absolute\n * path of one of the backing images further up the chain, or NULL to\n * convert the disk image so that it has no backing image.  Once all\n * data from its backing image chain has been pulled, the disk no\n * longer depends on those intermediate backing images.  This function\n * pulls data for the entire device in the background.  Progress of\n * the operation can be checked with virDomainGetBlockJobInfo() with a\n * job type of VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, and the operation can be\n * aborted with virDomainBlockJobAbort().  When finished, an asynchronous\n * event is raised to indicate the final status, and the job no longer\n * exists.  If the job is aborted, a new one can be started later to\n * resume from the same point.\n *\n * If @flags contains VIR_DOMAIN_BLOCK_REBASE_RELATIVE, the name recorded\n * into the active disk as the location for @base will be kept relative.\n * The operation will fail if libvirt can't infer the name.\n *\n * When @flags includes VIR_DOMAIN_BLOCK_REBASE_COPY, this starts a copy,\n * where @base must be the name of a new file to copy the chain to.  By\n * default, the copy will pull the entire source chain into the destination\n * file, but if @flags also contains VIR_DOMAIN_BLOCK_REBASE_SHALLOW, then\n * only the top of the source chain will be copied (the source and\n * destination have a common backing file).  By default, @base will be\n * created with the same file format as the source, but this can be altered\n * by adding VIR_DOMAIN_BLOCK_REBASE_COPY_RAW to force the copy to be raw\n * (does not make sense with the shallow flag unless the source is also raw),\n * or by using VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT to reuse an existing file\n * which was pre-created with the correct format and metadata and sufficient\n * size to hold the copy. In case the VIR_DOMAIN_BLOCK_REBASE_SHALLOW flag\n * is used the pre-created file has to exhibit the same guest visible contents\n * as the backing file of the original image. This allows a management app to\n * pre-create files with relative backing file names, rather than the default\n * of absolute backing file names; as a security precaution, you should\n * generally only use reuse_ext with the shallow flag and a non-raw\n * destination file.  By default, the copy destination will be treated as\n * type='file', but using VIR_DOMAIN_BLOCK_REBASE_COPY_DEV treats the\n * destination as type='block' (affecting how virDomainGetBlockInfo() will\n * report allocation after pivoting).\n *\n * A copy job has two parts; in the first phase, the @bandwidth parameter\n * affects how fast the source is pulled into the destination, and the job\n * can only be canceled by reverting to the source file; progress in this\n * phase can be tracked via the virDomainBlockJobInfo() command, with a\n * job type of VIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the\n * second phase when the job info states cur == end, and remains alive to\n * mirror all further changes to both source and destination.  The user\n * must call virDomainBlockJobAbort() to end the mirroring while choosing\n * whether to revert to source or pivot to the destination.  An event is\n * issued when the job ends, and depending on the hypervisor, an event may\n * also be issued when the job transitions from pulling to mirroring.  If\n * the job is aborted, a new job will have to start over from the beginning\n * of the first phase.\n *\n * Some hypervisors will restrict certain actions, such as virDomainSave()\n * or virDomainDetachDevice(), while a copy job is active; they may\n * also restrict a copy job to transient domains.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The @base parameter can be either a path to a file within the backing\n * chain, or the device target shorthand (the <target dev='...'/>\n * sub-element, such as \"vda\") followed by an index to the backing chain\n * enclosed in square brackets. Backing chain indexes can be found by\n * inspecting //disk//backingStore/@index in the domain XML. Thus, for\n * example, \"vda[3]\" refers to the backing store with index equal to \"3\"\n * in the chain of disk \"vda\".\n *\n * The maximum bandwidth that will be used to do the copy can be\n * specified with the @bandwidth parameter.  If set to 0, there is no\n * limit.  If @flags includes VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES,\n * @bandwidth is in bytes/second; otherwise, it is in MiB/second.\n * Values larger than 2^52 bytes/sec may be rejected due to overflow\n * considerations based on the word size of both client and server,\n * and values larger than 2^31 bytes/sec may cause overflow problems\n * if later queried by virDomainGetBlockJobInfo() without scaling.\n * Hypervisors may further restrict the range of valid bandwidth\n * values.  Some hypervisors do not support this feature and will\n * return an error if bandwidth is not 0; in this case, it might still\n * be possible for a later call to virDomainBlockJobSetSpeed() to\n * succeed.  The actual speed can be determined with\n * virDomainGetBlockJobInfo().\n *\n * When @base is NULL and @flags is 0, this is identical to\n * virDomainBlockPull().  When @flags contains VIR_DOMAIN_BLOCK_REBASE_COPY,\n * this command is shorthand for virDomainBlockCopy() where the destination\n * XML encodes @base as a <disk type='file'>, @bandwidth is properly scaled\n * and passed as a typed parameter, the shallow and reuse external flags\n * are preserved, and remaining flags control whether the XML encodes a\n * destination format of raw instead of leaving the destination identical\n * to the source format or probed from the reused file.\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockRebase(virDomainPtr dom, const char *disk,\n                     const char *base, unsigned long bandwidth,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, base=%s, bandwidth=%lu, flags=%x\",\n                     disk, NULLSTR(base), bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (flags & VIR_DOMAIN_BLOCK_REBASE_COPY) {\n        virCheckNonNullArgGoto(base, error);\n    } else if (flags & (VIR_DOMAIN_BLOCK_REBASE_SHALLOW |\n                        VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT |\n                        VIR_DOMAIN_BLOCK_REBASE_COPY_RAW |\n                        VIR_DOMAIN_BLOCK_REBASE_COPY_DEV)) {\n        virReportInvalidArg(flags, \"%s\",\n                            _(\"use of flags requires a copy job\"));\n        goto error;\n    }\n\n    if (conn->driver->domainBlockRebase) {\n        int ret;\n        ret = conn->driver->domainBlockRebase(dom, disk, base, bandwidth,\n                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockCopy:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @destxml: XML description of the copy destination\n * @params: Pointer to block copy parameter objects, or NULL\n * @nparams: Number of block copy parameters (this value can be the same or\n *           less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainBlockCopyFlags\n *\n * Copy the guest-visible contents of a disk image to a new file described\n * by @destxml.  The destination XML has a top-level element of <disk>, and\n * resembles what is used when hot-plugging a disk via virDomainAttachDevice(),\n * except that only sub-elements related to describing the new host resource\n * are necessary (sub-elements related to the guest view, such as <target>,\n * are ignored).  It is strongly recommended to include a <driver type='...'/>\n * format designation for the destination, to avoid the potential of any\n * security problem that might be caused by probing a file for its format.\n *\n * This command starts a long-running copy.  By default, the copy will pull\n * the entire source chain into the destination file, but if @flags also\n * contains VIR_DOMAIN_BLOCK_COPY_SHALLOW, then only the top of the source\n * chain will be copied (the source and destination have a common backing\n * file).  The format of the destination file is controlled by the <driver>\n * sub-element of the XML.  The destination will be created unless the\n * VIR_DOMAIN_BLOCK_COPY_REUSE_EXT flag is present stating that the file\n * was pre-created with the correct format and metadata and sufficient\n * size to hold the copy. In case the VIR_DOMAIN_BLOCK_COPY_SHALLOW flag\n * is used the pre-created file has to exhibit the same guest visible contents\n * as the backing file of the original image. This allows a management app to\n * pre-create files with relative backing file names, rather than the default\n * of absolute backing file names.\n *\n * A copy job has two parts; in the first phase, the source is copied into\n * the destination, and the job can only be canceled by reverting to the\n * source file; progress in this phase can be tracked via the\n * virDomainBlockJobInfo() command, with a job type of\n * VIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the second\n * phase when the job info states cur == end, and remains alive to mirror\n * all further changes to both source and destination.  The user must\n * call virDomainBlockJobAbort() to end the mirroring while choosing\n * whether to revert to source or pivot to the destination.  An event is\n * issued when the job ends, and depending on the hypervisor, an event may\n * also be issued when the job transitions from pulling to mirroring.  If\n * the job is aborted, a new job will have to start over from the beginning\n * of the first phase.\n *\n * Some hypervisors will restrict certain actions, such as virDomainSave()\n * or virDomainDetachDevice(), while a copy job is active; they may\n * also restrict a copy job to transient domains.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The @params and @nparams arguments can be used to set hypervisor-specific\n * tuning parameters, such as maximum bandwidth or granularity.  For a\n * parameter that the hypervisor understands, explicitly specifying 0\n * behaves the same as omitting the parameter, to use the hypervisor\n * default; however, omitting a parameter is less likely to fail.\n *\n * This command is a superset of the older virDomainBlockRebase() when used\n * with the VIR_DOMAIN_BLOCK_REBASE_COPY flag, and offers better control\n * over the destination format, the ability to copy to a destination that\n * is not a local file, and the possibility of additional tuning parameters.\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockCopy(virDomainPtr dom, const char *disk,\n                   const char *destxml,\n                   virTypedParameterPtr params,\n                   int nparams,\n                   unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom,\n                     \"disk=%s, destxml=%s, params=%p, nparams=%d, flags=%x\",\n                     disk, destxml, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckNonNullArgGoto(destxml, error);\n    virCheckNonNegativeArgGoto(nparams, error);\n    if (nparams)\n        virCheckNonNullArgGoto(params, error);\n\n    if (conn->driver->domainBlockCopy) {\n        int ret;\n        ret = conn->driver->domainBlockCopy(dom, disk, destxml,\n                                            params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainBlockCommit:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @base: path to backing file to merge into, or device shorthand,\n *        or NULL for default\n * @top: path to file within backing chain that contains data to be merged,\n *       or device shorthand, or NULL to merge all possible data\n * @bandwidth: (optional) specify bandwidth limit; flags determine the unit\n * @flags: bitwise-OR of virDomainBlockCommitFlags\n *\n * Commit changes that were made to temporary top-level files within a disk\n * image backing file chain into a lower-level base file.  In other words,\n * take all the difference between @base and @top, and update @base to contain\n * that difference; after the commit, any portion of the chain that previously\n * depended on @top will now depend on @base, and all files after @base up\n * to and including @top will now be invalidated.  A typical use of this\n * command is to reduce the length of a backing file chain after taking an\n * external disk snapshot.  To move data in the opposite direction, see\n * virDomainBlockPull().\n *\n * This command starts a long-running commit block job, whose status may\n * be tracked by virDomainBlockJobInfo() with a job type of\n * VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT, and the operation can be aborted with\n * virDomainBlockJobAbort().  When finished, an asynchronous event is\n * raised to indicate the final status, and the job no longer exists.  If\n * the job is aborted, it is up to the hypervisor whether starting a new\n * job will resume from the same point, or start over.\n *\n * As a special case, if @top is the active image (or NULL), and @flags\n * includes VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, the block job will have a type\n * of VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT, and operates in two phases.\n * In the first phase, the contents are being committed into @base, and the\n * job can only be canceled.  The job transitions to the second phase when\n * the job info states cur == end, and remains alive to keep all further\n * changes to @top synchronized into @base; an event with status\n * VIR_DOMAIN_BLOCK_JOB_READY is also issued to mark the job transition.\n * Once in the second phase, the user must choose whether to cancel the job\n * (keeping @top as the active image, but now containing only the changes\n * since the time the job ended) or to pivot the job (adjusting to @base as\n * the active image, and invalidating @top).\n *\n * Be aware that this command may invalidate files even if it is aborted;\n * the user is cautioned against relying on the contents of invalidated\n * intermediate files such as @top (when @top is not the active image)\n * without manually rebasing those files to use a backing file of a\n * read-only copy of @base prior to the point where the commit operation\n * was started (and such a rebase cannot be safely done until the commit\n * has successfully completed).  However, the domain itself will not have\n * any issues; the active layer remains valid throughout the entire commit\n * operation.\n *\n * Some hypervisors may support a shortcut where if @flags contains\n * VIR_DOMAIN_BLOCK_COMMIT_DELETE, then this command will unlink all files\n * that were invalidated, after the commit successfully completes.\n *\n * If @flags contains VIR_DOMAIN_BLOCK_COMMIT_RELATIVE, the name recorded\n * into the overlay of the @top image (if there is such image) as the\n * path to the new backing file will be kept relative to other images.\n * The operation will fail if libvirt can't infer the name.\n *\n * By default, if @base is NULL, the commit target will be the bottom of\n * the backing chain; if @flags contains VIR_DOMAIN_BLOCK_COMMIT_SHALLOW,\n * then the immediate backing file of @top will be used instead.  If @top\n * is NULL, the active image at the top of the chain will be used.  Some\n * hypervisors place restrictions on how much can be committed, and might\n * fail if @base is not the immediate backing file of @top, or if @top is\n * the active layer in use by a running domain but @flags did not include\n * VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, or if @top is not the top-most file;\n * restrictions may differ for online vs. offline domains.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the\n * <target dev='...'/> sub-element, such as \"vda\").  Valid names\n * can be found by calling virDomainGetXMLDesc() and inspecting\n * elements within //domain/devices/disk.\n *\n * The @base and @top parameters can be either paths to files within the\n * backing chain, or the device target shorthand (the <target dev='...'/>\n * sub-element, such as \"vda\") followed by an index to the backing chain\n * enclosed in square brackets. Backing chain indexes can be found by\n * inspecting //disk//backingStore/@index in the domain XML. Thus, for\n * example, \"vda[3]\" refers to the backing store with index equal to \"3\"\n * in the chain of disk \"vda\".\n *\n * The maximum bandwidth that will be used to do the commit can be\n * specified with the @bandwidth parameter.  If set to 0, there is no\n * limit.  If @flags includes VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES,\n * @bandwidth is in bytes/second; otherwise, it is in MiB/second.\n * Values larger than 2^52 bytes/sec may be rejected due to overflow\n * considerations based on the word size of both client and server,\n * and values larger than 2^31 bytes/sec may cause overflow problems\n * if later queried by virDomainGetBlockJobInfo() without scaling.\n * Hypervisors may further restrict the range of valid bandwidth\n * values.  Some hypervisors do not support this feature and will\n * return an error if bandwidth is not 0; in this case, it might still\n * be possible for a later call to virDomainBlockJobSetSpeed() to\n * succeed.  The actual speed can be determined with\n * virDomainGetBlockJobInfo().\n *\n * Returns 0 if the operation has started, -1 on failure.\n */\nint\nvirDomainBlockCommit(virDomainPtr dom, const char *disk,\n                     const char *base, const char *top,\n                     unsigned long bandwidth, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, base=%s, top=%s, bandwidth=%lu, flags=%x\",\n                     disk, NULLSTR(base), NULLSTR(top), bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (conn->driver->domainBlockCommit) {\n        int ret;\n        ret = conn->driver->domainBlockCommit(dom, disk, base, top, bandwidth,\n                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainOpenGraphics:\n * @dom: pointer to domain object\n * @idx: index of graphics config to open\n * @fd: file descriptor to attach graphics to\n * @flags: bitwise-OR of virDomainOpenGraphicsFlags\n *\n * This will attempt to connect the file descriptor @fd, to\n * the graphics backend of @dom. If @dom has multiple graphics\n * backends configured, then @idx will determine which one is\n * opened, starting from @idx 0.\n *\n * To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH\n * constant for @flags.\n *\n * The caller should use an anonymous socketpair to open\n * @fd before invocation.\n *\n * This method can only be used when connected to a local\n * libvirt hypervisor, over a UNIX domain socket. Attempts\n * to use this method over a TCP connection will always fail\n *\n * Returns 0 on success, -1 on failure\n */\nint\nvirDomainOpenGraphics(virDomainPtr dom,\n                      unsigned int idx,\n                      int fd,\n                      unsigned int flags)\n{\n    struct stat sb;\n    VIR_DOMAIN_DEBUG(dom, \"idx=%u, fd=%d, flags=%x\",\n                     idx, fd, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNegativeArgGoto(fd, error);\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access file descriptor %d\"), fd);\n        goto error;\n    }\n\n    if (!S_ISSOCK(sb.st_mode)) {\n        virReportInvalidArg(fd,\n                            _(\"fd %d must be a socket\"),\n                            fd);\n        goto error;\n    }\n\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (!VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                  VIR_DRV_FEATURE_FD_PASSING)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"fd passing is not supported by this connection\"));\n        goto error;\n    }\n\n    if (dom->conn->driver->domainOpenGraphics) {\n        int ret;\n        ret = dom->conn->driver->domainOpenGraphics(dom, idx, fd, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainOpenGraphicsFD:\n * @dom: pointer to domain object\n * @idx: index of graphics config to open\n * @flags: bitwise-OR of virDomainOpenGraphicsFlags\n *\n * This will create a socket pair connected to the graphics backend of @dom.\n * One end of the socket will be returned on success, and the other end is\n * handed to the hypervisor.\n * If @dom has multiple graphics backends configured, then @idx will determine\n * which one is opened, starting from @idx 0.\n *\n * To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH\n * constant for @flags.\n *\n * This method can only be used when connected to a local\n * libvirt hypervisor, over a UNIX domain socket. Attempts\n * to use this method over a TCP connection will always fail.\n *\n * Returns an fd on success, -1 on failure\n */\nint\nvirDomainOpenGraphicsFD(virDomainPtr dom,\n                        unsigned int idx,\n                        unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"idx=%u, flags=%x\", idx, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (!VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                  VIR_DRV_FEATURE_FD_PASSING)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"fd passing is not supported by this connection\"));\n        goto error;\n    }\n\n    if (dom->conn->driver->domainOpenGraphicsFD) {\n        int ret;\n        ret = dom->conn->driver->domainOpenGraphicsFD(dom, idx, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetBlockIoTune:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @params: Pointer to blkio parameter objects\n * @nparams: Number of blkio parameters (this value can be the same or\n *           less than the number of parameters supported)\n * @flags: bitwise-OR of virDomainModificationImpact\n *\n * Change all or a subset of the per-device block IO tunables.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the <target\n * dev='...'/> sub-element, such as \"xvda\").  Valid names can be found\n * by calling virDomainGetXMLDesc() and inspecting elements\n * within //domain/devices/disk.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainSetBlockIoTune(virDomainPtr dom,\n                        const char *disk,\n                        virTypedParameterPtr params,\n                        int nparams,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, params=%p, nparams=%d, flags=%x\",\n                     disk, params, nparams, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n    virCheckPositiveArgGoto(nparams, error);\n    virCheckNonNullArgGoto(params, error);\n\n    if (virTypedParameterValidateSet(dom->conn, params, nparams) < 0)\n        goto error;\n\n    if (conn->driver->domainSetBlockIoTune) {\n        int ret;\n        ret = conn->driver->domainSetBlockIoTune(dom, disk, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetBlockIoTune:\n * @dom: pointer to domain object\n * @disk: path to the block device, or device shorthand\n * @params: Pointer to blkio parameter object\n *          (return value, allocated by the caller)\n * @nparams: Pointer to number of blkio parameters\n * @flags: bitwise-OR of virDomainModificationImpact and virTypedParameterFlags\n *\n * Get all block IO tunable parameters for a given device.  On input,\n * @nparams gives the size of the @params array; on output, @nparams\n * gives how many slots were filled with parameter information, which\n * might be less but will not exceed the input value.\n *\n * As a special case, calling with @params as NULL and @nparams as 0\n * on input will cause @nparams on output to contain the number of\n * parameters supported by the hypervisor, either for the given @disk\n * (note that block devices of different types might support different\n * parameters), or if @disk is NULL, for all possible disks. The\n * caller should then allocate @params array,\n * i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\n * again.  See virDomainGetMemoryParameters() for more details.\n *\n * The @disk parameter is either an unambiguous source name of the\n * block device (the <source file='...'/> sub-element, such as\n * \"/path/to/image\"), or the device target shorthand (the <target\n * dev='...'/> sub-element, such as \"xvda\").  Valid names can be found\n * by calling virDomainGetXMLDesc() and inspecting elements\n * within //domain/devices/disk.  This parameter cannot be NULL\n * unless @nparams is 0 on input.\n *\n * Returns -1 in case of error, 0 in case of success.\n */\nint\nvirDomainGetBlockIoTune(virDomainPtr dom,\n                        const char *disk,\n                        virTypedParameterPtr params,\n                        int *nparams,\n                        unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, params=%p, nparams=%d, flags=%x\",\n                     NULLSTR(disk), params, (nparams) ? *nparams : -1, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    virCheckNonNullArgGoto(nparams, error);\n    virCheckNonNegativeArgGoto(*nparams, error);\n    if (*nparams != 0) {\n        virCheckNonNullArgGoto(params, error);\n        virCheckNonNullArgGoto(disk, error);\n    }\n\n    if (VIR_DRV_SUPPORTS_FEATURE(dom->conn->driver, dom->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DOMAIN_AFFECT_LIVE,\n                             VIR_DOMAIN_AFFECT_CONFIG,\n                             error);\n\n    conn = dom->conn;\n\n    if (conn->driver->domainGetBlockIoTune) {\n        int ret;\n        ret = conn->driver->domainGetBlockIoTune(dom, disk, params, nparams, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetCPUStats:\n * @domain: domain to query\n * @params: array to populate on output\n * @nparams: number of parameters per cpu\n * @start_cpu: which cpu to start with, or -1 for summary\n * @ncpus: how many cpus to query\n * @flags: bitwise-OR of virTypedParameterFlags\n *\n * Get statistics relating to CPU usage attributable to a single\n * domain (in contrast to the statistics returned by\n * virNodeGetCPUStats() for all processes on the host).  @dom\n * must be running (an inactive domain has no attributable cpu\n * usage).  On input, @params must contain at least @nparams * @ncpus\n * entries, allocated by the caller.\n *\n * If @start_cpu is -1, then @ncpus must be 1, and the returned\n * results reflect the statistics attributable to the entire\n * domain (such as user and system time for the process as a\n * whole).  Otherwise, @start_cpu represents which cpu to start\n * with, and @ncpus represents how many consecutive processors to\n * query, with statistics attributable per processor (such as\n * per-cpu usage).  If @ncpus is larger than the number of cpus\n * available to query, then the trailing part of the array will\n * be unpopulated.\n *\n * The remote driver imposes a limit of 128 @ncpus and 16 @nparams;\n * the number of parameters per cpu should not exceed 16, but if you\n * have a host with more than 128 CPUs, your program should split\n * the request into multiple calls.\n *\n * As special cases, if @params is NULL and @nparams is 0 and\n * @ncpus is 1, and the return value will be how many\n * statistics are available for the given @start_cpu.  This number\n * may be different for @start_cpu of -1 than for any non-negative\n * value, but will be the same for all non-negative @start_cpu.\n * Likewise, if @params is NULL and @nparams is 0 and @ncpus is 0,\n * the number of cpus available to query is returned.  From the\n * host perspective, this would typically match the cpus member\n * of virNodeGetInfo(), but might be less due to host cpu hotplug.\n *\n * For now, @flags is unused, and the statistics all relate to the\n * usage from the host perspective.  It is possible that a future\n * version will support a flag that queries the cpu usage from the\n * guest's perspective, where the maximum cpu to query would be\n * related to virDomainGetVcpusFlags() rather than virNodeGetInfo().\n * An individual guest vcpu cannot be reliably mapped back to a\n * specific host cpu unless a single-processor vcpu pinning was used,\n * but when @start_cpu is -1, any difference in usage between a host\n * and guest perspective would serve as a measure of hypervisor overhead.\n *\n * Typical use sequence is below.\n *\n * getting total stats: set start_cpu as -1, ncpus 1\n *\n *   virDomainGetCPUStats(dom, NULL, 0, -1, 1, 0); // nparams\n *   params = calloc(nparams, sizeof(virTypedParameter))\n *   virDomainGetCPUStats(dom, params, nparams, -1, 1, 0); // total stats.\n *\n * getting per-cpu stats:\n *\n *   virDomainGetCPUStats(dom, NULL, 0, 0, 0, 0); // ncpus\n *   virDomainGetCPUStats(dom, NULL, 0, 0, 1, 0); // nparams\n *   params = calloc(ncpus * nparams, sizeof(virTypedParameter));\n *   virDomainGetCPUStats(dom, params, nparams, 0, ncpus, 0); // per-cpu stats\n *\n * Returns -1 on failure, or the number of statistics that were\n * populated per cpu on success (this will be less than the total\n * number of populated @params, unless @ncpus was 1; and may be\n * less than @nparams).  The populated parameters start at each\n * stride of @nparams, which means the results may be discontiguous;\n * any unpopulated parameters will be zeroed on success (this includes\n * skipped elements if @nparams is too large, and tail elements if\n * @ncpus is too large).  The caller is responsible for freeing any\n * returned string parameters.\n */\nint\nvirDomainGetCPUStats(virDomainPtr domain,\n                     virTypedParameterPtr params,\n                     unsigned int nparams,\n                     int start_cpu,\n                     unsigned int ncpus,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain,\n                     \"params=%p, nparams=%d, start_cpu=%d, ncpus=%u, flags=%x\",\n                     params, nparams, start_cpu, ncpus, flags);\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    /* Special cases:\n     * start_cpu must be non-negative, or else -1\n     * if start_cpu is -1, ncpus must be 1\n     * params == NULL must match nparams == 0\n     * ncpus must be non-zero unless params == NULL\n     * nparams * ncpus must not overflow (RPC may restrict it even more)\n     */\n    if (start_cpu == -1) {\n        if (ncpus != 1) {\n            virReportInvalidArg(start_cpu, \"%s\",\n                                _(\"ncpus must be 1 when start_cpu is -1\"));\n            goto error;\n        }\n    } else {\n        virCheckNonNegativeArgGoto(start_cpu, error);\n    }\n    if (nparams)\n        virCheckNonNullArgGoto(params, error);\n    else\n        virCheckNullArgGoto(params, error);\n    if (ncpus == 0)\n        virCheckNullArgGoto(params, error);\n\n    if (nparams && ncpus > UINT_MAX / nparams) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"input too large: %u * %u\"),\n                       nparams, ncpus);\n        goto error;\n    }\n    if (VIR_DRV_SUPPORTS_FEATURE(domain->conn->driver, domain->conn,\n                                 VIR_DRV_FEATURE_TYPED_PARAM_STRING))\n        flags |= VIR_TYPED_PARAM_STRING_OKAY;\n\n    if (conn->driver->domainGetCPUStats) {\n        int ret;\n\n        ret = conn->driver->domainGetCPUStats(domain, params, nparams,\n                                              start_cpu, ncpus, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetDiskErrors:\n * @dom: a domain object\n * @errors: array to populate on output\n * @maxerrors: size of @errors array\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * The function populates @errors array with all disks that encountered an\n * I/O error.  Disks with no error will not be returned in the @errors array.\n * Each disk is identified by its target (the dev attribute of target\n * subelement in domain XML), such as \"vda\", and accompanied with the error\n * that was seen on it.  The caller is also responsible for calling free()\n * on each disk name returned.\n *\n * In a special case when @errors is NULL and @maxerrors is 0, the function\n * returns preferred size of @errors that the caller should use to get all\n * disk errors.\n *\n * Since calling virDomainGetDiskErrors(dom, NULL, 0, 0) to get preferred size\n * of @errors array and getting the errors are two separate operations, new\n * disks may be hotplugged to the domain and new errors may be encountered\n * between the two calls.  Thus, this function may not return all disk errors\n * because the supplied array is not large enough.  Such errors may, however,\n * be detected by listening to domain events.\n *\n * Returns number of disks with errors filled in the @errors array or -1 on\n * error.\n */\nint\nvirDomainGetDiskErrors(virDomainPtr dom,\n                       virDomainDiskErrorPtr errors,\n                       unsigned int maxerrors,\n                       unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"errors=%p, maxerrors=%u, flags=%x\",\n                     errors, maxerrors, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (maxerrors)\n        virCheckNonNullArgGoto(errors, error);\n    else\n        virCheckNullArgGoto(errors, error);\n\n    if (dom->conn->driver->domainGetDiskErrors) {\n        int ret = dom->conn->driver->domainGetDiskErrors(dom, errors,\n                                                         maxerrors, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainGetHostname:\n * @domain: a domain object\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Get the hostname for that domain.\n *\n * Dependent on hypervisor used, this may require a guest agent to be\n * available.\n *\n * Returns the hostname which must be freed by the caller, or\n * NULL if there was an error.\n */\nchar *\nvirDomainGetHostname(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if (conn->driver->domainGetHostname) {\n        char *ret;\n        ret = conn->driver->domainGetHostname(domain, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}\n\n\n/**\n * virDomainFSTrim:\n * @dom: a domain object\n * @mountPoint: which mount point to trim\n * @minimum: Minimum contiguous free range to discard in bytes\n * @flags: extra flags, not used yet, so callers should always pass 0\n *\n * Calls FITRIM within the guest (hence guest agent may be\n * required depending on hypervisor used). Either call it on each\n * mounted filesystem (@mountPoint is NULL) or just on specified\n * @mountPoint. @minimum hints that free ranges smaller than this\n * may be ignored (this is a hint and the guest may not respect\n * it).  By increasing this value, the fstrim operation will\n * complete more quickly for filesystems with badly fragmented\n * free space, although not all blocks will be discarded.\n * If @minimum is not zero, the command may fail.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainFSTrim(virDomainPtr dom,\n                const char *mountPoint,\n                unsigned long long minimum,\n                unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"mountPoint=%s, minimum=%llu, flags=%x\",\n                     mountPoint, minimum, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainFSTrim) {\n        int ret = dom->conn->driver->domainFSTrim(dom, mountPoint,\n                                                  minimum, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainFSFreeze:\n * @dom: a domain object\n * @mountpoints: list of mount points to be frozen\n * @nmountpoints: the number of mount points specified in @mountpoints\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Freeze specified filesystems within the guest (hence guest agent\n * may be required depending on hypervisor used). If @mountpoints is NULL and\n * @nmountpoints is 0, every mounted filesystem on the guest is frozen.\n * In some environments (e.g. QEMU guest with guest agent which doesn't\n * support mountpoints argument), @mountpoints may need to be NULL.\n *\n * Returns the number of frozen filesystems on success, -1 otherwise.\n */\nint\nvirDomainFSFreeze(virDomainPtr dom,\n                  const char **mountpoints,\n                  unsigned int nmountpoints,\n                  unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"mountpoints=%p, nmountpoints=%d, flags=%x\",\n                     mountpoints, nmountpoints, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    if (nmountpoints)\n        virCheckNonNullArgGoto(mountpoints, error);\n    else\n        virCheckNullArgGoto(mountpoints, error);\n\n    if (dom->conn->driver->domainFSFreeze) {\n        int ret = dom->conn->driver->domainFSFreeze(\n            dom, mountpoints, nmountpoints, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainFSThaw:\n * @dom: a domain object\n * @mountpoints: list of mount points to be thawed\n * @nmountpoints: the number of mount points specified in @mountpoints\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Thaw specified filesystems within the guest. If @mountpoints is NULL and\n * @nmountpoints is 0, every mounted filesystem on the guest is thawed.\n * In some drivers (e.g. QEMU driver), @mountpoints may need to be NULL.\n *\n * Returns the number of thawed filesystems on success, -1 otherwise.\n */\nint\nvirDomainFSThaw(virDomainPtr dom,\n                const char **mountpoints,\n                unsigned int nmountpoints,\n                unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    if (nmountpoints)\n        virCheckNonNullArgGoto(mountpoints, error);\n    else\n        virCheckNullArgGoto(mountpoints, error);\n\n    if (dom->conn->driver->domainFSThaw) {\n        int ret = dom->conn->driver->domainFSThaw(\n            dom, mountpoints, nmountpoints, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainGetTime:\n * @dom: a domain object\n * @seconds: domain's time in seconds\n * @nseconds: the nanoscond part of @seconds\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Extract information about guest time and store it into\n * @seconds and @nseconds. The @seconds represents the number of\n * seconds since the UNIX Epoch of 1970-01-01 00:00:00 in UTC.\n *\n * Please note that some hypervisors may require guest agent to\n * be configured and running in order to run this API.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n/**\n * virDomainSetTime:\n * @dom: a domain object\n * @seconds: time to set\n * @nseconds: the nanosecond part of @seconds\n * @flags: bitwise-OR of virDomainSetTimeFlags\n *\n * When a domain is suspended or restored from a file the\n * domain's OS has no idea that there was a big gap in the time.\n * Depending on how long the gap was, NTP might not be able to\n * resynchronize the guest.\n *\n * This API tries to set guest time to the given value. The time\n * to set (@seconds and @nseconds) should be in seconds relative\n * to the Epoch of 1970-01-01 00:00:00 in UTC.\n *\n * Please note that some hypervisors may require guest agent to\n * be configured and running in order to be able to run this API.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainSetTime(virDomainPtr dom,\n                 long long seconds,\n                 unsigned int nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%lld, nseconds=%u, flags=%x\",\n                     seconds, nseconds, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainSetTime) {\n        int ret = dom->conn->driver->domainSetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainSetUserPassword:\n * @dom: a domain object\n * @user: the username that will get a new password\n * @password: the password to set\n * @flags: bitwise-OR of virDomainSetUserPasswordFlags\n *\n * Sets the @user password to the value specified by @password.\n * If @flags contain VIR_DOMAIN_PASSWORD_ENCRYPTED, the password\n * is assumed to be encrypted by the method required by the guest OS.\n *\n * Please note that some hypervisors may require guest agent to\n * be configured and running in order to be able to run this API.\n *\n * Returns 0 on success, -1 otherwise.\n */\nint\nvirDomainSetUserPassword(virDomainPtr dom,\n                         const char *user,\n                         const char *password,\n                         unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"user=%s, password=%s, flags=%x\",\n                     NULLSTR(user), NULLSTR(password), flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    virCheckNonNullArgGoto(user, error);\n    virCheckNonNullArgGoto(password, error);\n\n    if (dom->conn->driver->domainSetUserPassword) {\n        int ret = dom->conn->driver->domainSetUserPassword(dom, user, password,\n                                                           flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virConnectGetDomainCapabilities:\n * @conn: pointer to the hypervisor connection\n * @emulatorbin: path to emulator\n * @arch: domain architecture\n * @machine: machine type\n * @virttype: virtualization type\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Prior creating a domain (for instance via virDomainCreateXML\n * or virDomainDefineXML) it may be suitable to know what the\n * underlying emulator and/or libvirt is capable of. For\n * instance, if host, libvirt and qemu is capable of VFIO\n * passthrough and so on.\n *\n * Returns NULL in case of error or an XML string\n * defining the capabilities.\n */\nchar *\nvirConnectGetDomainCapabilities(virConnectPtr conn,\n                                const char *emulatorbin,\n                                const char *arch,\n                                const char *machine,\n                                const char *virttype,\n                                unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, emulatorbin=%s, arch=%s, \"\n              \"machine=%s, virttype=%s, flags=%x\",\n              conn, NULLSTR(emulatorbin), NULLSTR(arch),\n              NULLSTR(machine), NULLSTR(virttype), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    if (conn->driver->connectGetDomainCapabilities) {\n        char *ret;\n        ret = conn->driver->connectGetDomainCapabilities(conn, emulatorbin,\n                                                         arch, machine,\n                                                         virttype, flags);\n        if (!ret)\n            goto error;\n        VIR_DEBUG(\"conn=%p, ret=%s\", conn, ret);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n\n\n/**\n * virConnectGetAllDomainStats:\n * @conn: pointer to the hypervisor connection\n * @stats: stats to return, binary-OR of virDomainStatsTypes\n * @retStats: Pointer that will be filled with the array of returned stats\n * @flags: extra flags; binary-OR of virConnectGetAllDomainStatsFlags\n *\n * Query statistics for all domains on a given connection.\n *\n * Report statistics of various parameters for a running VM according to @stats\n * field. The statistics are returned as an array of structures for each queried\n * domain. The structure contains an array of typed parameters containing the\n * individual statistics. The typed parameter name for each statistic field\n * consists of a dot-separated string containing name of the requested group\n * followed by a group specific description of the statistic value.\n *\n * The statistic groups are enabled using the @stats parameter which is a\n * binary-OR of enum virDomainStatsTypes. The following groups are available\n * (although not necessarily implemented for each hypervisor):\n *\n * VIR_DOMAIN_STATS_STATE: Return domain state and reason for entering that\n * state. The typed parameter keys are in this format:\n * \"state.state\" - state of the VM, returned as int from virDomainState enum\n * \"state.reason\" - reason for entering given state, returned as int from\n *                  virDomain*Reason enum corresponding to given state.\n *\n * VIR_DOMAIN_STATS_CPU_TOTAL: Return CPU statistics and usage information.\n * The typed parameter keys are in this format:\n * \"cpu.time\" - total cpu time spent for this domain in nanoseconds\n *              as unsigned long long.\n * \"cpu.user\" - user cpu time spent in nanoseconds as unsigned long long.\n * \"cpu.system\" - system cpu time spent in nanoseconds as unsigned long long.\n *\n * VIR_DOMAIN_STATS_BALLOON: Return memory balloon device information.\n * The typed parameter keys are in this format:\n * \"balloon.current\" - the memory in kiB currently used\n *                     as unsigned long long.\n * \"balloon.maximum\" - the maximum memory in kiB allowed\n *                     as unsigned long long.\n *\n * VIR_DOMAIN_STATS_VCPU: Return virtual CPU statistics.\n * Due to VCPU hotplug, the vcpu.<num>.* array could be sparse.\n * The actual size of the array corresponds to \"vcpu.current\".\n * The array size will never exceed \"vcpu.maximum\".\n * The typed parameter keys are in this format:\n * \"vcpu.current\" - current number of online virtual CPUs as unsigned int.\n * \"vcpu.maximum\" - maximum number of online virtual CPUs as unsigned int.\n * \"vcpu.<num>.state\" - state of the virtual CPU <num>, as int\n *                      from virVcpuState enum.\n * \"vcpu.<num>.time\" - virtual cpu time spent by virtual CPU <num>\n *                     as unsigned long long.\n *\n * VIR_DOMAIN_STATS_INTERFACE: Return network interface statistics.\n * The typed parameter keys are in this format:\n * \"net.count\" - number of network interfaces on this domain\n *               as unsigned int.\n * \"net.<num>.name\" - name of the interface <num> as string.\n * \"net.<num>.rx.bytes\" - bytes received as unsigned long long.\n * \"net.<num>.rx.pkts\" - packets received as unsigned long long.\n * \"net.<num>.rx.errs\" - receive errors as unsigned long long.\n * \"net.<num>.rx.drop\" - receive packets dropped as unsigned long long.\n * \"net.<num>.tx.bytes\" - bytes transmitted as unsigned long long.\n * \"net.<num>.tx.pkts\" - packets transmitted as unsigned long long.\n * \"net.<num>.tx.errs\" - transmission errors as unsigned long long.\n * \"net.<num>.tx.drop\" - transmit packets dropped as unsigned long long.\n *\n * VIR_DOMAIN_STATS_BLOCK: Return block devices statistics.  By default,\n * this information is limited to the active layer of each <disk> of the\n * domain (where block.count is equal to the number of disks), but adding\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING to @flags will expand the\n * array to cover backing chains (block.count corresponds to the number\n * of host resources used together to provide the guest disks).\n * The typed parameter keys are in this format:\n * \"block.count\" - number of block devices in the subsequent list,\n *                 as unsigned int.\n * \"block.<num>.name\" - name of the block device <num> as string.\n *                      matches the target name (vda/sda/hda) of the\n *                      block device.  If the backing chain is listed,\n *                      this name is the same for all host resources tied\n *                      to the same guest device.\n * \"block.<num>.backingIndex\" - unsigned int giving the <backingStore> index,\n *                              only used when backing images are listed.\n * \"block.<num>.path\" - string describing the source of block device <num>,\n *                      if it is a file or block device (omitted for network\n *                      sources and drives with no media inserted).\n * \"block.<num>.rd.reqs\" - number of read requests as unsigned long long.\n * \"block.<num>.rd.bytes\" - number of read bytes as unsigned long long.\n * \"block.<num>.rd.times\" - total time (ns) spent on reads as\n *                          unsigned long long.\n * \"block.<num>.wr.reqs\" - number of write requests as unsigned long long.\n * \"block.<num>.wr.bytes\" - number of written bytes as unsigned long long.\n * \"block.<num>.wr.times\" - total time (ns) spent on writes as\n *                          unsigned long long.\n * \"block.<num>.fl.reqs\" - total flush requests as unsigned long long.\n * \"block.<num>.fl.times\" - total time (ns) spent on cache flushing as\n *                          unsigned long long.\n * \"block.<num>.errors\" - Xen only: the 'oo_req' value as\n *                        unsigned long long.\n * \"block.<num>.allocation\" - offset of the highest written sector\n *                            as unsigned long long.\n * \"block.<num>.capacity\" - logical size in bytes of the block device backing\n *                          image as unsigned long long.\n * \"block.<num>.physical\" - physical size in bytes of the container of the\n *                          backing image as unsigned long long.\n *\n * Note that entire stats groups or individual stat fields may be missing from\n * the output in case they are not supported by the given hypervisor, are not\n * applicable for the current state of the guest domain, or their retrieval\n * was not successful.\n *\n * Using 0 for @stats returns all stats groups supported by the given\n * hypervisor.\n *\n * Specifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes\n * the function return error in case some of the stat types in @stats were\n * not recognized by the daemon.  However, even with this flag, a hypervisor\n * may omit individual fields within a known group if the information is not\n * available; as an extreme example, a supported group may produce zero\n * fields for offline domains if the statistics are meaningful only for a\n * running domain.\n *\n * Similarly to virConnectListAllDomains, @flags can contain various flags to\n * filter the list of domains to provide stats for.\n *\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE selects online domains while\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE selects offline ones.\n *\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT and\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT allow to filter the list\n * according to their persistence.\n *\n * To filter the list of VMs by domain state @flags can contain\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING,\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED,\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF and/or\n * VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER for all other states.\n *\n * Returns the count of returned statistics structures on success, -1 on error.\n * The requested data are returned in the @retStats parameter. The returned\n * array should be freed by the caller. See virDomainStatsRecordListFree.\n */\nint\nvirConnectGetAllDomainStats(virConnectPtr conn,\n                            unsigned int stats,\n                            virDomainStatsRecordPtr **retStats,\n                            unsigned int flags)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"conn=%p, stats=0x%x, retStats=%p, flags=0x%x\",\n              conn, stats, retStats, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(retStats, cleanup);\n\n    if (!conn->driver->connectGetAllDomainStats) {\n        virReportUnsupportedError();\n        goto cleanup;\n    }\n\n    ret = conn->driver->connectGetAllDomainStats(conn, NULL, 0, stats,\n                                                 retStats, flags);\n\n cleanup:\n    if (ret < 0)\n        virDispatchError(conn);\n\n    return ret;\n}\n\n\n/**\n * virDomainListGetStats:\n * @doms: NULL terminated array of domains\n * @stats: stats to return, binary-OR of virDomainStatsTypes\n * @retStats: Pointer that will be filled with the array of returned stats\n * @flags: extra flags; binary-OR of virConnectGetAllDomainStatsFlags\n *\n * Query statistics for domains provided by @doms. Note that all domains in\n * @doms must share the same connection.\n *\n * Report statistics of various parameters for a running VM according to @stats\n * field. The statistics are returned as an array of structures for each queried\n * domain. The structure contains an array of typed parameters containing the\n * individual statistics. The typed parameter name for each statistic field\n * consists of a dot-separated string containing name of the requested group\n * followed by a group specific description of the statistic value.\n *\n * The statistic groups are enabled using the @stats parameter which is a\n * binary-OR of enum virDomainStatsTypes. The stats groups are documented\n * in virConnectGetAllDomainStats.\n *\n * Using 0 for @stats returns all stats groups supported by the given\n * hypervisor.\n *\n * Specifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes\n * the function return error in case some of the stat types in @stats were\n * not recognized by the daemon.  However, even with this flag, a hypervisor\n * may omit individual fields within a known group if the information is not\n * available; as an extreme example, a supported group may produce zero\n * fields for offline domains if the statistics are meaningful only for a\n * running domain.\n *\n * Note that any of the domain list filtering flags in @flags may be rejected\n * by this function.\n *\n * Returns the count of returned statistics structures on success, -1 on error.\n * The requested data are returned in the @retStats parameter. The returned\n * array should be freed by the caller. See virDomainStatsRecordListFree.\n * Note that the count of returned stats may be less than the domain count\n * provided via @doms.\n */\nint\nvirDomainListGetStats(virDomainPtr *doms,\n                      unsigned int stats,\n                      virDomainStatsRecordPtr **retStats,\n                      unsigned int flags)\n{\n    virConnectPtr conn = NULL;\n    virDomainPtr *nextdom = doms;\n    unsigned int ndoms = 0;\n    int ret = -1;\n\n    VIR_DEBUG(\"doms=%p, stats=0x%x, retStats=%p, flags=0x%x\",\n              doms, stats, retStats, flags);\n\n    virResetLastError();\n\n    virCheckNonNullArgGoto(doms, cleanup);\n    virCheckNonNullArgGoto(retStats, cleanup);\n\n    if (!*doms) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"doms array in %s must contain at least one domain\"),\n                       __FUNCTION__);\n        goto cleanup;\n    }\n\n    conn = doms[0]->conn;\n    virCheckConnectReturn(conn, -1);\n\n    if (!conn->driver->connectGetAllDomainStats) {\n        virReportUnsupportedError();\n        goto cleanup;\n    }\n\n    while (*nextdom) {\n        virDomainPtr dom = *nextdom;\n\n        virCheckDomainGoto(dom, cleanup);\n\n        if (dom->conn != conn) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"domains in 'doms' array must belong to a \"\n                             \"single connection\"));\n            goto cleanup;\n        }\n\n        ndoms++;\n        nextdom++;\n    }\n\n    ret = conn->driver->connectGetAllDomainStats(conn, doms, ndoms,\n                                                 stats, retStats, flags);\n\n cleanup:\n    if (ret < 0)\n        virDispatchError(conn);\n    return ret;\n}\n\n\n/**\n * virDomainStatsRecordListFree:\n * @stats: NULL terminated array of virDomainStatsRecords to free\n *\n * Convenience function to free a list of domain stats returned by\n * virDomainListGetStats and virConnectGetAllDomainStats.\n */\nvoid\nvirDomainStatsRecordListFree(virDomainStatsRecordPtr *stats)\n{\n    virDomainStatsRecordPtr *next;\n\n    if (!stats)\n        return;\n\n    for (next = stats; *next; next++) {\n        virTypedParamsFree((*next)->params, (*next)->nparams);\n        virDomainFree((*next)->dom);\n        VIR_FREE(*next);\n    }\n\n    VIR_FREE(stats);\n}\n\n\n/**\n * virDomainGetFSInfo:\n * @dom: a domain object\n * @info: a pointer to a variable to store an array of mount points information\n * @flags: extra flags; not used yet, so callers should always pass 0\n *\n * Get a list of mapping information for each mounted file systems within the\n * specified guest and the disks.\n *\n * Returns the number of returned mount points, or -1 in case of error.\n * On success, the array of the information is stored into @info. The caller is\n * responsible for calling virDomainFSInfoFree() on each array element, then\n * calling free() on @info. On error, @info is set to NULL.\n */\nint\nvirDomainGetFSInfo(virDomainPtr dom,\n                   virDomainFSInfoPtr **info,\n                   unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"info=%p, flags=%x\", info, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    virCheckNonNullArgGoto(info, error);\n    *info = NULL;\n\n    if (dom->conn->driver->domainGetFSInfo) {\n        int ret = dom->conn->driver->domainGetFSInfo(dom, info, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainFSInfoFree:\n * @info: pointer to a FSInfo object\n *\n * Frees all the memory occupied by @info.\n */\nvoid\nvirDomainFSInfoFree(virDomainFSInfoPtr info)\n{\n    size_t i;\n\n    if (!info)\n        return;\n\n    VIR_FREE(info->mountpoint);\n    VIR_FREE(info->name);\n    VIR_FREE(info->fstype);\n\n    for (i = 0; i < info->ndevAlias; i++)\n        VIR_FREE(info->devAlias[i]);\n    VIR_FREE(info->devAlias);\n\n    VIR_FREE(info);\n}\n\n/**\n * virDomainInterfaceAddresses:\n * @dom: domain object\n * @ifaces: pointer to an array of pointers pointing to interface objects\n * @source: one of the virDomainInterfaceAddressesSource constants\n * @flags: currently unused, pass zero\n *\n * Return a pointer to the allocated array of pointers to interfaces\n * present in given domain along with their IP and MAC addresses. Note that\n * single interface can have multiple or even 0 IP addresses.\n *\n * This API dynamically allocates the virDomainInterfacePtr struct based on\n * how many interfaces domain @dom has, usually there's 1:1 correlation. The\n * count of the interfaces is returned as the return value.\n *\n * If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE, the DHCP lease\n * file associated with any virtual networks will be examined to obtain\n * the interface addresses. This only returns data for interfaces which\n * are connected to virtual networks managed by libvirt.\n *\n * If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT, a configured\n * guest agent is needed for successful return from this API. Moreover, if\n * guest agent is used then the interface name is the one seen by guest OS.\n * To match such interface with the one from @dom XML use MAC address or IP\n * range.\n *\n * @ifaces->name and @ifaces->hwaddr are never NULL.\n *\n * The caller *must* free @ifaces when no longer needed. Usual use case\n * looks like this:\n *\n *  virDomainInterfacePtr *ifaces = NULL;\n *  int ifaces_count = 0;\n *  size_t i, j;\n *  virDomainPtr dom = ... obtain a domain here ...;\n *\n *  if ((ifaces_count = virDomainInterfaceAddresses(dom, &ifaces,\n *           VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE)) < 0)\n *      goto cleanup;\n *\n *  ... do something with returned values, for example:\n *  for (i = 0; i < ifaces_count; i++) {\n *      printf(\"name: %s\", ifaces[i]->name);\n *      if (ifaces[i]->hwaddr)\n *          printf(\" hwaddr: %s\", ifaces[i]->hwaddr);\n *\n *      for (j = 0; j < ifaces[i]->naddrs; j++) {\n *          virDomainIPAddressPtr ip_addr = ifaces[i]->addrs + j;\n *          printf(\"[addr: %s prefix: %d type: %d]\",\n *                 ip_addr->addr, ip_addr->prefix, ip_addr->type);\n *      }\n *      printf(\"\\n\");\n *  }\n *\n *  cleanup:\n *      if (ifaces && ifaces_count > 0)\n *          for (i = 0; i < ifaces_count; i++)\n *              virDomainInterfaceFree(ifaces[i]);\n *      free(ifaces);\n *\n * Returns the number of interfaces on success, -1 in case of error.\n */\nint\nvirDomainInterfaceAddresses(virDomainPtr dom,\n                            virDomainInterfacePtr **ifaces,\n                            unsigned int source,\n                            unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"ifaces=%p, source=%d, flags=%x\", ifaces, source, flags);\n\n    virResetLastError();\n\n    if (ifaces)\n        *ifaces = NULL;\n    virCheckDomainReturn(dom, -1);\n    virCheckNonNullArgGoto(ifaces, error);\n    if (source == VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT)\n        virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainInterfaceAddresses) {\n        int ret;\n        ret = dom->conn->driver->domainInterfaceAddresses(dom, ifaces, source, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportError(VIR_ERR_NO_SUPPORT, __FUNCTION__);\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n\n\n/**\n * virDomainInterfaceFree:\n * @iface: an interface object\n *\n * Free the interface object. The data structure is\n * freed and should not be used thereafter. If @iface\n * is NULL, then this method has no effect.\n */\nvoid\nvirDomainInterfaceFree(virDomainInterfacePtr iface)\n{\n    size_t i;\n\n    if (!iface)\n        return;\n\n    VIR_FREE(iface->name);\n    VIR_FREE(iface->hwaddr);\n\n    for (i = 0; i < iface->naddrs; i++)\n        VIR_FREE(iface->addrs[i].addr);\n    VIR_FREE(iface->addrs);\n\n    VIR_FREE(iface);\n}\n"], "filenames": ["src/libvirt-domain.c"], "buggy_code_start_loc": [10936], "buggy_code_end_loc": [10936], "fixing_code_start_loc": [10937], "fixing_code_end_loc": [10938], "type": "CWE-254", "message": "libvirt-domain.c in libvirt before 1.3.1 supports virDomainGetTime API calls by guest agents with an RO connection, even though an RW connection was supposed to be required, a different vulnerability than CVE-2019-3886.", "other": {"cve": {"id": "CVE-2016-10746", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-18T16:29:00.273", "lastModified": "2019-05-01T19:47:57.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libvirt-domain.c in libvirt before 1.3.1 supports virDomainGetTime API calls by guest agents with an RO connection, even though an RW connection was supposed to be required, a different vulnerability than CVE-2019-3886."}, {"lang": "es", "value": "libvirt-domain.c en libvirt versiones anteriores a la 1.3.1 soporta las llamadas a la API virDomainGetTime por agentes invitados con una conexi\u00f3n RO, aunque se supon\u00eda que se requer\u00eda una conexi\u00f3n RW, es una vulnerabilidad diferente de CVE-2019-3886."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-254"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:libvirt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.1", "matchCriteriaId": "C7B4E452-4F38-41D5-9D7F-60A3B27A7A33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/libvirt/libvirt/commit/506e9d6c2d4baaf580d489fff0690c0ff2ff588f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libvirt/libvirt/compare/11288f5...8fd6867", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/04/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libvirt/libvirt/commit/506e9d6c2d4baaf580d489fff0690c0ff2ff588f"}}