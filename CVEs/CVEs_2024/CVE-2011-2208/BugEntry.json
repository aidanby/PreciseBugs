{"buggy_code": ["/*\n *  linux/arch/alpha/kernel/osf_sys.c\n *\n *  Copyright (C) 1995  Linus Torvalds\n */\n\n/*\n * This file handles some of the stranger OSF/1 system call interfaces.\n * Some of the system calls expect a non-C calling standard, others have\n * special parameter blocks..\n */\n\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/stddef.h>\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/ptrace.h>\n#include <linux/user.h>\n#include <linux/utsname.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/major.h>\n#include <linux/stat.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/ipc.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/vfs.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n\n#include <asm/fpu.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/system.h>\n#include <asm/sysinfo.h>\n#include <asm/hwrpb.h>\n#include <asm/processor.h>\n\n/*\n * Brk needs to return an error.  Still support Linux's brk(0) query idiom,\n * which OSF programs just shouldn't be doing.  We're still not quite\n * identical to OSF as we don't return 0 on success, but doing otherwise\n * would require changes to libc.  Hopefully this is good enough.\n */\nSYSCALL_DEFINE1(osf_brk, unsigned long, brk)\n{\n\tunsigned long retval = sys_brk(brk);\n\tif (brk && brk != retval)\n\t\tretval = -ENOMEM;\n\treturn retval;\n}\n \n/*\n * This is pure guess-work..\n */\nSYSCALL_DEFINE4(osf_set_program_attributes, unsigned long, text_start,\n\t\tunsigned long, text_len, unsigned long, bss_start,\n\t\tunsigned long, bss_len)\n{\n\tstruct mm_struct *mm;\n\n\tmm = current->mm;\n\tmm->end_code = bss_start + bss_len;\n\tmm->start_brk = bss_start + bss_len;\n\tmm->brk = bss_start + bss_len;\n#if 0\n\tprintk(\"set_program_attributes(%lx %lx %lx %lx)\\n\",\n\t\ttext_start, text_len, bss_start, bss_len);\n#endif\n\treturn 0;\n}\n\n/*\n * OSF/1 directory handling functions...\n *\n * The \"getdents()\" interface is much more sane: the \"basep\" stuff is\n * braindamage (it can't really handle filesystems where the directory\n * offset differences aren't the same as \"d_reclen\").\n */\n#define NAME_OFFSET\toffsetof (struct osf_dirent, d_name)\n\nstruct osf_dirent {\n\tunsigned int d_ino;\n\tunsigned short d_reclen;\n\tunsigned short d_namlen;\n\tchar d_name[1];\n};\n\nstruct osf_dirent_callback {\n\tstruct osf_dirent __user *dirent;\n\tlong __user *basep;\n\tunsigned int count;\n\tint error;\n};\n\nstatic int\nosf_filldir(void *__buf, const char *name, int namlen, loff_t offset,\n\t    u64 ino, unsigned int d_type)\n{\n\tstruct osf_dirent __user *dirent;\n\tstruct osf_dirent_callback *buf = (struct osf_dirent_callback *) __buf;\n\tunsigned int reclen = ALIGN(NAME_OFFSET + namlen + 1, sizeof(u32));\n\tunsigned int d_ino;\n\n\tbuf->error = -EINVAL;\t/* only used if we fail */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tif (buf->basep) {\n\t\tif (put_user(offset, buf->basep))\n\t\t\tgoto Efault;\n\t\tbuf->basep = NULL;\n\t}\n\tdirent = buf->dirent;\n\tif (put_user(d_ino, &dirent->d_ino) ||\n\t    put_user(namlen, &dirent->d_namlen) ||\n\t    put_user(reclen, &dirent->d_reclen) ||\n\t    copy_to_user(dirent->d_name, name, namlen) ||\n\t    put_user(0, dirent->d_name + namlen))\n\t\tgoto Efault;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->dirent = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nEfault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}\n\nSYSCALL_DEFINE4(osf_getdirentries, unsigned int, fd,\n\t\tstruct osf_dirent __user *, dirent, unsigned int, count,\n\t\tlong __user *, basep)\n{\n\tint error;\n\tstruct file *file;\n\tstruct osf_dirent_callback buf;\n\n\terror = -EBADF;\n\tfile = fget(fd);\n\tif (!file)\n\t\tgoto out;\n\n\tbuf.dirent = dirent;\n\tbuf.basep = basep;\n\tbuf.count = count;\n\tbuf.error = 0;\n\n\terror = vfs_readdir(file, osf_filldir, &buf);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tif (count != buf.count)\n\t\terror = count - buf.count;\n\n\tfput(file);\n out:\n\treturn error;\n}\n\n#undef NAME_OFFSET\n\nSYSCALL_DEFINE6(osf_mmap, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags, unsigned long, fd,\n\t\tunsigned long, off)\n{\n\tunsigned long ret = -EINVAL;\n\n#if 0\n\tif (flags & (_MAP_HASSEMAPHORE | _MAP_INHERIT | _MAP_UNALIGNED))\n\t\tprintk(\"%s: unimplemented OSF mmap flags %04lx\\n\", \n\t\t\tcurrent->comm, flags);\n#endif\n\tif ((off + PAGE_ALIGN(len)) < off)\n\t\tgoto out;\n\tif (off & ~PAGE_MASK)\n\t\tgoto out;\n\tret = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n out:\n\treturn ret;\n}\n\n\n/*\n * The OSF/1 statfs structure is much larger, but this should\n * match the beginning, at least.\n */\nstruct osf_statfs {\n\tshort f_type;\n\tshort f_flags;\n\tint f_fsize;\n\tint f_bsize;\n\tint f_blocks;\n\tint f_bfree;\n\tint f_bavail;\n\tint f_files;\n\tint f_ffree;\n\t__kernel_fsid_t f_fsid;\n};\n\nstatic int\nlinux_to_osf_statfs(struct kstatfs *linux_stat, struct osf_statfs __user *osf_stat,\n\t\t    unsigned long bufsiz)\n{\n\tstruct osf_statfs tmp_stat;\n\n\ttmp_stat.f_type = linux_stat->f_type;\n\ttmp_stat.f_flags = 0;\t/* mount flags */\n\ttmp_stat.f_fsize = linux_stat->f_frsize;\n\ttmp_stat.f_bsize = linux_stat->f_bsize;\n\ttmp_stat.f_blocks = linux_stat->f_blocks;\n\ttmp_stat.f_bfree = linux_stat->f_bfree;\n\ttmp_stat.f_bavail = linux_stat->f_bavail;\n\ttmp_stat.f_files = linux_stat->f_files;\n\ttmp_stat.f_ffree = linux_stat->f_ffree;\n\ttmp_stat.f_fsid = linux_stat->f_fsid;\n\tif (bufsiz > sizeof(tmp_stat))\n\t\tbufsiz = sizeof(tmp_stat);\n\treturn copy_to_user(osf_stat, &tmp_stat, bufsiz) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE3(osf_statfs, const char __user *, pathname,\n\t\tstruct osf_statfs __user *, buffer, unsigned long, bufsiz)\n{\n\tstruct kstatfs linux_stat;\n\tint error = user_statfs(pathname, &linux_stat);\n\tif (!error)\n\t\terror = linux_to_osf_statfs(&linux_stat, buffer, bufsiz);\n\treturn error;\t\n}\n\nSYSCALL_DEFINE3(osf_fstatfs, unsigned long, fd,\n\t\tstruct osf_statfs __user *, buffer, unsigned long, bufsiz)\n{\n\tstruct kstatfs linux_stat;\n\tint error = fd_statfs(fd, &linux_stat);\n\tif (!error)\n\t\terror = linux_to_osf_statfs(&linux_stat, buffer, bufsiz);\n\treturn error;\n}\n\n/*\n * Uhh.. OSF/1 mount parameters aren't exactly obvious..\n *\n * Although to be frank, neither are the native Linux/i386 ones..\n */\nstruct ufs_args {\n\tchar __user *devname;\n\tint flags;\n\tuid_t exroot;\n};\n\nstruct cdfs_args {\n\tchar __user *devname;\n\tint flags;\n\tuid_t exroot;\n\n\t/* This has lots more here, which Linux handles with the option block\n\t   but I'm too lazy to do the translation into ASCII.  */\n};\n\nstruct procfs_args {\n\tchar __user *devname;\n\tint flags;\n\tuid_t exroot;\n};\n\n/*\n * We can't actually handle ufs yet, so we translate UFS mounts to\n * ext2fs mounts. I wouldn't mind a UFS filesystem, but the UFS\n * layout is so braindead it's a major headache doing it.\n *\n * Just how long ago was it written? OTOH our UFS driver may be still\n * unhappy with OSF UFS. [CHECKME]\n */\nstatic int\nosf_ufs_mount(char *dirname, struct ufs_args __user *args, int flags)\n{\n\tint retval;\n\tstruct cdfs_args tmp;\n\tchar *devname;\n\n\tretval = -EFAULT;\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\tgoto out;\n\tdevname = getname(tmp.devname);\n\tretval = PTR_ERR(devname);\n\tif (IS_ERR(devname))\n\t\tgoto out;\n\tretval = do_mount(devname, dirname, \"ext2\", flags, NULL);\n\tputname(devname);\n out:\n\treturn retval;\n}\n\nstatic int\nosf_cdfs_mount(char *dirname, struct cdfs_args __user *args, int flags)\n{\n\tint retval;\n\tstruct cdfs_args tmp;\n\tchar *devname;\n\n\tretval = -EFAULT;\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\tgoto out;\n\tdevname = getname(tmp.devname);\n\tretval = PTR_ERR(devname);\n\tif (IS_ERR(devname))\n\t\tgoto out;\n\tretval = do_mount(devname, dirname, \"iso9660\", flags, NULL);\n\tputname(devname);\n out:\n\treturn retval;\n}\n\nstatic int\nosf_procfs_mount(char *dirname, struct procfs_args __user *args, int flags)\n{\n\tstruct procfs_args tmp;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\treturn do_mount(\"\", dirname, \"proc\", flags, NULL);\n}\n\nSYSCALL_DEFINE4(osf_mount, unsigned long, typenr, const char __user *, path,\n\t\tint, flag, void __user *, data)\n{\n\tint retval;\n\tchar *name;\n\n\tname = getname(path);\n\tretval = PTR_ERR(name);\n\tif (IS_ERR(name))\n\t\tgoto out;\n\tswitch (typenr) {\n\tcase 1:\n\t\tretval = osf_ufs_mount(name, data, flag);\n\t\tbreak;\n\tcase 6:\n\t\tretval = osf_cdfs_mount(name, data, flag);\n\t\tbreak;\n\tcase 9:\n\t\tretval = osf_procfs_mount(name, data, flag);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tprintk(\"osf_mount(%ld, %x)\\n\", typenr, flag);\n\t}\n\tputname(name);\n out:\n\treturn retval;\n}\n\nSYSCALL_DEFINE1(osf_utsname, char __user *, name)\n{\n\tint error;\n\n\tdown_read(&uts_sem);\n\terror = -EFAULT;\n\tif (copy_to_user(name + 0, utsname()->sysname, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 32, utsname()->nodename, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 64, utsname()->release, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 96, utsname()->version, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 128, utsname()->machine, 32))\n\t\tgoto out;\n\n\terror = 0;\n out:\n\tup_read(&uts_sem);\t\n\treturn error;\n}\n\nSYSCALL_DEFINE0(getpagesize)\n{\n\treturn PAGE_SIZE;\n}\n\nSYSCALL_DEFINE0(getdtablesize)\n{\n\treturn sysctl_nr_open;\n}\n\n/*\n * For compatibility with OSF/1 only.  Use utsname(2) instead.\n */\nSYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n{\n\tunsigned len;\n\tint i;\n\n\tif (!access_ok(VERIFY_WRITE, name, namelen))\n\t\treturn -EFAULT;\n\n\tlen = namelen;\n\tif (namelen > 32)\n\t\tlen = 32;\n\n\tdown_read(&uts_sem);\n\tfor (i = 0; i < len; ++i) {\n\t\t__put_user(utsname()->domainname[i], name + i);\n\t\tif (utsname()->domainname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tup_read(&uts_sem);\n\n\treturn 0;\n}\n\n/*\n * The following stuff should move into a header file should it ever\n * be labeled \"officially supported.\"  Right now, there is just enough\n * support to avoid applications (such as tar) printing error\n * messages.  The attributes are not really implemented.\n */\n\n/*\n * Values for Property list entry flag\n */\n#define PLE_PROPAGATE_ON_COPY\t\t0x1\t/* cp(1) will copy entry\n\t\t\t\t\t\t   by default */\n#define PLE_FLAG_MASK\t\t\t0x1\t/* Valid flag values */\n#define PLE_FLAG_ALL\t\t\t-1\t/* All flag value */\n\nstruct proplistname_args {\n\tunsigned int pl_mask;\n\tunsigned int pl_numnames;\n\tchar **pl_names;\n};\n\nunion pl_args {\n\tstruct setargs {\n\t\tchar __user *path;\n\t\tlong follow;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t} set;\n\tstruct fsetargs {\n\t\tlong fd;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t} fset;\n\tstruct getargs {\n\t\tchar __user *path;\n\t\tlong follow;\n\t\tstruct proplistname_args __user *name_args;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t\tint __user *min_buf_size;\n\t} get;\n\tstruct fgetargs {\n\t\tlong fd;\n\t\tstruct proplistname_args __user *name_args;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t\tint __user *min_buf_size;\n\t} fget;\n\tstruct delargs {\n\t\tchar __user *path;\n\t\tlong follow;\n\t\tstruct proplistname_args __user *name_args;\n\t} del;\n\tstruct fdelargs {\n\t\tlong fd;\n\t\tstruct proplistname_args __user *name_args;\n\t} fdel;\n};\n\nenum pl_code {\n\tPL_SET = 1, PL_FSET = 2,\n\tPL_GET = 3, PL_FGET = 4,\n\tPL_DEL = 5, PL_FDEL = 6\n};\n\nSYSCALL_DEFINE2(osf_proplist_syscall, enum pl_code, code,\n\t\tunion pl_args __user *, args)\n{\n\tlong error;\n\tint __user *min_buf_size_ptr;\n\n\tswitch (code) {\n\tcase PL_SET:\n\t\tif (get_user(error, &args->set.nbytes))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\tcase PL_FSET:\n\t\tif (get_user(error, &args->fset.nbytes))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\tcase PL_GET:\n\t\terror = get_user(min_buf_size_ptr, &args->get.min_buf_size);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = put_user(0, min_buf_size_ptr);\n\t\tbreak;\n\tcase PL_FGET:\n\t\terror = get_user(min_buf_size_ptr, &args->fget.min_buf_size);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = put_user(0, min_buf_size_ptr);\n\t\tbreak;\n\tcase PL_DEL:\n\tcase PL_FDEL:\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\terror = -EOPNOTSUPP;\n\t\tbreak;\n\t};\n\treturn error;\n}\n\nSYSCALL_DEFINE2(osf_sigstack, struct sigstack __user *, uss,\n\t\tstruct sigstack __user *, uoss)\n{\n\tunsigned long usp = rdusp();\n\tunsigned long oss_sp = current->sas_ss_sp + current->sas_ss_size;\n\tunsigned long oss_os = on_sig_stack(usp);\n\tint error;\n\n\tif (uss) {\n\t\tvoid __user *ss_sp;\n\n\t\terror = -EFAULT;\n\t\tif (get_user(ss_sp, &uss->ss_sp))\n\t\t\tgoto out;\n\n\t\t/* If the current stack was set with sigaltstack, don't\n\t\t   swap stacks while we are on it.  */\n\t\terror = -EPERM;\n\t\tif (current->sas_ss_sp && on_sig_stack(usp))\n\t\t\tgoto out;\n\n\t\t/* Since we don't know the extent of the stack, and we don't\n\t\t   track onstack-ness, but rather calculate it, we must \n\t\t   presume a size.  Ho hum this interface is lossy.  */\n\t\tcurrent->sas_ss_sp = (unsigned long)ss_sp - SIGSTKSZ;\n\t\tcurrent->sas_ss_size = SIGSTKSZ;\n\t}\n\n\tif (uoss) {\n\t\terror = -EFAULT;\n\t\tif (! access_ok(VERIFY_WRITE, uoss, sizeof(*uoss))\n\t\t    || __put_user(oss_sp, &uoss->ss_sp)\n\t\t    || __put_user(oss_os, &uoss->ss_onstack))\n\t\t\tgoto out;\n\t}\n\n\terror = 0;\n out:\n\treturn error;\n}\n\nSYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n{\n\tconst char *sysinfo_table[] = {\n\t\tutsname()->sysname,\n\t\tutsname()->nodename,\n\t\tutsname()->release,\n\t\tutsname()->version,\n\t\tutsname()->machine,\n\t\t\"alpha\",\t/* instruction set architecture */\n\t\t\"dummy\",\t/* hardware serial number */\n\t\t\"dummy\",\t/* hardware manufacturer */\n\t\t\"dummy\",\t/* secure RPC domain */\n\t};\n\tunsigned long offset;\n\tconst char *res;\n\tlong len, err = -EINVAL;\n\n\toffset = command-1;\n\tif (offset >= ARRAY_SIZE(sysinfo_table)) {\n\t\t/* Digital UNIX has a few unpublished interfaces here */\n\t\tprintk(\"sysinfo(%d)\", command);\n\t\tgoto out;\n\t}\n\n\tdown_read(&uts_sem);\n\tres = sysinfo_table[offset];\n\tlen = strlen(res)+1;\n\tif (len > count)\n\t\tlen = count;\n\tif (copy_to_user(buf, res, len))\n\t\terr = -EFAULT;\n\telse\n\t\terr = 0;\n\tup_read(&uts_sem);\n out:\n\treturn err;\n}\n\nSYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n\t\tunsigned long, nbytes, int __user *, start, void __user *, arg)\n{\n\tunsigned long w;\n\tstruct percpu_struct *cpu;\n\n\tswitch (op) {\n\tcase GSI_IEEE_FP_CONTROL:\n\t\t/* Return current software fp control & status bits.  */\n\t\t/* Note that DU doesn't verify available space here.  */\n\n \t\tw = current_thread_info()->ieee_state & IEEE_SW_MASK;\n \t\tw = swcr_update_status(w, rdfpcr());\n\t\tif (put_user(w, (unsigned long __user *) buffer))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase GSI_IEEE_STATE_AT_SIGNAL:\n\t\t/*\n\t\t * Not sure anybody will ever use this weird stuff.  These\n\t\t * ops can be used (under OSF/1) to set the fpcr that should\n\t\t * be used when a signal handler starts executing.\n\t\t */\n\t\tbreak;\n\n \tcase GSI_UACPROC:\n\t\tif (nbytes < sizeof(unsigned int))\n\t\t\treturn -EINVAL;\n \t\tw = (current_thread_info()->flags >> UAC_SHIFT) & UAC_BITMASK;\n \t\tif (put_user(w, (unsigned int __user *)buffer))\n \t\t\treturn -EFAULT;\n \t\treturn 1;\n\n\tcase GSI_PROC_TYPE:\n\t\tif (nbytes < sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tcpu = (struct percpu_struct*)\n\t\t  ((char*)hwrpb + hwrpb->processor_offset);\n\t\tw = cpu->type;\n\t\tif (put_user(w, (unsigned long  __user*)buffer))\n\t\t\treturn -EFAULT;\n\t\treturn 1;\n\n\tcase GSI_GET_HWRPB:\n\t\tif (nbytes < sizeof(*hwrpb))\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)\n\t\t\treturn -EFAULT;\n\t\treturn 1;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nSYSCALL_DEFINE5(osf_setsysinfo, unsigned long, op, void __user *, buffer,\n\t\tunsigned long, nbytes, int __user *, start, void __user *, arg)\n{\n\tswitch (op) {\n\tcase SSI_IEEE_FP_CONTROL: {\n\t\tunsigned long swcr, fpcr;\n\t\tunsigned int *state;\n\n\t\t/* \n\t\t * Alpha Architecture Handbook 4.7.7.3:\n\t\t * To be fully IEEE compiant, we must track the current IEEE\n\t\t * exception state in software, because spurious bits can be\n\t\t * set in the trap shadow of a software-complete insn.\n\t\t */\n\n\t\tif (get_user(swcr, (unsigned long __user *)buffer))\n\t\t\treturn -EFAULT;\n\t\tstate = &current_thread_info()->ieee_state;\n\n\t\t/* Update softare trap enable bits.  */\n\t\t*state = (*state & ~IEEE_SW_MASK) | (swcr & IEEE_SW_MASK);\n\n\t\t/* Update the real fpcr.  */\n\t\tfpcr = rdfpcr() & FPCR_DYN_MASK;\n\t\tfpcr |= ieee_swcr_to_fpcr(swcr);\n\t\twrfpcr(fpcr);\n\n\t\treturn 0;\n\t}\n\n\tcase SSI_IEEE_RAISE_EXCEPTION: {\n\t\tunsigned long exc, swcr, fpcr, fex;\n\t\tunsigned int *state;\n\n\t\tif (get_user(exc, (unsigned long __user *)buffer))\n\t\t\treturn -EFAULT;\n\t\tstate = &current_thread_info()->ieee_state;\n\t\texc &= IEEE_STATUS_MASK;\n\n\t\t/* Update softare trap enable bits.  */\n \t\tswcr = (*state & IEEE_SW_MASK) | exc;\n\t\t*state |= exc;\n\n\t\t/* Update the real fpcr.  */\n\t\tfpcr = rdfpcr();\n\t\tfpcr |= ieee_swcr_to_fpcr(swcr);\n\t\twrfpcr(fpcr);\n\n \t\t/* If any exceptions set by this call, and are unmasked,\n\t\t   send a signal.  Old exceptions are not signaled.  */\n\t\tfex = (exc >> IEEE_STATUS_TO_EXCSUM_SHIFT) & swcr;\n \t\tif (fex) {\n\t\t\tsiginfo_t info;\n\t\t\tint si_code = 0;\n\n\t\t\tif (fex & IEEE_TRAP_ENABLE_DNO) si_code = FPE_FLTUND;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_INE) si_code = FPE_FLTRES;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_UNF) si_code = FPE_FLTUND;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_OVF) si_code = FPE_FLTOVF;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_DZE) si_code = FPE_FLTDIV;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_INV) si_code = FPE_FLTINV;\n\n\t\t\tinfo.si_signo = SIGFPE;\n\t\t\tinfo.si_errno = 0;\n\t\t\tinfo.si_code = si_code;\n\t\t\tinfo.si_addr = NULL;  /* FIXME */\n \t\t\tsend_sig_info(SIGFPE, &info, current);\n \t\t}\n\t\treturn 0;\n\t}\n\n\tcase SSI_IEEE_STATE_AT_SIGNAL:\n\tcase SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\t\t/*\n\t\t * Not sure anybody will ever use this weird stuff.  These\n\t\t * ops can be used (under OSF/1) to set the fpcr that should\n\t\t * be used when a signal handler starts executing.\n\t\t */\n\t\tbreak;\n\n \tcase SSI_NVPAIRS: {\n\t\tunsigned long v, w, i;\n\t\tunsigned int old, new;\n\t\t\n \t\tfor (i = 0; i < nbytes; ++i) {\n\n \t\t\tif (get_user(v, 2*i + (unsigned int __user *)buffer))\n \t\t\t\treturn -EFAULT;\n \t\t\tif (get_user(w, 2*i + 1 + (unsigned int __user *)buffer))\n \t\t\t\treturn -EFAULT;\n \t\t\tswitch (v) {\n \t\t\tcase SSIN_UACPROC:\n\t\t\tagain:\n\t\t\t\told = current_thread_info()->flags;\n\t\t\t\tnew = old & ~(UAC_BITMASK << UAC_SHIFT);\n\t\t\t\tnew = new | (w & UAC_BITMASK) << UAC_SHIFT;\n\t\t\t\tif (cmpxchg(&current_thread_info()->flags,\n\t\t\t\t\t    old, new) != old)\n\t\t\t\t\tgoto again;\n \t\t\t\tbreak;\n \n \t\t\tdefault:\n \t\t\t\treturn -EOPNOTSUPP;\n \t\t\t}\n \t\t}\n \t\treturn 0;\n\t}\n \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* Translations due to the fact that OSF's time_t is an int.  Which\n   affects all sorts of things, like timeval and itimerval.  */\n\nextern struct timezone sys_tz;\n\nstruct timeval32\n{\n    int tv_sec, tv_usec;\n};\n\nstruct itimerval32\n{\n    struct timeval32 it_interval;\n    struct timeval32 it_value;\n};\n\nstatic inline long\nget_tv32(struct timeval *o, struct timeval32 __user *i)\n{\n\treturn (!access_ok(VERIFY_READ, i, sizeof(*i)) ||\n\t\t(__get_user(o->tv_sec, &i->tv_sec) |\n\t\t __get_user(o->tv_usec, &i->tv_usec)));\n}\n\nstatic inline long\nput_tv32(struct timeval32 __user *o, struct timeval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->tv_sec, &o->tv_sec) |\n\t\t __put_user(i->tv_usec, &o->tv_usec)));\n}\n\nstatic inline long\nget_it32(struct itimerval *o, struct itimerval32 __user *i)\n{\n\treturn (!access_ok(VERIFY_READ, i, sizeof(*i)) ||\n\t\t(__get_user(o->it_interval.tv_sec, &i->it_interval.tv_sec) |\n\t\t __get_user(o->it_interval.tv_usec, &i->it_interval.tv_usec) |\n\t\t __get_user(o->it_value.tv_sec, &i->it_value.tv_sec) |\n\t\t __get_user(o->it_value.tv_usec, &i->it_value.tv_usec)));\n}\n\nstatic inline long\nput_it32(struct itimerval32 __user *o, struct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}\n\nstatic inline void\njiffies_to_timeval32(unsigned long jiffies, struct timeval32 *value)\n{\n\tvalue->tv_usec = (jiffies % HZ) * (1000000L / HZ);\n\tvalue->tv_sec = jiffies / HZ;\n}\n\nSYSCALL_DEFINE2(osf_gettimeofday, struct timeval32 __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tif (tv) {\n\t\tstruct timeval ktv;\n\t\tdo_gettimeofday(&ktv);\n\t\tif (put_tv32(tv, &ktv))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(osf_settimeofday, struct timeval32 __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tstruct timespec kts;\n\tstruct timezone ktz;\n\n \tif (tv) {\n\t\tif (get_tv32((struct timeval *)&kts, tv))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&ktz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tkts.tv_nsec *= 1000;\n\n\treturn do_sys_settimeofday(tv ? &kts : NULL, tz ? &ktz : NULL);\n}\n\nSYSCALL_DEFINE2(osf_getitimer, int, which, struct itimerval32 __user *, it)\n{\n\tstruct itimerval kit;\n\tint error;\n\n\terror = do_getitimer(which, &kit);\n\tif (!error && put_it32(it, &kit))\n\t\terror = -EFAULT;\n\n\treturn error;\n}\n\nSYSCALL_DEFINE3(osf_setitimer, int, which, struct itimerval32 __user *, in,\n\t\tstruct itimerval32 __user *, out)\n{\n\tstruct itimerval kin, kout;\n\tint error;\n\n\tif (in) {\n\t\tif (get_it32(&kin, in))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemset(&kin, 0, sizeof(kin));\n\n\terror = do_setitimer(which, &kin, out ? &kout : NULL);\n\tif (error || !out)\n\t\treturn error;\n\n\tif (put_it32(out, &kout))\n\t\treturn -EFAULT;\n\n\treturn 0;\n\n}\n\nSYSCALL_DEFINE2(osf_utimes, const char __user *, filename,\n\t\tstruct timeval32 __user *, tvs)\n{\n\tstruct timespec tv[2];\n\n\tif (tvs) {\n\t\tstruct timeval ktvs[2];\n\t\tif (get_tv32(&ktvs[0], &tvs[0]) ||\n\t\t    get_tv32(&ktvs[1], &tvs[1]))\n\t\t\treturn -EFAULT;\n\n\t\tif (ktvs[0].tv_usec < 0 || ktvs[0].tv_usec >= 1000000 ||\n\t\t    ktvs[1].tv_usec < 0 || ktvs[1].tv_usec >= 1000000)\n\t\t\treturn -EINVAL;\n\n\t\ttv[0].tv_sec = ktvs[0].tv_sec;\n\t\ttv[0].tv_nsec = 1000 * ktvs[0].tv_usec;\n\t\ttv[1].tv_sec = ktvs[1].tv_sec;\n\t\ttv[1].tv_nsec = 1000 * ktvs[1].tv_usec;\n\t}\n\n\treturn do_utimes(AT_FDCWD, filename, tvs ? tv : NULL, 0);\n}\n\nSYSCALL_DEFINE5(osf_select, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct timeval32 __user *, tvp)\n{\n\tstruct timespec end_time, *to = NULL;\n\tif (tvp) {\n\t\ttime_t sec, usec;\n\n\t\tto = &end_time;\n\n\t\tif (!access_ok(VERIFY_READ, tvp, sizeof(*tvp))\n\t\t    || __get_user(sec, &tvp->tv_sec)\n\t\t    || __get_user(usec, &tvp->tv_usec)) {\n\t\t    \treturn -EFAULT;\n\t\t}\n\n\t\tif (sec < 0 || usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (poll_select_set_timeout(to, sec, usec * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\t\t\n\n\t}\n\n\t/* OSF does not copy back the remaining time.  */\n\treturn core_sys_select(n, inp, outp, exp, to);\n}\n\nstruct rusage32 {\n\tstruct timeval32 ru_utime;\t/* user time used */\n\tstruct timeval32 ru_stime;\t/* system time used */\n\tlong\tru_maxrss;\t\t/* maximum resident set size */\n\tlong\tru_ixrss;\t\t/* integral shared memory size */\n\tlong\tru_idrss;\t\t/* integral unshared data size */\n\tlong\tru_isrss;\t\t/* integral unshared stack size */\n\tlong\tru_minflt;\t\t/* page reclaims */\n\tlong\tru_majflt;\t\t/* page faults */\n\tlong\tru_nswap;\t\t/* swaps */\n\tlong\tru_inblock;\t\t/* block input operations */\n\tlong\tru_oublock;\t\t/* block output operations */\n\tlong\tru_msgsnd;\t\t/* messages sent */\n\tlong\tru_msgrcv;\t\t/* messages received */\n\tlong\tru_nsignals;\t\t/* signals received */\n\tlong\tru_nvcsw;\t\t/* voluntary context switches */\n\tlong\tru_nivcsw;\t\t/* involuntary \" */\n};\n\nSYSCALL_DEFINE2(osf_getrusage, int, who, struct rusage32 __user *, ru)\n{\n\tstruct rusage32 r;\n\n\tif (who != RUSAGE_SELF && who != RUSAGE_CHILDREN)\n\t\treturn -EINVAL;\n\n\tmemset(&r, 0, sizeof(r));\n\tswitch (who) {\n\tcase RUSAGE_SELF:\n\t\tjiffies_to_timeval32(current->utime, &r.ru_utime);\n\t\tjiffies_to_timeval32(current->stime, &r.ru_stime);\n\t\tr.ru_minflt = current->min_flt;\n\t\tr.ru_majflt = current->maj_flt;\n\t\tbreak;\n\tcase RUSAGE_CHILDREN:\n\t\tjiffies_to_timeval32(current->signal->cutime, &r.ru_utime);\n\t\tjiffies_to_timeval32(current->signal->cstime, &r.ru_stime);\n\t\tr.ru_minflt = current->signal->cmin_flt;\n\t\tr.ru_majflt = current->signal->cmaj_flt;\n\t\tbreak;\n\t}\n\n\treturn copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n\t\tstruct rusage32 __user *, ur)\n{\n\tstruct rusage r;\n\tlong ret, err;\n\tmm_segment_t old_fs;\n\n\tif (!ur)\n\t\treturn sys_wait4(pid, ustatus, options, NULL);\n\n\told_fs = get_fs();\n\t\t\n\tset_fs (KERNEL_DS);\n\tret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);\n\tset_fs (old_fs);\n\n\tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n\t\treturn -EFAULT;\n\n\terr = 0;\n\terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n\terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n\terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n\terr |= __put_user(r.ru_stime.tv_usec, &ur->ru_stime.tv_usec);\n\terr |= __put_user(r.ru_maxrss, &ur->ru_maxrss);\n\terr |= __put_user(r.ru_ixrss, &ur->ru_ixrss);\n\terr |= __put_user(r.ru_idrss, &ur->ru_idrss);\n\terr |= __put_user(r.ru_isrss, &ur->ru_isrss);\n\terr |= __put_user(r.ru_minflt, &ur->ru_minflt);\n\terr |= __put_user(r.ru_majflt, &ur->ru_majflt);\n\terr |= __put_user(r.ru_nswap, &ur->ru_nswap);\n\terr |= __put_user(r.ru_inblock, &ur->ru_inblock);\n\terr |= __put_user(r.ru_oublock, &ur->ru_oublock);\n\terr |= __put_user(r.ru_msgsnd, &ur->ru_msgsnd);\n\terr |= __put_user(r.ru_msgrcv, &ur->ru_msgrcv);\n\terr |= __put_user(r.ru_nsignals, &ur->ru_nsignals);\n\terr |= __put_user(r.ru_nvcsw, &ur->ru_nvcsw);\n\terr |= __put_user(r.ru_nivcsw, &ur->ru_nivcsw);\n\n\treturn err ? err : ret;\n}\n\n/*\n * I don't know what the parameters are: the first one\n * seems to be a timeval pointer, and I suspect the second\n * one is the time remaining.. Ho humm.. No documentation.\n */\nSYSCALL_DEFINE2(osf_usleep_thread, struct timeval32 __user *, sleep,\n\t\tstruct timeval32 __user *, remain)\n{\n\tstruct timeval tmp;\n\tunsigned long ticks;\n\n\tif (get_tv32(&tmp, sleep))\n\t\tgoto fault;\n\n\tticks = timeval_to_jiffies(&tmp);\n\n\tticks = schedule_timeout_interruptible(ticks);\n\n\tif (remain) {\n\t\tjiffies_to_timeval(ticks, &tmp);\n\t\tif (put_tv32(remain, &tmp))\n\t\t\tgoto fault;\n\t}\n\t\n\treturn 0;\n fault:\n\treturn -EFAULT;\n}\n\n\nstruct timex32 {\n\tunsigned int modes;\t/* mode selector */\n\tlong offset;\t\t/* time offset (usec) */\n\tlong freq;\t\t/* frequency offset (scaled ppm) */\n\tlong maxerror;\t\t/* maximum error (usec) */\n\tlong esterror;\t\t/* estimated error (usec) */\n\tint status;\t\t/* clock command/status */\n\tlong constant;\t\t/* pll time constant */\n\tlong precision;\t\t/* clock precision (usec) (read only) */\n\tlong tolerance;\t\t/* clock frequency tolerance (ppm)\n\t\t\t\t * (read only)\n\t\t\t\t */\n\tstruct timeval32 time;\t/* (read only) */\n\tlong tick;\t\t/* (modified) usecs between clock ticks */\n\n\tlong ppsfreq;           /* pps frequency (scaled ppm) (ro) */\n\tlong jitter;            /* pps jitter (us) (ro) */\n\tint shift;              /* interval duration (s) (shift) (ro) */\n\tlong stabil;            /* pps stability (scaled ppm) (ro) */\n\tlong jitcnt;            /* jitter limit exceeded (ro) */\n\tlong calcnt;            /* calibration intervals (ro) */\n\tlong errcnt;            /* calibration errors (ro) */\n\tlong stbcnt;            /* stability limit exceeded (ro) */\n\n\tint  :32; int  :32; int  :32; int  :32;\n\tint  :32; int  :32; int  :32; int  :32;\n\tint  :32; int  :32; int  :32; int  :32;\n};\n\nSYSCALL_DEFINE1(old_adjtimex, struct timex32 __user *, txc_p)\n{\n        struct timex txc;\n\tint ret;\n\n\t/* copy relevant bits of struct timex. */\n\tif (copy_from_user(&txc, txc_p, offsetof(struct timex32, time)) ||\n\t    copy_from_user(&txc.tick, &txc_p->tick, sizeof(struct timex32) - \n\t\t\t   offsetof(struct timex32, time)))\n\t  return -EFAULT;\n\n\tret = do_adjtimex(&txc);\t\n\tif (ret < 0)\n\t  return ret;\n\t\n\t/* copy back to timex32 */\n\tif (copy_to_user(txc_p, &txc, offsetof(struct timex32, time)) ||\n\t    (copy_to_user(&txc_p->tick, &txc.tick, sizeof(struct timex32) - \n\t\t\t  offsetof(struct timex32, tick))) ||\n\t    (put_tv32(&txc_p->time, &txc.time)))\n\t  return -EFAULT;\n\n\treturn ret;\n}\n\n/* Get an address range which is currently unmapped.  Similar to the\n   generic version except that we know how to honor ADDR_LIMIT_32BIT.  */\n\nstatic unsigned long\narch_get_unmapped_area_1(unsigned long addr, unsigned long len,\n\t\t         unsigned long limit)\n{\n\tstruct vm_area_struct *vma = find_vma(current->mm, addr);\n\n\twhile (1) {\n\t\t/* At this point:  (!vma || addr < vma->vm_end). */\n\t\tif (limit - len < addr)\n\t\t\treturn -ENOMEM;\n\t\tif (!vma || addr + len <= vma->vm_start)\n\t\t\treturn addr;\n\t\taddr = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t}\n}\n\nunsigned long\narch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\t       unsigned long len, unsigned long pgoff,\n\t\t       unsigned long flags)\n{\n\tunsigned long limit;\n\n\t/* \"32 bit\" actually means 31 bit, since pointers sign extend.  */\n\tif (current->personality & ADDR_LIMIT_32BIT)\n\t\tlimit = 0x80000000;\n\telse\n\t\tlimit = TASK_SIZE;\n\n\tif (len > limit)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t/* First, see if the given suggestion fits.\n\n\t   The OSF/1 loader (/sbin/loader) relies on us returning an\n\t   address larger than the requested if one exists, which is\n\t   a terribly broken way to program.\n\n\t   That said, I can see the use in being able to suggest not\n\t   merely specific addresses, but regions of memory -- perhaps\n\t   this feature should be incorporated into all ports?  */\n\n\tif (addr) {\n\t\taddr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);\n\t\tif (addr != (unsigned long) -ENOMEM)\n\t\t\treturn addr;\n\t}\n\n\t/* Next, try allocating at TASK_UNMAPPED_BASE.  */\n\taddr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),\n\t\t\t\t\t len, limit);\n\tif (addr != (unsigned long) -ENOMEM)\n\t\treturn addr;\n\n\t/* Finally, try allocating in low memory.  */\n\taddr = arch_get_unmapped_area_1 (PAGE_SIZE, len, limit);\n\n\treturn addr;\n}\n\n#ifdef CONFIG_OSF4_COMPAT\n\n/* Clear top 32 bits of iov_len in the user's buffer for\n   compatibility with old versions of OSF/1 where iov_len\n   was defined as int. */\nstatic int\nosf_fix_iov_len(const struct iovec __user *iov, unsigned long count)\n{\n\tunsigned long i;\n\n\tfor (i = 0 ; i < count ; i++) {\n\t\tint __user *iov_len_high = (int __user *)&iov[i].iov_len + 1;\n\n\t\tif (put_user(0, iov_len_high))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(osf_readv, unsigned long, fd,\n\t\tconst struct iovec __user *, vector, unsigned long, count)\n{\n\tif (unlikely(personality(current->personality) == PER_OSF4))\n\t\tif (osf_fix_iov_len(vector, count))\n\t\t\treturn -EFAULT;\n\treturn sys_readv(fd, vector, count);\n}\n\nSYSCALL_DEFINE3(osf_writev, unsigned long, fd,\n\t\tconst struct iovec __user *, vector, unsigned long, count)\n{\n\tif (unlikely(personality(current->personality) == PER_OSF4))\n\t\tif (osf_fix_iov_len(vector, count))\n\t\t\treturn -EFAULT;\n\treturn sys_writev(fd, vector, count);\n}\n\n#endif\n"], "fixing_code": ["/*\n *  linux/arch/alpha/kernel/osf_sys.c\n *\n *  Copyright (C) 1995  Linus Torvalds\n */\n\n/*\n * This file handles some of the stranger OSF/1 system call interfaces.\n * Some of the system calls expect a non-C calling standard, others have\n * special parameter blocks..\n */\n\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/stddef.h>\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/ptrace.h>\n#include <linux/user.h>\n#include <linux/utsname.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/major.h>\n#include <linux/stat.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/ipc.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/vfs.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n\n#include <asm/fpu.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/system.h>\n#include <asm/sysinfo.h>\n#include <asm/hwrpb.h>\n#include <asm/processor.h>\n\n/*\n * Brk needs to return an error.  Still support Linux's brk(0) query idiom,\n * which OSF programs just shouldn't be doing.  We're still not quite\n * identical to OSF as we don't return 0 on success, but doing otherwise\n * would require changes to libc.  Hopefully this is good enough.\n */\nSYSCALL_DEFINE1(osf_brk, unsigned long, brk)\n{\n\tunsigned long retval = sys_brk(brk);\n\tif (brk && brk != retval)\n\t\tretval = -ENOMEM;\n\treturn retval;\n}\n \n/*\n * This is pure guess-work..\n */\nSYSCALL_DEFINE4(osf_set_program_attributes, unsigned long, text_start,\n\t\tunsigned long, text_len, unsigned long, bss_start,\n\t\tunsigned long, bss_len)\n{\n\tstruct mm_struct *mm;\n\n\tmm = current->mm;\n\tmm->end_code = bss_start + bss_len;\n\tmm->start_brk = bss_start + bss_len;\n\tmm->brk = bss_start + bss_len;\n#if 0\n\tprintk(\"set_program_attributes(%lx %lx %lx %lx)\\n\",\n\t\ttext_start, text_len, bss_start, bss_len);\n#endif\n\treturn 0;\n}\n\n/*\n * OSF/1 directory handling functions...\n *\n * The \"getdents()\" interface is much more sane: the \"basep\" stuff is\n * braindamage (it can't really handle filesystems where the directory\n * offset differences aren't the same as \"d_reclen\").\n */\n#define NAME_OFFSET\toffsetof (struct osf_dirent, d_name)\n\nstruct osf_dirent {\n\tunsigned int d_ino;\n\tunsigned short d_reclen;\n\tunsigned short d_namlen;\n\tchar d_name[1];\n};\n\nstruct osf_dirent_callback {\n\tstruct osf_dirent __user *dirent;\n\tlong __user *basep;\n\tunsigned int count;\n\tint error;\n};\n\nstatic int\nosf_filldir(void *__buf, const char *name, int namlen, loff_t offset,\n\t    u64 ino, unsigned int d_type)\n{\n\tstruct osf_dirent __user *dirent;\n\tstruct osf_dirent_callback *buf = (struct osf_dirent_callback *) __buf;\n\tunsigned int reclen = ALIGN(NAME_OFFSET + namlen + 1, sizeof(u32));\n\tunsigned int d_ino;\n\n\tbuf->error = -EINVAL;\t/* only used if we fail */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tif (buf->basep) {\n\t\tif (put_user(offset, buf->basep))\n\t\t\tgoto Efault;\n\t\tbuf->basep = NULL;\n\t}\n\tdirent = buf->dirent;\n\tif (put_user(d_ino, &dirent->d_ino) ||\n\t    put_user(namlen, &dirent->d_namlen) ||\n\t    put_user(reclen, &dirent->d_reclen) ||\n\t    copy_to_user(dirent->d_name, name, namlen) ||\n\t    put_user(0, dirent->d_name + namlen))\n\t\tgoto Efault;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->dirent = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nEfault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}\n\nSYSCALL_DEFINE4(osf_getdirentries, unsigned int, fd,\n\t\tstruct osf_dirent __user *, dirent, unsigned int, count,\n\t\tlong __user *, basep)\n{\n\tint error;\n\tstruct file *file;\n\tstruct osf_dirent_callback buf;\n\n\terror = -EBADF;\n\tfile = fget(fd);\n\tif (!file)\n\t\tgoto out;\n\n\tbuf.dirent = dirent;\n\tbuf.basep = basep;\n\tbuf.count = count;\n\tbuf.error = 0;\n\n\terror = vfs_readdir(file, osf_filldir, &buf);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tif (count != buf.count)\n\t\terror = count - buf.count;\n\n\tfput(file);\n out:\n\treturn error;\n}\n\n#undef NAME_OFFSET\n\nSYSCALL_DEFINE6(osf_mmap, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags, unsigned long, fd,\n\t\tunsigned long, off)\n{\n\tunsigned long ret = -EINVAL;\n\n#if 0\n\tif (flags & (_MAP_HASSEMAPHORE | _MAP_INHERIT | _MAP_UNALIGNED))\n\t\tprintk(\"%s: unimplemented OSF mmap flags %04lx\\n\", \n\t\t\tcurrent->comm, flags);\n#endif\n\tif ((off + PAGE_ALIGN(len)) < off)\n\t\tgoto out;\n\tif (off & ~PAGE_MASK)\n\t\tgoto out;\n\tret = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n out:\n\treturn ret;\n}\n\n\n/*\n * The OSF/1 statfs structure is much larger, but this should\n * match the beginning, at least.\n */\nstruct osf_statfs {\n\tshort f_type;\n\tshort f_flags;\n\tint f_fsize;\n\tint f_bsize;\n\tint f_blocks;\n\tint f_bfree;\n\tint f_bavail;\n\tint f_files;\n\tint f_ffree;\n\t__kernel_fsid_t f_fsid;\n};\n\nstatic int\nlinux_to_osf_statfs(struct kstatfs *linux_stat, struct osf_statfs __user *osf_stat,\n\t\t    unsigned long bufsiz)\n{\n\tstruct osf_statfs tmp_stat;\n\n\ttmp_stat.f_type = linux_stat->f_type;\n\ttmp_stat.f_flags = 0;\t/* mount flags */\n\ttmp_stat.f_fsize = linux_stat->f_frsize;\n\ttmp_stat.f_bsize = linux_stat->f_bsize;\n\ttmp_stat.f_blocks = linux_stat->f_blocks;\n\ttmp_stat.f_bfree = linux_stat->f_bfree;\n\ttmp_stat.f_bavail = linux_stat->f_bavail;\n\ttmp_stat.f_files = linux_stat->f_files;\n\ttmp_stat.f_ffree = linux_stat->f_ffree;\n\ttmp_stat.f_fsid = linux_stat->f_fsid;\n\tif (bufsiz > sizeof(tmp_stat))\n\t\tbufsiz = sizeof(tmp_stat);\n\treturn copy_to_user(osf_stat, &tmp_stat, bufsiz) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE3(osf_statfs, const char __user *, pathname,\n\t\tstruct osf_statfs __user *, buffer, unsigned long, bufsiz)\n{\n\tstruct kstatfs linux_stat;\n\tint error = user_statfs(pathname, &linux_stat);\n\tif (!error)\n\t\terror = linux_to_osf_statfs(&linux_stat, buffer, bufsiz);\n\treturn error;\t\n}\n\nSYSCALL_DEFINE3(osf_fstatfs, unsigned long, fd,\n\t\tstruct osf_statfs __user *, buffer, unsigned long, bufsiz)\n{\n\tstruct kstatfs linux_stat;\n\tint error = fd_statfs(fd, &linux_stat);\n\tif (!error)\n\t\terror = linux_to_osf_statfs(&linux_stat, buffer, bufsiz);\n\treturn error;\n}\n\n/*\n * Uhh.. OSF/1 mount parameters aren't exactly obvious..\n *\n * Although to be frank, neither are the native Linux/i386 ones..\n */\nstruct ufs_args {\n\tchar __user *devname;\n\tint flags;\n\tuid_t exroot;\n};\n\nstruct cdfs_args {\n\tchar __user *devname;\n\tint flags;\n\tuid_t exroot;\n\n\t/* This has lots more here, which Linux handles with the option block\n\t   but I'm too lazy to do the translation into ASCII.  */\n};\n\nstruct procfs_args {\n\tchar __user *devname;\n\tint flags;\n\tuid_t exroot;\n};\n\n/*\n * We can't actually handle ufs yet, so we translate UFS mounts to\n * ext2fs mounts. I wouldn't mind a UFS filesystem, but the UFS\n * layout is so braindead it's a major headache doing it.\n *\n * Just how long ago was it written? OTOH our UFS driver may be still\n * unhappy with OSF UFS. [CHECKME]\n */\nstatic int\nosf_ufs_mount(char *dirname, struct ufs_args __user *args, int flags)\n{\n\tint retval;\n\tstruct cdfs_args tmp;\n\tchar *devname;\n\n\tretval = -EFAULT;\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\tgoto out;\n\tdevname = getname(tmp.devname);\n\tretval = PTR_ERR(devname);\n\tif (IS_ERR(devname))\n\t\tgoto out;\n\tretval = do_mount(devname, dirname, \"ext2\", flags, NULL);\n\tputname(devname);\n out:\n\treturn retval;\n}\n\nstatic int\nosf_cdfs_mount(char *dirname, struct cdfs_args __user *args, int flags)\n{\n\tint retval;\n\tstruct cdfs_args tmp;\n\tchar *devname;\n\n\tretval = -EFAULT;\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\tgoto out;\n\tdevname = getname(tmp.devname);\n\tretval = PTR_ERR(devname);\n\tif (IS_ERR(devname))\n\t\tgoto out;\n\tretval = do_mount(devname, dirname, \"iso9660\", flags, NULL);\n\tputname(devname);\n out:\n\treturn retval;\n}\n\nstatic int\nosf_procfs_mount(char *dirname, struct procfs_args __user *args, int flags)\n{\n\tstruct procfs_args tmp;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\treturn do_mount(\"\", dirname, \"proc\", flags, NULL);\n}\n\nSYSCALL_DEFINE4(osf_mount, unsigned long, typenr, const char __user *, path,\n\t\tint, flag, void __user *, data)\n{\n\tint retval;\n\tchar *name;\n\n\tname = getname(path);\n\tretval = PTR_ERR(name);\n\tif (IS_ERR(name))\n\t\tgoto out;\n\tswitch (typenr) {\n\tcase 1:\n\t\tretval = osf_ufs_mount(name, data, flag);\n\t\tbreak;\n\tcase 6:\n\t\tretval = osf_cdfs_mount(name, data, flag);\n\t\tbreak;\n\tcase 9:\n\t\tretval = osf_procfs_mount(name, data, flag);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tprintk(\"osf_mount(%ld, %x)\\n\", typenr, flag);\n\t}\n\tputname(name);\n out:\n\treturn retval;\n}\n\nSYSCALL_DEFINE1(osf_utsname, char __user *, name)\n{\n\tint error;\n\n\tdown_read(&uts_sem);\n\terror = -EFAULT;\n\tif (copy_to_user(name + 0, utsname()->sysname, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 32, utsname()->nodename, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 64, utsname()->release, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 96, utsname()->version, 32))\n\t\tgoto out;\n\tif (copy_to_user(name + 128, utsname()->machine, 32))\n\t\tgoto out;\n\n\terror = 0;\n out:\n\tup_read(&uts_sem);\t\n\treturn error;\n}\n\nSYSCALL_DEFINE0(getpagesize)\n{\n\treturn PAGE_SIZE;\n}\n\nSYSCALL_DEFINE0(getdtablesize)\n{\n\treturn sysctl_nr_open;\n}\n\n/*\n * For compatibility with OSF/1 only.  Use utsname(2) instead.\n */\nSYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n{\n\tunsigned len;\n\tint i;\n\n\tif (!access_ok(VERIFY_WRITE, name, namelen))\n\t\treturn -EFAULT;\n\n\tlen = namelen;\n\tif (len > 32)\n\t\tlen = 32;\n\n\tdown_read(&uts_sem);\n\tfor (i = 0; i < len; ++i) {\n\t\t__put_user(utsname()->domainname[i], name + i);\n\t\tif (utsname()->domainname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tup_read(&uts_sem);\n\n\treturn 0;\n}\n\n/*\n * The following stuff should move into a header file should it ever\n * be labeled \"officially supported.\"  Right now, there is just enough\n * support to avoid applications (such as tar) printing error\n * messages.  The attributes are not really implemented.\n */\n\n/*\n * Values for Property list entry flag\n */\n#define PLE_PROPAGATE_ON_COPY\t\t0x1\t/* cp(1) will copy entry\n\t\t\t\t\t\t   by default */\n#define PLE_FLAG_MASK\t\t\t0x1\t/* Valid flag values */\n#define PLE_FLAG_ALL\t\t\t-1\t/* All flag value */\n\nstruct proplistname_args {\n\tunsigned int pl_mask;\n\tunsigned int pl_numnames;\n\tchar **pl_names;\n};\n\nunion pl_args {\n\tstruct setargs {\n\t\tchar __user *path;\n\t\tlong follow;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t} set;\n\tstruct fsetargs {\n\t\tlong fd;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t} fset;\n\tstruct getargs {\n\t\tchar __user *path;\n\t\tlong follow;\n\t\tstruct proplistname_args __user *name_args;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t\tint __user *min_buf_size;\n\t} get;\n\tstruct fgetargs {\n\t\tlong fd;\n\t\tstruct proplistname_args __user *name_args;\n\t\tlong nbytes;\n\t\tchar __user *buf;\n\t\tint __user *min_buf_size;\n\t} fget;\n\tstruct delargs {\n\t\tchar __user *path;\n\t\tlong follow;\n\t\tstruct proplistname_args __user *name_args;\n\t} del;\n\tstruct fdelargs {\n\t\tlong fd;\n\t\tstruct proplistname_args __user *name_args;\n\t} fdel;\n};\n\nenum pl_code {\n\tPL_SET = 1, PL_FSET = 2,\n\tPL_GET = 3, PL_FGET = 4,\n\tPL_DEL = 5, PL_FDEL = 6\n};\n\nSYSCALL_DEFINE2(osf_proplist_syscall, enum pl_code, code,\n\t\tunion pl_args __user *, args)\n{\n\tlong error;\n\tint __user *min_buf_size_ptr;\n\n\tswitch (code) {\n\tcase PL_SET:\n\t\tif (get_user(error, &args->set.nbytes))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\tcase PL_FSET:\n\t\tif (get_user(error, &args->fset.nbytes))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\tcase PL_GET:\n\t\terror = get_user(min_buf_size_ptr, &args->get.min_buf_size);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = put_user(0, min_buf_size_ptr);\n\t\tbreak;\n\tcase PL_FGET:\n\t\terror = get_user(min_buf_size_ptr, &args->fget.min_buf_size);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = put_user(0, min_buf_size_ptr);\n\t\tbreak;\n\tcase PL_DEL:\n\tcase PL_FDEL:\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\terror = -EOPNOTSUPP;\n\t\tbreak;\n\t};\n\treturn error;\n}\n\nSYSCALL_DEFINE2(osf_sigstack, struct sigstack __user *, uss,\n\t\tstruct sigstack __user *, uoss)\n{\n\tunsigned long usp = rdusp();\n\tunsigned long oss_sp = current->sas_ss_sp + current->sas_ss_size;\n\tunsigned long oss_os = on_sig_stack(usp);\n\tint error;\n\n\tif (uss) {\n\t\tvoid __user *ss_sp;\n\n\t\terror = -EFAULT;\n\t\tif (get_user(ss_sp, &uss->ss_sp))\n\t\t\tgoto out;\n\n\t\t/* If the current stack was set with sigaltstack, don't\n\t\t   swap stacks while we are on it.  */\n\t\terror = -EPERM;\n\t\tif (current->sas_ss_sp && on_sig_stack(usp))\n\t\t\tgoto out;\n\n\t\t/* Since we don't know the extent of the stack, and we don't\n\t\t   track onstack-ness, but rather calculate it, we must \n\t\t   presume a size.  Ho hum this interface is lossy.  */\n\t\tcurrent->sas_ss_sp = (unsigned long)ss_sp - SIGSTKSZ;\n\t\tcurrent->sas_ss_size = SIGSTKSZ;\n\t}\n\n\tif (uoss) {\n\t\terror = -EFAULT;\n\t\tif (! access_ok(VERIFY_WRITE, uoss, sizeof(*uoss))\n\t\t    || __put_user(oss_sp, &uoss->ss_sp)\n\t\t    || __put_user(oss_os, &uoss->ss_onstack))\n\t\t\tgoto out;\n\t}\n\n\terror = 0;\n out:\n\treturn error;\n}\n\nSYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n{\n\tconst char *sysinfo_table[] = {\n\t\tutsname()->sysname,\n\t\tutsname()->nodename,\n\t\tutsname()->release,\n\t\tutsname()->version,\n\t\tutsname()->machine,\n\t\t\"alpha\",\t/* instruction set architecture */\n\t\t\"dummy\",\t/* hardware serial number */\n\t\t\"dummy\",\t/* hardware manufacturer */\n\t\t\"dummy\",\t/* secure RPC domain */\n\t};\n\tunsigned long offset;\n\tconst char *res;\n\tlong len, err = -EINVAL;\n\n\toffset = command-1;\n\tif (offset >= ARRAY_SIZE(sysinfo_table)) {\n\t\t/* Digital UNIX has a few unpublished interfaces here */\n\t\tprintk(\"sysinfo(%d)\", command);\n\t\tgoto out;\n\t}\n\n\tdown_read(&uts_sem);\n\tres = sysinfo_table[offset];\n\tlen = strlen(res)+1;\n\tif ((unsigned long)len > (unsigned long)count)\n\t\tlen = count;\n\tif (copy_to_user(buf, res, len))\n\t\terr = -EFAULT;\n\telse\n\t\terr = 0;\n\tup_read(&uts_sem);\n out:\n\treturn err;\n}\n\nSYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n\t\tunsigned long, nbytes, int __user *, start, void __user *, arg)\n{\n\tunsigned long w;\n\tstruct percpu_struct *cpu;\n\n\tswitch (op) {\n\tcase GSI_IEEE_FP_CONTROL:\n\t\t/* Return current software fp control & status bits.  */\n\t\t/* Note that DU doesn't verify available space here.  */\n\n \t\tw = current_thread_info()->ieee_state & IEEE_SW_MASK;\n \t\tw = swcr_update_status(w, rdfpcr());\n\t\tif (put_user(w, (unsigned long __user *) buffer))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase GSI_IEEE_STATE_AT_SIGNAL:\n\t\t/*\n\t\t * Not sure anybody will ever use this weird stuff.  These\n\t\t * ops can be used (under OSF/1) to set the fpcr that should\n\t\t * be used when a signal handler starts executing.\n\t\t */\n\t\tbreak;\n\n \tcase GSI_UACPROC:\n\t\tif (nbytes < sizeof(unsigned int))\n\t\t\treturn -EINVAL;\n \t\tw = (current_thread_info()->flags >> UAC_SHIFT) & UAC_BITMASK;\n \t\tif (put_user(w, (unsigned int __user *)buffer))\n \t\t\treturn -EFAULT;\n \t\treturn 1;\n\n\tcase GSI_PROC_TYPE:\n\t\tif (nbytes < sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tcpu = (struct percpu_struct*)\n\t\t  ((char*)hwrpb + hwrpb->processor_offset);\n\t\tw = cpu->type;\n\t\tif (put_user(w, (unsigned long  __user*)buffer))\n\t\t\treturn -EFAULT;\n\t\treturn 1;\n\n\tcase GSI_GET_HWRPB:\n\t\tif (nbytes > sizeof(*hwrpb))\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)\n\t\t\treturn -EFAULT;\n\t\treturn 1;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nSYSCALL_DEFINE5(osf_setsysinfo, unsigned long, op, void __user *, buffer,\n\t\tunsigned long, nbytes, int __user *, start, void __user *, arg)\n{\n\tswitch (op) {\n\tcase SSI_IEEE_FP_CONTROL: {\n\t\tunsigned long swcr, fpcr;\n\t\tunsigned int *state;\n\n\t\t/* \n\t\t * Alpha Architecture Handbook 4.7.7.3:\n\t\t * To be fully IEEE compiant, we must track the current IEEE\n\t\t * exception state in software, because spurious bits can be\n\t\t * set in the trap shadow of a software-complete insn.\n\t\t */\n\n\t\tif (get_user(swcr, (unsigned long __user *)buffer))\n\t\t\treturn -EFAULT;\n\t\tstate = &current_thread_info()->ieee_state;\n\n\t\t/* Update softare trap enable bits.  */\n\t\t*state = (*state & ~IEEE_SW_MASK) | (swcr & IEEE_SW_MASK);\n\n\t\t/* Update the real fpcr.  */\n\t\tfpcr = rdfpcr() & FPCR_DYN_MASK;\n\t\tfpcr |= ieee_swcr_to_fpcr(swcr);\n\t\twrfpcr(fpcr);\n\n\t\treturn 0;\n\t}\n\n\tcase SSI_IEEE_RAISE_EXCEPTION: {\n\t\tunsigned long exc, swcr, fpcr, fex;\n\t\tunsigned int *state;\n\n\t\tif (get_user(exc, (unsigned long __user *)buffer))\n\t\t\treturn -EFAULT;\n\t\tstate = &current_thread_info()->ieee_state;\n\t\texc &= IEEE_STATUS_MASK;\n\n\t\t/* Update softare trap enable bits.  */\n \t\tswcr = (*state & IEEE_SW_MASK) | exc;\n\t\t*state |= exc;\n\n\t\t/* Update the real fpcr.  */\n\t\tfpcr = rdfpcr();\n\t\tfpcr |= ieee_swcr_to_fpcr(swcr);\n\t\twrfpcr(fpcr);\n\n \t\t/* If any exceptions set by this call, and are unmasked,\n\t\t   send a signal.  Old exceptions are not signaled.  */\n\t\tfex = (exc >> IEEE_STATUS_TO_EXCSUM_SHIFT) & swcr;\n \t\tif (fex) {\n\t\t\tsiginfo_t info;\n\t\t\tint si_code = 0;\n\n\t\t\tif (fex & IEEE_TRAP_ENABLE_DNO) si_code = FPE_FLTUND;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_INE) si_code = FPE_FLTRES;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_UNF) si_code = FPE_FLTUND;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_OVF) si_code = FPE_FLTOVF;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_DZE) si_code = FPE_FLTDIV;\n\t\t\tif (fex & IEEE_TRAP_ENABLE_INV) si_code = FPE_FLTINV;\n\n\t\t\tinfo.si_signo = SIGFPE;\n\t\t\tinfo.si_errno = 0;\n\t\t\tinfo.si_code = si_code;\n\t\t\tinfo.si_addr = NULL;  /* FIXME */\n \t\t\tsend_sig_info(SIGFPE, &info, current);\n \t\t}\n\t\treturn 0;\n\t}\n\n\tcase SSI_IEEE_STATE_AT_SIGNAL:\n\tcase SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\t\t/*\n\t\t * Not sure anybody will ever use this weird stuff.  These\n\t\t * ops can be used (under OSF/1) to set the fpcr that should\n\t\t * be used when a signal handler starts executing.\n\t\t */\n\t\tbreak;\n\n \tcase SSI_NVPAIRS: {\n\t\tunsigned long v, w, i;\n\t\tunsigned int old, new;\n\t\t\n \t\tfor (i = 0; i < nbytes; ++i) {\n\n \t\t\tif (get_user(v, 2*i + (unsigned int __user *)buffer))\n \t\t\t\treturn -EFAULT;\n \t\t\tif (get_user(w, 2*i + 1 + (unsigned int __user *)buffer))\n \t\t\t\treturn -EFAULT;\n \t\t\tswitch (v) {\n \t\t\tcase SSIN_UACPROC:\n\t\t\tagain:\n\t\t\t\told = current_thread_info()->flags;\n\t\t\t\tnew = old & ~(UAC_BITMASK << UAC_SHIFT);\n\t\t\t\tnew = new | (w & UAC_BITMASK) << UAC_SHIFT;\n\t\t\t\tif (cmpxchg(&current_thread_info()->flags,\n\t\t\t\t\t    old, new) != old)\n\t\t\t\t\tgoto again;\n \t\t\t\tbreak;\n \n \t\t\tdefault:\n \t\t\t\treturn -EOPNOTSUPP;\n \t\t\t}\n \t\t}\n \t\treturn 0;\n\t}\n \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* Translations due to the fact that OSF's time_t is an int.  Which\n   affects all sorts of things, like timeval and itimerval.  */\n\nextern struct timezone sys_tz;\n\nstruct timeval32\n{\n    int tv_sec, tv_usec;\n};\n\nstruct itimerval32\n{\n    struct timeval32 it_interval;\n    struct timeval32 it_value;\n};\n\nstatic inline long\nget_tv32(struct timeval *o, struct timeval32 __user *i)\n{\n\treturn (!access_ok(VERIFY_READ, i, sizeof(*i)) ||\n\t\t(__get_user(o->tv_sec, &i->tv_sec) |\n\t\t __get_user(o->tv_usec, &i->tv_usec)));\n}\n\nstatic inline long\nput_tv32(struct timeval32 __user *o, struct timeval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->tv_sec, &o->tv_sec) |\n\t\t __put_user(i->tv_usec, &o->tv_usec)));\n}\n\nstatic inline long\nget_it32(struct itimerval *o, struct itimerval32 __user *i)\n{\n\treturn (!access_ok(VERIFY_READ, i, sizeof(*i)) ||\n\t\t(__get_user(o->it_interval.tv_sec, &i->it_interval.tv_sec) |\n\t\t __get_user(o->it_interval.tv_usec, &i->it_interval.tv_usec) |\n\t\t __get_user(o->it_value.tv_sec, &i->it_value.tv_sec) |\n\t\t __get_user(o->it_value.tv_usec, &i->it_value.tv_usec)));\n}\n\nstatic inline long\nput_it32(struct itimerval32 __user *o, struct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}\n\nstatic inline void\njiffies_to_timeval32(unsigned long jiffies, struct timeval32 *value)\n{\n\tvalue->tv_usec = (jiffies % HZ) * (1000000L / HZ);\n\tvalue->tv_sec = jiffies / HZ;\n}\n\nSYSCALL_DEFINE2(osf_gettimeofday, struct timeval32 __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tif (tv) {\n\t\tstruct timeval ktv;\n\t\tdo_gettimeofday(&ktv);\n\t\tif (put_tv32(tv, &ktv))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(osf_settimeofday, struct timeval32 __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tstruct timespec kts;\n\tstruct timezone ktz;\n\n \tif (tv) {\n\t\tif (get_tv32((struct timeval *)&kts, tv))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&ktz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tkts.tv_nsec *= 1000;\n\n\treturn do_sys_settimeofday(tv ? &kts : NULL, tz ? &ktz : NULL);\n}\n\nSYSCALL_DEFINE2(osf_getitimer, int, which, struct itimerval32 __user *, it)\n{\n\tstruct itimerval kit;\n\tint error;\n\n\terror = do_getitimer(which, &kit);\n\tif (!error && put_it32(it, &kit))\n\t\terror = -EFAULT;\n\n\treturn error;\n}\n\nSYSCALL_DEFINE3(osf_setitimer, int, which, struct itimerval32 __user *, in,\n\t\tstruct itimerval32 __user *, out)\n{\n\tstruct itimerval kin, kout;\n\tint error;\n\n\tif (in) {\n\t\tif (get_it32(&kin, in))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemset(&kin, 0, sizeof(kin));\n\n\terror = do_setitimer(which, &kin, out ? &kout : NULL);\n\tif (error || !out)\n\t\treturn error;\n\n\tif (put_it32(out, &kout))\n\t\treturn -EFAULT;\n\n\treturn 0;\n\n}\n\nSYSCALL_DEFINE2(osf_utimes, const char __user *, filename,\n\t\tstruct timeval32 __user *, tvs)\n{\n\tstruct timespec tv[2];\n\n\tif (tvs) {\n\t\tstruct timeval ktvs[2];\n\t\tif (get_tv32(&ktvs[0], &tvs[0]) ||\n\t\t    get_tv32(&ktvs[1], &tvs[1]))\n\t\t\treturn -EFAULT;\n\n\t\tif (ktvs[0].tv_usec < 0 || ktvs[0].tv_usec >= 1000000 ||\n\t\t    ktvs[1].tv_usec < 0 || ktvs[1].tv_usec >= 1000000)\n\t\t\treturn -EINVAL;\n\n\t\ttv[0].tv_sec = ktvs[0].tv_sec;\n\t\ttv[0].tv_nsec = 1000 * ktvs[0].tv_usec;\n\t\ttv[1].tv_sec = ktvs[1].tv_sec;\n\t\ttv[1].tv_nsec = 1000 * ktvs[1].tv_usec;\n\t}\n\n\treturn do_utimes(AT_FDCWD, filename, tvs ? tv : NULL, 0);\n}\n\nSYSCALL_DEFINE5(osf_select, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct timeval32 __user *, tvp)\n{\n\tstruct timespec end_time, *to = NULL;\n\tif (tvp) {\n\t\ttime_t sec, usec;\n\n\t\tto = &end_time;\n\n\t\tif (!access_ok(VERIFY_READ, tvp, sizeof(*tvp))\n\t\t    || __get_user(sec, &tvp->tv_sec)\n\t\t    || __get_user(usec, &tvp->tv_usec)) {\n\t\t    \treturn -EFAULT;\n\t\t}\n\n\t\tif (sec < 0 || usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (poll_select_set_timeout(to, sec, usec * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\t\t\n\n\t}\n\n\t/* OSF does not copy back the remaining time.  */\n\treturn core_sys_select(n, inp, outp, exp, to);\n}\n\nstruct rusage32 {\n\tstruct timeval32 ru_utime;\t/* user time used */\n\tstruct timeval32 ru_stime;\t/* system time used */\n\tlong\tru_maxrss;\t\t/* maximum resident set size */\n\tlong\tru_ixrss;\t\t/* integral shared memory size */\n\tlong\tru_idrss;\t\t/* integral unshared data size */\n\tlong\tru_isrss;\t\t/* integral unshared stack size */\n\tlong\tru_minflt;\t\t/* page reclaims */\n\tlong\tru_majflt;\t\t/* page faults */\n\tlong\tru_nswap;\t\t/* swaps */\n\tlong\tru_inblock;\t\t/* block input operations */\n\tlong\tru_oublock;\t\t/* block output operations */\n\tlong\tru_msgsnd;\t\t/* messages sent */\n\tlong\tru_msgrcv;\t\t/* messages received */\n\tlong\tru_nsignals;\t\t/* signals received */\n\tlong\tru_nvcsw;\t\t/* voluntary context switches */\n\tlong\tru_nivcsw;\t\t/* involuntary \" */\n};\n\nSYSCALL_DEFINE2(osf_getrusage, int, who, struct rusage32 __user *, ru)\n{\n\tstruct rusage32 r;\n\n\tif (who != RUSAGE_SELF && who != RUSAGE_CHILDREN)\n\t\treturn -EINVAL;\n\n\tmemset(&r, 0, sizeof(r));\n\tswitch (who) {\n\tcase RUSAGE_SELF:\n\t\tjiffies_to_timeval32(current->utime, &r.ru_utime);\n\t\tjiffies_to_timeval32(current->stime, &r.ru_stime);\n\t\tr.ru_minflt = current->min_flt;\n\t\tr.ru_majflt = current->maj_flt;\n\t\tbreak;\n\tcase RUSAGE_CHILDREN:\n\t\tjiffies_to_timeval32(current->signal->cutime, &r.ru_utime);\n\t\tjiffies_to_timeval32(current->signal->cstime, &r.ru_stime);\n\t\tr.ru_minflt = current->signal->cmin_flt;\n\t\tr.ru_majflt = current->signal->cmaj_flt;\n\t\tbreak;\n\t}\n\n\treturn copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n\t\tstruct rusage32 __user *, ur)\n{\n\tstruct rusage r;\n\tlong ret, err;\n\tunsigned int status = 0;\n\tmm_segment_t old_fs;\n\n\tif (!ur)\n\t\treturn sys_wait4(pid, ustatus, options, NULL);\n\n\told_fs = get_fs();\n\t\t\n\tset_fs (KERNEL_DS);\n\tret = sys_wait4(pid, (unsigned int __user *) &status, options,\n\t\t\t(struct rusage __user *) &r);\n\tset_fs (old_fs);\n\n\tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n\t\treturn -EFAULT;\n\n\terr = 0;\n\terr |= put_user(status, ustatus);\n\terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n\terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n\terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n\terr |= __put_user(r.ru_stime.tv_usec, &ur->ru_stime.tv_usec);\n\terr |= __put_user(r.ru_maxrss, &ur->ru_maxrss);\n\terr |= __put_user(r.ru_ixrss, &ur->ru_ixrss);\n\terr |= __put_user(r.ru_idrss, &ur->ru_idrss);\n\terr |= __put_user(r.ru_isrss, &ur->ru_isrss);\n\terr |= __put_user(r.ru_minflt, &ur->ru_minflt);\n\terr |= __put_user(r.ru_majflt, &ur->ru_majflt);\n\terr |= __put_user(r.ru_nswap, &ur->ru_nswap);\n\terr |= __put_user(r.ru_inblock, &ur->ru_inblock);\n\terr |= __put_user(r.ru_oublock, &ur->ru_oublock);\n\terr |= __put_user(r.ru_msgsnd, &ur->ru_msgsnd);\n\terr |= __put_user(r.ru_msgrcv, &ur->ru_msgrcv);\n\terr |= __put_user(r.ru_nsignals, &ur->ru_nsignals);\n\terr |= __put_user(r.ru_nvcsw, &ur->ru_nvcsw);\n\terr |= __put_user(r.ru_nivcsw, &ur->ru_nivcsw);\n\n\treturn err ? err : ret;\n}\n\n/*\n * I don't know what the parameters are: the first one\n * seems to be a timeval pointer, and I suspect the second\n * one is the time remaining.. Ho humm.. No documentation.\n */\nSYSCALL_DEFINE2(osf_usleep_thread, struct timeval32 __user *, sleep,\n\t\tstruct timeval32 __user *, remain)\n{\n\tstruct timeval tmp;\n\tunsigned long ticks;\n\n\tif (get_tv32(&tmp, sleep))\n\t\tgoto fault;\n\n\tticks = timeval_to_jiffies(&tmp);\n\n\tticks = schedule_timeout_interruptible(ticks);\n\n\tif (remain) {\n\t\tjiffies_to_timeval(ticks, &tmp);\n\t\tif (put_tv32(remain, &tmp))\n\t\t\tgoto fault;\n\t}\n\t\n\treturn 0;\n fault:\n\treturn -EFAULT;\n}\n\n\nstruct timex32 {\n\tunsigned int modes;\t/* mode selector */\n\tlong offset;\t\t/* time offset (usec) */\n\tlong freq;\t\t/* frequency offset (scaled ppm) */\n\tlong maxerror;\t\t/* maximum error (usec) */\n\tlong esterror;\t\t/* estimated error (usec) */\n\tint status;\t\t/* clock command/status */\n\tlong constant;\t\t/* pll time constant */\n\tlong precision;\t\t/* clock precision (usec) (read only) */\n\tlong tolerance;\t\t/* clock frequency tolerance (ppm)\n\t\t\t\t * (read only)\n\t\t\t\t */\n\tstruct timeval32 time;\t/* (read only) */\n\tlong tick;\t\t/* (modified) usecs between clock ticks */\n\n\tlong ppsfreq;           /* pps frequency (scaled ppm) (ro) */\n\tlong jitter;            /* pps jitter (us) (ro) */\n\tint shift;              /* interval duration (s) (shift) (ro) */\n\tlong stabil;            /* pps stability (scaled ppm) (ro) */\n\tlong jitcnt;            /* jitter limit exceeded (ro) */\n\tlong calcnt;            /* calibration intervals (ro) */\n\tlong errcnt;            /* calibration errors (ro) */\n\tlong stbcnt;            /* stability limit exceeded (ro) */\n\n\tint  :32; int  :32; int  :32; int  :32;\n\tint  :32; int  :32; int  :32; int  :32;\n\tint  :32; int  :32; int  :32; int  :32;\n};\n\nSYSCALL_DEFINE1(old_adjtimex, struct timex32 __user *, txc_p)\n{\n        struct timex txc;\n\tint ret;\n\n\t/* copy relevant bits of struct timex. */\n\tif (copy_from_user(&txc, txc_p, offsetof(struct timex32, time)) ||\n\t    copy_from_user(&txc.tick, &txc_p->tick, sizeof(struct timex32) - \n\t\t\t   offsetof(struct timex32, time)))\n\t  return -EFAULT;\n\n\tret = do_adjtimex(&txc);\t\n\tif (ret < 0)\n\t  return ret;\n\t\n\t/* copy back to timex32 */\n\tif (copy_to_user(txc_p, &txc, offsetof(struct timex32, time)) ||\n\t    (copy_to_user(&txc_p->tick, &txc.tick, sizeof(struct timex32) - \n\t\t\t  offsetof(struct timex32, tick))) ||\n\t    (put_tv32(&txc_p->time, &txc.time)))\n\t  return -EFAULT;\n\n\treturn ret;\n}\n\n/* Get an address range which is currently unmapped.  Similar to the\n   generic version except that we know how to honor ADDR_LIMIT_32BIT.  */\n\nstatic unsigned long\narch_get_unmapped_area_1(unsigned long addr, unsigned long len,\n\t\t         unsigned long limit)\n{\n\tstruct vm_area_struct *vma = find_vma(current->mm, addr);\n\n\twhile (1) {\n\t\t/* At this point:  (!vma || addr < vma->vm_end). */\n\t\tif (limit - len < addr)\n\t\t\treturn -ENOMEM;\n\t\tif (!vma || addr + len <= vma->vm_start)\n\t\t\treturn addr;\n\t\taddr = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t}\n}\n\nunsigned long\narch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\t       unsigned long len, unsigned long pgoff,\n\t\t       unsigned long flags)\n{\n\tunsigned long limit;\n\n\t/* \"32 bit\" actually means 31 bit, since pointers sign extend.  */\n\tif (current->personality & ADDR_LIMIT_32BIT)\n\t\tlimit = 0x80000000;\n\telse\n\t\tlimit = TASK_SIZE;\n\n\tif (len > limit)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t/* First, see if the given suggestion fits.\n\n\t   The OSF/1 loader (/sbin/loader) relies on us returning an\n\t   address larger than the requested if one exists, which is\n\t   a terribly broken way to program.\n\n\t   That said, I can see the use in being able to suggest not\n\t   merely specific addresses, but regions of memory -- perhaps\n\t   this feature should be incorporated into all ports?  */\n\n\tif (addr) {\n\t\taddr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);\n\t\tif (addr != (unsigned long) -ENOMEM)\n\t\t\treturn addr;\n\t}\n\n\t/* Next, try allocating at TASK_UNMAPPED_BASE.  */\n\taddr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),\n\t\t\t\t\t len, limit);\n\tif (addr != (unsigned long) -ENOMEM)\n\t\treturn addr;\n\n\t/* Finally, try allocating in low memory.  */\n\taddr = arch_get_unmapped_area_1 (PAGE_SIZE, len, limit);\n\n\treturn addr;\n}\n\n#ifdef CONFIG_OSF4_COMPAT\n\n/* Clear top 32 bits of iov_len in the user's buffer for\n   compatibility with old versions of OSF/1 where iov_len\n   was defined as int. */\nstatic int\nosf_fix_iov_len(const struct iovec __user *iov, unsigned long count)\n{\n\tunsigned long i;\n\n\tfor (i = 0 ; i < count ; i++) {\n\t\tint __user *iov_len_high = (int __user *)&iov[i].iov_len + 1;\n\n\t\tif (put_user(0, iov_len_high))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(osf_readv, unsigned long, fd,\n\t\tconst struct iovec __user *, vector, unsigned long, count)\n{\n\tif (unlikely(personality(current->personality) == PER_OSF4))\n\t\tif (osf_fix_iov_len(vector, count))\n\t\t\treturn -EFAULT;\n\treturn sys_readv(fd, vector, count);\n}\n\nSYSCALL_DEFINE3(osf_writev, unsigned long, fd,\n\t\tconst struct iovec __user *, vector, unsigned long, count)\n{\n\tif (unlikely(personality(current->personality) == PER_OSF4))\n\t\tif (osf_fix_iov_len(vector, count))\n\t\t\treturn -EFAULT;\n\treturn sys_writev(fd, vector, count);\n}\n\n#endif\n"], "filenames": ["arch/alpha/kernel/osf_sys.c"], "buggy_code_start_loc": [412], "buggy_code_end_loc": [1025], "fixing_code_start_loc": [412], "fixing_code_end_loc": [1029], "type": "CWE-189", "message": "Integer signedness error in the osf_getdomainname function in arch/alpha/kernel/osf_sys.c in the Linux kernel before 2.6.39.4 on the Alpha platform allows local users to obtain sensitive information from kernel memory via a crafted call.", "other": {"cve": {"id": "CVE-2011-2208", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:54.467", "lastModified": "2023-02-13T04:31:00.023", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer signedness error in the osf_getdomainname function in arch/alpha/kernel/osf_sys.c in the Linux kernel before 2.6.39.4 on the Alpha platform allows local users to obtain sensitive information from kernel memory via a crafted call."}, {"lang": "es", "value": "Error de signo de entero en la funci\u00f3n osf_getdomainname de arch/alpha/kernel/osf_sys.c del kernel de Linux en versiones anteriores a la 2.6.39.4 de la plataforma Alpha permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel a trav\u00e9s de una llamada modificada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.39.3", "matchCriteriaId": "94597E40-EA22-414E-BF5A-A4664E943F09"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:*:*:*:*:*:*:*", "matchCriteriaId": "EAAF54BC-6282-492F-BA52-8792223320ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc1:*:*:*:*:*:*", "matchCriteriaId": "2493C2FB-2BA1-4DB3-BC04-E282C9CD399D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc2:*:*:*:*:*:*", "matchCriteriaId": "18DBC8AF-18ED-4879-8888-23022E494D14"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc3:*:*:*:*:*:*", "matchCriteriaId": "75EB375B-8ADF-4EAB-A3FB-ED5D35E5E719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc4:*:*:*:*:*:*", "matchCriteriaId": "D49BB231-622E-4F20-97C8-E6289933912C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc5:*:*:*:*:*:*", "matchCriteriaId": "2D6859AA-DA7F-4AF9-8443-05962171D6E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc6:*:*:*:*:*:*", "matchCriteriaId": "9B79A89D-F048-48C5-B148-4B38A6C3953B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc7:*:*:*:*:*:*", "matchCriteriaId": "BEBA9217-9105-4BA3-BE1E-FE387FECEF87"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39.1:*:*:*:*:*:*:*", "matchCriteriaId": "1713DDF4-33F1-4716-84D7-FCFECCF9BCCA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39.2:*:*:*:*:*:*:*", "matchCriteriaId": "ABCE5879-317D-4A33-B6DA-A9ACF553F8E9"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39.4", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=21c5977a836e399fc710ff2c5367845ed5c2527f", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/06/15/7", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f"}}