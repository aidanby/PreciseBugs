{"buggy_code": ["// Copyright 2023 The Gitea Authors. All rights reserved.\n// SPDX-License-Identifier: MIT\n\npackage context\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tuser_model \"code.gitea.io/gitea/models/user\"\n\t\"code.gitea.io/gitea/modules/base\"\n\t\"code.gitea.io/gitea/modules/log\"\n\t\"code.gitea.io/gitea/modules/setting\"\n\t\"code.gitea.io/gitea/modules/templates\"\n\t\"code.gitea.io/gitea/modules/web/middleware\"\n)\n\n// RedirectToUser redirect to a differently-named user\nfunc RedirectToUser(ctx *Base, userName string, redirectUserID int64) {\n\tuser, err := user_model.GetUserByID(ctx, redirectUserID)\n\tif err != nil {\n\t\tctx.Error(http.StatusInternalServerError, \"unable to get user\")\n\t\treturn\n\t}\n\n\tredirectPath := strings.Replace(\n\t\tctx.Req.URL.EscapedPath(),\n\t\turl.PathEscape(userName),\n\t\turl.PathEscape(user.Name),\n\t\t1,\n\t)\n\tif ctx.Req.URL.RawQuery != \"\" {\n\t\tredirectPath += \"?\" + ctx.Req.URL.RawQuery\n\t}\n\tctx.Redirect(path.Join(setting.AppSubURL, redirectPath), http.StatusTemporaryRedirect)\n}\n\n// RedirectToFirst redirects to first not empty URL\nfunc (ctx *Context) RedirectToFirst(location ...string) {\n\tfor _, loc := range location {\n\t\tif len(loc) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Unfortunately browsers consider a redirect Location with preceding \"//\" and \"/\\\" as meaning redirect to \"http(s)://REST_OF_PATH\"\n\t\t// Therefore we should ignore these redirect locations to prevent open redirects\n\t\tif len(loc) > 1 && loc[0] == '/' && (loc[1] == '/' || loc[1] == '\\\\') {\n\t\t\tcontinue\n\t\t}\n\n\t\tu, err := url.Parse(loc)\n\t\tif err != nil || ((u.Scheme != \"\" || u.Host != \"\") && !strings.HasPrefix(strings.ToLower(loc), strings.ToLower(setting.AppURL))) {\n\t\t\tcontinue\n\t\t}\n\n\t\tctx.Redirect(loc)\n\t\treturn\n\t}\n\n\tctx.Redirect(setting.AppSubURL + \"/\")\n}\n\nconst tplStatus500 base.TplName = \"status/500\"\n\n// HTML calls Context.HTML and renders the template to HTTP response\nfunc (ctx *Context) HTML(status int, name base.TplName) {\n\tlog.Debug(\"Template: %s\", name)\n\n\ttmplStartTime := time.Now()\n\tif !setting.IsProd {\n\t\tctx.Data[\"TemplateName\"] = name\n\t}\n\tctx.Data[\"TemplateLoadTimes\"] = func() string {\n\t\treturn strconv.FormatInt(time.Since(tmplStartTime).Nanoseconds()/1e6, 10) + \"ms\"\n\t}\n\n\terr := ctx.Render.HTML(ctx.Resp, status, string(name), ctx.Data)\n\tif err == nil {\n\t\treturn\n\t}\n\n\t// if rendering fails, show error page\n\tif name != tplStatus500 {\n\t\terr = fmt.Errorf(\"failed to render template: %s, error: %s\", name, templates.HandleTemplateRenderingError(err))\n\t\tctx.ServerError(\"Render failed\", err) // show the 500 error page\n\t} else {\n\t\tctx.PlainText(http.StatusInternalServerError, \"Unable to render status/500 page, the template system is broken, or Gitea can't find your template files.\")\n\t\treturn\n\t}\n}\n\n// RenderToString renders the template content to a string\nfunc (ctx *Context) RenderToString(name base.TplName, data map[string]interface{}) (string, error) {\n\tvar buf strings.Builder\n\terr := ctx.Render.HTML(&buf, http.StatusOK, string(name), data)\n\treturn buf.String(), err\n}\n\n// RenderWithErr used for page has form validation but need to prompt error to users.\nfunc (ctx *Context) RenderWithErr(msg string, tpl base.TplName, form interface{}) {\n\tif form != nil {\n\t\tmiddleware.AssignForm(form, ctx.Data)\n\t}\n\tctx.Flash.ErrorMsg = msg\n\tctx.Data[\"Flash\"] = ctx.Flash\n\tctx.HTML(http.StatusOK, tpl)\n}\n\n// NotFound displays a 404 (Not Found) page and prints the given error, if any.\nfunc (ctx *Context) NotFound(logMsg string, logErr error) {\n\tctx.notFoundInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) notFoundInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.Log(2, log.DEBUG, \"%s: %v\", logMsg, logErr)\n\t\tif !setting.IsProd {\n\t\t\tctx.Data[\"ErrorMsg\"] = logErr\n\t\t}\n\t}\n\n\t// response simple message if Accept isn't text/html\n\tshowHTML := false\n\tfor _, part := range ctx.Req.Header[\"Accept\"] {\n\t\tif strings.Contains(part, \"text/html\") {\n\t\t\tshowHTML = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !showHTML {\n\t\tctx.plainTextInternal(3, http.StatusNotFound, []byte(\"Not found.\\n\"))\n\t\treturn\n\t}\n\n\tctx.Data[\"IsRepo\"] = ctx.Repo.Repository != nil\n\tctx.Data[\"Title\"] = \"Page Not Found\"\n\tctx.HTML(http.StatusNotFound, base.TplName(\"status/404\"))\n}\n\n// ServerError displays a 500 (Internal Server Error) page and prints the given error, if any.\nfunc (ctx *Context) ServerError(logMsg string, logErr error) {\n\tctx.serverErrorInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) serverErrorInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.ErrorWithSkip(2, \"%s: %v\", logMsg, logErr)\n\t\tif _, ok := logErr.(*net.OpError); ok || errors.Is(logErr, &net.OpError{}) {\n\t\t\t// This is an error within the underlying connection\n\t\t\t// and further rendering will not work so just return\n\t\t\treturn\n\t\t}\n\n\t\t// it's safe to show internal error to admin users, and it helps\n\t\tif !setting.IsProd || (ctx.Doer != nil && ctx.Doer.IsAdmin) {\n\t\t\tctx.Data[\"ErrorMsg\"] = fmt.Sprintf(\"%s, %s\", logMsg, logErr)\n\t\t}\n\t}\n\n\tctx.Data[\"Title\"] = \"Internal Server Error\"\n\tctx.HTML(http.StatusInternalServerError, tplStatus500)\n}\n\n// NotFoundOrServerError use error check function to determine if the error\n// is about not found. It responds with 404 status code for not found error,\n// or error context description for logging purpose of 500 server error.\nfunc (ctx *Context) NotFoundOrServerError(logMsg string, errCheck func(error) bool, logErr error) {\n\tif errCheck(logErr) {\n\t\tctx.notFoundInternal(logMsg, logErr)\n\t\treturn\n\t}\n\tctx.serverErrorInternal(logMsg, logErr)\n}\n"], "fixing_code": ["// Copyright 2023 The Gitea Authors. All rights reserved.\n// SPDX-License-Identifier: MIT\n\npackage context\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tuser_model \"code.gitea.io/gitea/models/user\"\n\t\"code.gitea.io/gitea/modules/base\"\n\t\"code.gitea.io/gitea/modules/log\"\n\t\"code.gitea.io/gitea/modules/setting\"\n\t\"code.gitea.io/gitea/modules/templates\"\n\t\"code.gitea.io/gitea/modules/web/middleware\"\n)\n\n// RedirectToUser redirect to a differently-named user\nfunc RedirectToUser(ctx *Base, userName string, redirectUserID int64) {\n\tuser, err := user_model.GetUserByID(ctx, redirectUserID)\n\tif err != nil {\n\t\tctx.Error(http.StatusInternalServerError, \"unable to get user\")\n\t\treturn\n\t}\n\n\tredirectPath := strings.Replace(\n\t\tctx.Req.URL.EscapedPath(),\n\t\turl.PathEscape(userName),\n\t\turl.PathEscape(user.Name),\n\t\t1,\n\t)\n\tif ctx.Req.URL.RawQuery != \"\" {\n\t\tredirectPath += \"?\" + ctx.Req.URL.RawQuery\n\t}\n\tctx.Redirect(path.Join(setting.AppSubURL, redirectPath), http.StatusTemporaryRedirect)\n}\n\n// RedirectToFirst redirects to first not empty URL\nfunc (ctx *Context) RedirectToFirst(location ...string) {\n\tfor _, loc := range location {\n\t\tif len(loc) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Unfortunately browsers consider a redirect Location with preceding \"//\", \"\\\\\" and \"/\\\" as meaning redirect to \"http(s)://REST_OF_PATH\"\n\t\t// Therefore we should ignore these redirect locations to prevent open redirects\n\t\tif len(loc) > 1 && (loc[0] == '/' || loc[0] == '\\\\') && (loc[1] == '/' || loc[1] == '\\\\') {\n\t\t\tcontinue\n\t\t}\n\n\t\tu, err := url.Parse(loc)\n\t\tif err != nil || ((u.Scheme != \"\" || u.Host != \"\") && !strings.HasPrefix(strings.ToLower(loc), strings.ToLower(setting.AppURL))) {\n\t\t\tcontinue\n\t\t}\n\n\t\tctx.Redirect(loc)\n\t\treturn\n\t}\n\n\tctx.Redirect(setting.AppSubURL + \"/\")\n}\n\nconst tplStatus500 base.TplName = \"status/500\"\n\n// HTML calls Context.HTML and renders the template to HTTP response\nfunc (ctx *Context) HTML(status int, name base.TplName) {\n\tlog.Debug(\"Template: %s\", name)\n\n\ttmplStartTime := time.Now()\n\tif !setting.IsProd {\n\t\tctx.Data[\"TemplateName\"] = name\n\t}\n\tctx.Data[\"TemplateLoadTimes\"] = func() string {\n\t\treturn strconv.FormatInt(time.Since(tmplStartTime).Nanoseconds()/1e6, 10) + \"ms\"\n\t}\n\n\terr := ctx.Render.HTML(ctx.Resp, status, string(name), ctx.Data)\n\tif err == nil {\n\t\treturn\n\t}\n\n\t// if rendering fails, show error page\n\tif name != tplStatus500 {\n\t\terr = fmt.Errorf(\"failed to render template: %s, error: %s\", name, templates.HandleTemplateRenderingError(err))\n\t\tctx.ServerError(\"Render failed\", err) // show the 500 error page\n\t} else {\n\t\tctx.PlainText(http.StatusInternalServerError, \"Unable to render status/500 page, the template system is broken, or Gitea can't find your template files.\")\n\t\treturn\n\t}\n}\n\n// RenderToString renders the template content to a string\nfunc (ctx *Context) RenderToString(name base.TplName, data map[string]interface{}) (string, error) {\n\tvar buf strings.Builder\n\terr := ctx.Render.HTML(&buf, http.StatusOK, string(name), data)\n\treturn buf.String(), err\n}\n\n// RenderWithErr used for page has form validation but need to prompt error to users.\nfunc (ctx *Context) RenderWithErr(msg string, tpl base.TplName, form interface{}) {\n\tif form != nil {\n\t\tmiddleware.AssignForm(form, ctx.Data)\n\t}\n\tctx.Flash.ErrorMsg = msg\n\tctx.Data[\"Flash\"] = ctx.Flash\n\tctx.HTML(http.StatusOK, tpl)\n}\n\n// NotFound displays a 404 (Not Found) page and prints the given error, if any.\nfunc (ctx *Context) NotFound(logMsg string, logErr error) {\n\tctx.notFoundInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) notFoundInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.Log(2, log.DEBUG, \"%s: %v\", logMsg, logErr)\n\t\tif !setting.IsProd {\n\t\t\tctx.Data[\"ErrorMsg\"] = logErr\n\t\t}\n\t}\n\n\t// response simple message if Accept isn't text/html\n\tshowHTML := false\n\tfor _, part := range ctx.Req.Header[\"Accept\"] {\n\t\tif strings.Contains(part, \"text/html\") {\n\t\t\tshowHTML = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !showHTML {\n\t\tctx.plainTextInternal(3, http.StatusNotFound, []byte(\"Not found.\\n\"))\n\t\treturn\n\t}\n\n\tctx.Data[\"IsRepo\"] = ctx.Repo.Repository != nil\n\tctx.Data[\"Title\"] = \"Page Not Found\"\n\tctx.HTML(http.StatusNotFound, base.TplName(\"status/404\"))\n}\n\n// ServerError displays a 500 (Internal Server Error) page and prints the given error, if any.\nfunc (ctx *Context) ServerError(logMsg string, logErr error) {\n\tctx.serverErrorInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) serverErrorInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.ErrorWithSkip(2, \"%s: %v\", logMsg, logErr)\n\t\tif _, ok := logErr.(*net.OpError); ok || errors.Is(logErr, &net.OpError{}) {\n\t\t\t// This is an error within the underlying connection\n\t\t\t// and further rendering will not work so just return\n\t\t\treturn\n\t\t}\n\n\t\t// it's safe to show internal error to admin users, and it helps\n\t\tif !setting.IsProd || (ctx.Doer != nil && ctx.Doer.IsAdmin) {\n\t\t\tctx.Data[\"ErrorMsg\"] = fmt.Sprintf(\"%s, %s\", logMsg, logErr)\n\t\t}\n\t}\n\n\tctx.Data[\"Title\"] = \"Internal Server Error\"\n\tctx.HTML(http.StatusInternalServerError, tplStatus500)\n}\n\n// NotFoundOrServerError use error check function to determine if the error\n// is about not found. It responds with 404 status code for not found error,\n// or error context description for logging purpose of 500 server error.\nfunc (ctx *Context) NotFoundOrServerError(logMsg string, errCheck func(error) bool, logErr error) {\n\tif errCheck(logErr) {\n\t\tctx.notFoundInternal(logMsg, logErr)\n\t\treturn\n\t}\n\tctx.serverErrorInternal(logMsg, logErr)\n}\n"], "filenames": ["modules/context/context_response.go"], "buggy_code_start_loc": [52], "buggy_code_end_loc": [55], "fixing_code_start_loc": [52], "fixing_code_end_loc": [55], "type": "CWE-601", "message": "Open Redirect in GitHub repository go-gitea/gitea prior to 1.19.4.", "other": {"cve": {"id": "CVE-2023-3515", "sourceIdentifier": "security@huntr.dev", "published": "2023-07-05T15:15:09.933", "lastModified": "2023-12-23T11:15:07.817", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Open Redirect in GitHub repository go-gitea/gitea prior to 1.19.4."}, {"lang": "es", "value": "Vulnerabilidad de redireccionamiento abierto en el repositorio de GitHub go-Gitea/Gitea antes de 1.19.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.0, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitea:gitea:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.19.4", "matchCriteriaId": "FC12DBDF-CB92-4D4E-A1E3-CFB4FBBF0F05"}]}]}], "references": [{"url": "https://github.com/go-gitea/gitea/commit/9aaaf980f0ba15611f30568bd67bce3ec12954e2", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/e335cd18-bc4d-4585-adb7-426c817ed053", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202312-13", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/go-gitea/gitea/commit/9aaaf980f0ba15611f30568bd67bce3ec12954e2"}}