{"buggy_code": ["/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage opts\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/containerd/containerd/containers\"\n\t\"github.com/containerd/containerd/log\"\n\t\"github.com/containerd/containerd/mount\"\n\t\"github.com/containerd/containerd/oci\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\truntimespec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1alpha2\"\n\n\t\"github.com/containerd/containerd/pkg/cri/util\"\n\tosinterface \"github.com/containerd/containerd/pkg/os\"\n)\n\n// WithAdditionalGIDs adds any additional groups listed for a particular user in the\n// /etc/groups file of the image's root filesystem to the OCI spec's additionalGids array.\nfunc WithAdditionalGIDs(userstr string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\tgids := s.Process.User.AdditionalGids\n\t\tif err := oci.WithAdditionalGIDs(userstr)(ctx, client, c, s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Merge existing gids and new gids.\n\t\ts.Process.User.AdditionalGids = mergeGids(s.Process.User.AdditionalGids, gids)\n\t\treturn nil\n\t}\n}\n\nfunc mergeGids(gids1, gids2 []uint32) []uint32 {\n\tgidsMap := make(map[uint32]struct{})\n\tfor _, gid1 := range gids1 {\n\t\tgidsMap[gid1] = struct{}{}\n\t}\n\tfor _, gid2 := range gids2 {\n\t\tgidsMap[gid2] = struct{}{}\n\t}\n\tvar gids []uint32\n\tfor gid := range gidsMap {\n\t\tgids = append(gids, gid)\n\t}\n\tsort.Slice(gids, func(i, j int) bool { return gids[i] < gids[j] })\n\treturn gids\n}\n\n// WithoutRunMount removes the `/run` inside the spec\nfunc WithoutRunMount(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tvar (\n\t\tmounts  []runtimespec.Mount\n\t\tcurrent = s.Mounts\n\t)\n\tfor _, m := range current {\n\t\tif filepath.Clean(m.Destination) == \"/run\" {\n\t\t\tcontinue\n\t\t}\n\t\tmounts = append(mounts, m)\n\t}\n\ts.Mounts = mounts\n\treturn nil\n}\n\n// WithoutDefaultSecuritySettings removes the default security settings generated on a spec\nfunc WithoutDefaultSecuritySettings(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Process == nil {\n\t\ts.Process = &runtimespec.Process{}\n\t}\n\t// Make sure no default seccomp/apparmor is specified\n\ts.Process.ApparmorProfile = \"\"\n\tif s.Linux != nil {\n\t\ts.Linux.Seccomp = nil\n\t}\n\t// Remove default rlimits (See issue #515)\n\ts.Process.Rlimits = nil\n\treturn nil\n}\n\n// WithMounts sorts and adds runtime and CRI mounts to the spec\nfunc WithMounts(osi osinterface.OS, config *runtime.ContainerConfig, extra []*runtime.Mount, mountLabel string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, _ *containers.Container, s *runtimespec.Spec) (err error) {\n\t\t// mergeMounts merge CRI mounts with extra mounts. If a mount destination\n\t\t// is mounted by both a CRI mount and an extra mount, the CRI mount will\n\t\t// be kept.\n\t\tvar (\n\t\t\tcriMounts = config.GetMounts()\n\t\t\tmounts    = append([]*runtime.Mount{}, criMounts...)\n\t\t)\n\t\t// Copy all mounts from extra mounts, except for mounts overridden by CRI.\n\t\tfor _, e := range extra {\n\t\t\tfound := false\n\t\t\tfor _, c := range criMounts {\n\t\t\t\tif filepath.Clean(e.ContainerPath) == filepath.Clean(c.ContainerPath) {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tmounts = append(mounts, e)\n\t\t\t}\n\t\t}\n\n\t\t// Sort mounts in number of parts. This ensures that high level mounts don't\n\t\t// shadow other mounts.\n\t\tsort.Sort(orderedMounts(mounts))\n\n\t\t// Mount cgroup into the container as readonly, which inherits docker's behavior.\n\t\ts.Mounts = append(s.Mounts, runtimespec.Mount{\n\t\t\tSource:      \"cgroup\",\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tType:        \"cgroup\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"ro\"},\n\t\t})\n\n\t\t// Copy all mounts from default mounts, except for\n\t\t// - mounts overridden by supplied mount;\n\t\t// - all mounts under /dev if a supplied /dev is present.\n\t\tmountSet := make(map[string]struct{})\n\t\tfor _, m := range mounts {\n\t\t\tmountSet[filepath.Clean(m.ContainerPath)] = struct{}{}\n\t\t}\n\n\t\tdefaultMounts := s.Mounts\n\t\ts.Mounts = nil\n\n\t\tfor _, m := range defaultMounts {\n\t\t\tdst := filepath.Clean(m.Destination)\n\t\t\tif _, ok := mountSet[dst]; ok {\n\t\t\t\t// filter out mount overridden by a supplied mount\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, mountDev := mountSet[\"/dev\"]; mountDev && strings.HasPrefix(dst, \"/dev/\") {\n\t\t\t\t// filter out everything under /dev if /dev is a supplied mount\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.Mounts = append(s.Mounts, m)\n\t\t}\n\n\t\tfor _, mount := range mounts {\n\t\t\tvar (\n\t\t\t\tdst = mount.GetContainerPath()\n\t\t\t\tsrc = mount.GetHostPath()\n\t\t\t)\n\t\t\t// Create the host path if it doesn't exist.\n\t\t\t// TODO(random-liu): Add CRI validation test for this case.\n\t\t\tif _, err := osi.Stat(src); err != nil {\n\t\t\t\tif !os.IsNotExist(err) {\n\t\t\t\t\treturn errors.Wrapf(err, \"failed to stat %q\", src)\n\t\t\t\t}\n\t\t\t\tif err := osi.MkdirAll(src, 0755); err != nil {\n\t\t\t\t\treturn errors.Wrapf(err, \"failed to mkdir %q\", src)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO(random-liu): Add cri-containerd integration test or cri validation test\n\t\t\t// for this.\n\t\t\tsrc, err := osi.ResolveSymbolicLink(src)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"failed to resolve symlink %q\", src)\n\t\t\t}\n\t\t\tif s.Linux == nil {\n\t\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t\t}\n\t\t\toptions := []string{\"rbind\"}\n\t\t\tswitch mount.GetPropagation() {\n\t\t\tcase runtime.MountPropagation_PROPAGATION_PRIVATE:\n\t\t\t\toptions = append(options, \"rprivate\")\n\t\t\t\t// Since default root propagation in runc is rprivate ignore\n\t\t\t\t// setting the root propagation\n\t\t\tcase runtime.MountPropagation_PROPAGATION_BIDIRECTIONAL:\n\t\t\t\tif err := ensureShared(src, osi.(osinterface.UNIX).LookupMount); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\toptions = append(options, \"rshared\")\n\t\t\t\ts.Linux.RootfsPropagation = \"rshared\"\n\t\t\tcase runtime.MountPropagation_PROPAGATION_HOST_TO_CONTAINER:\n\t\t\t\tif err := ensureSharedOrSlave(src, osi.(osinterface.UNIX).LookupMount); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\toptions = append(options, \"rslave\")\n\t\t\t\tif s.Linux.RootfsPropagation != \"rshared\" &&\n\t\t\t\t\ts.Linux.RootfsPropagation != \"rslave\" {\n\t\t\t\t\ts.Linux.RootfsPropagation = \"rslave\"\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tlog.G(ctx).Warnf(\"Unknown propagation mode for hostPath %q\", mount.HostPath)\n\t\t\t\toptions = append(options, \"rprivate\")\n\t\t\t}\n\n\t\t\t// NOTE(random-liu): we don't change all mounts to `ro` when root filesystem\n\t\t\t// is readonly. This is different from docker's behavior, but make more sense.\n\t\t\tif mount.GetReadonly() {\n\t\t\t\toptions = append(options, \"ro\")\n\t\t\t} else {\n\t\t\t\toptions = append(options, \"rw\")\n\t\t\t}\n\n\t\t\tif mount.GetSelinuxRelabel() {\n\t\t\t\tif err := label.Relabel(src, mountLabel, false); err != nil && err != unix.ENOTSUP {\n\t\t\t\t\treturn errors.Wrapf(err, \"relabel %q with %q failed\", src, mountLabel)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.Mounts = append(s.Mounts, runtimespec.Mount{\n\t\t\t\tSource:      src,\n\t\t\t\tDestination: dst,\n\t\t\t\tType:        \"bind\",\n\t\t\t\tOptions:     options,\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// Ensure mount point on which path is mounted, is shared.\nfunc ensureShared(path string, lookupMount func(string) (mount.Info, error)) error {\n\tmountInfo, err := lookupMount(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure source mount point is shared.\n\toptsSplit := strings.Split(mountInfo.Optional, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.Errorf(\"path %q is mounted on %q but it is not a shared mount\", path, mountInfo.Mountpoint)\n}\n\n// ensure mount point on which path is mounted, is either shared or slave.\nfunc ensureSharedOrSlave(path string, lookupMount func(string) (mount.Info, error)) error {\n\tmountInfo, err := lookupMount(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Make sure source mount point is shared.\n\toptsSplit := strings.Split(mountInfo.Optional, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\treturn nil\n\t\t} else if strings.HasPrefix(opt, \"master:\") {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.Errorf(\"path %q is mounted on %q but it is not a shared or slave mount\", path, mountInfo.Mountpoint)\n}\n\nfunc addDevice(s *runtimespec.Spec, rd runtimespec.LinuxDevice) {\n\tfor i, dev := range s.Linux.Devices {\n\t\tif dev.Path == rd.Path {\n\t\t\ts.Linux.Devices[i] = rd\n\t\t\treturn\n\t\t}\n\t}\n\ts.Linux.Devices = append(s.Linux.Devices, rd)\n}\n\n// WithDevices sets the provided devices onto the container spec\nfunc WithDevices(osi osinterface.OS, config *runtime.ContainerConfig) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Linux.Resources == nil {\n\t\t\ts.Linux.Resources = &runtimespec.LinuxResources{}\n\t\t}\n\t\tfor _, device := range config.GetDevices() {\n\t\t\tpath, err := osi.ResolveSymbolicLink(device.HostPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdev, err := devices.DeviceFromPath(path, device.Permissions)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trd := runtimespec.LinuxDevice{\n\t\t\t\tPath:  device.ContainerPath,\n\t\t\t\tType:  string(dev.Type),\n\t\t\t\tMajor: dev.Major,\n\t\t\t\tMinor: dev.Minor,\n\t\t\t\tUID:   &dev.Uid,\n\t\t\t\tGID:   &dev.Gid,\n\t\t\t}\n\n\t\t\taddDevice(s, rd)\n\n\t\t\ts.Linux.Resources.Devices = append(s.Linux.Resources.Devices, runtimespec.LinuxDeviceCgroup{\n\t\t\t\tAllow:  true,\n\t\t\t\tType:   string(dev.Type),\n\t\t\t\tMajor:  &dev.Major,\n\t\t\t\tMinor:  &dev.Minor,\n\t\t\t\tAccess: string(dev.Permissions),\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithCapabilities sets the provided capabilities from the security context\nfunc WithCapabilities(sc *runtime.LinuxContainerSecurityContext) oci.SpecOpts {\n\tcapabilities := sc.GetCapabilities()\n\tif capabilities == nil {\n\t\treturn nullOpt\n\t}\n\n\tvar opts []oci.SpecOpts\n\t// Add/drop all capabilities if \"all\" is specified, so that\n\t// following individual add/drop could still work. E.g.\n\t// AddCapabilities: []string{\"ALL\"}, DropCapabilities: []string{\"CHOWN\"}\n\t// will be all capabilities without `CAP_CHOWN`.\n\tif util.InStringSlice(capabilities.GetAddCapabilities(), \"ALL\") {\n\t\topts = append(opts, oci.WithAllCapabilities)\n\t}\n\tif util.InStringSlice(capabilities.GetDropCapabilities(), \"ALL\") {\n\t\topts = append(opts, oci.WithCapabilities(nil))\n\t}\n\n\tvar caps []string\n\tfor _, c := range capabilities.GetAddCapabilities() {\n\t\tif strings.ToUpper(c) == \"ALL\" {\n\t\t\tcontinue\n\t\t}\n\t\t// Capabilities in CRI doesn't have `CAP_` prefix, so add it.\n\t\tcaps = append(caps, \"CAP_\"+strings.ToUpper(c))\n\t}\n\topts = append(opts, oci.WithAddedCapabilities(caps))\n\n\tcaps = []string{}\n\tfor _, c := range capabilities.GetDropCapabilities() {\n\t\tif strings.ToUpper(c) == \"ALL\" {\n\t\t\tcontinue\n\t\t}\n\t\tcaps = append(caps, \"CAP_\"+strings.ToUpper(c))\n\t}\n\topts = append(opts, oci.WithDroppedCapabilities(caps))\n\treturn oci.Compose(opts...)\n}\n\n// WithoutAmbientCaps removes the ambient caps from the spec\nfunc WithoutAmbientCaps(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Process == nil {\n\t\ts.Process = &runtimespec.Process{}\n\t}\n\tif s.Process.Capabilities == nil {\n\t\ts.Process.Capabilities = &runtimespec.LinuxCapabilities{}\n\t}\n\ts.Process.Capabilities.Ambient = nil\n\treturn nil\n}\n\n// WithDisabledCgroups clears the Cgroups Path from the spec\nfunc WithDisabledCgroups(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Linux == nil {\n\t\ts.Linux = &runtimespec.Linux{}\n\t}\n\ts.Linux.CgroupsPath = \"\"\n\treturn nil\n}\n\n// WithSelinuxLabels sets the mount and process labels\nfunc WithSelinuxLabels(process, mount string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\ts.Linux.MountLabel = mount\n\t\ts.Process.SelinuxLabel = process\n\t\treturn nil\n\t}\n}\n\n// WithResources sets the provided resource restrictions\nfunc WithResources(resources *runtime.LinuxContainerResources, tolerateMissingHugetlbController, disableHugetlbController bool) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif resources == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Linux.Resources == nil {\n\t\t\ts.Linux.Resources = &runtimespec.LinuxResources{}\n\t\t}\n\t\tif s.Linux.Resources.CPU == nil {\n\t\t\ts.Linux.Resources.CPU = &runtimespec.LinuxCPU{}\n\t\t}\n\t\tif s.Linux.Resources.Memory == nil {\n\t\t\ts.Linux.Resources.Memory = &runtimespec.LinuxMemory{}\n\t\t}\n\t\tvar (\n\t\t\tp         = uint64(resources.GetCpuPeriod())\n\t\t\tq         = resources.GetCpuQuota()\n\t\t\tshares    = uint64(resources.GetCpuShares())\n\t\t\tlimit     = resources.GetMemoryLimitInBytes()\n\t\t\thugepages = resources.GetHugepageLimits()\n\t\t)\n\n\t\tif p != 0 {\n\t\t\ts.Linux.Resources.CPU.Period = &p\n\t\t}\n\t\tif q != 0 {\n\t\t\ts.Linux.Resources.CPU.Quota = &q\n\t\t}\n\t\tif shares != 0 {\n\t\t\ts.Linux.Resources.CPU.Shares = &shares\n\t\t}\n\t\tif cpus := resources.GetCpusetCpus(); cpus != \"\" {\n\t\t\ts.Linux.Resources.CPU.Cpus = cpus\n\t\t}\n\t\tif mems := resources.GetCpusetMems(); mems != \"\" {\n\t\t\ts.Linux.Resources.CPU.Mems = resources.GetCpusetMems()\n\t\t}\n\t\tif limit != 0 {\n\t\t\ts.Linux.Resources.Memory.Limit = &limit\n\t\t}\n\t\tif !disableHugetlbController {\n\t\t\tif isHugetlbControllerPresent() {\n\t\t\t\tfor _, limit := range hugepages {\n\t\t\t\t\ts.Linux.Resources.HugepageLimits = append(s.Linux.Resources.HugepageLimits, runtimespec.LinuxHugepageLimit{\n\t\t\t\t\t\tPagesize: limit.PageSize,\n\t\t\t\t\t\tLimit:    limit.Limit,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !tolerateMissingHugetlbController {\n\t\t\t\t\treturn errors.Errorf(\"huge pages limits are specified but hugetlb cgroup controller is missing. \" +\n\t\t\t\t\t\t\"Please set tolerate_missing_hugetlb_controller to `true` to ignore this error\")\n\t\t\t\t}\n\t\t\t\tlogrus.Warn(\"hugetlb cgroup controller is absent. skipping huge pages limits\")\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\nvar (\n\tsupportsHugetlbOnce sync.Once\n\tsupportsHugetlb     bool\n)\n\nfunc isHugetlbControllerPresent() bool {\n\tsupportsHugetlbOnce.Do(func() {\n\t\tsupportsHugetlb = false\n\t\tif IsCgroup2UnifiedMode() {\n\t\t\tsupportsHugetlb, _ = cgroupv2HasHugetlb()\n\t\t} else {\n\t\t\tsupportsHugetlb, _ = cgroupv1HasHugetlb()\n\t\t}\n\t})\n\treturn supportsHugetlb\n}\n\nvar (\n\t_cgroupv1HasHugetlbOnce sync.Once\n\t_cgroupv1HasHugetlb     bool\n\t_cgroupv1HasHugetlbErr  error\n\t_cgroupv2HasHugetlbOnce sync.Once\n\t_cgroupv2HasHugetlb     bool\n\t_cgroupv2HasHugetlbErr  error\n\tisUnifiedOnce           sync.Once\n\tisUnified               bool\n)\n\n// cgroupv1HasHugetlb returns whether the hugetlb controller is present on\n// cgroup v1.\nfunc cgroupv1HasHugetlb() (bool, error) {\n\t_cgroupv1HasHugetlbOnce.Do(func() {\n\t\tif _, err := ioutil.ReadDir(\"/sys/fs/cgroup/hugetlb\"); err != nil {\n\t\t\t_cgroupv1HasHugetlbErr = errors.Wrap(err, \"readdir /sys/fs/cgroup/hugetlb\")\n\t\t\t_cgroupv1HasHugetlb = false\n\t\t} else {\n\t\t\t_cgroupv1HasHugetlbErr = nil\n\t\t\t_cgroupv1HasHugetlb = true\n\t\t}\n\t})\n\treturn _cgroupv1HasHugetlb, _cgroupv1HasHugetlbErr\n}\n\n// cgroupv2HasHugetlb returns whether the hugetlb controller is present on\n// cgroup v2.\nfunc cgroupv2HasHugetlb() (bool, error) {\n\t_cgroupv2HasHugetlbOnce.Do(func() {\n\t\tcontrollers, err := ioutil.ReadFile(\"/sys/fs/cgroup/cgroup.controllers\")\n\t\tif err != nil {\n\t\t\t_cgroupv2HasHugetlbErr = errors.Wrap(err, \"read /sys/fs/cgroup/cgroup.controllers\")\n\t\t\treturn\n\t\t}\n\t\t_cgroupv2HasHugetlb = strings.Contains(string(controllers), \"hugetlb\")\n\t})\n\treturn _cgroupv2HasHugetlb, _cgroupv2HasHugetlbErr\n}\n\n// IsCgroup2UnifiedMode returns whether we are running in cgroup v2 unified mode.\nfunc IsCgroup2UnifiedMode() bool {\n\tisUnifiedOnce.Do(func() {\n\t\tvar st syscall.Statfs_t\n\t\tif err := syscall.Statfs(\"/sys/fs/cgroup\", &st); err != nil {\n\t\t\tpanic(\"cannot statfs cgroup root\")\n\t\t}\n\t\tisUnified = st.Type == unix.CGROUP2_SUPER_MAGIC\n\t})\n\treturn isUnified\n}\n\n// WithOOMScoreAdj sets the oom score\nfunc WithOOMScoreAdj(config *runtime.ContainerConfig, restrict bool) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\n\t\tresources := config.GetLinux().GetResources()\n\t\tif resources == nil {\n\t\t\treturn nil\n\t\t}\n\t\tadj := int(resources.GetOomScoreAdj())\n\t\tif restrict {\n\t\t\tvar err error\n\t\t\tadj, err = restrictOOMScoreAdj(adj)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\ts.Process.OOMScoreAdj = &adj\n\t\treturn nil\n\t}\n}\n\n// WithSysctls sets the provided sysctls onto the spec\nfunc WithSysctls(sysctls map[string]string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Linux.Sysctl == nil {\n\t\t\ts.Linux.Sysctl = make(map[string]string)\n\t\t}\n\t\tfor k, v := range sysctls {\n\t\t\ts.Linux.Sysctl[k] = v\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithPodOOMScoreAdj sets the oom score for the pod sandbox\nfunc WithPodOOMScoreAdj(adj int, restrict bool) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\tif restrict {\n\t\t\tvar err error\n\t\t\tadj, err = restrictOOMScoreAdj(adj)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\ts.Process.OOMScoreAdj = &adj\n\t\treturn nil\n\t}\n}\n\n// WithSupplementalGroups sets the supplemental groups for the process\nfunc WithSupplementalGroups(groups []int64) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\tvar guids []uint32\n\t\tfor _, g := range groups {\n\t\t\tguids = append(guids, uint32(g))\n\t\t}\n\t\ts.Process.User.AdditionalGids = mergeGids(s.Process.User.AdditionalGids, guids)\n\t\treturn nil\n\t}\n}\n\n// WithPodNamespaces sets the pod namespaces for the container\nfunc WithPodNamespaces(config *runtime.LinuxContainerSecurityContext, pid uint32) oci.SpecOpts {\n\tnamespaces := config.GetNamespaceOptions()\n\n\topts := []oci.SpecOpts{\n\t\toci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.NetworkNamespace, Path: GetNetworkNamespace(pid)}),\n\t\toci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.IPCNamespace, Path: GetIPCNamespace(pid)}),\n\t\toci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.UTSNamespace, Path: GetUTSNamespace(pid)}),\n\t}\n\tif namespaces.GetPid() != runtime.NamespaceMode_CONTAINER {\n\t\topts = append(opts, oci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.PIDNamespace, Path: GetPIDNamespace(pid)}))\n\t}\n\treturn oci.Compose(opts...)\n}\n\n// WithDefaultSandboxShares sets the default sandbox CPU shares\nfunc WithDefaultSandboxShares(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Linux == nil {\n\t\ts.Linux = &runtimespec.Linux{}\n\t}\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &runtimespec.LinuxResources{}\n\t}\n\tif s.Linux.Resources.CPU == nil {\n\t\ts.Linux.Resources.CPU = &runtimespec.LinuxCPU{}\n\t}\n\ti := uint64(DefaultSandboxCPUshares)\n\ts.Linux.Resources.CPU.Shares = &i\n\treturn nil\n}\n\n// WithoutNamespace removes the provided namespace\nfunc WithoutNamespace(t runtimespec.LinuxNamespaceType) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Linux == nil {\n\t\t\treturn nil\n\t\t}\n\t\tvar namespaces []runtimespec.LinuxNamespace\n\t\tfor i, ns := range s.Linux.Namespaces {\n\t\t\tif ns.Type != t {\n\t\t\t\tnamespaces = append(namespaces, s.Linux.Namespaces[i])\n\t\t\t}\n\t\t}\n\t\ts.Linux.Namespaces = namespaces\n\t\treturn nil\n\t}\n}\n\nfunc nullOpt(_ context.Context, _ oci.Client, _ *containers.Container, _ *runtimespec.Spec) error {\n\treturn nil\n}\n\nfunc getCurrentOOMScoreAdj() (int, error) {\n\tb, err := ioutil.ReadFile(\"/proc/self/oom_score_adj\")\n\tif err != nil {\n\t\treturn 0, errors.Wrap(err, \"could not get the daemon oom_score_adj\")\n\t}\n\ts := strings.TrimSpace(string(b))\n\ti, err := strconv.Atoi(s)\n\tif err != nil {\n\t\treturn 0, errors.Wrap(err, \"could not get the daemon oom_score_adj\")\n\t}\n\treturn i, nil\n}\n\nfunc restrictOOMScoreAdj(preferredOOMScoreAdj int) (int, error) {\n\tcurrentOOMScoreAdj, err := getCurrentOOMScoreAdj()\n\tif err != nil {\n\t\treturn preferredOOMScoreAdj, err\n\t}\n\tif preferredOOMScoreAdj < currentOOMScoreAdj {\n\t\treturn currentOOMScoreAdj, nil\n\t}\n\treturn preferredOOMScoreAdj, nil\n}\n\nconst (\n\t// netNSFormat is the format of network namespace of a process.\n\tnetNSFormat = \"/proc/%v/ns/net\"\n\t// ipcNSFormat is the format of ipc namespace of a process.\n\tipcNSFormat = \"/proc/%v/ns/ipc\"\n\t// utsNSFormat is the format of uts namespace of a process.\n\tutsNSFormat = \"/proc/%v/ns/uts\"\n\t// pidNSFormat is the format of pid namespace of a process.\n\tpidNSFormat = \"/proc/%v/ns/pid\"\n)\n\n// GetNetworkNamespace returns the network namespace of a process.\nfunc GetNetworkNamespace(pid uint32) string {\n\treturn fmt.Sprintf(netNSFormat, pid)\n}\n\n// GetIPCNamespace returns the ipc namespace of a process.\nfunc GetIPCNamespace(pid uint32) string {\n\treturn fmt.Sprintf(ipcNSFormat, pid)\n}\n\n// GetUTSNamespace returns the uts namespace of a process.\nfunc GetUTSNamespace(pid uint32) string {\n\treturn fmt.Sprintf(utsNSFormat, pid)\n}\n\n// GetPIDNamespace returns the pid namespace of a process.\nfunc GetPIDNamespace(pid uint32) string {\n\treturn fmt.Sprintf(pidNSFormat, pid)\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage server\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/cgroups\"\n\t\"github.com/containerd/containerd/contrib/apparmor\"\n\t\"github.com/containerd/containerd/contrib/seccomp\"\n\t\"github.com/containerd/containerd/oci\"\n\timagespec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\truntimespec \"github.com/opencontainers/runtime-spec/specs-go\"\n\tselinux \"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1alpha2\"\n\n\t\"github.com/containerd/containerd/pkg/cri/annotations\"\n\t\"github.com/containerd/containerd/pkg/cri/config\"\n\tcustomopts \"github.com/containerd/containerd/pkg/cri/opts\"\n)\n\nconst (\n\t// profileNamePrefix is the prefix for loading profiles on a localhost. Eg. AppArmor localhost/profileName.\n\tprofileNamePrefix = \"localhost/\" // TODO (mikebrow): get localhost/ & runtime/default from CRI kubernetes/kubernetes#51747\n\t// runtimeDefault indicates that we should use or create a runtime default profile.\n\truntimeDefault = \"runtime/default\"\n\t// dockerDefault indicates that we should use or create a docker default profile.\n\tdockerDefault = \"docker/default\"\n\t// appArmorDefaultProfileName is name to use when creating a default apparmor profile.\n\tappArmorDefaultProfileName = \"cri-containerd.apparmor.d\"\n\t// unconfinedProfile is a string indicating one should run a pod/containerd without a security profile\n\tunconfinedProfile = \"unconfined\"\n\t// seccompDefaultProfile is the default seccomp profile.\n\tseccompDefaultProfile = dockerDefault\n)\n\n// containerMounts sets up necessary container system file mounts\n// including /dev/shm, /etc/hosts and /etc/resolv.conf.\nfunc (c *criService) containerMounts(sandboxID string, config *runtime.ContainerConfig) []*runtime.Mount {\n\tvar mounts []*runtime.Mount\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tif !isInCRIMounts(etcHostname, config.GetMounts()) {\n\t\t// /etc/hostname is added since 1.1.6, 1.2.4 and 1.3.\n\t\t// For in-place upgrade, the old sandbox doesn't have the hostname file,\n\t\t// do not mount this in that case.\n\t\t// TODO(random-liu): Remove the check and always mount this when\n\t\t// containerd 1.1 and 1.2 are deprecated.\n\t\thostpath := c.getSandboxHostname(sandboxID)\n\t\tif _, err := c.os.Stat(hostpath); err == nil {\n\t\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\t\tContainerPath: etcHostname,\n\t\t\t\tHostPath:      hostpath,\n\t\t\t\tReadonly:      securityContext.GetReadonlyRootfs(),\n\t\t\t})\n\t\t}\n\t}\n\n\tif !isInCRIMounts(etcHosts, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath: etcHosts,\n\t\t\tHostPath:      c.getSandboxHosts(sandboxID),\n\t\t\tReadonly:      securityContext.GetReadonlyRootfs(),\n\t\t})\n\t}\n\n\t// Mount sandbox resolv.config.\n\t// TODO: Need to figure out whether we should always mount it as read-only\n\tif !isInCRIMounts(resolvConfPath, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath: resolvConfPath,\n\t\t\tHostPath:      c.getResolvPath(sandboxID),\n\t\t\tReadonly:      securityContext.GetReadonlyRootfs(),\n\t\t})\n\t}\n\n\tif !isInCRIMounts(devShm, config.GetMounts()) {\n\t\tsandboxDevShm := c.getSandboxDevShm(sandboxID)\n\t\tif securityContext.GetNamespaceOptions().GetIpc() == runtime.NamespaceMode_NODE {\n\t\t\tsandboxDevShm = devShm\n\t\t}\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  devShm,\n\t\t\tHostPath:       sandboxDevShm,\n\t\t\tReadonly:       false,\n\t\t\tSelinuxRelabel: sandboxDevShm != devShm,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc (c *criService) containerSpec(id string, sandboxID string, sandboxPid uint32, netNSPath string, containerName string,\n\tconfig *runtime.ContainerConfig, sandboxConfig *runtime.PodSandboxConfig, imageConfig *imagespec.ImageConfig,\n\textraMounts []*runtime.Mount, ociRuntime config.Runtime) (_ *runtimespec.Spec, retErr error) {\n\n\tspecOpts := []oci.SpecOpts{\n\t\tcustomopts.WithoutRunMount,\n\t}\n\t// only clear the default security settings if the runtime does not have a custom\n\t// base runtime spec spec.  Admins can use this functionality to define\n\t// default ulimits, seccomp, or other default settings.\n\tif ociRuntime.BaseRuntimeSpec == \"\" {\n\t\tspecOpts = append(specOpts, customopts.WithoutDefaultSecuritySettings)\n\t}\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithRelativeRoot(relativeRootfsPath),\n\t\tcustomopts.WithProcessArgs(config, imageConfig),\n\t\toci.WithDefaultPathEnv,\n\t\t// this will be set based on the security context below\n\t\toci.WithNewPrivileges,\n\t)\n\tif config.GetWorkingDir() != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(config.GetWorkingDir()))\n\t} else if imageConfig.WorkingDir != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(imageConfig.WorkingDir))\n\t}\n\n\tif config.GetTty() {\n\t\tspecOpts = append(specOpts, oci.WithTTY)\n\t}\n\n\t// Add HOSTNAME env.\n\tvar (\n\t\terr      error\n\t\thostname = sandboxConfig.GetHostname()\n\t)\n\tif hostname == \"\" {\n\t\tif hostname, err = c.os.Hostname(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv([]string{hostnameEnv + \"=\" + hostname}))\n\n\t// Apply envs from image config first, so that envs from container config\n\t// can override them.\n\tenv := imageConfig.Env\n\tfor _, e := range config.GetEnvs() {\n\t\tenv = append(env, e.GetKey()+\"=\"+e.GetValue())\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv(env))\n\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tlabelOptions, err := toLabel(securityContext.GetSelinuxOptions())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(labelOptions) == 0 {\n\t\t// Use pod level SELinux config\n\t\tif sandbox, err := c.sandboxStore.Get(sandboxID); err == nil {\n\t\t\tlabelOptions, err = selinux.DupSecOpt(sandbox.ProcessLabel)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tprocessLabel, mountLabel, err := label.InitLabels(labelOptions)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to init selinux options %+v\", securityContext.GetSelinuxOptions())\n\t}\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\t_ = label.ReleaseLabel(processLabel)\n\t\t}\n\t}()\n\n\tspecOpts = append(specOpts, customopts.WithMounts(c.os, config, extraMounts, mountLabel))\n\n\tif !c.config.DisableProcMount {\n\t\t// Apply masked paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif maskedPaths := securityContext.GetMaskedPaths(); maskedPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithMaskedPaths(maskedPaths))\n\t\t}\n\n\t\t// Apply readonly paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif readonlyPaths := securityContext.GetReadonlyPaths(); readonlyPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithReadonlyPaths(readonlyPaths))\n\t\t}\n\t}\n\n\tif securityContext.GetPrivileged() {\n\t\tif !sandboxConfig.GetLinux().GetSecurityContext().GetPrivileged() {\n\t\t\treturn nil, errors.New(\"no privileged container allowed in sandbox\")\n\t\t}\n\t\tspecOpts = append(specOpts, oci.WithPrivileged)\n\t\tif !ociRuntime.PrivilegedWithoutHostDevices {\n\t\t\tspecOpts = append(specOpts, oci.WithHostDevices, oci.WithAllDevicesAllowed)\n\t\t} else {\n\t\t\t// add requested devices by the config as host devices are not automatically added\n\t\t\tspecOpts = append(specOpts, customopts.WithDevices(c.os, config), customopts.WithCapabilities(securityContext))\n\t\t}\n\t} else { // not privileged\n\t\tspecOpts = append(specOpts, customopts.WithDevices(c.os, config), customopts.WithCapabilities(securityContext))\n\t}\n\n\t// Clear all ambient capabilities. The implication of non-root + caps\n\t// is not clearly defined in Kubernetes.\n\t// See https://github.com/kubernetes/kubernetes/issues/56374\n\t// Keep docker's behavior for now.\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithoutAmbientCaps,\n\t\tcustomopts.WithSelinuxLabels(processLabel, mountLabel),\n\t)\n\n\t// TODO: Figure out whether we should set no new privilege for sandbox container by default\n\tif securityContext.GetNoNewPrivs() {\n\t\tspecOpts = append(specOpts, oci.WithNoNewPrivileges)\n\t}\n\t// TODO(random-liu): [P1] Set selinux options (privileged or not).\n\tif securityContext.GetReadonlyRootfs() {\n\t\tspecOpts = append(specOpts, oci.WithRootFSReadonly())\n\t}\n\n\tif c.config.DisableCgroup {\n\t\tspecOpts = append(specOpts, customopts.WithDisabledCgroups)\n\t} else {\n\t\tspecOpts = append(specOpts, customopts.WithResources(config.GetLinux().GetResources(), c.config.TolerateMissingHugetlbController, c.config.DisableHugetlbController))\n\t\tif sandboxConfig.GetLinux().GetCgroupParent() != \"\" {\n\t\t\tcgroupsPath := getCgroupsPath(sandboxConfig.GetLinux().GetCgroupParent(), id)\n\t\t\tspecOpts = append(specOpts, oci.WithCgroup(cgroupsPath))\n\t\t}\n\t}\n\n\tsupplementalGroups := securityContext.GetSupplementalGroups()\n\n\tfor pKey, pValue := range getPassthroughAnnotations(sandboxConfig.Annotations,\n\t\tociRuntime.PodAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\tfor pKey, pValue := range getPassthroughAnnotations(config.Annotations,\n\t\tociRuntime.ContainerAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithOOMScoreAdj(config, c.config.RestrictOOMScoreAdj),\n\t\tcustomopts.WithPodNamespaces(securityContext, sandboxPid),\n\t\tcustomopts.WithSupplementalGroups(supplementalGroups),\n\t\tcustomopts.WithAnnotation(annotations.ContainerType, annotations.ContainerTypeContainer),\n\t\tcustomopts.WithAnnotation(annotations.SandboxID, sandboxID),\n\t\tcustomopts.WithAnnotation(annotations.ContainerName, containerName),\n\t)\n\t// cgroupns is used for hiding /sys/fs/cgroup from containers.\n\t// For compatibility, cgroupns is not used when running in cgroup v1 mode or in privileged.\n\t// https://github.com/containers/libpod/issues/4363\n\t// https://github.com/kubernetes/enhancements/blob/0e409b47497e398b369c281074485c8de129694f/keps/sig-node/20191118-cgroups-v2.md#cgroup-namespace\n\tif cgroups.Mode() == cgroups.Unified && !securityContext.GetPrivileged() {\n\t\tspecOpts = append(specOpts, oci.WithLinuxNamespace(\n\t\t\truntimespec.LinuxNamespace{\n\t\t\t\tType: runtimespec.CgroupNamespace,\n\t\t\t}))\n\t}\n\treturn c.runtimeSpec(id, ociRuntime.BaseRuntimeSpec, specOpts...)\n}\n\nfunc (c *criService) containerSpecOpts(config *runtime.ContainerConfig, imageConfig *imagespec.ImageConfig) ([]oci.SpecOpts, error) {\n\tvar specOpts []oci.SpecOpts\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\t// Set container username. This could only be done by containerd, because it needs\n\t// access to the container rootfs. Pass user name to containerd, and let it overwrite\n\t// the spec for us.\n\tuserstr, err := generateUserString(\n\t\tsecurityContext.GetRunAsUsername(),\n\t\tsecurityContext.GetRunAsUser(),\n\t\tsecurityContext.GetRunAsGroup())\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to generate user string\")\n\t}\n\tif userstr == \"\" {\n\t\t// Lastly, since no user override was passed via CRI try to set via OCI\n\t\t// Image\n\t\tuserstr = imageConfig.User\n\t}\n\tif userstr != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithUser(userstr))\n\t}\n\n\tif securityContext.GetRunAsUsername() != \"\" {\n\t\tuserstr = securityContext.GetRunAsUsername()\n\t} else {\n\t\t// Even if RunAsUser is not set, we still call `GetValue` to get uid 0.\n\t\t// Because it is still useful to get additional gids for uid 0.\n\t\tuserstr = strconv.FormatInt(securityContext.GetRunAsUser().GetValue(), 10)\n\t}\n\tspecOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr))\n\n\tasp := securityContext.GetApparmor()\n\tif asp == nil {\n\t\tasp, err = generateApparmorSecurityProfile(securityContext.GetApparmorProfile()) // nolint:staticcheck deprecated but we don't want to remove yet\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to generate apparmor spec opts\")\n\t\t}\n\t}\n\tapparmorSpecOpts, err := generateApparmorSpecOpts(\n\t\tasp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.apparmorEnabled())\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to generate apparmor spec opts\")\n\t}\n\tif apparmorSpecOpts != nil {\n\t\tspecOpts = append(specOpts, apparmorSpecOpts)\n\t}\n\n\tssp := securityContext.GetSeccomp()\n\tif ssp == nil {\n\t\tssp, err = generateSeccompSecurityProfile(\n\t\t\tsecurityContext.GetSeccompProfilePath(), // nolint:staticcheck deprecated but we don't want to remove yet\n\t\t\tc.config.UnsetSeccompProfile)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to generate seccomp spec opts\")\n\t\t}\n\t}\n\tseccompSpecOpts, err := c.generateSeccompSpecOpts(\n\t\tssp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.seccompEnabled())\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to generate seccomp spec opts\")\n\t}\n\tif seccompSpecOpts != nil {\n\t\tspecOpts = append(specOpts, seccompSpecOpts)\n\t}\n\treturn specOpts, nil\n}\n\nfunc generateSeccompSecurityProfile(profilePath string, unsetProfilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\tif unsetProfilePath != \"\" {\n\t\treturn generateSecurityProfile(unsetProfilePath)\n\t}\n\treturn nil, nil\n}\nfunc generateApparmorSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\treturn nil, nil\n}\n\nfunc generateSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tswitch profilePath {\n\tcase runtimeDefault, dockerDefault, \"\":\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_RuntimeDefault,\n\t\t}, nil\n\tcase unconfinedProfile:\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_Unconfined,\n\t\t}, nil\n\tdefault:\n\t\t// Require and Trim default profile name prefix\n\t\tif !strings.HasPrefix(profilePath, profileNamePrefix) {\n\t\t\treturn nil, errors.Errorf(\"invalid profile %q\", profilePath)\n\t\t}\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType:  runtime.SecurityProfile_Localhost,\n\t\t\tLocalhostRef: strings.TrimPrefix(profilePath, profileNamePrefix),\n\t\t}, nil\n\t}\n}\n\n// generateSeccompSpecOpts generates containerd SpecOpts for seccomp.\nfunc (c *criService) generateSeccompSpecOpts(sp *runtime.SecurityProfile, privileged, seccompEnabled bool) (oci.SpecOpts, error) {\n\tif privileged {\n\t\t// Do not set seccomp profile when container is privileged\n\t\treturn nil, nil\n\t}\n\tif !seccompEnabled {\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"seccomp is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\treturn nil, nil\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"seccomp config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set seccomp profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\treturn seccomp.WithDefaultProfile(), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even though it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\treturn seccomp.WithProfile(strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)), nil\n\tdefault:\n\t\treturn nil, errors.New(\"seccomp unknown ProfileType\")\n\t}\n}\n\n// generateApparmorSpecOpts generates containerd SpecOpts for apparmor.\nfunc generateApparmorSpecOpts(sp *runtime.SecurityProfile, privileged, apparmorEnabled bool) (oci.SpecOpts, error) {\n\tif !apparmorEnabled {\n\t\t// Should fail loudly if user try to specify apparmor profile\n\t\t// but we don't support it.\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"apparmor is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\t// Based on kubernetes#51746, default apparmor profile should be applied\n\t\t// for when apparmor is not specified.\n\t\tsp, _ = generateSecurityProfile(\"\")\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"apparmor config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set apparmor profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\tif privileged {\n\t\t\t// Do not set apparmor profile when container is privileged\n\t\t\treturn nil, nil\n\t\t}\n\t\t// TODO (mikebrow): delete created apparmor default profile\n\t\treturn apparmor.WithDefaultProfile(appArmorDefaultProfileName), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even through it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\tappArmorProfile := strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)\n\t\tif profileExists, err := appArmorProfileExists(appArmorProfile); !profileExists {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrap(err, \"failed to generate apparmor spec opts\")\n\t\t\t}\n\t\t\treturn nil, errors.Errorf(\"apparmor profile not found %s\", appArmorProfile)\n\t\t}\n\t\treturn apparmor.WithProfile(appArmorProfile), nil\n\tdefault:\n\t\treturn nil, errors.New(\"apparmor unknown ProfileType\")\n\t}\n}\n\n// appArmorProfileExists scans apparmor/profiles for the requested profile\nfunc appArmorProfileExists(profile string) (bool, error) {\n\tif profile == \"\" {\n\t\treturn false, errors.New(\"nil apparmor profile is not supported\")\n\t}\n\tprofiles, err := os.Open(\"/sys/kernel/security/apparmor/profiles\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer profiles.Close()\n\n\trbuff := bufio.NewReader(profiles)\n\tfor {\n\t\tline, err := rbuff.ReadString('\\n')\n\t\tswitch err {\n\t\tcase nil:\n\t\t\tif strings.HasPrefix(line, profile+\" (\") {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase io.EOF:\n\t\t\treturn false, nil\n\t\tdefault:\n\t\t\treturn false, err\n\t\t}\n\t}\n}\n\n// generateUserString generates valid user string based on OCI Image Spec\n// v1.0.0.\n//\n// CRI defines that the following combinations are valid:\n//\n// (none) -> \"\"\n// username -> username\n// username, uid -> username\n// username, uid, gid -> username:gid\n// username, gid -> username:gid\n// uid -> uid\n// uid, gid -> uid:gid\n// gid -> error\n//\n// TODO(random-liu): Add group name support in CRI.\nfunc generateUserString(username string, uid, gid *runtime.Int64Value) (string, error) {\n\tvar userstr, groupstr string\n\tif uid != nil {\n\t\tuserstr = strconv.FormatInt(uid.GetValue(), 10)\n\t}\n\tif username != \"\" {\n\t\tuserstr = username\n\t}\n\tif gid != nil {\n\t\tgroupstr = strconv.FormatInt(gid.GetValue(), 10)\n\t}\n\tif userstr == \"\" {\n\t\tif groupstr != \"\" {\n\t\t\treturn \"\", errors.Errorf(\"user group %q is specified without user\", groupstr)\n\t\t}\n\t\treturn \"\", nil\n\t}\n\tif groupstr != \"\" {\n\t\tuserstr = userstr + \":\" + groupstr\n\t}\n\treturn userstr, nil\n}\n"], "fixing_code": ["/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage opts\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/containerd/containerd/containers\"\n\t\"github.com/containerd/containerd/log\"\n\t\"github.com/containerd/containerd/mount\"\n\t\"github.com/containerd/containerd/oci\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\truntimespec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1alpha2\"\n\n\t\"github.com/containerd/containerd/pkg/cri/util\"\n\tosinterface \"github.com/containerd/containerd/pkg/os\"\n)\n\n// WithAdditionalGIDs adds any additional groups listed for a particular user in the\n// /etc/groups file of the image's root filesystem to the OCI spec's additionalGids array.\nfunc WithAdditionalGIDs(userstr string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\tgids := s.Process.User.AdditionalGids\n\t\tif err := oci.WithAdditionalGIDs(userstr)(ctx, client, c, s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Merge existing gids and new gids.\n\t\ts.Process.User.AdditionalGids = mergeGids(s.Process.User.AdditionalGids, gids)\n\t\treturn nil\n\t}\n}\n\nfunc mergeGids(gids1, gids2 []uint32) []uint32 {\n\tgidsMap := make(map[uint32]struct{})\n\tfor _, gid1 := range gids1 {\n\t\tgidsMap[gid1] = struct{}{}\n\t}\n\tfor _, gid2 := range gids2 {\n\t\tgidsMap[gid2] = struct{}{}\n\t}\n\tvar gids []uint32\n\tfor gid := range gidsMap {\n\t\tgids = append(gids, gid)\n\t}\n\tsort.Slice(gids, func(i, j int) bool { return gids[i] < gids[j] })\n\treturn gids\n}\n\n// WithoutRunMount removes the `/run` inside the spec\nfunc WithoutRunMount(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tvar (\n\t\tmounts  []runtimespec.Mount\n\t\tcurrent = s.Mounts\n\t)\n\tfor _, m := range current {\n\t\tif filepath.Clean(m.Destination) == \"/run\" {\n\t\t\tcontinue\n\t\t}\n\t\tmounts = append(mounts, m)\n\t}\n\ts.Mounts = mounts\n\treturn nil\n}\n\n// WithoutDefaultSecuritySettings removes the default security settings generated on a spec\nfunc WithoutDefaultSecuritySettings(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Process == nil {\n\t\ts.Process = &runtimespec.Process{}\n\t}\n\t// Make sure no default seccomp/apparmor is specified\n\ts.Process.ApparmorProfile = \"\"\n\tif s.Linux != nil {\n\t\ts.Linux.Seccomp = nil\n\t}\n\t// Remove default rlimits (See issue #515)\n\ts.Process.Rlimits = nil\n\treturn nil\n}\n\n// WithMounts sorts and adds runtime and CRI mounts to the spec\nfunc WithMounts(osi osinterface.OS, config *runtime.ContainerConfig, extra []*runtime.Mount, mountLabel string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, _ *containers.Container, s *runtimespec.Spec) (err error) {\n\t\t// mergeMounts merge CRI mounts with extra mounts. If a mount destination\n\t\t// is mounted by both a CRI mount and an extra mount, the CRI mount will\n\t\t// be kept.\n\t\tvar (\n\t\t\tcriMounts = config.GetMounts()\n\t\t\tmounts    = append([]*runtime.Mount{}, criMounts...)\n\t\t)\n\t\t// Copy all mounts from extra mounts, except for mounts overridden by CRI.\n\t\tfor _, e := range extra {\n\t\t\tfound := false\n\t\t\tfor _, c := range criMounts {\n\t\t\t\tif filepath.Clean(e.ContainerPath) == filepath.Clean(c.ContainerPath) {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tmounts = append(mounts, e)\n\t\t\t}\n\t\t}\n\n\t\t// Sort mounts in number of parts. This ensures that high level mounts don't\n\t\t// shadow other mounts.\n\t\tsort.Sort(orderedMounts(mounts))\n\n\t\t// Mount cgroup into the container as readonly, which inherits docker's behavior.\n\t\ts.Mounts = append(s.Mounts, runtimespec.Mount{\n\t\t\tSource:      \"cgroup\",\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tType:        \"cgroup\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"ro\"},\n\t\t})\n\n\t\t// Copy all mounts from default mounts, except for\n\t\t// - mounts overridden by supplied mount;\n\t\t// - all mounts under /dev if a supplied /dev is present.\n\t\tmountSet := make(map[string]struct{})\n\t\tfor _, m := range mounts {\n\t\t\tmountSet[filepath.Clean(m.ContainerPath)] = struct{}{}\n\t\t}\n\n\t\tdefaultMounts := s.Mounts\n\t\ts.Mounts = nil\n\n\t\tfor _, m := range defaultMounts {\n\t\t\tdst := filepath.Clean(m.Destination)\n\t\t\tif _, ok := mountSet[dst]; ok {\n\t\t\t\t// filter out mount overridden by a supplied mount\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, mountDev := mountSet[\"/dev\"]; mountDev && strings.HasPrefix(dst, \"/dev/\") {\n\t\t\t\t// filter out everything under /dev if /dev is a supplied mount\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.Mounts = append(s.Mounts, m)\n\t\t}\n\n\t\tfor _, mount := range mounts {\n\t\t\tvar (\n\t\t\t\tdst = mount.GetContainerPath()\n\t\t\t\tsrc = mount.GetHostPath()\n\t\t\t)\n\t\t\t// Create the host path if it doesn't exist.\n\t\t\t// TODO(random-liu): Add CRI validation test for this case.\n\t\t\tif _, err := osi.Stat(src); err != nil {\n\t\t\t\tif !os.IsNotExist(err) {\n\t\t\t\t\treturn errors.Wrapf(err, \"failed to stat %q\", src)\n\t\t\t\t}\n\t\t\t\tif err := osi.MkdirAll(src, 0755); err != nil {\n\t\t\t\t\treturn errors.Wrapf(err, \"failed to mkdir %q\", src)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO(random-liu): Add cri-containerd integration test or cri validation test\n\t\t\t// for this.\n\t\t\tsrc, err := osi.ResolveSymbolicLink(src)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"failed to resolve symlink %q\", src)\n\t\t\t}\n\t\t\tif s.Linux == nil {\n\t\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t\t}\n\t\t\toptions := []string{\"rbind\"}\n\t\t\tswitch mount.GetPropagation() {\n\t\t\tcase runtime.MountPropagation_PROPAGATION_PRIVATE:\n\t\t\t\toptions = append(options, \"rprivate\")\n\t\t\t\t// Since default root propagation in runc is rprivate ignore\n\t\t\t\t// setting the root propagation\n\t\t\tcase runtime.MountPropagation_PROPAGATION_BIDIRECTIONAL:\n\t\t\t\tif err := ensureShared(src, osi.(osinterface.UNIX).LookupMount); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\toptions = append(options, \"rshared\")\n\t\t\t\ts.Linux.RootfsPropagation = \"rshared\"\n\t\t\tcase runtime.MountPropagation_PROPAGATION_HOST_TO_CONTAINER:\n\t\t\t\tif err := ensureSharedOrSlave(src, osi.(osinterface.UNIX).LookupMount); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\toptions = append(options, \"rslave\")\n\t\t\t\tif s.Linux.RootfsPropagation != \"rshared\" &&\n\t\t\t\t\ts.Linux.RootfsPropagation != \"rslave\" {\n\t\t\t\t\ts.Linux.RootfsPropagation = \"rslave\"\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tlog.G(ctx).Warnf(\"Unknown propagation mode for hostPath %q\", mount.HostPath)\n\t\t\t\toptions = append(options, \"rprivate\")\n\t\t\t}\n\n\t\t\t// NOTE(random-liu): we don't change all mounts to `ro` when root filesystem\n\t\t\t// is readonly. This is different from docker's behavior, but make more sense.\n\t\t\tif mount.GetReadonly() {\n\t\t\t\toptions = append(options, \"ro\")\n\t\t\t} else {\n\t\t\t\toptions = append(options, \"rw\")\n\t\t\t}\n\n\t\t\tif mount.GetSelinuxRelabel() {\n\t\t\t\tif err := label.Relabel(src, mountLabel, false); err != nil && err != unix.ENOTSUP {\n\t\t\t\t\treturn errors.Wrapf(err, \"relabel %q with %q failed\", src, mountLabel)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.Mounts = append(s.Mounts, runtimespec.Mount{\n\t\t\t\tSource:      src,\n\t\t\t\tDestination: dst,\n\t\t\t\tType:        \"bind\",\n\t\t\t\tOptions:     options,\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t}\n}\n\nconst (\n\tetcHosts       = \"/etc/hosts\"\n\tetcHostname    = \"/etc/hostname\"\n\tresolvConfPath = \"/etc/resolv.conf\"\n)\n\n// WithRelabeledContainerMounts relabels the default container mounts for files in /etc\nfunc WithRelabeledContainerMounts(mountLabel string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, _ *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif mountLabel == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\tfor _, m := range s.Mounts {\n\t\t\tswitch m.Destination {\n\t\t\tcase etcHosts, etcHostname, resolvConfPath:\n\t\t\t\tif err := label.Relabel(m.Source, mountLabel, false); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// Ensure mount point on which path is mounted, is shared.\nfunc ensureShared(path string, lookupMount func(string) (mount.Info, error)) error {\n\tmountInfo, err := lookupMount(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure source mount point is shared.\n\toptsSplit := strings.Split(mountInfo.Optional, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.Errorf(\"path %q is mounted on %q but it is not a shared mount\", path, mountInfo.Mountpoint)\n}\n\n// ensure mount point on which path is mounted, is either shared or slave.\nfunc ensureSharedOrSlave(path string, lookupMount func(string) (mount.Info, error)) error {\n\tmountInfo, err := lookupMount(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Make sure source mount point is shared.\n\toptsSplit := strings.Split(mountInfo.Optional, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\treturn nil\n\t\t} else if strings.HasPrefix(opt, \"master:\") {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.Errorf(\"path %q is mounted on %q but it is not a shared or slave mount\", path, mountInfo.Mountpoint)\n}\n\nfunc addDevice(s *runtimespec.Spec, rd runtimespec.LinuxDevice) {\n\tfor i, dev := range s.Linux.Devices {\n\t\tif dev.Path == rd.Path {\n\t\t\ts.Linux.Devices[i] = rd\n\t\t\treturn\n\t\t}\n\t}\n\ts.Linux.Devices = append(s.Linux.Devices, rd)\n}\n\n// WithDevices sets the provided devices onto the container spec\nfunc WithDevices(osi osinterface.OS, config *runtime.ContainerConfig) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Linux.Resources == nil {\n\t\t\ts.Linux.Resources = &runtimespec.LinuxResources{}\n\t\t}\n\t\tfor _, device := range config.GetDevices() {\n\t\t\tpath, err := osi.ResolveSymbolicLink(device.HostPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdev, err := devices.DeviceFromPath(path, device.Permissions)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trd := runtimespec.LinuxDevice{\n\t\t\t\tPath:  device.ContainerPath,\n\t\t\t\tType:  string(dev.Type),\n\t\t\t\tMajor: dev.Major,\n\t\t\t\tMinor: dev.Minor,\n\t\t\t\tUID:   &dev.Uid,\n\t\t\t\tGID:   &dev.Gid,\n\t\t\t}\n\n\t\t\taddDevice(s, rd)\n\n\t\t\ts.Linux.Resources.Devices = append(s.Linux.Resources.Devices, runtimespec.LinuxDeviceCgroup{\n\t\t\t\tAllow:  true,\n\t\t\t\tType:   string(dev.Type),\n\t\t\t\tMajor:  &dev.Major,\n\t\t\t\tMinor:  &dev.Minor,\n\t\t\t\tAccess: string(dev.Permissions),\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithCapabilities sets the provided capabilities from the security context\nfunc WithCapabilities(sc *runtime.LinuxContainerSecurityContext) oci.SpecOpts {\n\tcapabilities := sc.GetCapabilities()\n\tif capabilities == nil {\n\t\treturn nullOpt\n\t}\n\n\tvar opts []oci.SpecOpts\n\t// Add/drop all capabilities if \"all\" is specified, so that\n\t// following individual add/drop could still work. E.g.\n\t// AddCapabilities: []string{\"ALL\"}, DropCapabilities: []string{\"CHOWN\"}\n\t// will be all capabilities without `CAP_CHOWN`.\n\tif util.InStringSlice(capabilities.GetAddCapabilities(), \"ALL\") {\n\t\topts = append(opts, oci.WithAllCapabilities)\n\t}\n\tif util.InStringSlice(capabilities.GetDropCapabilities(), \"ALL\") {\n\t\topts = append(opts, oci.WithCapabilities(nil))\n\t}\n\n\tvar caps []string\n\tfor _, c := range capabilities.GetAddCapabilities() {\n\t\tif strings.ToUpper(c) == \"ALL\" {\n\t\t\tcontinue\n\t\t}\n\t\t// Capabilities in CRI doesn't have `CAP_` prefix, so add it.\n\t\tcaps = append(caps, \"CAP_\"+strings.ToUpper(c))\n\t}\n\topts = append(opts, oci.WithAddedCapabilities(caps))\n\n\tcaps = []string{}\n\tfor _, c := range capabilities.GetDropCapabilities() {\n\t\tif strings.ToUpper(c) == \"ALL\" {\n\t\t\tcontinue\n\t\t}\n\t\tcaps = append(caps, \"CAP_\"+strings.ToUpper(c))\n\t}\n\topts = append(opts, oci.WithDroppedCapabilities(caps))\n\treturn oci.Compose(opts...)\n}\n\n// WithoutAmbientCaps removes the ambient caps from the spec\nfunc WithoutAmbientCaps(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Process == nil {\n\t\ts.Process = &runtimespec.Process{}\n\t}\n\tif s.Process.Capabilities == nil {\n\t\ts.Process.Capabilities = &runtimespec.LinuxCapabilities{}\n\t}\n\ts.Process.Capabilities.Ambient = nil\n\treturn nil\n}\n\n// WithDisabledCgroups clears the Cgroups Path from the spec\nfunc WithDisabledCgroups(_ context.Context, _ oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Linux == nil {\n\t\ts.Linux = &runtimespec.Linux{}\n\t}\n\ts.Linux.CgroupsPath = \"\"\n\treturn nil\n}\n\n// WithSelinuxLabels sets the mount and process labels\nfunc WithSelinuxLabels(process, mount string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\ts.Linux.MountLabel = mount\n\t\ts.Process.SelinuxLabel = process\n\t\treturn nil\n\t}\n}\n\n// WithResources sets the provided resource restrictions\nfunc WithResources(resources *runtime.LinuxContainerResources, tolerateMissingHugetlbController, disableHugetlbController bool) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) (err error) {\n\t\tif resources == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Linux.Resources == nil {\n\t\t\ts.Linux.Resources = &runtimespec.LinuxResources{}\n\t\t}\n\t\tif s.Linux.Resources.CPU == nil {\n\t\t\ts.Linux.Resources.CPU = &runtimespec.LinuxCPU{}\n\t\t}\n\t\tif s.Linux.Resources.Memory == nil {\n\t\t\ts.Linux.Resources.Memory = &runtimespec.LinuxMemory{}\n\t\t}\n\t\tvar (\n\t\t\tp         = uint64(resources.GetCpuPeriod())\n\t\t\tq         = resources.GetCpuQuota()\n\t\t\tshares    = uint64(resources.GetCpuShares())\n\t\t\tlimit     = resources.GetMemoryLimitInBytes()\n\t\t\thugepages = resources.GetHugepageLimits()\n\t\t)\n\n\t\tif p != 0 {\n\t\t\ts.Linux.Resources.CPU.Period = &p\n\t\t}\n\t\tif q != 0 {\n\t\t\ts.Linux.Resources.CPU.Quota = &q\n\t\t}\n\t\tif shares != 0 {\n\t\t\ts.Linux.Resources.CPU.Shares = &shares\n\t\t}\n\t\tif cpus := resources.GetCpusetCpus(); cpus != \"\" {\n\t\t\ts.Linux.Resources.CPU.Cpus = cpus\n\t\t}\n\t\tif mems := resources.GetCpusetMems(); mems != \"\" {\n\t\t\ts.Linux.Resources.CPU.Mems = resources.GetCpusetMems()\n\t\t}\n\t\tif limit != 0 {\n\t\t\ts.Linux.Resources.Memory.Limit = &limit\n\t\t}\n\t\tif !disableHugetlbController {\n\t\t\tif isHugetlbControllerPresent() {\n\t\t\t\tfor _, limit := range hugepages {\n\t\t\t\t\ts.Linux.Resources.HugepageLimits = append(s.Linux.Resources.HugepageLimits, runtimespec.LinuxHugepageLimit{\n\t\t\t\t\t\tPagesize: limit.PageSize,\n\t\t\t\t\t\tLimit:    limit.Limit,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !tolerateMissingHugetlbController {\n\t\t\t\t\treturn errors.Errorf(\"huge pages limits are specified but hugetlb cgroup controller is missing. \" +\n\t\t\t\t\t\t\"Please set tolerate_missing_hugetlb_controller to `true` to ignore this error\")\n\t\t\t\t}\n\t\t\t\tlogrus.Warn(\"hugetlb cgroup controller is absent. skipping huge pages limits\")\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\nvar (\n\tsupportsHugetlbOnce sync.Once\n\tsupportsHugetlb     bool\n)\n\nfunc isHugetlbControllerPresent() bool {\n\tsupportsHugetlbOnce.Do(func() {\n\t\tsupportsHugetlb = false\n\t\tif IsCgroup2UnifiedMode() {\n\t\t\tsupportsHugetlb, _ = cgroupv2HasHugetlb()\n\t\t} else {\n\t\t\tsupportsHugetlb, _ = cgroupv1HasHugetlb()\n\t\t}\n\t})\n\treturn supportsHugetlb\n}\n\nvar (\n\t_cgroupv1HasHugetlbOnce sync.Once\n\t_cgroupv1HasHugetlb     bool\n\t_cgroupv1HasHugetlbErr  error\n\t_cgroupv2HasHugetlbOnce sync.Once\n\t_cgroupv2HasHugetlb     bool\n\t_cgroupv2HasHugetlbErr  error\n\tisUnifiedOnce           sync.Once\n\tisUnified               bool\n)\n\n// cgroupv1HasHugetlb returns whether the hugetlb controller is present on\n// cgroup v1.\nfunc cgroupv1HasHugetlb() (bool, error) {\n\t_cgroupv1HasHugetlbOnce.Do(func() {\n\t\tif _, err := ioutil.ReadDir(\"/sys/fs/cgroup/hugetlb\"); err != nil {\n\t\t\t_cgroupv1HasHugetlbErr = errors.Wrap(err, \"readdir /sys/fs/cgroup/hugetlb\")\n\t\t\t_cgroupv1HasHugetlb = false\n\t\t} else {\n\t\t\t_cgroupv1HasHugetlbErr = nil\n\t\t\t_cgroupv1HasHugetlb = true\n\t\t}\n\t})\n\treturn _cgroupv1HasHugetlb, _cgroupv1HasHugetlbErr\n}\n\n// cgroupv2HasHugetlb returns whether the hugetlb controller is present on\n// cgroup v2.\nfunc cgroupv2HasHugetlb() (bool, error) {\n\t_cgroupv2HasHugetlbOnce.Do(func() {\n\t\tcontrollers, err := ioutil.ReadFile(\"/sys/fs/cgroup/cgroup.controllers\")\n\t\tif err != nil {\n\t\t\t_cgroupv2HasHugetlbErr = errors.Wrap(err, \"read /sys/fs/cgroup/cgroup.controllers\")\n\t\t\treturn\n\t\t}\n\t\t_cgroupv2HasHugetlb = strings.Contains(string(controllers), \"hugetlb\")\n\t})\n\treturn _cgroupv2HasHugetlb, _cgroupv2HasHugetlbErr\n}\n\n// IsCgroup2UnifiedMode returns whether we are running in cgroup v2 unified mode.\nfunc IsCgroup2UnifiedMode() bool {\n\tisUnifiedOnce.Do(func() {\n\t\tvar st syscall.Statfs_t\n\t\tif err := syscall.Statfs(\"/sys/fs/cgroup\", &st); err != nil {\n\t\t\tpanic(\"cannot statfs cgroup root\")\n\t\t}\n\t\tisUnified = st.Type == unix.CGROUP2_SUPER_MAGIC\n\t})\n\treturn isUnified\n}\n\n// WithOOMScoreAdj sets the oom score\nfunc WithOOMScoreAdj(config *runtime.ContainerConfig, restrict bool) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\n\t\tresources := config.GetLinux().GetResources()\n\t\tif resources == nil {\n\t\t\treturn nil\n\t\t}\n\t\tadj := int(resources.GetOomScoreAdj())\n\t\tif restrict {\n\t\t\tvar err error\n\t\t\tadj, err = restrictOOMScoreAdj(adj)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\ts.Process.OOMScoreAdj = &adj\n\t\treturn nil\n\t}\n}\n\n// WithSysctls sets the provided sysctls onto the spec\nfunc WithSysctls(sysctls map[string]string) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Linux == nil {\n\t\t\ts.Linux = &runtimespec.Linux{}\n\t\t}\n\t\tif s.Linux.Sysctl == nil {\n\t\t\ts.Linux.Sysctl = make(map[string]string)\n\t\t}\n\t\tfor k, v := range sysctls {\n\t\t\ts.Linux.Sysctl[k] = v\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithPodOOMScoreAdj sets the oom score for the pod sandbox\nfunc WithPodOOMScoreAdj(adj int, restrict bool) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\tif restrict {\n\t\t\tvar err error\n\t\t\tadj, err = restrictOOMScoreAdj(adj)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\ts.Process.OOMScoreAdj = &adj\n\t\treturn nil\n\t}\n}\n\n// WithSupplementalGroups sets the supplemental groups for the process\nfunc WithSupplementalGroups(groups []int64) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Process == nil {\n\t\t\ts.Process = &runtimespec.Process{}\n\t\t}\n\t\tvar guids []uint32\n\t\tfor _, g := range groups {\n\t\t\tguids = append(guids, uint32(g))\n\t\t}\n\t\ts.Process.User.AdditionalGids = mergeGids(s.Process.User.AdditionalGids, guids)\n\t\treturn nil\n\t}\n}\n\n// WithPodNamespaces sets the pod namespaces for the container\nfunc WithPodNamespaces(config *runtime.LinuxContainerSecurityContext, pid uint32) oci.SpecOpts {\n\tnamespaces := config.GetNamespaceOptions()\n\n\topts := []oci.SpecOpts{\n\t\toci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.NetworkNamespace, Path: GetNetworkNamespace(pid)}),\n\t\toci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.IPCNamespace, Path: GetIPCNamespace(pid)}),\n\t\toci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.UTSNamespace, Path: GetUTSNamespace(pid)}),\n\t}\n\tif namespaces.GetPid() != runtime.NamespaceMode_CONTAINER {\n\t\topts = append(opts, oci.WithLinuxNamespace(runtimespec.LinuxNamespace{Type: runtimespec.PIDNamespace, Path: GetPIDNamespace(pid)}))\n\t}\n\treturn oci.Compose(opts...)\n}\n\n// WithDefaultSandboxShares sets the default sandbox CPU shares\nfunc WithDefaultSandboxShares(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\tif s.Linux == nil {\n\t\ts.Linux = &runtimespec.Linux{}\n\t}\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &runtimespec.LinuxResources{}\n\t}\n\tif s.Linux.Resources.CPU == nil {\n\t\ts.Linux.Resources.CPU = &runtimespec.LinuxCPU{}\n\t}\n\ti := uint64(DefaultSandboxCPUshares)\n\ts.Linux.Resources.CPU.Shares = &i\n\treturn nil\n}\n\n// WithoutNamespace removes the provided namespace\nfunc WithoutNamespace(t runtimespec.LinuxNamespaceType) oci.SpecOpts {\n\treturn func(ctx context.Context, client oci.Client, c *containers.Container, s *runtimespec.Spec) error {\n\t\tif s.Linux == nil {\n\t\t\treturn nil\n\t\t}\n\t\tvar namespaces []runtimespec.LinuxNamespace\n\t\tfor i, ns := range s.Linux.Namespaces {\n\t\t\tif ns.Type != t {\n\t\t\t\tnamespaces = append(namespaces, s.Linux.Namespaces[i])\n\t\t\t}\n\t\t}\n\t\ts.Linux.Namespaces = namespaces\n\t\treturn nil\n\t}\n}\n\nfunc nullOpt(_ context.Context, _ oci.Client, _ *containers.Container, _ *runtimespec.Spec) error {\n\treturn nil\n}\n\nfunc getCurrentOOMScoreAdj() (int, error) {\n\tb, err := ioutil.ReadFile(\"/proc/self/oom_score_adj\")\n\tif err != nil {\n\t\treturn 0, errors.Wrap(err, \"could not get the daemon oom_score_adj\")\n\t}\n\ts := strings.TrimSpace(string(b))\n\ti, err := strconv.Atoi(s)\n\tif err != nil {\n\t\treturn 0, errors.Wrap(err, \"could not get the daemon oom_score_adj\")\n\t}\n\treturn i, nil\n}\n\nfunc restrictOOMScoreAdj(preferredOOMScoreAdj int) (int, error) {\n\tcurrentOOMScoreAdj, err := getCurrentOOMScoreAdj()\n\tif err != nil {\n\t\treturn preferredOOMScoreAdj, err\n\t}\n\tif preferredOOMScoreAdj < currentOOMScoreAdj {\n\t\treturn currentOOMScoreAdj, nil\n\t}\n\treturn preferredOOMScoreAdj, nil\n}\n\nconst (\n\t// netNSFormat is the format of network namespace of a process.\n\tnetNSFormat = \"/proc/%v/ns/net\"\n\t// ipcNSFormat is the format of ipc namespace of a process.\n\tipcNSFormat = \"/proc/%v/ns/ipc\"\n\t// utsNSFormat is the format of uts namespace of a process.\n\tutsNSFormat = \"/proc/%v/ns/uts\"\n\t// pidNSFormat is the format of pid namespace of a process.\n\tpidNSFormat = \"/proc/%v/ns/pid\"\n)\n\n// GetNetworkNamespace returns the network namespace of a process.\nfunc GetNetworkNamespace(pid uint32) string {\n\treturn fmt.Sprintf(netNSFormat, pid)\n}\n\n// GetIPCNamespace returns the ipc namespace of a process.\nfunc GetIPCNamespace(pid uint32) string {\n\treturn fmt.Sprintf(ipcNSFormat, pid)\n}\n\n// GetUTSNamespace returns the uts namespace of a process.\nfunc GetUTSNamespace(pid uint32) string {\n\treturn fmt.Sprintf(utsNSFormat, pid)\n}\n\n// GetPIDNamespace returns the pid namespace of a process.\nfunc GetPIDNamespace(pid uint32) string {\n\treturn fmt.Sprintf(pidNSFormat, pid)\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage server\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/cgroups\"\n\t\"github.com/containerd/containerd/contrib/apparmor\"\n\t\"github.com/containerd/containerd/contrib/seccomp\"\n\t\"github.com/containerd/containerd/oci\"\n\timagespec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\truntimespec \"github.com/opencontainers/runtime-spec/specs-go\"\n\tselinux \"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1alpha2\"\n\n\t\"github.com/containerd/containerd/pkg/cri/annotations\"\n\t\"github.com/containerd/containerd/pkg/cri/config\"\n\tcustomopts \"github.com/containerd/containerd/pkg/cri/opts\"\n)\n\nconst (\n\t// profileNamePrefix is the prefix for loading profiles on a localhost. Eg. AppArmor localhost/profileName.\n\tprofileNamePrefix = \"localhost/\" // TODO (mikebrow): get localhost/ & runtime/default from CRI kubernetes/kubernetes#51747\n\t// runtimeDefault indicates that we should use or create a runtime default profile.\n\truntimeDefault = \"runtime/default\"\n\t// dockerDefault indicates that we should use or create a docker default profile.\n\tdockerDefault = \"docker/default\"\n\t// appArmorDefaultProfileName is name to use when creating a default apparmor profile.\n\tappArmorDefaultProfileName = \"cri-containerd.apparmor.d\"\n\t// unconfinedProfile is a string indicating one should run a pod/containerd without a security profile\n\tunconfinedProfile = \"unconfined\"\n\t// seccompDefaultProfile is the default seccomp profile.\n\tseccompDefaultProfile = dockerDefault\n)\n\n// containerMounts sets up necessary container system file mounts\n// including /dev/shm, /etc/hosts and /etc/resolv.conf.\nfunc (c *criService) containerMounts(sandboxID string, config *runtime.ContainerConfig) []*runtime.Mount {\n\tvar mounts []*runtime.Mount\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tif !isInCRIMounts(etcHostname, config.GetMounts()) {\n\t\t// /etc/hostname is added since 1.1.6, 1.2.4 and 1.3.\n\t\t// For in-place upgrade, the old sandbox doesn't have the hostname file,\n\t\t// do not mount this in that case.\n\t\t// TODO(random-liu): Remove the check and always mount this when\n\t\t// containerd 1.1 and 1.2 are deprecated.\n\t\thostpath := c.getSandboxHostname(sandboxID)\n\t\tif _, err := c.os.Stat(hostpath); err == nil {\n\t\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\t\tContainerPath: etcHostname,\n\t\t\t\tHostPath:      hostpath,\n\t\t\t\tReadonly:      securityContext.GetReadonlyRootfs(),\n\t\t\t})\n\t\t}\n\t}\n\n\tif !isInCRIMounts(etcHosts, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath: etcHosts,\n\t\t\tHostPath:      c.getSandboxHosts(sandboxID),\n\t\t\tReadonly:      securityContext.GetReadonlyRootfs(),\n\t\t})\n\t}\n\n\t// Mount sandbox resolv.config.\n\t// TODO: Need to figure out whether we should always mount it as read-only\n\tif !isInCRIMounts(resolvConfPath, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath: resolvConfPath,\n\t\t\tHostPath:      c.getResolvPath(sandboxID),\n\t\t\tReadonly:      securityContext.GetReadonlyRootfs(),\n\t\t})\n\t}\n\n\tif !isInCRIMounts(devShm, config.GetMounts()) {\n\t\tsandboxDevShm := c.getSandboxDevShm(sandboxID)\n\t\tif securityContext.GetNamespaceOptions().GetIpc() == runtime.NamespaceMode_NODE {\n\t\t\tsandboxDevShm = devShm\n\t\t}\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  devShm,\n\t\t\tHostPath:       sandboxDevShm,\n\t\t\tReadonly:       false,\n\t\t\tSelinuxRelabel: sandboxDevShm != devShm,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc (c *criService) containerSpec(id string, sandboxID string, sandboxPid uint32, netNSPath string, containerName string,\n\tconfig *runtime.ContainerConfig, sandboxConfig *runtime.PodSandboxConfig, imageConfig *imagespec.ImageConfig,\n\textraMounts []*runtime.Mount, ociRuntime config.Runtime) (_ *runtimespec.Spec, retErr error) {\n\n\tspecOpts := []oci.SpecOpts{\n\t\tcustomopts.WithoutRunMount,\n\t}\n\t// only clear the default security settings if the runtime does not have a custom\n\t// base runtime spec spec.  Admins can use this functionality to define\n\t// default ulimits, seccomp, or other default settings.\n\tif ociRuntime.BaseRuntimeSpec == \"\" {\n\t\tspecOpts = append(specOpts, customopts.WithoutDefaultSecuritySettings)\n\t}\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithRelativeRoot(relativeRootfsPath),\n\t\tcustomopts.WithProcessArgs(config, imageConfig),\n\t\toci.WithDefaultPathEnv,\n\t\t// this will be set based on the security context below\n\t\toci.WithNewPrivileges,\n\t)\n\tif config.GetWorkingDir() != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(config.GetWorkingDir()))\n\t} else if imageConfig.WorkingDir != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(imageConfig.WorkingDir))\n\t}\n\n\tif config.GetTty() {\n\t\tspecOpts = append(specOpts, oci.WithTTY)\n\t}\n\n\t// Add HOSTNAME env.\n\tvar (\n\t\terr      error\n\t\thostname = sandboxConfig.GetHostname()\n\t)\n\tif hostname == \"\" {\n\t\tif hostname, err = c.os.Hostname(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv([]string{hostnameEnv + \"=\" + hostname}))\n\n\t// Apply envs from image config first, so that envs from container config\n\t// can override them.\n\tenv := imageConfig.Env\n\tfor _, e := range config.GetEnvs() {\n\t\tenv = append(env, e.GetKey()+\"=\"+e.GetValue())\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv(env))\n\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tlabelOptions, err := toLabel(securityContext.GetSelinuxOptions())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(labelOptions) == 0 {\n\t\t// Use pod level SELinux config\n\t\tif sandbox, err := c.sandboxStore.Get(sandboxID); err == nil {\n\t\t\tlabelOptions, err = selinux.DupSecOpt(sandbox.ProcessLabel)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tprocessLabel, mountLabel, err := label.InitLabels(labelOptions)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to init selinux options %+v\", securityContext.GetSelinuxOptions())\n\t}\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\t_ = label.ReleaseLabel(processLabel)\n\t\t}\n\t}()\n\n\tspecOpts = append(specOpts, customopts.WithMounts(c.os, config, extraMounts, mountLabel), customopts.WithRelabeledContainerMounts(mountLabel))\n\n\tif !c.config.DisableProcMount {\n\t\t// Apply masked paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif maskedPaths := securityContext.GetMaskedPaths(); maskedPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithMaskedPaths(maskedPaths))\n\t\t}\n\n\t\t// Apply readonly paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif readonlyPaths := securityContext.GetReadonlyPaths(); readonlyPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithReadonlyPaths(readonlyPaths))\n\t\t}\n\t}\n\n\tif securityContext.GetPrivileged() {\n\t\tif !sandboxConfig.GetLinux().GetSecurityContext().GetPrivileged() {\n\t\t\treturn nil, errors.New(\"no privileged container allowed in sandbox\")\n\t\t}\n\t\tspecOpts = append(specOpts, oci.WithPrivileged)\n\t\tif !ociRuntime.PrivilegedWithoutHostDevices {\n\t\t\tspecOpts = append(specOpts, oci.WithHostDevices, oci.WithAllDevicesAllowed)\n\t\t} else {\n\t\t\t// add requested devices by the config as host devices are not automatically added\n\t\t\tspecOpts = append(specOpts, customopts.WithDevices(c.os, config), customopts.WithCapabilities(securityContext))\n\t\t}\n\t} else { // not privileged\n\t\tspecOpts = append(specOpts, customopts.WithDevices(c.os, config), customopts.WithCapabilities(securityContext))\n\t}\n\n\t// Clear all ambient capabilities. The implication of non-root + caps\n\t// is not clearly defined in Kubernetes.\n\t// See https://github.com/kubernetes/kubernetes/issues/56374\n\t// Keep docker's behavior for now.\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithoutAmbientCaps,\n\t\tcustomopts.WithSelinuxLabels(processLabel, mountLabel),\n\t)\n\n\t// TODO: Figure out whether we should set no new privilege for sandbox container by default\n\tif securityContext.GetNoNewPrivs() {\n\t\tspecOpts = append(specOpts, oci.WithNoNewPrivileges)\n\t}\n\t// TODO(random-liu): [P1] Set selinux options (privileged or not).\n\tif securityContext.GetReadonlyRootfs() {\n\t\tspecOpts = append(specOpts, oci.WithRootFSReadonly())\n\t}\n\n\tif c.config.DisableCgroup {\n\t\tspecOpts = append(specOpts, customopts.WithDisabledCgroups)\n\t} else {\n\t\tspecOpts = append(specOpts, customopts.WithResources(config.GetLinux().GetResources(), c.config.TolerateMissingHugetlbController, c.config.DisableHugetlbController))\n\t\tif sandboxConfig.GetLinux().GetCgroupParent() != \"\" {\n\t\t\tcgroupsPath := getCgroupsPath(sandboxConfig.GetLinux().GetCgroupParent(), id)\n\t\t\tspecOpts = append(specOpts, oci.WithCgroup(cgroupsPath))\n\t\t}\n\t}\n\n\tsupplementalGroups := securityContext.GetSupplementalGroups()\n\n\tfor pKey, pValue := range getPassthroughAnnotations(sandboxConfig.Annotations,\n\t\tociRuntime.PodAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\tfor pKey, pValue := range getPassthroughAnnotations(config.Annotations,\n\t\tociRuntime.ContainerAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithOOMScoreAdj(config, c.config.RestrictOOMScoreAdj),\n\t\tcustomopts.WithPodNamespaces(securityContext, sandboxPid),\n\t\tcustomopts.WithSupplementalGroups(supplementalGroups),\n\t\tcustomopts.WithAnnotation(annotations.ContainerType, annotations.ContainerTypeContainer),\n\t\tcustomopts.WithAnnotation(annotations.SandboxID, sandboxID),\n\t\tcustomopts.WithAnnotation(annotations.ContainerName, containerName),\n\t)\n\t// cgroupns is used for hiding /sys/fs/cgroup from containers.\n\t// For compatibility, cgroupns is not used when running in cgroup v1 mode or in privileged.\n\t// https://github.com/containers/libpod/issues/4363\n\t// https://github.com/kubernetes/enhancements/blob/0e409b47497e398b369c281074485c8de129694f/keps/sig-node/20191118-cgroups-v2.md#cgroup-namespace\n\tif cgroups.Mode() == cgroups.Unified && !securityContext.GetPrivileged() {\n\t\tspecOpts = append(specOpts, oci.WithLinuxNamespace(\n\t\t\truntimespec.LinuxNamespace{\n\t\t\t\tType: runtimespec.CgroupNamespace,\n\t\t\t}))\n\t}\n\treturn c.runtimeSpec(id, ociRuntime.BaseRuntimeSpec, specOpts...)\n}\n\nfunc (c *criService) containerSpecOpts(config *runtime.ContainerConfig, imageConfig *imagespec.ImageConfig) ([]oci.SpecOpts, error) {\n\tvar specOpts []oci.SpecOpts\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\t// Set container username. This could only be done by containerd, because it needs\n\t// access to the container rootfs. Pass user name to containerd, and let it overwrite\n\t// the spec for us.\n\tuserstr, err := generateUserString(\n\t\tsecurityContext.GetRunAsUsername(),\n\t\tsecurityContext.GetRunAsUser(),\n\t\tsecurityContext.GetRunAsGroup())\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to generate user string\")\n\t}\n\tif userstr == \"\" {\n\t\t// Lastly, since no user override was passed via CRI try to set via OCI\n\t\t// Image\n\t\tuserstr = imageConfig.User\n\t}\n\tif userstr != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithUser(userstr))\n\t}\n\n\tif securityContext.GetRunAsUsername() != \"\" {\n\t\tuserstr = securityContext.GetRunAsUsername()\n\t} else {\n\t\t// Even if RunAsUser is not set, we still call `GetValue` to get uid 0.\n\t\t// Because it is still useful to get additional gids for uid 0.\n\t\tuserstr = strconv.FormatInt(securityContext.GetRunAsUser().GetValue(), 10)\n\t}\n\tspecOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr))\n\n\tasp := securityContext.GetApparmor()\n\tif asp == nil {\n\t\tasp, err = generateApparmorSecurityProfile(securityContext.GetApparmorProfile()) // nolint:staticcheck deprecated but we don't want to remove yet\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to generate apparmor spec opts\")\n\t\t}\n\t}\n\tapparmorSpecOpts, err := generateApparmorSpecOpts(\n\t\tasp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.apparmorEnabled())\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to generate apparmor spec opts\")\n\t}\n\tif apparmorSpecOpts != nil {\n\t\tspecOpts = append(specOpts, apparmorSpecOpts)\n\t}\n\n\tssp := securityContext.GetSeccomp()\n\tif ssp == nil {\n\t\tssp, err = generateSeccompSecurityProfile(\n\t\t\tsecurityContext.GetSeccompProfilePath(), // nolint:staticcheck deprecated but we don't want to remove yet\n\t\t\tc.config.UnsetSeccompProfile)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to generate seccomp spec opts\")\n\t\t}\n\t}\n\tseccompSpecOpts, err := c.generateSeccompSpecOpts(\n\t\tssp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.seccompEnabled())\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to generate seccomp spec opts\")\n\t}\n\tif seccompSpecOpts != nil {\n\t\tspecOpts = append(specOpts, seccompSpecOpts)\n\t}\n\treturn specOpts, nil\n}\n\nfunc generateSeccompSecurityProfile(profilePath string, unsetProfilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\tif unsetProfilePath != \"\" {\n\t\treturn generateSecurityProfile(unsetProfilePath)\n\t}\n\treturn nil, nil\n}\nfunc generateApparmorSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\treturn nil, nil\n}\n\nfunc generateSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tswitch profilePath {\n\tcase runtimeDefault, dockerDefault, \"\":\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_RuntimeDefault,\n\t\t}, nil\n\tcase unconfinedProfile:\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_Unconfined,\n\t\t}, nil\n\tdefault:\n\t\t// Require and Trim default profile name prefix\n\t\tif !strings.HasPrefix(profilePath, profileNamePrefix) {\n\t\t\treturn nil, errors.Errorf(\"invalid profile %q\", profilePath)\n\t\t}\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType:  runtime.SecurityProfile_Localhost,\n\t\t\tLocalhostRef: strings.TrimPrefix(profilePath, profileNamePrefix),\n\t\t}, nil\n\t}\n}\n\n// generateSeccompSpecOpts generates containerd SpecOpts for seccomp.\nfunc (c *criService) generateSeccompSpecOpts(sp *runtime.SecurityProfile, privileged, seccompEnabled bool) (oci.SpecOpts, error) {\n\tif privileged {\n\t\t// Do not set seccomp profile when container is privileged\n\t\treturn nil, nil\n\t}\n\tif !seccompEnabled {\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"seccomp is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\treturn nil, nil\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"seccomp config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set seccomp profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\treturn seccomp.WithDefaultProfile(), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even though it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\treturn seccomp.WithProfile(strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)), nil\n\tdefault:\n\t\treturn nil, errors.New(\"seccomp unknown ProfileType\")\n\t}\n}\n\n// generateApparmorSpecOpts generates containerd SpecOpts for apparmor.\nfunc generateApparmorSpecOpts(sp *runtime.SecurityProfile, privileged, apparmorEnabled bool) (oci.SpecOpts, error) {\n\tif !apparmorEnabled {\n\t\t// Should fail loudly if user try to specify apparmor profile\n\t\t// but we don't support it.\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"apparmor is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\t// Based on kubernetes#51746, default apparmor profile should be applied\n\t\t// for when apparmor is not specified.\n\t\tsp, _ = generateSecurityProfile(\"\")\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"apparmor config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set apparmor profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\tif privileged {\n\t\t\t// Do not set apparmor profile when container is privileged\n\t\t\treturn nil, nil\n\t\t}\n\t\t// TODO (mikebrow): delete created apparmor default profile\n\t\treturn apparmor.WithDefaultProfile(appArmorDefaultProfileName), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even through it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\tappArmorProfile := strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)\n\t\tif profileExists, err := appArmorProfileExists(appArmorProfile); !profileExists {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrap(err, \"failed to generate apparmor spec opts\")\n\t\t\t}\n\t\t\treturn nil, errors.Errorf(\"apparmor profile not found %s\", appArmorProfile)\n\t\t}\n\t\treturn apparmor.WithProfile(appArmorProfile), nil\n\tdefault:\n\t\treturn nil, errors.New(\"apparmor unknown ProfileType\")\n\t}\n}\n\n// appArmorProfileExists scans apparmor/profiles for the requested profile\nfunc appArmorProfileExists(profile string) (bool, error) {\n\tif profile == \"\" {\n\t\treturn false, errors.New(\"nil apparmor profile is not supported\")\n\t}\n\tprofiles, err := os.Open(\"/sys/kernel/security/apparmor/profiles\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer profiles.Close()\n\n\trbuff := bufio.NewReader(profiles)\n\tfor {\n\t\tline, err := rbuff.ReadString('\\n')\n\t\tswitch err {\n\t\tcase nil:\n\t\t\tif strings.HasPrefix(line, profile+\" (\") {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase io.EOF:\n\t\t\treturn false, nil\n\t\tdefault:\n\t\t\treturn false, err\n\t\t}\n\t}\n}\n\n// generateUserString generates valid user string based on OCI Image Spec\n// v1.0.0.\n//\n// CRI defines that the following combinations are valid:\n//\n// (none) -> \"\"\n// username -> username\n// username, uid -> username\n// username, uid, gid -> username:gid\n// username, gid -> username:gid\n// uid -> uid\n// uid, gid -> uid:gid\n// gid -> error\n//\n// TODO(random-liu): Add group name support in CRI.\nfunc generateUserString(username string, uid, gid *runtime.Int64Value) (string, error) {\n\tvar userstr, groupstr string\n\tif uid != nil {\n\t\tuserstr = strconv.FormatInt(uid.GetValue(), 10)\n\t}\n\tif username != \"\" {\n\t\tuserstr = username\n\t}\n\tif gid != nil {\n\t\tgroupstr = strconv.FormatInt(gid.GetValue(), 10)\n\t}\n\tif userstr == \"\" {\n\t\tif groupstr != \"\" {\n\t\t\treturn \"\", errors.Errorf(\"user group %q is specified without user\", groupstr)\n\t\t}\n\t\treturn \"\", nil\n\t}\n\tif groupstr != \"\" {\n\t\tuserstr = userstr + \":\" + groupstr\n\t}\n\treturn userstr, nil\n}\n"], "filenames": ["pkg/cri/opts/spec_linux.go", "pkg/cri/server/container_create_linux.go"], "buggy_code_start_loc": [244, 186], "buggy_code_end_loc": [244, 187], "fixing_code_start_loc": [245, 186], "fixing_code_end_loc": [269, 187], "type": "CWE-281", "message": "containerd is an open source container runtime. On installations using SELinux, such as EL8 (CentOS, RHEL), Fedora, or SUSE MicroOS, with containerd since v1.5.0-beta.0 as the backing container runtime interface (CRI), an unprivileged pod scheduled to the node may bind mount, via hostPath volume, any privileged, regular file on disk for complete read/write access (sans delete). Such is achieved by placing the in-container location of the hostPath volume mount at either `/etc/hosts`, `/etc/hostname`, or `/etc/resolv.conf`. These locations are being relabeled indiscriminately to match the container process-label which effectively elevates permissions for savvy containers that would not normally be able to access privileged host files. This issue has been resolved in version 1.5.9. Users are advised to upgrade as soon as possible.", "other": {"cve": {"id": "CVE-2021-43816", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-05T19:15:08.717", "lastModified": "2022-04-01T14:50:57.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "containerd is an open source container runtime. On installations using SELinux, such as EL8 (CentOS, RHEL), Fedora, or SUSE MicroOS, with containerd since v1.5.0-beta.0 as the backing container runtime interface (CRI), an unprivileged pod scheduled to the node may bind mount, via hostPath volume, any privileged, regular file on disk for complete read/write access (sans delete). Such is achieved by placing the in-container location of the hostPath volume mount at either `/etc/hosts`, `/etc/hostname`, or `/etc/resolv.conf`. These locations are being relabeled indiscriminately to match the container process-label which effectively elevates permissions for savvy containers that would not normally be able to access privileged host files. This issue has been resolved in version 1.5.9. Users are advised to upgrade as soon as possible."}, {"lang": "es", "value": "containerd es un tiempo de ejecuci\u00f3n de contenedores de c\u00f3digo abierto. En las instalaciones que usan SELinux, como EL8 (CentOS, RHEL), Fedora o SUSE MicroOS, con containerd desde la versi\u00f3n v1.5.0-beta.0 como interfaz de ejecuci\u00f3n de contenedores de respaldo (CRI), un pod sin privilegios programado en el nodo puede enlazar el montaje, por medio del volumen hostPath, de cualquier archivo privilegiado y regular en el disco para un acceso completo de lectura/escritura (sans delete). Esto es conseguido al colocar la ubicaci\u00f3n dentro del contenedor del montaje del volumen hostPath en \"/etc/hosts\", \"/etc/hostname\", o \"/etc/resolv.conf\". Estas ubicaciones est\u00e1n siendo reetiquetadas indiscriminadamente para que coincidan con la etiqueta del proceso del contenedor, lo que efectivamente eleva los permisos para los contenedores inteligentes que normalmente no podr\u00edan acceder a los archivos privilegiados del host. Este problema ha sido resuelto en versi\u00f3n 1.5.9. Se recomienda a usuarios que actualicen lo antes posible."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-281"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-281"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.5.1", "versionEndExcluding": "1.5.9", "matchCriteriaId": "43387595-2EE9-4BCB-BA40-899372BAFD60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:-:*:*:*:*:*:*", "matchCriteriaId": "51312F5E-E77D-4714-A47A-EB2900F91852"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:beta0:*:*:*:*:*:*", "matchCriteriaId": "2C477ED1-29F2-47CC-B523-331FE4052336"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "2DD59A2E-2AF5-4D24-A0BD-F9A7C2064A91"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "6D819271-9946-4A69-8EF7-AFF8AAA226CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F87C27FC-1AE4-45BA-BCF5-D5C2AEC3F3E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "3F6FA16C-59DA-42A7-A75C-5E8FB0E83453"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "2829C988-52D0-42A6-B063-B789046DBC58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "459C3B7F-4875-42A1-B242-A342218CEFD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "6C93E100-A2D4-4781-8C36-4DBCFD704CB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:1.5.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "F43624CC-D1D3-4FF0-8D97-20E190A9A56E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/containerd/containerd/commit/a731039238c62be081eb8c31525b988415745eea", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/containerd/containerd/issues/6194", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/containerd/containerd/security/advisories/GHSA-mvff-h3cj-wj9c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/dweomer/containerd/commit/f7f08f0e34fb97392b0d382e58916d6865100299", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GD5GH7NMK5VJMA2Y5CYB5O5GTPYMWMLX/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MPDIZMI7ZPERSZE2XO265UCK5IWM7CID/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containerd/containerd/commit/a731039238c62be081eb8c31525b988415745eea"}}