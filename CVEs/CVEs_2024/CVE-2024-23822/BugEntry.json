{"buggy_code": ["package Thruk::Controller::panorama;\n\nuse warnings;\nuse strict;\nuse Carp qw/confess/;\nuse Cpanel::JSON::XS qw/decode_json/;\nuse Data::Dumper qw/Dumper/;\nuse Encode qw(encode_utf8);\nuse File::Copy qw/move copy/;\nuse IO::Socket::INET ();\nuse Module::Load qw/load/;\n\nuse Thruk::Action::AddDefaults ();\nuse Thruk::Backend::Manager ();\nuse Thruk::Timer qw/timing_breakpoint/;\nuse Thruk::Utils::Auth ();\nuse Thruk::Utils::Broadcast ();\nuse Thruk::Utils::Cache ();\nuse Thruk::Utils::External ();\nuse Thruk::Utils::Log qw/:all/;\nuse Thruk::Utils::Panorama qw/:all/;\nuse Thruk::Utils::Status ();\n\n=head1 NAME\n\nThruk::Controller::panorama - Thruk Controller\n\n=head1 DESCRIPTION\n\nThruk Controller.\n\n=head1 METHODS\n\n=cut\n\n\n##########################################################\n\n=head2 index\n\n=cut\nsub index {\n    my ( $c ) = @_;\n\n    &timing_breakpoint('panorama::index');\n    return unless Thruk::Action::AddDefaults::add_defaults($c, Thruk::Constants::ADD_CACHED_DEFAULTS);\n\n    if(!$c->config->{'panorama_modules_loaded'}) {\n        load URI::Escape, qw/uri_unescape/;\n        load Scalar::Util, qw/looks_like_number/;\n        load Thruk::Utils::PanoramaCpuStats;\n        load Thruk::Utils::Avail;\n        $c->config->{'panorama_modules_loaded'} = 1;\n    }\n\n    # add current dashboard to error details, so if something goes wrong, we can log which dashboard is responsible\n    $c->stash->{errorDetails} = '' unless $c->stash->{errorDetails};\n    $c->stash->{errorDetails} .= sprintf(\"Dashboard: %s\\n\", $c->req->parameters->{'current_tab'}) if $c->req->parameters->{'current_tab'};\n\n    # add some functions\n    $c->stash->{'get_static_panorama_files'} = \\&Thruk::Utils::Panorama::get_static_panorama_files;\n\n    $c->stash->{title}             = 'Thruk Panorama';\n    $c->stash->{'skip_navigation'} = 1;\n    $c->stash->{'inject_stats'}    = 0;\n    $c->stash->{'no_totals'}       = 1;\n    $c->stash->{default_nagvis_base_url} = '';\n    $c->stash->{default_nagvis_base_url} = '/'.$ENV{'OMD_SITE'}.'/nagvis' if $ENV{'OMD_SITE'};\n    $c->stash->{'panorama_debug'} = $c->config->{'panorama_debug'} // 0;\n    $c->stash->{'panorama_debug'} = 1 if $c->req->parameters->{'debug'};\n    $c->stash->{'plugin_name'}    = Thruk::Utils::get_plugin_name(__FILE__, __PACKAGE__);\n\n    $c->stash->{'readonly'} = defined $c->config->{'Thruk::Plugin::Panorama'}->{'readonly'} ? $c->config->{'Thruk::Plugin::Panorama'}->{'readonly'} : 0;\n    $c->stash->{'readonly'} = 1 if defined $c->req->parameters->{'readonly'};\n\n    $c->stash->{'dashboard_ignore_changes'} = defined $c->config->{'Thruk::Plugin::Panorama'}->{'dashboard_ignore_changes'} ? $c->config->{'Thruk::Plugin::Panorama'}->{'dashboard_ignore_changes'} : 0;\n    $c->stash->{'dashboard_ignore_changes'} = 1 if defined $c->req->parameters->{'dashboard_ignore_changes'};\n\n    Thruk::Utils::Panorama::set_is_admin($c);\n\n    $c->stash->{one_tab_only}           = '';\n    $c->stash->{'full_reload_interval'} = defined $c->config->{'Thruk::Plugin::Panorama'}->{'full_reload_interval'} ? $c->config->{'Thruk::Plugin::Panorama'}->{'full_reload_interval'} : 10800;\n    $c->stash->{'extjs_version'}        = \"4.2.2\";\n\n    $c->{'panorama_var'} = $c->config->{'var_path'}.'/panorama';\n    Thruk::Utils::IO::mkdir_r($c->{'panorama_var'});\n    $c->{'panorama_etc'} = $c->config->{'etc_path'}.'/panorama';\n    Thruk::Utils::IO::mkdir_r($c->{'panorama_etc'});\n\n    if(defined $c->req->uri->query) {\n        if($c->req->uri->query eq 'state') {\n            return(_stateprovider($c));\n        }\n    }\n\n    if(defined $c->req->parameters->{'js'}) {\n        return(_js($c));\n    }\n\n    if(defined $c->req->parameters->{'task'}) {\n        my $task = $c->req->parameters->{'task'};\n        if($task eq 'status') {\n            return(_task_status($c));\n        }\n        if($task eq 'availability') {\n            return(_task_availability($c));\n        }\n        elsif($task eq 'dashboard_save_states') {\n            return(_task_dashboard_save_states($c));\n        }\n        elsif($task eq 'dashboard_data') {\n            return(_task_dashboard_data($c));\n        }\n        elsif($task eq 'dashboard_list') {\n            return(_task_dashboard_list($c));\n        }\n        elsif($task eq 'dashboard_update') {\n            return(_task_dashboard_update($c));\n        }\n        elsif($task eq 'dashboard_restore_list') {\n            return(_task_dashboard_restore_list($c));\n        }\n        elsif($task eq 'dashboard_restore_point') {\n            return(_task_dashboard_restore_point($c));\n        }\n        elsif($task eq 'dashboard_restore') {\n            return(_task_dashboard_restore($c));\n        }\n        elsif($task eq 'dashboards_clean') {\n            return(_task_dashboards_clean($c));\n        }\n        elsif($task eq 'stats_core_metrics') {\n            return(_task_stats_core_metrics($c));\n        }\n        elsif($task eq 'stats_check_metrics') {\n            return(_task_stats_check_metrics($c));\n        }\n        elsif($task eq 'server_stats') {\n            return(_task_server_stats($c));\n        }\n        elsif($task eq 'show_logs') {\n            return(_task_show_logs($c));\n        }\n        elsif($task eq 'show_comments') {\n            return(_task_show_comments($c));\n        }\n        elsif($task eq 'site_status') {\n            return(_task_site_status($c));\n        }\n        elsif($task eq 'hosts') {\n            return(_task_hosts($c));\n        }\n        elsif($task eq 'hosttotals') {\n            return(_task_hosttotals($c));\n        }\n        elsif($task eq 'services') {\n            return(_task_services($c));\n        }\n        elsif($task eq 'squares_data') {\n            return(_task_squares_data($c));\n        }\n        elsif($task eq 'servicesminemap') {\n            return(_task_servicesminemap($c));\n        }\n        elsif($task eq 'servicetotals') {\n            return(_task_servicetotals($c));\n        }\n        elsif($task eq 'hosts_pie') {\n            return(_task_hosts_pie($c));\n        }\n        elsif($task eq 'host_list') {\n            return(_task_host_list($c));\n        }\n        elsif($task eq 'host_detail') {\n            return(_task_host_detail($c));\n        }\n        elsif($task eq 'service_list') {\n            return(_task_service_list($c));\n        }\n        elsif($task eq 'service_detail') {\n            return(_task_service_detail($c));\n        }\n        elsif($task eq 'services_pie') {\n            return(_task_services_pie($c));\n        }\n        elsif($task eq 'stats_gearman') {\n            return(_task_stats_gearman($c));\n        }\n        elsif($task eq 'stats_gearman_grid') {\n            return(_task_stats_gearman_grid($c));\n        }\n        elsif($task eq 'pnp_graphs') {\n            return(_task_pnp_graphs($c));\n        }\n        elsif($task eq 'grafana_graphs') {\n            return(_task_grafana_graphs($c));\n        }\n        elsif($task eq 'userdata_backgroundimages') {\n            return(_task_userdata_backgroundimages($c));\n        }\n        elsif($task eq 'userdata_images') {\n            return(_task_userdata_images($c));\n        }\n        elsif($task eq 'userdata_iconsets') {\n            return(_task_userdata_iconsets($c));\n        }\n        elsif($task eq 'userdata_trendiconsets') {\n            return(_task_userdata_trendiconsets($c));\n        }\n        elsif($task eq 'userdata_sounds') {\n            return(_task_userdata_sounds($c));\n        }\n        elsif($task eq 'userdata_shapes') {\n            return(_task_userdata_shapes($c));\n        }\n        elsif($task eq 'redirect_status') {\n            return(_task_redirect_status($c));\n        }\n        elsif($task eq 'textsave') {\n            return(_task_textsave($c));\n        }\n        elsif($task eq 'serveraction') {\n            return(_task_serveraction($c));\n        }\n        elsif($task eq 'timezones') {\n            return(_task_timezones($c));\n        }\n        elsif($task eq 'wms_provider') {\n            return(_task_wms_provider($c));\n        }\n        elsif($task eq 'upload') {\n            return(_task_upload($c));\n        }\n        elsif($task eq 'uploadecho') {\n            return(_task_uploadecho($c));\n        }\n        elsif($task eq 'save_dashboard') {\n            return(_task_save_dashboard($c));\n        }\n        elsif($task eq 'load_dashboard') {\n            return(_task_load_dashboard($c));\n        }\n        elsif($task eq 'search') {\n            return(_task_search($c));\n        }\n    }\n\n    # find images for preloader\n    _set_preload_images($c);\n\n    # clean up?\n    if($c->req->parameters->{'clean'}) {\n        my $data = Thruk::Utils::get_user_data($c);\n        delete $data->{'panorama'};\n        Thruk::Utils::store_user_data($c, $data);\n        return $c->redirect_to(\"panorama.cgi\");\n    }\n\n    &timing_breakpoint('loading _js');\n    _js($c, 1);\n    &timing_breakpoint('loading _js done');\n\n    $c->stash->{template} = 'panorama.tt';\n    return 1;\n}\n\n##########################################################\nsub _js {\n    my($c, $only_data) = @_;\n\n    # merge open dashboards into state\n    my $data = Thruk::Utils::get_user_data($c);\n    if($data->{'panorama'} && $data->{'panorama'}->{'tabpan'} && $data->{'panorama'}->{'tabpan'}->{'xdata'}) {\n        $data->{'panorama'} = delete $data->{'panorama'}->{'tabpan'}->{'xdata'};\n    }\n    my $user_data = $data->{'panorama'} || {};\n    my $open_tabs = $user_data->{'open_tabs'} || [];\n    if(defined $c->req->parameters->{'map'}) {\n        my $dashboard = _get_dashboard_by_name($c, $c->req->parameters->{'map'});\n        if(!$dashboard) {\n            Thruk::Utils::set_message( $c, { style => 'fail_message', msg => 'no such dashboard', code => 404 });\n            return $c->redirect_to($c->stash->{'url_prefix'});\n        }\n        $open_tabs = [$dashboard->{'nr'}];\n        $c->stash->{one_tab_only} = $dashboard->{'nr'};\n        $c->stash->{title}        = $dashboard->{'tab'}->{'xdata'}->{'title'};\n    } elsif(defined $c->req->parameters->{'maps'}) {\n        $open_tabs = [];\n        for my $name (@{Thruk::Base::list($c->req->parameters->{'maps'})}) {\n            my $dashboard = _get_dashboard_by_name($c, $name);\n            if($dashboard) {\n                push @{$open_tabs}, $dashboard->{'nr'};\n            }\n        }\n        $user_data->{'activeTab'} = scalar @{$open_tabs} > 0 ? $open_tabs->[0] : \"\";\n    } elsif($c->cookies('thruk_panorama_tabs')) {\n        $open_tabs = [split(/\\s*:\\s*/mx, $c->cookies('thruk_panorama_tabs'))];\n        if($c->cookies('thruk_panorama_active')) {\n            $user_data->{'activeTab'} = $c->cookies('thruk_panorama_active');\n        }\n    }\n\n    if(scalar @{$open_tabs} == 0) {\n        $open_tabs = [\"0\"];\n        $user_data->{'activeTab'} = \"0\";\n    }\n\n    # restore last open tabs\n    $user_data->{'open_tabs'} = $open_tabs;\n    my $extstate = {\n        tabbar => $user_data,\n    };\n    my $shapes = {};\n    my $open_tabs_hash = Thruk::Base::array2hash($open_tabs);\n    for my $nr (@{$open_tabs}) {\n        _add_initial_dashboard($c, $nr, $extstate, $shapes, $open_tabs_hash);\n    }\n    $c->stash->{shapes} = $shapes;\n\n    $c->stash->{extstate}          = $extstate;\n    $c->stash->{default_dashboard} = [];\n    $c->stash->{shapes}            = $shapes;\n    if($c->config->{'Thruk::Plugin::Panorama'}->{'default_dashboard'}) {\n        my $default_dashboard = $c->config->{'Thruk::Plugin::Panorama'}->{'default_dashboard'};\n        if(ref $c->config->{'Thruk::Plugin::Panorama'}->{'default_dashboard'} eq 'ARRAY') {\n            $default_dashboard = join(',', @{$default_dashboard});\n        }\n        my @defaults = split(/\\s*,+\\s*/mx, $default_dashboard);\n        $c->stash->{default_dashboard} = \\@defaults;\n    }\n\n    my $action_menu_actions = [];\n    if($c->config->{'action_menu_actions'}) {\n        for my $name (keys %{$c->config->{'action_menu_actions'}}) {\n            push @{$action_menu_actions}, $name;\n        }\n    }\n    $c->stash->{action_menu_actions}   = $action_menu_actions;\n\n    my $action_menu_items    = [];\n    my $action_menu_items_js = '';\n    if($c->config->{'action_menu_items'}) {\n        for my $name (sort keys %{$c->config->{'action_menu_items'}}) {\n            my $menu = Thruk::Utils::Filter::get_action_menu($c, $name);\n            $action_menu_items_js .= delete $menu->{'data'} if $menu->{'type'} eq 'js';\n            push @{$action_menu_items}, $menu;\n        }\n    }\n    $c->stash->{action_menu_items}    = $action_menu_items;\n    $c->stash->{action_menu_items_js} = $action_menu_items_js;\n\n    $c->stash->{shape_data}         = _task_userdata_shapes($c, 1);\n    $c->stash->{iconset_data}       = _task_userdata_iconsets($c, 1);\n    $c->stash->{trendiconset_data}  = _task_userdata_trendiconsets($c, 1);\n    $c->stash->{wms_provider}       = _get_wms_provider($c);\n    $c->stash->{fonts}              = _get_available_fonts($c);\n\n    # default geo map center\n    $c->stash->{default_map_zoom} = $c->config->{'Thruk::Plugin::Panorama'}->{'geo_map_default_zoom'} || 5;\n    my($lon,$lat) = split(/\\s*,\\s*/mx, ($c->config->{'Thruk::Plugin::Panorama'}->{'geo_map_default_center'} || '13.74,47.77'));\n    $c->stash->{default_map_lon} = $lon;\n    $c->stash->{default_map_lat} = $lat;\n\n    $c->stash->{default_maintenance_text} = $c->config->{'Thruk::Plugin::Panorama'}->{'default_maintenance_text'} || '';\n\n    my $default_state_order = $c->config->{'Thruk::Plugin::Panorama'}->{'default_state_order'} // $c->config->{'default_state_order'};\n    $c->stash->{default_state_order} = [split(/\\s*,\\s*/mx, $default_state_order)];\n\n    unless($only_data) {\n        $c->res->content_type('text/javascript; charset=utf-8');\n        $c->stash->{template} = 'panorama_js.tt';\n    }\n    return 1;\n}\n\n##########################################################\nsub _stateprovider {\n    my ( $c ) = @_;\n\n    my $json;\n    my $param = $c->req->parameters;\n    my $task  = delete $param->{'task'};\n    my $value = $param->{'value'};\n    my $name  = $param->{'name'};\n    if($c->stash->{'readonly'} || $c->stash->{'dashboard_ignore_changes'}) {\n        $json = { 'status' => 'failed' };\n    }\n    elsif(defined $task and $task eq 'update2') {\n        $json = { 'status' => 'ok' };\n        my $replace = delete $param->{'replace'} || 0;\n        my $newids  = [];\n        my $newid   = delete $param->{'nr'} || '';\n        for my $key (keys %{$param}) {\n            next if !$param->{$key};\n            next if $key eq 'current_tab';\n            my $param_data = $param->{$key};\n            if(ref $param_data eq '') {\n                $param_data = decode_json($param->{$key});\n            }\n            if($key eq 'tabbar') {\n                my $data = Thruk::Utils::get_user_data($c);\n                $data->{'panorama'} = $param_data->{'xdata'};\n                Thruk::Utils::store_user_data($c, $data);\n            } else {\n                # update dashboards\n                for my $k2 (keys %{$param_data}) {\n                    if($k2 eq 'id') {\n                        $newid = $param_data->{$k2};\n                    } else {\n                        $param_data->{$k2} = $param_data->{$k2};\n                        if(ref $param_data->{$k2} eq '') {\n                            eval {\n                                if($k2 eq 'tab') {\n                                    # throws encoding error when having a dashboad with umlaut in title\n                                    $param_data->{$k2} = encode_utf8($param_data->{$k2});\n                                }\n                                $param_data->{$k2} = decode_json($param_data->{$k2});\n                            };\n                            confess(Dumper(\"Error in parsing json:\", $@, $k2, $param_data)) if $@;\n                        }\n\n                    }\n                }\n                $param_data->{'id'}   = $newid || $key;\n                $param_data->{'user'} = $c->stash->{'remote_user'};\n                my $extra = {};\n                if($c->stash->{'is_admin'} && $param_data->{'tab'}->{'xdata'}->{'owner'}) {\n                    $extra->{'user'} = $param_data->{'tab'}->{'xdata'}->{'owner'};\n                }\n                delete $param_data->{'tab'}->{'xdata'}->{'owner'};\n                if(!Thruk::Utils::Panorama::save_dashboard($c, $param_data, $extra)) {\n                    $json = { 'status' => 'failed' };\n                } else {\n                    if($newid) {\n                        $json->{'newid'} = $param_data->{'id'};\n                        push @{$newids}, $param_data->{'id'};\n                    }\n                }\n            }\n        }\n        if($replace) {\n            my $data = Thruk::Utils::get_user_data($c);\n            $data->{'panorama'}->{dashboards}->{'tabbar'}->{'open_tabs'} = $newids;\n            Thruk::Utils::store_user_data($c, $data);\n        }\n    } else {\n        $json = { 'status' => 'failed' };\n    }\n\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _nice_ext_value {\n    my($orig) = @_;\n    my $value = uri_unescape($orig);\n    $value =~ s/^o://gmx;\n    my @val   = split/\\^/mx, $value;\n    my $o = {};\n    for my $v (@val) {\n        my($key, $val) = split(/=/mx, $v, 2);\n        $val =~ s/^n%3A//gmx;\n        $val =~ s/^b%3A0/false/gmx;\n        $val =~ s/^b%3A1/true/gmx;\n        if($val =~ m/^a%3A/mx) {\n            $val =~ s/^a%3A//mx;\n            $val =~ s/s%253A//gmx;\n            $val = [ split(m/n%253A|%5E/mx, $val) ];\n            @{$val} = grep {!/^$/mx} @{$val};\n        }\n        elsif($val =~ m/^o%3A/mx) {\n            $val =~ s/^o%3A//mx;\n            $val = [ split(m/n%253A|%3D|%5E/mx, $val) ];\n            @{$val} = grep {!/^$/mx} @{$val};\n            $val = {@{$val}};\n        } else {\n            $val =~ s/^s%3A//mx;\n        }\n        $o->{$key} = $val;\n    }\n    $Data::Dumper::Sortkeys = 1;\n    $value = Dumper($o);\n    $value =~ s/^\\$VAR1\\ =//gmx;\n    $value =~ s/\\n/ /gmx;\n    $value =~ s/\\s+/ /gmx;\n    return $value;\n}\n\n##########################################################\nsub _task_status {\n    my($c, $data_only, $params) = @_;\n\n    $params = $c->req->parameters unless defined $params;\n\n    # make status group filter faster\n    $c->stash->{'cache_groups_filter'} = {} unless defined $c->stash->{'cache_groups_filter'};\n\n    my $types        = {};\n    my $tab_backends = $params->{'backends'};\n    if($params->{'types'}) {\n        if(ref $params->{'types'}) {\n            $types = $params->{'types'};\n        } else {\n            $types = decode_json($params->{'types'});\n        }\n    }\n\n    my $hostfilter    = Thruk::Utils::combine_filter('-or', [map {{name => $_}} keys %{$types->{'hosts'}}]);\n    my $servicefilter = [];\n    for my $host (keys %{$types->{'services'}}) {\n        for my $svc (keys %{$types->{'services'}->{$host}}) {\n            push @{$servicefilter}, { '-and' => { host_name => $host, description => $svc}};\n        }\n    }\n    $servicefilter = Thruk::Utils::combine_filter('-or', $servicefilter);\n\n    my $state_type = SOFT_STATE;\n    if(defined $params->{'state_type'} && $params->{'state_type'} eq 'hard') {\n        $state_type = HARD_STATE;\n    }\n\n    if($params->{'reschedule'}) {\n        Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n        # works only for a single host or service\n        $c->stash->{'now'}                   = time();\n        $c->req->parameters->{'cmd_mod'}     = 2;\n        $c->req->parameters->{'force_check'} = 0;\n        $c->req->parameters->{'start_time'}  = time();\n        $c->req->parameters->{'json'}        = 1;\n        $c->req->parameters->{'service'}     = '';\n        if(scalar keys %{$types->{'hosts'}} == 1) {\n            my $hosts  = $c->db->get_hosts(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ],\n                                               columns => [qw/name/]);\n            if(scalar @{$hosts} == 1) {\n                $c->req->parameters->{'cmd_typ'} = 96;\n                $c->req->parameters->{'host'}    = $hosts->[0]->{'name'};\n                $c->req->parameters->{'backend'} = [$hosts->[0]->{'peer_key'}];\n            } else {\n                Thruk::Utils::set_message($c, 'fail_message', 'Found '.(scalar @{$hosts}).' hosts. Cannot send reschedule command.');\n            }\n        }\n        elsif(scalar keys %{$types->{'services'}} == 1) {\n            my $services = $c->db->get_services(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ],\n                                                    columns => [qw/host_name description/]);\n            if(scalar @{$services} == 1) {\n                $c->req->parameters->{'cmd_typ'} = 7;\n                $c->req->parameters->{'host'}    = $services->[0]->{'host_name'};\n                $c->req->parameters->{'service'} = $services->[0]->{'description'};\n                $c->req->parameters->{'backend'} = [$services->[0]->{'peer_key'}];\n            } else {\n                Thruk::Utils::set_message($c, 'fail_message', 'Found '.(scalar @{$services}).' services. Cannot send reschedule command.');\n            }\n        }\n        if($params->{'cmd_typ'}) {\n            require Thruk::Controller::cmd;\n            if(Thruk::Controller::cmd::do_send_command($c)) {\n                Thruk::Utils::set_message( $c, 'success_message', 'Commands successfully submitted' );\n                Thruk::Controller::cmd::redirect_or_success($c, -2, 1);\n            }\n        }\n    }\n\n    my $data = {};\n    if(scalar keys %{$types->{'filter'}} > 0) {\n        for my $f (keys %{$types->{'filter'}}) {\n            my($incl_hst, $incl_svc, $filter, $backends) = @{decode_json($f)};\n            next if $c->stash->{'has_error'};\n            delete $c->req->parameters->{'backend'};\n            delete $c->req->parameters->{'backends'};\n            if($backends && scalar @{$backends} > 0 && (scalar @{$backends} != 1 || $backends->[0] ne '')) {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $backends);\n            } else {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n            }\n            $c->req->parameters->{'filter'} = $filter;\n            my( $hfilter, $sfilter, $hostgroupfilter, $servicegroupfilter, $has_service_filter ) = _do_filter($c);\n            $data->{'filter'}->{$f} = _summarize_query($c, $incl_hst, $incl_svc, $hfilter, $sfilter, $state_type, $has_service_filter);\n        }\n        Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n    }\n    if(scalar keys %{$types->{'hostgroups'}} > 0) {\n        $data->{'hostgroups'} = [values %{_summarize_hostgroup_query($c, $types->{'hostgroups'}, $state_type)}];\n    }\n    if(scalar keys %{$types->{'servicegroups'}} > 0) {\n        $data->{'servicegroups'} = [values %{_summarize_servicegroup_query($c, $types->{'servicegroups'}, $state_type)}];\n    }\n    if(scalar keys %{$types->{'hosts'}} > 0) {\n        my $columns = [qw/name alias state state_type has_been_checked scheduled_downtime_depth acknowledged last_state_change last_check plugin_output\n                          last_notification current_notification_number perf_data next_check action_url_expanded notes_url_expanded\n                         /];\n        push @{$columns}, \"long_plugin_output\" if $types->{'has_long_plugin_output'};\n        $data->{'hosts'} = $c->db->get_hosts(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ],\n                                                 columns => $columns,\n                                                );\n        if($c->config->{'shown_inline_pnp'}) {\n            for my $hst (@{$data->{'hosts'}}) {\n                $hst->{'pnp_url'} = Thruk::Utils::get_pnp_url($c, $hst);\n            }\n        }\n    }\n    if(scalar keys %{$types->{'services'}} > 0) {\n        my $columns = [qw/host_name host_alias description state state_type has_been_checked scheduled_downtime_depth acknowledged last_state_change last_check\n                          plugin_output last_notification current_notification_number perf_data next_check action_url_expanded notes_url_expanded\n                         /];\n        push @{$columns}, \"long_plugin_output\" if $types->{'has_long_plugin_output'};\n        $data->{'services'} = $c->db->get_services(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ],\n                                                       columns => $columns,\n                                                      );\n        if($c->config->{'shown_inline_pnp'}) {\n            for my $svc (@{$data->{'services'}}) {\n                $svc->{'pnp_url'} = Thruk::Utils::get_pnp_url($c, $svc);\n            }\n        }\n    }\n\n    return $data if $data_only;\n\n    # add status data for sub dashboards\n    if($params->{'sub'}) {\n        my $sub = decode_json($params->{'sub'});\n        $data->{'sub'} = {};\n        for my $key (keys %{$sub}) {\n            $data->{'sub'}->{$key} = _task_status($c, 1, $sub->{$key});\n        }\n    }\n\n    $data->{backends} = $c->stash->{'backend_detail'};\n\n    my $json = { data => $data };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_redirect_status {\n    my($c) = @_;\n    my $types = {};\n    return $c->redirect_to(\"status.cgi\") unless $c->req->parameters->{'filter'};\n\n    my($hfilter, $sfilter, $hostgroupfilter, $servicegroupfilter, $has_service_filter) = _do_filter($c);\n    $c->req->parameters->{'filter'} = '';\n    $c->req->parameters->{'task'}   = '';\n    my $url = Thruk::Utils::Filter::uri_with($c, $c->req->parameters);\n    $url    =~ s/^panorama.cgi/status.cgi/gmx;\n    $url    =~ s/\\&amp;filter=.*?\\&amp;/&amp;/gmx;\n    $url    =~ s/\\&amp;task=.*?\\&amp;/&amp;/gmx;\n    $url    =~ s/\\&amp;/&/gmx;\n    if($has_service_filter) {\n        $url =~ s/style=hostdetail/style=detail/gmx;\n    }\n    if($c->req->method() eq 'POST') {\n        # directly answer query, POST does not redirect\n        if($url =~ m/^\\w+\\.cgi/mx) {\n            $url = '/cgi-bin/'.$url;\n        }\n        my($sub_c);\n        eval {\n            ($sub_c) = $c->sub_request($url, \"POST\", {}, 1, undef, 1);\n        };\n        my $err = $@;\n        if($err) {\n            confess(\"internal sub request to \".$url.\" failed: \".$err);\n        }\n        $c->res->status($sub_c->res->code);\n        $c->res->headers($sub_c->res->headers);\n        $c->res->body($sub_c->res->content);\n        $c->{'rendered'} = 1;\n        $c->stash->{'inject_stats'} = 0;\n        return;\n    }\n\n    # shorten url to avoid hitting max request uri limits in webservers\n    $url =~ s/(\\?|&)backends=/$1be=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_type=/$1_t=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_val_pre=/$1_vp=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_value=/$1_v=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_hoststatustypes=/$1_hst=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_hostprops=/$1_hp=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_servicestatustypes=/$1_sst=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_serviceprops=/$1_sp=/gmx;\n\n    return $c->redirect_to($url);\n}\n\n##########################################################\nsub _task_textsave {\n    my($c) = @_;\n    my $file = $c->req->parameters->{'file'} || \"log.txt\";\n    $c->res->headers->header('Content-Disposition', 'attachment; filename=\"'.$file.'\"');\n    $c->res->headers->content_type('application/octet-stream');\n    $c->stash->{text}     = $c->req->parameters->{'text'};\n    $c->stash->{template} = 'passthrough.tt';\n    return;\n}\n\n##########################################################\nsub _task_serveraction {\n    my($c) = @_;\n    my($rc, $msg);\n    # if there is a dashboard in our parameters, make sure we have proper permissions\n    if($c->req->parameters->{'dashboard'} && Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $c->req->parameters->{'dashboard'}) == ACCESS_NONE) {\n        ($rc, $msg) = (1, 'no permission for this dashboard');\n    } else {\n        ($rc, $msg) = Thruk::Utils::Status::serveraction($c);\n    }\n    my $json = { 'rc' => $rc, 'msg' => $msg };\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_upload {\n    my($c) = @_;\n\n    $c->stash->{'template'} = 'passthrough.tt';\n\n    my $type     = $c->req->parameters->{'type'};\n    my $location = $c->req->parameters->{'location'};\n    if(!$type || !$location || !$c->req->uploads->{$type}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'missing properties in fileupload.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n    $location =~ s|/$||gmx;\n\n    if($c->config->{'demo_mode'}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'fileupload is disabled in demo mode.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $upload = $c->req->uploads->{$type};\n    my $folder = $c->stash->{'usercontent_folder'}.'/'.$location;\n\n    if(!-w $folder.'/.') {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload must use existing and writable folder.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    if($upload->{'size'} > (50*1024*1024)) { # not more than 50MB\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload exceeds the allowed filesize of 50MB.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $filename = $upload->{'filename'};\n    $filename =~ s|^/||gmx;\n    if($filename !~ m/^[a-z0-9_\\- ]+\\.(jpeg|jpg|gif|png|svg)$/mxi) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload contains invalid characters (a-z0-9_- ) in filename.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $newlocation = $folder.'/'.$filename;\n    if(-s $newlocation && !_check_media_permissions($c, $newlocation)) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Only administrator/panorama_view_media_manager roles may overwrite existing files.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    eval {\n        move($upload->{'tempname'}, $newlocation);\n    };\n    if($@) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => $@, success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    # must be text/html result, otherwise extjs form result handler dies\n    $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Upload successfull', success => Cpanel::JSON::XS::true, filename => $filename });\n    return;\n}\n\n##########################################################\nsub _task_uploadecho {\n    my($c) = @_;\n\n    $c->stash->{'template'} = 'passthrough.tt';\n\n    if(!$c->req->uploads->{'file'}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'missing file in fileupload.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $upload = $c->req->uploads->{'file'};\n    if($upload->{'size'} > (50*1024*1024)) { # not more than 50MB\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload exceeds the allowed filesize of 50MB.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $content = Thruk::Utils::IO::read($upload->{'tempname'});\n    unlink($upload->{'tempname'});\n\n    # must be text/html result, otherwise extjs form result handler dies\n    $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Upload successfull', success => Cpanel::JSON::XS::true, content => $content });\n    return;\n}\n\n##########################################################\nsub _task_save_dashboard {\n    my($c) = @_;\n\n    my $nr = $c->req->parameters->{'nr'} || die('no number supplied');\n       $nr =~ s/^pantab_//gmx;\n    my $d  = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n    return unless Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $d) >= ACCESS_READONLY;\n\n    my $data = {\n        usercontent => {},\n        version     => Thruk::Utils::Filter::fullversion($c),\n    };\n    for my $key (keys %{$d}) {\n        if($key =~ m/^(tab|panlet)/mx) {\n            $data->{$key} = $d->{$key};\n        }\n    }\n    # add image data\n    require MIME::Base64;\n    my $images = {};\n    for my $id (sort keys %{$d}) {\n        my $p = $d->{$id};\n        next unless ref $p eq 'HASH';\n        # dashboard background\n        if($p->{'xdata'}->{'background'}) {\n            my $file = $p->{'xdata'}->{'background'};\n            if($file =~ s|^../usercontent/||mx && $file !~ m|\\.\\.|mx) {\n                next if $file eq 'backgrounds/europa.png';\n                next if $file eq 'backgrounds/world.png';\n                next if $file eq 'backgrounds/world.svg';\n                next if $file eq 'backgrounds/europa.svg';\n                next if $file eq 'backgrounds/germany.svg';\n                $images->{$file} = $c->stash->{'usercontent_folder'}.'/'.$file;\n            }\n        }\n        # type image\n        if($p->{'xdata'}->{'appearance'} && $p->{'xdata'}->{'appearance'}->{'type'} && $p->{'xdata'}->{'appearance'}->{'type'} eq 'icon') {\n            my $file = $p->{'xdata'}->{'general'}->{'src'};\n            if($file && $file =~ s|^../usercontent/||mx && $file !~ m|\\.\\.|mx) {\n                $images->{$file} = $c->stash->{'usercontent_folder'}.'/'.$file;\n            }\n        }\n        # type icon - iconset\n        if($p->{'xdata'}->{'appearance'} && $p->{'xdata'}->{'appearance'}->{'iconset'}) {\n            my $file = $p->{'xdata'}->{'appearance'}->{'iconset'};\n            if($file && $file !~ m|/|mx && $file !~ m|\\.\\.|mx) {\n                next if $file eq 'default'; # skip our default sets\n                next if $file eq 'default_64';\n                next if $file eq 'tfl';\n                next if $file eq 'emoji';\n                next if $file eq 'emoji_64';\n                my @files = glob($c->stash->{'usercontent_folder'}.'/images/status/'.$file.'/*');\n                my $usercontent_folder = $c->stash->{'usercontent_folder'}.'/';\n                for my $f (@files) {\n                    my $short = $f;\n                    $short =~ s|^$usercontent_folder||mx;\n                    $images->{$short} = $f;\n                }\n            }\n        }\n    }\n    for my $image (sort keys %{$images}) {\n        my $file = $images->{$image};\n        next unless -r $file;\n        $data->{'usercontent'}->{$image} = MIME::Base64::encode_base64(\"\".Thruk::Utils::IO::read($file));\n    }\n    $c->stash->{'template'} = 'passthrough.tt';\n    my $text = \"\";\n    $text   .= \"# Thruk Panorama Dashboard Export: \".$d->{'tab'}->{'xdata'}->{'title'}.\"\\n\";\n    $text   .= Thruk::Utils::Filter::json_encode($data);\n    $text   .= \"\\n# End Export\\n\";\n    $c->stash->{text} = $text;\n    $c->res->headers->header( 'Content-Disposition', 'attachment; filename=\"'.$d->{'tab'}->{'xdata'}->{'title'}.'.dashboard\"' );\n    return;\n}\n\n##########################################################\nsub _task_load_dashboard {\n    my($c) = @_;\n\n    $c->stash->{'template'} = 'passthrough.tt';\n\n    if(!$c->req->uploads->{'file'}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'missing file in fileupload.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $upload = $c->req->uploads->{'file'};\n    if($upload->{'size'} > (50*1024*1024)) { # not more than 50MB\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'File exceeds the allowed filesize of 50MB.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $content = Thruk::Utils::IO::read($upload->{'tempname'});\n    unlink($upload->{'tempname'});\n\n    $content =~ s/^\\#.*$//gmx;\n    my $data;\n    eval {\n        $data = decode_json($content);\n    };\n    if($@) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'This is not a valid dashboard', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    delete $data->{'version'};\n\n    if($data->{'usercontent'}) {\n        require MIME::Base64;\n        my $usercontent_folder = $c->stash->{'usercontent_folder'}.'/';\n        for my $file (sort keys %{$data->{'usercontent'}}) {\n            my $size = -s $usercontent_folder.$file;\n            next if $c->config->{'demo_mode'};\n            next if $size && !_check_media_permissions($c, $usercontent_folder.$file); # overwrite only if user is allowed to\n            my $content = MIME::Base64::decode_base64($data->{'usercontent'}->{$file});\n            next if($size && length($content) == $size);\n            my $dir     = $file;\n            $dir        =~ s|/[^/]+$||mx;\n            eval {\n                Thruk::Utils::IO::mkdir_r($usercontent_folder.$dir);\n                Thruk::Utils::IO::write($usercontent_folder.$file,$content);\n            };\n            if($@) {\n                _error('Usercontent upload for '.$file.' failed: '.$@);\n                $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Usercontent upload for '.$file.' failed.', success => Cpanel::JSON::XS::false });\n                return;\n            }\n        }\n        delete $data->{'usercontent'};\n    }\n    $data->{'id'}   = 'new';\n    $data->{'user'} = $c->stash->{'remote_user'};\n    $data = Thruk::Utils::Panorama::save_dashboard($c, $data);\n    my $newid = $data->{'id'};\n\n    # must be text/html result, otherwise extjs form result handler dies\n    $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Import successfull', success => Cpanel::JSON::XS::true, newid => $newid });\n    return;\n}\n\n##########################################################\nsub _task_search {\n    my($c) = @_;\n\n    my $query = $c->req->parameters->{'value'} || '';\n    $query = Thruk::Base::trim_whitespace($query);\n    $query =~ s/\\s+/.*/gmx;\n    my $json = { 'rc' => 0, 'data' => [] };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json) unless $query;\n\n    my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, 'all', 1);\n\n    # search names and aliases\n    my $search = {\n        'host'         => $c->db->get_hosts( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'hosts' ), { '-or' => [ { name => { '~~' => $query } }, { alias => { '~~' => $query } } ] } ], columns => [qw/name alias/]),\n        'hostgroup'    => $c->db->get_hostgroups( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'hostgroups' ), { '-or' => [ { name => { '~~' => $query } }, { alias => { '~~' => $query } } ] } ], columns => [qw/name alias/]),\n        'service'      => $c->db->get_services( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'services' ), { '-or' => [ { description => { '~~' => $query } }, { display_name => { '~~' => $query } } ] } ], columns => [qw/description display_name/]),\n        'servicegroup' => $c->db->get_hostgroups( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'servicegroups' ), { '-or' => [ { name => { '~~' => $query } }, { alias => { '~~' => $query } } ] } ], columns => [qw/name alias/]),\n    };\n\n    # normalize services\n    for my $o (@{$search->{\"service\"}}) {\n        $o->{'name'}  = delete $o->{'description'};\n        $o->{'alias'} = delete $o->{'display_name'};\n    }\n\n    my $data  = {};\n    for my $d (@{$dashboards}) {\n        my $found = _search_match($data, $d, $d->{'tab'}->{'xdata'}->{'title'}, $query, \"title\")\n                 || _search_match($data, $d, $d->{'tab'}->{'xdata'}->{'description'}, $query, \"description\");\n\n        for my $icon_id (sort keys %{$d}) {\n            my $icon = $d->{$icon_id};\n            next unless ref $icon eq 'HASH';\n            next unless $icon->{'xdata'};\n\n            for my $type (sort keys %{$search}) {\n                if($icon->{'xdata'}->{'general'}->{$type}) {\n                    for my $o (@{$search->{$type}}) {\n                        my $found = _search_match($data, $d, $icon->{'xdata'}->{'general'}->{$type}, $query, $type, $o);\n                        if($found) {\n                            $found->{'highlight'} = $icon_id;\n                            $found->{'object'}    = $o;\n                        }\n                    }\n                }\n                if(!$found) {\n                    my $found = _search_match($data, $d, $icon->{'xdata'}->{'general'}->{$type}, $query, $type);\n                    if($found) {\n                        $found->{'highlight'} = $icon_id;\n                    }\n                }\n            }\n\n            my $found = _search_match($data, $d, $icon->{'xdata'}->{'label'}->{'labeltext'}, $query, \"iconlabel\")\n                     || _search_match($data, $d, $icon->{'xdata'}->{'general'}->{'text'}, $query, \"icontext\");\n            if($found) {\n                $found->{'highlight'} = $icon_id;\n            }\n        }\n    }\n\n    # sort by dashboard name\n    $json->{'data'} = [sort { $a->{'name'} cmp $b->{'name'} } values(%{$data})];\n\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _search_match {\n    my($result, $dashboard, $field, $query, $type, $names) = @_;\n    return unless defined $field;\n\n    # strip html and tags\n    $field =~ s/\\{\\{.*?\\}\\}//gmx;\n    $field =~ s/<.*?>//gmx;\n\n    my($matched, $pre,$match,$post) = (0, '', '', '');\n    if($names) {\n        return if $names->{'name'} ne $field;\n        $field   = $names->{'name'} eq $names->{'alias'} ? $names->{'name'} : $names->{'name'}.' - '.$names->{'alias'};\n        $match   = $query;\n        $matched = 1;\n    }\n    ## no critic\n    if($field =~ m#(.*)($query)(.*)#si) {\n        ($pre,$match,$post) = ($1,$2,$3);\n        $matched = 1;\n    }\n    ## use critic\n\n    return unless $matched;\n    my $found = {\n        type  => $type,\n        match => $match,\n        pre   => $pre,\n        post  => $post,\n        value => $field,\n    };\n    $result->{$dashboard->{id}} = {\n        id      => $dashboard->{id},\n        name    => $dashboard->{'tab'}->{'xdata'}->{'title'},\n        matches => [],\n    } unless $result->{$dashboard->{id}};\n    push @{$result->{$dashboard->{id}}->{'matches'}}, $found;\n    return($found);\n}\n\n##########################################################\nsub _task_wms_provider {\n    my($c) = @_;\n\n    my $provider = _get_wms_provider($c);\n    my $json = { 'rc' => 0, 'data' => $provider };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _get_wms_provider {\n    my($c) = @_;\n    my $provider = [];\n    my $list     = $c->config->{'Thruk::Plugin::Panorama'}->{'wms_provider'};\n    if(ref $list eq \"\") { $list = [$list] }\n    for my $entry (@{$list}) {\n        next unless $entry;\n        my($name, $data) = split(/\\s*=\\s*/mx, $entry, 2);\n        $name =~ s/^\\s*//gmx;\n        $name =~ s/\\s*$//gmx;\n        $data =~ s/^\\s*//gmx;\n        $data =~ s/\\s*$//gmx;\n        next unless $data;\n        eval {\n            my $test = Cpanel::JSON::XS::decode_json($data);\n        };\n        if($@) {\n            print STDERR \"error in wms provider: \".$@;\n            print STDERR $entry,\"\\n\";\n            die(\"error in wms provider: \".$@.\"\\nat entry: \".$entry.\"\\n\");\n        }\n        push @{$provider}, { name => $name, provider => $data };\n    }\n    return($provider);\n}\n\n\n##########################################################\nsub _task_timezones {\n    my($c) = @_;\n\n    my $query = $c->req->parameters->{'query'} || '';\n    my $data  = [];\n    for my $tz (@{Thruk::Utils::get_timezone_data($c)}) {\n        next if($query && $tz->{'text'} !~ m/$query/mxi);\n        push @{$data}, $tz;\n    }\n\n    my $json = { 'rc' => 0, 'data' => $data };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n\n##########################################################\nsub _task_availability {\n    my($c) = @_;\n\n    # make status group filter faster\n    $c->stash->{'cache_groups_filter'} = {};\n\n    if($c->req->parameters->{'force'}) {\n        return(avail_update($c));\n    }\n\n    $c->stats->profile(begin => \"_task_avail\");\n    if($c->req->parameters->{'force'}) {\n        avail_update($c);\n    } else {\n        Thruk::Utils::External::perl($c, { expr       => 'Thruk::Controller::panorama::avail_update($c)',\n                                           message    => 'availability is being calculated',\n                                           background => 1,\n                                        });\n    }\n    my $res = avail_update($c, 1);\n    $c->stats->profile(end => \"_task_avail\");\n    return($res);\n}\n\n##########################################################\n\n=head2 avail_update\n\n  avail_update($c, [$cached_only])\n\nreturns calculated availability data in json format\n\n=cut\nsub avail_update {\n    my($c, $cached_only) = @_;\n\n    $c->stats->profile(begin => \"avail_update\");\n    my $in    = {};\n    my $types = {};\n\n    my $tab_backends = $c->req->parameters->{'backends'};\n    return $c->render(json => {status => 'ok', msg => 'nothing to do'}) if(!defined $c->req->parameters->{'avail'} || $c->req->parameters->{'avail'} eq 'null');\n    if($c->req->parameters->{'avail'}) { $in    = decode_json($c->req->parameters->{'avail'}); }\n    if($c->req->parameters->{'types'}) { $types = decode_json($c->req->parameters->{'types'}); }\n    my $cache = Thruk::Utils::Cache->new($c->config->{'var_path'}.'/availability.cache');\n\n    # cache hit?\n    my @cache_prefix;\n    if($c->check_user_roles('authorized_for_all_hosts') && $c->check_user_roles('authorized_for_all_services')) {\n        my $tmp_cache = $cache->get('global');\n        if(!defined $tmp_cache) {\n            $cache->set('global', {});\n        }\n        @cache_prefix = ('global');\n    } else {\n        my $tmp_cache = $cache->get('users');\n        if(!defined $tmp_cache->{$c->stash->{'remote_user'}}) {\n            $tmp_cache->{$c->stash->{'remote_user'}} = {};\n            $cache->set('users', $c->stash->{'remote_user'}, {});\n        }\n        @cache_prefix = ('users', $c->stash->{'remote_user'});\n    }\n\n    my $data = {};\n    my $now  = time();\n    Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n    if(scalar keys %{$types->{'filter'}} > 0) {\n        for my $f (keys %{$types->{'filter'}}) {\n            # check if this filter is used in availabilities at all\n            my $found = 0;\n            for my $panel (@{$types->{'filter'}->{$f}}) {\n                if($in->{$panel}) { $found = 1; last; }\n            }\n            next unless $found;\n\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            my $filtername = \"$f\"; # results in *** glibc detected *** perl: double free or corruption (!prev): 0x0e482c38 *** otherwise\n            my($incl_hst, $incl_svc, $filter, $backends) = @{decode_json($f)};\n            delete $c->req->parameters->{'backend'};\n            delete $c->req->parameters->{'backends'};\n            if((ref $backends eq \"\" and $backends) || (ref $backends eq 'ARRAY' && scalar @{$backends} > 0)) {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $backends);\n            } else {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n            }\n            $c->req->parameters->{'filter'} = $filter;\n            my( $hfilter, $sfilter, $groupfilter ) = _do_filter($c);\n            next if $c->stash->{'has_error'};\n            for my $panel (@{$types->{'filter'}->{$f}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $opts   = $in->{$panel}->{$key}->{opts};\n                    Thruk::Utils::Avail::reset_req_parameters($c);\n                    if($opts->{'incl_hst'} || (!$opts->{'incl_hst'} && !$opts->{'incl_svc'})) {\n                        if($hfilter) {\n                            $c->req->parameters->{h_filter} = $hfilter;\n                        } else {\n                            $c->req->parameters->{host}     = 'all';\n                        }\n                    }\n                    if($opts->{'incl_svc'} || (!$opts->{'incl_hst'} && !$opts->{'incl_svc'})) {\n                        if($sfilter) {\n                            $c->req->parameters->{s_filter} = $sfilter;\n                        } else {\n                            $c->req->parameters->{service}  = 'all';\n                        }\n                    }\n                    my $cached = $cache->get(@cache_prefix, 'filter', $filtername, $key);\n                    $cache->set(@cache_prefix, 'filter', $filtername, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $opts, undef, undef, 1);\n                    $cache->set(@cache_prefix, 'filter', $filtername, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n        Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n    }\n    if(scalar keys %{$types->{'hostgroups'}} > 0) {\n        for my $group (keys %{$types->{'hostgroups'}}) {\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            $c->req->parameters->{hostgroup} = $group;\n            for my $panel (@{$types->{'hostgroups'}->{$group}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $opts   = $in->{$panel}->{$key}->{opts};\n                    my $cached = $cache->get(@cache_prefix, 'hostgroups', $group, $key);\n                    $cache->set(@cache_prefix, 'hostgroups', $group, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    if($opts->{'incl_svc'} || (!$opts->{'incl_hst'} && !$opts->{'incl_svc'})) {\n                        $c->req->parameters->{include_host_services} = 1;\n                    }\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $opts);\n                    $cache->set(@cache_prefix, 'hostgroups', $group, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n    }\n    if(scalar keys %{$types->{'servicegroups'}} > 0) {\n        for my $group (keys %{$types->{'servicegroups'}}) {\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            $c->req->parameters->{servicegroup} = $group;\n            for my $panel (@{$types->{'servicegroups'}->{$group}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $cached = $cache->get(@cache_prefix, 'servicegroups', $group, $key);\n                    $cache->set(@cache_prefix, 'servicegroups', $group, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $in->{$panel}->{$key}->{opts});\n                    $cache->set(@cache_prefix, 'servicegroups', $group, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n    }\n    if(scalar keys %{$types->{'hosts'}} > 0) {\n        for my $host (keys %{$types->{'hosts'}}) {\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            $c->req->parameters->{host} = $host;\n            $c->req->parameters->{include_host_services} = 0;\n            for my $panel (@{$types->{'hosts'}->{$host}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $cached = $cache->get(@cache_prefix, 'hosts', $host, $key);\n                    $cache->set(@cache_prefix, 'hosts', $host, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $in->{$panel}->{$key}->{opts}, $host);\n                    $cache->set(@cache_prefix, 'hosts', $host, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n    }\n    if(scalar keys %{$types->{'services'}} > 0) {\n        for my $host (keys %{$types->{'services'}}) {\n            for my $service (keys %{$types->{'services'}->{$host}}) {\n                Thruk::Utils::Avail::reset_req_parameters($c);\n                $c->req->parameters->{host}    = $host;\n                $c->req->parameters->{service} = $service;\n                for my $panel (@{$types->{'services'}->{$host}->{$service}}) {\n                    for my $key (keys %{$in->{$panel}}) {\n                        my $cached = $cache->get(@cache_prefix, 'services', $host, $service, $key);\n                        $cache->set(@cache_prefix, 'services', $host, $service, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                        $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $in->{$panel}->{$key}->{opts}, $host, $service);\n                        $cache->set(@cache_prefix, 'services', $host, $service, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                    }\n                }\n            }\n        }\n    }\n\n    # clean up cache\n    $c->stats->profile(begin => \"_avail_clean_cache\");\n    my $cached = $cache->get();\n    _avail_clean_cache($cached, $now - 86400);\n    $cache->set($cached);\n    $c->stats->profile(end => \"_avail_clean_cache\");\n\n    my $json = { data => $data };\n\n    $c->stats->profile(end => \"avail_update\");\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _avail_clean_cache {\n    my($data, $expire) = @_;\n    for my $key (keys %{$data}) {\n        if(ref $data->{$key} eq 'HASH') {\n            if(exists $data->{$key}->{'time'}) {\n                if($data->{$key}->{'time'} < $expire) {\n                    delete $data->{$key};\n                }\n            } else {\n                _avail_clean_cache($data->{$key}, $expire);\n            }\n            if(scalar keys %{$data->{$key}} == 0) {\n                delete $data->{$key};\n            }\n        }\n    }\n    return;\n}\n\n##########################################################\nsub _avail_calc {\n    my($c, $cached_only, $now, $cached, $opts, $host, $service, $filter) = @_;\n    my $duration = Thruk::Utils::expand_duration($opts->{'d'});\n    my $unavailable_states = {'down' => 1, 'unreachable' => 1, 'critical' => 1, 'unknown' => 1};\n    my $cache_retrieve_factor = $c->config->{'Thruk::Plugin::Panorama'}->{'cache_retrieve_factor'} || 0.0025; # ~ once a day for yearly values, every ~ 3.5 minutes for daily averages\n\n    # cache hit?\n    if($cached && !$c->req->parameters->{'force'}) {\n        my $refresh = 0;\n        if($now > $cached->{'time'} + $duration * $cache_retrieve_factor) {\n            $refresh = 1;\n        }\n        # retry unknown values every 2 minutes\n        elsif(!looks_like_number($cached->{'val'}) || $cached->{'val'} == -1) {\n            if($now > $cached->{'time'} + 120) {\n                $refresh = 1;\n            }\n        }\n        if(!$refresh) {\n            return($cached->{'val'});\n        }\n    }\n    if($cached_only) {\n        if(defined $cached->{'val'}) {\n            if($now > $cached->{'time'} + $duration * $cache_retrieve_factor*5 && $now > $cached->{'time'} + 180) {\n                # better return unknown for really old cached values\n                return(-1);\n            }\n            return($cached->{'val'});\n        }\n        return(-1);\n    }\n\n    $cached->{'time'} = $now;\n\n    $c->req->parameters->{t2}            = time();\n    $c->req->parameters->{t1}            = $c->req->parameters->{t2} - $duration;\n    $c->req->parameters->{rpttimeperiod} = $opts->{'tm'};\n    if($opts->{'h'}) {\n        $unavailable_states->{'down'}        = 0;\n        $unavailable_states->{'unreachable'} = 0;\n        for my $chr (split//mx, lc $opts->{'h'}) {\n            if($chr eq 'd') { $unavailable_states->{'down'}        = 1; }\n            if($chr eq 'u') { $unavailable_states->{'unreachable'} = 1; }\n        }\n    }\n    if($opts->{'s'}) {\n        $unavailable_states->{'warning'}  = 0;\n        $unavailable_states->{'critical'} = 0;\n        $unavailable_states->{'unknown'}  = 0;\n        for my $chr (split//mx, lc $opts->{'s'}) {\n            if($chr eq 'w') { $unavailable_states->{'warning'}  = 1; }\n            if($chr eq 'c') { $unavailable_states->{'critical'} = 1; }\n            if($chr eq 'u') { $unavailable_states->{'unknown'}  = 1; }\n        }\n    }\n    # set downtimes as unavailable too\n    if(defined $opts->{'downtime'} && !$opts->{'downtime'}) {\n        for my $key (keys %{$unavailable_states}) {\n            $unavailable_states->{$key.\"_downtime\"} = 1;\n        }\n    }\n    if(!$filter) {\n        eval {\n            Thruk::Utils::Avail::calculate_availability($c)\n        };\n        if($@) {\n            _error(\"calculating availability failed for filter:\");\n            _error(Dumper($c->req->parameters));\n            _error($@);\n            return(($ENV{'THRUK_JOB_ID'} ? '('.$ENV{'THRUK_JOB_ID'}.') ' : '').$@);\n        }\n    }\n    if($host) {\n        my $totals = Thruk::Utils::Avail::get_availability_percents($c->stash->{avail_data},\n                                                                    $unavailable_states,\n                                                                    $host,\n                                                                    $service,\n                                                                   );\n        return(\"found no data for service: \".$host.\" - \".$service) if($service && $totals->{'total'}->{'percent'} == -1);\n        return(\"found no data for host: \".$host) if (!defined $totals->{'total'}->{'percent'} || $totals->{'total'}->{'percent'} == -1);\n        return($totals->{'total'}->{'percent'});\n    } else {\n        my($num, $total) = (0,0);\n        # if nothing is enabled, use all\n        if(!$opts->{'incl_hst'} && !$opts->{'incl_svc'}) {\n            $opts->{'incl_hst'} = 1;\n            $opts->{'incl_svc'} = 1;\n        }\n        if($opts->{'incl_hst'}) {\n            my $s_filter = delete $c->req->parameters->{s_filter};\n            if($filter) {\n                delete $c->stash->{avail_data}->{'hosts'};\n                eval {\n                    Thruk::Utils::Avail::calculate_availability($c)\n                };\n                if($@) {\n                    _error(\"calculating availability failed for host filter:\");\n                    _error(Dumper($c->req->parameters));\n                    _error($@);\n                    return(($ENV{'THRUK_JOB_ID'} ? '('.$ENV{'THRUK_JOB_ID'}.') ' : '').$@);\n                }\n            }\n            if($c->stash->{avail_data}->{'hosts'}) {\n                for my $host (keys %{$c->stash->{avail_data}->{'hosts'}}) {\n                    my $totals = Thruk::Utils::Avail::get_availability_percents($c->stash->{avail_data},\n                                                                                $unavailable_states,\n                                                                                $host,\n                                                                               );\n                    if($totals->{'total'}->{'percent'} != -1) {\n                        $total += $totals->{'total'}->{'percent'};\n                        $num++;\n                    }\n                }\n            }\n            $c->req->parameters->{s_filter} = $s_filter;\n        }\n        if($opts->{'incl_svc'}) {\n            delete $c->req->parameters->{h_filter};\n            if($filter) {\n                delete $c->stash->{avail_data}->{'services'};\n                eval {\n                    Thruk::Utils::Avail::calculate_availability($c)\n                };\n                if($@) {\n                    _error(\"calculating availability failed for service filter:\");\n                    _error(Dumper($c->req->parameters));\n                    _error($@);\n                    return(($ENV{'THRUK_JOB_ID'} ? '('.$ENV{'THRUK_JOB_ID'}.') ' : '').$@);\n                }\n            }\n            if($c->stash->{avail_data}->{'services'}) {\n                for my $host (keys %{$c->stash->{avail_data}->{'services'}}) {\n                    for my $service (keys %{$c->stash->{avail_data}->{'services'}->{$host}}) {\n                        my $totals = Thruk::Utils::Avail::get_availability_percents($c->stash->{avail_data},\n                                                                                    $unavailable_states,\n                                                                                    $host,\n                                                                                    $service,\n                                                                                   );\n                        if($totals->{'total'}->{'percent'} != -1) {\n                            $total += $totals->{'total'}->{'percent'};\n                            $num++;\n                        }\n                    }\n                }\n            }\n        }\n        if($num > 0) {\n            return($total/$num);\n        }\n    }\n    return(\"found no data\");\n}\n\n##########################################################\nsub _task_stats_core_metrics {\n    my($c) = @_;\n\n    my $data = $c->db->get_extra_perf_stats(  filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'status' ) ] );\n    my $json = {\n        columns => [\n            { 'header' => 'Type',  dataIndex => 'type',  flex  => 1 },\n            { 'header' => 'Total', dataIndex => 'total', align => 'right', xtype => 'numbercolumn', format => '0,000' },\n            { 'header' => 'Rate',  dataIndex => 'rate',  align => 'right', xtype => 'numbercolumn', format => '0.00/s' },\n        ],\n        data    => [\n            { type => 'Servicechecks',       total => $data->{'service_checks'}, rate => $data->{'service_checks_rate'} },\n            { type => 'Hostchecks',          total => $data->{'host_checks'},    rate => $data->{'host_checks_rate'} },\n            { type => 'Connections',         total => $data->{'connections'},    rate => $data->{'connections_rate'} },\n            { type => 'Requests',            total => $data->{'requests'},       rate => $data->{'requests_rate'} },\n            { type => 'NEB Callbacks',       total => $data->{'neb_callbacks'},  rate => $data->{'neb_callbacks_rate'} },\n            { type => 'Cached Log Messages', total => $data->{'cached_log_messages'}, rate => '' },\n        ],\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_stats_check_metrics {\n    my($c) = @_;\n\n    my $data = $c->db->get_performance_stats( services_filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'services' ) ], hosts_filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'hosts' ) ] );\n\n    my $json = {\n        columns => [\n            { 'header' => 'Type',  dataIndex => 'type', flex  => 1 },\n            { 'header' => 'Min',   dataIndex => 'min', width => 60, align => 'right', xtype => 'numbercolumn', format => '0.00s' },\n            { 'header' => 'Max',   dataIndex => 'max', width => 60, align => 'right', xtype => 'numbercolumn', format => '0.00s' },\n            { 'header' => 'Avg',   dataIndex => 'avg', width => 60, align => 'right', xtype => 'numbercolumn', format => '0.00s' },\n        ],\n        data    => [\n            { type => 'Service Check Execution Time', min => $data->{'services_execution_time_min'}, max => $data->{'services_execution_time_max'}, avg => $data->{'services_execution_time_avg'} },\n            { type => 'Service Check Latency',        min => $data->{'services_latency_min'},        max => $data->{'services_latency_max'},        avg => $data->{'services_latency_avg'} },\n            { type => 'Host Check Execution Time',    min => $data->{'hosts_execution_time_min'},    max => $data->{'hosts_execution_time_max'},    avg => $data->{'hosts_execution_time_avg'} },\n            { type => 'Host Check Latency',           min => $data->{'hosts_latency_min'},           max => $data->{'hosts_latency_max'},           avg => $data->{'hosts_latency_avg'} },\n        ],\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_server_stats {\n    my($c) = @_;\n\n    my $show_load   = $c->req->parameters->{'load'}   || 'true';\n    my $show_cpu    = $c->req->parameters->{'cpu'}    || 'true';\n    my $show_memory = $c->req->parameters->{'memory'} || 'true';\n\n    my $json = {\n        columns => [\n            { 'header' => 'Cat',    dataIndex => 'cat',   hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Type',   dataIndex => 'type',  width => 60, align => 'right' },\n            { 'header' => 'Value',  dataIndex => 'value', width => 65, align => 'right', renderer => 'TP.render_systat_value' },\n            { 'header' => 'Graph',  dataIndex => 'graph', flex  => 1,                    renderer => 'TP.render_systat_graph' },\n            { 'header' => 'Warn',   dataIndex => 'warn',  hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Crit',   dataIndex => 'crit',  hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Max',    dataIndex => 'max',   hidden => Cpanel::JSON::XS::true },\n        ],\n        data  => [],\n        group => 'cat',\n    };\n    return $c->render(json => $json) unless -e '/proc'; # all beyond is linux only\n\n    my($cpu, $cpucount);\n    if($show_load eq 'true' or $show_cpu eq 'true') {\n        my $lastcpu = $c->cache->get('panorama_sys_cpu');\n        my $pcs  = Thruk::Utils::PanoramaCpuStats->new({sleep => 3, init => $lastcpu->{'init'}});\n           $cpu  = $pcs->get();\n           $cpucount = (scalar keys %{$cpu}) - 1;\n        # don't save more often than 5 seconds to keep a better reference\n        if(!defined $lastcpu->{'time'} || $lastcpu->{'time'} +5 < time()) {\n            $c->cache->set('panorama_sys_cpu', { init => $pcs->{'init'}, time => time() });\n        }\n        $cpu     = $cpu->{'cpu'};\n    }\n\n    if($show_load eq 'true') {\n        my @load = split(/\\s+/mx,(Thruk::Utils::IO::read('/proc/loadavg')));\n        push @{$json->{'data'}},\n            { cat => 'Load',    type => 'load 1',   value => $load[0],            'warn' => $cpucount*2.5, crit => $cpucount*5.0, max => $cpucount*3, graph => '' },\n            { cat => 'Load',    type => 'load 5',   value => $load[1],            'warn' => $cpucount*2.0, crit => $cpucount*3.0, max => $cpucount*3, graph => '' },\n            { cat => 'Load',    type => 'load 15',  value => $load[2],            'warn' => $cpucount*1.5, crit => $cpucount*2,   max => $cpucount*3, graph => '' };\n    }\n    if($show_cpu eq 'true') {\n        push @{$json->{'data'}},\n            { cat => 'CPU',     type => 'User',     value => $cpu->{'user'},      'warn' => 70, crit => 90, max => 100, graph => '' },\n            { cat => 'CPU',     type => 'Nice',     value => $cpu->{'nice'},      'warn' => 70, crit => 90, max => 100, graph => '' },\n            { cat => 'CPU',     type => 'System',   value => $cpu->{'system'},    'warn' => 70, crit => 90, max => 100, graph => '' },\n            { cat => 'CPU',     type => 'Wait IO',  value => $cpu->{'iowait'},    'warn' => 70, crit => 90, max => 100, graph => '' };\n    }\n    if($show_memory eq 'true') {\n        # gather system statistics\n        my $mem = {};\n        for my $line (split/\\n/mx,(Thruk::Utils::IO::read('/proc/meminfo'))) {\n            my($name,$val,$unit) = split(/\\s+/mx,$line,3);\n            next unless defined $unit;\n            $name =~ s/:$//gmx;\n            $mem->{$name} = int($val / 1024);\n        }\n        $mem->{'Buffers'} = 0; # can be empty on some machines\n        push @{$json->{'data'}},\n            { cat => 'Memory',  type => 'total',    value => $mem->{'MemTotal'},  graph => '', warn => $mem->{'MemTotal'}, crit => $mem->{'MemTotal'}, max => $mem->{'MemTotal'} },\n            { cat => 'Memory',  type => 'free',     value => $mem->{'MemFree'},   'warn' => $mem->{'MemTotal'}*0.7, crit => $mem->{'MemTotal'}*0.8, max => $mem->{'MemTotal'}, graph => '' },\n            { cat => 'Memory',  type => 'used',     value => $mem->{'MemTotal'}-$mem->{'MemFree'}-$mem->{'Buffers'}-$mem->{'Cached'}, 'warn' => $mem->{'MemTotal'}*0.7, crit => $mem->{'MemTotal'}*0.8, max => $mem->{'MemTotal'}, graph => '' },\n            { cat => 'Memory',  type => 'buffers',  value => $mem->{'Buffers'},   'warn' => $mem->{'MemTotal'}*0.8, crit => $mem->{'MemTotal'}*0.9, max => $mem->{'MemTotal'}, graph => '' },\n            { cat => 'Memory',  type => 'cached',   value => $mem->{'Cached'},    'warn' => $mem->{'MemTotal'}*0.8, crit => $mem->{'MemTotal'}*0.9, max => $mem->{'MemTotal'}, graph => '' };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_stats_gearman {\n    my($c) = @_;\n    my $json = _get_gearman_stats($c);\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_stats_gearman_grid {\n    my($c) = @_;\n\n    my $data = _get_gearman_stats($c);\n\n    my $json = {\n        columns => [\n            { 'header' => 'Queue',   dataIndex => 'name', flex  => 1, renderer => 'TP.render_gearman_queue' },\n            { 'header' => 'Worker',  dataIndex => 'worker',  width => 60, align => 'right', xtype => 'numbercolumn', format => '0,000' },\n            { 'header' => 'Running', dataIndex => 'running', width => 60, align => 'right', xtype => 'numbercolumn', format => '0,000' },\n            { 'header' => 'Waiting', dataIndex => 'waiting', width => 60, align => 'right', xtype => 'numbercolumn', format => '0,000' },\n        ],\n        data    => [],\n    };\n    for my $queue (sort keys %{$data}) {\n        # hide empty queues\n        next if($data->{$queue}->{'worker'} == 0 and $data->{$queue}->{'running'} == 0 and $data->{$queue}->{'waiting'} == 0);\n        push @{$json->{'data'}}, {\n            name    => $queue,\n            worker  => $data->{$queue}->{'worker'},\n            running => $data->{$queue}->{'running'},\n            waiting => $data->{$queue}->{'waiting'},\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_show_logs {\n    my($c) = @_;\n\n    my $filter;\n    my $end   = time();\n    my $start = $end - Thruk::Utils::expand_duration($c->req->parameters->{'time'} || '15m');\n    push @{$filter}, { time => { '>=' => $start }};\n    push @{$filter}, { time => { '<=' => $end }};\n\n    # additional filters set?\n    my $pattern         = $c->req->parameters->{'pattern'};\n    my $exclude_pattern = $c->req->parameters->{'exclude'};\n    if(defined $pattern and $pattern !~ m/^\\s*$/mx) {\n        push @{$filter}, { message => { '~~' => Thruk::Utils::clean_regex($pattern) }};\n    }\n    if(defined $exclude_pattern and $exclude_pattern !~ m/^\\s*$/mx) {\n        push @{$filter}, { message => { '!~~' => Thruk::Utils::clean_regex($exclude_pattern) }};\n    }\n    my $total_filter = Thruk::Utils::combine_filter('-and', $filter);\n    $c->db->renew_logcache($c);\n    my $data = $c->db->get_logs(filter => [$total_filter, Thruk::Utils::Auth::get_auth_filter($c, 'log')], sort => {'DESC' => 'time'});\n\n    my $json = {\n        columns => [\n            { 'header' => 'Icon',    dataIndex => 'icon', width => 30, tdCls => 'icon_column', renderer => 'TP.render_icon_log' },\n            { 'header' => 'Time',    dataIndex => 'time', width => 60, renderer => 'TP.render_date' },\n            { 'header' => 'Message', dataIndex => 'message', flex => 1 },\n        ],\n        data    => [],\n    };\n    for my $row (@{$data}) {\n        push @{$json->{'data'}}, {\n            icon    => Thruk::Utils::Filter::logline_icon($row),\n            time    => $row->{'time'},\n            message => substr($row->{'message'},13),\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_site_status {\n    my($c) = @_;\n\n    if(!$c->stash->{'pi_detail'} || scalar keys %{$c->stash->{'pi_detail'}} == 0) {\n        my $cached_data = $c->cache->get->{'global'} || {};\n        Thruk::Action::AddDefaults::set_processinfo($c, undef, undef, $cached_data, 1);\n    }\n\n    my $backend_filter;\n    if($c->req->parameters->{'backends'}) {\n        $backend_filter = {};\n        for my $b (ref $c->req->parameters->{'backends'} eq 'ARRAY' ? @{$c->req->parameters->{'backends'}} : $c->req->parameters->{'backends'}) {\n            $backend_filter->{$b} = 1;\n        }\n    }\n\n    my $json = {\n        columns => [\n            { 'header' => 'Id',               dataIndex => 'id',                      width => 45, hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Icon',             dataIndex => 'icon',                    width => 30, tdCls => 'icon_column', renderer => 'TP.render_icon_site' },\n            { 'header' => 'Category',         dataIndex => 'category',                width => 60, hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Section',          dataIndex => 'section',                 width => 60, hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Site',             dataIndex => 'site',                    width => 60, flex => 1 },\n            { 'header' => 'Version',          dataIndex => 'version',                 width => 50, renderer => 'TP.add_title' },\n            { 'header' => 'Runtime',          dataIndex => 'runtime',                 width => 85 },\n            { 'header' => 'Notifications',    dataIndex => 'enable_notifications',    width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Svc Checks',       dataIndex => 'execute_service_checks',  width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Hst Checks',       dataIndex => 'execute_host_checks',     width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Eventhandlers',    dataIndex => 'enable_event_handlers',   width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Performance Data', dataIndex => 'process_performance_data',width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n        ],\n        data    => [],\n    };\n\n    for my $key (@{$c->stash->{'backends'}}) {\n        next if($backend_filter && !defined $backend_filter->{$key});\n        my $b    = $c->stash->{'backend_detail'}->{$key};\n        my $d    = {};\n        $d       = $c->stash->{'pi_detail'}->{$key} if ref $c->stash->{'pi_detail'} eq 'HASH';\n        my $icon = 'exclamation.png';\n        if($b->{'running'} && $d->{'program_start'}) { $icon = 'accept.png'; }\n        my $runtime = \"\";\n        my $program_version = $b->{'last_error'};\n        if($b->{'running'} && $d->{'program_start'}) {\n            $runtime = Thruk::Utils::Filter::duration(time() - $d->{'program_start'});\n            $program_version = $d->{'program_version'};\n        }\n        my $row = {\n            id       => $key,\n            icon     => $icon,\n            site     => $b->{'name'},\n            version  => $program_version,\n            runtime  => $runtime,\n            section  => $b->{'section'},\n            category => $b->{'section'}, # keep for backwards compatibility\n        };\n        for my $attr (qw/enable_notifications execute_host_checks execute_service_checks\n                      enable_event_handlers process_performance_data/) {\n            $row->{$attr} = $d->{$attr};\n        }\n        push @{$json->{'data'}}, $row;\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_hosts {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'pageSize'};\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'currentPage'};\n\n    my $data = $c->db->get_hosts(filter        => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ],\n                                     pager         => 1,\n                                     extra_columns => [qw/long_plugin_output/],\n                                     sort          => _append_sort($c->req->parameters->{'sort'}, { ASC => [ 'name' ] }),\n                                    );\n\n    my $json = {\n        columns => [\n            { 'header' => 'Hostname',               width => 120, dataIndex => 'name',                                 renderer => 'TP.render_clickable_host' },\n            { 'header' => 'Icons',                  width => 75,  dataIndex => 'icons',             align => 'right',  renderer => 'TP.render_host_icons' },\n            { 'header' => 'Status',                 width => 80,  dataIndex => 'state',             align => 'center', renderer => 'TP.render_host_status' },\n            { 'header' => 'Last Check',             width => 80,  dataIndex => 'last_check',        align => 'center', renderer => 'TP.render_last_check' },\n            { 'header' => 'Duration',               width => 100, dataIndex => 'last_state_change', align => 'center', renderer => 'TP.render_duration' },\n            { 'header' => 'Attempt',                width => 60,  dataIndex => 'current_attempt',   align => 'center', renderer => 'TP.render_attempt' },\n            { 'header' => 'Site',                   width => 60,  dataIndex => 'peer_name',         align => 'center', renderer => 'TP.render_peer_name' },\n            { 'header' => 'Status Information',     flex  => 1,   dataIndex => 'plugin_output',                        renderer => 'TP.render_plugin_output' },\n            { 'header' => 'Performance',            width => 80,  dataIndex => 'perf_data',                            renderer => 'TP.render_perfbar' },\n\n            { 'header' => 'Parents',                  dataIndex => 'parents',                     hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_clickable_host_list' },\n            { 'header' => 'Current Attempt',          dataIndex => 'current_attempt',             hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Max Check Attempts',       dataIndex => 'max_check_attempts',          hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Last State Change',        dataIndex => 'last_state_change',           hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Check Type',               dataIndex => 'check_type',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_check_type' },\n            { 'header' => 'Site ID',                  dataIndex => 'peer_key',                    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Has Been Checked',         dataIndex => 'has_been_checked',            hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Active Checks Enabled',    dataIndex => 'active_checks_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Accept Passive Checks',    dataIndex => 'accept_passive_checks',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Next Check',               dataIndex => 'next_check',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Notification Number',      dataIndex => 'current_notification_number', hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'First Notification Delay', dataIndex => 'first_notification_delay',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Notifications Enabled',    dataIndex => 'notifications_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Is Flapping',              dataIndex => 'is_flapping',                 hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Acknowledged',             dataIndex => 'acknowledged',                hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Comments',                 dataIndex => 'comments',                    hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Scheduled Downtime Depth', dataIndex => 'scheduled_downtime_depth',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Action Url',               dataIndex => 'action_url_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_action_url' },\n            { 'header' => 'Notes url',                dataIndex => 'notes_url_expanded',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_notes_url' },\n            { 'header' => 'Notes',                    dataIndex => 'notes',                       hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Icon Image',               dataIndex => 'icon_image_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_icon_url' },\n            { 'header' => 'Icon Image Alt',           dataIndex => 'icon_image_alt',              hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Names',    dataIndex => 'custom_variable_names',       hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Values',   dataIndex => 'custom_variable_values',      hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Long Plugin Output',       dataIndex => 'long_plugin_output',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_long_pluginoutput' },\n\n            { 'header' => 'Last Time Up',          dataIndex => 'last_time_up',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Unreachable', dataIndex => 'last_time_unreachable', hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Down',        dataIndex => 'last_time_down',        hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n        ],\n        data        => $c->stash->{'data'},\n        totalCount  => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    if($c->config->{'show_custom_vars'} || $c->config->{'expose_custom_vars'}) {\n        for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n            $var =~ s/^_//gmx;\n            push @{$json->{'columns'}},\n            { 'header' => $var, dataIndex => $var, hidden => Cpanel::JSON::XS::true };\n        }\n        for my $h ( @{$c->stash->{'data'}}) {\n            my $cust = Thruk::Utils::get_custom_vars($c, $h);\n            for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n                $var =~ s/^_//gmx;\n                $h->{$var} = $cust->{$var} // '';\n            }\n            $h->{'THRUK_ACTION_MENU'} = $cust->{'THRUK_ACTION_MENU'} // '';\n        }\n    }\n    if(!$c->check_user_roles(\"authorized_for_configuration_information\")) {\n        # remove custom macro colums which could contain confidential informations\n        for my $h ( @{$c->stash->{'data'}}) {\n            delete $h->{'custom_variable_names'};\n            delete $h->{'custom_variable_values'};\n        }\n    }\n\n    if($c->stash->{'escape_html_tags'} or $c->stash->{'show_long_plugin_output'} eq 'inline') {\n        for my $h ( @{$c->stash->{'data'}}) {\n            _escape($h)      if $c->stash->{'escape_html_tags'};\n            _long_plugin($h) if $c->stash->{'show_long_plugin_output'} eq 'inline';\n        }\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_services {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'pageSize'};\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'currentPage'};\n\n    $c->db->get_services(filter        => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter],\n                             pager         => 1,\n                             extra_columns => [qw/long_plugin_output/],\n                             sort          => _append_sort($c->req->parameters->{'sort'}, { ASC => [ 'host_name',   'description' ] }),\n                            );\n\n    my $json = {\n        columns => [\n            { 'header' => 'Hostname',               width => 120, dataIndex => 'host_display_name',                    renderer => 'TP.render_service_host' },\n            { 'header' => 'Host',                                 dataIndex => 'host_name',         hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Host Icons',             width => 75,  dataIndex => 'icons',             align => 'right',  renderer => 'TP.render_host_service_icons' },\n            { 'header' => 'Service',                width => 120, dataIndex => 'display_name',                         renderer => 'TP.render_clickable_service' },\n            { 'header' => 'Description',                          dataIndex => 'description',       hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Icons',                  width => 75,  dataIndex => 'icons',             align => 'right',  renderer => 'TP.render_service_icons' },\n            { 'header' => 'Status',                 width => 70,  dataIndex => 'state',             align => 'center', renderer => 'TP.render_service_status' },\n            { 'header' => 'Last Check',             width => 80,  dataIndex => 'last_check',        align => 'center', renderer => 'TP.render_last_check' },\n            { 'header' => 'Duration',               width => 100, dataIndex => 'last_state_change', align => 'center', renderer => 'TP.render_duration' },\n            { 'header' => 'Attempt',                width => 60,  dataIndex => 'current_attempt',   align => 'center', renderer => 'TP.render_attempt' },\n            { 'header' => 'Site',                   width => 60,  dataIndex => 'peer_name',         align => 'center', renderer => 'TP.render_peer_name' },\n            { 'header' => 'Status Information',     flex  => 1,   dataIndex => 'plugin_output',                        renderer => 'TP.render_plugin_output' },\n            { 'header' => 'Performance',            width => 80,  dataIndex => 'perf_data',                            renderer => 'TP.render_perfbar' },\n\n            { 'header' => 'Current Attempt',          dataIndex => 'current_attempt',             hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Max Check Attempts',       dataIndex => 'max_check_attempts',          hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Last State Change',        dataIndex => 'last_state_change',           hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Check Type',               dataIndex => 'check_type',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_check_type' },\n            { 'header' => 'Site ID',                  dataIndex => 'peer_key',                    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Has Been Checked',         dataIndex => 'has_been_checked',            hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Active Checks Enabled',    dataIndex => 'active_checks_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Accept Passive Checks',    dataIndex => 'accept_passive_checks',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Next Check',               dataIndex => 'next_check',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Notification Number',      dataIndex => 'current_notification_number', hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'First Notification Delay', dataIndex => 'first_notification_delay',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Notifications Enabled',    dataIndex => 'notifications_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Is Flapping',              dataIndex => 'is_flapping',                 hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Acknowledged',             dataIndex => 'acknowledged',                hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Comments',                 dataIndex => 'comments',                    hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Scheduled Downtime Depth', dataIndex => 'scheduled_downtime_depth',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Action Url',               dataIndex => 'action_url_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_action_url' },\n            { 'header' => 'Notes url',                dataIndex => 'notes_url_expanded',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_notes_url' },\n            { 'header' => 'Icon Image',               dataIndex => 'icon_image_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_icon_url' },\n            { 'header' => 'Icon Image Alt',           dataIndex => 'icon_image_alt',              hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Names',    dataIndex => 'custom_variable_names',       hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Values',   dataIndex => 'custom_variable_values',      hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Long Plugin Output',       dataIndex => 'long_plugin_output',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_long_pluginoutput' },\n\n            { 'header' => 'Host Parents',                   dataIndex => 'host_parents',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_clickable_host_list' },\n            { 'header' => 'Host Status',                    dataIndex => 'host_state',                    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_host_status' },\n            { 'header' => 'Host Notifications Enabled',     dataIndex => 'host_notifications_enabled',    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Host Check Type',                dataIndex => 'host_check_type',               hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_check_type' },\n            { 'header' => 'Host Active Checks Enabled',     dataIndex => 'host_active_checks_enabled',    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Accept Passive Checks',     dataIndex => 'host_accept_passive_checks',    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Is Flapping',               dataIndex => 'host_is_flapping',              hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Acknowledged',              dataIndex => 'host_acknowledged',             hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Comments',                  dataIndex => 'host_comments',                 hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Host Scheduled Downtime Depth',  dataIndex => 'host_scheduled_downtime_depth', hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Host Action Url',                dataIndex => 'host_action_url_expanded',      hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_action_url' },\n            { 'header' => 'Host Notes Url',                 dataIndex => 'host_notes_url_expanded',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_notes_url' },\n            { 'header' => 'Host Notes',                     dataIndex => 'host_notes',                    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Host Icon Image',                dataIndex => 'host_icon_image_expanded',      hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_icon_url' },\n            { 'header' => 'Host Icon Image Alt',            dataIndex => 'host_icon_image_alt',           hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Host Custom Variable Names',     dataIndex => 'host_custom_variable_names',    hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Host Custom Variable Values',    dataIndex => 'host_custom_variable_values',   hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n\n            { 'header' => 'Last Time Ok',       dataIndex => 'last_time_ok',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Warning',  dataIndex => 'last_time_warning',  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Unknown',  dataIndex => 'last_time_unknown',  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Critical', dataIndex => 'last_time_critical', hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n        ],\n        data        => $c->stash->{'data'},\n        totalCount  => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    if($c->config->{'show_custom_vars'} || $c->config->{'expose_custom_vars'}) {\n        for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n            $var =~ s/^_//gmx;\n            push @{$json->{'columns'}},\n            { 'header' => $var, dataIndex => $var, hidden => Cpanel::JSON::XS::true };\n        }\n    }\n    for my $s ( @{$c->stash->{'data'}}) {\n        my $cust = Thruk::Utils::get_custom_vars($c, $s, undef, 1);\n        for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n            $var =~ s/^_//gmx;\n            $s->{$var} = $cust->{$var} // $cust->{'HOST'.$var} // '';\n        }\n        $s->{'THRUK_ACTION_MENU'}     = $cust->{'THRUK_ACTION_MENU'} // '';\n        $s->{'HOSTTHRUK_ACTION_MENU'} = $cust->{'HOSTTHRUK_ACTION_MENU'} // '';\n    }\n    if(!$c->check_user_roles(\"authorized_for_configuration_information\")) {\n        # remove custom macro colums which could contain confidential informations\n        for my $s ( @{$c->stash->{'data'}}) {\n            delete $s->{'host_custom_variable_names'};\n            delete $s->{'host_custom_variable_values'};\n            delete $s->{'custom_variable_names'};\n            delete $s->{'custom_variable_values'};\n        }\n    }\n\n    if($c->stash->{'escape_html_tags'} or $c->stash->{'show_long_plugin_output'} eq 'inline') {\n        for my $s ( @{$c->stash->{'data'}}) {\n            _escape($s)      if $c->stash->{'escape_html_tags'};\n            _long_plugin($s) if $c->stash->{'show_long_plugin_output'} eq 'inline';\n        }\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_squares_data {\n    my($c) = @_;\n\n    my $source = $c->req->parameters->{'source'} || 'hosts';\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $now          = time();\n    my $data         = [];\n    my $allowed      = $c->check_user_roles(\"authorized_for_configuration_information\");\n    my $allowed_list = Thruk::Utils::get_exposed_custom_vars($c->config);\n\n    my $show_full_commandline = $c->config->{'show_full_commandline'};\n    if($source eq 'services' || $source eq 'both') {\n        my $services = $c->db->get_services(\n                                    filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter],\n                                    columns => [qw/host_name description state acknowledged scheduled_downtime_depth has_been_checked last_state_change/, $c->req->parameters->{'service_label'} ? qw/host_alias custom_variable_names custom_variable_values host_custom_variable_names host_custom_variable_values/ : ()],\n                                    sort    => { ASC => [ 'host_name',   'description' ] },\n                                );\n        for my $svc (@{$services}) {\n            Thruk::Utils::set_allowed_rows_data($svc, $allowed, $allowed_list, $show_full_commandline);\n            push @{$data}, { uniq         => $svc->{'host_name'}.';'.$svc->{'description'},\n                             name         => $c->req->parameters->{'service_label'} ? _squares_data_label($svc, $c->req->parameters->{'service_label'}) : $svc->{'host_name'}.' - '.$svc->{'description'},\n                             host_name    => $svc->{'host_name'},\n                             description  => $svc->{'description'},\n                             state        => $svc->{'has_been_checked'} == 0 ? 4 : $svc->{'state'},\n                             downtime     => $svc->{'scheduled_downtime_depth'},\n                             acknowledged => $svc->{'acknowledged'},\n                             link         => 'extinfo.cgi?type=2&host='.$svc->{'host_name'}.\"&service=\".$svc->{'description'},\n                             duration     => $now - $svc->{'last_state_change'},\n                             isHost       => 0,\n                           };\n        }\n    }\n\n    if($source eq 'hosts' || $source eq 'both') {\n        my $hosts = $c->db->get_hosts(\n                                    filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter],\n                                    columns => [qw/name state acknowledged scheduled_downtime_depth has_been_checked last_state_change/, $c->req->parameters->{'host_label'} ? qw/alias custom_variable_names custom_variable_values/ : ()],\n                                    sort    => { ASC => [ 'name' ] },\n                                );\n        for my $hst (@{$hosts}) {\n            Thruk::Utils::set_allowed_rows_data($hst, $allowed, $allowed_list, $show_full_commandline);\n            push @{$data}, { uniq         => $hst->{'name'},\n                             name         => $c->req->parameters->{'host_label'} ? _squares_data_label($hst, $c->req->parameters->{'host_label'}) : $hst->{'name'},\n                             host_name    => $hst->{'name'},\n                             description  => '',\n                             state        => $hst->{'state'},\n                             downtime     => $hst->{'scheduled_downtime_depth'},\n                             acknowledged => $hst->{'acknowledged'},\n                             link         => 'extinfo.cgi?type=1&host='.$hst->{'name'},\n                             duration     => $now - $hst->{'last_state_change'},\n                             isHost       => 1,\n                            };\n        }\n    }\n\n    # need to sort by host/service again\n    if($source eq 'both') {\n        $data = Thruk::Backend::Manager::sort_result({}, $data, 'uniq');\n    }\n\n    # apply group by\n    if($c->req->parameters->{'groupby'}) {\n        my $groupby = Thruk::Base::list($c->req->parameters->{'groupby'});\n        if(scalar @{$groupby} == 2 && $groupby->[0] eq 'host_name' && $groupby->[1] eq 'description') {\n            # nothing todo\n        }\n        elsif(scalar @{$groupby} == 1 && $groupby->[0] eq 'host_name' && $source eq 'hosts') {\n            # nothing todo\n        } else {\n            my $grouped_data = {};\n            for my $d (@{$data}) {\n                my $uniq = [];\n                for my $key (@{$groupby}) {\n                    push @{$uniq}, $d->{$key};\n                }\n                $uniq = join(\" - \", @{$uniq});\n                my $details = {\n                    'host_name'    => $d->{'host_name'},\n                    'description'  => $d->{'description'},\n                    'state'        => $d->{'state'},\n                    'duration'     => $d->{'duration'},\n                    'acknowledged' => $d->{'acknowledged'},\n                    'downtime'     => $d->{'downtime'},\n                    'isHost'       => $d->{'isHost'},\n                };\n                if(!$grouped_data->{$uniq}) {\n                    $grouped_data->{$uniq} = $d;\n                    $grouped_data->{$uniq}->{'uniq'}    = $uniq;\n                    $grouped_data->{$uniq}->{'name'}    = $uniq;\n                    $grouped_data->{$uniq}->{'details'} = [$details];\n                    delete $grouped_data->{$uniq}->{'link'};\n                } else {\n                    my $comb = $grouped_data->{$uniq};\n                    if($d->{'state'} > 0 && $d->{'state'} != 4) {\n                        my $worse = 0;\n                        if(!$d->{'acknowledged'} && $comb->{'acknowledged'}) {\n                            $worse = 1;\n                        }\n                        elsif(!$d->{'downtime'} && $comb->{'downtime'}) {\n                            $worse = 1;\n                        }\n                        elsif($d->{'isHost'} && !$comb->{'isHost'}) {\n                            $worse = 1;\n                        }\n                        elsif($comb->{'isHost'} && $comb->{'state'} != 0) {\n                            # host state beats every service\n                        }\n                        elsif($d->{'state'} > $comb->{'state'}) {\n                            $worse = 1;\n                        }\n                        if($worse) {\n                            $comb->{'state'}        = $d->{'state'};\n                            $comb->{'isHost'}       = $d->{'isHost'};\n                            $comb->{'downtime'}     = $d->{'downtime'};\n                            $comb->{'acknowledged'} = $d->{'acknowledged'};\n                            $comb->{'duration'}     = $d->{'duration'};\n                        }\n                    }\n                    if($comb->{'duration'} > $d->{'duration'} && $comb->{'state'} == $d->{'state'} && $comb->{'isHost'} == $d->{'isHost'}) {\n                        $comb->{'duration'} = $d->{'duration'};\n                    }\n                    push @{$grouped_data->{$uniq}->{'details'}}, $details;\n                }\n            }\n            $data = [];\n            for my $key (sort keys %{$grouped_data}) {\n                push @{$data}, $grouped_data->{$key};\n            }\n        }\n    }\n\n    my $json = {\n        data => $data,\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _squares_data_label {\n    my($obj, $label) = @_;\n    my $res = $label;\n    for my $key (qw/host_name host_alias name alias description/) {\n        my $val = $obj->{$key} // '';\n        $res =~ s|\\{\\{$key\\}\\}|$val|gmxi;\n    }\n    if($obj->{'custom_variables'}) {\n        for my $key (sort keys %{$obj->{'custom_variables'}}) {\n            my $val = $obj->{'custom_variables'}->{$key} // '';\n            $res =~ s|\\{\\{_$key\\}\\}|$val|gmxi;\n        }\n    }\n    if($obj->{'host_custom_variables'}) {\n        for my $key (sort keys %{$obj->{'custom_variables'}}) {\n            my $val = $obj->{'custom_variables'}->{$key} // '';\n            $res =~ s|\\{\\{_HOST$key\\}\\}|$val|gmxi;\n        }\n    }\n    # remove all remaining placeholder\n    $res =~ s|\\{\\{.*?\\}\\}||gmxi;\n    return($res);\n}\n\n##########################################################\nsub _task_hosttotals {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n    Thruk::Utils::Status::fill_totals_box( $c, $hostfilter, undef, 1);\n\n    my $s = $c->stash->{'host_stats'};\n    my $json = {\n        columns => [\n            { 'header' => '#',     width => 40, dataIndex => 'count', align => 'right', renderer => 'TP.render_statuscount' },\n            { 'header' => 'State', flex  => 1,  dataIndex => 'state' },\n        ],\n        data      => [],\n    };\n\n    for my $state (qw/up down unreachable pending/) {\n        push @{$json->{'data'}}, {\n            state => ucfirst $state,\n            count => $s->{$state},\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_servicetotals {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n    Thruk::Utils::Status::fill_totals_box( $c, undef, $servicefilter, 1 );\n\n    my $s = $c->stash->{'service_stats'};\n    my $json = {\n        columns => [\n            { 'header' => '#',     width => 40, dataIndex => 'count', align => 'right', renderer => 'TP.render_statuscount' },\n            { 'header' => 'State', flex  => 1,  dataIndex => 'state' },\n        ],\n        data      => [],\n    };\n\n    for my $state (qw/ok warning unknown critical pending/) {\n        push @{$json->{'data'}}, {\n            state => ucfirst $state,\n            count => $s->{$state},\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_hosts_pie {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $data = $c->db->get_host_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter]);\n\n    my $json = {\n        columns => [\n            { 'header' => 'Name',      dataIndex => 'name' },\n            { 'header' => 'Data',      dataIndex => 'value' },\n        ],\n        colors    => [ ],\n        data      => [],\n    };\n    my $colors = {\n        up          => '#00FF33',\n        down        => '#FF5B33',\n        unreachable => '#FF7A59',\n        pending     => '#ACACAC',\n    };\n\n    for my $state (qw/up down unreachable pending/) {\n        next if $data->{$state} == 0;\n        push @{$json->{'data'}}, {\n            name    => ucfirst $state,\n            value   => $data->{$state},\n        };\n        push @{$json->{'colors'}}, $colors->{$state};\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_services_pie {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $data = $c->db->get_service_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter]);\n\n    my $json = {\n        columns => [\n            { 'header' => 'Name',      dataIndex => 'name' },\n            { 'header' => 'Data',      dataIndex => 'value' },\n        ],\n        colors    => [],\n        data      => [],\n    };\n    my $colors = {\n        ok       => '#00FF33',\n        warning  => '#FFDE00',\n        unknown  => '#FF9E00',\n        critical => '#FF5B33',\n        pending  => '#ACACAC',\n    };\n\n    for my $state (qw/ok warning unknown critical pending/) {\n        next if $data->{$state} == 0;\n        push @{$json->{'data'}}, {\n            name    => ucfirst $state,\n            value   => $data->{$state},\n        };\n        push @{$json->{'colors'}}, $colors->{$state};\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_servicesminemap {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my($uniq_services, $hosts, $matrix) = Thruk::Utils::Status::get_service_matrix($c, $hostfilter, $servicefilter);\n\n    # automatically adjust service column hight\n    my $longest_description = 0;\n    for my $svc (sort keys %{$uniq_services}) {\n        my $l = length($svc);\n        $longest_description = $l if $l > $longest_description;\n    }\n    my $height = 15 + int($longest_description * 5.70);\n    $height    =  40 if $height <  40;\n    $height    = 300 if $height > 300;\n\n    my $service2index = {};\n    my $json = {\n        columns => [\n            { 'header'       => '<div class=\"minemap_first_col\" style=\"top: '.($height/2-10).'px;\">Hostname</div>',\n              'headerIE'     => '<div class=\"minemap_first_col\" style=\"top: '.($height-25).'px;\">Hostname</div>',\n              'headerChrome' => '<div class=\"minemap_first_col\" style=\"bottom: 0px;\">Hostname</div>',\n              'width'        => 120,\n              'height'       => $height,\n              'dataIndex'    => 'host_display_name',\n            },\n        ],\n        data        => [],\n    };\n\n    my $x=0;\n    for my $svc (sort keys %{$uniq_services}) {\n        my $index = 'col'.$x;\n        $service2index->{$svc} = $index;\n        push @{$json->{'columns'}}, {\n                    'header'       => '<div class=\"vertical\" style=\"top: '.($height/2-10).'px;\">'.$svc.'</div>',\n                    'headerIE'     => '<div class=\"vertical\" style=\"top: 8px; width: '.($height-25).'px; right: '.($height/2-16).'px;\">'.$svc.'</div>',\n                    'headerChrome' => '<div class=\"vertical\" style=\"top: '.($height/2-10).'px;\">'.$svc.'</div>',\n                    'width'        => 20,\n                    'height'       => $height,\n                    'dataIndex'    => $index,\n                    'align'        => 'center',\n                    'tdCls'        => 'mine_map_cell',\n        };\n        $x++;\n    }\n    for my $name (sort keys %{$hosts}) {\n        my $hst  = $hosts->{$name};\n        my $data;\n        if ($hst->{'host_action_url_expanded'}) {\n            $data = { 'host_display_name' => $hst->{'host_display_name'} . \"&nbsp;<a target='_blank' href='\".$hst->{'host_action_url_expanded'}.\"' style='position: relative;'><i class='fa-solid fa-chart-line clickable' title='Show Performance Chart'></i></a>\" };\n        } else {\n            $data = { 'host_display_name' => $hst->{'host_display_name'} };\n        }\n\n        for my $svc (keys %{$uniq_services}) {\n            my $service = $matrix->{$name}->{$svc};\n            next unless defined $service->{state};\n            my $cls     = 'mine_map_state'.$service->{state};\n            $cls        = 'mine_map_state4' if $service->{has_been_checked} == 0;\n            my $text    = '&nbsp;';\n            if($service->{'scheduled_downtime_depth'}) { $text = '<i class=\"fa-solid fa-moon\" title=\"downtime\" style=\"font-size: 14px; line-height: 16px;\"></i>' }\n            if($service->{'acknowledged'})             { $text = '<i class=\"fa-solid fa-person-digging\" title=\"acknowledged\" style=\"font-size: 14px; line-height: 16px;\"></i>' }\n            $data->{$service2index->{$svc}} = '<div class=\"clickable '.$cls.'\" '._generate_service_popup($c, $service).'>'.$text.'</div>';\n        }\n        push @{$json->{'data'}}, $data;\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_show_comments {\n    my($c) = @_;\n\n    my($hostfilter, $servicefilter, undef, undef, $has_service_filter) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $source = $c->req->parameters->{'source'} || 'both';\n\n    my $generalfilter;\n    if($source eq 'hosts') {\n        push @{$generalfilter},  { service_description => { '=' => '' }};\n    }\n    elsif($source eq 'services') {\n        push @{$generalfilter},  { service_description => { '!=' => '' }};\n    }\n\n    if($hostfilter && ($source eq 'hosts' || $source eq 'both')) {\n        my $hosts = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ], columns => [qw/name/]);\n        my $host_comments_filter = [{ host_name => ''}]; # add useless filter, so the -or will not match on empty hostlists\n        for my $hst (@{$hosts}) {\n            push @{$host_comments_filter}, { host_name => $hst->{'name'}};\n        }\n        push @{$generalfilter},  Thruk::Utils::combine_filter( '-or', $host_comments_filter );\n    }\n\n    if($servicefilter && ($source eq 'services' || $source eq 'both')) {\n        my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ], columns => [qw/host_name description/]);\n        my $svc_comments_filter = [{ host_name => ''}]; # add useless filter, so the -or will not match on empty servicelists\n        for my $svc (@{$services}) {\n            push @{$svc_comments_filter}, [{ host_name => $svc->{'host_name'}}, { service_description => $svc->{'service_description'}}];\n        }\n        push @{$generalfilter}, Thruk::Utils::combine_filter( '-or', $svc_comments_filter );\n    }\n\n    my $types = Thruk::Base::list($c->req->parameters->{'type'});\n    my $commentfilter = [];\n    my $typesfilter   = [];\n    my $add_downtimes = 0;\n    my $add_comments  = 0;\n    for my $t (@{$types}) {\n        if(   $t eq 'comment')  { $add_comments  = 1; push @{$typesfilter}, { entry_type => 1 }; }\n        elsif($t eq 'flap')     { $add_comments  = 1; push @{$typesfilter}, { entry_type => 3 }; }\n        elsif($t eq 'ack')      { $add_comments  = 1; push @{$typesfilter}, { entry_type => 4 }; }\n        elsif($t eq 'downtime') { $add_downtimes = 1; }\n    }\n    push @{$commentfilter}, Thruk::Utils::combine_filter( '-or', $typesfilter );\n\n    my $data = [];\n    if($add_comments) {\n        $data = $c->db->get_comments(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'comments'), $generalfilter, $commentfilter ]);\n        # move some fields to match downtimes\n        for my $d (@{$data}) {\n            $d->{'start_time'} = $d->{'entry_time'};\n            $d->{'end_time'}   = -1;\n        }\n    }\n\n    if($add_downtimes) {\n        my $downtimes = $c->db->get_downtimes(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'downtimes'), $generalfilter ]);\n        for my $d (@{$downtimes}) {\n            $d->{'entry_type'} = 2;\n        }\n        push @{$data}, @{$downtimes};\n    }\n\n    my $include = $c->req->parameters->{'pattern'};\n    if($include) {\n        my $filtered = [];\n        for my $d (@{$data}) {\n            ## no critic\n            if($d->{'author'} =~ m/$include/ || $d->{'comment'} =~ m/$include/) {\n                push @{$filtered}, $d;\n            }\n            ## use critic\n        }\n        $data = $filtered;\n    }\n\n    my $exclude = $c->req->parameters->{'exclude'};\n    if($exclude) {\n        my $filtered = [];\n        for my $d (@{$data}) {\n            ## no critic\n            if($d->{'author'} !~ m/$exclude/ && $d->{'comment'} !~ m/$exclude/) {\n                push @{$filtered}, $d;\n            }\n            ## use critic\n        }\n        $data = $filtered;\n    }\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'pageSize'};\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'currentPage'};\n    $data = [sort { $a->{'host_name'} cmp $b->{'host_name'} || $a->{'service_description'} cmp $b->{'service_description'} } @{$data}];\n    Thruk::Utils::page_data($c, $data);\n    my $json = {\n        columns => [\n            { 'header' => 'Hostname',               width => 120, dataIndex => 'host_name',           renderer => 'TP.render_service_host' },\n            { 'header' => 'Service',                width => 120, dataIndex => 'service_description', renderer => 'TP.render_clickable_service' },\n            { 'header' => 'Type',                   width => 120, dataIndex => 'entry_type',          renderer => 'TP.render_entry_type'    },\n            { 'header' => 'Start Time',             width => 120, dataIndex => 'start_time',          align => 'right', renderer => 'TP.render_date' },\n            { 'header' => 'End Time',               width => 120, dataIndex => 'end_time',            align => 'right', renderer => 'TP.render_date' },\n            { 'header' => 'Entry Time',             width => 120, dataIndex => 'entry_time',          hidden => Cpanel::JSON::XS::true, align => 'right', renderer => 'TP.render_date' },\n            { 'header' => 'Author',                 width => 100, dataIndex => 'author',              },\n            { 'header' => 'Comment',                flex  => 1,   dataIndex => 'comment',             },\n            { 'header' => 'ID',                                   dataIndex => 'id',                  hidden => Cpanel::JSON::XS::true },\n        ],\n        data        => $c->stash->{'data'},\n        totalCount  => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_pnp_graphs {\n    my($c) = @_;\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    my $search  = $c->req->parameters->{'query'};\n    my $graphs  = [];\n    my $current;\n\n    my $data = _fetch_graph_hosts($c, $search, $c->config->{'pnp_url_regex'});\n    for my $hst (@{$data}) {\n        my $text = $hst->{'name'}.';_HOST_';\n        next if($search and $text !~ m/$search/mxi);\n        my $url = Thruk::Utils::get_pnp_url($c, $hst, 1);\n        if($url ne '') {\n            push @{$graphs}, {\n                text => $text,\n                url  => $url.'/image?host='.$hst->{'name'}.'&srv=_HOST_',\n            };\n        }\n    }\n\n    $data = _fetch_graph_services($c, $search, $c->config->{'pnp_url_regex'});\n    for my $svc (@{$data}) {\n        my $text = $svc->{'host_name'}.';'.$svc->{'description'};\n        next if($search and $text !~ m/$search/mxi);\n        my $url = Thruk::Utils::get_pnp_url($c, $svc, 1);\n        if($url ne '') {\n            push @{$graphs}, {\n                text => $text,\n                url  => $url.'/image?host='.$svc->{'host_name'}.'&srv='.$svc->{'description'},\n            };\n        }\n    }\n    $graphs = Thruk::Backend::Manager::sort_result({}, $graphs, 'text');\n    Thruk::Utils::page_data($c, $graphs);\n\n    # make sure current graph is always part of the result\n    push @{$c->stash->{'data'}}, $current if $current;\n\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_grafana_graphs {\n    my($c) = @_;\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    my $search  = $c->req->parameters->{'query'};\n    my $search2 = $c->req->parameters->{'query2'}; # current selected graph should always be returned, otherwise text/alias replacement does not work on paging\n    my $graphs  = [];\n    my $current;\n\n    my $data = _fetch_graph_hosts($c, $search, $c->config->{'grafana_url_regex'});\n    for my $hst (@{$data}) {\n        my $url = Thruk::Utils::get_histou_url($c, $hst, 1);\n        if($url ne '') {\n            my $text   = $hst->{'name'}.';';\n            my $exturl = 'extinfo.cgi?type=grafana&host='.$hst->{'name'};\n            if($search2 && $exturl eq $search2) {\n                $current = {\n                    text       => $text,\n                    url        => $exturl,\n                    source_url => $url,\n                };\n            }\n            next if($search && $text !~ m/$search/mxi && $exturl ne $search);\n            push @{$graphs}, {\n                text       => $text,\n                url        => $exturl,\n                source_url => $url,\n            };\n        }\n    }\n\n    $data = _fetch_graph_services($c, $search, $c->config->{'grafana_url_regex'});\n    for my $svc (@{$data}) {\n        my $url = Thruk::Utils::get_histou_url($c, $svc, 1);\n        if($url ne '') {\n            my $text   = $svc->{'host_name'}.';'.$svc->{'description'};\n            my $exturl = 'extinfo.cgi?type=grafana&host='.$svc->{'host_name'}.'&service='.$svc->{'description'};\n            if($search2 && $exturl eq $search2) {\n                $current = {\n                    text       => $text,\n                    url        => $exturl,\n                    source_url => $url,\n                };\n            }\n            next if($search && $text !~ m/$search/mxi && $exturl ne $search);\n            push @{$graphs}, {\n                text       => $text,\n                url        => $exturl,\n                source_url => $url,\n            };\n        }\n    }\n    $graphs = Thruk::Backend::Manager::sort_result({}, $graphs, 'text');\n    Thruk::Utils::page_data($c, $graphs);\n\n    # make sure current graph is always part of the result\n    push @{$c->stash->{'data'}}, $current if $current;\n\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _fetch_graph_hosts {\n    my($c, $search, $url_regex) = @_;\n    my $data = [];\n\n    my $graphfilter = { '-or' => [\n        { action_url_expanded => { '~~' => $url_regex } },\n        { notes_url_expanded  => { '~~' => $url_regex } },\n    ]};\n    my($hostfilter, $servicefilter) = split(/;/mx, ($search//''), 2);\n    my $filter = [];\n    if($hostfilter) {\n        push @{$filter}, { name => { '~~' => $hostfilter } };\n    }\n    if(!$servicefilter || '_HOST_' =~ m/$servicefilter/mxi) {\n        $data = $c->db->get_hosts(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $graphfilter, $filter ],\n                                  columns => [qw/name action_url_expanded notes_url_expanded/],\n                                  limit   => 1000, # avoid timeouts and unresponsive js\n                                 );\n    }\n    return($data);\n}\n\n##########################################################\nsub _fetch_graph_services {\n    my($c, $search, $url_regex) = @_;\n    my $data = [];\n\n    my $graphfilter = { '-or' => [\n        { action_url_expanded => { '~~' => $url_regex } },\n        { notes_url_expanded  => { '~~' => $url_regex } },\n    ]};\n    my($hostfilter, $servicefilter) = split(/;/mx, ($search//''), 2);\n    my $filter = [];\n    if($hostfilter) {\n        push @{$filter}, { host_name => { '~~' => $hostfilter } };\n    }\n    if($servicefilter) {\n        push @{$filter}, { description => { '~~' => $servicefilter } };\n    }\n    $data = $c->db->get_services(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $graphfilter, $filter ],\n                                 columns => [qw/host_name description action_url_expanded notes_url_expanded/],\n                                 limit   => 1000, # avoid timeouts and unresponsive js\n                                );\n    return($data);\n}\n\n##########################################################\nsub _task_userdata_backgroundimages {\n    my($c) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/backgrounds/';\n    my $query  = $c->req->parameters->{'query'};\n    my $images = [];\n    my $files = Thruk::Utils::IO::find_files($folder, '\\.(png|gif|jpg|jpeg|svg)$') || [];\n    for my $img (@{$files}) {\n        my $path = $img;\n        $path    =~ s/^\\Q$folder\\E//gmx;\n        next if $query and $path !~ m/\\Q$query\\E/mx;\n        my $name = $path;\n        $name    =~ s/^.*\\///gmx;\n        push @{$images}, {\n            path  => '../usercontent/backgrounds/'.$path,\n            image => $path,\n        };\n    }\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    $images = Thruk::Backend::Manager::sort_result({}, $images, 'path');\n    if(!$query) {\n        unshift @{$images}, { path => $c->stash->{'url_prefix'}.'plugins/panorama/images/s2.gif', image => '&lt;upload new image&gt;'};\n        unshift @{$images}, { path => $c->stash->{'url_prefix'}.'plugins/panorama/images/s.gif',  image => 'none'};\n    }\n    Thruk::Utils::page_data($c, $images);\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_images {\n    my($c) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/images/';\n    my $query  = $c->req->parameters->{'query'};\n    my $images = [];\n    my $files = Thruk::Utils::IO::find_files($folder, '\\.(png|gif|jpg|jpeg|svg)$') || [];\n    for my $img (@{$files}) {\n        my $path = $img;\n        $path    =~ s/^\\Q$folder\\E//gmx;\n        next if $query and $path !~ m/\\Q$query\\E/mx;\n        my $name = $path;\n        $name    =~ s/^.*\\///gmx;\n        push @{$images}, {\n            path  => '../usercontent/images/'.$path,\n            image => $path,\n        };\n    }\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    $images = Thruk::Backend::Manager::sort_result({}, $images, 'path');\n    if(!$query) {\n        unshift @{$images}, { path => $c->stash->{'url_prefix'}.'plugins/panorama/images/s2.gif', image => '&lt;upload new image&gt;'};\n    }\n    Thruk::Utils::page_data($c, $images);\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_iconsets {\n    my($c, $return_only) = @_;\n    my $folder  = $c->stash->{'usercontent_folder'}.'/images/status';\n    my $folders = [];\n    for my $f (glob(\"$folder/*/.\")) {\n        my $name = $f;\n        $name    =~ s/^\\Q$folder\\E//gmx;\n        $name    =~ s/^\\///gmx;\n        $name    =~ s/\\/\\.$//gmx;\n        my $fileset = {};\n        for my $pic (glob(\"$folder/$name/*.gif $folder/$name/*.jpg $folder/$name/*.png $folder/$name/*.svg\")) {\n            $pic =~ s|\\Q$folder/$name/\\E||gmx;\n            my $type = $pic;\n            $type =~ s/\\.(png|gif|jpg|svg)$//gmx;\n            $fileset->{$type} = $pic;\n        }\n        $fileset->{'ok'} = '' unless $fileset->{'ok'};\n        push @{$folders}, { name => $name, 'sample' => \"../usercontent/images/status/\".$name.\"/\".$fileset->{'ok'}, value => $name, fileset => $fileset };\n    }\n    $folders = Thruk::Backend::Manager::sort_result({}, $folders, 'name');\n    if($c->req->parameters->{'withempty'}) {\n        unshift @{$folders}, { name => 'use dashboards default iconset', 'sample' => $c->stash->{'url_prefix'}.'plugins/panorama/images/s.gif', value => '' };\n    }\n    return $folders if $return_only;\n    my $json = { data => $folders };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_trendiconsets {\n    my($c, $return_only) = @_;\n    my $folder  = $c->stash->{'usercontent_folder'}.'/images/trend';\n    my $folders = [];\n    for my $f (glob(\"$folder/*/.\")) {\n        my $name = $f;\n        $name    =~ s/^\\Q$folder\\E//gmx;\n        $name    =~ s/^\\///gmx;\n        $name    =~ s/\\/\\.$//gmx;\n        my $fileset = {};\n        for my $pic (glob(\"$folder/$name/*.gif $folder/$name/*.jpg $folder/$name/*.png  $folder/$name/*.svg\")) {\n            $pic =~ s|\\Q$folder/$name/\\E||gmx;\n            my $type = $pic;\n            $type =~ s/\\.(png|gif|jpg|svg)$//gmx;\n            $fileset->{$type} = $pic;\n        }\n        $fileset->{'good'} = '' unless $fileset->{'good'};\n        push @{$folders}, { name => $name, 'sample' => \"../usercontent/images/trend/\".$name.\"/\".$fileset->{'good'}, value => $name, fileset => $fileset };\n    }\n    $folders = Thruk::Backend::Manager::sort_result({}, $folders, 'name');\n    return $folders if $return_only;\n    my $json = { data => $folders };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_sounds {\n    my($c) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/sounds/';\n    my $sounds = [];\n    for my $file (glob(\"$folder/*.ogg $folder/*/*.ogg $folder/*.mp3 $folder/*/*.mp3\")) {\n        my $path = $file;\n        $path    =~ s/^\\Q$folder\\E//gmx;\n        my $name = $path;\n        $name    =~ s/^.*\\///gmx;\n        push @{$sounds}, {\n            path  => '../usercontent/sounds'.$path,\n            name  => $name,\n        };\n    }\n    $sounds = Thruk::Backend::Manager::sort_result({}, $sounds, 'name');\n    unshift @{$sounds}, { path => '', name => 'none'};\n    my $json = { data => $sounds };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_shapes {\n    my($c, $return_only) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/shapes/';\n    my $shapes = [];\n    for my $file (glob(\"$folder/*.js $folder/*/*.js $folder/*.shape $folder/*/*.shape\")) {\n        my $name = $file;\n        $name    =~ s/^\\Q$folder\\E//gmx;\n        $name    =~ s/^.*\\///gmx;\n        $name    =~ s/\\.js$//gmx;\n        $name    =~ s/\\.shape$//gmx;\n        push @{$shapes}, {\n            name  => $name,\n            data  => Thruk::Utils::IO::read($file),\n        };\n    }\n    $shapes = Thruk::Backend::Manager::sort_result({}, $shapes, 'name');\n    return $shapes if $return_only;\n    my $json = { data => $shapes };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_host_list {\n    my($c) = @_;\n\n    my $hosts = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts')], columns => [qw/name/]);\n    my $data = [];\n    for my $hst (@{$hosts}) {\n        push @{$data}, { name => $hst->{'name'} };\n    }\n\n    $data = Thruk::Backend::Manager::sort_result({}, $data, 'name');\n    my $json = { data => $data };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_host_detail {\n    my($c) = @_;\n\n    my $host        = $c->req->parameters->{'host'}    || '';\n    my $json      = {};\n    my $hosts     = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), { name => $host }], extra_columns => [qw/long_plugin_output/]);\n    my $downtimes = $c->db->get_downtimes(\n        filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'downtimes' ), { 'host_name' => $host }, { 'service_description' => '' } ],\n        sort => { 'DESC' => 'id' },\n    );\n    if(defined $hosts and scalar @{$hosts} > 0) {\n        if($c->stash->{'escape_html_tags'}) {\n            _escape($hosts->[0]);\n        }\n        my $cust_vars = Thruk::Utils::get_custom_vars($c, $hosts->[0]);\n        $json = { data => $hosts->[0], downtimes => $downtimes, action_menu => $cust_vars->{'THRUK_ACTION_MENU'} };\n    }\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_service_list {\n    my($c) = @_;\n\n    my $host     = $c->req->parameters->{'host'} || '';\n    my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), { host_name => $host }], columns => [qw/description/]);\n    my $data = [];\n    for my $svc (@{$services}) {\n        push @{$data}, { description => $svc->{'description'} };\n    }\n\n    $data = Thruk::Backend::Manager::sort_result({}, $data, 'description');\n    my $json = { data => $data };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_service_detail {\n    my($c) = @_;\n\n    my $host        = $c->req->parameters->{'host'}    || '';\n    my $description = $c->req->parameters->{'service'} || '';\n    my $json        = {};\n    my $services    = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), { host_name => $host, description => $description }], extra_columns => [qw/long_plugin_output/]);\n    my $downtimes = $c->db->get_downtimes(\n        filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'downtimes' ), { 'host_name' => $host }, { 'service_description' => $description } ],\n        sort => { 'DESC' => 'id' },\n    );\n    if(defined $services and scalar @{$services} > 0) {\n        if($c->stash->{'escape_html_tags'}) {\n            _escape($services->[0]);\n        }\n        my $cust_vars = Thruk::Utils::get_custom_vars($c, $services->[0]);\n        $json = { data => $services->[0], downtimes => $downtimes, action_menu => $cust_vars->{'THRUK_ACTION_MENU'} };\n    }\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_save_states {\n    my($c) = @_;\n\n    my $nr        = $c->req->parameters->{'nr'} || die('no number supplied');\n       $nr        =~ s/^pantab_//gmx;\n    my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $states;\n    eval {\n        $states = decode_json($c->req->parameters->{'states'});\n    };\n    if($@) {\n        _warn('_task_dashboard_save_states failed: '.$@);\n        return;\n    }\n\n    Thruk::Utils::Panorama::save_runtime_file($c, $dashboard, $states);\n\n    my $json = { 'status' => 'ok' };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_data {\n    my($c) = @_;\n    my $nr = $c->req->parameters->{'nr'} || die('no number supplied');\n    $nr = Thruk::Base::array_uniq(Thruk::Base::list($nr));\n\n    my $open_tabs_hash = Thruk::Base::array2hash(Thruk::Base::list($c->req->parameters->{'recursive'}));\n    if(scalar @{$nr} > 1) {\n        my $json;\n        my $data = {};\n        for my $n (@{$nr}) {\n            _add_initial_dashboard($c, $n, $data, undef, $open_tabs_hash);\n        }\n        return $c->render(json => { data => $data });\n    }\n    $nr = $nr->[0];\n\n    my $dashboard;\n    my $new_override = 0;\n    if($nr eq 'new_or_empty' || $nr eq 'first_or_new') {\n        # avoid too many empty dashboards, so return the first existing empty dashboard for this user\n        my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, 'my');\n        for my $d (@{$dashboards}) {\n            if($nr eq 'first_or_new' || $d->{'objects'} == 0) {\n                $nr = $d->{'nr'};\n                $new_override = 1;\n                last;\n            }\n        }\n        $nr = 'new' if $nr eq 'first_or_new';\n        $nr = 'new' if $nr eq 'new_or_empty';\n    }\n\n    if($nr eq 'new') {\n        return if $c->stash->{'readonly'};\n        $dashboard = {\n            tab     => {\n                xdata => _get_default_tab_xdata($c),\n            },\n            id      => 'new',\n        };\n        $dashboard = Thruk::Utils::Panorama::save_dashboard($c, $dashboard);\n    } else {\n        $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n    }\n    my $json;\n    if(!$dashboard) {\n        if(!$c->req->parameters->{'hidden'}) {\n            Thruk::Utils::set_message( $c, { style => 'fail_message', msg => 'no such dashboard' });\n        }\n        $c->res->code(404);\n        $json = { 'status' => 'failed' };\n    } else {\n        my $data = {};\n        _merge_dashboard_into_hash($c, $dashboard, $data);\n        _add_recursive_dashboards($c, $dashboard, $data, undef, $open_tabs_hash);\n        if($nr eq 'new' || $new_override) {\n            $data->{'newid'} = $dashboard->{'id'};\n        }\n        $json = { data => $data };\n    }\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _get_dashboard_by_name {\n    my($c, $name) = @_;\n    return unless $name;\n\n    for my $file (glob($c->{'panorama_etc'}.'/*.tab')) {\n        if($file =~ s/^.*\\/([a-zA-Z_\\-\\d]+)\\.tab$//mx) {\n            my $d = Thruk::Utils::Panorama::load_dashboard($c, $1, 1);\n            if($d) {\n                if(  ($d->{'tab'}->{'xdata'}->{'title'} && $d->{'tab'}->{'xdata'}->{'title'} eq $name)\n                   || $d->{'nr'} eq $name) {\n                    return($d);\n                }\n            }\n        }\n    }\n    return;\n}\n\n##########################################################\nsub _task_dashboard_list {\n    my($c) = @_;\n\n    my $type       = $c->req->parameters->{'list'} || 'my';\n    my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, $type);\n\n    my $columns = [\n        { 'header' => 'Id',                        dataIndex => 'id',                              hidden => Cpanel::JSON::XS::true },\n        { 'header' => 'Nr',          width => 60,  dataIndex => 'nr', align => 'left' },\n        { 'header' => '',            width => 20,  dataIndex => 'visible',      align => 'left', tdCls => 'icon_column', renderer => 'TP.render_dashboard_toggle_visible' },\n        { 'header' => 'Name',        width => 130, dataIndex => 'name',         align => 'left', editor => {}, tdCls => 'editable'   },\n        { 'header' => 'Description', flex  => 1,   dataIndex => 'description',  align => 'left', editor => {}, tdCls => 'editable'   },\n        { 'header' => 'Owner',        width => 130, dataIndex => 'user',        align => 'center',\n                                        editor => $c->stash->{'is_admin'} ? {} : undef,\n                                        hidden => $type eq 'my' ? Cpanel::JSON::XS::true : Cpanel::JSON::XS::false,\n                                        tdCls => $c->stash->{'is_admin'} ? 'editable' : '',\n        },\n        { 'header' => 'Read-Write Permissions',  width => 135, dataIndex => 'perm_rw',    align => 'left' },\n        { 'header' => 'Read-Only Permissions',   width => 135, dataIndex => 'perm_ro',    align => 'left' },\n        { 'header' => 'Direct Link',        width =>  65, dataIndex => 'link',         align => 'center', renderer => 'TP.render_directlink' },\n        { 'header' => 'Objects',     width => 55,  dataIndex => 'objects',      align => 'center' },\n        { 'header' => 'Last Time Used',     width => 130,  dataIndex => 'last_used',   align => 'center', renderer => 'TP.render_date_only' },\n        { 'header' => 'Readonly',    width => 60,  dataIndex => 'readonly',     align => 'center', renderer => 'TP.render_yes_no' },\n        { 'header' => 'Actions',     width => 60,\n                    xtype => 'actioncolumn',\n                    items => [{\n                        icon => '../plugins/panorama/images/edit.png',\n                        handler => 'TP.dashboardActionHandler',\n                        action  => 'edit',\n                    }, {\n                        icon => '../plugins/panorama/images/delete.png',\n                        handler => 'TP.dashboardActionHandler',\n                        action  => 'remove',\n                    }],\n                    tdCls => 'clickable icon_column',\n        },\n    ];\n\n    my $search = $c->req->parameters->{'query'};\n    if($search) {\n        my $filtered = [];\n        for my $d (@{$dashboards}) {\n            next unless $d->{'name'} =~ m/$search/mxi;\n            push @{$filtered}, $d;\n        }\n        $dashboards = $filtered;\n    }\n\n    # add last_used data\n    for my $d (@{$dashboards}) {\n        $d->{'last_used'} = 0;\n        for my $file (glob($c->config->{'var_path'}.'/panorama/'.$d->{'nr'}.'.tab.*runtime')) {\n            my @stat = stat($file);\n            $d->{'last_used'} = $stat[9] if $d->{'last_used'} < $stat[9];\n        }\n    }\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} // 'all';\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    Thruk::Utils::page_data($c, $dashboards);\n    my $json = {\n        columns     => $columns,\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_update {\n    my($c) = @_;\n\n    my $json   = { 'status' => 'failed' };\n    my $nr     = $c->req->parameters->{'nr'};\n    my $action = $c->req->parameters->{'action'};\n    my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    if($action && $dashboard && !$dashboard->{'readonly'}) {\n        $json = { 'status' => 'ok' };\n        if($action eq 'remove') {\n            Thruk::Utils::Panorama::delete_dashboard($c, $nr, $dashboard);\n        }\n        if($action eq 'update') {\n            my $extra_settings = {};\n            my $field = $c->req->parameters->{'field'};\n            my $value = $c->req->parameters->{'value'};\n            if($field eq 'description') {\n                $extra_settings->{$field} = $value;\n            }\n            elsif($field eq 'name') {\n                $dashboard->{'tab'}->{'xdata'}->{'title'} = $value;\n            }\n            elsif($field eq 'user' and $c->stash->{'is_admin'}) {\n                $extra_settings->{$field} = $value;\n            }\n            Thruk::Utils::Panorama::save_dashboard($c, $dashboard, $extra_settings);\n        }\n    }\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_restore_list {\n    my($c) = @_;\n\n    my $nr         = $c->req->parameters->{'nr'};\n    my $dashboard  = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $permission = Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $dashboard);\n    my $json;\n    if($permission >= ACCESS_READWRITE && !$dashboard->{'scripted'}) {\n        my $list = {\n            a => [],\n            m => [],\n        };\n        $nr       =~ s/^pantab_//gmx;\n        my @files = reverse sort glob($c->{'panorama_var'}.'/'.$nr.'.tab.*');\n        for my $file (@files) {\n            next if $file =~ m/\\.runtime$/mx;\n            if($file =~ m/\\.(\\d+)\\.(\\w)$/mx) {\n                my $date = $1;\n                my $mode = $2;\n                push(@{$list->{$mode}}, { num => $date });\n            } else {\n                die(\"wrong file name format in $file\");\n            }\n        }\n        $json = { data => $list };\n    }\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_restore_point {\n    my($c) = @_;\n\n    my $nr         = $c->req->parameters->{'nr'};\n       $nr         =~ s/^pantab_//gmx;\n    my $mode       = $c->req->parameters->{'mode'} || 'm';\n    my $dashboard  = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $permission = Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $dashboard);\n    my $etc_file   = $c->{'panorama_etc'}.'/'.$nr.'.tab';\n    my $var_file   = $c->{'panorama_var'}.'/'.$nr.'.tab';\n    if($permission >= ACCESS_READWRITE && !$dashboard->{'scripted'}) {\n        if(!$mode || $mode eq 'm') {\n            Thruk::Utils::backup_data_file($etc_file, $var_file, 'm', 5, 0, 1);\n        } else {\n            Thruk::Utils::backup_data_file($etc_file, $var_file, 'a', 5, 600, 1);\n        }\n    }\n\n    my $json = { msg => \"ok\" };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_restore {\n    my($c) = @_;\n\n    my $nr         = $c->req->parameters->{'nr'};\n       $nr         =~ s/^pantab_//gmx;\n    my $mode       = $c->req->parameters->{'mode'};\n    my $timestamp  = $c->req->parameters->{'timestamp'};\n    my $dashboard  = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $permission = Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $dashboard);\n    if($permission >= ACCESS_READWRITE && !$dashboard->{'scripted'}) {\n        die(\"no such dashboard\") unless -e $c->{'panorama_etc'}.'/'.$nr.'.tab';\n        die(\"no such restore point\") unless -e $c->{'panorama_var'}.'/'.$nr.'.tab.'.$timestamp.\".\".$mode;\n        unlink($c->{'panorama_etc'}.'/'.$nr.'.tab');\n        copy($c->{'panorama_var'}.'/'.$nr.'.tab.'.$timestamp.\".\".$mode, $c->{'panorama_etc'}.'/'.$nr.'.tab');\n    }\n    my $json = {};\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboards_clean {\n    my($c) = @_;\n\n    die(\"no admin permissions\") unless $c->stash->{'is_admin'};\n    my $json = { num => Thruk::Utils::Panorama::clean_old_dashboards($c) };\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _get_gearman_stats {\n    my($c) = @_;\n\n    my $data = {};\n    my $host = 'localhost';\n    my $port = 4730;\n\n    if(defined $c->req->parameters->{'server'}) {\n        ($host,$port) = split(/:/mx, $c->req->parameters->{'server'}, 2);\n    }\n\n    load IO::Socket;\n    my $handle = IO::Socket::INET->new(\n        Proto    => \"tcp\",\n        PeerAddr => $host,\n        PeerPort => $port,\n    )\n    or do {\n        _warn(\"can't connect to port $port on $host: $!\") unless(Thruk::Base->mode eq 'TEST');\n        return $data;\n    };\n    $handle->autoflush(1);\n\n    print $handle \"status\\n\";\n\n    while ( defined( my $line = <$handle> ) ) {\n        chomp($line);\n        my($name,$total,$running,$worker) = split(/\\t/mx, $line);\n        next if $name eq 'dummy';\n        if(defined $worker) {\n            my $stat = {\n                'name'      => $name,\n                'worker'    => int($worker),\n                'running'   => int($running),\n                'waiting'   => int($total - $running),\n            };\n            $data->{$name} = $stat;\n        }\n        last if $line eq '.';\n    }\n    CORE::close($handle);\n\n    return $data;\n}\n\n##########################################################\n# convert json filter to perl object and do filtering\nsub _do_filter {\n    my($c) = @_;\n\n    # reset existing filter\n    Thruk::Utils::Status::reset_filter($c);\n\n    if(!defined $c->req->parameters->{'filter'} || $c->req->parameters->{'filter'} eq '') {\n        my @f = Thruk::Utils::Status::do_filter($c, undef, undef, 1);\n        return @f;\n    }\n\n    my $filter;\n    eval {\n        $filter = decode_json($c->req->parameters->{'filter'});\n    };\n    if($@) {\n        _warn('filter failed: '.$@);\n        return;\n    }\n\n    if(ref $filter eq 'HASH') {\n        $filter = [$filter];\n    }\n\n    my $nr = 0;\n    for my $f (@{$filter}) {\n        my $pre = 'dfl_s'.$nr.'_';\n        for my $key (qw/hostprops hoststatustypes serviceprops servicestatustypes/) {\n            $c->req->parameters->{$pre.$key} = $f->{$key};\n        }\n        for my $type (qw/op type value value_date val_pre/) {\n            if(ref $f->{$type} ne 'ARRAY') { $f->{$type} = [$f->{$type}]; }\n        }\n\n        for my $type (qw/op type value val_pre/) {\n            my $x = 0;\n            for my $val (@{$f->{$type}}) {\n                $c->req->parameters->{$pre.$type} = [] unless defined $c->req->parameters->{$pre.$type};\n                if($type eq 'value') {\n                    if(!defined $val) { $val = ''; }\n                    if($f->{'type'}->[$x] eq 'last check' or $f->{'type'}->[$x] eq 'next check') {\n                        $val = $f->{'value_date'}->[$x];\n                        $val =~ s/T/ /gmx;\n                    }\n                }\n                elsif($type eq 'type') {\n                    $val = lc($val || '');\n                }\n                elsif($type eq 'val_pre') {\n                    if(!defined $val) { $val = ''; }\n                }\n\n                push @{$c->req->parameters->{$pre.$type}}, $val;\n                $x++;\n            }\n        }\n        $nr++;\n    }\n\n    my @f = Thruk::Utils::Status::do_filter($c, undef, undef, 1);\n    return @f;\n}\n\n##########################################################\nsub _generate_service_popup {\n    my ($c, $service) = @_;\n    return ' title=\"'.Thruk::Utils::Filter::escape_quotes($service->{'plugin_output'}).'\" onclick=\"TP.add_panlet({type:\\'TP.PanletService\\', conf: { xdata: { host: \\''.Thruk::Utils::Filter::escape_bslash($service->{'host_name'}).'\\', service: \\''.Thruk::Utils::Filter::escape_bslash($service->{'description'}).'\\', }}})\"';\n}\n\n##########################################################\nsub _escape {\n    my($o) = @_;\n    $o->{'plugin_output'}      = Thruk::Utils::Filter::escape_quotes(Thruk::Utils::Filter::escape_html($o->{'plugin_output'}));\n    $o->{'long_plugin_output'} = Thruk::Utils::Filter::escape_quotes(Thruk::Utils::Filter::escape_html($o->{'long_plugin_output'}));\n    return $o;\n}\n\n##########################################################\nsub _long_plugin {\n    my($o) = @_;\n    if($o->{'long_plugin_output'}) {\n        $o->{'plugin_output'}      = $o->{'plugin_output'}.'<br>'.$o->{'long_plugin_output'};\n        $o->{'long_plugin_output'} = '';\n    }\n    return $o;\n}\n\n##########################################################\nsub _summarize_hostgroup_query {\n    my($c, $type_groups, $state_type) = @_;\n\n    my $filter = Thruk::Utils::combine_filter('-or', [map {{ name => { '=' => $_ }}} keys %{$type_groups}]);\n    my $details = $c->db->get_hostgroups(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hostgroups'), $filter ], columns => [qw/name alias/]);\n    $details = Thruk::Base::array2hash($details, 'name');\n\n    $filter = Thruk::Utils::combine_filter('-or', [map {{ groups => { '>=' => $_ }}} keys %{$type_groups}]);\n    my $hosts = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $filter ], columns => [qw/name groups state state_type last_state_change acknowledged scheduled_downtime_depth has_been_checked/]);\n    my $hostgroups = {};\n    for my $hst (@{$hosts}) {\n        for my $grp (@{$hst->{'groups'}}) {\n            next unless defined $type_groups->{$grp};\n            if(!defined $hostgroups->{$grp}) {\n                $hostgroups->{$grp} = { services => { ok => 0, warning => 0, critical => 0, unknown => 0, pending => 0,\n                                                      plain_ok => 0, plain_warning => 0, plain_critical => 0, plain_unknown => 0, plain_pending => 0,\n                                                      ack_warning => 0, ack_critical => 0, ack_unknown => 0,\n                                                      downtime_ok => 0, downtime_warning => 0, downtime_critical => 0, downtime_unknown => 0,\n                                                    },\n                                        hosts    => { up => 0, down => 0, unreachable => 0, pending => 0,\n                                                      plain_up => 0, plain_down => 0, plain_unreachable => 0, plain_pending => 0,\n                                                      ack_down => 0, ack_unreachable => 0,\n                                                      downtime_up => 0, downtime_down => 0, downtime_unreachable => 0,\n                                                    },\n                                        name     => $grp,\n                                        alias    => $details->{$grp}->{'alias'} // '',\n                                      };\n            }\n            if($state_type == HARD_STATE && $hst->{'state_type'} != HARD_STATE) {\n                $hostgroups->{$grp}->{'hosts'}->{'up'}++;\n                if($hst->{'scheduled_downtime_depth'}) {\n                    $hostgroups->{$grp}->{'hosts'}->{'downtime_up'}++;\n                } else {\n                    $hostgroups->{$grp}->{'hosts'}->{'plain_up'}++;\n                }\n                next;\n            }\n            if($hst->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'hosts'}->{'pending'}++;     }\n            elsif($hst->{'state'} == 0)         { $hostgroups->{$grp}->{'hosts'}->{'up'}++;          }\n            elsif($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'down'}++;        }\n            elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'unreachable'}++; }\n            if($hst->{'acknowledged'}) {\n                   if($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'ack_down'}++;        }\n                elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'ack_unreachable'}++; }\n            }\n            if($hst->{'scheduled_downtime_depth'}) {\n                   if($hst->{'state'} == 0)         { $hostgroups->{$grp}->{'hosts'}->{'downtime_up'}++;          }\n                elsif($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'downtime_down'}++;        }\n                elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'downtime_unreachable'}++; }\n            }\n            if(!$hst->{'acknowledged'} && !$hst->{'scheduled_downtime_depth'}) {\n                if($hst->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'hosts'}->{'plain_pending'}++;     }\n                elsif($hst->{'state'} == 0)         { $hostgroups->{$grp}->{'hosts'}->{'plain_up'}++;          }\n                elsif($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'plain_down'}++;        }\n                elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'plain_unreachable'}++; }\n            }\n        }\n    }\n    $filter      = Thruk::Utils::combine_filter('-or', [map {{ host_groups => { '>=' => $_ }}} keys %{$type_groups}]);\n    my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $filter ], columns => [qw/host_name description host_groups state state_type last_state_change acknowledged scheduled_downtime_depth has_been_checked/]);\n    for my $svc (@{$services}) {\n        for my $grp (@{$svc->{'host_groups'}}) {\n            next unless defined $type_groups->{$grp};\n            if($state_type == HARD_STATE && $svc->{'state_type'} != HARD_STATE) {\n                $hostgroups->{$grp}->{'services'}->{'ok'}++;\n                if($svc->{'scheduled_downtime_depth'}) {\n                   $hostgroups->{$grp}->{'services'}->{'downtime_ok'}++;\n                } else {\n                    $hostgroups->{$grp}->{'services'}->{'plain_ok'}++;\n                }\n                next;\n            }\n            if($svc->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'services'}->{'pending'}++;  }\n            elsif($svc->{'state'} == 0)         { $hostgroups->{$grp}->{'services'}->{'ok'}++;       }\n            elsif($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'warning'}++;  }\n            elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'critical'}++; }\n            elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'unknown'}++;  }\n            if($svc->{'acknowledged'}) {\n                   if($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'ack_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'ack_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'ack_unknown'}++;  }\n            }\n            if($svc->{'scheduled_downtime_depth'}) {\n                   if($svc->{'state'} == 0)         { $hostgroups->{$grp}->{'services'}->{'downtime_ok'}++;       }\n                elsif($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'downtime_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'downtime_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'downtime_unknown'}++;  }\n            }\n            if(!$svc->{'acknowledged'} && !$svc->{'scheduled_downtime_depth'}) {\n                if($svc->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'services'}->{'plain_pending'}++;  }\n                elsif($svc->{'state'} == 0)         { $hostgroups->{$grp}->{'services'}->{'plain_ok'}++;       }\n                elsif($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'plain_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'plain_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'plain_unknown'}++;  }\n            }\n        }\n    }\n    return($hostgroups);\n}\n\n##########################################################\nsub _summarize_servicegroup_query {\n    my($c, $type_groups, $state_type) = @_;\n\n    my $filter = Thruk::Utils::combine_filter('-or', [map {{ name => { '=' => $_ }}} keys %{$type_groups}]);\n    my $details = $c->db->get_servicegroups(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'servicegroups'), $filter ], columns => [qw/name alias/]);\n    $details = Thruk::Base::array2hash($details, 'name');\n\n    $filter = Thruk::Utils::combine_filter('-or', [map {{ groups => { '>=' => $_ }}} keys %{$type_groups}]);\n    my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $filter ], columns => [qw/host_name description groups state state_type last_state_change acknowledged scheduled_downtime_depth has_been_checked/]);\n    my $servicegroups = {};\n    for my $svc (@{$services}) {\n        for my $grp (@{$svc->{'groups'}}) {\n            next unless defined $type_groups->{$grp};\n            if(!defined $servicegroups->{$grp}) {\n                $servicegroups->{$grp} = { services => { ok => 0, warning => 0, critical => 0, unknown => 0, pending => 0,\n                                                         plain_ok => 0, plain_warning => 0, plain_critical => 0, plain_unknown => 0, plain_pending => 0,\n                                                         ack_warning => 0, ack_critical => 0, ack_unknown => 0,\n                                                         downtime_ok => 0, downtime_warning => 0, downtime_critical => 0, downtime_unknown => 0,\n                                                       },\n                                           name     => $grp,\n                                           alias    => $details->{$grp}->{'alias'} // '',\n                                         };\n            }\n            if($state_type == HARD_STATE && $svc->{'state_type'} != HARD_STATE) {\n                $servicegroups->{$grp}->{'services'}->{'ok'}++;\n                if($svc->{'scheduled_downtime_depth'}) {\n                    $servicegroups->{$grp}->{'services'}->{'downtime_ok'}++;\n                } else {\n                    $servicegroups->{$grp}->{'services'}->{'plain_ok'}++;\n                }\n                next;\n            }\n            if($svc->{'has_been_checked'} == 0) { $servicegroups->{$grp}->{'services'}->{'pending'}++;  }\n            elsif($svc->{'state'} == 0)         { $servicegroups->{$grp}->{'services'}->{'ok'}++;       }\n            elsif($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'warning'}++;  }\n            elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'critical'}++; }\n            elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'unknown'}++;  }\n            if($svc->{'acknowledged'}) {\n                   if($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'ack_warning'}++;    }\n                elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'ack_critical'}++;   }\n                elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'ack_unknown'}++;    }\n            }\n            if($svc->{'scheduled_downtime_depth'}) {\n                   if($svc->{'state'} == 0)         { $servicegroups->{$grp}->{'services'}->{'downtime_ok'}++;        }\n                elsif($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'downtime_warning'}++;   }\n                elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'downtime_critical'}++;  }\n                elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'downtime_unknown'}++;   }\n            }\n            if(!$svc->{'acknowledged'} && !$svc->{'scheduled_downtime_depth'}) {\n                if($svc->{'has_been_checked'} == 0) { $servicegroups->{$grp}->{'services'}->{'plain_pending'}++;  }\n                elsif($svc->{'state'} == 0)         { $servicegroups->{$grp}->{'services'}->{'plain_ok'}++;       }\n                elsif($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'plain_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'plain_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'plain_unknown'}++;  }\n            }\n        }\n    }\n    return($servicegroups);\n}\n\n##########################################################\nsub _summarize_query {\n    my($c, $incl_hst, $incl_svc, $hostfilter, $servicefilter, $state_type, $has_service_filter) = @_;\n    my $sum   = { services => { ok => 0, warning => 0, critical => 0, unknown => 0, pending => 0,\n                                plain_ok => 0, plain_warning => 0, plain_critical => 0, plain_unknown => 0, plain_pending => 0,\n                                ack_warning => 0, ack_critical => 0, ack_unknown => 0,\n                                downtime_ok => 0, downtime_warning => 0, downtime_critical => 0, downtime_unknown => 0,\n                              },\n                  hosts    => { up => 0, down => 0, unreachable => 0, pending => 0,\n                                plain_up => 0, plain_down => 0, plain_unreachable => 0, plain_pending => 0,\n                                ack_down => 0, ack_unreachable => 0,\n                                downtime_up => 0, downtime_down => 0, downtime_unreachable => 0,\n                              },\n                };\n\n    my $hard_states_only = $state_type == HARD_STATE;\n    if($incl_hst) {\n        my $host_sum;\n        if(!$has_service_filter) {\n            $host_sum = $c->db->get_host_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ], hard_states_only => $hard_states_only);\n        } else {\n            $host_sum = $c->db->get_host_stats_by_servicequery(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ], hard_states_only => $hard_states_only);\n        }\n        for my $k (qw/up down unreachable pending/) {\n            $sum->{'hosts'}->{$k} = $host_sum->{$k};\n            $sum->{'hosts'}->{'plain_'.$k} = $host_sum->{'plain_'.$k};\n            if($k ne 'up' and $k ne 'pending') {\n                $sum->{'hosts'}->{'ack_'.$k} = $host_sum->{$k.'_and_ack'};\n            }\n            if($k ne 'pending') {\n                $sum->{'hosts'}->{'downtime_'.$k} = $host_sum->{$k.'_and_scheduled'};\n            }\n        }\n    }\n    if($incl_svc) {\n        my $service_sum = $c->db->get_service_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ], hard_states_only => $hard_states_only);\n        for my $k (qw/ok warning critical unknown pending/) {\n            $sum->{'services'}->{$k} = $service_sum->{$k};\n            $sum->{'services'}->{'plain_'.$k} = $service_sum->{'plain_'.$k};\n            if($k ne 'ok' and $k ne 'pending') {\n                $sum->{'services'}->{'ack_'.$k} = $service_sum->{$k.'_and_ack'};\n            }\n            if($k ne 'pending') {\n                $sum->{'services'}->{'downtime_'.$k} = $service_sum->{$k.'_and_scheduled'};\n            }\n        }\n    }\n    return($sum);\n}\n\n##########################################################\nsub _merge_dashboard_into_hash {\n    my($c, $dashboard, $data) = @_;\n    return $data unless $dashboard;\n\n    my $id = $dashboard->{'id'};\n    for my $key (keys %{$dashboard}) {\n        if($key =~ m/^panlet_\\d+$/mx) {\n            $data->{$id.'_'.$key} = $dashboard->{$key};\n        }\n        elsif($key eq 'tab') {\n            # add some values to the tab\n            for my $k (qw/user public readonly ts scripted maintenance/) {\n                $dashboard->{'tab'}->{$k} = $dashboard->{$k} if defined $dashboard->{$k};\n            }\n            $data->{$id} = $dashboard->{'tab'};\n\n            # touch runtime file, since thats what we use to reflect last_used date\n            my $runtime_file = Thruk::Utils::Panorama::get_runtime_file($c, $dashboard->{'nr'});\n            Thruk::Utils::IO::touch($runtime_file);\n        }\n    }\n    return $data;\n}\n\n##########################################################\nsub _add_initial_dashboard {\n    my($c, $nr, $data, $shapes, $open_tabs) = @_;\n\n    my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n    if(!$dashboard && $data->{'tabbar'}->{'open_tabs'}) {\n        # remove orphaned or removed dashboards\n        @{$data->{'tabbar'}->{'open_tabs'}} = grep !/^\\Q$nr\\E$/mx, @{$data->{'tabbar'}->{'open_tabs'}};\n        return;\n    }\n    _merge_dashboard_into_hash($c, $dashboard, $data);\n    _add_recursive_dashboards($c, $dashboard, $data, $shapes, $open_tabs);\n    return;\n}\n\n##########################################################\nsub _add_recursive_dashboards {\n    my($c, $dashboard, $data, $shapes, $open_tabs) = @_;\n    my $add_hidden = {};\n    # add shapes data\n    for my $key (keys %{$dashboard}) {\n        if(ref $dashboard->{$key} eq 'HASH' && $dashboard->{$key}->{'xdata'} && $dashboard->{$key}->{'xdata'}->{'appearance'}) {\n            my $shape = $dashboard->{$key}->{'xdata'}->{'appearance'}->{'shapename'};\n            if(defined $shapes && $shape && !exists $shapes->{$shape}) {\n                if(-e $c->stash->{'usercontent_folder'}.'/shapes/'.$shape.'.js') {\n                    $shapes->{$shape} = Thruk::Utils::IO::read($c->stash->{'usercontent_folder'}.'/shapes/'.$shape.'.js');\n                } else {\n                    $shapes->{$shape} = undef;\n                }\n            }\n            if($dashboard->{$key}->{'xdata'}->{'cls'} eq 'TP.DashboardStatusIcon') {\n                my $sub = $dashboard->{$key}->{'xdata'}->{'general'}->{'dashboard'};\n                if(!defined $open_tabs->{$sub}) {\n                    $open_tabs->{$sub} = 1;\n                    $add_hidden->{$sub} = 1;\n                }\n            }\n        }\n    }\n    # add hidden dashboards recursivly\n    for my $key (sort keys %{$add_hidden}) {\n        _add_initial_dashboard($c, $key, $data, $shapes, $open_tabs);\n    }\n    return;\n}\n\n##########################################################\nsub _get_default_tab_xdata {\n    my($c) = @_;\n    return({\n        title           => $c->req->parameters->{'title'} || 'Dashboard',\n        refresh         => $c->config->{'refresh_rate'} || 60,\n        select_backends => 0,\n        backends        => [],\n        background      => 'none',\n        autohideheader  => 1,\n        defaulticonset  => 'default',\n        groups          => [],\n    });\n}\n\n##########################################################\nsub _add_json_dashboard_timestamps {\n    my($c, $json, $tab) = @_;\n    if(!defined $tab && $c->cookies('thruk_panorama_active')) {\n        $tab = $c->cookies('thruk_panorama_active');\n    }\n    if($tab) {\n        my $nr = $tab;\n           $nr =~ s/^pantab_//gmx;\n        $json->{'dashboard_ts'} = {};\n        my $file  = $c->{'panorama_etc'}.'/'.$nr.'.tab';\n        if($nr eq \"0\" && !-s $file) {\n            $file = $c->config->{'plugin_path'}.'/plugins-enabled/panorama/0.tab';\n        }\n        my @stat = stat($file);\n        if(-x $file) {\n            my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n            if($dashboard->{'ts'}) {\n                $json->{'dashboard_ts'}->{$tab} = $dashboard->{'ts'};\n            } else {\n                $json->{'dashboard_ts'}->{$tab} = $stat[9] if defined $stat[9];\n            }\n        } else {\n            $json->{'dashboard_ts'}->{$tab} = $stat[9] if defined $stat[9];\n        }\n        my $maintfile  = Thruk::Utils::Panorama::get_maint_file($c, $nr);\n        if(-e $maintfile) {\n            my $maintenance = Thruk::Utils::IO::json_lock_retrieve($maintfile);\n            $json->{'maintenance'}->{$tab} = $maintenance->{'maintenance'};\n        } else {\n            $json->{'maintenance'}->{$tab} = \"\";\n        }\n    }\n    return;\n}\n\n##########################################################\nsub _add_json_pi_detail {\n    my($c, $json) = @_;\n    $json->{'pi_detail'} = $c->stash->{pi_detail};\n    return;\n}\n\n##########################################################\nsub _add_misc_details {\n    my($c, $always, $json) = @_;\n    if($always || $c->req->parameters->{'update_proc'}) {\n        $c->stats->profile(begin => \"_add_misc_details\");\n        _add_json_dashboard_timestamps($c, $json, $c->req->parameters->{'current_tab'});\n        _add_json_pi_detail($c, $json);\n        $json->{'server_version'}       = $c->config->{'thrukversion'};\n        $json->{'server_extra_version'} = $c->config->{'extra_version'};\n        $json->{'broadcasts'}           = Thruk::Utils::Broadcast::get_broadcasts($c, undef, undef, 1);\n        $c->stats->profile(end => \"_add_misc_details\");\n    }\n    elsif($c->req->parameters->{'current_tab'}) {\n        _add_json_dashboard_timestamps($c, $json, $c->req->parameters->{'current_tab'});\n    }\n    return;\n}\n\n##########################################################\nsub _set_preload_images {\n    my($c) = @_;\n    my $plugin_dir = $c->config->{'plugin_path'} || $c->config->{home}.\"/plugins\";\n    my @images = glob($plugin_dir.'/plugins-enabled/panorama/root/images/*');\n    $c->stash->{preload_img} = [];\n    for my $i (@images) {\n        $i =~ s|^.*/||gmx;\n        push @{$c->stash->{preload_img}}, $i;\n    }\n    return;\n}\n\n##########################################################\nsub _get_available_fonts {\n    my($c) = @_;\n    my $fonts = [ 'Arial', 'Comic Sans MS', 'Georgia', 'Helvetica', 'Lucida Console',\n                  'Lucida Grande', 'Tahoma', 'Times', 'Times New Roman', 'Trebuchet MS',\n                  'Verdana', 'caption', 'cursive', 'fantasy', 'icon', 'menu',\n                  'message-box', 'monospace', 'sans-serif', 'serif', 'small-caption',\n    ];\n    if($c->config->{'Thruk::Plugin::Panorama'}->{'extra_fonts'}) {\n        for my $font (@{Thruk::Base::list($c->config->{'Thruk::Plugin::Panorama'}->{'extra_fonts'})}) {\n            my @extra = split/\\s*,\\s*/mx, $font;\n            push @{$fonts}, @extra;\n        }\n        @{$fonts} = sort(@{$fonts});\n    }\n    unshift @{$fonts}, 'inherit';\n    return($fonts);\n}\n\n##########################################################\nsub _check_media_permissions {\n    my($c, $file) = @_;\n    return 1 if $c->stash->{'is_admin'};\n    return 1 if $c->check_user_roles('panorama_view_media_manager');\n\n    my $folder = $c->stash->{'usercontent_folder'}.'/';\n    $file = Thruk::Utils::IO::realpath($file);\n\n    # user is allowed to change the image if he has write access to all dashboards using this image\n    my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, 'all', 1);\n    for my $d (@{$dashboards}) {\n        # we are looking for dashboards without access which use this image,so skip the dashboard we have full access to\n        next if Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $d->{'nr'}, $d) >= ACCESS_READWRITE;\n        if($d->{'tab'}->{'xdata'}->{'background'}) {\n            return if Thruk::Utils::IO::realpath($folder.$d->{'tab'}->{'xdata'}->{'background'}) eq $file;\n        }\n        for my $key (sort keys %{$d}) {\n            if(ref($d->{$key}) eq 'HASH' && $d->{$key}->{'xdata'} && $d->{$key}->{'xdata'}->{'general'} && $d->{$key}->{'xdata'}->{'general'}->{'src'}) {\n                return if Thruk::Utils::IO::realpath($folder.$d->{$key}->{'xdata'}->{'general'}->{'src'}) eq $file;\n            }\n        }\n    }\n\n    return 1;\n}\n\n##########################################################\nsub _append_sort {\n    my($param, $default) = @_;\n    if(!$param || ref $param ne 'ARRAY') {\n        return($default);\n    }\n\n    my $others = $default->{'ASC'} || $default->{'DESC'};\n    return({\n        $param->[1] => [ $param->[0], @{$others} ],\n    });\n}\n\n##########################################################\n\n1;\n"], "fixing_code": ["package Thruk::Controller::panorama;\n\nuse warnings;\nuse strict;\nuse Carp qw/confess/;\nuse Cpanel::JSON::XS qw/decode_json/;\nuse Cwd ();\nuse Data::Dumper qw/Dumper/;\nuse Encode qw(encode_utf8);\nuse File::Copy qw/move copy/;\nuse IO::Socket::INET ();\nuse Module::Load qw/load/;\n\nuse Thruk::Action::AddDefaults ();\nuse Thruk::Backend::Manager ();\nuse Thruk::Timer qw/timing_breakpoint/;\nuse Thruk::Utils::Auth ();\nuse Thruk::Utils::Broadcast ();\nuse Thruk::Utils::Cache ();\nuse Thruk::Utils::External ();\nuse Thruk::Utils::Log qw/:all/;\nuse Thruk::Utils::Panorama qw/:all/;\nuse Thruk::Utils::Status ();\n\n=head1 NAME\n\nThruk::Controller::panorama - Thruk Controller\n\n=head1 DESCRIPTION\n\nThruk Controller.\n\n=head1 METHODS\n\n=cut\n\n\n##########################################################\n\n=head2 index\n\n=cut\nsub index {\n    my ( $c ) = @_;\n\n    &timing_breakpoint('panorama::index');\n    return unless Thruk::Action::AddDefaults::add_defaults($c, Thruk::Constants::ADD_CACHED_DEFAULTS);\n\n    if(!$c->config->{'panorama_modules_loaded'}) {\n        load URI::Escape, qw/uri_unescape/;\n        load Scalar::Util, qw/looks_like_number/;\n        load Thruk::Utils::PanoramaCpuStats;\n        load Thruk::Utils::Avail;\n        $c->config->{'panorama_modules_loaded'} = 1;\n    }\n\n    # add current dashboard to error details, so if something goes wrong, we can log which dashboard is responsible\n    $c->stash->{errorDetails} = '' unless $c->stash->{errorDetails};\n    $c->stash->{errorDetails} .= sprintf(\"Dashboard: %s\\n\", $c->req->parameters->{'current_tab'}) if $c->req->parameters->{'current_tab'};\n\n    # add some functions\n    $c->stash->{'get_static_panorama_files'} = \\&Thruk::Utils::Panorama::get_static_panorama_files;\n\n    $c->stash->{title}             = 'Thruk Panorama';\n    $c->stash->{'skip_navigation'} = 1;\n    $c->stash->{'inject_stats'}    = 0;\n    $c->stash->{'no_totals'}       = 1;\n    $c->stash->{default_nagvis_base_url} = '';\n    $c->stash->{default_nagvis_base_url} = '/'.$ENV{'OMD_SITE'}.'/nagvis' if $ENV{'OMD_SITE'};\n    $c->stash->{'panorama_debug'} = $c->config->{'panorama_debug'} // 0;\n    $c->stash->{'panorama_debug'} = 1 if $c->req->parameters->{'debug'};\n    $c->stash->{'plugin_name'}    = Thruk::Utils::get_plugin_name(__FILE__, __PACKAGE__);\n\n    $c->stash->{'readonly'} = defined $c->config->{'Thruk::Plugin::Panorama'}->{'readonly'} ? $c->config->{'Thruk::Plugin::Panorama'}->{'readonly'} : 0;\n    $c->stash->{'readonly'} = 1 if defined $c->req->parameters->{'readonly'};\n\n    $c->stash->{'dashboard_ignore_changes'} = defined $c->config->{'Thruk::Plugin::Panorama'}->{'dashboard_ignore_changes'} ? $c->config->{'Thruk::Plugin::Panorama'}->{'dashboard_ignore_changes'} : 0;\n    $c->stash->{'dashboard_ignore_changes'} = 1 if defined $c->req->parameters->{'dashboard_ignore_changes'};\n\n    Thruk::Utils::Panorama::set_is_admin($c);\n\n    $c->stash->{one_tab_only}           = '';\n    $c->stash->{'full_reload_interval'} = defined $c->config->{'Thruk::Plugin::Panorama'}->{'full_reload_interval'} ? $c->config->{'Thruk::Plugin::Panorama'}->{'full_reload_interval'} : 10800;\n    $c->stash->{'extjs_version'}        = \"4.2.2\";\n\n    $c->{'panorama_var'} = $c->config->{'var_path'}.'/panorama';\n    Thruk::Utils::IO::mkdir_r($c->{'panorama_var'});\n    $c->{'panorama_etc'} = $c->config->{'etc_path'}.'/panorama';\n    Thruk::Utils::IO::mkdir_r($c->{'panorama_etc'});\n\n    if(defined $c->req->uri->query) {\n        if($c->req->uri->query eq 'state') {\n            return(_stateprovider($c));\n        }\n    }\n\n    if(defined $c->req->parameters->{'js'}) {\n        return(_js($c));\n    }\n\n    if(defined $c->req->parameters->{'task'}) {\n        my $task = $c->req->parameters->{'task'};\n        if($task eq 'status') {\n            return(_task_status($c));\n        }\n        if($task eq 'availability') {\n            return(_task_availability($c));\n        }\n        elsif($task eq 'dashboard_save_states') {\n            return(_task_dashboard_save_states($c));\n        }\n        elsif($task eq 'dashboard_data') {\n            return(_task_dashboard_data($c));\n        }\n        elsif($task eq 'dashboard_list') {\n            return(_task_dashboard_list($c));\n        }\n        elsif($task eq 'dashboard_update') {\n            return(_task_dashboard_update($c));\n        }\n        elsif($task eq 'dashboard_restore_list') {\n            return(_task_dashboard_restore_list($c));\n        }\n        elsif($task eq 'dashboard_restore_point') {\n            return(_task_dashboard_restore_point($c));\n        }\n        elsif($task eq 'dashboard_restore') {\n            return(_task_dashboard_restore($c));\n        }\n        elsif($task eq 'dashboards_clean') {\n            return(_task_dashboards_clean($c));\n        }\n        elsif($task eq 'stats_core_metrics') {\n            return(_task_stats_core_metrics($c));\n        }\n        elsif($task eq 'stats_check_metrics') {\n            return(_task_stats_check_metrics($c));\n        }\n        elsif($task eq 'server_stats') {\n            return(_task_server_stats($c));\n        }\n        elsif($task eq 'show_logs') {\n            return(_task_show_logs($c));\n        }\n        elsif($task eq 'show_comments') {\n            return(_task_show_comments($c));\n        }\n        elsif($task eq 'site_status') {\n            return(_task_site_status($c));\n        }\n        elsif($task eq 'hosts') {\n            return(_task_hosts($c));\n        }\n        elsif($task eq 'hosttotals') {\n            return(_task_hosttotals($c));\n        }\n        elsif($task eq 'services') {\n            return(_task_services($c));\n        }\n        elsif($task eq 'squares_data') {\n            return(_task_squares_data($c));\n        }\n        elsif($task eq 'servicesminemap') {\n            return(_task_servicesminemap($c));\n        }\n        elsif($task eq 'servicetotals') {\n            return(_task_servicetotals($c));\n        }\n        elsif($task eq 'hosts_pie') {\n            return(_task_hosts_pie($c));\n        }\n        elsif($task eq 'host_list') {\n            return(_task_host_list($c));\n        }\n        elsif($task eq 'host_detail') {\n            return(_task_host_detail($c));\n        }\n        elsif($task eq 'service_list') {\n            return(_task_service_list($c));\n        }\n        elsif($task eq 'service_detail') {\n            return(_task_service_detail($c));\n        }\n        elsif($task eq 'services_pie') {\n            return(_task_services_pie($c));\n        }\n        elsif($task eq 'stats_gearman') {\n            return(_task_stats_gearman($c));\n        }\n        elsif($task eq 'stats_gearman_grid') {\n            return(_task_stats_gearman_grid($c));\n        }\n        elsif($task eq 'pnp_graphs') {\n            return(_task_pnp_graphs($c));\n        }\n        elsif($task eq 'grafana_graphs') {\n            return(_task_grafana_graphs($c));\n        }\n        elsif($task eq 'userdata_backgroundimages') {\n            return(_task_userdata_backgroundimages($c));\n        }\n        elsif($task eq 'userdata_images') {\n            return(_task_userdata_images($c));\n        }\n        elsif($task eq 'userdata_iconsets') {\n            return(_task_userdata_iconsets($c));\n        }\n        elsif($task eq 'userdata_trendiconsets') {\n            return(_task_userdata_trendiconsets($c));\n        }\n        elsif($task eq 'userdata_sounds') {\n            return(_task_userdata_sounds($c));\n        }\n        elsif($task eq 'userdata_shapes') {\n            return(_task_userdata_shapes($c));\n        }\n        elsif($task eq 'redirect_status') {\n            return(_task_redirect_status($c));\n        }\n        elsif($task eq 'textsave') {\n            return(_task_textsave($c));\n        }\n        elsif($task eq 'serveraction') {\n            return(_task_serveraction($c));\n        }\n        elsif($task eq 'timezones') {\n            return(_task_timezones($c));\n        }\n        elsif($task eq 'wms_provider') {\n            return(_task_wms_provider($c));\n        }\n        elsif($task eq 'upload') {\n            return(_task_upload($c));\n        }\n        elsif($task eq 'uploadecho') {\n            return(_task_uploadecho($c));\n        }\n        elsif($task eq 'save_dashboard') {\n            return(_task_save_dashboard($c));\n        }\n        elsif($task eq 'load_dashboard') {\n            return(_task_load_dashboard($c));\n        }\n        elsif($task eq 'search') {\n            return(_task_search($c));\n        }\n    }\n\n    # find images for preloader\n    _set_preload_images($c);\n\n    # clean up?\n    if($c->req->parameters->{'clean'}) {\n        my $data = Thruk::Utils::get_user_data($c);\n        delete $data->{'panorama'};\n        Thruk::Utils::store_user_data($c, $data);\n        return $c->redirect_to(\"panorama.cgi\");\n    }\n\n    &timing_breakpoint('loading _js');\n    _js($c, 1);\n    &timing_breakpoint('loading _js done');\n\n    $c->stash->{template} = 'panorama.tt';\n    return 1;\n}\n\n##########################################################\nsub _js {\n    my($c, $only_data) = @_;\n\n    # merge open dashboards into state\n    my $data = Thruk::Utils::get_user_data($c);\n    if($data->{'panorama'} && $data->{'panorama'}->{'tabpan'} && $data->{'panorama'}->{'tabpan'}->{'xdata'}) {\n        $data->{'panorama'} = delete $data->{'panorama'}->{'tabpan'}->{'xdata'};\n    }\n    my $user_data = $data->{'panorama'} || {};\n    my $open_tabs = $user_data->{'open_tabs'} || [];\n    if(defined $c->req->parameters->{'map'}) {\n        my $dashboard = _get_dashboard_by_name($c, $c->req->parameters->{'map'});\n        if(!$dashboard) {\n            Thruk::Utils::set_message( $c, { style => 'fail_message', msg => 'no such dashboard', code => 404 });\n            return $c->redirect_to($c->stash->{'url_prefix'});\n        }\n        $open_tabs = [$dashboard->{'nr'}];\n        $c->stash->{one_tab_only} = $dashboard->{'nr'};\n        $c->stash->{title}        = $dashboard->{'tab'}->{'xdata'}->{'title'};\n    } elsif(defined $c->req->parameters->{'maps'}) {\n        $open_tabs = [];\n        for my $name (@{Thruk::Base::list($c->req->parameters->{'maps'})}) {\n            my $dashboard = _get_dashboard_by_name($c, $name);\n            if($dashboard) {\n                push @{$open_tabs}, $dashboard->{'nr'};\n            }\n        }\n        $user_data->{'activeTab'} = scalar @{$open_tabs} > 0 ? $open_tabs->[0] : \"\";\n    } elsif($c->cookies('thruk_panorama_tabs')) {\n        $open_tabs = [split(/\\s*:\\s*/mx, $c->cookies('thruk_panorama_tabs'))];\n        if($c->cookies('thruk_panorama_active')) {\n            $user_data->{'activeTab'} = $c->cookies('thruk_panorama_active');\n        }\n    }\n\n    if(scalar @{$open_tabs} == 0) {\n        $open_tabs = [\"0\"];\n        $user_data->{'activeTab'} = \"0\";\n    }\n\n    # restore last open tabs\n    $user_data->{'open_tabs'} = $open_tabs;\n    my $extstate = {\n        tabbar => $user_data,\n    };\n    my $shapes = {};\n    my $open_tabs_hash = Thruk::Base::array2hash($open_tabs);\n    for my $nr (@{$open_tabs}) {\n        _add_initial_dashboard($c, $nr, $extstate, $shapes, $open_tabs_hash);\n    }\n    $c->stash->{shapes} = $shapes;\n\n    $c->stash->{extstate}          = $extstate;\n    $c->stash->{default_dashboard} = [];\n    $c->stash->{shapes}            = $shapes;\n    if($c->config->{'Thruk::Plugin::Panorama'}->{'default_dashboard'}) {\n        my $default_dashboard = $c->config->{'Thruk::Plugin::Panorama'}->{'default_dashboard'};\n        if(ref $c->config->{'Thruk::Plugin::Panorama'}->{'default_dashboard'} eq 'ARRAY') {\n            $default_dashboard = join(',', @{$default_dashboard});\n        }\n        my @defaults = split(/\\s*,+\\s*/mx, $default_dashboard);\n        $c->stash->{default_dashboard} = \\@defaults;\n    }\n\n    my $action_menu_actions = [];\n    if($c->config->{'action_menu_actions'}) {\n        for my $name (keys %{$c->config->{'action_menu_actions'}}) {\n            push @{$action_menu_actions}, $name;\n        }\n    }\n    $c->stash->{action_menu_actions}   = $action_menu_actions;\n\n    my $action_menu_items    = [];\n    my $action_menu_items_js = '';\n    if($c->config->{'action_menu_items'}) {\n        for my $name (sort keys %{$c->config->{'action_menu_items'}}) {\n            my $menu = Thruk::Utils::Filter::get_action_menu($c, $name);\n            $action_menu_items_js .= delete $menu->{'data'} if $menu->{'type'} eq 'js';\n            push @{$action_menu_items}, $menu;\n        }\n    }\n    $c->stash->{action_menu_items}    = $action_menu_items;\n    $c->stash->{action_menu_items_js} = $action_menu_items_js;\n\n    $c->stash->{shape_data}         = _task_userdata_shapes($c, 1);\n    $c->stash->{iconset_data}       = _task_userdata_iconsets($c, 1);\n    $c->stash->{trendiconset_data}  = _task_userdata_trendiconsets($c, 1);\n    $c->stash->{wms_provider}       = _get_wms_provider($c);\n    $c->stash->{fonts}              = _get_available_fonts($c);\n\n    # default geo map center\n    $c->stash->{default_map_zoom} = $c->config->{'Thruk::Plugin::Panorama'}->{'geo_map_default_zoom'} || 5;\n    my($lon,$lat) = split(/\\s*,\\s*/mx, ($c->config->{'Thruk::Plugin::Panorama'}->{'geo_map_default_center'} || '13.74,47.77'));\n    $c->stash->{default_map_lon} = $lon;\n    $c->stash->{default_map_lat} = $lat;\n\n    $c->stash->{default_maintenance_text} = $c->config->{'Thruk::Plugin::Panorama'}->{'default_maintenance_text'} || '';\n\n    my $default_state_order = $c->config->{'Thruk::Plugin::Panorama'}->{'default_state_order'} // $c->config->{'default_state_order'};\n    $c->stash->{default_state_order} = [split(/\\s*,\\s*/mx, $default_state_order)];\n\n    unless($only_data) {\n        $c->res->content_type('text/javascript; charset=utf-8');\n        $c->stash->{template} = 'panorama_js.tt';\n    }\n    return 1;\n}\n\n##########################################################\nsub _stateprovider {\n    my ( $c ) = @_;\n\n    my $json;\n    my $param = $c->req->parameters;\n    my $task  = delete $param->{'task'};\n    my $value = $param->{'value'};\n    my $name  = $param->{'name'};\n    if($c->stash->{'readonly'} || $c->stash->{'dashboard_ignore_changes'}) {\n        $json = { 'status' => 'failed' };\n    }\n    elsif(defined $task and $task eq 'update2') {\n        $json = { 'status' => 'ok' };\n        my $replace = delete $param->{'replace'} || 0;\n        my $newids  = [];\n        my $newid   = delete $param->{'nr'} || '';\n        for my $key (keys %{$param}) {\n            next if !$param->{$key};\n            next if $key eq 'current_tab';\n            my $param_data = $param->{$key};\n            if(ref $param_data eq '') {\n                $param_data = decode_json($param->{$key});\n            }\n            if($key eq 'tabbar') {\n                my $data = Thruk::Utils::get_user_data($c);\n                $data->{'panorama'} = $param_data->{'xdata'};\n                Thruk::Utils::store_user_data($c, $data);\n            } else {\n                # update dashboards\n                for my $k2 (keys %{$param_data}) {\n                    if($k2 eq 'id') {\n                        $newid = $param_data->{$k2};\n                    } else {\n                        $param_data->{$k2} = $param_data->{$k2};\n                        if(ref $param_data->{$k2} eq '') {\n                            eval {\n                                if($k2 eq 'tab') {\n                                    # throws encoding error when having a dashboad with umlaut in title\n                                    $param_data->{$k2} = encode_utf8($param_data->{$k2});\n                                }\n                                $param_data->{$k2} = decode_json($param_data->{$k2});\n                            };\n                            confess(Dumper(\"Error in parsing json:\", $@, $k2, $param_data)) if $@;\n                        }\n\n                    }\n                }\n                $param_data->{'id'}   = $newid || $key;\n                $param_data->{'user'} = $c->stash->{'remote_user'};\n                my $extra = {};\n                if($c->stash->{'is_admin'} && $param_data->{'tab'}->{'xdata'}->{'owner'}) {\n                    $extra->{'user'} = $param_data->{'tab'}->{'xdata'}->{'owner'};\n                }\n                delete $param_data->{'tab'}->{'xdata'}->{'owner'};\n                if(!Thruk::Utils::Panorama::save_dashboard($c, $param_data, $extra)) {\n                    $json = { 'status' => 'failed' };\n                } else {\n                    if($newid) {\n                        $json->{'newid'} = $param_data->{'id'};\n                        push @{$newids}, $param_data->{'id'};\n                    }\n                }\n            }\n        }\n        if($replace) {\n            my $data = Thruk::Utils::get_user_data($c);\n            $data->{'panorama'}->{dashboards}->{'tabbar'}->{'open_tabs'} = $newids;\n            Thruk::Utils::store_user_data($c, $data);\n        }\n    } else {\n        $json = { 'status' => 'failed' };\n    }\n\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _nice_ext_value {\n    my($orig) = @_;\n    my $value = uri_unescape($orig);\n    $value =~ s/^o://gmx;\n    my @val   = split/\\^/mx, $value;\n    my $o = {};\n    for my $v (@val) {\n        my($key, $val) = split(/=/mx, $v, 2);\n        $val =~ s/^n%3A//gmx;\n        $val =~ s/^b%3A0/false/gmx;\n        $val =~ s/^b%3A1/true/gmx;\n        if($val =~ m/^a%3A/mx) {\n            $val =~ s/^a%3A//mx;\n            $val =~ s/s%253A//gmx;\n            $val = [ split(m/n%253A|%5E/mx, $val) ];\n            @{$val} = grep {!/^$/mx} @{$val};\n        }\n        elsif($val =~ m/^o%3A/mx) {\n            $val =~ s/^o%3A//mx;\n            $val = [ split(m/n%253A|%3D|%5E/mx, $val) ];\n            @{$val} = grep {!/^$/mx} @{$val};\n            $val = {@{$val}};\n        } else {\n            $val =~ s/^s%3A//mx;\n        }\n        $o->{$key} = $val;\n    }\n    $Data::Dumper::Sortkeys = 1;\n    $value = Dumper($o);\n    $value =~ s/^\\$VAR1\\ =//gmx;\n    $value =~ s/\\n/ /gmx;\n    $value =~ s/\\s+/ /gmx;\n    return $value;\n}\n\n##########################################################\nsub _task_status {\n    my($c, $data_only, $params) = @_;\n\n    $params = $c->req->parameters unless defined $params;\n\n    # make status group filter faster\n    $c->stash->{'cache_groups_filter'} = {} unless defined $c->stash->{'cache_groups_filter'};\n\n    my $types        = {};\n    my $tab_backends = $params->{'backends'};\n    if($params->{'types'}) {\n        if(ref $params->{'types'}) {\n            $types = $params->{'types'};\n        } else {\n            $types = decode_json($params->{'types'});\n        }\n    }\n\n    my $hostfilter    = Thruk::Utils::combine_filter('-or', [map {{name => $_}} keys %{$types->{'hosts'}}]);\n    my $servicefilter = [];\n    for my $host (keys %{$types->{'services'}}) {\n        for my $svc (keys %{$types->{'services'}->{$host}}) {\n            push @{$servicefilter}, { '-and' => { host_name => $host, description => $svc}};\n        }\n    }\n    $servicefilter = Thruk::Utils::combine_filter('-or', $servicefilter);\n\n    my $state_type = SOFT_STATE;\n    if(defined $params->{'state_type'} && $params->{'state_type'} eq 'hard') {\n        $state_type = HARD_STATE;\n    }\n\n    if($params->{'reschedule'}) {\n        Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n        # works only for a single host or service\n        $c->stash->{'now'}                   = time();\n        $c->req->parameters->{'cmd_mod'}     = 2;\n        $c->req->parameters->{'force_check'} = 0;\n        $c->req->parameters->{'start_time'}  = time();\n        $c->req->parameters->{'json'}        = 1;\n        $c->req->parameters->{'service'}     = '';\n        if(scalar keys %{$types->{'hosts'}} == 1) {\n            my $hosts  = $c->db->get_hosts(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ],\n                                               columns => [qw/name/]);\n            if(scalar @{$hosts} == 1) {\n                $c->req->parameters->{'cmd_typ'} = 96;\n                $c->req->parameters->{'host'}    = $hosts->[0]->{'name'};\n                $c->req->parameters->{'backend'} = [$hosts->[0]->{'peer_key'}];\n            } else {\n                Thruk::Utils::set_message($c, 'fail_message', 'Found '.(scalar @{$hosts}).' hosts. Cannot send reschedule command.');\n            }\n        }\n        elsif(scalar keys %{$types->{'services'}} == 1) {\n            my $services = $c->db->get_services(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ],\n                                                    columns => [qw/host_name description/]);\n            if(scalar @{$services} == 1) {\n                $c->req->parameters->{'cmd_typ'} = 7;\n                $c->req->parameters->{'host'}    = $services->[0]->{'host_name'};\n                $c->req->parameters->{'service'} = $services->[0]->{'description'};\n                $c->req->parameters->{'backend'} = [$services->[0]->{'peer_key'}];\n            } else {\n                Thruk::Utils::set_message($c, 'fail_message', 'Found '.(scalar @{$services}).' services. Cannot send reschedule command.');\n            }\n        }\n        if($params->{'cmd_typ'}) {\n            require Thruk::Controller::cmd;\n            if(Thruk::Controller::cmd::do_send_command($c)) {\n                Thruk::Utils::set_message( $c, 'success_message', 'Commands successfully submitted' );\n                Thruk::Controller::cmd::redirect_or_success($c, -2, 1);\n            }\n        }\n    }\n\n    my $data = {};\n    if(scalar keys %{$types->{'filter'}} > 0) {\n        for my $f (keys %{$types->{'filter'}}) {\n            my($incl_hst, $incl_svc, $filter, $backends) = @{decode_json($f)};\n            next if $c->stash->{'has_error'};\n            delete $c->req->parameters->{'backend'};\n            delete $c->req->parameters->{'backends'};\n            if($backends && scalar @{$backends} > 0 && (scalar @{$backends} != 1 || $backends->[0] ne '')) {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $backends);\n            } else {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n            }\n            $c->req->parameters->{'filter'} = $filter;\n            my( $hfilter, $sfilter, $hostgroupfilter, $servicegroupfilter, $has_service_filter ) = _do_filter($c);\n            $data->{'filter'}->{$f} = _summarize_query($c, $incl_hst, $incl_svc, $hfilter, $sfilter, $state_type, $has_service_filter);\n        }\n        Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n    }\n    if(scalar keys %{$types->{'hostgroups'}} > 0) {\n        $data->{'hostgroups'} = [values %{_summarize_hostgroup_query($c, $types->{'hostgroups'}, $state_type)}];\n    }\n    if(scalar keys %{$types->{'servicegroups'}} > 0) {\n        $data->{'servicegroups'} = [values %{_summarize_servicegroup_query($c, $types->{'servicegroups'}, $state_type)}];\n    }\n    if(scalar keys %{$types->{'hosts'}} > 0) {\n        my $columns = [qw/name alias state state_type has_been_checked scheduled_downtime_depth acknowledged last_state_change last_check plugin_output\n                          last_notification current_notification_number perf_data next_check action_url_expanded notes_url_expanded\n                         /];\n        push @{$columns}, \"long_plugin_output\" if $types->{'has_long_plugin_output'};\n        $data->{'hosts'} = $c->db->get_hosts(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ],\n                                                 columns => $columns,\n                                                );\n        if($c->config->{'shown_inline_pnp'}) {\n            for my $hst (@{$data->{'hosts'}}) {\n                $hst->{'pnp_url'} = Thruk::Utils::get_pnp_url($c, $hst);\n            }\n        }\n    }\n    if(scalar keys %{$types->{'services'}} > 0) {\n        my $columns = [qw/host_name host_alias description state state_type has_been_checked scheduled_downtime_depth acknowledged last_state_change last_check\n                          plugin_output last_notification current_notification_number perf_data next_check action_url_expanded notes_url_expanded\n                         /];\n        push @{$columns}, \"long_plugin_output\" if $types->{'has_long_plugin_output'};\n        $data->{'services'} = $c->db->get_services(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ],\n                                                       columns => $columns,\n                                                      );\n        if($c->config->{'shown_inline_pnp'}) {\n            for my $svc (@{$data->{'services'}}) {\n                $svc->{'pnp_url'} = Thruk::Utils::get_pnp_url($c, $svc);\n            }\n        }\n    }\n\n    return $data if $data_only;\n\n    # add status data for sub dashboards\n    if($params->{'sub'}) {\n        my $sub = decode_json($params->{'sub'});\n        $data->{'sub'} = {};\n        for my $key (keys %{$sub}) {\n            $data->{'sub'}->{$key} = _task_status($c, 1, $sub->{$key});\n        }\n    }\n\n    $data->{backends} = $c->stash->{'backend_detail'};\n\n    my $json = { data => $data };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_redirect_status {\n    my($c) = @_;\n    my $types = {};\n    return $c->redirect_to(\"status.cgi\") unless $c->req->parameters->{'filter'};\n\n    my($hfilter, $sfilter, $hostgroupfilter, $servicegroupfilter, $has_service_filter) = _do_filter($c);\n    $c->req->parameters->{'filter'} = '';\n    $c->req->parameters->{'task'}   = '';\n    my $url = Thruk::Utils::Filter::uri_with($c, $c->req->parameters);\n    $url    =~ s/^panorama.cgi/status.cgi/gmx;\n    $url    =~ s/\\&amp;filter=.*?\\&amp;/&amp;/gmx;\n    $url    =~ s/\\&amp;task=.*?\\&amp;/&amp;/gmx;\n    $url    =~ s/\\&amp;/&/gmx;\n    if($has_service_filter) {\n        $url =~ s/style=hostdetail/style=detail/gmx;\n    }\n    if($c->req->method() eq 'POST') {\n        # directly answer query, POST does not redirect\n        if($url =~ m/^\\w+\\.cgi/mx) {\n            $url = '/cgi-bin/'.$url;\n        }\n        my($sub_c);\n        eval {\n            ($sub_c) = $c->sub_request($url, \"POST\", {}, 1, undef, 1);\n        };\n        my $err = $@;\n        if($err) {\n            confess(\"internal sub request to \".$url.\" failed: \".$err);\n        }\n        $c->res->status($sub_c->res->code);\n        $c->res->headers($sub_c->res->headers);\n        $c->res->body($sub_c->res->content);\n        $c->{'rendered'} = 1;\n        $c->stash->{'inject_stats'} = 0;\n        return;\n    }\n\n    # shorten url to avoid hitting max request uri limits in webservers\n    $url =~ s/(\\?|&)backends=/$1be=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_type=/$1_t=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_val_pre=/$1_vp=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_value=/$1_v=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_hoststatustypes=/$1_hst=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_hostprops=/$1_hp=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_servicestatustypes=/$1_sst=/gmx;\n    $url =~ s/(\\?|&dfl_s\\d+)_serviceprops=/$1_sp=/gmx;\n\n    return $c->redirect_to($url);\n}\n\n##########################################################\nsub _task_textsave {\n    my($c) = @_;\n    my $file = $c->req->parameters->{'file'} || \"log.txt\";\n    $c->res->headers->header('Content-Disposition', 'attachment; filename=\"'.$file.'\"');\n    $c->res->headers->content_type('application/octet-stream');\n    $c->stash->{text}     = $c->req->parameters->{'text'};\n    $c->stash->{template} = 'passthrough.tt';\n    return;\n}\n\n##########################################################\nsub _task_serveraction {\n    my($c) = @_;\n    my($rc, $msg);\n    # if there is a dashboard in our parameters, make sure we have proper permissions\n    if($c->req->parameters->{'dashboard'} && Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $c->req->parameters->{'dashboard'}) == ACCESS_NONE) {\n        ($rc, $msg) = (1, 'no permission for this dashboard');\n    } else {\n        ($rc, $msg) = Thruk::Utils::Status::serveraction($c);\n    }\n    my $json = { 'rc' => $rc, 'msg' => $msg };\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_upload {\n    my($c) = @_;\n\n    $c->stash->{'template'} = 'passthrough.tt';\n\n    my $type     = $c->req->parameters->{'type'};\n    my $location = $c->req->parameters->{'location'};\n    if(!$type || !$location || !$c->req->uploads->{$type}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'missing properties in fileupload.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n    $location =~ s|/$||gmx;\n\n    if($c->config->{'demo_mode'}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'fileupload is disabled in demo mode.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $upload = $c->req->uploads->{$type};\n    my $folder = Cwd::abs_path($c->stash->{'usercontent_folder'}.'/'.$location);\n\n    # make sure requested folder is below the usercontent folder\n    if(CORE::index(Cwd::abs_path($c->stash->{'usercontent_folder'}), $folder) != 0) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload contains illegal folder.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    if(!-w $folder.'/.') {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload must use existing and writable folder.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    if($upload->{'size'} > (50*1024*1024)) { # not more than 50MB\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload exceeds the allowed filesize of 50MB.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $filename = $upload->{'filename'};\n    $filename =~ s|^/||gmx;\n    if($filename !~ m/^[a-z0-9_\\- ]+\\.(jpeg|jpg|gif|png|svg)$/mxi) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload contains invalid characters (a-z0-9_- ) in filename.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $newlocation = $folder.'/'.$filename;\n    if(-s $newlocation && !_check_media_permissions($c, $newlocation)) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Only administrator/panorama_view_media_manager roles may overwrite existing files.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    eval {\n        move($upload->{'tempname'}, $newlocation);\n    };\n    if($@) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => $@, success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    # must be text/html result, otherwise extjs form result handler dies\n    $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Upload successfull', success => Cpanel::JSON::XS::true, filename => $filename });\n    return;\n}\n\n##########################################################\nsub _task_uploadecho {\n    my($c) = @_;\n\n    $c->stash->{'template'} = 'passthrough.tt';\n\n    if(!$c->req->uploads->{'file'}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'missing file in fileupload.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $upload = $c->req->uploads->{'file'};\n    if($upload->{'size'} > (50*1024*1024)) { # not more than 50MB\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Fileupload exceeds the allowed filesize of 50MB.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $content = Thruk::Utils::IO::read($upload->{'tempname'});\n    unlink($upload->{'tempname'});\n\n    # must be text/html result, otherwise extjs form result handler dies\n    $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Upload successfull', success => Cpanel::JSON::XS::true, content => $content });\n    return;\n}\n\n##########################################################\nsub _task_save_dashboard {\n    my($c) = @_;\n\n    my $nr = $c->req->parameters->{'nr'} || die('no number supplied');\n       $nr =~ s/^pantab_//gmx;\n    my $d  = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n    return unless Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $d) >= ACCESS_READONLY;\n\n    my $data = {\n        usercontent => {},\n        version     => Thruk::Utils::Filter::fullversion($c),\n    };\n    for my $key (keys %{$d}) {\n        if($key =~ m/^(tab|panlet)/mx) {\n            $data->{$key} = $d->{$key};\n        }\n    }\n    # add image data\n    require MIME::Base64;\n    my $images = {};\n    for my $id (sort keys %{$d}) {\n        my $p = $d->{$id};\n        next unless ref $p eq 'HASH';\n        # dashboard background\n        if($p->{'xdata'}->{'background'}) {\n            my $file = $p->{'xdata'}->{'background'};\n            if($file =~ s|^../usercontent/||mx && $file !~ m|\\.\\.|mx) {\n                next if $file eq 'backgrounds/europa.png';\n                next if $file eq 'backgrounds/world.png';\n                next if $file eq 'backgrounds/world.svg';\n                next if $file eq 'backgrounds/europa.svg';\n                next if $file eq 'backgrounds/germany.svg';\n                $images->{$file} = $c->stash->{'usercontent_folder'}.'/'.$file;\n            }\n        }\n        # type image\n        if($p->{'xdata'}->{'appearance'} && $p->{'xdata'}->{'appearance'}->{'type'} && $p->{'xdata'}->{'appearance'}->{'type'} eq 'icon') {\n            my $file = $p->{'xdata'}->{'general'}->{'src'};\n            if($file && $file =~ s|^../usercontent/||mx && $file !~ m|\\.\\.|mx) {\n                $images->{$file} = $c->stash->{'usercontent_folder'}.'/'.$file;\n            }\n        }\n        # type icon - iconset\n        if($p->{'xdata'}->{'appearance'} && $p->{'xdata'}->{'appearance'}->{'iconset'}) {\n            my $file = $p->{'xdata'}->{'appearance'}->{'iconset'};\n            if($file && $file !~ m|/|mx && $file !~ m|\\.\\.|mx) {\n                next if $file eq 'default'; # skip our default sets\n                next if $file eq 'default_64';\n                next if $file eq 'tfl';\n                next if $file eq 'emoji';\n                next if $file eq 'emoji_64';\n                my @files = glob($c->stash->{'usercontent_folder'}.'/images/status/'.$file.'/*');\n                my $usercontent_folder = $c->stash->{'usercontent_folder'}.'/';\n                for my $f (@files) {\n                    my $short = $f;\n                    $short =~ s|^$usercontent_folder||mx;\n                    $images->{$short} = $f;\n                }\n            }\n        }\n    }\n    for my $image (sort keys %{$images}) {\n        my $file = $images->{$image};\n        next unless -r $file;\n        $data->{'usercontent'}->{$image} = MIME::Base64::encode_base64(\"\".Thruk::Utils::IO::read($file));\n    }\n    $c->stash->{'template'} = 'passthrough.tt';\n    my $text = \"\";\n    $text   .= \"# Thruk Panorama Dashboard Export: \".$d->{'tab'}->{'xdata'}->{'title'}.\"\\n\";\n    $text   .= Thruk::Utils::Filter::json_encode($data);\n    $text   .= \"\\n# End Export\\n\";\n    $c->stash->{text} = $text;\n    $c->res->headers->header( 'Content-Disposition', 'attachment; filename=\"'.$d->{'tab'}->{'xdata'}->{'title'}.'.dashboard\"' );\n    return;\n}\n\n##########################################################\nsub _task_load_dashboard {\n    my($c) = @_;\n\n    $c->stash->{'template'} = 'passthrough.tt';\n\n    if(!$c->req->uploads->{'file'}) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'missing file in fileupload.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $upload = $c->req->uploads->{'file'};\n    if($upload->{'size'} > (50*1024*1024)) { # not more than 50MB\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'File exceeds the allowed filesize of 50MB.', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    my $content = Thruk::Utils::IO::read($upload->{'tempname'});\n    unlink($upload->{'tempname'});\n\n    $content =~ s/^\\#.*$//gmx;\n    my $data;\n    eval {\n        $data = decode_json($content);\n    };\n    if($@) {\n        # must be text/html result, otherwise extjs form result handler dies\n        $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'This is not a valid dashboard', success => Cpanel::JSON::XS::false });\n        return;\n    }\n\n    delete $data->{'version'};\n\n    if($data->{'usercontent'}) {\n        require MIME::Base64;\n        my $usercontent_folder = $c->stash->{'usercontent_folder'}.'/';\n        for my $file (sort keys %{$data->{'usercontent'}}) {\n            my $size = -s $usercontent_folder.$file;\n            next if $c->config->{'demo_mode'};\n            next if $size && !_check_media_permissions($c, $usercontent_folder.$file); # overwrite only if user is allowed to\n            my $content = MIME::Base64::decode_base64($data->{'usercontent'}->{$file});\n            next if($size && length($content) == $size);\n            my $dir     = $file;\n            $dir        =~ s|/[^/]+$||mx;\n            eval {\n                Thruk::Utils::IO::mkdir_r($usercontent_folder.$dir);\n                Thruk::Utils::IO::write($usercontent_folder.$file,$content);\n            };\n            if($@) {\n                _error('Usercontent upload for '.$file.' failed: '.$@);\n                $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Usercontent upload for '.$file.' failed.', success => Cpanel::JSON::XS::false });\n                return;\n            }\n        }\n        delete $data->{'usercontent'};\n    }\n    $data->{'id'}   = 'new';\n    $data->{'user'} = $c->stash->{'remote_user'};\n    $data = Thruk::Utils::Panorama::save_dashboard($c, $data);\n    my $newid = $data->{'id'};\n\n    # must be text/html result, otherwise extjs form result handler dies\n    $c->stash->{text} = Thruk::Utils::Filter::json_encode({ 'msg' => 'Import successfull', success => Cpanel::JSON::XS::true, newid => $newid });\n    return;\n}\n\n##########################################################\nsub _task_search {\n    my($c) = @_;\n\n    my $query = $c->req->parameters->{'value'} || '';\n    $query = Thruk::Base::trim_whitespace($query);\n    $query =~ s/\\s+/.*/gmx;\n    my $json = { 'rc' => 0, 'data' => [] };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json) unless $query;\n\n    my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, 'all', 1);\n\n    # search names and aliases\n    my $search = {\n        'host'         => $c->db->get_hosts( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'hosts' ), { '-or' => [ { name => { '~~' => $query } }, { alias => { '~~' => $query } } ] } ], columns => [qw/name alias/]),\n        'hostgroup'    => $c->db->get_hostgroups( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'hostgroups' ), { '-or' => [ { name => { '~~' => $query } }, { alias => { '~~' => $query } } ] } ], columns => [qw/name alias/]),\n        'service'      => $c->db->get_services( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'services' ), { '-or' => [ { description => { '~~' => $query } }, { display_name => { '~~' => $query } } ] } ], columns => [qw/description display_name/]),\n        'servicegroup' => $c->db->get_hostgroups( filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'servicegroups' ), { '-or' => [ { name => { '~~' => $query } }, { alias => { '~~' => $query } } ] } ], columns => [qw/name alias/]),\n    };\n\n    # normalize services\n    for my $o (@{$search->{\"service\"}}) {\n        $o->{'name'}  = delete $o->{'description'};\n        $o->{'alias'} = delete $o->{'display_name'};\n    }\n\n    my $data  = {};\n    for my $d (@{$dashboards}) {\n        my $found = _search_match($data, $d, $d->{'tab'}->{'xdata'}->{'title'}, $query, \"title\")\n                 || _search_match($data, $d, $d->{'tab'}->{'xdata'}->{'description'}, $query, \"description\");\n\n        for my $icon_id (sort keys %{$d}) {\n            my $icon = $d->{$icon_id};\n            next unless ref $icon eq 'HASH';\n            next unless $icon->{'xdata'};\n\n            for my $type (sort keys %{$search}) {\n                if($icon->{'xdata'}->{'general'}->{$type}) {\n                    for my $o (@{$search->{$type}}) {\n                        my $found = _search_match($data, $d, $icon->{'xdata'}->{'general'}->{$type}, $query, $type, $o);\n                        if($found) {\n                            $found->{'highlight'} = $icon_id;\n                            $found->{'object'}    = $o;\n                        }\n                    }\n                }\n                if(!$found) {\n                    my $found = _search_match($data, $d, $icon->{'xdata'}->{'general'}->{$type}, $query, $type);\n                    if($found) {\n                        $found->{'highlight'} = $icon_id;\n                    }\n                }\n            }\n\n            my $found = _search_match($data, $d, $icon->{'xdata'}->{'label'}->{'labeltext'}, $query, \"iconlabel\")\n                     || _search_match($data, $d, $icon->{'xdata'}->{'general'}->{'text'}, $query, \"icontext\");\n            if($found) {\n                $found->{'highlight'} = $icon_id;\n            }\n        }\n    }\n\n    # sort by dashboard name\n    $json->{'data'} = [sort { $a->{'name'} cmp $b->{'name'} } values(%{$data})];\n\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _search_match {\n    my($result, $dashboard, $field, $query, $type, $names) = @_;\n    return unless defined $field;\n\n    # strip html and tags\n    $field =~ s/\\{\\{.*?\\}\\}//gmx;\n    $field =~ s/<.*?>//gmx;\n\n    my($matched, $pre,$match,$post) = (0, '', '', '');\n    if($names) {\n        return if $names->{'name'} ne $field;\n        $field   = $names->{'name'} eq $names->{'alias'} ? $names->{'name'} : $names->{'name'}.' - '.$names->{'alias'};\n        $match   = $query;\n        $matched = 1;\n    }\n    ## no critic\n    if($field =~ m#(.*)($query)(.*)#si) {\n        ($pre,$match,$post) = ($1,$2,$3);\n        $matched = 1;\n    }\n    ## use critic\n\n    return unless $matched;\n    my $found = {\n        type  => $type,\n        match => $match,\n        pre   => $pre,\n        post  => $post,\n        value => $field,\n    };\n    $result->{$dashboard->{id}} = {\n        id      => $dashboard->{id},\n        name    => $dashboard->{'tab'}->{'xdata'}->{'title'},\n        matches => [],\n    } unless $result->{$dashboard->{id}};\n    push @{$result->{$dashboard->{id}}->{'matches'}}, $found;\n    return($found);\n}\n\n##########################################################\nsub _task_wms_provider {\n    my($c) = @_;\n\n    my $provider = _get_wms_provider($c);\n    my $json = { 'rc' => 0, 'data' => $provider };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _get_wms_provider {\n    my($c) = @_;\n    my $provider = [];\n    my $list     = $c->config->{'Thruk::Plugin::Panorama'}->{'wms_provider'};\n    if(ref $list eq \"\") { $list = [$list] }\n    for my $entry (@{$list}) {\n        next unless $entry;\n        my($name, $data) = split(/\\s*=\\s*/mx, $entry, 2);\n        $name =~ s/^\\s*//gmx;\n        $name =~ s/\\s*$//gmx;\n        $data =~ s/^\\s*//gmx;\n        $data =~ s/\\s*$//gmx;\n        next unless $data;\n        eval {\n            my $test = Cpanel::JSON::XS::decode_json($data);\n        };\n        if($@) {\n            print STDERR \"error in wms provider: \".$@;\n            print STDERR $entry,\"\\n\";\n            die(\"error in wms provider: \".$@.\"\\nat entry: \".$entry.\"\\n\");\n        }\n        push @{$provider}, { name => $name, provider => $data };\n    }\n    return($provider);\n}\n\n\n##########################################################\nsub _task_timezones {\n    my($c) = @_;\n\n    my $query = $c->req->parameters->{'query'} || '';\n    my $data  = [];\n    for my $tz (@{Thruk::Utils::get_timezone_data($c)}) {\n        next if($query && $tz->{'text'} !~ m/$query/mxi);\n        push @{$data}, $tz;\n    }\n\n    my $json = { 'rc' => 0, 'data' => $data };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n\n##########################################################\nsub _task_availability {\n    my($c) = @_;\n\n    # make status group filter faster\n    $c->stash->{'cache_groups_filter'} = {};\n\n    if($c->req->parameters->{'force'}) {\n        return(avail_update($c));\n    }\n\n    $c->stats->profile(begin => \"_task_avail\");\n    if($c->req->parameters->{'force'}) {\n        avail_update($c);\n    } else {\n        Thruk::Utils::External::perl($c, { expr       => 'Thruk::Controller::panorama::avail_update($c)',\n                                           message    => 'availability is being calculated',\n                                           background => 1,\n                                        });\n    }\n    my $res = avail_update($c, 1);\n    $c->stats->profile(end => \"_task_avail\");\n    return($res);\n}\n\n##########################################################\n\n=head2 avail_update\n\n  avail_update($c, [$cached_only])\n\nreturns calculated availability data in json format\n\n=cut\nsub avail_update {\n    my($c, $cached_only) = @_;\n\n    $c->stats->profile(begin => \"avail_update\");\n    my $in    = {};\n    my $types = {};\n\n    my $tab_backends = $c->req->parameters->{'backends'};\n    return $c->render(json => {status => 'ok', msg => 'nothing to do'}) if(!defined $c->req->parameters->{'avail'} || $c->req->parameters->{'avail'} eq 'null');\n    if($c->req->parameters->{'avail'}) { $in    = decode_json($c->req->parameters->{'avail'}); }\n    if($c->req->parameters->{'types'}) { $types = decode_json($c->req->parameters->{'types'}); }\n    my $cache = Thruk::Utils::Cache->new($c->config->{'var_path'}.'/availability.cache');\n\n    # cache hit?\n    my @cache_prefix;\n    if($c->check_user_roles('authorized_for_all_hosts') && $c->check_user_roles('authorized_for_all_services')) {\n        my $tmp_cache = $cache->get('global');\n        if(!defined $tmp_cache) {\n            $cache->set('global', {});\n        }\n        @cache_prefix = ('global');\n    } else {\n        my $tmp_cache = $cache->get('users');\n        if(!defined $tmp_cache->{$c->stash->{'remote_user'}}) {\n            $tmp_cache->{$c->stash->{'remote_user'}} = {};\n            $cache->set('users', $c->stash->{'remote_user'}, {});\n        }\n        @cache_prefix = ('users', $c->stash->{'remote_user'});\n    }\n\n    my $data = {};\n    my $now  = time();\n    Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n    if(scalar keys %{$types->{'filter'}} > 0) {\n        for my $f (keys %{$types->{'filter'}}) {\n            # check if this filter is used in availabilities at all\n            my $found = 0;\n            for my $panel (@{$types->{'filter'}->{$f}}) {\n                if($in->{$panel}) { $found = 1; last; }\n            }\n            next unless $found;\n\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            my $filtername = \"$f\"; # results in *** glibc detected *** perl: double free or corruption (!prev): 0x0e482c38 *** otherwise\n            my($incl_hst, $incl_svc, $filter, $backends) = @{decode_json($f)};\n            delete $c->req->parameters->{'backend'};\n            delete $c->req->parameters->{'backends'};\n            if((ref $backends eq \"\" and $backends) || (ref $backends eq 'ARRAY' && scalar @{$backends} > 0)) {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $backends);\n            } else {\n                Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n            }\n            $c->req->parameters->{'filter'} = $filter;\n            my( $hfilter, $sfilter, $groupfilter ) = _do_filter($c);\n            next if $c->stash->{'has_error'};\n            for my $panel (@{$types->{'filter'}->{$f}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $opts   = $in->{$panel}->{$key}->{opts};\n                    Thruk::Utils::Avail::reset_req_parameters($c);\n                    if($opts->{'incl_hst'} || (!$opts->{'incl_hst'} && !$opts->{'incl_svc'})) {\n                        if($hfilter) {\n                            $c->req->parameters->{h_filter} = $hfilter;\n                        } else {\n                            $c->req->parameters->{host}     = 'all';\n                        }\n                    }\n                    if($opts->{'incl_svc'} || (!$opts->{'incl_hst'} && !$opts->{'incl_svc'})) {\n                        if($sfilter) {\n                            $c->req->parameters->{s_filter} = $sfilter;\n                        } else {\n                            $c->req->parameters->{service}  = 'all';\n                        }\n                    }\n                    my $cached = $cache->get(@cache_prefix, 'filter', $filtername, $key);\n                    $cache->set(@cache_prefix, 'filter', $filtername, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $opts, undef, undef, 1);\n                    $cache->set(@cache_prefix, 'filter', $filtername, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n        Thruk::Action::AddDefaults::set_enabled_backends($c, $tab_backends);\n    }\n    if(scalar keys %{$types->{'hostgroups'}} > 0) {\n        for my $group (keys %{$types->{'hostgroups'}}) {\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            $c->req->parameters->{hostgroup} = $group;\n            for my $panel (@{$types->{'hostgroups'}->{$group}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $opts   = $in->{$panel}->{$key}->{opts};\n                    my $cached = $cache->get(@cache_prefix, 'hostgroups', $group, $key);\n                    $cache->set(@cache_prefix, 'hostgroups', $group, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    if($opts->{'incl_svc'} || (!$opts->{'incl_hst'} && !$opts->{'incl_svc'})) {\n                        $c->req->parameters->{include_host_services} = 1;\n                    }\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $opts);\n                    $cache->set(@cache_prefix, 'hostgroups', $group, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n    }\n    if(scalar keys %{$types->{'servicegroups'}} > 0) {\n        for my $group (keys %{$types->{'servicegroups'}}) {\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            $c->req->parameters->{servicegroup} = $group;\n            for my $panel (@{$types->{'servicegroups'}->{$group}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $cached = $cache->get(@cache_prefix, 'servicegroups', $group, $key);\n                    $cache->set(@cache_prefix, 'servicegroups', $group, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $in->{$panel}->{$key}->{opts});\n                    $cache->set(@cache_prefix, 'servicegroups', $group, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n    }\n    if(scalar keys %{$types->{'hosts'}} > 0) {\n        for my $host (keys %{$types->{'hosts'}}) {\n            Thruk::Utils::Avail::reset_req_parameters($c);\n            $c->req->parameters->{host} = $host;\n            $c->req->parameters->{include_host_services} = 0;\n            for my $panel (@{$types->{'hosts'}->{$host}}) {\n                for my $key (keys %{$in->{$panel}}) {\n                    my $cached = $cache->get(@cache_prefix, 'hosts', $host, $key);\n                    $cache->set(@cache_prefix, 'hosts', $host, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                    $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $in->{$panel}->{$key}->{opts}, $host);\n                    $cache->set(@cache_prefix, 'hosts', $host, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                }\n            }\n        }\n    }\n    if(scalar keys %{$types->{'services'}} > 0) {\n        for my $host (keys %{$types->{'services'}}) {\n            for my $service (keys %{$types->{'services'}->{$host}}) {\n                Thruk::Utils::Avail::reset_req_parameters($c);\n                $c->req->parameters->{host}    = $host;\n                $c->req->parameters->{service} = $service;\n                for my $panel (@{$types->{'services'}->{$host}->{$service}}) {\n                    for my $key (keys %{$in->{$panel}}) {\n                        my $cached = $cache->get(@cache_prefix, 'services', $host, $service, $key);\n                        $cache->set(@cache_prefix, 'services', $host, $service, $key, {val => -1, time => $now}) if(!$cached && !$cached_only);\n                        $data->{$panel}->{$key} = _avail_calc($c, $cached_only, $now, $cached, $in->{$panel}->{$key}->{opts}, $host, $service);\n                        $cache->set(@cache_prefix, 'services', $host, $service, $key, {val => $data->{$panel}->{$key}, time => $now}) if !$cached_only;\n                    }\n                }\n            }\n        }\n    }\n\n    # clean up cache\n    $c->stats->profile(begin => \"_avail_clean_cache\");\n    my $cached = $cache->get();\n    _avail_clean_cache($cached, $now - 86400);\n    $cache->set($cached);\n    $c->stats->profile(end => \"_avail_clean_cache\");\n\n    my $json = { data => $data };\n\n    $c->stats->profile(end => \"avail_update\");\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _avail_clean_cache {\n    my($data, $expire) = @_;\n    for my $key (keys %{$data}) {\n        if(ref $data->{$key} eq 'HASH') {\n            if(exists $data->{$key}->{'time'}) {\n                if($data->{$key}->{'time'} < $expire) {\n                    delete $data->{$key};\n                }\n            } else {\n                _avail_clean_cache($data->{$key}, $expire);\n            }\n            if(scalar keys %{$data->{$key}} == 0) {\n                delete $data->{$key};\n            }\n        }\n    }\n    return;\n}\n\n##########################################################\nsub _avail_calc {\n    my($c, $cached_only, $now, $cached, $opts, $host, $service, $filter) = @_;\n    my $duration = Thruk::Utils::expand_duration($opts->{'d'});\n    my $unavailable_states = {'down' => 1, 'unreachable' => 1, 'critical' => 1, 'unknown' => 1};\n    my $cache_retrieve_factor = $c->config->{'Thruk::Plugin::Panorama'}->{'cache_retrieve_factor'} || 0.0025; # ~ once a day for yearly values, every ~ 3.5 minutes for daily averages\n\n    # cache hit?\n    if($cached && !$c->req->parameters->{'force'}) {\n        my $refresh = 0;\n        if($now > $cached->{'time'} + $duration * $cache_retrieve_factor) {\n            $refresh = 1;\n        }\n        # retry unknown values every 2 minutes\n        elsif(!looks_like_number($cached->{'val'}) || $cached->{'val'} == -1) {\n            if($now > $cached->{'time'} + 120) {\n                $refresh = 1;\n            }\n        }\n        if(!$refresh) {\n            return($cached->{'val'});\n        }\n    }\n    if($cached_only) {\n        if(defined $cached->{'val'}) {\n            if($now > $cached->{'time'} + $duration * $cache_retrieve_factor*5 && $now > $cached->{'time'} + 180) {\n                # better return unknown for really old cached values\n                return(-1);\n            }\n            return($cached->{'val'});\n        }\n        return(-1);\n    }\n\n    $cached->{'time'} = $now;\n\n    $c->req->parameters->{t2}            = time();\n    $c->req->parameters->{t1}            = $c->req->parameters->{t2} - $duration;\n    $c->req->parameters->{rpttimeperiod} = $opts->{'tm'};\n    if($opts->{'h'}) {\n        $unavailable_states->{'down'}        = 0;\n        $unavailable_states->{'unreachable'} = 0;\n        for my $chr (split//mx, lc $opts->{'h'}) {\n            if($chr eq 'd') { $unavailable_states->{'down'}        = 1; }\n            if($chr eq 'u') { $unavailable_states->{'unreachable'} = 1; }\n        }\n    }\n    if($opts->{'s'}) {\n        $unavailable_states->{'warning'}  = 0;\n        $unavailable_states->{'critical'} = 0;\n        $unavailable_states->{'unknown'}  = 0;\n        for my $chr (split//mx, lc $opts->{'s'}) {\n            if($chr eq 'w') { $unavailable_states->{'warning'}  = 1; }\n            if($chr eq 'c') { $unavailable_states->{'critical'} = 1; }\n            if($chr eq 'u') { $unavailable_states->{'unknown'}  = 1; }\n        }\n    }\n    # set downtimes as unavailable too\n    if(defined $opts->{'downtime'} && !$opts->{'downtime'}) {\n        for my $key (keys %{$unavailable_states}) {\n            $unavailable_states->{$key.\"_downtime\"} = 1;\n        }\n    }\n    if(!$filter) {\n        eval {\n            Thruk::Utils::Avail::calculate_availability($c)\n        };\n        if($@) {\n            _error(\"calculating availability failed for filter:\");\n            _error(Dumper($c->req->parameters));\n            _error($@);\n            return(($ENV{'THRUK_JOB_ID'} ? '('.$ENV{'THRUK_JOB_ID'}.') ' : '').$@);\n        }\n    }\n    if($host) {\n        my $totals = Thruk::Utils::Avail::get_availability_percents($c->stash->{avail_data},\n                                                                    $unavailable_states,\n                                                                    $host,\n                                                                    $service,\n                                                                   );\n        return(\"found no data for service: \".$host.\" - \".$service) if($service && $totals->{'total'}->{'percent'} == -1);\n        return(\"found no data for host: \".$host) if (!defined $totals->{'total'}->{'percent'} || $totals->{'total'}->{'percent'} == -1);\n        return($totals->{'total'}->{'percent'});\n    } else {\n        my($num, $total) = (0,0);\n        # if nothing is enabled, use all\n        if(!$opts->{'incl_hst'} && !$opts->{'incl_svc'}) {\n            $opts->{'incl_hst'} = 1;\n            $opts->{'incl_svc'} = 1;\n        }\n        if($opts->{'incl_hst'}) {\n            my $s_filter = delete $c->req->parameters->{s_filter};\n            if($filter) {\n                delete $c->stash->{avail_data}->{'hosts'};\n                eval {\n                    Thruk::Utils::Avail::calculate_availability($c)\n                };\n                if($@) {\n                    _error(\"calculating availability failed for host filter:\");\n                    _error(Dumper($c->req->parameters));\n                    _error($@);\n                    return(($ENV{'THRUK_JOB_ID'} ? '('.$ENV{'THRUK_JOB_ID'}.') ' : '').$@);\n                }\n            }\n            if($c->stash->{avail_data}->{'hosts'}) {\n                for my $host (keys %{$c->stash->{avail_data}->{'hosts'}}) {\n                    my $totals = Thruk::Utils::Avail::get_availability_percents($c->stash->{avail_data},\n                                                                                $unavailable_states,\n                                                                                $host,\n                                                                               );\n                    if($totals->{'total'}->{'percent'} != -1) {\n                        $total += $totals->{'total'}->{'percent'};\n                        $num++;\n                    }\n                }\n            }\n            $c->req->parameters->{s_filter} = $s_filter;\n        }\n        if($opts->{'incl_svc'}) {\n            delete $c->req->parameters->{h_filter};\n            if($filter) {\n                delete $c->stash->{avail_data}->{'services'};\n                eval {\n                    Thruk::Utils::Avail::calculate_availability($c)\n                };\n                if($@) {\n                    _error(\"calculating availability failed for service filter:\");\n                    _error(Dumper($c->req->parameters));\n                    _error($@);\n                    return(($ENV{'THRUK_JOB_ID'} ? '('.$ENV{'THRUK_JOB_ID'}.') ' : '').$@);\n                }\n            }\n            if($c->stash->{avail_data}->{'services'}) {\n                for my $host (keys %{$c->stash->{avail_data}->{'services'}}) {\n                    for my $service (keys %{$c->stash->{avail_data}->{'services'}->{$host}}) {\n                        my $totals = Thruk::Utils::Avail::get_availability_percents($c->stash->{avail_data},\n                                                                                    $unavailable_states,\n                                                                                    $host,\n                                                                                    $service,\n                                                                                   );\n                        if($totals->{'total'}->{'percent'} != -1) {\n                            $total += $totals->{'total'}->{'percent'};\n                            $num++;\n                        }\n                    }\n                }\n            }\n        }\n        if($num > 0) {\n            return($total/$num);\n        }\n    }\n    return(\"found no data\");\n}\n\n##########################################################\nsub _task_stats_core_metrics {\n    my($c) = @_;\n\n    my $data = $c->db->get_extra_perf_stats(  filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'status' ) ] );\n    my $json = {\n        columns => [\n            { 'header' => 'Type',  dataIndex => 'type',  flex  => 1 },\n            { 'header' => 'Total', dataIndex => 'total', align => 'right', xtype => 'numbercolumn', format => '0,000' },\n            { 'header' => 'Rate',  dataIndex => 'rate',  align => 'right', xtype => 'numbercolumn', format => '0.00/s' },\n        ],\n        data    => [\n            { type => 'Servicechecks',       total => $data->{'service_checks'}, rate => $data->{'service_checks_rate'} },\n            { type => 'Hostchecks',          total => $data->{'host_checks'},    rate => $data->{'host_checks_rate'} },\n            { type => 'Connections',         total => $data->{'connections'},    rate => $data->{'connections_rate'} },\n            { type => 'Requests',            total => $data->{'requests'},       rate => $data->{'requests_rate'} },\n            { type => 'NEB Callbacks',       total => $data->{'neb_callbacks'},  rate => $data->{'neb_callbacks_rate'} },\n            { type => 'Cached Log Messages', total => $data->{'cached_log_messages'}, rate => '' },\n        ],\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_stats_check_metrics {\n    my($c) = @_;\n\n    my $data = $c->db->get_performance_stats( services_filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'services' ) ], hosts_filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'hosts' ) ] );\n\n    my $json = {\n        columns => [\n            { 'header' => 'Type',  dataIndex => 'type', flex  => 1 },\n            { 'header' => 'Min',   dataIndex => 'min', width => 60, align => 'right', xtype => 'numbercolumn', format => '0.00s' },\n            { 'header' => 'Max',   dataIndex => 'max', width => 60, align => 'right', xtype => 'numbercolumn', format => '0.00s' },\n            { 'header' => 'Avg',   dataIndex => 'avg', width => 60, align => 'right', xtype => 'numbercolumn', format => '0.00s' },\n        ],\n        data    => [\n            { type => 'Service Check Execution Time', min => $data->{'services_execution_time_min'}, max => $data->{'services_execution_time_max'}, avg => $data->{'services_execution_time_avg'} },\n            { type => 'Service Check Latency',        min => $data->{'services_latency_min'},        max => $data->{'services_latency_max'},        avg => $data->{'services_latency_avg'} },\n            { type => 'Host Check Execution Time',    min => $data->{'hosts_execution_time_min'},    max => $data->{'hosts_execution_time_max'},    avg => $data->{'hosts_execution_time_avg'} },\n            { type => 'Host Check Latency',           min => $data->{'hosts_latency_min'},           max => $data->{'hosts_latency_max'},           avg => $data->{'hosts_latency_avg'} },\n        ],\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_server_stats {\n    my($c) = @_;\n\n    my $show_load   = $c->req->parameters->{'load'}   || 'true';\n    my $show_cpu    = $c->req->parameters->{'cpu'}    || 'true';\n    my $show_memory = $c->req->parameters->{'memory'} || 'true';\n\n    my $json = {\n        columns => [\n            { 'header' => 'Cat',    dataIndex => 'cat',   hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Type',   dataIndex => 'type',  width => 60, align => 'right' },\n            { 'header' => 'Value',  dataIndex => 'value', width => 65, align => 'right', renderer => 'TP.render_systat_value' },\n            { 'header' => 'Graph',  dataIndex => 'graph', flex  => 1,                    renderer => 'TP.render_systat_graph' },\n            { 'header' => 'Warn',   dataIndex => 'warn',  hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Crit',   dataIndex => 'crit',  hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Max',    dataIndex => 'max',   hidden => Cpanel::JSON::XS::true },\n        ],\n        data  => [],\n        group => 'cat',\n    };\n    return $c->render(json => $json) unless -e '/proc'; # all beyond is linux only\n\n    my($cpu, $cpucount);\n    if($show_load eq 'true' or $show_cpu eq 'true') {\n        my $lastcpu = $c->cache->get('panorama_sys_cpu');\n        my $pcs  = Thruk::Utils::PanoramaCpuStats->new({sleep => 3, init => $lastcpu->{'init'}});\n           $cpu  = $pcs->get();\n           $cpucount = (scalar keys %{$cpu}) - 1;\n        # don't save more often than 5 seconds to keep a better reference\n        if(!defined $lastcpu->{'time'} || $lastcpu->{'time'} +5 < time()) {\n            $c->cache->set('panorama_sys_cpu', { init => $pcs->{'init'}, time => time() });\n        }\n        $cpu     = $cpu->{'cpu'};\n    }\n\n    if($show_load eq 'true') {\n        my @load = split(/\\s+/mx,(Thruk::Utils::IO::read('/proc/loadavg')));\n        push @{$json->{'data'}},\n            { cat => 'Load',    type => 'load 1',   value => $load[0],            'warn' => $cpucount*2.5, crit => $cpucount*5.0, max => $cpucount*3, graph => '' },\n            { cat => 'Load',    type => 'load 5',   value => $load[1],            'warn' => $cpucount*2.0, crit => $cpucount*3.0, max => $cpucount*3, graph => '' },\n            { cat => 'Load',    type => 'load 15',  value => $load[2],            'warn' => $cpucount*1.5, crit => $cpucount*2,   max => $cpucount*3, graph => '' };\n    }\n    if($show_cpu eq 'true') {\n        push @{$json->{'data'}},\n            { cat => 'CPU',     type => 'User',     value => $cpu->{'user'},      'warn' => 70, crit => 90, max => 100, graph => '' },\n            { cat => 'CPU',     type => 'Nice',     value => $cpu->{'nice'},      'warn' => 70, crit => 90, max => 100, graph => '' },\n            { cat => 'CPU',     type => 'System',   value => $cpu->{'system'},    'warn' => 70, crit => 90, max => 100, graph => '' },\n            { cat => 'CPU',     type => 'Wait IO',  value => $cpu->{'iowait'},    'warn' => 70, crit => 90, max => 100, graph => '' };\n    }\n    if($show_memory eq 'true') {\n        # gather system statistics\n        my $mem = {};\n        for my $line (split/\\n/mx,(Thruk::Utils::IO::read('/proc/meminfo'))) {\n            my($name,$val,$unit) = split(/\\s+/mx,$line,3);\n            next unless defined $unit;\n            $name =~ s/:$//gmx;\n            $mem->{$name} = int($val / 1024);\n        }\n        $mem->{'Buffers'} = 0; # can be empty on some machines\n        push @{$json->{'data'}},\n            { cat => 'Memory',  type => 'total',    value => $mem->{'MemTotal'},  graph => '', warn => $mem->{'MemTotal'}, crit => $mem->{'MemTotal'}, max => $mem->{'MemTotal'} },\n            { cat => 'Memory',  type => 'free',     value => $mem->{'MemFree'},   'warn' => $mem->{'MemTotal'}*0.7, crit => $mem->{'MemTotal'}*0.8, max => $mem->{'MemTotal'}, graph => '' },\n            { cat => 'Memory',  type => 'used',     value => $mem->{'MemTotal'}-$mem->{'MemFree'}-$mem->{'Buffers'}-$mem->{'Cached'}, 'warn' => $mem->{'MemTotal'}*0.7, crit => $mem->{'MemTotal'}*0.8, max => $mem->{'MemTotal'}, graph => '' },\n            { cat => 'Memory',  type => 'buffers',  value => $mem->{'Buffers'},   'warn' => $mem->{'MemTotal'}*0.8, crit => $mem->{'MemTotal'}*0.9, max => $mem->{'MemTotal'}, graph => '' },\n            { cat => 'Memory',  type => 'cached',   value => $mem->{'Cached'},    'warn' => $mem->{'MemTotal'}*0.8, crit => $mem->{'MemTotal'}*0.9, max => $mem->{'MemTotal'}, graph => '' };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_stats_gearman {\n    my($c) = @_;\n    my $json = _get_gearman_stats($c);\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_stats_gearman_grid {\n    my($c) = @_;\n\n    my $data = _get_gearman_stats($c);\n\n    my $json = {\n        columns => [\n            { 'header' => 'Queue',   dataIndex => 'name', flex  => 1, renderer => 'TP.render_gearman_queue' },\n            { 'header' => 'Worker',  dataIndex => 'worker',  width => 60, align => 'right', xtype => 'numbercolumn', format => '0,000' },\n            { 'header' => 'Running', dataIndex => 'running', width => 60, align => 'right', xtype => 'numbercolumn', format => '0,000' },\n            { 'header' => 'Waiting', dataIndex => 'waiting', width => 60, align => 'right', xtype => 'numbercolumn', format => '0,000' },\n        ],\n        data    => [],\n    };\n    for my $queue (sort keys %{$data}) {\n        # hide empty queues\n        next if($data->{$queue}->{'worker'} == 0 and $data->{$queue}->{'running'} == 0 and $data->{$queue}->{'waiting'} == 0);\n        push @{$json->{'data'}}, {\n            name    => $queue,\n            worker  => $data->{$queue}->{'worker'},\n            running => $data->{$queue}->{'running'},\n            waiting => $data->{$queue}->{'waiting'},\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_show_logs {\n    my($c) = @_;\n\n    my $filter;\n    my $end   = time();\n    my $start = $end - Thruk::Utils::expand_duration($c->req->parameters->{'time'} || '15m');\n    push @{$filter}, { time => { '>=' => $start }};\n    push @{$filter}, { time => { '<=' => $end }};\n\n    # additional filters set?\n    my $pattern         = $c->req->parameters->{'pattern'};\n    my $exclude_pattern = $c->req->parameters->{'exclude'};\n    if(defined $pattern and $pattern !~ m/^\\s*$/mx) {\n        push @{$filter}, { message => { '~~' => Thruk::Utils::clean_regex($pattern) }};\n    }\n    if(defined $exclude_pattern and $exclude_pattern !~ m/^\\s*$/mx) {\n        push @{$filter}, { message => { '!~~' => Thruk::Utils::clean_regex($exclude_pattern) }};\n    }\n    my $total_filter = Thruk::Utils::combine_filter('-and', $filter);\n    $c->db->renew_logcache($c);\n    my $data = $c->db->get_logs(filter => [$total_filter, Thruk::Utils::Auth::get_auth_filter($c, 'log')], sort => {'DESC' => 'time'});\n\n    my $json = {\n        columns => [\n            { 'header' => 'Icon',    dataIndex => 'icon', width => 30, tdCls => 'icon_column', renderer => 'TP.render_icon_log' },\n            { 'header' => 'Time',    dataIndex => 'time', width => 60, renderer => 'TP.render_date' },\n            { 'header' => 'Message', dataIndex => 'message', flex => 1 },\n        ],\n        data    => [],\n    };\n    for my $row (@{$data}) {\n        push @{$json->{'data'}}, {\n            icon    => Thruk::Utils::Filter::logline_icon($row),\n            time    => $row->{'time'},\n            message => substr($row->{'message'},13),\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_site_status {\n    my($c) = @_;\n\n    if(!$c->stash->{'pi_detail'} || scalar keys %{$c->stash->{'pi_detail'}} == 0) {\n        my $cached_data = $c->cache->get->{'global'} || {};\n        Thruk::Action::AddDefaults::set_processinfo($c, undef, undef, $cached_data, 1);\n    }\n\n    my $backend_filter;\n    if($c->req->parameters->{'backends'}) {\n        $backend_filter = {};\n        for my $b (ref $c->req->parameters->{'backends'} eq 'ARRAY' ? @{$c->req->parameters->{'backends'}} : $c->req->parameters->{'backends'}) {\n            $backend_filter->{$b} = 1;\n        }\n    }\n\n    my $json = {\n        columns => [\n            { 'header' => 'Id',               dataIndex => 'id',                      width => 45, hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Icon',             dataIndex => 'icon',                    width => 30, tdCls => 'icon_column', renderer => 'TP.render_icon_site' },\n            { 'header' => 'Category',         dataIndex => 'category',                width => 60, hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Section',          dataIndex => 'section',                 width => 60, hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Site',             dataIndex => 'site',                    width => 60, flex => 1 },\n            { 'header' => 'Version',          dataIndex => 'version',                 width => 50, renderer => 'TP.add_title' },\n            { 'header' => 'Runtime',          dataIndex => 'runtime',                 width => 85 },\n            { 'header' => 'Notifications',    dataIndex => 'enable_notifications',    width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Svc Checks',       dataIndex => 'execute_service_checks',  width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Hst Checks',       dataIndex => 'execute_host_checks',     width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Eventhandlers',    dataIndex => 'enable_event_handlers',   width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Performance Data', dataIndex => 'process_performance_data',width => 65, hidden => Cpanel::JSON::XS::true, align => 'center', renderer => 'TP.render_enabled_switch' },\n        ],\n        data    => [],\n    };\n\n    for my $key (@{$c->stash->{'backends'}}) {\n        next if($backend_filter && !defined $backend_filter->{$key});\n        my $b    = $c->stash->{'backend_detail'}->{$key};\n        my $d    = {};\n        $d       = $c->stash->{'pi_detail'}->{$key} if ref $c->stash->{'pi_detail'} eq 'HASH';\n        my $icon = 'exclamation.png';\n        if($b->{'running'} && $d->{'program_start'}) { $icon = 'accept.png'; }\n        my $runtime = \"\";\n        my $program_version = $b->{'last_error'};\n        if($b->{'running'} && $d->{'program_start'}) {\n            $runtime = Thruk::Utils::Filter::duration(time() - $d->{'program_start'});\n            $program_version = $d->{'program_version'};\n        }\n        my $row = {\n            id       => $key,\n            icon     => $icon,\n            site     => $b->{'name'},\n            version  => $program_version,\n            runtime  => $runtime,\n            section  => $b->{'section'},\n            category => $b->{'section'}, # keep for backwards compatibility\n        };\n        for my $attr (qw/enable_notifications execute_host_checks execute_service_checks\n                      enable_event_handlers process_performance_data/) {\n            $row->{$attr} = $d->{$attr};\n        }\n        push @{$json->{'data'}}, $row;\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_hosts {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'pageSize'};\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'currentPage'};\n\n    my $data = $c->db->get_hosts(filter        => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ],\n                                     pager         => 1,\n                                     extra_columns => [qw/long_plugin_output/],\n                                     sort          => _append_sort($c->req->parameters->{'sort'}, { ASC => [ 'name' ] }),\n                                    );\n\n    my $json = {\n        columns => [\n            { 'header' => 'Hostname',               width => 120, dataIndex => 'name',                                 renderer => 'TP.render_clickable_host' },\n            { 'header' => 'Icons',                  width => 75,  dataIndex => 'icons',             align => 'right',  renderer => 'TP.render_host_icons' },\n            { 'header' => 'Status',                 width => 80,  dataIndex => 'state',             align => 'center', renderer => 'TP.render_host_status' },\n            { 'header' => 'Last Check',             width => 80,  dataIndex => 'last_check',        align => 'center', renderer => 'TP.render_last_check' },\n            { 'header' => 'Duration',               width => 100, dataIndex => 'last_state_change', align => 'center', renderer => 'TP.render_duration' },\n            { 'header' => 'Attempt',                width => 60,  dataIndex => 'current_attempt',   align => 'center', renderer => 'TP.render_attempt' },\n            { 'header' => 'Site',                   width => 60,  dataIndex => 'peer_name',         align => 'center', renderer => 'TP.render_peer_name' },\n            { 'header' => 'Status Information',     flex  => 1,   dataIndex => 'plugin_output',                        renderer => 'TP.render_plugin_output' },\n            { 'header' => 'Performance',            width => 80,  dataIndex => 'perf_data',                            renderer => 'TP.render_perfbar' },\n\n            { 'header' => 'Parents',                  dataIndex => 'parents',                     hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_clickable_host_list' },\n            { 'header' => 'Current Attempt',          dataIndex => 'current_attempt',             hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Max Check Attempts',       dataIndex => 'max_check_attempts',          hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Last State Change',        dataIndex => 'last_state_change',           hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Check Type',               dataIndex => 'check_type',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_check_type' },\n            { 'header' => 'Site ID',                  dataIndex => 'peer_key',                    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Has Been Checked',         dataIndex => 'has_been_checked',            hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Active Checks Enabled',    dataIndex => 'active_checks_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Accept Passive Checks',    dataIndex => 'accept_passive_checks',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Next Check',               dataIndex => 'next_check',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Notification Number',      dataIndex => 'current_notification_number', hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'First Notification Delay', dataIndex => 'first_notification_delay',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Notifications Enabled',    dataIndex => 'notifications_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Is Flapping',              dataIndex => 'is_flapping',                 hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Acknowledged',             dataIndex => 'acknowledged',                hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Comments',                 dataIndex => 'comments',                    hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Scheduled Downtime Depth', dataIndex => 'scheduled_downtime_depth',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Action Url',               dataIndex => 'action_url_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_action_url' },\n            { 'header' => 'Notes url',                dataIndex => 'notes_url_expanded',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_notes_url' },\n            { 'header' => 'Notes',                    dataIndex => 'notes',                       hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Icon Image',               dataIndex => 'icon_image_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_icon_url' },\n            { 'header' => 'Icon Image Alt',           dataIndex => 'icon_image_alt',              hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Names',    dataIndex => 'custom_variable_names',       hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Values',   dataIndex => 'custom_variable_values',      hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Long Plugin Output',       dataIndex => 'long_plugin_output',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_long_pluginoutput' },\n\n            { 'header' => 'Last Time Up',          dataIndex => 'last_time_up',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Unreachable', dataIndex => 'last_time_unreachable', hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Down',        dataIndex => 'last_time_down',        hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n        ],\n        data        => $c->stash->{'data'},\n        totalCount  => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    if($c->config->{'show_custom_vars'} || $c->config->{'expose_custom_vars'}) {\n        for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n            $var =~ s/^_//gmx;\n            push @{$json->{'columns'}},\n            { 'header' => $var, dataIndex => $var, hidden => Cpanel::JSON::XS::true };\n        }\n        for my $h ( @{$c->stash->{'data'}}) {\n            my $cust = Thruk::Utils::get_custom_vars($c, $h);\n            for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n                $var =~ s/^_//gmx;\n                $h->{$var} = $cust->{$var} // '';\n            }\n            $h->{'THRUK_ACTION_MENU'} = $cust->{'THRUK_ACTION_MENU'} // '';\n        }\n    }\n    if(!$c->check_user_roles(\"authorized_for_configuration_information\")) {\n        # remove custom macro colums which could contain confidential informations\n        for my $h ( @{$c->stash->{'data'}}) {\n            delete $h->{'custom_variable_names'};\n            delete $h->{'custom_variable_values'};\n        }\n    }\n\n    if($c->stash->{'escape_html_tags'} or $c->stash->{'show_long_plugin_output'} eq 'inline') {\n        for my $h ( @{$c->stash->{'data'}}) {\n            _escape($h)      if $c->stash->{'escape_html_tags'};\n            _long_plugin($h) if $c->stash->{'show_long_plugin_output'} eq 'inline';\n        }\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_services {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'pageSize'};\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'currentPage'};\n\n    $c->db->get_services(filter        => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter],\n                             pager         => 1,\n                             extra_columns => [qw/long_plugin_output/],\n                             sort          => _append_sort($c->req->parameters->{'sort'}, { ASC => [ 'host_name',   'description' ] }),\n                            );\n\n    my $json = {\n        columns => [\n            { 'header' => 'Hostname',               width => 120, dataIndex => 'host_display_name',                    renderer => 'TP.render_service_host' },\n            { 'header' => 'Host',                                 dataIndex => 'host_name',         hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Host Icons',             width => 75,  dataIndex => 'icons',             align => 'right',  renderer => 'TP.render_host_service_icons' },\n            { 'header' => 'Service',                width => 120, dataIndex => 'display_name',                         renderer => 'TP.render_clickable_service' },\n            { 'header' => 'Description',                          dataIndex => 'description',       hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Icons',                  width => 75,  dataIndex => 'icons',             align => 'right',  renderer => 'TP.render_service_icons' },\n            { 'header' => 'Status',                 width => 70,  dataIndex => 'state',             align => 'center', renderer => 'TP.render_service_status' },\n            { 'header' => 'Last Check',             width => 80,  dataIndex => 'last_check',        align => 'center', renderer => 'TP.render_last_check' },\n            { 'header' => 'Duration',               width => 100, dataIndex => 'last_state_change', align => 'center', renderer => 'TP.render_duration' },\n            { 'header' => 'Attempt',                width => 60,  dataIndex => 'current_attempt',   align => 'center', renderer => 'TP.render_attempt' },\n            { 'header' => 'Site',                   width => 60,  dataIndex => 'peer_name',         align => 'center', renderer => 'TP.render_peer_name' },\n            { 'header' => 'Status Information',     flex  => 1,   dataIndex => 'plugin_output',                        renderer => 'TP.render_plugin_output' },\n            { 'header' => 'Performance',            width => 80,  dataIndex => 'perf_data',                            renderer => 'TP.render_perfbar' },\n\n            { 'header' => 'Current Attempt',          dataIndex => 'current_attempt',             hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Max Check Attempts',       dataIndex => 'max_check_attempts',          hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Last State Change',        dataIndex => 'last_state_change',           hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Check Type',               dataIndex => 'check_type',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_check_type' },\n            { 'header' => 'Site ID',                  dataIndex => 'peer_key',                    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Has Been Checked',         dataIndex => 'has_been_checked',            hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Active Checks Enabled',    dataIndex => 'active_checks_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Accept Passive Checks',    dataIndex => 'accept_passive_checks',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Next Check',               dataIndex => 'next_check',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Notification Number',      dataIndex => 'current_notification_number', hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'First Notification Delay', dataIndex => 'first_notification_delay',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Notifications Enabled',    dataIndex => 'notifications_enabled',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Is Flapping',              dataIndex => 'is_flapping',                 hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Acknowledged',             dataIndex => 'acknowledged',                hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Comments',                 dataIndex => 'comments',                    hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Scheduled Downtime Depth', dataIndex => 'scheduled_downtime_depth',    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Action Url',               dataIndex => 'action_url_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_action_url' },\n            { 'header' => 'Notes url',                dataIndex => 'notes_url_expanded',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_notes_url' },\n            { 'header' => 'Icon Image',               dataIndex => 'icon_image_expanded',         hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_icon_url' },\n            { 'header' => 'Icon Image Alt',           dataIndex => 'icon_image_alt',              hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Names',    dataIndex => 'custom_variable_names',       hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Custom Variable Values',   dataIndex => 'custom_variable_values',      hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Long Plugin Output',       dataIndex => 'long_plugin_output',          hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_long_pluginoutput' },\n\n            { 'header' => 'Host Parents',                   dataIndex => 'host_parents',                  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_clickable_host_list' },\n            { 'header' => 'Host Status',                    dataIndex => 'host_state',                    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_host_status' },\n            { 'header' => 'Host Notifications Enabled',     dataIndex => 'host_notifications_enabled',    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_enabled_switch' },\n            { 'header' => 'Host Check Type',                dataIndex => 'host_check_type',               hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_check_type' },\n            { 'header' => 'Host Active Checks Enabled',     dataIndex => 'host_active_checks_enabled',    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Accept Passive Checks',     dataIndex => 'host_accept_passive_checks',    hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Is Flapping',               dataIndex => 'host_is_flapping',              hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Acknowledged',              dataIndex => 'host_acknowledged',             hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_yes_no' },\n            { 'header' => 'Host Comments',                  dataIndex => 'host_comments',                 hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Host Scheduled Downtime Depth',  dataIndex => 'host_scheduled_downtime_depth', hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Host Action Url',                dataIndex => 'host_action_url_expanded',      hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_action_url' },\n            { 'header' => 'Host Notes Url',                 dataIndex => 'host_notes_url_expanded',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_notes_url' },\n            { 'header' => 'Host Notes',                     dataIndex => 'host_notes',                    hidden => Cpanel::JSON::XS::true },\n            { 'header' => 'Host Icon Image',                dataIndex => 'host_icon_image_expanded',      hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_icon_url' },\n            { 'header' => 'Host Icon Image Alt',            dataIndex => 'host_icon_image_alt',           hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Host Custom Variable Names',     dataIndex => 'host_custom_variable_names',    hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n            { 'header' => 'Host Custom Variable Values',    dataIndex => 'host_custom_variable_values',   hidden => Cpanel::JSON::XS::true, hideable => Cpanel::JSON::XS::false },\n\n            { 'header' => 'Last Time Ok',       dataIndex => 'last_time_ok',       hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Warning',  dataIndex => 'last_time_warning',  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Unknown',  dataIndex => 'last_time_unknown',  hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n            { 'header' => 'Last Time Critical', dataIndex => 'last_time_critical', hidden => Cpanel::JSON::XS::true, renderer => 'TP.render_date' },\n        ],\n        data        => $c->stash->{'data'},\n        totalCount  => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    if($c->config->{'show_custom_vars'} || $c->config->{'expose_custom_vars'}) {\n        for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n            $var =~ s/^_//gmx;\n            push @{$json->{'columns'}},\n            { 'header' => $var, dataIndex => $var, hidden => Cpanel::JSON::XS::true };\n        }\n    }\n    for my $s ( @{$c->stash->{'data'}}) {\n        my $cust = Thruk::Utils::get_custom_vars($c, $s, undef, 1);\n        for my $var (@{Thruk::Utils::get_exposed_custom_vars($c->config, 1)}) {\n            $var =~ s/^_//gmx;\n            $s->{$var} = $cust->{$var} // $cust->{'HOST'.$var} // '';\n        }\n        $s->{'THRUK_ACTION_MENU'}     = $cust->{'THRUK_ACTION_MENU'} // '';\n        $s->{'HOSTTHRUK_ACTION_MENU'} = $cust->{'HOSTTHRUK_ACTION_MENU'} // '';\n    }\n    if(!$c->check_user_roles(\"authorized_for_configuration_information\")) {\n        # remove custom macro colums which could contain confidential informations\n        for my $s ( @{$c->stash->{'data'}}) {\n            delete $s->{'host_custom_variable_names'};\n            delete $s->{'host_custom_variable_values'};\n            delete $s->{'custom_variable_names'};\n            delete $s->{'custom_variable_values'};\n        }\n    }\n\n    if($c->stash->{'escape_html_tags'} or $c->stash->{'show_long_plugin_output'} eq 'inline') {\n        for my $s ( @{$c->stash->{'data'}}) {\n            _escape($s)      if $c->stash->{'escape_html_tags'};\n            _long_plugin($s) if $c->stash->{'show_long_plugin_output'} eq 'inline';\n        }\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_squares_data {\n    my($c) = @_;\n\n    my $source = $c->req->parameters->{'source'} || 'hosts';\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $now          = time();\n    my $data         = [];\n    my $allowed      = $c->check_user_roles(\"authorized_for_configuration_information\");\n    my $allowed_list = Thruk::Utils::get_exposed_custom_vars($c->config);\n\n    my $show_full_commandline = $c->config->{'show_full_commandline'};\n    if($source eq 'services' || $source eq 'both') {\n        my $services = $c->db->get_services(\n                                    filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter],\n                                    columns => [qw/host_name description state acknowledged scheduled_downtime_depth has_been_checked last_state_change/, $c->req->parameters->{'service_label'} ? qw/host_alias custom_variable_names custom_variable_values host_custom_variable_names host_custom_variable_values/ : ()],\n                                    sort    => { ASC => [ 'host_name',   'description' ] },\n                                );\n        for my $svc (@{$services}) {\n            Thruk::Utils::set_allowed_rows_data($svc, $allowed, $allowed_list, $show_full_commandline);\n            push @{$data}, { uniq         => $svc->{'host_name'}.';'.$svc->{'description'},\n                             name         => $c->req->parameters->{'service_label'} ? _squares_data_label($svc, $c->req->parameters->{'service_label'}) : $svc->{'host_name'}.' - '.$svc->{'description'},\n                             host_name    => $svc->{'host_name'},\n                             description  => $svc->{'description'},\n                             state        => $svc->{'has_been_checked'} == 0 ? 4 : $svc->{'state'},\n                             downtime     => $svc->{'scheduled_downtime_depth'},\n                             acknowledged => $svc->{'acknowledged'},\n                             link         => 'extinfo.cgi?type=2&host='.$svc->{'host_name'}.\"&service=\".$svc->{'description'},\n                             duration     => $now - $svc->{'last_state_change'},\n                             isHost       => 0,\n                           };\n        }\n    }\n\n    if($source eq 'hosts' || $source eq 'both') {\n        my $hosts = $c->db->get_hosts(\n                                    filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter],\n                                    columns => [qw/name state acknowledged scheduled_downtime_depth has_been_checked last_state_change/, $c->req->parameters->{'host_label'} ? qw/alias custom_variable_names custom_variable_values/ : ()],\n                                    sort    => { ASC => [ 'name' ] },\n                                );\n        for my $hst (@{$hosts}) {\n            Thruk::Utils::set_allowed_rows_data($hst, $allowed, $allowed_list, $show_full_commandline);\n            push @{$data}, { uniq         => $hst->{'name'},\n                             name         => $c->req->parameters->{'host_label'} ? _squares_data_label($hst, $c->req->parameters->{'host_label'}) : $hst->{'name'},\n                             host_name    => $hst->{'name'},\n                             description  => '',\n                             state        => $hst->{'state'},\n                             downtime     => $hst->{'scheduled_downtime_depth'},\n                             acknowledged => $hst->{'acknowledged'},\n                             link         => 'extinfo.cgi?type=1&host='.$hst->{'name'},\n                             duration     => $now - $hst->{'last_state_change'},\n                             isHost       => 1,\n                            };\n        }\n    }\n\n    # need to sort by host/service again\n    if($source eq 'both') {\n        $data = Thruk::Backend::Manager::sort_result({}, $data, 'uniq');\n    }\n\n    # apply group by\n    if($c->req->parameters->{'groupby'}) {\n        my $groupby = Thruk::Base::list($c->req->parameters->{'groupby'});\n        if(scalar @{$groupby} == 2 && $groupby->[0] eq 'host_name' && $groupby->[1] eq 'description') {\n            # nothing todo\n        }\n        elsif(scalar @{$groupby} == 1 && $groupby->[0] eq 'host_name' && $source eq 'hosts') {\n            # nothing todo\n        } else {\n            my $grouped_data = {};\n            for my $d (@{$data}) {\n                my $uniq = [];\n                for my $key (@{$groupby}) {\n                    push @{$uniq}, $d->{$key};\n                }\n                $uniq = join(\" - \", @{$uniq});\n                my $details = {\n                    'host_name'    => $d->{'host_name'},\n                    'description'  => $d->{'description'},\n                    'state'        => $d->{'state'},\n                    'duration'     => $d->{'duration'},\n                    'acknowledged' => $d->{'acknowledged'},\n                    'downtime'     => $d->{'downtime'},\n                    'isHost'       => $d->{'isHost'},\n                };\n                if(!$grouped_data->{$uniq}) {\n                    $grouped_data->{$uniq} = $d;\n                    $grouped_data->{$uniq}->{'uniq'}    = $uniq;\n                    $grouped_data->{$uniq}->{'name'}    = $uniq;\n                    $grouped_data->{$uniq}->{'details'} = [$details];\n                    delete $grouped_data->{$uniq}->{'link'};\n                } else {\n                    my $comb = $grouped_data->{$uniq};\n                    if($d->{'state'} > 0 && $d->{'state'} != 4) {\n                        my $worse = 0;\n                        if(!$d->{'acknowledged'} && $comb->{'acknowledged'}) {\n                            $worse = 1;\n                        }\n                        elsif(!$d->{'downtime'} && $comb->{'downtime'}) {\n                            $worse = 1;\n                        }\n                        elsif($d->{'isHost'} && !$comb->{'isHost'}) {\n                            $worse = 1;\n                        }\n                        elsif($comb->{'isHost'} && $comb->{'state'} != 0) {\n                            # host state beats every service\n                        }\n                        elsif($d->{'state'} > $comb->{'state'}) {\n                            $worse = 1;\n                        }\n                        if($worse) {\n                            $comb->{'state'}        = $d->{'state'};\n                            $comb->{'isHost'}       = $d->{'isHost'};\n                            $comb->{'downtime'}     = $d->{'downtime'};\n                            $comb->{'acknowledged'} = $d->{'acknowledged'};\n                            $comb->{'duration'}     = $d->{'duration'};\n                        }\n                    }\n                    if($comb->{'duration'} > $d->{'duration'} && $comb->{'state'} == $d->{'state'} && $comb->{'isHost'} == $d->{'isHost'}) {\n                        $comb->{'duration'} = $d->{'duration'};\n                    }\n                    push @{$grouped_data->{$uniq}->{'details'}}, $details;\n                }\n            }\n            $data = [];\n            for my $key (sort keys %{$grouped_data}) {\n                push @{$data}, $grouped_data->{$key};\n            }\n        }\n    }\n\n    my $json = {\n        data => $data,\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _squares_data_label {\n    my($obj, $label) = @_;\n    my $res = $label;\n    for my $key (qw/host_name host_alias name alias description/) {\n        my $val = $obj->{$key} // '';\n        $res =~ s|\\{\\{$key\\}\\}|$val|gmxi;\n    }\n    if($obj->{'custom_variables'}) {\n        for my $key (sort keys %{$obj->{'custom_variables'}}) {\n            my $val = $obj->{'custom_variables'}->{$key} // '';\n            $res =~ s|\\{\\{_$key\\}\\}|$val|gmxi;\n        }\n    }\n    if($obj->{'host_custom_variables'}) {\n        for my $key (sort keys %{$obj->{'custom_variables'}}) {\n            my $val = $obj->{'custom_variables'}->{$key} // '';\n            $res =~ s|\\{\\{_HOST$key\\}\\}|$val|gmxi;\n        }\n    }\n    # remove all remaining placeholder\n    $res =~ s|\\{\\{.*?\\}\\}||gmxi;\n    return($res);\n}\n\n##########################################################\nsub _task_hosttotals {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n    Thruk::Utils::Status::fill_totals_box( $c, $hostfilter, undef, 1);\n\n    my $s = $c->stash->{'host_stats'};\n    my $json = {\n        columns => [\n            { 'header' => '#',     width => 40, dataIndex => 'count', align => 'right', renderer => 'TP.render_statuscount' },\n            { 'header' => 'State', flex  => 1,  dataIndex => 'state' },\n        ],\n        data      => [],\n    };\n\n    for my $state (qw/up down unreachable pending/) {\n        push @{$json->{'data'}}, {\n            state => ucfirst $state,\n            count => $s->{$state},\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_servicetotals {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n    Thruk::Utils::Status::fill_totals_box( $c, undef, $servicefilter, 1 );\n\n    my $s = $c->stash->{'service_stats'};\n    my $json = {\n        columns => [\n            { 'header' => '#',     width => 40, dataIndex => 'count', align => 'right', renderer => 'TP.render_statuscount' },\n            { 'header' => 'State', flex  => 1,  dataIndex => 'state' },\n        ],\n        data      => [],\n    };\n\n    for my $state (qw/ok warning unknown critical pending/) {\n        push @{$json->{'data'}}, {\n            state => ucfirst $state,\n            count => $s->{$state},\n        };\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_hosts_pie {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $data = $c->db->get_host_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter]);\n\n    my $json = {\n        columns => [\n            { 'header' => 'Name',      dataIndex => 'name' },\n            { 'header' => 'Data',      dataIndex => 'value' },\n        ],\n        colors    => [ ],\n        data      => [],\n    };\n    my $colors = {\n        up          => '#00FF33',\n        down        => '#FF5B33',\n        unreachable => '#FF7A59',\n        pending     => '#ACACAC',\n    };\n\n    for my $state (qw/up down unreachable pending/) {\n        next if $data->{$state} == 0;\n        push @{$json->{'data'}}, {\n            name    => ucfirst $state,\n            value   => $data->{$state},\n        };\n        push @{$json->{'colors'}}, $colors->{$state};\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_services_pie {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $data = $c->db->get_service_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter]);\n\n    my $json = {\n        columns => [\n            { 'header' => 'Name',      dataIndex => 'name' },\n            { 'header' => 'Data',      dataIndex => 'value' },\n        ],\n        colors    => [],\n        data      => [],\n    };\n    my $colors = {\n        ok       => '#00FF33',\n        warning  => '#FFDE00',\n        unknown  => '#FF9E00',\n        critical => '#FF5B33',\n        pending  => '#ACACAC',\n    };\n\n    for my $state (qw/ok warning unknown critical pending/) {\n        next if $data->{$state} == 0;\n        push @{$json->{'data'}}, {\n            name    => ucfirst $state,\n            value   => $data->{$state},\n        };\n        push @{$json->{'colors'}}, $colors->{$state};\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_servicesminemap {\n    my($c) = @_;\n\n    my( $hostfilter, $servicefilter, $groupfilter ) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my($uniq_services, $hosts, $matrix) = Thruk::Utils::Status::get_service_matrix($c, $hostfilter, $servicefilter);\n\n    # automatically adjust service column hight\n    my $longest_description = 0;\n    for my $svc (sort keys %{$uniq_services}) {\n        my $l = length($svc);\n        $longest_description = $l if $l > $longest_description;\n    }\n    my $height = 15 + int($longest_description * 5.70);\n    $height    =  40 if $height <  40;\n    $height    = 300 if $height > 300;\n\n    my $service2index = {};\n    my $json = {\n        columns => [\n            { 'header'       => '<div class=\"minemap_first_col\" style=\"top: '.($height/2-10).'px;\">Hostname</div>',\n              'headerIE'     => '<div class=\"minemap_first_col\" style=\"top: '.($height-25).'px;\">Hostname</div>',\n              'headerChrome' => '<div class=\"minemap_first_col\" style=\"bottom: 0px;\">Hostname</div>',\n              'width'        => 120,\n              'height'       => $height,\n              'dataIndex'    => 'host_display_name',\n            },\n        ],\n        data        => [],\n    };\n\n    my $x=0;\n    for my $svc (sort keys %{$uniq_services}) {\n        my $index = 'col'.$x;\n        $service2index->{$svc} = $index;\n        push @{$json->{'columns'}}, {\n                    'header'       => '<div class=\"vertical\" style=\"top: '.($height/2-10).'px;\">'.$svc.'</div>',\n                    'headerIE'     => '<div class=\"vertical\" style=\"top: 8px; width: '.($height-25).'px; right: '.($height/2-16).'px;\">'.$svc.'</div>',\n                    'headerChrome' => '<div class=\"vertical\" style=\"top: '.($height/2-10).'px;\">'.$svc.'</div>',\n                    'width'        => 20,\n                    'height'       => $height,\n                    'dataIndex'    => $index,\n                    'align'        => 'center',\n                    'tdCls'        => 'mine_map_cell',\n        };\n        $x++;\n    }\n    for my $name (sort keys %{$hosts}) {\n        my $hst  = $hosts->{$name};\n        my $data;\n        if ($hst->{'host_action_url_expanded'}) {\n            $data = { 'host_display_name' => $hst->{'host_display_name'} . \"&nbsp;<a target='_blank' href='\".$hst->{'host_action_url_expanded'}.\"' style='position: relative;'><i class='fa-solid fa-chart-line clickable' title='Show Performance Chart'></i></a>\" };\n        } else {\n            $data = { 'host_display_name' => $hst->{'host_display_name'} };\n        }\n\n        for my $svc (keys %{$uniq_services}) {\n            my $service = $matrix->{$name}->{$svc};\n            next unless defined $service->{state};\n            my $cls     = 'mine_map_state'.$service->{state};\n            $cls        = 'mine_map_state4' if $service->{has_been_checked} == 0;\n            my $text    = '&nbsp;';\n            if($service->{'scheduled_downtime_depth'}) { $text = '<i class=\"fa-solid fa-moon\" title=\"downtime\" style=\"font-size: 14px; line-height: 16px;\"></i>' }\n            if($service->{'acknowledged'})             { $text = '<i class=\"fa-solid fa-person-digging\" title=\"acknowledged\" style=\"font-size: 14px; line-height: 16px;\"></i>' }\n            $data->{$service2index->{$svc}} = '<div class=\"clickable '.$cls.'\" '._generate_service_popup($c, $service).'>'.$text.'</div>';\n        }\n        push @{$json->{'data'}}, $data;\n    }\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_show_comments {\n    my($c) = @_;\n\n    my($hostfilter, $servicefilter, undef, undef, $has_service_filter) = _do_filter($c);\n    return if $c->stash->{'has_error'};\n\n    my $source = $c->req->parameters->{'source'} || 'both';\n\n    my $generalfilter;\n    if($source eq 'hosts') {\n        push @{$generalfilter},  { service_description => { '=' => '' }};\n    }\n    elsif($source eq 'services') {\n        push @{$generalfilter},  { service_description => { '!=' => '' }};\n    }\n\n    if($hostfilter && ($source eq 'hosts' || $source eq 'both')) {\n        my $hosts = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ], columns => [qw/name/]);\n        my $host_comments_filter = [{ host_name => ''}]; # add useless filter, so the -or will not match on empty hostlists\n        for my $hst (@{$hosts}) {\n            push @{$host_comments_filter}, { host_name => $hst->{'name'}};\n        }\n        push @{$generalfilter},  Thruk::Utils::combine_filter( '-or', $host_comments_filter );\n    }\n\n    if($servicefilter && ($source eq 'services' || $source eq 'both')) {\n        my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ], columns => [qw/host_name description/]);\n        my $svc_comments_filter = [{ host_name => ''}]; # add useless filter, so the -or will not match on empty servicelists\n        for my $svc (@{$services}) {\n            push @{$svc_comments_filter}, [{ host_name => $svc->{'host_name'}}, { service_description => $svc->{'service_description'}}];\n        }\n        push @{$generalfilter}, Thruk::Utils::combine_filter( '-or', $svc_comments_filter );\n    }\n\n    my $types = Thruk::Base::list($c->req->parameters->{'type'});\n    my $commentfilter = [];\n    my $typesfilter   = [];\n    my $add_downtimes = 0;\n    my $add_comments  = 0;\n    for my $t (@{$types}) {\n        if(   $t eq 'comment')  { $add_comments  = 1; push @{$typesfilter}, { entry_type => 1 }; }\n        elsif($t eq 'flap')     { $add_comments  = 1; push @{$typesfilter}, { entry_type => 3 }; }\n        elsif($t eq 'ack')      { $add_comments  = 1; push @{$typesfilter}, { entry_type => 4 }; }\n        elsif($t eq 'downtime') { $add_downtimes = 1; }\n    }\n    push @{$commentfilter}, Thruk::Utils::combine_filter( '-or', $typesfilter );\n\n    my $data = [];\n    if($add_comments) {\n        $data = $c->db->get_comments(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'comments'), $generalfilter, $commentfilter ]);\n        # move some fields to match downtimes\n        for my $d (@{$data}) {\n            $d->{'start_time'} = $d->{'entry_time'};\n            $d->{'end_time'}   = -1;\n        }\n    }\n\n    if($add_downtimes) {\n        my $downtimes = $c->db->get_downtimes(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'downtimes'), $generalfilter ]);\n        for my $d (@{$downtimes}) {\n            $d->{'entry_type'} = 2;\n        }\n        push @{$data}, @{$downtimes};\n    }\n\n    my $include = $c->req->parameters->{'pattern'};\n    if($include) {\n        my $filtered = [];\n        for my $d (@{$data}) {\n            ## no critic\n            if($d->{'author'} =~ m/$include/ || $d->{'comment'} =~ m/$include/) {\n                push @{$filtered}, $d;\n            }\n            ## use critic\n        }\n        $data = $filtered;\n    }\n\n    my $exclude = $c->req->parameters->{'exclude'};\n    if($exclude) {\n        my $filtered = [];\n        for my $d (@{$data}) {\n            ## no critic\n            if($d->{'author'} !~ m/$exclude/ && $d->{'comment'} !~ m/$exclude/) {\n                push @{$filtered}, $d;\n            }\n            ## use critic\n        }\n        $data = $filtered;\n    }\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'pageSize'};\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'currentPage'};\n    $data = [sort { $a->{'host_name'} cmp $b->{'host_name'} || $a->{'service_description'} cmp $b->{'service_description'} } @{$data}];\n    Thruk::Utils::page_data($c, $data);\n    my $json = {\n        columns => [\n            { 'header' => 'Hostname',               width => 120, dataIndex => 'host_name',           renderer => 'TP.render_service_host' },\n            { 'header' => 'Service',                width => 120, dataIndex => 'service_description', renderer => 'TP.render_clickable_service' },\n            { 'header' => 'Type',                   width => 120, dataIndex => 'entry_type',          renderer => 'TP.render_entry_type'    },\n            { 'header' => 'Start Time',             width => 120, dataIndex => 'start_time',          align => 'right', renderer => 'TP.render_date' },\n            { 'header' => 'End Time',               width => 120, dataIndex => 'end_time',            align => 'right', renderer => 'TP.render_date' },\n            { 'header' => 'Entry Time',             width => 120, dataIndex => 'entry_time',          hidden => Cpanel::JSON::XS::true, align => 'right', renderer => 'TP.render_date' },\n            { 'header' => 'Author',                 width => 100, dataIndex => 'author',              },\n            { 'header' => 'Comment',                flex  => 1,   dataIndex => 'comment',             },\n            { 'header' => 'ID',                                   dataIndex => 'id',                  hidden => Cpanel::JSON::XS::true },\n        ],\n        data        => $c->stash->{'data'},\n        totalCount  => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_pnp_graphs {\n    my($c) = @_;\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    my $search  = $c->req->parameters->{'query'};\n    my $graphs  = [];\n    my $current;\n\n    my $data = _fetch_graph_hosts($c, $search, $c->config->{'pnp_url_regex'});\n    for my $hst (@{$data}) {\n        my $text = $hst->{'name'}.';_HOST_';\n        next if($search and $text !~ m/$search/mxi);\n        my $url = Thruk::Utils::get_pnp_url($c, $hst, 1);\n        if($url ne '') {\n            push @{$graphs}, {\n                text => $text,\n                url  => $url.'/image?host='.$hst->{'name'}.'&srv=_HOST_',\n            };\n        }\n    }\n\n    $data = _fetch_graph_services($c, $search, $c->config->{'pnp_url_regex'});\n    for my $svc (@{$data}) {\n        my $text = $svc->{'host_name'}.';'.$svc->{'description'};\n        next if($search and $text !~ m/$search/mxi);\n        my $url = Thruk::Utils::get_pnp_url($c, $svc, 1);\n        if($url ne '') {\n            push @{$graphs}, {\n                text => $text,\n                url  => $url.'/image?host='.$svc->{'host_name'}.'&srv='.$svc->{'description'},\n            };\n        }\n    }\n    $graphs = Thruk::Backend::Manager::sort_result({}, $graphs, 'text');\n    Thruk::Utils::page_data($c, $graphs);\n\n    # make sure current graph is always part of the result\n    push @{$c->stash->{'data'}}, $current if $current;\n\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_grafana_graphs {\n    my($c) = @_;\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    my $search  = $c->req->parameters->{'query'};\n    my $search2 = $c->req->parameters->{'query2'}; # current selected graph should always be returned, otherwise text/alias replacement does not work on paging\n    my $graphs  = [];\n    my $current;\n\n    my $data = _fetch_graph_hosts($c, $search, $c->config->{'grafana_url_regex'});\n    for my $hst (@{$data}) {\n        my $url = Thruk::Utils::get_histou_url($c, $hst, 1);\n        if($url ne '') {\n            my $text   = $hst->{'name'}.';';\n            my $exturl = 'extinfo.cgi?type=grafana&host='.$hst->{'name'};\n            if($search2 && $exturl eq $search2) {\n                $current = {\n                    text       => $text,\n                    url        => $exturl,\n                    source_url => $url,\n                };\n            }\n            next if($search && $text !~ m/$search/mxi && $exturl ne $search);\n            push @{$graphs}, {\n                text       => $text,\n                url        => $exturl,\n                source_url => $url,\n            };\n        }\n    }\n\n    $data = _fetch_graph_services($c, $search, $c->config->{'grafana_url_regex'});\n    for my $svc (@{$data}) {\n        my $url = Thruk::Utils::get_histou_url($c, $svc, 1);\n        if($url ne '') {\n            my $text   = $svc->{'host_name'}.';'.$svc->{'description'};\n            my $exturl = 'extinfo.cgi?type=grafana&host='.$svc->{'host_name'}.'&service='.$svc->{'description'};\n            if($search2 && $exturl eq $search2) {\n                $current = {\n                    text       => $text,\n                    url        => $exturl,\n                    source_url => $url,\n                };\n            }\n            next if($search && $text !~ m/$search/mxi && $exturl ne $search);\n            push @{$graphs}, {\n                text       => $text,\n                url        => $exturl,\n                source_url => $url,\n            };\n        }\n    }\n    $graphs = Thruk::Backend::Manager::sort_result({}, $graphs, 'text');\n    Thruk::Utils::page_data($c, $graphs);\n\n    # make sure current graph is always part of the result\n    push @{$c->stash->{'data'}}, $current if $current;\n\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _fetch_graph_hosts {\n    my($c, $search, $url_regex) = @_;\n    my $data = [];\n\n    my $graphfilter = { '-or' => [\n        { action_url_expanded => { '~~' => $url_regex } },\n        { notes_url_expanded  => { '~~' => $url_regex } },\n    ]};\n    my($hostfilter, $servicefilter) = split(/;/mx, ($search//''), 2);\n    my $filter = [];\n    if($hostfilter) {\n        push @{$filter}, { name => { '~~' => $hostfilter } };\n    }\n    if(!$servicefilter || '_HOST_' =~ m/$servicefilter/mxi) {\n        $data = $c->db->get_hosts(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $graphfilter, $filter ],\n                                  columns => [qw/name action_url_expanded notes_url_expanded/],\n                                  limit   => 1000, # avoid timeouts and unresponsive js\n                                 );\n    }\n    return($data);\n}\n\n##########################################################\nsub _fetch_graph_services {\n    my($c, $search, $url_regex) = @_;\n    my $data = [];\n\n    my $graphfilter = { '-or' => [\n        { action_url_expanded => { '~~' => $url_regex } },\n        { notes_url_expanded  => { '~~' => $url_regex } },\n    ]};\n    my($hostfilter, $servicefilter) = split(/;/mx, ($search//''), 2);\n    my $filter = [];\n    if($hostfilter) {\n        push @{$filter}, { host_name => { '~~' => $hostfilter } };\n    }\n    if($servicefilter) {\n        push @{$filter}, { description => { '~~' => $servicefilter } };\n    }\n    $data = $c->db->get_services(filter  => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $graphfilter, $filter ],\n                                 columns => [qw/host_name description action_url_expanded notes_url_expanded/],\n                                 limit   => 1000, # avoid timeouts and unresponsive js\n                                );\n    return($data);\n}\n\n##########################################################\nsub _task_userdata_backgroundimages {\n    my($c) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/backgrounds/';\n    my $query  = $c->req->parameters->{'query'};\n    my $images = [];\n    my $files = Thruk::Utils::IO::find_files($folder, '\\.(png|gif|jpg|jpeg|svg)$') || [];\n    for my $img (@{$files}) {\n        my $path = $img;\n        $path    =~ s/^\\Q$folder\\E//gmx;\n        next if $query and $path !~ m/\\Q$query\\E/mx;\n        my $name = $path;\n        $name    =~ s/^.*\\///gmx;\n        push @{$images}, {\n            path  => '../usercontent/backgrounds/'.$path,\n            image => $path,\n        };\n    }\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    $images = Thruk::Backend::Manager::sort_result({}, $images, 'path');\n    if(!$query) {\n        unshift @{$images}, { path => $c->stash->{'url_prefix'}.'plugins/panorama/images/s2.gif', image => '&lt;upload new image&gt;'};\n        unshift @{$images}, { path => $c->stash->{'url_prefix'}.'plugins/panorama/images/s.gif',  image => 'none'};\n    }\n    Thruk::Utils::page_data($c, $images);\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_images {\n    my($c) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/images/';\n    my $query  = $c->req->parameters->{'query'};\n    my $images = [];\n    my $files = Thruk::Utils::IO::find_files($folder, '\\.(png|gif|jpg|jpeg|svg)$') || [];\n    for my $img (@{$files}) {\n        my $path = $img;\n        $path    =~ s/^\\Q$folder\\E//gmx;\n        next if $query and $path !~ m/\\Q$query\\E/mx;\n        my $name = $path;\n        $name    =~ s/^.*\\///gmx;\n        push @{$images}, {\n            path  => '../usercontent/images/'.$path,\n            image => $path,\n        };\n    }\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} || 15;\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    $images = Thruk::Backend::Manager::sort_result({}, $images, 'path');\n    if(!$query) {\n        unshift @{$images}, { path => $c->stash->{'url_prefix'}.'plugins/panorama/images/s2.gif', image => '&lt;upload new image&gt;'};\n    }\n    Thruk::Utils::page_data($c, $images);\n    my $json = {\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_iconsets {\n    my($c, $return_only) = @_;\n    my $folder  = $c->stash->{'usercontent_folder'}.'/images/status';\n    my $folders = [];\n    for my $f (glob(\"$folder/*/.\")) {\n        my $name = $f;\n        $name    =~ s/^\\Q$folder\\E//gmx;\n        $name    =~ s/^\\///gmx;\n        $name    =~ s/\\/\\.$//gmx;\n        my $fileset = {};\n        for my $pic (glob(\"$folder/$name/*.gif $folder/$name/*.jpg $folder/$name/*.png $folder/$name/*.svg\")) {\n            $pic =~ s|\\Q$folder/$name/\\E||gmx;\n            my $type = $pic;\n            $type =~ s/\\.(png|gif|jpg|svg)$//gmx;\n            $fileset->{$type} = $pic;\n        }\n        $fileset->{'ok'} = '' unless $fileset->{'ok'};\n        push @{$folders}, { name => $name, 'sample' => \"../usercontent/images/status/\".$name.\"/\".$fileset->{'ok'}, value => $name, fileset => $fileset };\n    }\n    $folders = Thruk::Backend::Manager::sort_result({}, $folders, 'name');\n    if($c->req->parameters->{'withempty'}) {\n        unshift @{$folders}, { name => 'use dashboards default iconset', 'sample' => $c->stash->{'url_prefix'}.'plugins/panorama/images/s.gif', value => '' };\n    }\n    return $folders if $return_only;\n    my $json = { data => $folders };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_trendiconsets {\n    my($c, $return_only) = @_;\n    my $folder  = $c->stash->{'usercontent_folder'}.'/images/trend';\n    my $folders = [];\n    for my $f (glob(\"$folder/*/.\")) {\n        my $name = $f;\n        $name    =~ s/^\\Q$folder\\E//gmx;\n        $name    =~ s/^\\///gmx;\n        $name    =~ s/\\/\\.$//gmx;\n        my $fileset = {};\n        for my $pic (glob(\"$folder/$name/*.gif $folder/$name/*.jpg $folder/$name/*.png  $folder/$name/*.svg\")) {\n            $pic =~ s|\\Q$folder/$name/\\E||gmx;\n            my $type = $pic;\n            $type =~ s/\\.(png|gif|jpg|svg)$//gmx;\n            $fileset->{$type} = $pic;\n        }\n        $fileset->{'good'} = '' unless $fileset->{'good'};\n        push @{$folders}, { name => $name, 'sample' => \"../usercontent/images/trend/\".$name.\"/\".$fileset->{'good'}, value => $name, fileset => $fileset };\n    }\n    $folders = Thruk::Backend::Manager::sort_result({}, $folders, 'name');\n    return $folders if $return_only;\n    my $json = { data => $folders };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_sounds {\n    my($c) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/sounds/';\n    my $sounds = [];\n    for my $file (glob(\"$folder/*.ogg $folder/*/*.ogg $folder/*.mp3 $folder/*/*.mp3\")) {\n        my $path = $file;\n        $path    =~ s/^\\Q$folder\\E//gmx;\n        my $name = $path;\n        $name    =~ s/^.*\\///gmx;\n        push @{$sounds}, {\n            path  => '../usercontent/sounds'.$path,\n            name  => $name,\n        };\n    }\n    $sounds = Thruk::Backend::Manager::sort_result({}, $sounds, 'name');\n    unshift @{$sounds}, { path => '', name => 'none'};\n    my $json = { data => $sounds };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_userdata_shapes {\n    my($c, $return_only) = @_;\n    my $folder = $c->stash->{'usercontent_folder'}.'/shapes/';\n    my $shapes = [];\n    for my $file (glob(\"$folder/*.js $folder/*/*.js $folder/*.shape $folder/*/*.shape\")) {\n        my $name = $file;\n        $name    =~ s/^\\Q$folder\\E//gmx;\n        $name    =~ s/^.*\\///gmx;\n        $name    =~ s/\\.js$//gmx;\n        $name    =~ s/\\.shape$//gmx;\n        push @{$shapes}, {\n            name  => $name,\n            data  => Thruk::Utils::IO::read($file),\n        };\n    }\n    $shapes = Thruk::Backend::Manager::sort_result({}, $shapes, 'name');\n    return $shapes if $return_only;\n    my $json = { data => $shapes };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_host_list {\n    my($c) = @_;\n\n    my $hosts = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts')], columns => [qw/name/]);\n    my $data = [];\n    for my $hst (@{$hosts}) {\n        push @{$data}, { name => $hst->{'name'} };\n    }\n\n    $data = Thruk::Backend::Manager::sort_result({}, $data, 'name');\n    my $json = { data => $data };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_host_detail {\n    my($c) = @_;\n\n    my $host        = $c->req->parameters->{'host'}    || '';\n    my $json      = {};\n    my $hosts     = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), { name => $host }], extra_columns => [qw/long_plugin_output/]);\n    my $downtimes = $c->db->get_downtimes(\n        filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'downtimes' ), { 'host_name' => $host }, { 'service_description' => '' } ],\n        sort => { 'DESC' => 'id' },\n    );\n    if(defined $hosts and scalar @{$hosts} > 0) {\n        if($c->stash->{'escape_html_tags'}) {\n            _escape($hosts->[0]);\n        }\n        my $cust_vars = Thruk::Utils::get_custom_vars($c, $hosts->[0]);\n        $json = { data => $hosts->[0], downtimes => $downtimes, action_menu => $cust_vars->{'THRUK_ACTION_MENU'} };\n    }\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_service_list {\n    my($c) = @_;\n\n    my $host     = $c->req->parameters->{'host'} || '';\n    my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), { host_name => $host }], columns => [qw/description/]);\n    my $data = [];\n    for my $svc (@{$services}) {\n        push @{$data}, { description => $svc->{'description'} };\n    }\n\n    $data = Thruk::Backend::Manager::sort_result({}, $data, 'description');\n    my $json = { data => $data };\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_service_detail {\n    my($c) = @_;\n\n    my $host        = $c->req->parameters->{'host'}    || '';\n    my $description = $c->req->parameters->{'service'} || '';\n    my $json        = {};\n    my $services    = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), { host_name => $host, description => $description }], extra_columns => [qw/long_plugin_output/]);\n    my $downtimes = $c->db->get_downtimes(\n        filter => [ Thruk::Utils::Auth::get_auth_filter( $c, 'downtimes' ), { 'host_name' => $host }, { 'service_description' => $description } ],\n        sort => { 'DESC' => 'id' },\n    );\n    if(defined $services and scalar @{$services} > 0) {\n        if($c->stash->{'escape_html_tags'}) {\n            _escape($services->[0]);\n        }\n        my $cust_vars = Thruk::Utils::get_custom_vars($c, $services->[0]);\n        $json = { data => $services->[0], downtimes => $downtimes, action_menu => $cust_vars->{'THRUK_ACTION_MENU'} };\n    }\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_save_states {\n    my($c) = @_;\n\n    my $nr        = $c->req->parameters->{'nr'} || die('no number supplied');\n       $nr        =~ s/^pantab_//gmx;\n    my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $states;\n    eval {\n        $states = decode_json($c->req->parameters->{'states'});\n    };\n    if($@) {\n        _warn('_task_dashboard_save_states failed: '.$@);\n        return;\n    }\n\n    Thruk::Utils::Panorama::save_runtime_file($c, $dashboard, $states);\n\n    my $json = { 'status' => 'ok' };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_data {\n    my($c) = @_;\n    my $nr = $c->req->parameters->{'nr'} || die('no number supplied');\n    $nr = Thruk::Base::array_uniq(Thruk::Base::list($nr));\n\n    my $open_tabs_hash = Thruk::Base::array2hash(Thruk::Base::list($c->req->parameters->{'recursive'}));\n    if(scalar @{$nr} > 1) {\n        my $json;\n        my $data = {};\n        for my $n (@{$nr}) {\n            _add_initial_dashboard($c, $n, $data, undef, $open_tabs_hash);\n        }\n        return $c->render(json => { data => $data });\n    }\n    $nr = $nr->[0];\n\n    my $dashboard;\n    my $new_override = 0;\n    if($nr eq 'new_or_empty' || $nr eq 'first_or_new') {\n        # avoid too many empty dashboards, so return the first existing empty dashboard for this user\n        my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, 'my');\n        for my $d (@{$dashboards}) {\n            if($nr eq 'first_or_new' || $d->{'objects'} == 0) {\n                $nr = $d->{'nr'};\n                $new_override = 1;\n                last;\n            }\n        }\n        $nr = 'new' if $nr eq 'first_or_new';\n        $nr = 'new' if $nr eq 'new_or_empty';\n    }\n\n    if($nr eq 'new') {\n        return if $c->stash->{'readonly'};\n        $dashboard = {\n            tab     => {\n                xdata => _get_default_tab_xdata($c),\n            },\n            id      => 'new',\n        };\n        $dashboard = Thruk::Utils::Panorama::save_dashboard($c, $dashboard);\n    } else {\n        $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n    }\n    my $json;\n    if(!$dashboard) {\n        if(!$c->req->parameters->{'hidden'}) {\n            Thruk::Utils::set_message( $c, { style => 'fail_message', msg => 'no such dashboard' });\n        }\n        $c->res->code(404);\n        $json = { 'status' => 'failed' };\n    } else {\n        my $data = {};\n        _merge_dashboard_into_hash($c, $dashboard, $data);\n        _add_recursive_dashboards($c, $dashboard, $data, undef, $open_tabs_hash);\n        if($nr eq 'new' || $new_override) {\n            $data->{'newid'} = $dashboard->{'id'};\n        }\n        $json = { data => $data };\n    }\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _get_dashboard_by_name {\n    my($c, $name) = @_;\n    return unless $name;\n\n    for my $file (glob($c->{'panorama_etc'}.'/*.tab')) {\n        if($file =~ s/^.*\\/([a-zA-Z_\\-\\d]+)\\.tab$//mx) {\n            my $d = Thruk::Utils::Panorama::load_dashboard($c, $1, 1);\n            if($d) {\n                if(  ($d->{'tab'}->{'xdata'}->{'title'} && $d->{'tab'}->{'xdata'}->{'title'} eq $name)\n                   || $d->{'nr'} eq $name) {\n                    return($d);\n                }\n            }\n        }\n    }\n    return;\n}\n\n##########################################################\nsub _task_dashboard_list {\n    my($c) = @_;\n\n    my $type       = $c->req->parameters->{'list'} || 'my';\n    my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, $type);\n\n    my $columns = [\n        { 'header' => 'Id',                        dataIndex => 'id',                              hidden => Cpanel::JSON::XS::true },\n        { 'header' => 'Nr',          width => 60,  dataIndex => 'nr', align => 'left' },\n        { 'header' => '',            width => 20,  dataIndex => 'visible',      align => 'left', tdCls => 'icon_column', renderer => 'TP.render_dashboard_toggle_visible' },\n        { 'header' => 'Name',        width => 130, dataIndex => 'name',         align => 'left', editor => {}, tdCls => 'editable'   },\n        { 'header' => 'Description', flex  => 1,   dataIndex => 'description',  align => 'left', editor => {}, tdCls => 'editable'   },\n        { 'header' => 'Owner',        width => 130, dataIndex => 'user',        align => 'center',\n                                        editor => $c->stash->{'is_admin'} ? {} : undef,\n                                        hidden => $type eq 'my' ? Cpanel::JSON::XS::true : Cpanel::JSON::XS::false,\n                                        tdCls => $c->stash->{'is_admin'} ? 'editable' : '',\n        },\n        { 'header' => 'Read-Write Permissions',  width => 135, dataIndex => 'perm_rw',    align => 'left' },\n        { 'header' => 'Read-Only Permissions',   width => 135, dataIndex => 'perm_ro',    align => 'left' },\n        { 'header' => 'Direct Link',        width =>  65, dataIndex => 'link',         align => 'center', renderer => 'TP.render_directlink' },\n        { 'header' => 'Objects',     width => 55,  dataIndex => 'objects',      align => 'center' },\n        { 'header' => 'Last Time Used',     width => 130,  dataIndex => 'last_used',   align => 'center', renderer => 'TP.render_date_only' },\n        { 'header' => 'Readonly',    width => 60,  dataIndex => 'readonly',     align => 'center', renderer => 'TP.render_yes_no' },\n        { 'header' => 'Actions',     width => 60,\n                    xtype => 'actioncolumn',\n                    items => [{\n                        icon => '../plugins/panorama/images/edit.png',\n                        handler => 'TP.dashboardActionHandler',\n                        action  => 'edit',\n                    }, {\n                        icon => '../plugins/panorama/images/delete.png',\n                        handler => 'TP.dashboardActionHandler',\n                        action  => 'remove',\n                    }],\n                    tdCls => 'clickable icon_column',\n        },\n    ];\n\n    my $search = $c->req->parameters->{'query'};\n    if($search) {\n        my $filtered = [];\n        for my $d (@{$dashboards}) {\n            next unless $d->{'name'} =~ m/$search/mxi;\n            push @{$filtered}, $d;\n        }\n        $dashboards = $filtered;\n    }\n\n    # add last_used data\n    for my $d (@{$dashboards}) {\n        $d->{'last_used'} = 0;\n        for my $file (glob($c->config->{'var_path'}.'/panorama/'.$d->{'nr'}.'.tab.*runtime')) {\n            my @stat = stat($file);\n            $d->{'last_used'} = $stat[9] if $d->{'last_used'} < $stat[9];\n        }\n    }\n\n    $c->req->parameters->{'entries'} = $c->req->parameters->{'limit'} // 'all';\n    $c->req->parameters->{'page'}    = $c->req->parameters->{'page'}  || 1;\n    Thruk::Utils::page_data($c, $dashboards);\n    my $json = {\n        columns     => $columns,\n        data        => $c->stash->{'data'},\n        total       => $c->stash->{'pager'}->{'total_items'},\n        currentPage => $c->stash->{'pager'}->{'page'},\n        paging      => Cpanel::JSON::XS::true,\n    };\n\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_update {\n    my($c) = @_;\n\n    my $json   = { 'status' => 'failed' };\n    my $nr     = $c->req->parameters->{'nr'};\n    my $action = $c->req->parameters->{'action'};\n    my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    if($action && $dashboard && !$dashboard->{'readonly'}) {\n        $json = { 'status' => 'ok' };\n        if($action eq 'remove') {\n            Thruk::Utils::Panorama::delete_dashboard($c, $nr, $dashboard);\n        }\n        if($action eq 'update') {\n            my $extra_settings = {};\n            my $field = $c->req->parameters->{'field'};\n            my $value = $c->req->parameters->{'value'};\n            if($field eq 'description') {\n                $extra_settings->{$field} = $value;\n            }\n            elsif($field eq 'name') {\n                $dashboard->{'tab'}->{'xdata'}->{'title'} = $value;\n            }\n            elsif($field eq 'user' and $c->stash->{'is_admin'}) {\n                $extra_settings->{$field} = $value;\n            }\n            Thruk::Utils::Panorama::save_dashboard($c, $dashboard, $extra_settings);\n        }\n    }\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_restore_list {\n    my($c) = @_;\n\n    my $nr         = $c->req->parameters->{'nr'};\n    my $dashboard  = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $permission = Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $dashboard);\n    my $json;\n    if($permission >= ACCESS_READWRITE && !$dashboard->{'scripted'}) {\n        my $list = {\n            a => [],\n            m => [],\n        };\n        $nr       =~ s/^pantab_//gmx;\n        my @files = reverse sort glob($c->{'panorama_var'}.'/'.$nr.'.tab.*');\n        for my $file (@files) {\n            next if $file =~ m/\\.runtime$/mx;\n            if($file =~ m/\\.(\\d+)\\.(\\w)$/mx) {\n                my $date = $1;\n                my $mode = $2;\n                push(@{$list->{$mode}}, { num => $date });\n            } else {\n                die(\"wrong file name format in $file\");\n            }\n        }\n        $json = { data => $list };\n    }\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_restore_point {\n    my($c) = @_;\n\n    my $nr         = $c->req->parameters->{'nr'};\n       $nr         =~ s/^pantab_//gmx;\n    my $mode       = $c->req->parameters->{'mode'} || 'm';\n    my $dashboard  = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $permission = Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $dashboard);\n    my $etc_file   = $c->{'panorama_etc'}.'/'.$nr.'.tab';\n    my $var_file   = $c->{'panorama_var'}.'/'.$nr.'.tab';\n    if($permission >= ACCESS_READWRITE && !$dashboard->{'scripted'}) {\n        if(!$mode || $mode eq 'm') {\n            Thruk::Utils::backup_data_file($etc_file, $var_file, 'm', 5, 0, 1);\n        } else {\n            Thruk::Utils::backup_data_file($etc_file, $var_file, 'a', 5, 600, 1);\n        }\n    }\n\n    my $json = { msg => \"ok\" };\n    _add_misc_details($c, undef, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboard_restore {\n    my($c) = @_;\n\n    my $nr         = $c->req->parameters->{'nr'};\n       $nr         =~ s/^pantab_//gmx;\n    my $mode       = $c->req->parameters->{'mode'};\n    my $timestamp  = $c->req->parameters->{'timestamp'};\n    my $dashboard  = Thruk::Utils::Panorama::load_dashboard($c, $nr, 1);\n    my $permission = Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $nr, $dashboard);\n    if($permission >= ACCESS_READWRITE && !$dashboard->{'scripted'}) {\n        die(\"no such dashboard\") unless -e $c->{'panorama_etc'}.'/'.$nr.'.tab';\n        die(\"no such restore point\") unless -e $c->{'panorama_var'}.'/'.$nr.'.tab.'.$timestamp.\".\".$mode;\n        unlink($c->{'panorama_etc'}.'/'.$nr.'.tab');\n        copy($c->{'panorama_var'}.'/'.$nr.'.tab.'.$timestamp.\".\".$mode, $c->{'panorama_etc'}.'/'.$nr.'.tab');\n    }\n    my $json = {};\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _task_dashboards_clean {\n    my($c) = @_;\n\n    die(\"no admin permissions\") unless $c->stash->{'is_admin'};\n    my $json = { num => Thruk::Utils::Panorama::clean_old_dashboards($c) };\n    _add_misc_details($c, 1, $json);\n    return $c->render(json => $json);\n}\n\n##########################################################\nsub _get_gearman_stats {\n    my($c) = @_;\n\n    my $data = {};\n    my $host = 'localhost';\n    my $port = 4730;\n\n    if(defined $c->req->parameters->{'server'}) {\n        ($host,$port) = split(/:/mx, $c->req->parameters->{'server'}, 2);\n    }\n\n    load IO::Socket;\n    my $handle = IO::Socket::INET->new(\n        Proto    => \"tcp\",\n        PeerAddr => $host,\n        PeerPort => $port,\n    )\n    or do {\n        _warn(\"can't connect to port $port on $host: $!\") unless(Thruk::Base->mode eq 'TEST');\n        return $data;\n    };\n    $handle->autoflush(1);\n\n    print $handle \"status\\n\";\n\n    while ( defined( my $line = <$handle> ) ) {\n        chomp($line);\n        my($name,$total,$running,$worker) = split(/\\t/mx, $line);\n        next if $name eq 'dummy';\n        if(defined $worker) {\n            my $stat = {\n                'name'      => $name,\n                'worker'    => int($worker),\n                'running'   => int($running),\n                'waiting'   => int($total - $running),\n            };\n            $data->{$name} = $stat;\n        }\n        last if $line eq '.';\n    }\n    CORE::close($handle);\n\n    return $data;\n}\n\n##########################################################\n# convert json filter to perl object and do filtering\nsub _do_filter {\n    my($c) = @_;\n\n    # reset existing filter\n    Thruk::Utils::Status::reset_filter($c);\n\n    if(!defined $c->req->parameters->{'filter'} || $c->req->parameters->{'filter'} eq '') {\n        my @f = Thruk::Utils::Status::do_filter($c, undef, undef, 1);\n        return @f;\n    }\n\n    my $filter;\n    eval {\n        $filter = decode_json($c->req->parameters->{'filter'});\n    };\n    if($@) {\n        _warn('filter failed: '.$@);\n        return;\n    }\n\n    if(ref $filter eq 'HASH') {\n        $filter = [$filter];\n    }\n\n    my $nr = 0;\n    for my $f (@{$filter}) {\n        my $pre = 'dfl_s'.$nr.'_';\n        for my $key (qw/hostprops hoststatustypes serviceprops servicestatustypes/) {\n            $c->req->parameters->{$pre.$key} = $f->{$key};\n        }\n        for my $type (qw/op type value value_date val_pre/) {\n            if(ref $f->{$type} ne 'ARRAY') { $f->{$type} = [$f->{$type}]; }\n        }\n\n        for my $type (qw/op type value val_pre/) {\n            my $x = 0;\n            for my $val (@{$f->{$type}}) {\n                $c->req->parameters->{$pre.$type} = [] unless defined $c->req->parameters->{$pre.$type};\n                if($type eq 'value') {\n                    if(!defined $val) { $val = ''; }\n                    if($f->{'type'}->[$x] eq 'last check' or $f->{'type'}->[$x] eq 'next check') {\n                        $val = $f->{'value_date'}->[$x];\n                        $val =~ s/T/ /gmx;\n                    }\n                }\n                elsif($type eq 'type') {\n                    $val = lc($val || '');\n                }\n                elsif($type eq 'val_pre') {\n                    if(!defined $val) { $val = ''; }\n                }\n\n                push @{$c->req->parameters->{$pre.$type}}, $val;\n                $x++;\n            }\n        }\n        $nr++;\n    }\n\n    my @f = Thruk::Utils::Status::do_filter($c, undef, undef, 1);\n    return @f;\n}\n\n##########################################################\nsub _generate_service_popup {\n    my ($c, $service) = @_;\n    return ' title=\"'.Thruk::Utils::Filter::escape_quotes($service->{'plugin_output'}).'\" onclick=\"TP.add_panlet({type:\\'TP.PanletService\\', conf: { xdata: { host: \\''.Thruk::Utils::Filter::escape_bslash($service->{'host_name'}).'\\', service: \\''.Thruk::Utils::Filter::escape_bslash($service->{'description'}).'\\', }}})\"';\n}\n\n##########################################################\nsub _escape {\n    my($o) = @_;\n    $o->{'plugin_output'}      = Thruk::Utils::Filter::escape_quotes(Thruk::Utils::Filter::escape_html($o->{'plugin_output'}));\n    $o->{'long_plugin_output'} = Thruk::Utils::Filter::escape_quotes(Thruk::Utils::Filter::escape_html($o->{'long_plugin_output'}));\n    return $o;\n}\n\n##########################################################\nsub _long_plugin {\n    my($o) = @_;\n    if($o->{'long_plugin_output'}) {\n        $o->{'plugin_output'}      = $o->{'plugin_output'}.'<br>'.$o->{'long_plugin_output'};\n        $o->{'long_plugin_output'} = '';\n    }\n    return $o;\n}\n\n##########################################################\nsub _summarize_hostgroup_query {\n    my($c, $type_groups, $state_type) = @_;\n\n    my $filter = Thruk::Utils::combine_filter('-or', [map {{ name => { '=' => $_ }}} keys %{$type_groups}]);\n    my $details = $c->db->get_hostgroups(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hostgroups'), $filter ], columns => [qw/name alias/]);\n    $details = Thruk::Base::array2hash($details, 'name');\n\n    $filter = Thruk::Utils::combine_filter('-or', [map {{ groups => { '>=' => $_ }}} keys %{$type_groups}]);\n    my $hosts = $c->db->get_hosts(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $filter ], columns => [qw/name groups state state_type last_state_change acknowledged scheduled_downtime_depth has_been_checked/]);\n    my $hostgroups = {};\n    for my $hst (@{$hosts}) {\n        for my $grp (@{$hst->{'groups'}}) {\n            next unless defined $type_groups->{$grp};\n            if(!defined $hostgroups->{$grp}) {\n                $hostgroups->{$grp} = { services => { ok => 0, warning => 0, critical => 0, unknown => 0, pending => 0,\n                                                      plain_ok => 0, plain_warning => 0, plain_critical => 0, plain_unknown => 0, plain_pending => 0,\n                                                      ack_warning => 0, ack_critical => 0, ack_unknown => 0,\n                                                      downtime_ok => 0, downtime_warning => 0, downtime_critical => 0, downtime_unknown => 0,\n                                                    },\n                                        hosts    => { up => 0, down => 0, unreachable => 0, pending => 0,\n                                                      plain_up => 0, plain_down => 0, plain_unreachable => 0, plain_pending => 0,\n                                                      ack_down => 0, ack_unreachable => 0,\n                                                      downtime_up => 0, downtime_down => 0, downtime_unreachable => 0,\n                                                    },\n                                        name     => $grp,\n                                        alias    => $details->{$grp}->{'alias'} // '',\n                                      };\n            }\n            if($state_type == HARD_STATE && $hst->{'state_type'} != HARD_STATE) {\n                $hostgroups->{$grp}->{'hosts'}->{'up'}++;\n                if($hst->{'scheduled_downtime_depth'}) {\n                    $hostgroups->{$grp}->{'hosts'}->{'downtime_up'}++;\n                } else {\n                    $hostgroups->{$grp}->{'hosts'}->{'plain_up'}++;\n                }\n                next;\n            }\n            if($hst->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'hosts'}->{'pending'}++;     }\n            elsif($hst->{'state'} == 0)         { $hostgroups->{$grp}->{'hosts'}->{'up'}++;          }\n            elsif($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'down'}++;        }\n            elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'unreachable'}++; }\n            if($hst->{'acknowledged'}) {\n                   if($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'ack_down'}++;        }\n                elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'ack_unreachable'}++; }\n            }\n            if($hst->{'scheduled_downtime_depth'}) {\n                   if($hst->{'state'} == 0)         { $hostgroups->{$grp}->{'hosts'}->{'downtime_up'}++;          }\n                elsif($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'downtime_down'}++;        }\n                elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'downtime_unreachable'}++; }\n            }\n            if(!$hst->{'acknowledged'} && !$hst->{'scheduled_downtime_depth'}) {\n                if($hst->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'hosts'}->{'plain_pending'}++;     }\n                elsif($hst->{'state'} == 0)         { $hostgroups->{$grp}->{'hosts'}->{'plain_up'}++;          }\n                elsif($hst->{'state'} == 1)         { $hostgroups->{$grp}->{'hosts'}->{'plain_down'}++;        }\n                elsif($hst->{'state'} == 2)         { $hostgroups->{$grp}->{'hosts'}->{'plain_unreachable'}++; }\n            }\n        }\n    }\n    $filter      = Thruk::Utils::combine_filter('-or', [map {{ host_groups => { '>=' => $_ }}} keys %{$type_groups}]);\n    my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $filter ], columns => [qw/host_name description host_groups state state_type last_state_change acknowledged scheduled_downtime_depth has_been_checked/]);\n    for my $svc (@{$services}) {\n        for my $grp (@{$svc->{'host_groups'}}) {\n            next unless defined $type_groups->{$grp};\n            if($state_type == HARD_STATE && $svc->{'state_type'} != HARD_STATE) {\n                $hostgroups->{$grp}->{'services'}->{'ok'}++;\n                if($svc->{'scheduled_downtime_depth'}) {\n                   $hostgroups->{$grp}->{'services'}->{'downtime_ok'}++;\n                } else {\n                    $hostgroups->{$grp}->{'services'}->{'plain_ok'}++;\n                }\n                next;\n            }\n            if($svc->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'services'}->{'pending'}++;  }\n            elsif($svc->{'state'} == 0)         { $hostgroups->{$grp}->{'services'}->{'ok'}++;       }\n            elsif($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'warning'}++;  }\n            elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'critical'}++; }\n            elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'unknown'}++;  }\n            if($svc->{'acknowledged'}) {\n                   if($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'ack_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'ack_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'ack_unknown'}++;  }\n            }\n            if($svc->{'scheduled_downtime_depth'}) {\n                   if($svc->{'state'} == 0)         { $hostgroups->{$grp}->{'services'}->{'downtime_ok'}++;       }\n                elsif($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'downtime_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'downtime_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'downtime_unknown'}++;  }\n            }\n            if(!$svc->{'acknowledged'} && !$svc->{'scheduled_downtime_depth'}) {\n                if($svc->{'has_been_checked'} == 0) { $hostgroups->{$grp}->{'services'}->{'plain_pending'}++;  }\n                elsif($svc->{'state'} == 0)         { $hostgroups->{$grp}->{'services'}->{'plain_ok'}++;       }\n                elsif($svc->{'state'} == 1)         { $hostgroups->{$grp}->{'services'}->{'plain_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $hostgroups->{$grp}->{'services'}->{'plain_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $hostgroups->{$grp}->{'services'}->{'plain_unknown'}++;  }\n            }\n        }\n    }\n    return($hostgroups);\n}\n\n##########################################################\nsub _summarize_servicegroup_query {\n    my($c, $type_groups, $state_type) = @_;\n\n    my $filter = Thruk::Utils::combine_filter('-or', [map {{ name => { '=' => $_ }}} keys %{$type_groups}]);\n    my $details = $c->db->get_servicegroups(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'servicegroups'), $filter ], columns => [qw/name alias/]);\n    $details = Thruk::Base::array2hash($details, 'name');\n\n    $filter = Thruk::Utils::combine_filter('-or', [map {{ groups => { '>=' => $_ }}} keys %{$type_groups}]);\n    my $services = $c->db->get_services(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $filter ], columns => [qw/host_name description groups state state_type last_state_change acknowledged scheduled_downtime_depth has_been_checked/]);\n    my $servicegroups = {};\n    for my $svc (@{$services}) {\n        for my $grp (@{$svc->{'groups'}}) {\n            next unless defined $type_groups->{$grp};\n            if(!defined $servicegroups->{$grp}) {\n                $servicegroups->{$grp} = { services => { ok => 0, warning => 0, critical => 0, unknown => 0, pending => 0,\n                                                         plain_ok => 0, plain_warning => 0, plain_critical => 0, plain_unknown => 0, plain_pending => 0,\n                                                         ack_warning => 0, ack_critical => 0, ack_unknown => 0,\n                                                         downtime_ok => 0, downtime_warning => 0, downtime_critical => 0, downtime_unknown => 0,\n                                                       },\n                                           name     => $grp,\n                                           alias    => $details->{$grp}->{'alias'} // '',\n                                         };\n            }\n            if($state_type == HARD_STATE && $svc->{'state_type'} != HARD_STATE) {\n                $servicegroups->{$grp}->{'services'}->{'ok'}++;\n                if($svc->{'scheduled_downtime_depth'}) {\n                    $servicegroups->{$grp}->{'services'}->{'downtime_ok'}++;\n                } else {\n                    $servicegroups->{$grp}->{'services'}->{'plain_ok'}++;\n                }\n                next;\n            }\n            if($svc->{'has_been_checked'} == 0) { $servicegroups->{$grp}->{'services'}->{'pending'}++;  }\n            elsif($svc->{'state'} == 0)         { $servicegroups->{$grp}->{'services'}->{'ok'}++;       }\n            elsif($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'warning'}++;  }\n            elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'critical'}++; }\n            elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'unknown'}++;  }\n            if($svc->{'acknowledged'}) {\n                   if($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'ack_warning'}++;    }\n                elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'ack_critical'}++;   }\n                elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'ack_unknown'}++;    }\n            }\n            if($svc->{'scheduled_downtime_depth'}) {\n                   if($svc->{'state'} == 0)         { $servicegroups->{$grp}->{'services'}->{'downtime_ok'}++;        }\n                elsif($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'downtime_warning'}++;   }\n                elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'downtime_critical'}++;  }\n                elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'downtime_unknown'}++;   }\n            }\n            if(!$svc->{'acknowledged'} && !$svc->{'scheduled_downtime_depth'}) {\n                if($svc->{'has_been_checked'} == 0) { $servicegroups->{$grp}->{'services'}->{'plain_pending'}++;  }\n                elsif($svc->{'state'} == 0)         { $servicegroups->{$grp}->{'services'}->{'plain_ok'}++;       }\n                elsif($svc->{'state'} == 1)         { $servicegroups->{$grp}->{'services'}->{'plain_warning'}++;  }\n                elsif($svc->{'state'} == 2)         { $servicegroups->{$grp}->{'services'}->{'plain_critical'}++; }\n                elsif($svc->{'state'} == 3)         { $servicegroups->{$grp}->{'services'}->{'plain_unknown'}++;  }\n            }\n        }\n    }\n    return($servicegroups);\n}\n\n##########################################################\nsub _summarize_query {\n    my($c, $incl_hst, $incl_svc, $hostfilter, $servicefilter, $state_type, $has_service_filter) = @_;\n    my $sum   = { services => { ok => 0, warning => 0, critical => 0, unknown => 0, pending => 0,\n                                plain_ok => 0, plain_warning => 0, plain_critical => 0, plain_unknown => 0, plain_pending => 0,\n                                ack_warning => 0, ack_critical => 0, ack_unknown => 0,\n                                downtime_ok => 0, downtime_warning => 0, downtime_critical => 0, downtime_unknown => 0,\n                              },\n                  hosts    => { up => 0, down => 0, unreachable => 0, pending => 0,\n                                plain_up => 0, plain_down => 0, plain_unreachable => 0, plain_pending => 0,\n                                ack_down => 0, ack_unreachable => 0,\n                                downtime_up => 0, downtime_down => 0, downtime_unreachable => 0,\n                              },\n                };\n\n    my $hard_states_only = $state_type == HARD_STATE;\n    if($incl_hst) {\n        my $host_sum;\n        if(!$has_service_filter) {\n            $host_sum = $c->db->get_host_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'hosts'), $hostfilter ], hard_states_only => $hard_states_only);\n        } else {\n            $host_sum = $c->db->get_host_stats_by_servicequery(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ], hard_states_only => $hard_states_only);\n        }\n        for my $k (qw/up down unreachable pending/) {\n            $sum->{'hosts'}->{$k} = $host_sum->{$k};\n            $sum->{'hosts'}->{'plain_'.$k} = $host_sum->{'plain_'.$k};\n            if($k ne 'up' and $k ne 'pending') {\n                $sum->{'hosts'}->{'ack_'.$k} = $host_sum->{$k.'_and_ack'};\n            }\n            if($k ne 'pending') {\n                $sum->{'hosts'}->{'downtime_'.$k} = $host_sum->{$k.'_and_scheduled'};\n            }\n        }\n    }\n    if($incl_svc) {\n        my $service_sum = $c->db->get_service_stats(filter => [ Thruk::Utils::Auth::get_auth_filter($c, 'services'), $servicefilter ], hard_states_only => $hard_states_only);\n        for my $k (qw/ok warning critical unknown pending/) {\n            $sum->{'services'}->{$k} = $service_sum->{$k};\n            $sum->{'services'}->{'plain_'.$k} = $service_sum->{'plain_'.$k};\n            if($k ne 'ok' and $k ne 'pending') {\n                $sum->{'services'}->{'ack_'.$k} = $service_sum->{$k.'_and_ack'};\n            }\n            if($k ne 'pending') {\n                $sum->{'services'}->{'downtime_'.$k} = $service_sum->{$k.'_and_scheduled'};\n            }\n        }\n    }\n    return($sum);\n}\n\n##########################################################\nsub _merge_dashboard_into_hash {\n    my($c, $dashboard, $data) = @_;\n    return $data unless $dashboard;\n\n    my $id = $dashboard->{'id'};\n    for my $key (keys %{$dashboard}) {\n        if($key =~ m/^panlet_\\d+$/mx) {\n            $data->{$id.'_'.$key} = $dashboard->{$key};\n        }\n        elsif($key eq 'tab') {\n            # add some values to the tab\n            for my $k (qw/user public readonly ts scripted maintenance/) {\n                $dashboard->{'tab'}->{$k} = $dashboard->{$k} if defined $dashboard->{$k};\n            }\n            $data->{$id} = $dashboard->{'tab'};\n\n            # touch runtime file, since thats what we use to reflect last_used date\n            my $runtime_file = Thruk::Utils::Panorama::get_runtime_file($c, $dashboard->{'nr'});\n            Thruk::Utils::IO::touch($runtime_file);\n        }\n    }\n    return $data;\n}\n\n##########################################################\nsub _add_initial_dashboard {\n    my($c, $nr, $data, $shapes, $open_tabs) = @_;\n\n    my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n    if(!$dashboard && $data->{'tabbar'}->{'open_tabs'}) {\n        # remove orphaned or removed dashboards\n        @{$data->{'tabbar'}->{'open_tabs'}} = grep !/^\\Q$nr\\E$/mx, @{$data->{'tabbar'}->{'open_tabs'}};\n        return;\n    }\n    _merge_dashboard_into_hash($c, $dashboard, $data);\n    _add_recursive_dashboards($c, $dashboard, $data, $shapes, $open_tabs);\n    return;\n}\n\n##########################################################\nsub _add_recursive_dashboards {\n    my($c, $dashboard, $data, $shapes, $open_tabs) = @_;\n    my $add_hidden = {};\n    # add shapes data\n    for my $key (keys %{$dashboard}) {\n        if(ref $dashboard->{$key} eq 'HASH' && $dashboard->{$key}->{'xdata'} && $dashboard->{$key}->{'xdata'}->{'appearance'}) {\n            my $shape = $dashboard->{$key}->{'xdata'}->{'appearance'}->{'shapename'};\n            if(defined $shapes && $shape && !exists $shapes->{$shape}) {\n                if(-e $c->stash->{'usercontent_folder'}.'/shapes/'.$shape.'.js') {\n                    $shapes->{$shape} = Thruk::Utils::IO::read($c->stash->{'usercontent_folder'}.'/shapes/'.$shape.'.js');\n                } else {\n                    $shapes->{$shape} = undef;\n                }\n            }\n            if($dashboard->{$key}->{'xdata'}->{'cls'} eq 'TP.DashboardStatusIcon') {\n                my $sub = $dashboard->{$key}->{'xdata'}->{'general'}->{'dashboard'};\n                if(!defined $open_tabs->{$sub}) {\n                    $open_tabs->{$sub} = 1;\n                    $add_hidden->{$sub} = 1;\n                }\n            }\n        }\n    }\n    # add hidden dashboards recursivly\n    for my $key (sort keys %{$add_hidden}) {\n        _add_initial_dashboard($c, $key, $data, $shapes, $open_tabs);\n    }\n    return;\n}\n\n##########################################################\nsub _get_default_tab_xdata {\n    my($c) = @_;\n    return({\n        title           => $c->req->parameters->{'title'} || 'Dashboard',\n        refresh         => $c->config->{'refresh_rate'} || 60,\n        select_backends => 0,\n        backends        => [],\n        background      => 'none',\n        autohideheader  => 1,\n        defaulticonset  => 'default',\n        groups          => [],\n    });\n}\n\n##########################################################\nsub _add_json_dashboard_timestamps {\n    my($c, $json, $tab) = @_;\n    if(!defined $tab && $c->cookies('thruk_panorama_active')) {\n        $tab = $c->cookies('thruk_panorama_active');\n    }\n    if($tab) {\n        my $nr = $tab;\n           $nr =~ s/^pantab_//gmx;\n        $json->{'dashboard_ts'} = {};\n        my $file  = $c->{'panorama_etc'}.'/'.$nr.'.tab';\n        if($nr eq \"0\" && !-s $file) {\n            $file = $c->config->{'plugin_path'}.'/plugins-enabled/panorama/0.tab';\n        }\n        my @stat = stat($file);\n        if(-x $file) {\n            my $dashboard = Thruk::Utils::Panorama::load_dashboard($c, $nr);\n            if($dashboard->{'ts'}) {\n                $json->{'dashboard_ts'}->{$tab} = $dashboard->{'ts'};\n            } else {\n                $json->{'dashboard_ts'}->{$tab} = $stat[9] if defined $stat[9];\n            }\n        } else {\n            $json->{'dashboard_ts'}->{$tab} = $stat[9] if defined $stat[9];\n        }\n        my $maintfile  = Thruk::Utils::Panorama::get_maint_file($c, $nr);\n        if(-e $maintfile) {\n            my $maintenance = Thruk::Utils::IO::json_lock_retrieve($maintfile);\n            $json->{'maintenance'}->{$tab} = $maintenance->{'maintenance'};\n        } else {\n            $json->{'maintenance'}->{$tab} = \"\";\n        }\n    }\n    return;\n}\n\n##########################################################\nsub _add_json_pi_detail {\n    my($c, $json) = @_;\n    $json->{'pi_detail'} = $c->stash->{pi_detail};\n    return;\n}\n\n##########################################################\nsub _add_misc_details {\n    my($c, $always, $json) = @_;\n    if($always || $c->req->parameters->{'update_proc'}) {\n        $c->stats->profile(begin => \"_add_misc_details\");\n        _add_json_dashboard_timestamps($c, $json, $c->req->parameters->{'current_tab'});\n        _add_json_pi_detail($c, $json);\n        $json->{'server_version'}       = $c->config->{'thrukversion'};\n        $json->{'server_extra_version'} = $c->config->{'extra_version'};\n        $json->{'broadcasts'}           = Thruk::Utils::Broadcast::get_broadcasts($c, undef, undef, 1);\n        $c->stats->profile(end => \"_add_misc_details\");\n    }\n    elsif($c->req->parameters->{'current_tab'}) {\n        _add_json_dashboard_timestamps($c, $json, $c->req->parameters->{'current_tab'});\n    }\n    return;\n}\n\n##########################################################\nsub _set_preload_images {\n    my($c) = @_;\n    my $plugin_dir = $c->config->{'plugin_path'} || $c->config->{home}.\"/plugins\";\n    my @images = glob($plugin_dir.'/plugins-enabled/panorama/root/images/*');\n    $c->stash->{preload_img} = [];\n    for my $i (@images) {\n        $i =~ s|^.*/||gmx;\n        push @{$c->stash->{preload_img}}, $i;\n    }\n    return;\n}\n\n##########################################################\nsub _get_available_fonts {\n    my($c) = @_;\n    my $fonts = [ 'Arial', 'Comic Sans MS', 'Georgia', 'Helvetica', 'Lucida Console',\n                  'Lucida Grande', 'Tahoma', 'Times', 'Times New Roman', 'Trebuchet MS',\n                  'Verdana', 'caption', 'cursive', 'fantasy', 'icon', 'menu',\n                  'message-box', 'monospace', 'sans-serif', 'serif', 'small-caption',\n    ];\n    if($c->config->{'Thruk::Plugin::Panorama'}->{'extra_fonts'}) {\n        for my $font (@{Thruk::Base::list($c->config->{'Thruk::Plugin::Panorama'}->{'extra_fonts'})}) {\n            my @extra = split/\\s*,\\s*/mx, $font;\n            push @{$fonts}, @extra;\n        }\n        @{$fonts} = sort(@{$fonts});\n    }\n    unshift @{$fonts}, 'inherit';\n    return($fonts);\n}\n\n##########################################################\nsub _check_media_permissions {\n    my($c, $file) = @_;\n    return 1 if $c->stash->{'is_admin'};\n    return 1 if $c->check_user_roles('panorama_view_media_manager');\n\n    my $folder = $c->stash->{'usercontent_folder'}.'/';\n    $file = Thruk::Utils::IO::realpath($file);\n\n    # user is allowed to change the image if he has write access to all dashboards using this image\n    my $dashboards = Thruk::Utils::Panorama::get_dashboard_list($c, 'all', 1);\n    for my $d (@{$dashboards}) {\n        # we are looking for dashboards without access which use this image,so skip the dashboard we have full access to\n        next if Thruk::Utils::Panorama::is_authorized_for_dashboard($c, $d->{'nr'}, $d) >= ACCESS_READWRITE;\n        if($d->{'tab'}->{'xdata'}->{'background'}) {\n            return if Thruk::Utils::IO::realpath($folder.$d->{'tab'}->{'xdata'}->{'background'}) eq $file;\n        }\n        for my $key (sort keys %{$d}) {\n            if(ref($d->{$key}) eq 'HASH' && $d->{$key}->{'xdata'} && $d->{$key}->{'xdata'}->{'general'} && $d->{$key}->{'xdata'}->{'general'}->{'src'}) {\n                return if Thruk::Utils::IO::realpath($folder.$d->{$key}->{'xdata'}->{'general'}->{'src'}) eq $file;\n            }\n        }\n    }\n\n    return 1;\n}\n\n##########################################################\nsub _append_sort {\n    my($param, $default) = @_;\n    if(!$param || ref $param ne 'ARRAY') {\n        return($default);\n    }\n\n    my $others = $default->{'ASC'} || $default->{'DESC'};\n    return({\n        $param->[1] => [ $param->[0], @{$others} ],\n    });\n}\n\n##########################################################\n\n1;\n"], "filenames": ["plugins/plugins-available/panorama/lib/Thruk/Controller/panorama.pm"], "buggy_code_start_loc": [6], "buggy_code_end_loc": [736], "fixing_code_start_loc": [7], "fixing_code_end_loc": [744], "type": "CWE-22", "message": "Thruk is a multibackend monitoring webinterface.  Prior to 3.12, the Thruk web monitoring application presents a vulnerability in a file upload form that allows a threat actor to arbitrarily upload files to the server to any path they desire and have permissions for. This vulnerability is known as Path Traversal or Directory Traversal. Version 3.12 fixes the issue.\n", "other": {"cve": {"id": "CVE-2024-23822", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-29T16:15:09.437", "lastModified": "2024-02-05T18:04:52.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Thruk is a multibackend monitoring webinterface.  Prior to 3.12, the Thruk web monitoring application presents a vulnerability in a file upload form that allows a threat actor to arbitrarily upload files to the server to any path they desire and have permissions for. This vulnerability is known as Path Traversal or Directory Traversal. Version 3.12 fixes the issue.\n"}, {"lang": "es", "value": "Thruk es una interfaz web de monitoreo multibackend. Antes de la versi\u00f3n 3.12, la aplicaci\u00f3n de monitoreo web Thruk presenta una vulnerabilidad en un formulario de carga de archivos que permite a un actor de amenazas cargar archivos arbitrariamente al servidor en cualquier ruta que desee y para la que tenga permisos. Esta vulnerabilidad se conoce como Path Traversal o Directory Traversal. La versi\u00f3n 3.12 soluciona el problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thruk:thruk:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.12", "matchCriteriaId": "1BA8DF0F-A05A-4BAA-840F-F4CEF38641E0"}]}]}], "references": [{"url": "https://github.com/sni/Thruk/commit/1aa9597cdf2722a69651124f68cbb449be12cc39", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/sni/Thruk/security/advisories/GHSA-4mrh-mx7x-rqjx", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/sni/Thruk/commit/1aa9597cdf2722a69651124f68cbb449be12cc39"}}