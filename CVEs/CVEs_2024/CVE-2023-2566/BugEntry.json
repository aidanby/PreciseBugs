{"buggy_code": ["<?php\n\n/**\n * Escaping Functions\n *\n * @package   OpenEMR\n * @link      https://www.open-emr.org\n * @author    Boyd Stephen Smith Jr.\n * @author    Brady Miller <brady.g.miller@gmail.com>\n * @copyright Copyright (c) 2011 Boyd Stephen Smith Jr.\n * @copyright Copyright (c) 2018 Brady Miller <brady.g.miller@gmail.com>\n * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3\n */\n\n/**\n * Escape a javascript literal.\n */\nfunction js_escape($text)\n{\n    return json_encode($text);\n}\n\n/**\n * Escape a javascript literal within html onclick attribute.\n */\nfunction attr_js($text)\n{\n    return attr(json_encode($text));\n}\n\n/**\n * Escape html and url encode a url item.\n */\nfunction attr_url($text)\n{\n    return attr(urlencode($text ?? ''));\n}\n\n/**\n * Escape js and url encode a url item.\n */\nfunction js_url($text)\n{\n    return js_escape(urlencode($text));\n}\n\n/**\n * Escape variables that are outputted into the php error log.\n */\nfunction errorLogEscape($text)\n{\n    return attr($text);\n}\n\n/**\n * Escape variables that are outputted into csv and spreadsheet files.\n * See here: https://www.owasp.org/index.php/CSV_Injection\n * Based mitigation strategy on this report: https://asecurityz.blogspot.com/2017/12/csv-injection-mitigations.html\n *  1. Remove all the following characters:  = + \" |\n *  2. Only remove leading - characters (since need in dates)\n *  3. Only remove leading @ characters (since need in email addresses)\n *  4. Surround with double quotes (no reference link, but seems very reasonable, which will prevent commas from breaking things).\n * If needed in future, will add a second parameter called 'options' which will be an array of option tokens that will allow\n * less stringent (or more stringent) mechanisms to escape for csv.\n */\nfunction csvEscape($text)\n{\n    // 1. Remove all the following characters:  = + \" |\n    $text = preg_replace('/[=+\"|]/', '', $text ?? '');\n\n    // 2. Only remove leading - characters (since need in dates)\n    // 3. Only remove leading @ characters (since need in email addresses)\n    $text = preg_replace('/^[\\-@]+/', '', $text);\n\n    // 4. Surround with double quotes (no reference link, but seems very reasonable, which will prevent commas from breaking things).\n    return '\"' . $text . '\"';\n}\n\n/**\n *\n * references: https://stackoverflow.com/questions/3426090/how-do-you-make-strings-xml-safe\n *             https://www.php.net/htmlspecialchars\n *             https://www.php.net/XMLWriter\n *\n *\n * Escapes & < > ' \"\n * TODO: not sure if need to escape ' and \", which are escaping for now (via the ENT_QUOTES flag)\n */\nfunction xmlEscape($text)\n{\n    return htmlspecialchars(($text ?? ''), ENT_XML1 | ENT_QUOTES);\n}\n\n/**\n * Special function to remove the 'javascript' string (case insensitive) for when including a variable within a html link\n */\nfunction javascriptStringRemove($text)\n{\n    return str_ireplace('javascript', '', $text ?? '');\n}\n\n/**\n * Escape a PHP string for use as (part of) an HTML / XML text node.\n *\n * It only escapes a few special chars: the ampersand (&) and both the left-\n * pointing angle bracket (<) and the right-pointing angle bracket (>), since\n * these are the only characters that are special in a text node.  Minimal\n * quoting is preferred because it produces smaller and more easily human-\n * readable output.\n *\n * Some characters simply cannot appear in valid XML documents, even\n * as entities but, this function does not attempt to handle them.\n *\n * NOTE: Attribute values are NOT text nodes, and require additional escaping.\n *\n * @param string $text The string to escape, possibly including \"&\", \"<\",\n *                     or \">\".\n * @return string The string, with \"&\", \"<\", and \">\" escaped.\n */\nfunction text($text)\n{\n    return htmlspecialchars(($text ?? ''), ENT_NOQUOTES);\n}\n\n/**\n * Given an array of properties run through both the keys and values of the array and\n * escape each PHP string for use as (part of) an HTML / XML text node.\n *\n * It only escapes a few special chars: the ampersand (&) and both the left-\n * pointing angle bracket (<) and the right-pointing angle bracket (>), since\n * these are the only characters that are special in a text node.  Minimal\n * quoting is preferred because it produces smaller and more easily human-\n * readable output.\n *\n * Some characters simply cannot appear in valid XML documents, even\n * as entities but, this function does not attempt to handle them.\n *\n * NOTE: Attribute values are NOT text nodes, and require additional escaping.\n *\n * @param string $arr The array of strings to escape, possibly including \"&\", \"<\",\n *                     or \">\".\n * @param int $depth The current recursive depth of the escaping function.  Defaults to 0 for initial call\n * @return array The array that has each key and property escaped.\n */\nfunction textArray(array $arr, $depth = 0)\n{\n    if ($depth > 50) {\n        throw new \\InvalidArgumentException(\"array was nested too deep for escaping.  Max limit reached\");\n    }\n\n    $newArray = [];\n    foreach ($arr as $key => $value) {\n        if (is_array($value)) {\n            $newArray[text($key)] = textArray($value, $depth + 1);\n        } else {\n            $newArray[text($key)] = text($value);\n        }\n    }\n    return $newArray;\n}\n\n/**\n * Escape a PHP string for use as (part of) an HTML / XML attribute value.\n *\n * It escapes several special chars: the ampersand (&), the double quote\n * (\"), the singlequote ('), and both the left-pointing angle bracket (<)\n * and the right-pointing angle bracket (>), since these are the characters\n * that are special in an attribute value.\n *\n * Some characters simply cannot appear in valid XML documents, even\n * as entities but, this function does not attempt to handle them.\n *\n * NOTE: This can be used as a \"generic\" HTML escape since it does maximal\n * quoting.  However, some HTML and XML contexts (CDATA) don't provide\n * escape mechanisms.  Also, further pre- or post-escaping might need to\n * be done when embdedded other languages (like JavaScript) inside HTML /\n * XML documents.\n *\n * @param string $text The string to escape, possibly including (&), (<),\n *                     (>), ('), and (\").\n * @return string The string, with (&), (<), (>), (\"), and (') escaped.\n */\nfunction attr($text)\n{\n    return htmlspecialchars(($text ?? ''), ENT_QUOTES);\n}\n\n/**\n * Don't call this function.  You don't see this function.  This function\n * doesn't exist.\n *\n * TODO: Hide this function so it can be called from this file but not from\n * PHP that includes / requires this file.  Either that, or write reasonable\n * documentation and clean up the name.\n */\nfunction hsc_private_xl_or_warn($key)\n{\n    if (function_exists('xl')) {\n        return xl($key);\n    } else {\n        trigger_error(\n            'Translation via xl() was requested, but the xl()'\n            . ' function is not defined, yet.',\n            E_USER_WARNING\n        );\n        return $key;\n    }\n}\n\n/**\n * Translate via xl() and then escape via text().\n *\n * @param string $key The string to escape, possibly including \"&\", \"<\",\n *                    or \">\".\n * @return string The string, with \"&\", \"<\", and \">\" escaped.\n */\nfunction xlt($key)\n{\n    return text(hsc_private_xl_or_warn($key));\n}\n\n/**\n * Translate via xl() and then escape via attr().\n *\n * @param string $key The string to escape, possibly including (&), (<),\n *                    (>), ('), and (\").\n * @return string The string, with (&), (<), (>), (\"), and (') escaped.\n */\nfunction xla($key)\n{\n    return attr(hsc_private_xl_or_warn($key));\n}\n\n/*\n * Translate via xl() and then escape via js_escape for use with javascript literals\n */\nfunction xlj($key)\n{\n    return js_escape(hsc_private_xl_or_warn($key));\n}\n\n/*\n * Deprecated\n *Translate via xl() and then escape via addslashes for use with javascript literals\n */\nfunction xls($key)\n{\n    return addslashes(hsc_private_xl_or_warn($key));\n}\n"], "fixing_code": ["<?php\n\n/**\n * Escaping Functions\n *\n * @package   OpenEMR\n * @link      https://www.open-emr.org\n * @author    Boyd Stephen Smith Jr.\n * @author    Brady Miller <brady.g.miller@gmail.com>\n * @copyright Copyright (c) 2011 Boyd Stephen Smith Jr.\n * @copyright Copyright (c) 2018 Brady Miller <brady.g.miller@gmail.com>\n * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3\n */\n\n/**\n * Escape a javascript literal.\n */\nfunction js_escape($text)\n{\n    return json_encode($text);\n}\n\n/**\n * Escape a javascript literal within html onclick attribute.\n */\nfunction attr_js($text)\n{\n    return attr(json_encode($text));\n}\n\n/**\n * Escape html and url encode a url item.\n */\nfunction attr_url($text)\n{\n    return attr(urlencode($text ?? ''));\n}\n\n/**\n * Escape js and url encode a url item.\n */\nfunction js_url($text)\n{\n    return js_escape(urlencode($text));\n}\n\n/**\n * Escape variables that are outputted into the php error log.\n */\nfunction errorLogEscape($text)\n{\n    return attr($text);\n}\n\n/**\n * Escape variables that are outputted into csv and spreadsheet files.\n * See here: https://www.owasp.org/index.php/CSV_Injection\n * Based mitigation strategy on this report: https://asecurityz.blogspot.com/2017/12/csv-injection-mitigations.html\n *  1. Remove all the following characters:  = + \" |\n *  2. Only remove leading - characters (since need in dates)\n *  3. Only remove leading @ characters (since need in email addresses)\n *  4. Surround with double quotes (no reference link, but seems very reasonable, which will prevent commas from breaking things).\n * If needed in future, will add a second parameter called 'options' which will be an array of option tokens that will allow\n * less stringent (or more stringent) mechanisms to escape for csv.\n */\nfunction csvEscape($text)\n{\n    // 1. Remove all the following characters:  = + \" |\n    $text = preg_replace('/[=+\"|]/', '', $text ?? '');\n\n    // 2. Only remove leading - characters (since need in dates)\n    // 3. Only remove leading @ characters (since need in email addresses)\n    $text = preg_replace('/^[\\-@]+/', '', $text);\n\n    // 4. Surround with double quotes (no reference link, but seems very reasonable, which will prevent commas from breaking things).\n    return '\"' . $text . '\"';\n}\n\n/**\n *\n * references: https://stackoverflow.com/questions/3426090/how-do-you-make-strings-xml-safe\n *             https://www.php.net/htmlspecialchars\n *             https://www.php.net/XMLWriter\n *\n *\n * Escapes & < > ' \"\n * TODO: not sure if need to escape ' and \", which are escaping for now (via the ENT_QUOTES flag)\n */\nfunction xmlEscape($text)\n{\n    return htmlspecialchars(($text ?? ''), ENT_XML1 | ENT_QUOTES);\n}\n\n/**\n * Special function to remove the 'javascript' strings (case insensitive) for when including a variable within a html link\n */\nfunction javascriptStringRemove(?string $text): string\n{\n    $returnText = str_ireplace('javascript', '', $text ?? '');\n\n    if (javascriptStringCheck($returnText)) {\n        $returnText = javascriptStringRemove($returnText);\n    }\n\n    return $returnText;\n}\n\n/**\n * Special function to check if 'javascript' string (case insensitive) is in a variable within a html link\n */\nfunction javascriptStringCheck(?string $text): bool\n{\n    if (stripos($text ?? '', 'javascript') === false) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n/**\n * Escape a PHP string for use as (part of) an HTML / XML text node.\n *\n * It only escapes a few special chars: the ampersand (&) and both the left-\n * pointing angle bracket (<) and the right-pointing angle bracket (>), since\n * these are the only characters that are special in a text node.  Minimal\n * quoting is preferred because it produces smaller and more easily human-\n * readable output.\n *\n * Some characters simply cannot appear in valid XML documents, even\n * as entities but, this function does not attempt to handle them.\n *\n * NOTE: Attribute values are NOT text nodes, and require additional escaping.\n *\n * @param string $text The string to escape, possibly including \"&\", \"<\",\n *                     or \">\".\n * @return string The string, with \"&\", \"<\", and \">\" escaped.\n */\nfunction text($text)\n{\n    return htmlspecialchars(($text ?? ''), ENT_NOQUOTES);\n}\n\n/**\n * Given an array of properties run through both the keys and values of the array and\n * escape each PHP string for use as (part of) an HTML / XML text node.\n *\n * It only escapes a few special chars: the ampersand (&) and both the left-\n * pointing angle bracket (<) and the right-pointing angle bracket (>), since\n * these are the only characters that are special in a text node.  Minimal\n * quoting is preferred because it produces smaller and more easily human-\n * readable output.\n *\n * Some characters simply cannot appear in valid XML documents, even\n * as entities but, this function does not attempt to handle them.\n *\n * NOTE: Attribute values are NOT text nodes, and require additional escaping.\n *\n * @param string $arr The array of strings to escape, possibly including \"&\", \"<\",\n *                     or \">\".\n * @param int $depth The current recursive depth of the escaping function.  Defaults to 0 for initial call\n * @return array The array that has each key and property escaped.\n */\nfunction textArray(array $arr, $depth = 0)\n{\n    if ($depth > 50) {\n        throw new \\InvalidArgumentException(\"array was nested too deep for escaping.  Max limit reached\");\n    }\n\n    $newArray = [];\n    foreach ($arr as $key => $value) {\n        if (is_array($value)) {\n            $newArray[text($key)] = textArray($value, $depth + 1);\n        } else {\n            $newArray[text($key)] = text($value);\n        }\n    }\n    return $newArray;\n}\n\n/**\n * Escape a PHP string for use as (part of) an HTML / XML attribute value.\n *\n * It escapes several special chars: the ampersand (&), the double quote\n * (\"), the singlequote ('), and both the left-pointing angle bracket (<)\n * and the right-pointing angle bracket (>), since these are the characters\n * that are special in an attribute value.\n *\n * Some characters simply cannot appear in valid XML documents, even\n * as entities but, this function does not attempt to handle them.\n *\n * NOTE: This can be used as a \"generic\" HTML escape since it does maximal\n * quoting.  However, some HTML and XML contexts (CDATA) don't provide\n * escape mechanisms.  Also, further pre- or post-escaping might need to\n * be done when embdedded other languages (like JavaScript) inside HTML /\n * XML documents.\n *\n * @param string $text The string to escape, possibly including (&), (<),\n *                     (>), ('), and (\").\n * @return string The string, with (&), (<), (>), (\"), and (') escaped.\n */\nfunction attr($text)\n{\n    return htmlspecialchars(($text ?? ''), ENT_QUOTES);\n}\n\n/**\n * Don't call this function.  You don't see this function.  This function\n * doesn't exist.\n *\n * TODO: Hide this function so it can be called from this file but not from\n * PHP that includes / requires this file.  Either that, or write reasonable\n * documentation and clean up the name.\n */\nfunction hsc_private_xl_or_warn($key)\n{\n    if (function_exists('xl')) {\n        return xl($key);\n    } else {\n        trigger_error(\n            'Translation via xl() was requested, but the xl()'\n            . ' function is not defined, yet.',\n            E_USER_WARNING\n        );\n        return $key;\n    }\n}\n\n/**\n * Translate via xl() and then escape via text().\n *\n * @param string $key The string to escape, possibly including \"&\", \"<\",\n *                    or \">\".\n * @return string The string, with \"&\", \"<\", and \">\" escaped.\n */\nfunction xlt($key)\n{\n    return text(hsc_private_xl_or_warn($key));\n}\n\n/**\n * Translate via xl() and then escape via attr().\n *\n * @param string $key The string to escape, possibly including (&), (<),\n *                    (>), ('), and (\").\n * @return string The string, with (&), (<), (>), (\"), and (') escaped.\n */\nfunction xla($key)\n{\n    return attr(hsc_private_xl_or_warn($key));\n}\n\n/*\n * Translate via xl() and then escape via js_escape for use with javascript literals\n */\nfunction xlj($key)\n{\n    return js_escape(hsc_private_xl_or_warn($key));\n}\n\n/*\n * Deprecated\n *Translate via xl() and then escape via addslashes for use with javascript literals\n */\nfunction xls($key)\n{\n    return addslashes(hsc_private_xl_or_warn($key));\n}\n"], "filenames": ["library/htmlspecialchars.inc.php"], "buggy_code_start_loc": [95], "buggy_code_end_loc": [100], "fixing_code_start_loc": [95], "fixing_code_end_loc": [118], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository openemr/openemr prior to 7.0.1.", "other": {"cve": {"id": "CVE-2023-2566", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-08T05:15:09.860", "lastModified": "2023-05-11T23:21:44.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository openemr/openemr prior to 7.0.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:C/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.7, "impactScore": 5.3}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:open-emr:openemr:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.1", "matchCriteriaId": "30B2EE3F-FA55-46FB-BC32-B041753826A4"}]}]}], "references": [{"url": "https://github.com/openemr/openemr/commit/a2adac7320dfc631b1da688c3b04f54b8240fc7b", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/47d6fc2a-989a-44eb-9cb7-ab4f8bd44496", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openemr/openemr/commit/a2adac7320dfc631b1da688c3b04f54b8240fc7b"}}