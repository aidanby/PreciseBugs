{"buggy_code": ["/* Copyright 2013-2022 Simo Sorce <simo@samba.org>, see COPYING for license */\n\n#define _GNU_SOURCE\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_ext.h>\n\n#include \"gss_ntlmssp.h\"\n\n#ifndef\tHOST_NAME_MAX\n#include <sys/param.h>\n#define\tHOST_NAME_MAX\tMAXHOSTNAMELEN\n#endif\n\nstatic uint32_t string_split(uint32_t *minor_status, char sep,\n                             const char *str, size_t len,\n                             char **s1, char **s2)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    char *r1 = NULL;\n    char *r2 = NULL;\n    const char *p;\n    size_t l;\n\n    p = memchr(str, sep, len);\n    if (!p) return GSSERRS(0, GSS_S_UNAVAILABLE);\n\n    /* left side */\n    l = p - str;\n    if (s1 && l != 0) {\n        r1 = strndup(str, l);\n        if (!r1) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n    }\n\n    /* right side */\n    p++;\n    l = len - (p - str);\n    if (s2 && l != 0) {\n        r2 = strndup(p, l);\n        if (!r2) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    if (retmaj) {\n        free(r1);\n        free(r2);\n    } else {\n        if (s1) *s1 = r1;\n        if (s2) *s2 = r2;\n    }\n    return GSSERR();\n}\n\n/* Form of names allowed in GSSNTLMSSP now:\n *\n * Standard Forms:\n *  foo\n *      USERNAME: foo\n *      DOMAIN: <null>\n *\n *  BAR\\foo\n *      USERNAME: foo\n *      DOMAIN: BAR\n *\n *  foo@BAR\n *      USERNAME: foo\n *      DOMAIN: BAR\n *\n * Enterprise name forms:\n *  foo\\@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: <null>\n *\n *  foo\\@bar.example.com@BAR\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: BAR\n *\n *  \\foo@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: <null>\n *\n *  BAR\\foo@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: BAR\n *\n *  BAR@dom\\foo@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: BAR@dom\n *\n * Invalid forms:\n *  BAR@dom\\@foo..\n *  DOM\\foo\\@bar\n *  foo@bar\\@baz\n */\n#define MAX_NAME_LEN 1024\nstatic uint32_t parse_user_name(uint32_t *minor_status,\n                                const char *str, size_t len,\n                                char **domain, char **username)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    char *at, *sep;\n\n    if (len > MAX_NAME_LEN) {\n        return GSSERRS(ERR_NAMETOOLONG, GSS_S_BAD_NAME);\n    }\n\n    *username = NULL;\n    *domain = NULL;\n\n    /* let's check if there are '@' or '\\' signs */\n    at = memchr(str, '@', len);\n    sep = memchr(str, '\\\\', len);\n\n    /* Check if enterprise name first */\n    if (at && sep) {\n        /* we may have an enterprise name here */\n        char strbuf[len + 1];\n        char *buf = strbuf;\n        bool domain_handled = false;\n\n        /* copy buf to manipulate it */\n        memcpy(buf, str, len);\n        buf[len] = '\\0';\n\n        /* adjust pointers relative to new buffer */\n        sep = buf + (sep - str);\n        at = buf + (at - str);\n\n        if (sep > at) {\n            /* domain name contains an '@' sign ... */\n            if (*(sep + 1) == '@') {\n                /* invalid case of XXX@YYY\\@ZZZ*/\n                set_GSSERR(EINVAL);\n                goto done;\n            }\n        } else if (at - sep == 1) {\n            /* it's just a '\\@' escape */\n            /* no leading domain */\n            sep = NULL;\n        }\n\n        if (sep) {\n            /* leading domain, copy if domain name is not empty */\n            domain_handled = true;\n\n            /* terminate and copy domain, even if empty */\n            /* NOTE: this is important for the Windbind integration case\n             * where we need to tell the machinery to *not* add the default\n             * domain name, it happens when the domain is NULL. */\n            *sep = '\\0';\n            *domain = strdup(buf);\n            if (NULL == *domain) {\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n            /* point buf at username part */\n            len = len - (sep - buf) - 1;\n            buf = sep + 1;\n        }\n\n        for (at = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {\n            if (*(at - 1) == '\\\\') {\n                if (domain_handled) {\n                    /* Invalid forms like DOM\\foo\\@bar or foo@bar\\@baz */\n                    free(*domain);\n                    *domain = NULL;\n                    set_GSSERR(EINVAL);\n                    goto done;\n                }\n                /* remove escape, moving all including terminating '\\0' */\n                memmove(at - 1, at, len - (at - buf) + 1);\n            } else if (!domain_handled) {\n                /* an '@' without escape and no previous\n                 * domain was split out.\n                 * the rest of the string is the domain */\n                *at = '\\0';\n                *domain = strdup(at + 1);\n                if (NULL == *domain) {\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n                /* note we continue the loop to check if any invalid\n                 * \\@ escapes is found in the domain part */\n            }\n            at += 1;\n        }\n\n        *username = strdup(buf);\n        if (NULL == *username) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n\n        /* we got an enterprise name, return */\n        set_GSSERRS(0, GSS_S_COMPLETE);\n        goto done;\n    }\n\n    /* Check if in classic DOMAIN\\User windows format */\n    if (sep) {\n        retmaj = string_split(&retmin, '\\\\', str, len, domain, username);\n        goto done;\n    }\n\n    /* else accept a user@domain format too */\n    if (at) {\n        retmaj = string_split(&retmin, '@', str, len, username, domain);\n        goto done;\n    }\n\n    /* finally, take string as simple user name */\n    *username = strndup(str, len);\n    if (NULL == *username) {\n        set_GSSERR(ENOMEM);\n    }\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}\n\nstatic uint32_t uid_to_name(uint32_t *minor_status, uid_t uid, char **name)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    struct passwd *pw;\n\n    pw = getpwuid(uid);\n    if (pw) {\n        return GSSERRS(ERR_NOUSRFOUND, GSS_S_FAILURE);\n    }\n    *name = strdup(pw->pw_name);\n    if (!*name) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}\n\nuint32_t gssntlm_import_name_by_mech(uint32_t *minor_status,\n                                     gss_const_OID mech_type,\n                                     gss_buffer_t input_name_buffer,\n                                     gss_OID input_name_type,\n                                     gss_name_t *output_name)\n{\n    struct gssntlm_name *name = NULL;\n    uint32_t retmaj;\n    uint32_t retmin;\n\n    /* TODO: check mech_type == gssntlm_oid */\n    if (mech_type == GSS_C_NO_OID) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    name = calloc(1, sizeof(struct gssntlm_name));\n    if (!name) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n\n    /* treat null OID like NT_USER_NAME */\n    if (input_name_type == GSS_C_NULL_OID) {\n        input_name_type = GSS_C_NT_USER_NAME;\n    }\n\n    if (gss_oid_equal(input_name_type, GSS_C_NT_HOSTBASED_SERVICE) ||\n        gss_oid_equal(input_name_type, GSS_C_NT_HOSTBASED_SERVICE_X)) {\n        char *spn = NULL;\n        char *p = NULL;\n\n        name->type = GSSNTLM_NAME_SERVER;\n\n        if (input_name_buffer->length > 0) {\n            spn = strndup(input_name_buffer->value, input_name_buffer->length);\n            if (!spn) {\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n            p = strchr(spn, '@');\n            if (p && input_name_buffer->length == 1) {\n                free(spn);\n                spn = p = NULL;\n            }\n        }\n\n        if (p) {\n            /* Windows expects a SPN not a GSS Name */\n            if (p != spn) {\n                *p = '/';\n                name->data.server.spn = spn;\n                spn = NULL;\n            }\n            p += 1;\n            name->data.server.name = strdup(p);\n            if (!name->data.server.name) {\n                free(spn);\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n        } else {\n            char hostname[HOST_NAME_MAX + 1] = { 0 };\n            size_t l, r;\n            /* no seprator, assume only service is provided and try to\n             * source the local host name */\n            retmin = gethostname(hostname, HOST_NAME_MAX);\n            if (retmin) {\n                free(spn);\n                set_GSSERR(retmin);\n                goto done;\n            }\n            hostname[HOST_NAME_MAX] = '\\0';\n            if (spn != NULL) {\n                /* spn = <service> + </> + <hostname> + <\\0> */\n                l = strlen(spn) + 1 + strlen(hostname) + 1;\n                name->data.server.spn = malloc(l);\n                if (!name->data.server.spn) {\n                    free(spn);\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n                r = snprintf(name->data.server.spn, l, \"%s/%s\", spn, hostname);\n                if (r != l - 1) {\n                    free(spn);\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n            }\n            name->data.server.name = strdup(hostname);\n            if (!name->data.server.name) {\n                free(spn);\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n        }\n        free(spn);\n        set_GSSERRS(0, GSS_S_COMPLETE);\n\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_USER_NAME)) {\n\n        name->type = GSSNTLM_NAME_USER;\n        retmaj = parse_user_name(&retmin,\n                                 input_name_buffer->value,\n                                 input_name_buffer->length,\n                                 &name->data.user.domain,\n                                 &name->data.user.name);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_MACHINE_UID_NAME)) {\n        uid_t uid;\n\n        name->type = GSSNTLM_NAME_USER;\n        name->data.user.domain = NULL;\n\n        uid = *(uid_t *)input_name_buffer->value;\n        retmaj = uid_to_name(&retmin, uid, &name->data.user.name);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_STRING_UID_NAME)) {\n        char struid[12] = { 0 };\n        uid_t uid;\n\n        name->type = GSSNTLM_NAME_USER;\n        name->data.user.domain = NULL;\n\n        if (input_name_buffer->length > 12) {\n            set_GSSERR(ERR_BADARG);\n            goto done;\n        }\n        memcpy(struid, input_name_buffer->value, input_name_buffer->length);\n        struid[11] = '\\0';\n        errno = 0;\n        uid = strtol(struid, NULL, 10);\n        if (errno) {\n            set_GSSERR(ERR_BADARG);\n            goto done;\n        }\n        retmaj = uid_to_name(&retmin, uid, &name->data.user.name);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_ANONYMOUS)) {\n        name->type = GSSNTLM_NAME_ANON;\n        set_GSSERRS(0, GSS_S_COMPLETE);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_EXPORT_NAME)) {\n        /* TODO */\n        set_GSSERRS(ERR_NOTSUPPORTED, GSS_S_BAD_NAMETYPE);\n    } else {\n        set_GSSERRS(ERR_BADARG, GSS_S_BAD_NAMETYPE);\n    }\n\ndone:\n    if (retmaj != GSS_S_COMPLETE) {\n        uint32_t tmpmin;\n        gssntlm_release_name(&tmpmin, (gss_name_t *)&name);\n    } else {\n        *output_name = (gss_name_t)name;\n    }\n    return GSSERR();\n}\n\nuint32_t gssntlm_import_name(uint32_t *minor_status,\n                             gss_buffer_t input_name_buffer,\n                             gss_OID input_name_type,\n                             gss_name_t *output_name)\n{\n    return gssntlm_import_name_by_mech(minor_status,\n                                       discard_const(&gssntlm_oid),\n                                       input_name_buffer,\n                                       input_name_type,\n                                       output_name);\n}\n\nsize_t gssntlm_get_attrs_count(const struct gssntlm_name_attribute *attrs)\n{\n    size_t c;\n    for (c = 0; attrs && attrs[c].attr_name != NULL; c++) ;\n    return c;\n}\n\nint gssntlm_copy_attrs(const struct gssntlm_name_attribute *src,\n                       struct gssntlm_name_attribute **dst)\n{\n    struct gssntlm_name_attribute *copied_attrs;\n    size_t attrs_count = gssntlm_get_attrs_count(src);\n\n    *dst = NULL;\n    if (attrs_count == 0) {\n        return 0;\n    }\n\n    copied_attrs = calloc(attrs_count + 1, /* +1 for terminator entry */\n                          sizeof(struct gssntlm_name_attribute));\n    if (copied_attrs == NULL) {\n        return ENOMEM;\n    }\n\n    for (size_t i = 0; i < attrs_count; i++) {\n        copied_attrs[i].attr_name = strdup(src[i].attr_name);\n        if (copied_attrs[i].attr_name == NULL) {\n            gssntlm_release_attrs(&copied_attrs);\n            return ENOMEM;\n        }\n        copied_attrs[i].attr_value.length = src[i].attr_value.length;\n        copied_attrs[i].attr_value.value = malloc(src[i].attr_value.length);\n        if (copied_attrs[i].attr_value.value == NULL) {\n            gssntlm_release_attrs(&copied_attrs);\n            return ENOMEM;\n        }\n        memcpy(copied_attrs[i].attr_value.value, src[i].attr_value.value,\n               src[i].attr_value.length);\n    }\n    /* terminator entry is filled with zeroes by calloc */\n\n    *dst = copied_attrs;\n    return 0;\n}\n\nstruct gssntlm_name_attribute *gssntlm_find_attr(\n                                        struct gssntlm_name_attribute *attrs,\n                                        const char *attr_name,\n                                        size_t attr_name_len)\n{\n    for (size_t i = 0; attrs && (attrs[i].attr_name != NULL); i++) {\n        /* We store attr_name as a zero-terminated string, so\n         * it is always zero-terminated */\n        if (attr_name_len == strlen(attrs[i].attr_name) &&\n            strncasecmp(attrs[i].attr_name, attr_name, attr_name_len) == 0) {\n            return &attrs[i];\n        }\n    }\n    return NULL;\n}\n\nvoid gssntlm_release_attrs(struct gssntlm_name_attribute **attrs)\n{\n    for (size_t i = 0; *attrs && (*attrs)[i].attr_name != NULL; i++) {\n        free((*attrs)[i].attr_name);\n        free((*attrs)[i].attr_value.value);\n    }\n    safefree(*attrs);\n}\n\nint gssntlm_copy_name(struct gssntlm_name *src, struct gssntlm_name *dst)\n{\n    char *dom = NULL, *usr = NULL, *spn = NULL, *srv = NULL;\n    int ret;\n    dst->type = src->type;\n    switch (src->type) {\n    case GSSNTLM_NAME_NULL:\n    case GSSNTLM_NAME_ANON:\n        break;\n    case GSSNTLM_NAME_USER:\n        if (src->data.user.domain) {\n            dom = strdup(src->data.user.domain);\n            if (!dom) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        if (src->data.user.name) {\n            usr = strdup(src->data.user.name);\n            if (!usr) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        dst->data.user.domain = dom;\n        dst->data.user.name = usr;\n        break;\n    case GSSNTLM_NAME_SERVER:\n        if (src->data.server.spn) {\n            spn = strdup(src->data.server.spn);\n            if (!spn) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        dst->data.server.spn = spn;\n        if (src->data.server.name) {\n            srv = strdup(src->data.server.name);\n            if (!srv) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        dst->data.server.name = srv;\n        break;\n    }\n\n    ret = gssntlm_copy_attrs(src->attrs, &dst->attrs);\n    if (ret) goto done;\n\n    ret = 0;\ndone:\n    if (ret) {\n        safefree(dom);\n        safefree(usr);\n        safefree(spn);\n        safefree(srv);\n    }\n    return ret;\n}\n\nuint32_t gssntlm_duplicate_name(uint32_t *minor_status,\n                                const gss_name_t input_name,\n                                gss_name_t *dest_name)\n{\n    struct gssntlm_name *in;\n    struct gssntlm_name *out;\n    uint32_t retmin;\n    uint32_t retmaj;\n\n    if (input_name == GSS_C_NO_NAME || dest_name == NULL) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    in = (struct gssntlm_name *)input_name;\n\n    if (in->type == GSSNTLM_NAME_NULL) {\n        *dest_name = GSS_C_NO_NAME;\n        return GSSERRS(0, GSS_S_COMPLETE);\n    }\n\n    out = calloc(1, sizeof(struct gssntlm_name));\n    if (!out) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n\n    retmin = gssntlm_copy_name(in, out);\n    if (retmin) {\n        set_GSSERR(retmin);\n        goto done;\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    if (retmaj) {\n        safefree(out);\n    }\n    *dest_name = (gss_name_t)out;\n    return GSSERR();\n}\n\nvoid gssntlm_int_release_name(struct gssntlm_name *name)\n{\n    if (!name) return;\n\n    switch (name->type) {\n    case GSSNTLM_NAME_NULL:\n        return;\n    case GSSNTLM_NAME_ANON:\n        break;\n    case GSSNTLM_NAME_USER:\n        safefree(name->data.user.domain);\n        safefree(name->data.user.name);\n        break;\n    case GSSNTLM_NAME_SERVER:\n        safefree(name->data.server.spn);\n        safefree(name->data.server.name);\n        break;\n    }\n    gssntlm_release_attrs(&name->attrs);\n    name->type = GSSNTLM_NAME_NULL;\n}\n\nuint32_t gssntlm_release_name(uint32_t *minor_status,\n                              gss_name_t *input_name)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n\n    if (!input_name) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    gssntlm_int_release_name((struct gssntlm_name *)*input_name);\n\n    safefree(*input_name);\n    return GSSERRS(0, GSS_S_COMPLETE);\n}\n\nuint32_t gssntlm_display_name(uint32_t *minor_status,\n                              gss_name_t input_name,\n                              gss_buffer_t output_name_buffer,\n                              gss_OID *output_name_type)\n{\n    struct gssntlm_name *in;\n    gss_buffer_t out;\n    uint32_t retmaj;\n    uint32_t retmin;\n    int ret;\n\n    if (input_name == GSS_C_NO_NAME || output_name_buffer == NULL) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    in = (struct gssntlm_name *)input_name;\n    out = output_name_buffer;\n\n    switch (in->type) {\n    case GSSNTLM_NAME_NULL:\n        return GSSERRS(ERR_BADARG, GSS_S_BAD_NAME);\n    case GSSNTLM_NAME_ANON:\n        out->value = strdup(\"NT AUTHORITY\\\\ANONYMOUS LOGON\");\n        if (!out->value) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        out->length = strlen(out->value) + 1;\n        if (output_name_type) {\n            *output_name_type = GSS_C_NT_ANONYMOUS;\n        }\n        break;\n    case GSSNTLM_NAME_USER:\n        if (in->data.user.domain) {\n            ret = asprintf((char **)&out->value, \"%s\\\\%s\",\n                           in->data.user.domain, in->data.user.name);\n            if (ret == -1) {\n                out->value = NULL;\n            }\n        } else {\n            out->value = strdup(in->data.user.name);\n        }\n        if (!out->value) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        out->length = strlen(out->value) + 1;\n        if (output_name_type) {\n            *output_name_type = GSS_C_NT_USER_NAME;\n        }\n        break;\n    case GSSNTLM_NAME_SERVER:\n        out->value = strdup(in->data.server.spn);\n        if (!out->value) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        out->length = strlen(out->value) + 1;\n        if (output_name_type) {\n            *output_name_type = GSS_C_NT_HOSTBASED_SERVICE;\n        }\n        break;\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}\n\n#define PWBUFLEN 1024\n\nuint32_t gssntlm_localname(uint32_t *minor_status,\n\t                   const gss_name_t name,\n\t                   gss_const_OID mech_type,\n\t                   gss_buffer_t localname)\n{\n    struct gssntlm_name *in;\n    char *uname = NULL;\n    char pwbuf[PWBUFLEN];\n    struct passwd pw, *res;\n    uint32_t retmaj;\n    uint32_t retmin;\n    int ret;\n\n    in = (struct gssntlm_name *)name;\n    if (in->type != GSSNTLM_NAME_USER) {\n        set_GSSERRS(ERR_BADARG, GSS_S_BAD_NAME);\n        goto done;\n    }\n\n    /* TODO: hook up with winbindd/sssd for name resolution ? */\n\n    if (in->data.user.domain) {\n        ret = asprintf(&uname, \"%s\\\\%s\",\n                       in->data.user.domain, in->data.user.name);\n        if (ret == -1) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        ret = getpwnam_r(uname, &pw, pwbuf, PWBUFLEN, &res);\n        if (ret) {\n            set_GSSERR(ret);\n            goto done;\n        }\n        safefree(uname);\n        if (res) {\n            uname = strdup(res->pw_name);\n        }\n    }\n    if (uname == NULL) {\n        ret = getpwnam_r(in->data.user.name, &pw, pwbuf, PWBUFLEN, &res);\n        if (ret != 0 || res == NULL) {\n            set_GSSERR(ret);\n            goto done;\n        }\n        uname = strdup(res->pw_name);\n    }\n    if (!uname) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    if (retmaj) {\n        safefree(uname);\n    } else {\n        localname->value = uname;\n        localname->length = strlen(uname) + 1;\n    }\n    return GSSERR();\n}\n\nuint32_t netbios_get_names(void *ctx, char *computer_name,\n                           char **netbios_host, char **netbios_domain)\n{\n    char *nb_computer_name = NULL;\n    char *nb_domain_name = NULL;\n    char *env_name;\n    uint32_t ret;\n\n    env_name = getenv(\"NETBIOS_COMPUTER_NAME\");\n    if (env_name) {\n        nb_computer_name = strdup(env_name);\n        if (!nb_computer_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    env_name = getenv(\"NETBIOS_DOMAIN_NAME\");\n    if (env_name) {\n        nb_domain_name = strdup(env_name);\n        if (!nb_domain_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (!nb_computer_name || !nb_domain_name) {\n        /* fetch only mising ones */\n        ret = external_netbios_get_names(ctx,\n                    nb_computer_name ? NULL : &nb_computer_name,\n                    nb_domain_name ? NULL : &nb_domain_name);\n        if ((ret != 0) &&\n            (ret != ENOENT) &&\n            (ret != ERR_NOTAVAIL)) {\n            goto done;\n        }\n    }\n\n    if (!nb_computer_name) {\n        char *p;\n        p = strchr(computer_name, '.');\n        if (p) {\n            nb_computer_name = strndup(computer_name, p - computer_name);\n        } else {\n            nb_computer_name = strdup(computer_name);\n        }\n        for (p = nb_computer_name; p && *p; p++) {\n            /* Can only be ASCII, so toupper is safe */\n            *p = toupper(*p);\n        }\n        if (!nb_computer_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (!nb_domain_name) {\n        nb_domain_name = strdup(DEF_NB_DOMAIN);\n        if (!nb_domain_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    ret = 0;\n\ndone:\n    if (ret) {\n        safefree(nb_computer_name);\n        safefree(nb_domain_name);\n    }\n\n    *netbios_domain = nb_domain_name;\n    *netbios_host = nb_computer_name;\n    return ret;\n}\n\nuint32_t gssntlm_inquire_name(uint32_t *minor_status,\n                              gss_name_t name,\n                              int *name_is_MN,\n                              gss_OID *MN_mech,\n                              gss_buffer_set_t *attrs)\n{\n    uint32_t retmin = 0;\n    uint32_t retmaj = 0;\n    uint32_t tmpmin;\n    const struct gssntlm_name *in = (const struct gssntlm_name *)name;\n\n    if (!attrs) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_WRITE);\n    }\n    *attrs = GSS_C_NO_BUFFER_SET;\n\n    if (name == GSS_C_NO_NAME) {\n        return GSSERRS(GSS_S_BAD_NAME, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    for (size_t i = 0; in->attrs && in->attrs[i].attr_name != NULL; i++) {\n        struct gssntlm_name_attribute *attr = &in->attrs[i];\n        size_t attr_name_len = strlen(attr->attr_name);\n        gss_buffer_desc buf;\n        gss_buffer_t attr_value = &attr->attr_value;\n        /* +1 for '=' separator and +1 for EOL */\n        size_t full_string_len = attr_value->length + attr_name_len + 2;\n        size_t offset = 0;\n        char *attr_string = malloc(full_string_len);\n        if (attr_string == NULL) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n\n        /* Construct 'attr_name=<attr_value>\\0' string */\n        memcpy(attr_string, attr->attr_name, attr_name_len);\n        offset += attr_name_len;\n\n        attr_string[offset++] = '=';\n\n        memcpy(attr_string + offset, attr_value->value, attr_value->length);\n        offset += attr_value->length;\n\n        attr_string[offset] = 0;\n\n        /* now add a buffer to output set */\n        buf.length = full_string_len;\n        buf.value = attr_string;\n        retmaj = gss_add_buffer_set_member(&retmin, &buf, attrs);\n        free(attr_string);\n        if (retmaj != GSS_S_COMPLETE) goto done;\n    }\n\ndone:\n    if (retmaj) {\n        (void)gss_release_buffer_set(&tmpmin, attrs);\n    }\n    return GSSERRS(retmin, retmaj);\n}\n\n/* RFC6680 - GSSAPI Naming Extensions */\nuint32_t gssntlm_get_name_attribute(uint32_t *minor_status,\n                                    gss_name_t name,\n                                    gss_buffer_t attr,\n                                    int *authenticated,\n                                    int *complete,\n                                    gss_buffer_t value,\n                                    gss_buffer_t display_value,\n                                    int *more)\n{\n    uint32_t retmin;\n    uint32_t retmaj;\n    const struct gssntlm_name *in = (const struct gssntlm_name *)name;\n    struct gssntlm_name_attribute *found_attr;\n\n    if (name == GSS_C_NO_NAME) {\n        return GSSERRS(GSS_S_BAD_NAME, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n    if (attr == NULL) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    if (display_value) {\n        display_value->value = NULL;\n        display_value->length = 0;\n    }\n    if (more) { *more = 0; }\n    if (authenticated) { *authenticated = 0; }\n    if (complete) { *complete = 0; }\n\n    found_attr = gssntlm_find_attr(in->attrs, attr->value, attr->length);\n    if (!found_attr) {\n        return GSSERRS(ENOENT, GSS_S_UNAVAILABLE);\n    }\n\n    if (authenticated) { *authenticated = 1; }\n    if (complete) { *complete = 1; }\n    if (value) {\n        gss_buffer_t attr_value = &found_attr->attr_value;\n        value->value = malloc(attr_value->length);\n        if (!value->value) {\n            return GSSERRS(ENOMEM, GSS_S_FAILURE);\n        }\n        memcpy(value->value, attr_value->value, attr_value->length);\n        value->length = attr_value->length;\n    }\n    return GSSERRS(0, GSS_S_COMPLETE);\n}\n\n/* RFC5801 Extensions */\n\n#define GS2_NTLM_SASL_NAME        \"GS2-NTLM\"\n#define GS2_NTLM_SASL_NAME_LEN    (sizeof(GS2_NTLM_SASL_NAME) - 1)\n\nuint32_t gssntlm_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                           const gss_OID desired_mech,\n                                           gss_buffer_t sasl_mech_name,\n                                           gss_buffer_t mech_name,\n                                           gss_buffer_t mech_description)\n{\n    if (desired_mech && !gss_oid_equal(desired_mech, &gssntlm_oid)) {\n        *minor_status = ENOENT;\n        return GSS_S_BAD_MECH;\n    }\n\n    sasl_mech_name->value = NULL;\n    mech_name->value = NULL;\n    mech_description->value = NULL;\n\n    *minor_status = ENOMEM;\n\n    sasl_mech_name->value = strdup(GS2_NTLM_SASL_NAME);\n    if (sasl_mech_name->value == NULL) {\n        goto done;\n    }\n    sasl_mech_name->length = strlen(sasl_mech_name->value);\n\n    mech_name->value = strdup(\"NTLM\");\n    if (mech_name->value == NULL) {\n        goto done;\n    }\n    mech_name->length = strlen(mech_name->value);\n\n    mech_description->value = strdup(\"NTLM Mechanism\");\n    if (mech_name->value == NULL) {\n        goto done;\n    }\n    mech_description->length = strlen(mech_description->value);\n\n    *minor_status = 0;\n\ndone:\n    if (*minor_status != 0) {\n        free(sasl_mech_name->value);\n        free(mech_name->value);\n        free(mech_description->value);\n        return GSS_S_FAILURE;\n    }\n\n    return GSS_S_COMPLETE;\n}\n\nuint32_t gssntlm_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                           const gss_buffer_t sasl_mech_name,\n                                           gss_OID *mech_type)\n{\n    if (sasl_mech_name->length == GS2_NTLM_SASL_NAME_LEN &&\n        memcmp(sasl_mech_name->value,\n               GS2_NTLM_SASL_NAME, GS2_NTLM_SASL_NAME_LEN) == 0) {\n        if (mech_type != NULL) {\n            *mech_type = discard_const(&gssntlm_oid);\n        }\n        *minor_status = 0;\n        return GSS_S_COMPLETE;\n    }\n\n    *minor_status = ENOENT;\n    return GSS_S_BAD_MECH;\n\n}\n\nstatic uint32_t make_ma_oid_set(uint32_t *minor_status, gss_OID_set *ma_set,\n                                int supported)\n{\n    gss_const_OID known_mech_attrs[] = {\n        GSS_C_MA_MECH_CONCRETE,\n        GSS_C_MA_MECH_PSEUDO,\n        GSS_C_MA_MECH_COMPOSITE,\n        GSS_C_MA_MECH_NEGO,\n        GSS_C_MA_MECH_GLUE,\n        GSS_C_MA_NOT_MECH,\n        GSS_C_MA_DEPRECATED,\n        GSS_C_MA_NOT_DFLT_MECH,\n        GSS_C_MA_ITOK_FRAMED,\n        GSS_C_MA_AUTH_INIT,\n        GSS_C_MA_AUTH_TARG,\n        GSS_C_MA_AUTH_INIT_INIT,\n        GSS_C_MA_AUTH_TARG_INIT,\n        GSS_C_MA_AUTH_INIT_ANON,\n        GSS_C_MA_AUTH_TARG_ANON,\n        GSS_C_MA_DELEG_CRED,\n        GSS_C_MA_INTEG_PROT,\n        GSS_C_MA_CONF_PROT,\n        GSS_C_MA_MIC,\n        GSS_C_MA_WRAP,\n        GSS_C_MA_PROT_READY,\n        GSS_C_MA_REPLAY_DET,\n        GSS_C_MA_OOS_DET,\n        GSS_C_MA_CBINDINGS,\n        GSS_C_MA_PFS,\n        GSS_C_MA_COMPRESS,\n        GSS_C_MA_CTX_TRANS,\n        NULL\n    };\n    gss_const_OID supported_mech_attrs[] = {\n        GSS_C_MA_MECH_CONCRETE,\n        GSS_C_MA_AUTH_INIT,\n        GSS_C_MA_INTEG_PROT,\n        GSS_C_MA_CONF_PROT,\n        GSS_C_MA_MIC,\n        GSS_C_MA_WRAP,\n        GSS_C_MA_OOS_DET,\n        GSS_C_MA_CBINDINGS,\n        GSS_C_MA_CTX_TRANS,\n        NULL\n    };\n    uint32_t maj = 0;\n    uint32_t min = 0;\n    gss_const_OID *array = known_mech_attrs;\n\n    if (supported) {\n        array = supported_mech_attrs;\n    }\n\n    maj = gss_create_empty_oid_set(&min, ma_set);\n    if (maj != GSS_S_COMPLETE) {\n        goto done;\n    }\n    for (int i = 0; array[i] != NULL; i++) {\n        maj = gss_add_oid_set_member(&min, discard_const(array[i]), ma_set);\n        if (maj != GSS_S_COMPLETE) {\n            goto done;\n        }\n    }\n\ndone:\n    *minor_status = min;\n    return maj;\n}\n\nuint32_t gssntlm_inquire_attrs_for_mech(uint32_t *minor_status,\n\t\t\t\t\tgss_const_OID mech_oid,\n\t\t\t\t\tgss_OID_set *mech_attrs,\n\t\t\t\t\tgss_OID_set *known_mech_attrs)\n{\n    gss_OID_set s_ma = GSS_C_NULL_OID_SET;\n    gss_OID_set k_ma = GSS_C_NULL_OID_SET;\n    uint32_t maj = GSS_S_COMPLETE;\n    uint32_t min = 0;\n\n    if (mech_oid && !gss_oid_equal(mech_oid, &gssntlm_oid)) {\n        *minor_status = ENOENT;\n        return GSS_S_BAD_MECH;\n    }\n\n    if (mech_attrs != NULL) {\n        maj = make_ma_oid_set(&min, &s_ma, 1);\n        if (maj != GSS_S_COMPLETE) {\n            goto done;\n        }\n    }\n    if (known_mech_attrs != NULL) {\n        maj = make_ma_oid_set(&min, &k_ma, 0);\n        if (maj != GSS_S_COMPLETE) {\n            goto done;\n        }\n    }\n\ndone:\n    if (maj != GSS_S_COMPLETE) {\n        gss_release_oid_set(&min, &s_ma);\n        gss_release_oid_set(&min, &k_ma);\n    }\n    if (mech_attrs != NULL) {\n        *mech_attrs = s_ma;\n    }\n    if (known_mech_attrs != NULL) {\n        *known_mech_attrs = k_ma;\n    }\n\n    *minor_status = min;\n    return maj;\n}\n"], "fixing_code": ["/* Copyright 2013-2022 Simo Sorce <simo@samba.org>, see COPYING for license */\n\n#define _GNU_SOURCE\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_ext.h>\n\n#include \"gss_ntlmssp.h\"\n\n#ifndef\tHOST_NAME_MAX\n#include <sys/param.h>\n#define\tHOST_NAME_MAX\tMAXHOSTNAMELEN\n#endif\n\nstatic uint32_t string_split(uint32_t *minor_status, char sep,\n                             const char *str, size_t len,\n                             char **s1, char **s2)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    char *r1 = NULL;\n    char *r2 = NULL;\n    const char *p;\n    size_t l;\n\n    p = memchr(str, sep, len);\n    if (!p) return GSSERRS(0, GSS_S_UNAVAILABLE);\n\n    /* left side */\n    l = p - str;\n    if (s1 && l != 0) {\n        r1 = strndup(str, l);\n        if (!r1) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n    }\n\n    /* right side */\n    p++;\n    l = len - (p - str);\n    if (s2 && l != 0) {\n        r2 = strndup(p, l);\n        if (!r2) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    if (retmaj) {\n        free(r1);\n        free(r2);\n    } else {\n        if (s1) *s1 = r1;\n        if (s2) *s2 = r2;\n    }\n    return GSSERR();\n}\n\n/* Form of names allowed in GSSNTLMSSP now:\n *\n * Standard Forms:\n *  foo\n *      USERNAME: foo\n *      DOMAIN: <null>\n *\n *  BAR\\foo\n *      USERNAME: foo\n *      DOMAIN: BAR\n *\n *  foo@BAR\n *      USERNAME: foo\n *      DOMAIN: BAR\n *\n * Enterprise name forms:\n *  foo\\@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: <null>\n *\n *  foo\\@bar.example.com@BAR\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: BAR\n *\n *  \\foo@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: <null>\n *\n *  BAR\\foo@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: BAR\n *\n *  BAR@dom\\foo@bar.example.com\n *      USERNAME: foo@bar.example.com\n *      DOMAIN: BAR@dom\n *\n * Invalid forms:\n *  BAR@dom\\@foo..\n *  DOM\\foo\\@bar\n *  foo@bar\\@baz\n */\n#define MAX_NAME_LEN 1024\nstatic uint32_t parse_user_name(uint32_t *minor_status,\n                                const char *str, size_t len,\n                                char **domain, char **username)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    char *at, *sep;\n\n    if (len > MAX_NAME_LEN) {\n        return GSSERRS(ERR_NAMETOOLONG, GSS_S_BAD_NAME);\n    }\n\n    *username = NULL;\n    *domain = NULL;\n\n    /* let's check if there are '@' or '\\' signs */\n    at = memchr(str, '@', len);\n    sep = memchr(str, '\\\\', len);\n\n    /* Check if enterprise name first */\n    if (at && sep) {\n        /* we may have an enterprise name here */\n        char strbuf[len + 1];\n        char *buf = strbuf;\n\n        /* copy buf to manipulate it */\n        memcpy(buf, str, len);\n        buf[len] = '\\0';\n\n        /* adjust pointers relative to new buffer */\n        sep = buf + (sep - str);\n        at = buf + (at - str);\n\n        if (sep > at) {\n            /* domain name contains an '@' sign ... */\n            if (*(sep + 1) == '@') {\n                /* invalid case of XXX@YYY\\@ZZZ*/\n                set_GSSERR(EINVAL);\n                goto done;\n            }\n        } else if (at - sep == 1) {\n            /* it's just a '\\@' escape */\n            /* no leading domain */\n            sep = NULL;\n        }\n\n        if (sep) {\n            /* terminate and copy domain, even if empty */\n            /* NOTE: this is important for the Windbind integration case\n             * where we need to tell the machinery to *not* add the default\n             * domain name, it happens when the domain is NULL. */\n            *sep = '\\0';\n            *domain = strdup(buf);\n            if (NULL == *domain) {\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n            /* point buf at username part */\n            len = len - (sep - buf) - 1;\n            buf = sep + 1;\n        }\n\n        for (at = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {\n            if (*(at - 1) == '\\\\') {\n                if (*domain) {\n                    /* Invalid forms like DOM\\foo\\@bar or foo@bar\\@baz */\n                    free(*domain);\n                    *domain = NULL;\n                    set_GSSERR(EINVAL);\n                    goto done;\n                }\n                /* remove escape, moving all including terminating '\\0' */\n                memmove(at - 1, at, len - (at - buf) + 1);\n            } else if (!*domain) {\n                /* an '@' without escape and no previous\n                 * domain was split out.\n                 * the rest of the string is the domain */\n                *at = '\\0';\n                *domain = strdup(at + 1);\n                if (NULL == *domain) {\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n                /* note we continue the loop to check if any invalid\n                 * \\@ escapes is found in the domain part */\n            }\n            at += 1;\n        }\n\n        *username = strdup(buf);\n        if (NULL == *username) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n\n        /* we got an enterprise name, return */\n        set_GSSERRS(0, GSS_S_COMPLETE);\n        goto done;\n    }\n\n    /* Check if in classic DOMAIN\\User windows format */\n    if (sep) {\n        retmaj = string_split(&retmin, '\\\\', str, len, domain, username);\n        goto done;\n    }\n\n    /* else accept a user@domain format too */\n    if (at) {\n        retmaj = string_split(&retmin, '@', str, len, username, domain);\n        goto done;\n    }\n\n    /* finally, take string as simple user name */\n    *username = strndup(str, len);\n    if (NULL == *username) {\n        set_GSSERR(ENOMEM);\n    }\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}\n\nstatic uint32_t uid_to_name(uint32_t *minor_status, uid_t uid, char **name)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    struct passwd *pw;\n\n    pw = getpwuid(uid);\n    if (pw) {\n        return GSSERRS(ERR_NOUSRFOUND, GSS_S_FAILURE);\n    }\n    *name = strdup(pw->pw_name);\n    if (!*name) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}\n\nuint32_t gssntlm_import_name_by_mech(uint32_t *minor_status,\n                                     gss_const_OID mech_type,\n                                     gss_buffer_t input_name_buffer,\n                                     gss_OID input_name_type,\n                                     gss_name_t *output_name)\n{\n    struct gssntlm_name *name = NULL;\n    uint32_t retmaj;\n    uint32_t retmin;\n\n    /* TODO: check mech_type == gssntlm_oid */\n    if (mech_type == GSS_C_NO_OID) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    name = calloc(1, sizeof(struct gssntlm_name));\n    if (!name) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n\n    /* treat null OID like NT_USER_NAME */\n    if (input_name_type == GSS_C_NULL_OID) {\n        input_name_type = GSS_C_NT_USER_NAME;\n    }\n\n    if (gss_oid_equal(input_name_type, GSS_C_NT_HOSTBASED_SERVICE) ||\n        gss_oid_equal(input_name_type, GSS_C_NT_HOSTBASED_SERVICE_X)) {\n        char *spn = NULL;\n        char *p = NULL;\n\n        name->type = GSSNTLM_NAME_SERVER;\n\n        if (input_name_buffer->length > 0) {\n            spn = strndup(input_name_buffer->value, input_name_buffer->length);\n            if (!spn) {\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n            p = strchr(spn, '@');\n            if (p && input_name_buffer->length == 1) {\n                free(spn);\n                spn = p = NULL;\n            }\n        }\n\n        if (p) {\n            /* Windows expects a SPN not a GSS Name */\n            if (p != spn) {\n                *p = '/';\n                name->data.server.spn = spn;\n                spn = NULL;\n            }\n            p += 1;\n            name->data.server.name = strdup(p);\n            if (!name->data.server.name) {\n                free(spn);\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n        } else {\n            char hostname[HOST_NAME_MAX + 1] = { 0 };\n            size_t l, r;\n            /* no seprator, assume only service is provided and try to\n             * source the local host name */\n            retmin = gethostname(hostname, HOST_NAME_MAX);\n            if (retmin) {\n                free(spn);\n                set_GSSERR(retmin);\n                goto done;\n            }\n            hostname[HOST_NAME_MAX] = '\\0';\n            if (spn != NULL) {\n                /* spn = <service> + </> + <hostname> + <\\0> */\n                l = strlen(spn) + 1 + strlen(hostname) + 1;\n                name->data.server.spn = malloc(l);\n                if (!name->data.server.spn) {\n                    free(spn);\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n                r = snprintf(name->data.server.spn, l, \"%s/%s\", spn, hostname);\n                if (r != l - 1) {\n                    free(spn);\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n            }\n            name->data.server.name = strdup(hostname);\n            if (!name->data.server.name) {\n                free(spn);\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n        }\n        free(spn);\n        set_GSSERRS(0, GSS_S_COMPLETE);\n\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_USER_NAME)) {\n\n        name->type = GSSNTLM_NAME_USER;\n        retmaj = parse_user_name(&retmin,\n                                 input_name_buffer->value,\n                                 input_name_buffer->length,\n                                 &name->data.user.domain,\n                                 &name->data.user.name);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_MACHINE_UID_NAME)) {\n        uid_t uid;\n\n        name->type = GSSNTLM_NAME_USER;\n        name->data.user.domain = NULL;\n\n        uid = *(uid_t *)input_name_buffer->value;\n        retmaj = uid_to_name(&retmin, uid, &name->data.user.name);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_STRING_UID_NAME)) {\n        char struid[12] = { 0 };\n        uid_t uid;\n\n        name->type = GSSNTLM_NAME_USER;\n        name->data.user.domain = NULL;\n\n        if (input_name_buffer->length > 12) {\n            set_GSSERR(ERR_BADARG);\n            goto done;\n        }\n        memcpy(struid, input_name_buffer->value, input_name_buffer->length);\n        struid[11] = '\\0';\n        errno = 0;\n        uid = strtol(struid, NULL, 10);\n        if (errno) {\n            set_GSSERR(ERR_BADARG);\n            goto done;\n        }\n        retmaj = uid_to_name(&retmin, uid, &name->data.user.name);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_ANONYMOUS)) {\n        name->type = GSSNTLM_NAME_ANON;\n        set_GSSERRS(0, GSS_S_COMPLETE);\n    } else if (gss_oid_equal(input_name_type, GSS_C_NT_EXPORT_NAME)) {\n        /* TODO */\n        set_GSSERRS(ERR_NOTSUPPORTED, GSS_S_BAD_NAMETYPE);\n    } else {\n        set_GSSERRS(ERR_BADARG, GSS_S_BAD_NAMETYPE);\n    }\n\ndone:\n    if (retmaj != GSS_S_COMPLETE) {\n        uint32_t tmpmin;\n        gssntlm_release_name(&tmpmin, (gss_name_t *)&name);\n    } else {\n        *output_name = (gss_name_t)name;\n    }\n    return GSSERR();\n}\n\nuint32_t gssntlm_import_name(uint32_t *minor_status,\n                             gss_buffer_t input_name_buffer,\n                             gss_OID input_name_type,\n                             gss_name_t *output_name)\n{\n    return gssntlm_import_name_by_mech(minor_status,\n                                       discard_const(&gssntlm_oid),\n                                       input_name_buffer,\n                                       input_name_type,\n                                       output_name);\n}\n\nsize_t gssntlm_get_attrs_count(const struct gssntlm_name_attribute *attrs)\n{\n    size_t c;\n    for (c = 0; attrs && attrs[c].attr_name != NULL; c++) ;\n    return c;\n}\n\nint gssntlm_copy_attrs(const struct gssntlm_name_attribute *src,\n                       struct gssntlm_name_attribute **dst)\n{\n    struct gssntlm_name_attribute *copied_attrs;\n    size_t attrs_count = gssntlm_get_attrs_count(src);\n\n    *dst = NULL;\n    if (attrs_count == 0) {\n        return 0;\n    }\n\n    copied_attrs = calloc(attrs_count + 1, /* +1 for terminator entry */\n                          sizeof(struct gssntlm_name_attribute));\n    if (copied_attrs == NULL) {\n        return ENOMEM;\n    }\n\n    for (size_t i = 0; i < attrs_count; i++) {\n        copied_attrs[i].attr_name = strdup(src[i].attr_name);\n        if (copied_attrs[i].attr_name == NULL) {\n            gssntlm_release_attrs(&copied_attrs);\n            return ENOMEM;\n        }\n        copied_attrs[i].attr_value.length = src[i].attr_value.length;\n        copied_attrs[i].attr_value.value = malloc(src[i].attr_value.length);\n        if (copied_attrs[i].attr_value.value == NULL) {\n            gssntlm_release_attrs(&copied_attrs);\n            return ENOMEM;\n        }\n        memcpy(copied_attrs[i].attr_value.value, src[i].attr_value.value,\n               src[i].attr_value.length);\n    }\n    /* terminator entry is filled with zeroes by calloc */\n\n    *dst = copied_attrs;\n    return 0;\n}\n\nstruct gssntlm_name_attribute *gssntlm_find_attr(\n                                        struct gssntlm_name_attribute *attrs,\n                                        const char *attr_name,\n                                        size_t attr_name_len)\n{\n    for (size_t i = 0; attrs && (attrs[i].attr_name != NULL); i++) {\n        /* We store attr_name as a zero-terminated string, so\n         * it is always zero-terminated */\n        if (attr_name_len == strlen(attrs[i].attr_name) &&\n            strncasecmp(attrs[i].attr_name, attr_name, attr_name_len) == 0) {\n            return &attrs[i];\n        }\n    }\n    return NULL;\n}\n\nvoid gssntlm_release_attrs(struct gssntlm_name_attribute **attrs)\n{\n    for (size_t i = 0; *attrs && (*attrs)[i].attr_name != NULL; i++) {\n        free((*attrs)[i].attr_name);\n        free((*attrs)[i].attr_value.value);\n    }\n    safefree(*attrs);\n}\n\nint gssntlm_copy_name(struct gssntlm_name *src, struct gssntlm_name *dst)\n{\n    char *dom = NULL, *usr = NULL, *spn = NULL, *srv = NULL;\n    int ret;\n    dst->type = src->type;\n    switch (src->type) {\n    case GSSNTLM_NAME_NULL:\n    case GSSNTLM_NAME_ANON:\n        break;\n    case GSSNTLM_NAME_USER:\n        if (src->data.user.domain) {\n            dom = strdup(src->data.user.domain);\n            if (!dom) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        if (src->data.user.name) {\n            usr = strdup(src->data.user.name);\n            if (!usr) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        dst->data.user.domain = dom;\n        dst->data.user.name = usr;\n        break;\n    case GSSNTLM_NAME_SERVER:\n        if (src->data.server.spn) {\n            spn = strdup(src->data.server.spn);\n            if (!spn) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        dst->data.server.spn = spn;\n        if (src->data.server.name) {\n            srv = strdup(src->data.server.name);\n            if (!srv) {\n                ret = ENOMEM;\n                goto done;\n            }\n        }\n        dst->data.server.name = srv;\n        break;\n    }\n\n    ret = gssntlm_copy_attrs(src->attrs, &dst->attrs);\n    if (ret) goto done;\n\n    ret = 0;\ndone:\n    if (ret) {\n        safefree(dom);\n        safefree(usr);\n        safefree(spn);\n        safefree(srv);\n    }\n    return ret;\n}\n\nuint32_t gssntlm_duplicate_name(uint32_t *minor_status,\n                                const gss_name_t input_name,\n                                gss_name_t *dest_name)\n{\n    struct gssntlm_name *in;\n    struct gssntlm_name *out;\n    uint32_t retmin;\n    uint32_t retmaj;\n\n    if (input_name == GSS_C_NO_NAME || dest_name == NULL) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    in = (struct gssntlm_name *)input_name;\n\n    if (in->type == GSSNTLM_NAME_NULL) {\n        *dest_name = GSS_C_NO_NAME;\n        return GSSERRS(0, GSS_S_COMPLETE);\n    }\n\n    out = calloc(1, sizeof(struct gssntlm_name));\n    if (!out) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n\n    retmin = gssntlm_copy_name(in, out);\n    if (retmin) {\n        set_GSSERR(retmin);\n        goto done;\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    if (retmaj) {\n        safefree(out);\n    }\n    *dest_name = (gss_name_t)out;\n    return GSSERR();\n}\n\nvoid gssntlm_int_release_name(struct gssntlm_name *name)\n{\n    if (!name) return;\n\n    switch (name->type) {\n    case GSSNTLM_NAME_NULL:\n        return;\n    case GSSNTLM_NAME_ANON:\n        break;\n    case GSSNTLM_NAME_USER:\n        safefree(name->data.user.domain);\n        safefree(name->data.user.name);\n        break;\n    case GSSNTLM_NAME_SERVER:\n        safefree(name->data.server.spn);\n        safefree(name->data.server.name);\n        break;\n    }\n    gssntlm_release_attrs(&name->attrs);\n    name->type = GSSNTLM_NAME_NULL;\n}\n\nuint32_t gssntlm_release_name(uint32_t *minor_status,\n                              gss_name_t *input_name)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n\n    if (!input_name) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    gssntlm_int_release_name((struct gssntlm_name *)*input_name);\n\n    safefree(*input_name);\n    return GSSERRS(0, GSS_S_COMPLETE);\n}\n\nuint32_t gssntlm_display_name(uint32_t *minor_status,\n                              gss_name_t input_name,\n                              gss_buffer_t output_name_buffer,\n                              gss_OID *output_name_type)\n{\n    struct gssntlm_name *in;\n    gss_buffer_t out;\n    uint32_t retmaj;\n    uint32_t retmin;\n    int ret;\n\n    if (input_name == GSS_C_NO_NAME || output_name_buffer == NULL) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    in = (struct gssntlm_name *)input_name;\n    out = output_name_buffer;\n\n    switch (in->type) {\n    case GSSNTLM_NAME_NULL:\n        return GSSERRS(ERR_BADARG, GSS_S_BAD_NAME);\n    case GSSNTLM_NAME_ANON:\n        out->value = strdup(\"NT AUTHORITY\\\\ANONYMOUS LOGON\");\n        if (!out->value) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        out->length = strlen(out->value) + 1;\n        if (output_name_type) {\n            *output_name_type = GSS_C_NT_ANONYMOUS;\n        }\n        break;\n    case GSSNTLM_NAME_USER:\n        if (in->data.user.domain) {\n            ret = asprintf((char **)&out->value, \"%s\\\\%s\",\n                           in->data.user.domain, in->data.user.name);\n            if (ret == -1) {\n                out->value = NULL;\n            }\n        } else {\n            out->value = strdup(in->data.user.name);\n        }\n        if (!out->value) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        out->length = strlen(out->value) + 1;\n        if (output_name_type) {\n            *output_name_type = GSS_C_NT_USER_NAME;\n        }\n        break;\n    case GSSNTLM_NAME_SERVER:\n        out->value = strdup(in->data.server.spn);\n        if (!out->value) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        out->length = strlen(out->value) + 1;\n        if (output_name_type) {\n            *output_name_type = GSS_C_NT_HOSTBASED_SERVICE;\n        }\n        break;\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}\n\n#define PWBUFLEN 1024\n\nuint32_t gssntlm_localname(uint32_t *minor_status,\n\t                   const gss_name_t name,\n\t                   gss_const_OID mech_type,\n\t                   gss_buffer_t localname)\n{\n    struct gssntlm_name *in;\n    char *uname = NULL;\n    char pwbuf[PWBUFLEN];\n    struct passwd pw, *res;\n    uint32_t retmaj;\n    uint32_t retmin;\n    int ret;\n\n    in = (struct gssntlm_name *)name;\n    if (in->type != GSSNTLM_NAME_USER) {\n        set_GSSERRS(ERR_BADARG, GSS_S_BAD_NAME);\n        goto done;\n    }\n\n    /* TODO: hook up with winbindd/sssd for name resolution ? */\n\n    if (in->data.user.domain) {\n        ret = asprintf(&uname, \"%s\\\\%s\",\n                       in->data.user.domain, in->data.user.name);\n        if (ret == -1) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n        ret = getpwnam_r(uname, &pw, pwbuf, PWBUFLEN, &res);\n        if (ret) {\n            set_GSSERR(ret);\n            goto done;\n        }\n        safefree(uname);\n        if (res) {\n            uname = strdup(res->pw_name);\n        }\n    }\n    if (uname == NULL) {\n        ret = getpwnam_r(in->data.user.name, &pw, pwbuf, PWBUFLEN, &res);\n        if (ret != 0 || res == NULL) {\n            set_GSSERR(ret);\n            goto done;\n        }\n        uname = strdup(res->pw_name);\n    }\n    if (!uname) {\n        set_GSSERR(ENOMEM);\n        goto done;\n    }\n\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    if (retmaj) {\n        safefree(uname);\n    } else {\n        localname->value = uname;\n        localname->length = strlen(uname) + 1;\n    }\n    return GSSERR();\n}\n\nuint32_t netbios_get_names(void *ctx, char *computer_name,\n                           char **netbios_host, char **netbios_domain)\n{\n    char *nb_computer_name = NULL;\n    char *nb_domain_name = NULL;\n    char *env_name;\n    uint32_t ret;\n\n    env_name = getenv(\"NETBIOS_COMPUTER_NAME\");\n    if (env_name) {\n        nb_computer_name = strdup(env_name);\n        if (!nb_computer_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    env_name = getenv(\"NETBIOS_DOMAIN_NAME\");\n    if (env_name) {\n        nb_domain_name = strdup(env_name);\n        if (!nb_domain_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (!nb_computer_name || !nb_domain_name) {\n        /* fetch only mising ones */\n        ret = external_netbios_get_names(ctx,\n                    nb_computer_name ? NULL : &nb_computer_name,\n                    nb_domain_name ? NULL : &nb_domain_name);\n        if ((ret != 0) &&\n            (ret != ENOENT) &&\n            (ret != ERR_NOTAVAIL)) {\n            goto done;\n        }\n    }\n\n    if (!nb_computer_name) {\n        char *p;\n        p = strchr(computer_name, '.');\n        if (p) {\n            nb_computer_name = strndup(computer_name, p - computer_name);\n        } else {\n            nb_computer_name = strdup(computer_name);\n        }\n        for (p = nb_computer_name; p && *p; p++) {\n            /* Can only be ASCII, so toupper is safe */\n            *p = toupper(*p);\n        }\n        if (!nb_computer_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (!nb_domain_name) {\n        nb_domain_name = strdup(DEF_NB_DOMAIN);\n        if (!nb_domain_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    ret = 0;\n\ndone:\n    if (ret) {\n        safefree(nb_computer_name);\n        safefree(nb_domain_name);\n    }\n\n    *netbios_domain = nb_domain_name;\n    *netbios_host = nb_computer_name;\n    return ret;\n}\n\nuint32_t gssntlm_inquire_name(uint32_t *minor_status,\n                              gss_name_t name,\n                              int *name_is_MN,\n                              gss_OID *MN_mech,\n                              gss_buffer_set_t *attrs)\n{\n    uint32_t retmin = 0;\n    uint32_t retmaj = 0;\n    uint32_t tmpmin;\n    const struct gssntlm_name *in = (const struct gssntlm_name *)name;\n\n    if (!attrs) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_WRITE);\n    }\n    *attrs = GSS_C_NO_BUFFER_SET;\n\n    if (name == GSS_C_NO_NAME) {\n        return GSSERRS(GSS_S_BAD_NAME, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    for (size_t i = 0; in->attrs && in->attrs[i].attr_name != NULL; i++) {\n        struct gssntlm_name_attribute *attr = &in->attrs[i];\n        size_t attr_name_len = strlen(attr->attr_name);\n        gss_buffer_desc buf;\n        gss_buffer_t attr_value = &attr->attr_value;\n        /* +1 for '=' separator and +1 for EOL */\n        size_t full_string_len = attr_value->length + attr_name_len + 2;\n        size_t offset = 0;\n        char *attr_string = malloc(full_string_len);\n        if (attr_string == NULL) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n\n        /* Construct 'attr_name=<attr_value>\\0' string */\n        memcpy(attr_string, attr->attr_name, attr_name_len);\n        offset += attr_name_len;\n\n        attr_string[offset++] = '=';\n\n        memcpy(attr_string + offset, attr_value->value, attr_value->length);\n        offset += attr_value->length;\n\n        attr_string[offset] = 0;\n\n        /* now add a buffer to output set */\n        buf.length = full_string_len;\n        buf.value = attr_string;\n        retmaj = gss_add_buffer_set_member(&retmin, &buf, attrs);\n        free(attr_string);\n        if (retmaj != GSS_S_COMPLETE) goto done;\n    }\n\ndone:\n    if (retmaj) {\n        (void)gss_release_buffer_set(&tmpmin, attrs);\n    }\n    return GSSERRS(retmin, retmaj);\n}\n\n/* RFC6680 - GSSAPI Naming Extensions */\nuint32_t gssntlm_get_name_attribute(uint32_t *minor_status,\n                                    gss_name_t name,\n                                    gss_buffer_t attr,\n                                    int *authenticated,\n                                    int *complete,\n                                    gss_buffer_t value,\n                                    gss_buffer_t display_value,\n                                    int *more)\n{\n    uint32_t retmin;\n    uint32_t retmaj;\n    const struct gssntlm_name *in = (const struct gssntlm_name *)name;\n    struct gssntlm_name_attribute *found_attr;\n\n    if (name == GSS_C_NO_NAME) {\n        return GSSERRS(GSS_S_BAD_NAME, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n    if (attr == NULL) {\n        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);\n    }\n\n    if (display_value) {\n        display_value->value = NULL;\n        display_value->length = 0;\n    }\n    if (more) { *more = 0; }\n    if (authenticated) { *authenticated = 0; }\n    if (complete) { *complete = 0; }\n\n    found_attr = gssntlm_find_attr(in->attrs, attr->value, attr->length);\n    if (!found_attr) {\n        return GSSERRS(ENOENT, GSS_S_UNAVAILABLE);\n    }\n\n    if (authenticated) { *authenticated = 1; }\n    if (complete) { *complete = 1; }\n    if (value) {\n        gss_buffer_t attr_value = &found_attr->attr_value;\n        value->value = malloc(attr_value->length);\n        if (!value->value) {\n            return GSSERRS(ENOMEM, GSS_S_FAILURE);\n        }\n        memcpy(value->value, attr_value->value, attr_value->length);\n        value->length = attr_value->length;\n    }\n    return GSSERRS(0, GSS_S_COMPLETE);\n}\n\n/* RFC5801 Extensions */\n\n#define GS2_NTLM_SASL_NAME        \"GS2-NTLM\"\n#define GS2_NTLM_SASL_NAME_LEN    (sizeof(GS2_NTLM_SASL_NAME) - 1)\n\nuint32_t gssntlm_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                           const gss_OID desired_mech,\n                                           gss_buffer_t sasl_mech_name,\n                                           gss_buffer_t mech_name,\n                                           gss_buffer_t mech_description)\n{\n    if (desired_mech && !gss_oid_equal(desired_mech, &gssntlm_oid)) {\n        *minor_status = ENOENT;\n        return GSS_S_BAD_MECH;\n    }\n\n    sasl_mech_name->value = NULL;\n    mech_name->value = NULL;\n    mech_description->value = NULL;\n\n    *minor_status = ENOMEM;\n\n    sasl_mech_name->value = strdup(GS2_NTLM_SASL_NAME);\n    if (sasl_mech_name->value == NULL) {\n        goto done;\n    }\n    sasl_mech_name->length = strlen(sasl_mech_name->value);\n\n    mech_name->value = strdup(\"NTLM\");\n    if (mech_name->value == NULL) {\n        goto done;\n    }\n    mech_name->length = strlen(mech_name->value);\n\n    mech_description->value = strdup(\"NTLM Mechanism\");\n    if (mech_name->value == NULL) {\n        goto done;\n    }\n    mech_description->length = strlen(mech_description->value);\n\n    *minor_status = 0;\n\ndone:\n    if (*minor_status != 0) {\n        free(sasl_mech_name->value);\n        free(mech_name->value);\n        free(mech_description->value);\n        return GSS_S_FAILURE;\n    }\n\n    return GSS_S_COMPLETE;\n}\n\nuint32_t gssntlm_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                           const gss_buffer_t sasl_mech_name,\n                                           gss_OID *mech_type)\n{\n    if (sasl_mech_name->length == GS2_NTLM_SASL_NAME_LEN &&\n        memcmp(sasl_mech_name->value,\n               GS2_NTLM_SASL_NAME, GS2_NTLM_SASL_NAME_LEN) == 0) {\n        if (mech_type != NULL) {\n            *mech_type = discard_const(&gssntlm_oid);\n        }\n        *minor_status = 0;\n        return GSS_S_COMPLETE;\n    }\n\n    *minor_status = ENOENT;\n    return GSS_S_BAD_MECH;\n\n}\n\nstatic uint32_t make_ma_oid_set(uint32_t *minor_status, gss_OID_set *ma_set,\n                                int supported)\n{\n    gss_const_OID known_mech_attrs[] = {\n        GSS_C_MA_MECH_CONCRETE,\n        GSS_C_MA_MECH_PSEUDO,\n        GSS_C_MA_MECH_COMPOSITE,\n        GSS_C_MA_MECH_NEGO,\n        GSS_C_MA_MECH_GLUE,\n        GSS_C_MA_NOT_MECH,\n        GSS_C_MA_DEPRECATED,\n        GSS_C_MA_NOT_DFLT_MECH,\n        GSS_C_MA_ITOK_FRAMED,\n        GSS_C_MA_AUTH_INIT,\n        GSS_C_MA_AUTH_TARG,\n        GSS_C_MA_AUTH_INIT_INIT,\n        GSS_C_MA_AUTH_TARG_INIT,\n        GSS_C_MA_AUTH_INIT_ANON,\n        GSS_C_MA_AUTH_TARG_ANON,\n        GSS_C_MA_DELEG_CRED,\n        GSS_C_MA_INTEG_PROT,\n        GSS_C_MA_CONF_PROT,\n        GSS_C_MA_MIC,\n        GSS_C_MA_WRAP,\n        GSS_C_MA_PROT_READY,\n        GSS_C_MA_REPLAY_DET,\n        GSS_C_MA_OOS_DET,\n        GSS_C_MA_CBINDINGS,\n        GSS_C_MA_PFS,\n        GSS_C_MA_COMPRESS,\n        GSS_C_MA_CTX_TRANS,\n        NULL\n    };\n    gss_const_OID supported_mech_attrs[] = {\n        GSS_C_MA_MECH_CONCRETE,\n        GSS_C_MA_AUTH_INIT,\n        GSS_C_MA_INTEG_PROT,\n        GSS_C_MA_CONF_PROT,\n        GSS_C_MA_MIC,\n        GSS_C_MA_WRAP,\n        GSS_C_MA_OOS_DET,\n        GSS_C_MA_CBINDINGS,\n        GSS_C_MA_CTX_TRANS,\n        NULL\n    };\n    uint32_t maj = 0;\n    uint32_t min = 0;\n    gss_const_OID *array = known_mech_attrs;\n\n    if (supported) {\n        array = supported_mech_attrs;\n    }\n\n    maj = gss_create_empty_oid_set(&min, ma_set);\n    if (maj != GSS_S_COMPLETE) {\n        goto done;\n    }\n    for (int i = 0; array[i] != NULL; i++) {\n        maj = gss_add_oid_set_member(&min, discard_const(array[i]), ma_set);\n        if (maj != GSS_S_COMPLETE) {\n            goto done;\n        }\n    }\n\ndone:\n    *minor_status = min;\n    return maj;\n}\n\nuint32_t gssntlm_inquire_attrs_for_mech(uint32_t *minor_status,\n\t\t\t\t\tgss_const_OID mech_oid,\n\t\t\t\t\tgss_OID_set *mech_attrs,\n\t\t\t\t\tgss_OID_set *known_mech_attrs)\n{\n    gss_OID_set s_ma = GSS_C_NULL_OID_SET;\n    gss_OID_set k_ma = GSS_C_NULL_OID_SET;\n    uint32_t maj = GSS_S_COMPLETE;\n    uint32_t min = 0;\n\n    if (mech_oid && !gss_oid_equal(mech_oid, &gssntlm_oid)) {\n        *minor_status = ENOENT;\n        return GSS_S_BAD_MECH;\n    }\n\n    if (mech_attrs != NULL) {\n        maj = make_ma_oid_set(&min, &s_ma, 1);\n        if (maj != GSS_S_COMPLETE) {\n            goto done;\n        }\n    }\n    if (known_mech_attrs != NULL) {\n        maj = make_ma_oid_set(&min, &k_ma, 0);\n        if (maj != GSS_S_COMPLETE) {\n            goto done;\n        }\n    }\n\ndone:\n    if (maj != GSS_S_COMPLETE) {\n        gss_release_oid_set(&min, &s_ma);\n        gss_release_oid_set(&min, &k_ma);\n    }\n    if (mech_attrs != NULL) {\n        *mech_attrs = s_ma;\n    }\n    if (known_mech_attrs != NULL) {\n        *known_mech_attrs = k_ma;\n    }\n\n    *minor_status = min;\n    return maj;\n}\n"], "filenames": ["src/gss_names.c"], "buggy_code_start_loc": [139], "buggy_code_end_loc": [193], "fixing_code_start_loc": [138], "fixing_code_end_loc": [189], "type": "CWE-401", "message": "GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM authentication. Prior to version 1.2.0, a memory leak can be triggered when parsing usernames which can trigger a denial-of-service. The domain portion of a username may be overridden causing an allocated memory area the size of the domain name to be leaked. An attacker can leak memory via the main `gss_accept_sec_context` entry point, potentially causing a denial-of-service. This issue is fixed in version 1.2.0.", "other": {"cve": {"id": "CVE-2023-25566", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-14T18:15:13.380", "lastModified": "2023-02-22T18:39:38.693", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM authentication. Prior to version 1.2.0, a memory leak can be triggered when parsing usernames which can trigger a denial-of-service. The domain portion of a username may be overridden causing an allocated memory area the size of the domain name to be leaked. An attacker can leak memory via the main `gss_accept_sec_context` entry point, potentially causing a denial-of-service. This issue is fixed in version 1.2.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gss-ntlmssp_project:gss-ntlmssp:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "13258161-610E-490D-B389-681F4803A220"}]}]}], "references": [{"url": "https://github.com/gssapi/gss-ntlmssp/commit/8660fb16474054e692a596e9c79670cd4d3954f4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gssapi/gss-ntlmssp/releases/tag/v1.2.0", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/gssapi/gss-ntlmssp/security/advisories/GHSA-mfm4-6g58-jw74", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gssapi/gss-ntlmssp/commit/8660fb16474054e692a596e9c79670cd4d3954f4"}}