{"buggy_code": ["/*\n * Copyright (c) 2010 Broadcom Corporation\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* Toplevel file. Relies on dhd_linux.c to send commands to the dongle. */\n\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <net/cfg80211.h>\n#include <net/netlink.h>\n\n#include <brcmu_utils.h>\n#include <defs.h>\n#include <brcmu_wifi.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"tracepoint.h\"\n#include \"fwil_types.h\"\n#include \"p2p.h\"\n#include \"btcoex.h\"\n#include \"pno.h\"\n#include \"cfg80211.h\"\n#include \"feature.h\"\n#include \"fwil.h\"\n#include \"proto.h\"\n#include \"vendor.h\"\n#include \"bus.h\"\n#include \"common.h\"\n\n#define BRCMF_SCAN_IE_LEN_MAX\t\t2048\n\n#define WPA_OUI\t\t\t\t\"\\x00\\x50\\xF2\"\t/* WPA OUI */\n#define WPA_OUI_TYPE\t\t\t1\n#define RSN_OUI\t\t\t\t\"\\x00\\x0F\\xAC\"\t/* RSN OUI */\n#define\tWME_OUI_TYPE\t\t\t2\n#define WPS_OUI_TYPE\t\t\t4\n\n#define VS_IE_FIXED_HDR_LEN\t\t6\n#define WPA_IE_VERSION_LEN\t\t2\n#define WPA_IE_MIN_OUI_LEN\t\t4\n#define WPA_IE_SUITE_COUNT_LEN\t\t2\n\n#define WPA_CIPHER_NONE\t\t\t0\t/* None */\n#define WPA_CIPHER_WEP_40\t\t1\t/* WEP (40-bit) */\n#define WPA_CIPHER_TKIP\t\t\t2\t/* TKIP: default for WPA */\n#define WPA_CIPHER_AES_CCM\t\t4\t/* AES (CCM) */\n#define WPA_CIPHER_WEP_104\t\t5\t/* WEP (104-bit) */\n\n#define RSN_AKM_NONE\t\t\t0\t/* None (IBSS) */\n#define RSN_AKM_UNSPECIFIED\t\t1\t/* Over 802.1x */\n#define RSN_AKM_PSK\t\t\t2\t/* Pre-shared Key */\n#define RSN_AKM_SHA256_1X\t\t5\t/* SHA256, 802.1X */\n#define RSN_AKM_SHA256_PSK\t\t6\t/* SHA256, Pre-shared Key */\n#define RSN_CAP_LEN\t\t\t2\t/* Length of RSN capabilities */\n#define RSN_CAP_PTK_REPLAY_CNTR_MASK\t(BIT(2) | BIT(3))\n#define RSN_CAP_MFPR_MASK\t\tBIT(6)\n#define RSN_CAP_MFPC_MASK\t\tBIT(7)\n#define RSN_PMKID_COUNT_LEN\t\t2\n\n#define VNDR_IE_CMD_LEN\t\t\t4\t/* length of the set command\n\t\t\t\t\t\t * string :\"add\", \"del\" (+ NUL)\n\t\t\t\t\t\t */\n#define VNDR_IE_COUNT_OFFSET\t\t4\n#define VNDR_IE_PKTFLAG_OFFSET\t\t8\n#define VNDR_IE_VSIE_OFFSET\t\t12\n#define VNDR_IE_HDR_SIZE\t\t12\n#define VNDR_IE_PARSE_LIMIT\t\t5\n\n#define\tDOT11_MGMT_HDR_LEN\t\t24\t/* d11 management header len */\n#define\tDOT11_BCN_PRB_FIXED_LEN\t\t12\t/* beacon/probe fixed length */\n\n#define BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS\t320\n#define BRCMF_SCAN_JOIN_PASSIVE_DWELL_TIME_MS\t400\n#define BRCMF_SCAN_JOIN_PROBE_INTERVAL_MS\t20\n\n#define BRCMF_SCAN_CHANNEL_TIME\t\t40\n#define BRCMF_SCAN_UNASSOC_TIME\t\t40\n#define BRCMF_SCAN_PASSIVE_TIME\t\t120\n\n#define BRCMF_ND_INFO_TIMEOUT\t\tmsecs_to_jiffies(2000)\n\n#define BRCMF_ASSOC_PARAMS_FIXED_SIZE \\\n\t(sizeof(struct brcmf_assoc_params_le) - sizeof(u16))\n\nstatic bool check_vif_up(struct brcmf_cfg80211_vif *vif)\n{\n\tif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state)) {\n\t\tbrcmf_dbg(INFO, \"device is not ready : status (%lu)\\n\",\n\t\t\t  vif->sme_state);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#define RATE_TO_BASE100KBPS(rate)   (((rate) * 10) / 2)\n#define RATETAB_ENT(_rateid, _flags) \\\n\t{                                                               \\\n\t\t.bitrate        = RATE_TO_BASE100KBPS(_rateid),     \\\n\t\t.hw_value       = (_rateid),                            \\\n\t\t.flags          = (_flags),                             \\\n\t}\n\nstatic struct ieee80211_rate __wl_rates[] = {\n\tRATETAB_ENT(BRCM_RATE_1M, 0),\n\tRATETAB_ENT(BRCM_RATE_2M, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_5M5, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_11M, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_6M, 0),\n\tRATETAB_ENT(BRCM_RATE_9M, 0),\n\tRATETAB_ENT(BRCM_RATE_12M, 0),\n\tRATETAB_ENT(BRCM_RATE_18M, 0),\n\tRATETAB_ENT(BRCM_RATE_24M, 0),\n\tRATETAB_ENT(BRCM_RATE_36M, 0),\n\tRATETAB_ENT(BRCM_RATE_48M, 0),\n\tRATETAB_ENT(BRCM_RATE_54M, 0),\n};\n\n#define wl_g_rates\t\t(__wl_rates + 0)\n#define wl_g_rates_size\t\tARRAY_SIZE(__wl_rates)\n#define wl_a_rates\t\t(__wl_rates + 4)\n#define wl_a_rates_size\t\t(wl_g_rates_size - 4)\n\n#define CHAN2G(_channel, _freq) {\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq\t\t= (_freq),\t\t\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\n#define CHAN5G(_channel) {\t\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_5GHZ,\t\t\\\n\t.center_freq\t\t= 5000 + (5 * (_channel)),\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\nstatic struct ieee80211_channel __wl_2ghz_channels[] = {\n\tCHAN2G(1, 2412), CHAN2G(2, 2417), CHAN2G(3, 2422), CHAN2G(4, 2427),\n\tCHAN2G(5, 2432), CHAN2G(6, 2437), CHAN2G(7, 2442), CHAN2G(8, 2447),\n\tCHAN2G(9, 2452), CHAN2G(10, 2457), CHAN2G(11, 2462), CHAN2G(12, 2467),\n\tCHAN2G(13, 2472), CHAN2G(14, 2484)\n};\n\nstatic struct ieee80211_channel __wl_5ghz_channels[] = {\n\tCHAN5G(34), CHAN5G(36), CHAN5G(38), CHAN5G(40), CHAN5G(42),\n\tCHAN5G(44), CHAN5G(46), CHAN5G(48), CHAN5G(52), CHAN5G(56),\n\tCHAN5G(60), CHAN5G(64), CHAN5G(100), CHAN5G(104), CHAN5G(108),\n\tCHAN5G(112), CHAN5G(116), CHAN5G(120), CHAN5G(124), CHAN5G(128),\n\tCHAN5G(132), CHAN5G(136), CHAN5G(140), CHAN5G(144), CHAN5G(149),\n\tCHAN5G(153), CHAN5G(157), CHAN5G(161), CHAN5G(165)\n};\n\n/* Band templates duplicated per wiphy. The channel info\n * above is added to the band during setup.\n */\nstatic const struct ieee80211_supported_band __wl_band_2ghz = {\n\t.band = NL80211_BAND_2GHZ,\n\t.bitrates = wl_g_rates,\n\t.n_bitrates = wl_g_rates_size,\n};\n\nstatic const struct ieee80211_supported_band __wl_band_5ghz = {\n\t.band = NL80211_BAND_5GHZ,\n\t.bitrates = wl_a_rates,\n\t.n_bitrates = wl_a_rates_size,\n};\n\n/* This is to override regulatory domains defined in cfg80211 module (reg.c)\n * By default world regulatory domain defined in reg.c puts the flags\n * NL80211_RRF_NO_IR for 5GHz channels (for * 36..48 and 149..165).\n * With respect to these flags, wpa_supplicant doesn't * start p2p\n * operations on 5GHz channels. All the changes in world regulatory\n * domain are to be done here.\n */\nstatic const struct ieee80211_regdomain brcmf_regdom = {\n\t.n_reg_rules = 4,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\t/* IEEE 802.11b/g, channels 1..11 */\n\t\tREG_RULE(2412-10, 2472+10, 40, 6, 20, 0),\n\t\t/* If any */\n\t\t/* IEEE 802.11 channel 14 - Only JP enables\n\t\t * this and for 802.11b only\n\t\t */\n\t\tREG_RULE(2484-10, 2484+10, 20, 6, 20, 0),\n\t\t/* IEEE 802.11a, channel 36..64 */\n\t\tREG_RULE(5150-10, 5350+10, 80, 6, 20, 0),\n\t\t/* IEEE 802.11a, channel 100..165 */\n\t\tREG_RULE(5470-10, 5850+10, 80, 6, 20, 0), }\n};\n\n/* Note: brcmf_cipher_suites is an array of int defining which cipher suites\n * are supported. A pointer to this array and the number of entries is passed\n * on to upper layers. AES_CMAC defines whether or not the driver supports MFP.\n * So the cipher suite AES_CMAC has to be the last one in the array, and when\n * device does not support MFP then the number of suites will be decreased by 1\n */\nstatic const u32 brcmf_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\t/* Keep as last entry: */\n\tWLAN_CIPHER_SUITE_AES_CMAC\n};\n\n/* Vendor specific ie. id = 221, oui and type defines exact ie */\nstruct brcmf_vs_tlv {\n\tu8 id;\n\tu8 len;\n\tu8 oui[3];\n\tu8 oui_type;\n};\n\nstruct parsed_vndr_ie_info {\n\tu8 *ie_ptr;\n\tu32 ie_len;\t/* total length including id & length field */\n\tstruct brcmf_vs_tlv vndrie;\n};\n\nstruct parsed_vndr_ies {\n\tu32 count;\n\tstruct parsed_vndr_ie_info ie_info[VNDR_IE_PARSE_LIMIT];\n};\n\nstatic u8 nl80211_band_to_fwil(enum nl80211_band band)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\treturn WLC_BAND_2G;\n\tcase NL80211_BAND_5GHZ:\n\t\treturn WLC_BAND_5G;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u16 chandef_to_chanspec(struct brcmu_d11inf *d11inf,\n\t\t\t       struct cfg80211_chan_def *ch)\n{\n\tstruct brcmu_chan ch_inf;\n\ts32 primary_offset;\n\n\tbrcmf_dbg(TRACE, \"chandef: control %d center %d width %d\\n\",\n\t\t  ch->chan->center_freq, ch->center_freq1, ch->width);\n\tch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq1);\n\tprimary_offset = ch->chan->center_freq - ch->center_freq1;\n\tswitch (ch->width) {\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tch_inf.bw = BRCMU_CHAN_BW_20;\n\t\tWARN_ON(primary_offset != 0);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tch_inf.bw = BRCMU_CHAN_BW_40;\n\t\tif (primary_offset > 0)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_U;\n\t\telse\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_L;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tch_inf.bw = BRCMU_CHAN_BW_80;\n\t\tif (primary_offset == -30)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LL;\n\t\telse if (primary_offset == -10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LU;\n\t\telse if (primary_offset == 10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UL;\n\t\telse\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UU;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\tswitch (ch->chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tch_inf.band = BRCMU_CHAN_BAND_2G;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tch_inf.band = BRCMU_CHAN_BAND_5G;\n\t\tbreak;\n\tcase NL80211_BAND_60GHZ:\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\td11inf->encchspec(&ch_inf);\n\n\treturn ch_inf.chspec;\n}\n\nu16 channel_to_chanspec(struct brcmu_d11inf *d11inf,\n\t\t\tstruct ieee80211_channel *ch)\n{\n\tstruct brcmu_chan ch_inf;\n\n\tch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq);\n\tch_inf.bw = BRCMU_CHAN_BW_20;\n\td11inf->encchspec(&ch_inf);\n\n\treturn ch_inf.chspec;\n}\n\n/* Traverse a string of 1-byte tag/1-byte length/variable-length value\n * triples, returning a pointer to the substring whose first element\n * matches tag\n */\nstatic const struct brcmf_tlv *\nbrcmf_parse_tlvs(const void *buf, int buflen, uint key)\n{\n\tconst struct brcmf_tlv *elt = buf;\n\tint totlen = buflen;\n\n\t/* find tagged parameter */\n\twhile (totlen >= TLV_HDR_LEN) {\n\t\tint len = elt->len;\n\n\t\t/* validate remaining totlen */\n\t\tif ((elt->id == key) && (totlen >= (len + TLV_HDR_LEN)))\n\t\t\treturn elt;\n\n\t\telt = (struct brcmf_tlv *)((u8 *)elt + (len + TLV_HDR_LEN));\n\t\ttotlen -= (len + TLV_HDR_LEN);\n\t}\n\n\treturn NULL;\n}\n\n/* Is any of the tlvs the expected entry? If\n * not update the tlvs buffer pointer/length.\n */\nstatic bool\nbrcmf_tlv_has_ie(const u8 *ie, const u8 **tlvs, u32 *tlvs_len,\n\t\t const u8 *oui, u32 oui_len, u8 type)\n{\n\t/* If the contents match the OUI and the type */\n\tif (ie[TLV_LEN_OFF] >= oui_len + 1 &&\n\t    !memcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&\n\t    type == ie[TLV_BODY_OFF + oui_len]) {\n\t\treturn true;\n\t}\n\n\tif (tlvs == NULL)\n\t\treturn false;\n\t/* point to the next ie */\n\tie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;\n\t/* calculate the length of the rest of the buffer */\n\t*tlvs_len -= (int)(ie - *tlvs);\n\t/* update the pointer to the start of the buffer */\n\t*tlvs = ie;\n\n\treturn false;\n}\n\nstatic struct brcmf_vs_tlv *\nbrcmf_find_wpaie(const u8 *parse, u32 len)\n{\n\tconst struct brcmf_tlv *ie;\n\n\twhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\n\t\tif (brcmf_tlv_has_ie((const u8 *)ie, &parse, &len,\n\t\t\t\t     WPA_OUI, TLV_OUI_LEN, WPA_OUI_TYPE))\n\t\t\treturn (struct brcmf_vs_tlv *)ie;\n\t}\n\treturn NULL;\n}\n\nstatic struct brcmf_vs_tlv *\nbrcmf_find_wpsie(const u8 *parse, u32 len)\n{\n\tconst struct brcmf_tlv *ie;\n\n\twhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\n\t\tif (brcmf_tlv_has_ie((u8 *)ie, &parse, &len,\n\t\t\t\t     WPA_OUI, TLV_OUI_LEN, WPS_OUI_TYPE))\n\t\t\treturn (struct brcmf_vs_tlv *)ie;\n\t}\n\treturn NULL;\n}\n\nstatic int brcmf_vif_change_validate(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t     struct brcmf_cfg80211_vif *vif,\n\t\t\t\t     enum nl80211_iftype new_type)\n{\n\tstruct brcmf_cfg80211_vif *pos;\n\tbool check_combos = false;\n\tint ret = 0;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tlist_for_each_entry(pos, &cfg->vif_list, list)\n\t\tif (pos == vif) {\n\t\t\tparams.iftype_num[new_type]++;\n\t\t} else {\n\t\t\t/* concurrent interfaces so need check combinations */\n\t\t\tcheck_combos = true;\n\t\t\tparams.iftype_num[pos->wdev.iftype]++;\n\t\t}\n\n\tif (check_combos)\n\t\tret = cfg80211_check_combinations(cfg->wiphy, &params);\n\n\treturn ret;\n}\n\nstatic int brcmf_vif_add_validate(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  enum nl80211_iftype new_type)\n{\n\tstruct brcmf_cfg80211_vif *pos;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tlist_for_each_entry(pos, &cfg->vif_list, list)\n\t\tparams.iftype_num[pos->wdev.iftype]++;\n\n\tparams.iftype_num[new_type]++;\n\treturn cfg80211_check_combinations(cfg->wiphy, &params);\n}\n\nstatic void convert_key_from_CPU(struct brcmf_wsec_key *key,\n\t\t\t\t struct brcmf_wsec_key_le *key_le)\n{\n\tkey_le->index = cpu_to_le32(key->index);\n\tkey_le->len = cpu_to_le32(key->len);\n\tkey_le->algo = cpu_to_le32(key->algo);\n\tkey_le->flags = cpu_to_le32(key->flags);\n\tkey_le->rxiv.hi = cpu_to_le32(key->rxiv.hi);\n\tkey_le->rxiv.lo = cpu_to_le16(key->rxiv.lo);\n\tkey_le->iv_initialized = cpu_to_le32(key->iv_initialized);\n\tmemcpy(key_le->data, key->data, sizeof(key->data));\n\tmemcpy(key_le->ea, key->ea, sizeof(key->ea));\n}\n\nstatic int\nsend_key_to_dongle(struct brcmf_if *ifp, struct brcmf_wsec_key *key)\n{\n\tint err;\n\tstruct brcmf_wsec_key_le key_le;\n\n\tconvert_key_from_CPU(key, &key_le);\n\n\tbrcmf_netdev_wait_pend8021x(ifp);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"wsec_key\", &key_le,\n\t\t\t\t\tsizeof(key_le));\n\n\tif (err)\n\t\tbrcmf_err(\"wsec_key error (%d)\\n\", err);\n\treturn err;\n}\n\nstatic s32\nbrcmf_configure_arp_nd_offload(struct brcmf_if *ifp, bool enable)\n{\n\ts32 err;\n\tu32 mode;\n\n\tif (enable)\n\t\tmode = BRCMF_ARP_OL_AGENT | BRCMF_ARP_OL_PEER_AUTO_REPLY;\n\telse\n\t\tmode = 0;\n\n\t/* Try to set and enable ARP offload feature, this may fail, then it  */\n\t/* is simply not supported and err 0 will be returned                 */\n\terr = brcmf_fil_iovar_int_set(ifp, \"arp_ol\", mode);\n\tif (err) {\n\t\tbrcmf_dbg(TRACE, \"failed to set ARP offload mode to 0x%x, err = %d\\n\",\n\t\t\t  mode, err);\n\t\terr = 0;\n\t} else {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"arpoe\", enable);\n\t\tif (err) {\n\t\t\tbrcmf_dbg(TRACE, \"failed to configure (%d) ARP offload err = %d\\n\",\n\t\t\t\t  enable, err);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tbrcmf_dbg(TRACE, \"successfully configured (%d) ARP offload to 0x%x\\n\",\n\t\t\t\t  enable, mode);\n\t}\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"ndoe\", enable);\n\tif (err) {\n\t\tbrcmf_dbg(TRACE, \"failed to configure (%d) ND offload err = %d\\n\",\n\t\t\t  enable, err);\n\t\terr = 0;\n\t} else\n\t\tbrcmf_dbg(TRACE, \"successfully configured (%d) ND offload to 0x%x\\n\",\n\t\t\t  enable, mode);\n\n\treturn err;\n}\n\nstatic void\nbrcmf_cfg80211_update_proto_addr_mode(struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tifp = vif->ifp;\n\n\tif ((wdev->iftype == NL80211_IFTYPE_ADHOC) ||\n\t    (wdev->iftype == NL80211_IFTYPE_AP) ||\n\t    (wdev->iftype == NL80211_IFTYPE_P2P_GO))\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_DIRECT);\n\telse\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_INDIRECT);\n}\n\nstatic int brcmf_get_first_free_bsscfgidx(struct brcmf_pub *drvr)\n{\n\tint bsscfgidx;\n\n\tfor (bsscfgidx = 0; bsscfgidx < BRCMF_MAX_IFS; bsscfgidx++) {\n\t\t/* bsscfgidx 1 is reserved for legacy P2P */\n\t\tif (bsscfgidx == 1)\n\t\t\tcontinue;\n\t\tif (!drvr->iflist[bsscfgidx])\n\t\t\treturn bsscfgidx;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)\n{\n\tstruct brcmf_mbss_ssid_le mbss_ssid_le;\n\tint bsscfgidx;\n\tint err;\n\n\tmemset(&mbss_ssid_le, 0, sizeof(mbss_ssid_le));\n\tbsscfgidx = brcmf_get_first_free_bsscfgidx(ifp->drvr);\n\tif (bsscfgidx < 0)\n\t\treturn bsscfgidx;\n\n\tmbss_ssid_le.bsscfgidx = cpu_to_le32(bsscfgidx);\n\tmbss_ssid_le.SSID_len = cpu_to_le32(5);\n\tsprintf(mbss_ssid_le.SSID, \"ssid%d\" , bsscfgidx);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"bsscfg:ssid\", &mbss_ssid_le,\n\t\t\t\t\tsizeof(mbss_ssid_le));\n\tif (err < 0)\n\t\tbrcmf_err(\"setting ssid failed %d\\n\", err);\n\n\treturn err;\n}\n\n/**\n * brcmf_ap_add_vif() - create a new AP virtual interface for multiple BSS\n *\n * @wiphy: wiphy device of new interface.\n * @name: name of the new interface.\n * @params: contains mac address for AP device.\n */\nstatic\nstruct wireless_dev *brcmf_ap_add_vif(struct wiphy *wiphy, const char *name,\n\t\t\t\t      struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct brcmf_cfg80211_vif *vif;\n\tint err;\n\n\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tbrcmf_dbg(INFO, \"Adding vif \\\"%s\\\"\\n\", name);\n\n\tvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_AP);\n\tif (IS_ERR(vif))\n\t\treturn (struct wireless_dev *)vif;\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, vif);\n\n\terr = brcmf_cfg80211_request_ap_if(ifp);\n\tif (err) {\n\t\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\t\tgoto fail;\n\t}\n\n\t/* wait for firmware event */\n\terr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_ADD,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\tif (!err) {\n\t\tbrcmf_err(\"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\t/* interface created in firmware */\n\tifp = vif->ifp;\n\tif (!ifp) {\n\t\tbrcmf_err(\"no if pointer provided\\n\");\n\t\terr = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tstrncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);\n\terr = brcmf_net_attach(ifp, true);\n\tif (err) {\n\t\tbrcmf_err(\"Registering netdevice failed\\n\");\n\t\tfree_netdev(ifp->ndev);\n\t\tgoto fail;\n\t}\n\n\treturn &ifp->vif->wdev;\n\nfail:\n\tbrcmf_free_vif(vif);\n\treturn ERR_PTR(err);\n}\n\nstatic bool brcmf_is_apmode(struct brcmf_cfg80211_vif *vif)\n{\n\tenum nl80211_iftype iftype;\n\n\tiftype = vif->wdev.iftype;\n\treturn iftype == NL80211_IFTYPE_AP || iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nstatic bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif)\n{\n\treturn vif->wdev.iftype == NL80211_IFTYPE_ADHOC;\n}\n\nstatic struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t\t\t     struct vif_params *params)\n{\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"enter: %s type %d\\n\", name, type);\n\terr = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);\n\tif (err) {\n\t\tbrcmf_err(\"iface validation failed: err=%d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tcase NL80211_IFTYPE_AP:\n\t\twdev = brcmf_ap_add_vif(wiphy, name, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\twdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (IS_ERR(wdev))\n\t\tbrcmf_err(\"add iface %s type %d failed: err=%d\\n\",\n\t\t\t  name, type, (int)PTR_ERR(wdev));\n\telse\n\t\tbrcmf_cfg80211_update_proto_addr_mode(wdev);\n\n\treturn wdev;\n}\n\nstatic void brcmf_scan_config_mpc(struct brcmf_if *ifp, int mpc)\n{\n\tif (brcmf_feat_is_quirk_enabled(ifp, BRCMF_FEAT_QUIRK_NEED_MPC))\n\t\tbrcmf_set_mpc(ifp, mpc);\n}\n\nvoid brcmf_set_mpc(struct brcmf_if *ifp, int mpc)\n{\n\ts32 err = 0;\n\n\tif (check_vif_up(ifp->vif)) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"mpc\", mpc);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"fail to set mpc\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"MPC : %d\\n\", mpc);\n\t}\n}\n\ns32 brcmf_notify_escan_complete(struct brcmf_cfg80211_info *cfg,\n\t\t\t\tstruct brcmf_if *ifp, bool aborted,\n\t\t\t\tbool fw_abort)\n{\n\tstruct brcmf_scan_params_le params_le;\n\tstruct cfg80211_scan_request *scan_request;\n\tu64 reqid;\n\tu32 bucket;\n\ts32 err = 0;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\t/* clear scan request, because the FW abort can cause a second call */\n\t/* to this functon and might cause a double cfg80211_scan_done      */\n\tscan_request = cfg->scan_request;\n\tcfg->scan_request = NULL;\n\n\tif (timer_pending(&cfg->escan_timeout))\n\t\tdel_timer_sync(&cfg->escan_timeout);\n\n\tif (fw_abort) {\n\t\t/* Do a scan abort to stop the driver's scan engine */\n\t\tbrcmf_dbg(SCAN, \"ABORT scan in firmware\\n\");\n\t\tmemset(&params_le, 0, sizeof(params_le));\n\t\teth_broadcast_addr(params_le.bssid);\n\t\tparams_le.bss_type = DOT11_BSSTYPE_ANY;\n\t\tparams_le.scan_type = 0;\n\t\tparams_le.channel_num = cpu_to_le32(1);\n\t\tparams_le.nprobes = cpu_to_le32(1);\n\t\tparams_le.active_time = cpu_to_le32(-1);\n\t\tparams_le.passive_time = cpu_to_le32(-1);\n\t\tparams_le.home_time = cpu_to_le32(-1);\n\t\t/* Scan is aborted by setting channel_list[0] to -1 */\n\t\tparams_le.channel_list[0] = cpu_to_le16(-1);\n\t\t/* E-Scan (or anyother type) can be aborted by SCAN */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN,\n\t\t\t\t\t     &params_le, sizeof(params_le));\n\t\tif (err)\n\t\t\tbrcmf_err(\"Scan abort failed\\n\");\n\t}\n\n\tbrcmf_scan_config_mpc(ifp, 1);\n\n\t/*\n\t * e-scan can be initiated internally\n\t * which takes precedence.\n\t */\n\tif (cfg->int_escan_map) {\n\t\tbrcmf_dbg(SCAN, \"scheduled scan completed (%x)\\n\",\n\t\t\t  cfg->int_escan_map);\n\t\twhile (cfg->int_escan_map) {\n\t\t\tbucket = __ffs(cfg->int_escan_map);\n\t\t\tcfg->int_escan_map &= ~BIT(bucket);\n\t\t\treqid = brcmf_pno_find_reqid_by_bucket(cfg->pno,\n\t\t\t\t\t\t\t       bucket);\n\t\t\tif (!aborted) {\n\t\t\t\tbrcmf_dbg(SCAN, \"report results: reqid=%llu\\n\",\n\t\t\t\t\t  reqid);\n\t\t\t\tcfg80211_sched_scan_results(cfg_to_wiphy(cfg),\n\t\t\t\t\t\t\t    reqid);\n\t\t\t}\n\t\t}\n\t} else if (scan_request) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = aborted,\n\t\t};\n\n\t\tbrcmf_dbg(SCAN, \"ESCAN Completed scan: %s\\n\",\n\t\t\t  aborted ? \"Aborted\" : \"Done\");\n\t\tcfg80211_scan_done(scan_request, &info);\n\t}\n\tif (!test_and_clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\n\t\tbrcmf_dbg(SCAN, \"Scan complete, probably P2P scan\\n\");\n\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_del_ap_iface(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tint ret;\n\tint err;\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, ifp->vif);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"interface_remove\", NULL, 0);\n\tif (err) {\n\t\tbrcmf_err(\"interface_remove failed %d\\n\", err);\n\t\tgoto err_unarm;\n\t}\n\n\t/* wait for firmware event */\n\tret = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tif (!ret) {\n\t\tbrcmf_err(\"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto err_unarm;\n\t}\n\n\tbrcmf_remove_interface(ifp, true);\n\nerr_unarm:\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\treturn err;\n}\n\nstatic\nint brcmf_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\n\tif (ndev && ndev == cfg_to_ndev(cfg))\n\t\treturn -ENOTSUPP;\n\n\t/* vif event pending in firmware */\n\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\treturn -EBUSY;\n\n\tif (ndev) {\n\t\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status) &&\n\t\t    cfg->escan_info.ifp == netdev_priv(ndev))\n\t\t\tbrcmf_notify_escan_complete(cfg, netdev_priv(ndev),\n\t\t\t\t\t\t    true, true);\n\n\t\tbrcmf_fil_iovar_int_set(netdev_priv(ndev), \"mpc\", 1);\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn -EOPNOTSUPP;\n\tcase NL80211_IFTYPE_AP:\n\t\treturn brcmf_cfg80211_del_ap_iface(wiphy, wdev);\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn brcmf_p2p_del_vif(wiphy, wdev);\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic s32\nbrcmf_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t enum nl80211_iftype type,\n\t\t\t struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_vif *vif = ifp->vif;\n\ts32 infra = 0;\n\ts32 ap = 0;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d, type=%d\\n\", ifp->bsscfgidx,\n\t\t  type);\n\n\t/* WAR: There are a number of p2p interface related problems which\n\t * need to be handled initially (before doing the validate).\n\t * wpa_supplicant tends to do iface changes on p2p device/client/go\n\t * which are not always possible/allowed. However we need to return\n\t * OK otherwise the wpa_supplicant wont start. The situation differs\n\t * on configuration and setup (p2pon=1 module param). The first check\n\t * is to see if the request is a change to station for p2p iface.\n\t */\n\tif ((type == NL80211_IFTYPE_STATION) &&\n\t    ((vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) ||\n\t     (vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) ||\n\t     (vif->wdev.iftype == NL80211_IFTYPE_P2P_DEVICE))) {\n\t\tbrcmf_dbg(TRACE, \"Ignoring cmd for p2p if\\n\");\n\t\t/* Now depending on whether module param p2pon=1 was used the\n\t\t * response needs to be either 0 or EOPNOTSUPP. The reason is\n\t\t * that if p2pon=1 is used, but a newer supplicant is used then\n\t\t * we should return an error, as this combination wont work.\n\t\t * In other situations 0 is returned and supplicant will start\n\t\t * normally. It will give a trace in cfg80211, but it is the\n\t\t * only way to get it working. Unfortunately this will result\n\t\t * in situation where we wont support new supplicant in\n\t\t * combination with module param p2pon=1, but that is the way\n\t\t * it is. If the user tries this then unloading of driver might\n\t\t * fail/lock.\n\t\t */\n\t\tif (cfg->p2p.p2pdev_dynamically)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn 0;\n\t}\n\terr = brcmf_vif_change_validate(wiphy_to_cfg(wiphy), vif, type);\n\tif (err) {\n\t\tbrcmf_err(\"iface validation failed: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_WDS:\n\t\tbrcmf_err(\"type (%d) : currently we do not support this type\\n\",\n\t\t\t  type);\n\t\treturn -EOPNOTSUPP;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tinfra = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tinfra = 1;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tap = 1;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (ap) {\n\t\tif (type == NL80211_IFTYPE_P2P_GO) {\n\t\t\tbrcmf_dbg(INFO, \"IF Type = P2P GO\\n\");\n\t\t\terr = brcmf_p2p_ifchange(cfg, BRCMF_FIL_P2P_IF_GO);\n\t\t}\n\t\tif (!err) {\n\t\t\tbrcmf_dbg(INFO, \"IF Type = AP\\n\");\n\t\t}\n\t} else {\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, infra);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_INFRA error (%d)\\n\", err);\n\t\t\terr = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"IF Type = %s\\n\", brcmf_is_ibssmode(vif) ?\n\t\t\t  \"Adhoc\" : \"Infra\");\n\t}\n\tndev->ieee80211_ptr->iftype = type;\n\n\tbrcmf_cfg80211_update_proto_addr_mode(&vif->wdev);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn err;\n}\n\nstatic void brcmf_escan_prep(struct brcmf_cfg80211_info *cfg,\n\t\t\t     struct brcmf_scan_params_le *params_le,\n\t\t\t     struct cfg80211_scan_request *request)\n{\n\tu32 n_ssids;\n\tu32 n_channels;\n\ts32 i;\n\ts32 offset;\n\tu16 chanspec;\n\tchar *ptr;\n\tstruct brcmf_ssid_le ssid_le;\n\n\teth_broadcast_addr(params_le->bssid);\n\tparams_le->bss_type = DOT11_BSSTYPE_ANY;\n\tparams_le->scan_type = 0;\n\tparams_le->channel_num = 0;\n\tparams_le->nprobes = cpu_to_le32(-1);\n\tparams_le->active_time = cpu_to_le32(-1);\n\tparams_le->passive_time = cpu_to_le32(-1);\n\tparams_le->home_time = cpu_to_le32(-1);\n\tmemset(&params_le->ssid_le, 0, sizeof(params_le->ssid_le));\n\n\t/* if request is null exit so it will be all channel broadcast scan */\n\tif (!request)\n\t\treturn;\n\n\tn_ssids = request->n_ssids;\n\tn_channels = request->n_channels;\n\t/* Copy channel array if applicable */\n\tbrcmf_dbg(SCAN, \"### List of channelspecs to scan ### %d\\n\",\n\t\t  n_channels);\n\tif (n_channels > 0) {\n\t\tfor (i = 0; i < n_channels; i++) {\n\t\t\tchanspec = channel_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       request->channels[i]);\n\t\t\tbrcmf_dbg(SCAN, \"Chan : %d, Channel spec: %x\\n\",\n\t\t\t\t  request->channels[i]->hw_value, chanspec);\n\t\t\tparams_le->channel_list[i] = cpu_to_le16(chanspec);\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"Scanning all channels\\n\");\n\t}\n\t/* Copy ssid array if applicable */\n\tbrcmf_dbg(SCAN, \"### List of SSIDs to scan ### %d\\n\", n_ssids);\n\tif (n_ssids > 0) {\n\t\toffset = offsetof(struct brcmf_scan_params_le, channel_list) +\n\t\t\t\tn_channels * sizeof(u16);\n\t\toffset = roundup(offset, sizeof(u32));\n\t\tptr = (char *)params_le + offset;\n\t\tfor (i = 0; i < n_ssids; i++) {\n\t\t\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\t\t\tssid_le.SSID_len =\n\t\t\t\t\tcpu_to_le32(request->ssids[i].ssid_len);\n\t\t\tmemcpy(ssid_le.SSID, request->ssids[i].ssid,\n\t\t\t       request->ssids[i].ssid_len);\n\t\t\tif (!ssid_le.SSID_len)\n\t\t\t\tbrcmf_dbg(SCAN, \"%d: Broadcast scan\\n\", i);\n\t\t\telse\n\t\t\t\tbrcmf_dbg(SCAN, \"%d: scan for  %.32s size=%d\\n\",\n\t\t\t\t\t  i, ssid_le.SSID, ssid_le.SSID_len);\n\t\t\tmemcpy(ptr, &ssid_le, sizeof(ssid_le));\n\t\t\tptr += sizeof(ssid_le);\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"Broadcast scan %p\\n\", request->ssids);\n\t\tif ((request->ssids) && request->ssids->ssid_len) {\n\t\t\tbrcmf_dbg(SCAN, \"SSID %s len=%d\\n\",\n\t\t\t\t  params_le->ssid_le.SSID,\n\t\t\t\t  request->ssids->ssid_len);\n\t\t\tparams_le->ssid_le.SSID_len =\n\t\t\t\tcpu_to_le32(request->ssids->ssid_len);\n\t\t\tmemcpy(&params_le->ssid_le.SSID, request->ssids->ssid,\n\t\t\t\trequest->ssids->ssid_len);\n\t\t}\n\t}\n\t/* Adding mask to channel numbers */\n\tparams_le->channel_num =\n\t\tcpu_to_le32((n_ssids << BRCMF_SCAN_PARAMS_NSSID_SHIFT) |\n\t\t\t(n_channels & BRCMF_SCAN_PARAMS_COUNT_MASK));\n}\n\nstatic s32\nbrcmf_run_escan(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp,\n\t\tstruct cfg80211_scan_request *request)\n{\n\ts32 params_size = BRCMF_SCAN_PARAMS_FIXED_SIZE +\n\t\t\t  offsetof(struct brcmf_escan_params_le, params_le);\n\tstruct brcmf_escan_params_le *params;\n\ts32 err = 0;\n\n\tbrcmf_dbg(SCAN, \"E-SCAN START\\n\");\n\n\tif (request != NULL) {\n\t\t/* Allocate space for populating ssids in struct */\n\t\tparams_size += sizeof(u32) * ((request->n_channels + 1) / 2);\n\n\t\t/* Allocate space for populating ssids in struct */\n\t\tparams_size += sizeof(struct brcmf_ssid_le) * request->n_ssids;\n\t}\n\n\tparams = kzalloc(params_size, GFP_KERNEL);\n\tif (!params) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tBUG_ON(params_size + sizeof(\"escan\") >= BRCMF_DCMD_MEDLEN);\n\tbrcmf_escan_prep(cfg, &params->params_le, request);\n\tparams->version = cpu_to_le32(BRCMF_ESCAN_REQ_VERSION);\n\tparams->action = cpu_to_le16(WL_ESCAN_ACTION_START);\n\tparams->sync_id = cpu_to_le16(0x1234);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"escan\", params, params_size);\n\tif (err) {\n\t\tif (err == -EBUSY)\n\t\t\tbrcmf_dbg(INFO, \"system busy : escan canceled\\n\");\n\t\telse\n\t\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t}\n\n\tkfree(params);\nexit:\n\treturn err;\n}\n\nstatic s32\nbrcmf_do_escan(struct brcmf_if *ifp, struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err;\n\tu32 passive_scan;\n\tstruct brcmf_scan_results *results;\n\tstruct escan_info *escan = &cfg->escan_info;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\tescan->ifp = ifp;\n\tescan->wiphy = cfg->wiphy;\n\tescan->escan_state = WL_ESCAN_STATE_SCANNING;\n\tpassive_scan = cfg->active_scan ? 0 : 1;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PASSIVE_SCAN,\n\t\t\t\t    passive_scan);\n\tif (err) {\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tbrcmf_scan_config_mpc(ifp, 0);\n\tresults = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\n\tresults->version = 0;\n\tresults->count = 0;\n\tresults->buflen = WL_ESCAN_RESULTS_FIXED_SIZE;\n\n\terr = escan->run(cfg, ifp, request);\n\tif (err)\n\t\tbrcmf_scan_config_mpc(ifp, 1);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_escan(struct wiphy *wiphy, struct brcmf_cfg80211_vif *vif,\n\t\t     struct cfg80211_scan_request *request,\n\t\t     struct cfg80211_ssid *this_ssid)\n{\n\tstruct brcmf_if *ifp = vif->ifp;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct cfg80211_ssid *ssids;\n\tu32 passive_scan;\n\tbool escan_req;\n\tbool spec_scan;\n\ts32 err;\n\tstruct brcmf_ssid_le ssid_le;\n\tu32 SSID_len;\n\n\tbrcmf_dbg(SCAN, \"START ESCAN\\n\");\n\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning already: status (%lu)\\n\", cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning being aborted: status (%lu)\\n\",\n\t\t\t  cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning suppressed: status (%lu)\\n\",\n\t\t\t  cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state)) {\n\t\tbrcmf_err(\"Connecting: status (%lu)\\n\", ifp->vif->sme_state);\n\t\treturn -EAGAIN;\n\t}\n\n\t/* If scan req comes for p2p0, send it over primary I/F */\n\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\n\n\tescan_req = false;\n\tif (request) {\n\t\t/* scan bss */\n\t\tssids = request->ssids;\n\t\tescan_req = true;\n\t} else {\n\t\t/* scan in ibss */\n\t\t/* we don't do escan in ibss */\n\t\tssids = this_ssid;\n\t}\n\n\tcfg->scan_request = request;\n\tset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tif (escan_req) {\n\t\tcfg->escan_info.run = brcmf_run_escan;\n\t\terr = brcmf_p2p_scan_prep(wiphy, request, vif);\n\t\tif (err)\n\t\t\tgoto scan_out;\n\n\t\terr = brcmf_do_escan(vif->ifp, request);\n\t\tif (err)\n\t\t\tgoto scan_out;\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"ssid \\\"%s\\\", ssid_len (%d)\\n\",\n\t\t\t  ssids->ssid, ssids->ssid_len);\n\t\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\t\tSSID_len = min_t(u8, sizeof(ssid_le.SSID), ssids->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32(0);\n\t\tspec_scan = false;\n\t\tif (SSID_len) {\n\t\t\tmemcpy(ssid_le.SSID, ssids->ssid, SSID_len);\n\t\t\tssid_le.SSID_len = cpu_to_le32(SSID_len);\n\t\t\tspec_scan = true;\n\t\t} else\n\t\t\tbrcmf_dbg(SCAN, \"Broadcast scan\\n\");\n\n\t\tpassive_scan = cfg->active_scan ? 0 : 1;\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PASSIVE_SCAN,\n\t\t\t\t\t    passive_scan);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_PASSIVE_SCAN error (%d)\\n\", err);\n\t\t\tgoto scan_out;\n\t\t}\n\t\tbrcmf_scan_config_mpc(ifp, 0);\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN, &ssid_le,\n\t\t\t\t\t     sizeof(ssid_le));\n\t\tif (err) {\n\t\t\tif (err == -EBUSY)\n\t\t\t\tbrcmf_dbg(INFO, \"BUSY: scan for \\\"%s\\\" canceled\\n\",\n\t\t\t\t\t  ssid_le.SSID);\n\t\t\telse\n\t\t\t\tbrcmf_err(\"WLC_SCAN error (%d)\\n\", err);\n\n\t\t\tbrcmf_scan_config_mpc(ifp, 1);\n\t\t\tgoto scan_out;\n\t\t}\n\t}\n\n\t/* Arm scan timeout timer */\n\tmod_timer(&cfg->escan_timeout, jiffies +\n\t\t\tBRCMF_ESCAN_TIMER_INTERVAL_MS * HZ / 1000);\n\n\treturn 0;\n\nscan_out:\n\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tcfg->scan_request = NULL;\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tvif = container_of(request->wdev, struct brcmf_cfg80211_vif, wdev);\n\tif (!check_vif_up(vif))\n\t\treturn -EIO;\n\n\terr = brcmf_cfg80211_escan(wiphy, vif, request, NULL);\n\n\tif (err)\n\t\tbrcmf_err(\"scan error (%d)\\n\", err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32 brcmf_set_rts(struct net_device *ndev, u32 rts_threshold)\n{\n\ts32 err = 0;\n\n\terr = brcmf_fil_iovar_int_set(netdev_priv(ndev), \"rtsthresh\",\n\t\t\t\t      rts_threshold);\n\tif (err)\n\t\tbrcmf_err(\"Error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic s32 brcmf_set_frag(struct net_device *ndev, u32 frag_threshold)\n{\n\ts32 err = 0;\n\n\terr = brcmf_fil_iovar_int_set(netdev_priv(ndev), \"fragthresh\",\n\t\t\t\t      frag_threshold);\n\tif (err)\n\t\tbrcmf_err(\"Error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic s32 brcmf_set_retry(struct net_device *ndev, u32 retry, bool l)\n{\n\ts32 err = 0;\n\tu32 cmd = (l ? BRCMF_C_SET_LRL : BRCMF_C_SET_SRL);\n\n\terr = brcmf_fil_cmd_int_set(netdev_priv(ndev), cmd, retry);\n\tif (err) {\n\t\tbrcmf_err(\"cmd (%d) , error (%d)\\n\", cmd, err);\n\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic s32 brcmf_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD &&\n\t    (cfg->conf->rts_threshold != wiphy->rts_threshold)) {\n\t\tcfg->conf->rts_threshold = wiphy->rts_threshold;\n\t\terr = brcmf_set_rts(ndev, cfg->conf->rts_threshold);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD &&\n\t    (cfg->conf->frag_threshold != wiphy->frag_threshold)) {\n\t\tcfg->conf->frag_threshold = wiphy->frag_threshold;\n\t\terr = brcmf_set_frag(ndev, cfg->conf->frag_threshold);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_LONG\n\t    && (cfg->conf->retry_long != wiphy->retry_long)) {\n\t\tcfg->conf->retry_long = wiphy->retry_long;\n\t\terr = brcmf_set_retry(ndev, cfg->conf->retry_long, true);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_SHORT\n\t    && (cfg->conf->retry_short != wiphy->retry_short)) {\n\t\tcfg->conf->retry_short = wiphy->retry_short;\n\t\terr = brcmf_set_retry(ndev, cfg->conf->retry_short, false);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic void brcmf_init_prof(struct brcmf_cfg80211_profile *prof)\n{\n\tmemset(prof, 0, sizeof(*prof));\n}\n\nstatic u16 brcmf_map_fw_linkdown_reason(const struct brcmf_event_msg *e)\n{\n\tu16 reason;\n\n\tswitch (e->event_code) {\n\tcase BRCMF_E_DEAUTH:\n\tcase BRCMF_E_DEAUTH_IND:\n\tcase BRCMF_E_DISASSOC_IND:\n\t\treason = e->reason;\n\t\tbreak;\n\tcase BRCMF_E_LINK:\n\tdefault:\n\t\treason = 0;\n\t\tbreak;\n\t}\n\treturn reason;\n}\n\nstatic int brcmf_set_pmk(struct brcmf_if *ifp, const u8 *pmk_data, u16 pmk_len)\n{\n\tstruct brcmf_wsec_pmk_le pmk;\n\tint i, err;\n\n\t/* convert to firmware key format */\n\tpmk.key_len = cpu_to_le16(pmk_len << 1);\n\tpmk.flags = cpu_to_le16(BRCMF_WSEC_PASSPHRASE);\n\tfor (i = 0; i < pmk_len; i++)\n\t\tsnprintf(&pmk.key[2 * i], 3, \"%02x\", pmk_data[i]);\n\n\t/* store psk in firmware */\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_WSEC_PMK,\n\t\t\t\t     &pmk, sizeof(pmk));\n\tif (err < 0)\n\t\tbrcmf_err(\"failed to change PSK in firmware (len=%u)\\n\",\n\t\t\t  pmk_len);\n\n\treturn err;\n}\n\nstatic void brcmf_link_down(struct brcmf_cfg80211_vif *vif, u16 reason)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTED, &vif->sme_state)) {\n\t\tbrcmf_dbg(INFO, \"Call WLC_DISASSOC to stop excess roaming\\n \");\n\t\terr = brcmf_fil_cmd_data_set(vif->ifp,\n\t\t\t\t\t     BRCMF_C_DISASSOC, NULL, 0);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_DISASSOC failed (%d)\\n\", err);\n\t\t}\n\t\tif ((vif->wdev.iftype == NL80211_IFTYPE_STATION) ||\n\t\t    (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT))\n\t\t\tcfg80211_disconnected(vif->wdev.netdev, reason, NULL, 0,\n\t\t\t\t\t      true, GFP_KERNEL);\n\t}\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state);\n\tclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n\tbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\n\tif (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {\n\t\tbrcmf_set_pmk(vif->ifp, NULL, 0);\n\t\tvif->profile.use_fwsup = BRCMF_PROFILE_FWSUP_NONE;\n\t}\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n}\n\nstatic s32\nbrcmf_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\n\t\t      struct cfg80211_ibss_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size = 0;\n\ts32 err = 0;\n\ts32 wsec = 0;\n\ts32 bcnprd;\n\tu16 chanspec;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (params->ssid)\n\t\tbrcmf_dbg(CONN, \"SSID: %s\\n\", params->ssid);\n\telse {\n\t\tbrcmf_dbg(CONN, \"SSID: NULL, Not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (params->bssid)\n\t\tbrcmf_dbg(CONN, \"BSSID: %pM\\n\", params->bssid);\n\telse\n\t\tbrcmf_dbg(CONN, \"No BSSID specified\\n\");\n\n\tif (params->chandef.chan)\n\t\tbrcmf_dbg(CONN, \"channel: %d\\n\",\n\t\t\t  params->chandef.chan->center_freq);\n\telse\n\t\tbrcmf_dbg(CONN, \"no channel specified\\n\");\n\n\tif (params->channel_fixed)\n\t\tbrcmf_dbg(CONN, \"fixed channel required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no fixed channel required\\n\");\n\n\tif (params->ie && params->ie_len)\n\t\tbrcmf_dbg(CONN, \"ie len: %d\\n\", params->ie_len);\n\telse\n\t\tbrcmf_dbg(CONN, \"no ie specified\\n\");\n\n\tif (params->beacon_interval)\n\t\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\",\n\t\t\t  params->beacon_interval);\n\telse\n\t\tbrcmf_dbg(CONN, \"no beacon interval specified\\n\");\n\n\tif (params->basic_rates)\n\t\tbrcmf_dbg(CONN, \"basic rates: %08X\\n\", params->basic_rates);\n\telse\n\t\tbrcmf_dbg(CONN, \"no basic rates specified\\n\");\n\n\tif (params->privacy)\n\t\tbrcmf_dbg(CONN, \"privacy required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no privacy required\\n\");\n\n\t/* Configure Privacy for starter */\n\tif (params->privacy)\n\t\twsec |= WEP_ENABLED;\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"wsec failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure Beacon Interval for starter */\n\tif (params->beacon_interval)\n\t\tbcnprd = params->beacon_interval;\n\telse\n\t\tbcnprd = 100;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_BCNPRD failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure required join parameter */\n\tmemset(&join_params, 0, sizeof(struct brcmf_join_params));\n\n\t/* SSID */\n\tssid_len = min_t(u32, params->ssid_len, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(join_params.ssid_le.SSID, params->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\t/* BSSID */\n\tif (params->bssid) {\n\t\tmemcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);\n\t\tjoin_params_size += BRCMF_ASSOC_PARAMS_FIXED_SIZE;\n\t\tmemcpy(profile->bssid, params->bssid, ETH_ALEN);\n\t} else {\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\t\teth_zero_addr(profile->bssid);\n\t}\n\n\t/* Channel */\n\tif (params->chandef.chan) {\n\t\tu32 target_channel;\n\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(\n\t\t\t\tparams->chandef.chan->center_freq);\n\t\tif (params->channel_fixed) {\n\t\t\t/* adding chanspec */\n\t\t\tchanspec = chandef_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       &params->chandef);\n\t\t\tjoin_params.params_le.chanspec_list[0] =\n\t\t\t\tcpu_to_le16(chanspec);\n\t\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\t\tjoin_params_size += sizeof(join_params.params_le);\n\t\t}\n\n\t\t/* set channel for starter */\n\t\ttarget_channel = cfg->channel;\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,\n\t\t\t\t\t    target_channel);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_CHANNEL failed (%d)\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tcfg->channel = 0;\n\n\tcfg->ibss_starter = false;\n\n\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_SSID failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif)) {\n\t\t/* When driver is being unloaded, it can end up here. If an\n\t\t * error is returned then later on a debug trace in the wireless\n\t\t * core module will be printed. To avoid this 0 is returned.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tbrcmf_link_down(ifp->vif, WLAN_REASON_DEAUTH_LEAVING);\n\tbrcmf_net_setcarrier(ifp, false);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn 0;\n}\n\nstatic s32 brcmf_set_wpa_version(struct net_device *ndev,\n\t\t\t\t struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 val = 0;\n\ts32 err = 0;\n\n\tif (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\tval = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;\n\telse if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\tval = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;\n\telse\n\t\tval = WPA_AUTH_DISABLED;\n\tbrcmf_dbg(CONN, \"setting wpa_auth to 0x%0x\\n\", val);\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"wpa_auth\", val);\n\tif (err) {\n\t\tbrcmf_err(\"set wpa_auth failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsec = &profile->sec;\n\tsec->wpa_versions = sme->crypto.wpa_versions;\n\treturn err;\n}\n\nstatic s32 brcmf_set_auth_type(struct net_device *ndev,\n\t\t\t       struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 val = 0;\n\ts32 err = 0;\n\n\tswitch (sme->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tval = 0;\n\t\tbrcmf_dbg(CONN, \"open system\\n\");\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tval = 1;\n\t\tbrcmf_dbg(CONN, \"shared key\\n\");\n\t\tbreak;\n\tdefault:\n\t\tval = 2;\n\t\tbrcmf_dbg(CONN, \"automatic, auth type (%d)\\n\", sme->auth_type);\n\t\tbreak;\n\t}\n\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"auth\", val);\n\tif (err) {\n\t\tbrcmf_err(\"set auth failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsec = &profile->sec;\n\tsec->auth_type = sme->auth_type;\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_wsec_mode(struct net_device *ndev,\n\t\t    struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 pval = 0;\n\ts32 gval = 0;\n\ts32 wsec;\n\ts32 err = 0;\n\n\tif (sme->crypto.n_ciphers_pairwise) {\n\t\tswitch (sme->crypto.ciphers_pairwise[0]) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tpval = WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tpval = TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tpval = AES_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tpval = AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher pairwise (%d)\\n\",\n\t\t\t\t  sme->crypto.ciphers_pairwise[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sme->crypto.cipher_group) {\n\t\tswitch (sme->crypto.cipher_group) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tgval = WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tgval = TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tgval = AES_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tgval = AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher group (%d)\\n\",\n\t\t\t\t  sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbrcmf_dbg(CONN, \"pval (%d) gval (%d)\\n\", pval, gval);\n\t/* In case of privacy, but no security and WPS then simulate */\n\t/* setting AES. WPS-2.0 allows no security                   */\n\tif (brcmf_find_wpsie(sme->ie, sme->ie_len) && !pval && !gval &&\n\t    sme->privacy)\n\t\tpval = AES_ENABLED;\n\n\twsec = pval | gval;\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tsec = &profile->sec;\n\tsec->cipher_pairwise = sme->crypto.ciphers_pairwise[0];\n\tsec->cipher_group = sme->crypto.cipher_group;\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\ts32 val;\n\ts32 err;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst u8 *ie;\n\tu32 ie_len;\n\tu32 offset;\n\tu16 rsn_cap;\n\tu32 mfp;\n\tu16 count;\n\n\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_NONE;\n\n\tif (!sme->crypto.n_akm_suites)\n\t\treturn 0;\n\n\terr = brcmf_fil_bsscfg_int_get(netdev_priv(ndev), \"wpa_auth\", &val);\n\tif (err) {\n\t\tbrcmf_err(\"could not get wpa_auth (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tif (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {\n\t\tswitch (sme->crypto.akm_suites[0]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tval = WPA_AUTH_UNSPECIFIED;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tval = WPA_AUTH_PSK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher group (%d)\\n\",\n\t\t\t\t  sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {\n\t\tswitch (sme->crypto.akm_suites[0]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tval = WPA2_AUTH_UNSPECIFIED;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_8021X_SHA256:\n\t\t\tval = WPA2_AUTH_1X_SHA256;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK_SHA256:\n\t\t\tval = WPA2_AUTH_PSK_SHA256;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tval = WPA2_AUTH_PSK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher group (%d)\\n\",\n\t\t\t\t  sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (profile->use_fwsup == BRCMF_PROFILE_FWSUP_1X)\n\t\tbrcmf_dbg(INFO, \"using 1X offload\\n\");\n\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\tgoto skip_mfp_config;\n\t/* The MFP mode (1 or 2) needs to be determined, parse IEs. The\n\t * IE will not be verified, just a quick search for MFP config\n\t */\n\trsn_ie = brcmf_parse_tlvs((const u8 *)sme->ie, sme->ie_len,\n\t\t\t\t  WLAN_EID_RSN);\n\tif (!rsn_ie)\n\t\tgoto skip_mfp_config;\n\tie = (const u8 *)rsn_ie;\n\tie_len = rsn_ie->len + TLV_HDR_LEN;\n\t/* Skip unicast suite */\n\toffset = TLV_HDR_LEN + WPA_IE_VERSION_LEN + WPA_IE_MIN_OUI_LEN;\n\tif (offset + WPA_IE_SUITE_COUNT_LEN >= ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Skip multicast suite */\n\tcount = ie[offset] + (ie[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN + (count * WPA_IE_MIN_OUI_LEN);\n\tif (offset + WPA_IE_SUITE_COUNT_LEN >= ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Skip auth key management suite(s) */\n\tcount = ie[offset] + (ie[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN + (count * WPA_IE_MIN_OUI_LEN);\n\tif (offset + WPA_IE_SUITE_COUNT_LEN > ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Ready to read capabilities */\n\tmfp = BRCMF_MFP_NONE;\n\trsn_cap = ie[offset] + (ie[offset + 1] << 8);\n\tif (rsn_cap & RSN_CAP_MFPR_MASK)\n\t\tmfp = BRCMF_MFP_REQUIRED;\n\telse if (rsn_cap & RSN_CAP_MFPC_MASK)\n\t\tmfp = BRCMF_MFP_CAPABLE;\n\tbrcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"mfp\", mfp);\n\nskip_mfp_config:\n\tbrcmf_dbg(CONN, \"setting wpa_auth to %d\\n\", val);\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"wpa_auth\", val);\n\tif (err) {\n\t\tbrcmf_err(\"could not set wpa_auth (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_sharedkey(struct net_device *ndev,\n\t\t    struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\tstruct brcmf_wsec_key key;\n\ts32 val;\n\ts32 err = 0;\n\n\tbrcmf_dbg(CONN, \"key len (%d)\\n\", sme->key_len);\n\n\tif (sme->key_len == 0)\n\t\treturn 0;\n\n\tsec = &profile->sec;\n\tbrcmf_dbg(CONN, \"wpa_versions 0x%x cipher_pairwise 0x%x\\n\",\n\t\t  sec->wpa_versions, sec->cipher_pairwise);\n\n\tif (sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))\n\t\treturn 0;\n\n\tif (!(sec->cipher_pairwise &\n\t    (WLAN_CIPHER_SUITE_WEP40 | WLAN_CIPHER_SUITE_WEP104)))\n\t\treturn 0;\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.len = (u32) sme->key_len;\n\tkey.index = (u32) sme->key_idx;\n\tif (key.len > sizeof(key.data)) {\n\t\tbrcmf_err(\"Too long key length (%u)\\n\", key.len);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(key.data, sme->key, key.len);\n\tkey.flags = BRCMF_PRIMARY_KEY;\n\tswitch (sec->cipher_pairwise) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey.algo = CRYPTO_ALGO_WEP1;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey.algo = CRYPTO_ALGO_WEP128;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"Invalid algorithm (%d)\\n\",\n\t\t\t  sme->crypto.ciphers_pairwise[0]);\n\t\treturn -EINVAL;\n\t}\n\t/* Set the new key/index */\n\tbrcmf_dbg(CONN, \"key length (%d) key index (%d) algo (%d)\\n\",\n\t\t  key.len, key.index, key.algo);\n\tbrcmf_dbg(CONN, \"key \\\"%s\\\"\\n\", key.data);\n\terr = send_key_to_dongle(netdev_priv(ndev), &key);\n\tif (err)\n\t\treturn err;\n\n\tif (sec->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {\n\t\tbrcmf_dbg(CONN, \"set auth_type to shared key\\n\");\n\t\tval = WL_AUTH_SHARED_KEY;\t/* shared key */\n\t\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"auth\", val);\n\t\tif (err)\n\t\t\tbrcmf_err(\"set auth failed (%d)\\n\", err);\n\t}\n\treturn err;\n}\n\nstatic\nenum nl80211_auth_type brcmf_war_auth_type(struct brcmf_if *ifp,\n\t\t\t\t\t   enum nl80211_auth_type type)\n{\n\tif (type == NL80211_AUTHTYPE_AUTOMATIC &&\n\t    brcmf_feat_is_quirk_enabled(ifp, BRCMF_FEAT_QUIRK_AUTO_AUTH)) {\n\t\tbrcmf_dbg(CONN, \"WAR: use OPEN instead of AUTO\\n\");\n\t\ttype = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t}\n\treturn type;\n}\n\nstatic void brcmf_set_join_pref(struct brcmf_if *ifp,\n\t\t\t\tstruct cfg80211_bss_selection *bss_select)\n{\n\tstruct brcmf_join_pref_params join_pref_params[2];\n\tenum nl80211_band band;\n\tint err, i = 0;\n\n\tjoin_pref_params[i].len = 2;\n\tjoin_pref_params[i].rssi_gain = 0;\n\n\tif (bss_select->behaviour != NL80211_BSS_SELECT_ATTR_BAND_PREF)\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_ASSOC_PREFER, WLC_BAND_AUTO);\n\n\tswitch (bss_select->behaviour) {\n\tcase __NL80211_BSS_SELECT_ATTR_INVALID:\n\t\tbrcmf_c_set_joinpref_default(ifp);\n\t\treturn;\n\tcase NL80211_BSS_SELECT_ATTR_BAND_PREF:\n\t\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_BAND;\n\t\tband = bss_select->param.band_pref;\n\t\tjoin_pref_params[i].band = nl80211_band_to_fwil(band);\n\t\ti++;\n\t\tbreak;\n\tcase NL80211_BSS_SELECT_ATTR_RSSI_ADJUST:\n\t\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_RSSI_DELTA;\n\t\tband = bss_select->param.adjust.band;\n\t\tjoin_pref_params[i].band = nl80211_band_to_fwil(band);\n\t\tjoin_pref_params[i].rssi_gain = bss_select->param.adjust.delta;\n\t\ti++;\n\t\tbreak;\n\tcase NL80211_BSS_SELECT_ATTR_RSSI:\n\tdefault:\n\t\tbreak;\n\t}\n\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_RSSI;\n\tjoin_pref_params[i].len = 2;\n\tjoin_pref_params[i].rssi_gain = 0;\n\tjoin_pref_params[i].band = 0;\n\terr = brcmf_fil_iovar_data_set(ifp, \"join_pref\", join_pref_params,\n\t\t\t\t       sizeof(join_pref_params));\n\tif (err)\n\t\tbrcmf_err(\"Set join_pref error (%d)\\n\", err);\n}\n\nstatic s32\nbrcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct ieee80211_channel *chan = sme->channel;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tconst void *ie;\n\tu32 ie_len;\n\tstruct brcmf_ext_join_params_le *ext_join_params;\n\tu16 chanspec;\n\ts32 err = 0;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (!sme->ssid) {\n\t\tbrcmf_err(\"Invalid ssid\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif) {\n\t\t/* A normal (non P2P) connection request setup. */\n\t\tie = NULL;\n\t\tie_len = 0;\n\t\t/* find the WPA_IE */\n\t\twpa_ie = brcmf_find_wpaie((u8 *)sme->ie, sme->ie_len);\n\t\tif (wpa_ie) {\n\t\t\tie = wpa_ie;\n\t\t\tie_len = wpa_ie->len + TLV_HDR_LEN;\n\t\t} else {\n\t\t\t/* find the RSN_IE */\n\t\t\trsn_ie = brcmf_parse_tlvs((const u8 *)sme->ie,\n\t\t\t\t\t\t  sme->ie_len,\n\t\t\t\t\t\t  WLAN_EID_RSN);\n\t\t\tif (rsn_ie) {\n\t\t\t\tie = rsn_ie;\n\t\t\t\tie_len = rsn_ie->len + TLV_HDR_LEN;\n\t\t\t}\n\t\t}\n\t\tbrcmf_fil_iovar_data_set(ifp, \"wpaie\", ie, ie_len);\n\t}\n\n\terr = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,\n\t\t\t\t    sme->ie, sme->ie_len);\n\tif (err)\n\t\tbrcmf_err(\"Set Assoc REQ IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Assoc request\\n\");\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (chan) {\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(chan->center_freq);\n\t\tchanspec = channel_to_chanspec(&cfg->d11inf, chan);\n\t\tbrcmf_dbg(CONN, \"channel=%d, center_req=%d, chanspec=0x%04x\\n\",\n\t\t\t  cfg->channel, chan->center_freq, chanspec);\n\t} else {\n\t\tcfg->channel = 0;\n\t\tchanspec = 0;\n\t}\n\n\tbrcmf_dbg(INFO, \"ie (%p), ie_len (%zd)\\n\", sme->ie, sme->ie_len);\n\n\terr = brcmf_set_wpa_version(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_wpa_version failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tsme->auth_type = brcmf_war_auth_type(ifp, sme->auth_type);\n\terr = brcmf_set_auth_type(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_auth_type failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_wsec_mode(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_set_cipher failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_key_mgmt(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_key_mgmt failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_sharedkey(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"brcmf_set_sharedkey failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tif (sme->crypto.psk) {\n\t\tif (WARN_ON(profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"using PSK offload\\n\");\n\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_PSK;\n\t}\n\n\tif (profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {\n\t\t/* enable firmware supplicant for this interface */\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"sup_wpa\", 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"failed to enable fw supplicant\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (profile->use_fwsup == BRCMF_PROFILE_FWSUP_PSK) {\n\t\terr = brcmf_set_pmk(ifp, sme->crypto.psk,\n\t\t\t\t    BRCMF_WSEC_MAX_PSK_LEN);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\t/* Join with specific BSSID and cached SSID\n\t * If SSID is zero join based on BSSID only\n\t */\n\tjoin_params_size = offsetof(struct brcmf_ext_join_params_le, assoc_le) +\n\t\toffsetof(struct brcmf_assoc_params_le, chanspec_list);\n\tif (cfg->channel)\n\t\tjoin_params_size += sizeof(u16);\n\text_join_params = kzalloc(join_params_size, GFP_KERNEL);\n\tif (ext_join_params == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tssid_len = min_t(u32, sme->ssid_len, IEEE80211_MAX_SSID_LEN);\n\text_join_params->ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tmemcpy(&ext_join_params->ssid_le.SSID, sme->ssid, ssid_len);\n\tif (ssid_len < IEEE80211_MAX_SSID_LEN)\n\t\tbrcmf_dbg(CONN, \"SSID \\\"%s\\\", len (%d)\\n\",\n\t\t\t  ext_join_params->ssid_le.SSID, ssid_len);\n\n\t/* Set up join scan parameters */\n\text_join_params->scan_le.scan_type = -1;\n\text_join_params->scan_le.home_time = cpu_to_le32(-1);\n\n\tif (sme->bssid)\n\t\tmemcpy(&ext_join_params->assoc_le.bssid, sme->bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(ext_join_params->assoc_le.bssid);\n\n\tif (cfg->channel) {\n\t\text_join_params->assoc_le.chanspec_num = cpu_to_le32(1);\n\n\t\text_join_params->assoc_le.chanspec_list[0] =\n\t\t\tcpu_to_le16(chanspec);\n\t\t/* Increase dwell time to receive probe response or detect\n\t\t * beacon from target AP at a noisy air only during connect\n\t\t * command.\n\t\t */\n\t\text_join_params->scan_le.active_time =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS);\n\t\text_join_params->scan_le.passive_time =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_PASSIVE_DWELL_TIME_MS);\n\t\t/* To sync with presence period of VSDB GO send probe request\n\t\t * more frequently. Probe request will be stopped when it gets\n\t\t * probe response from target AP/GO.\n\t\t */\n\t\text_join_params->scan_le.nprobes =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS /\n\t\t\t\t    BRCMF_SCAN_JOIN_PROBE_INTERVAL_MS);\n\t} else {\n\t\text_join_params->scan_le.active_time = cpu_to_le32(-1);\n\t\text_join_params->scan_le.passive_time = cpu_to_le32(-1);\n\t\text_join_params->scan_le.nprobes = cpu_to_le32(-1);\n\t}\n\n\tbrcmf_set_join_pref(ifp, &sme->bss_select);\n\n\terr  = brcmf_fil_bsscfg_data_set(ifp, \"join\", ext_join_params,\n\t\t\t\t\t join_params_size);\n\tkfree(ext_join_params);\n\tif (!err)\n\t\t/* This is it. join command worked, we are done */\n\t\tgoto done;\n\n\t/* join command failed, fallback to set ssid */\n\tmemset(&join_params, 0, sizeof(join_params));\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\tmemcpy(&join_params.ssid_le.SSID, sme->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\n\tif (sme->bssid)\n\t\tmemcpy(join_params.params_le.bssid, sme->bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\n\tif (cfg->channel) {\n\t\tjoin_params.params_le.chanspec_list[0] = cpu_to_le16(chanspec);\n\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\tjoin_params_size += sizeof(join_params.params_le);\n\t}\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err)\n\t\tbrcmf_err(\"BRCMF_C_SET_SSID failed (%d)\\n\", err);\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u16 reason_code)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_scb_val_le scbval;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter. Reason code = %d\\n\", reason_code);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tcfg80211_disconnected(ndev, reason_code, NULL, 0, true, GFP_KERNEL);\n\n\tmemcpy(&scbval.ea, &profile->bssid, ETH_ALEN);\n\tscbval.val = cpu_to_le32(reason_code);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_DISASSOC,\n\t\t\t\t     &scbval, sizeof(scbval));\n\tif (err)\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t    enum nl80211_tx_power_setting type, s32 mbm)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\ts32 disable;\n\tu32 qdbm = 127;\n\n\tbrcmf_dbg(TRACE, \"Enter %d %d\\n\", type, mbm);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tswitch (type) {\n\tcase NL80211_TX_POWER_AUTOMATIC:\n\t\tbreak;\n\tcase NL80211_TX_POWER_LIMITED:\n\tcase NL80211_TX_POWER_FIXED:\n\t\tif (mbm < 0) {\n\t\t\tbrcmf_err(\"TX_POWER_FIXED - dbm is negative\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tqdbm =  MBM_TO_DBM(4 * mbm);\n\t\tif (qdbm > 127)\n\t\t\tqdbm = 127;\n\t\tqdbm |= WL_TXPWR_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"Unsupported type %d\\n\", type);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\t/* Make sure radio is off or on as far as software is concerned */\n\tdisable = WL_RADIO_SW_DISABLE << 16;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_RADIO, disable);\n\tif (err)\n\t\tbrcmf_err(\"WLC_SET_RADIO error (%d)\\n\", err);\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"qtxpower\", qdbm);\n\tif (err)\n\t\tbrcmf_err(\"qtxpower error (%d)\\n\", err);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit %d (qdbm)\\n\", qdbm & ~WL_TXPWR_OVERRIDE);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t    s32 *dbm)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 qdbm = 0;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\terr = brcmf_fil_iovar_int_get(ifp, \"qtxpower\", &qdbm);\n\tif (err) {\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\t*dbm = (qdbm & ~WL_TXPWR_OVERRIDE) / 4;\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit (0x%x %d)\\n\", qdbm, *dbm);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t  u8 key_idx, bool unicast, bool multicast)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tu32 index;\n\tu32 wsec;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_GET_WSEC error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tif (wsec & WEP_ENABLED) {\n\t\t/* Just select a new current key */\n\t\tindex = key_idx;\n\t\terr = brcmf_fil_cmd_int_set(ifp,\n\t\t\t\t\t    BRCMF_C_SET_KEY_PRIMARY, index);\n\t\tif (err)\n\t\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u8 key_idx, bool pairwise, const u8 *mac_addr)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_wsec_key *key;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {\n\t\t/* we ignore this key index in this case */\n\t\treturn -EINVAL;\n\t}\n\n\tkey = &ifp->vif->profile.key[key_idx];\n\n\tif (key->algo == CRYPTO_ALGO_OFF) {\n\t\tbrcmf_dbg(CONN, \"Ignore clearing of (never configured) key\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(key, 0, sizeof(*key));\n\tkey->index = (u32)key_idx;\n\tkey->flags = BRCMF_PRIMARY_KEY;\n\n\t/* Clear the key/index */\n\terr = send_key_to_dongle(ifp, key);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u8 key_idx, bool pairwise, const u8 *mac_addr,\n\t\t       struct key_params *params)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_wsec_key *key;\n\ts32 val;\n\ts32 wsec;\n\ts32 err;\n\tu8 keybuf[8];\n\tbool ext_key;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {\n\t\t/* we ignore this key index in this case */\n\t\tbrcmf_err(\"invalid key index (%d)\\n\", key_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (params->key_len == 0)\n\t\treturn brcmf_cfg80211_del_key(wiphy, ndev, key_idx, pairwise,\n\t\t\t\t\t      mac_addr);\n\n\tif (params->key_len > sizeof(key->data)) {\n\t\tbrcmf_err(\"Too long key length (%u)\\n\", params->key_len);\n\t\treturn -EINVAL;\n\t}\n\n\text_key = false;\n\tif (mac_addr && (params->cipher != WLAN_CIPHER_SUITE_WEP40) &&\n\t    (params->cipher != WLAN_CIPHER_SUITE_WEP104)) {\n\t\tbrcmf_dbg(TRACE, \"Ext key, mac %pM\", mac_addr);\n\t\text_key = true;\n\t}\n\n\tkey = &ifp->vif->profile.key[key_idx];\n\tmemset(key, 0, sizeof(*key));\n\tif ((ext_key) && (!is_multicast_ether_addr(mac_addr)))\n\t\tmemcpy((char *)&key->ea, (void *)mac_addr, ETH_ALEN);\n\tkey->len = params->key_len;\n\tkey->index = key_idx;\n\tmemcpy(key->data, params->key, key->len);\n\tif (!ext_key)\n\t\tkey->flags = BRCMF_PRIMARY_KEY;\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey->algo = CRYPTO_ALGO_WEP1;\n\t\tval = WEP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP40\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey->algo = CRYPTO_ALGO_WEP128;\n\t\tval = WEP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP104\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (!brcmf_is_apmode(ifp->vif)) {\n\t\t\tbrcmf_dbg(CONN, \"Swapping RX/TX MIC key\\n\");\n\t\t\tmemcpy(keybuf, &key->data[24], sizeof(keybuf));\n\t\t\tmemcpy(&key->data[24], &key->data[16], sizeof(keybuf));\n\t\t\tmemcpy(&key->data[16], keybuf, sizeof(keybuf));\n\t\t}\n\t\tkey->algo = CRYPTO_ALGO_TKIP;\n\t\tval = TKIP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_TKIP\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tkey->algo = CRYPTO_ALGO_AES_CCM;\n\t\tval = AES_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_AES_CMAC\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey->algo = CRYPTO_ALGO_AES_CCM;\n\t\tval = AES_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_CCMP\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"Invalid cipher (0x%x)\\n\", params->cipher);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\terr = send_key_to_dongle(ifp, key);\n\tif (ext_key || err)\n\t\tgoto done;\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"get wsec error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\twsec |= val;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"set wsec error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev, u8 key_idx,\n\t\t       bool pairwise, const u8 *mac_addr, void *cookie,\n\t\t       void (*callback)(void *cookie,\n\t\t\t\t\tstruct key_params *params))\n{\n\tstruct key_params params;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 wsec;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemset(&params, 0, sizeof(params));\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_GET_WSEC error (%d)\\n\", err);\n\t\t/* Ignore this error, may happen during DISASSOC */\n\t\terr = -EAGAIN;\n\t\tgoto done;\n\t}\n\tif (wsec & WEP_ENABLED) {\n\t\tsec = &profile->sec;\n\t\tif (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {\n\t\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP40;\n\t\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP40\\n\");\n\t\t} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP104;\n\t\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP104\\n\");\n\t\t}\n\t} else if (wsec & TKIP_ENABLED) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_TKIP\\n\");\n\t} else if (wsec & AES_ENABLED) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_AES_CMAC;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_AES_CMAC\\n\");\n\t} else  {\n\t\tbrcmf_err(\"Invalid algo (0x%x)\\n\", wsec);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tcallback(cookie, &params);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *ndev, u8 key_idx)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter key_idx %d\\n\", key_idx);\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\treturn 0;\n\n\tbrcmf_dbg(INFO, \"Not supported\\n\");\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nbrcmf_cfg80211_reconfigure_wep(struct brcmf_if *ifp)\n{\n\ts32 err;\n\tu8 key_idx;\n\tstruct brcmf_wsec_key *key;\n\ts32 wsec;\n\n\tfor (key_idx = 0; key_idx < BRCMF_MAX_DEFAULT_KEYS; key_idx++) {\n\t\tkey = &ifp->vif->profile.key[key_idx];\n\t\tif ((key->algo == CRYPTO_ALGO_WEP1) ||\n\t\t    (key->algo == CRYPTO_ALGO_WEP128))\n\t\t\tbreak;\n\t}\n\tif (key_idx == BRCMF_MAX_DEFAULT_KEYS)\n\t\treturn;\n\n\terr = send_key_to_dongle(ifp, key);\n\tif (err) {\n\t\tbrcmf_err(\"Setting WEP key failed (%d)\\n\", err);\n\t\treturn;\n\t}\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"get wsec error (%d)\\n\", err);\n\t\treturn;\n\t}\n\twsec |= WEP_ENABLED;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err)\n\t\tbrcmf_err(\"set wsec error (%d)\\n\", err);\n}\n\nstatic void brcmf_convert_sta_flags(u32 fw_sta_flags, struct station_info *si)\n{\n\tstruct nl80211_sta_flag_update *sfu;\n\n\tbrcmf_dbg(TRACE, \"flags %08x\\n\", fw_sta_flags);\n\tsi->filled |= BIT(NL80211_STA_INFO_STA_FLAGS);\n\tsfu = &si->sta_flags;\n\tsfu->mask = BIT(NL80211_STA_FLAG_WME) |\n\t\t    BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t    BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t    BIT(NL80211_STA_FLAG_AUTHORIZED);\n\tif (fw_sta_flags & BRCMF_STA_WME)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_WME);\n\tif (fw_sta_flags & BRCMF_STA_AUTHE)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);\n\tif (fw_sta_flags & BRCMF_STA_ASSOC)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\tif (fw_sta_flags & BRCMF_STA_AUTHO)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_AUTHORIZED);\n}\n\nstatic void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)\n{\n\tstruct {\n\t\t__le32 len;\n\t\tstruct brcmf_bss_info_le bss_le;\n\t} *buf;\n\tu16 capability;\n\tint err;\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tbuf->len = cpu_to_le32(WL_BSS_INFO_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO, buf,\n\t\t\t\t     WL_BSS_INFO_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"Failed to get bss info (%d)\\n\", err);\n\t\tgoto out_kfree;\n\t}\n\tsi->filled |= BIT(NL80211_STA_INFO_BSS_PARAM);\n\tsi->bss_param.beacon_interval = le16_to_cpu(buf->bss_le.beacon_period);\n\tsi->bss_param.dtim_period = buf->bss_le.dtim_period;\n\tcapability = le16_to_cpu(buf->bss_le.capability);\n\tif (capability & IEEE80211_HT_STBC_PARAM_DUAL_CTS_PROT)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_CTS_PROT;\n\tif (capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;\n\tif (capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;\n\nout_kfree:\n\tkfree(buf);\n}\n\nstatic s32\nbrcmf_cfg80211_get_station_ibss(struct brcmf_if *ifp,\n\t\t\t\tstruct station_info *sinfo)\n{\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_pktcnt_le pktcnt;\n\ts32 err;\n\tu32 rate;\n\tu32 rssi;\n\n\t/* Get the current tx rate */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);\n\tif (err < 0) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RATE error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\n\tsinfo->txrate.legacy = rate * 5;\n\n\tmemset(&scbval, 0, sizeof(scbval));\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI, &scbval,\n\t\t\t\t     sizeof(scbval));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RSSI error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\trssi = le32_to_cpu(scbval.val);\n\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\tsinfo->signal = rssi;\n\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_GET_PKTCNTS, &pktcnt,\n\t\t\t\t     sizeof(pktcnt));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_GET_PKTCNTS error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_RX_DROP_MISC) |\n\t\t\t BIT(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_TX_FAILED);\n\tsinfo->rx_packets = le32_to_cpu(pktcnt.rx_good_pkt);\n\tsinfo->rx_dropped_misc = le32_to_cpu(pktcnt.rx_bad_pkt);\n\tsinfo->tx_packets = le32_to_cpu(pktcnt.tx_good_pkt);\n\tsinfo->tx_failed  = le32_to_cpu(pktcnt.tx_bad_pkt);\n\n\treturn 0;\n}\n\nstatic s32\nbrcmf_cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   const u8 *mac, struct station_info *sinfo)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_scb_val_le scb_val;\n\ts32 err = 0;\n\tstruct brcmf_sta_info_le sta_info_le;\n\tu32 sta_flags;\n\tu32 is_tdls_peer;\n\ts32 total_rssi;\n\ts32 count_rssi;\n\tint rssi;\n\tu32 i;\n\n\tbrcmf_dbg(TRACE, \"Enter, MAC %pM\\n\", mac);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (brcmf_is_ibssmode(ifp->vif))\n\t\treturn brcmf_cfg80211_get_station_ibss(ifp, sinfo);\n\n\tmemset(&sta_info_le, 0, sizeof(sta_info_le));\n\tmemcpy(&sta_info_le, mac, ETH_ALEN);\n\terr = brcmf_fil_iovar_data_get(ifp, \"tdls_sta_info\",\n\t\t\t\t       &sta_info_le,\n\t\t\t\t       sizeof(sta_info_le));\n\tis_tdls_peer = !err;\n\tif (err) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"sta_info\",\n\t\t\t\t\t       &sta_info_le,\n\t\t\t\t\t       sizeof(sta_info_le));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"GET STA INFO failed, %d\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tbrcmf_dbg(TRACE, \"version %d\\n\", le16_to_cpu(sta_info_le.ver));\n\tsinfo->filled = BIT(NL80211_STA_INFO_INACTIVE_TIME);\n\tsinfo->inactive_time = le32_to_cpu(sta_info_le.idle) * 1000;\n\tsta_flags = le32_to_cpu(sta_info_le.flags);\n\tbrcmf_convert_sta_flags(sta_flags, sinfo);\n\tsinfo->sta_flags.mask |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\tif (is_tdls_peer)\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\telse\n\t\tsinfo->sta_flags.set &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\tif (sta_flags & BRCMF_STA_ASSOC) {\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_CONNECTED_TIME);\n\t\tsinfo->connected_time = le32_to_cpu(sta_info_le.in);\n\t\tbrcmf_fill_bss_param(ifp, sinfo);\n\t}\n\tif (sta_flags & BRCMF_STA_SCBSTATS) {\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_FAILED);\n\t\tsinfo->tx_failed = le32_to_cpu(sta_info_le.tx_failures);\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);\n\t\tsinfo->tx_packets = le32_to_cpu(sta_info_le.tx_pkts);\n\t\tsinfo->tx_packets += le32_to_cpu(sta_info_le.tx_mcast_pkts);\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);\n\t\tsinfo->rx_packets = le32_to_cpu(sta_info_le.rx_ucast_pkts);\n\t\tsinfo->rx_packets += le32_to_cpu(sta_info_le.rx_mcast_pkts);\n\t\tif (sinfo->tx_packets) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\n\t\t\tsinfo->txrate.legacy =\n\t\t\t\tle32_to_cpu(sta_info_le.tx_rate) / 100;\n\t\t}\n\t\tif (sinfo->rx_packets) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_BITRATE);\n\t\t\tsinfo->rxrate.legacy =\n\t\t\t\tle32_to_cpu(sta_info_le.rx_rate) / 100;\n\t\t}\n\t\tif (le16_to_cpu(sta_info_le.ver) >= 4) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES);\n\t\t\tsinfo->tx_bytes = le64_to_cpu(sta_info_le.tx_tot_bytes);\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_BYTES);\n\t\t\tsinfo->rx_bytes = le64_to_cpu(sta_info_le.rx_tot_bytes);\n\t\t}\n\t\ttotal_rssi = 0;\n\t\tcount_rssi = 0;\n\t\tfor (i = 0; i < BRCMF_ANT_MAX; i++) {\n\t\t\tif (sta_info_le.rssi[i]) {\n\t\t\t\tsinfo->chain_signal_avg[count_rssi] =\n\t\t\t\t\tsta_info_le.rssi[i];\n\t\t\t\tsinfo->chain_signal[count_rssi] =\n\t\t\t\t\tsta_info_le.rssi[i];\n\t\t\t\ttotal_rssi += sta_info_le.rssi[i];\n\t\t\t\tcount_rssi++;\n\t\t\t}\n\t\t}\n\t\tif (count_rssi) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_CHAIN_SIGNAL);\n\t\t\tsinfo->chains = count_rssi;\n\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\t\t\ttotal_rssi /= count_rssi;\n\t\t\tsinfo->signal = total_rssi;\n\t\t} else if (test_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t&ifp->vif->sme_state)) {\n\t\t\tmemset(&scb_val, 0, sizeof(scb_val));\n\t\t\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,\n\t\t\t\t\t\t     &scb_val, sizeof(scb_val));\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"Could not get rssi (%d)\\n\", err);\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\trssi = le32_to_cpu(scb_val.val);\n\t\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\t\t\t\tsinfo->signal = rssi;\n\t\t\t\tbrcmf_dbg(CONN, \"RSSI %d dBm\\n\", rssi);\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t    int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, idx %d\\n\", idx);\n\n\tif (idx == 0) {\n\t\tcfg->assoclist.count = cpu_to_le32(BRCMF_MAX_ASSOCLIST);\n\t\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_ASSOCLIST,\n\t\t\t\t\t     &cfg->assoclist,\n\t\t\t\t\t     sizeof(cfg->assoclist));\n\t\tif (err) {\n\t\t\tbrcmf_err(\"BRCMF_C_GET_ASSOCLIST unsupported, err=%d\\n\",\n\t\t\t\t  err);\n\t\t\tcfg->assoclist.count = 0;\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (idx < le32_to_cpu(cfg->assoclist.count)) {\n\t\tmemcpy(mac, cfg->assoclist.mac[idx], ETH_ALEN);\n\t\treturn brcmf_cfg80211_get_station(wiphy, ndev, mac, sinfo);\n\t}\n\treturn -ENOENT;\n}\n\nstatic s32\nbrcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   bool enabled, s32 timeout)\n{\n\ts32 pm;\n\ts32 err = 0;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t/*\n\t * Powersave enable/disable request is coming from the\n\t * cfg80211 even before the interface is up. In that\n\t * scenario, driver will be storing the power save\n\t * preference in cfg struct to apply this to\n\t * FW later while initializing the dongle\n\t */\n\tcfg->pwr_save = enabled;\n\tif (!check_vif_up(ifp->vif)) {\n\n\t\tbrcmf_dbg(INFO, \"Device is not ready, storing the value in cfg_info struct\\n\");\n\t\tgoto done;\n\t}\n\n\tpm = enabled ? PM_FAST : PM_OFF;\n\t/* Do not enable the power save after assoc if it is a p2p interface */\n\tif (ifp->vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tbrcmf_dbg(INFO, \"Do not enable power save for P2P clients\\n\");\n\t\tpm = PM_OFF;\n\t}\n\tbrcmf_dbg(INFO, \"power save %s\\n\", (pm ? \"enabled\" : \"disabled\"));\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, pm);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tbrcmf_err(\"net_device is not ready yet\\n\");\n\t\telse\n\t\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t   struct brcmf_bss_info_le *bi)\n{\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct ieee80211_channel *notify_channel;\n\tstruct cfg80211_bss *bss;\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmu_chan ch;\n\tu16 channel;\n\tu32 freq;\n\tu16 notify_capability;\n\tu16 notify_interval;\n\tu8 *notify_ie;\n\tsize_t notify_ielen;\n\ts32 notify_signal;\n\n\tif (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {\n\t\tbrcmf_err(\"Bss info is larger than buffer. Discarding\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!bi->ctl_ch) {\n\t\tch.chspec = le16_to_cpu(bi->chanspec);\n\t\tcfg->d11inf.decchspec(&ch);\n\t\tbi->ctl_ch = ch.control_ch_num;\n\t}\n\tchannel = bi->ctl_ch;\n\n\tif (channel <= CH_MAX_2G_CHANNEL)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(channel, band->band);\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\n\tnotify_capability = le16_to_cpu(bi->capability);\n\tnotify_interval = le16_to_cpu(bi->beacon_period);\n\tnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\n\tnotify_ielen = le32_to_cpu(bi->ie_length);\n\tnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\n\n\tbrcmf_dbg(CONN, \"bssid: %pM\\n\", bi->BSSID);\n\tbrcmf_dbg(CONN, \"Channel: %d(%d)\\n\", channel, freq);\n\tbrcmf_dbg(CONN, \"Capability: %X\\n\", notify_capability);\n\tbrcmf_dbg(CONN, \"Beacon interval: %d\\n\", notify_interval);\n\tbrcmf_dbg(CONN, \"Signal: %d\\n\", notify_signal);\n\n\tbss = cfg80211_inform_bss(wiphy, notify_channel,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t  (const u8 *)bi->BSSID,\n\t\t\t\t  0, notify_capability,\n\t\t\t\t  notify_interval, notify_ie,\n\t\t\t\t  notify_ielen, notify_signal,\n\t\t\t\t  GFP_KERNEL);\n\n\tif (!bss)\n\t\treturn -ENOMEM;\n\n\tcfg80211_put_bss(wiphy, bss);\n\n\treturn 0;\n}\n\nstatic struct brcmf_bss_info_le *\nnext_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)\n{\n\tif (bss == NULL)\n\t\treturn list->bss_info_le;\n\treturn (struct brcmf_bss_info_le *)((unsigned long)bss +\n\t\t\t\t\t    le32_to_cpu(bss->length));\n}\n\nstatic s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_scan_results *bss_list;\n\tstruct brcmf_bss_info_le *bi = NULL;\t/* must be initialized */\n\ts32 err = 0;\n\tint i;\n\n\tbss_list = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\n\tif (bss_list->count != 0 &&\n\t    bss_list->version != BRCMF_BSS_INFO_VERSION) {\n\t\tbrcmf_err(\"Version %d != WL_BSS_INFO_VERSION\\n\",\n\t\t\t  bss_list->version);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tbrcmf_dbg(SCAN, \"scanned AP count (%d)\\n\", bss_list->count);\n\tfor (i = 0; i < bss_list->count; i++) {\n\t\tbi = next_bss_le(bss_list, bi);\n\t\terr = brcmf_inform_single_bss(cfg, bi);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic s32 brcmf_inform_ibss(struct brcmf_cfg80211_info *cfg,\n\t\t\t     struct net_device *ndev, const u8 *bssid)\n{\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct ieee80211_channel *notify_channel;\n\tstruct brcmf_bss_info_le *bi = NULL;\n\tstruct ieee80211_supported_band *band;\n\tstruct cfg80211_bss *bss;\n\tstruct brcmu_chan ch;\n\tu8 *buf = NULL;\n\ts32 err = 0;\n\tu32 freq;\n\tu16 notify_capability;\n\tu16 notify_interval;\n\tu8 *notify_ie;\n\tsize_t notify_ielen;\n\ts32 notify_signal;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto CleanUp;\n\t}\n\n\t*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\n\n\terr = brcmf_fil_cmd_data_get(netdev_priv(ndev), BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     buf, WL_BSS_INFO_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_GET_BSS_INFO failed: %d\\n\", err);\n\t\tgoto CleanUp;\n\t}\n\n\tbi = (struct brcmf_bss_info_le *)(buf + 4);\n\n\tch.chspec = le16_to_cpu(bi->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\n\tif (ch.band == BRCMU_CHAN_BAND_2G)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);\n\tcfg->channel = freq;\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\n\tnotify_capability = le16_to_cpu(bi->capability);\n\tnotify_interval = le16_to_cpu(bi->beacon_period);\n\tnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\n\tnotify_ielen = le32_to_cpu(bi->ie_length);\n\tnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\n\n\tbrcmf_dbg(CONN, \"channel: %d(%d)\\n\", ch.control_ch_num, freq);\n\tbrcmf_dbg(CONN, \"capability: %X\\n\", notify_capability);\n\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\", notify_interval);\n\tbrcmf_dbg(CONN, \"signal: %d\\n\", notify_signal);\n\n\tbss = cfg80211_inform_bss(wiphy, notify_channel,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN, bssid, 0,\n\t\t\t\t  notify_capability, notify_interval,\n\t\t\t\t  notify_ie, notify_ielen, notify_signal,\n\t\t\t\t  GFP_KERNEL);\n\n\tif (!bss) {\n\t\terr = -ENOMEM;\n\t\tgoto CleanUp;\n\t}\n\n\tcfg80211_put_bss(wiphy, bss);\n\nCleanUp:\n\n\tkfree(buf);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn err;\n}\n\nstatic s32 brcmf_update_bss_info(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t struct brcmf_if *ifp)\n{\n\tstruct brcmf_bss_info_le *bi;\n\tconst struct brcmf_tlv *tim;\n\tu16 beacon_interval;\n\tu8 dtim_period;\n\tsize_t ie_len;\n\tu8 *ie;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (brcmf_is_ibssmode(ifp->vif))\n\t\treturn err;\n\n\t*(__le32 *)cfg->extra_buf = cpu_to_le32(WL_EXTRA_BUF_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     cfg->extra_buf, WL_EXTRA_BUF_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"Could not get bss info %d\\n\", err);\n\t\tgoto update_bss_info_out;\n\t}\n\n\tbi = (struct brcmf_bss_info_le *)(cfg->extra_buf + 4);\n\terr = brcmf_inform_single_bss(cfg, bi);\n\tif (err)\n\t\tgoto update_bss_info_out;\n\n\tie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);\n\tie_len = le32_to_cpu(bi->ie_length);\n\tbeacon_interval = le16_to_cpu(bi->beacon_period);\n\n\ttim = brcmf_parse_tlvs(ie, ie_len, WLAN_EID_TIM);\n\tif (tim)\n\t\tdtim_period = tim->data[1];\n\telse {\n\t\t/*\n\t\t* active scan was done so we could not get dtim\n\t\t* information out of probe response.\n\t\t* so we speficially query dtim information to dongle.\n\t\t*/\n\t\tu32 var;\n\t\terr = brcmf_fil_iovar_int_get(ifp, \"dtim_assoc\", &var);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"wl dtim_assoc failed (%d)\\n\", err);\n\t\t\tgoto update_bss_info_out;\n\t\t}\n\t\tdtim_period = (u8)var;\n\t}\n\nupdate_bss_info_out:\n\tbrcmf_dbg(TRACE, \"Exit\");\n\treturn err;\n}\n\nvoid brcmf_abort_scanning(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct escan_info *escan = &cfg->escan_info;\n\n\tset_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\n\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\tescan->escan_state = WL_ESCAN_STATE_IDLE;\n\t\tbrcmf_notify_escan_complete(cfg, escan->ifp, true, true);\n\t}\n\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tclear_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\n}\n\nstatic void brcmf_cfg80211_escan_timeout_worker(struct work_struct *work)\n{\n\tstruct brcmf_cfg80211_info *cfg =\n\t\t\tcontainer_of(work, struct brcmf_cfg80211_info,\n\t\t\t\t     escan_timeout_work);\n\n\tbrcmf_inform_bss(cfg);\n\tbrcmf_notify_escan_complete(cfg, cfg->escan_info.ifp, true, true);\n}\n\nstatic void brcmf_escan_timeout(unsigned long data)\n{\n\tstruct brcmf_cfg80211_info *cfg =\n\t\t\t(struct brcmf_cfg80211_info *)data;\n\n\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\tbrcmf_err(\"timer expired\\n\");\n\t\tschedule_work(&cfg->escan_timeout_work);\n\t}\n}\n\nstatic s32\nbrcmf_compare_update_same_bss(struct brcmf_cfg80211_info *cfg,\n\t\t\t      struct brcmf_bss_info_le *bss,\n\t\t\t      struct brcmf_bss_info_le *bss_info_le)\n{\n\tstruct brcmu_chan ch_bss, ch_bss_info_le;\n\n\tch_bss.chspec = le16_to_cpu(bss->chanspec);\n\tcfg->d11inf.decchspec(&ch_bss);\n\tch_bss_info_le.chspec = le16_to_cpu(bss_info_le->chanspec);\n\tcfg->d11inf.decchspec(&ch_bss_info_le);\n\n\tif (!memcmp(&bss_info_le->BSSID, &bss->BSSID, ETH_ALEN) &&\n\t\tch_bss.band == ch_bss_info_le.band &&\n\t\tbss_info_le->SSID_len == bss->SSID_len &&\n\t\t!memcmp(bss_info_le->SSID, bss->SSID, bss_info_le->SSID_len)) {\n\t\tif ((bss->flags & BRCMF_BSS_RSSI_ON_CHANNEL) ==\n\t\t\t(bss_info_le->flags & BRCMF_BSS_RSSI_ON_CHANNEL)) {\n\t\t\ts16 bss_rssi = le16_to_cpu(bss->RSSI);\n\t\t\ts16 bss_info_rssi = le16_to_cpu(bss_info_le->RSSI);\n\n\t\t\t/* preserve max RSSI if the measurements are\n\t\t\t* both on-channel or both off-channel\n\t\t\t*/\n\t\t\tif (bss_info_rssi > bss_rssi)\n\t\t\t\tbss->RSSI = bss_info_le->RSSI;\n\t\t} else if ((bss->flags & BRCMF_BSS_RSSI_ON_CHANNEL) &&\n\t\t\t(bss_info_le->flags & BRCMF_BSS_RSSI_ON_CHANNEL) == 0) {\n\t\t\t/* preserve the on-channel rssi measurement\n\t\t\t* if the new measurement is off channel\n\t\t\t*/\n\t\t\tbss->RSSI = bss_info_le->RSSI;\n\t\t\tbss->flags |= BRCMF_BSS_RSSI_ON_CHANNEL;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic s32\nbrcmf_cfg80211_escan_handler(struct brcmf_if *ifp,\n\t\t\t     const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 status;\n\tstruct brcmf_escan_result_le *escan_result_le;\n\tstruct brcmf_bss_info_le *bss_info_le;\n\tstruct brcmf_bss_info_le *bss = NULL;\n\tu32 bi_length;\n\tstruct brcmf_scan_results *list;\n\tu32 i;\n\tbool aborted;\n\n\tstatus = e->status;\n\n\tif (status == BRCMF_E_STATUS_ABORT)\n\t\tgoto exit;\n\n\tif (!test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tbrcmf_err(\"scan not ready, bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\t\treturn -EPERM;\n\t}\n\n\tif (status == BRCMF_E_STATUS_PARTIAL) {\n\t\tbrcmf_dbg(SCAN, \"ESCAN Partial result\\n\");\n\t\tescan_result_le = (struct brcmf_escan_result_le *) data;\n\t\tif (!escan_result_le) {\n\t\t\tbrcmf_err(\"Invalid escan result (NULL pointer)\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (le16_to_cpu(escan_result_le->bss_count) != 1) {\n\t\t\tbrcmf_err(\"Invalid bss_count %d: ignoring\\n\",\n\t\t\t\t  escan_result_le->bss_count);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_info_le = &escan_result_le->bss_info_le;\n\n\t\tif (brcmf_p2p_scan_finding_common_channel(cfg, bss_info_le))\n\t\t\tgoto exit;\n\n\t\tif (!cfg->int_escan_map && !cfg->scan_request) {\n\t\t\tbrcmf_dbg(SCAN, \"result without cfg80211 request\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbi_length = le32_to_cpu(bss_info_le->length);\n\t\tif (bi_length != (le32_to_cpu(escan_result_le->buflen) -\n\t\t\t\t\tWL_ESCAN_RESULTS_FIXED_SIZE)) {\n\t\t\tbrcmf_err(\"Invalid bss_info length %d: ignoring\\n\",\n\t\t\t\t  bi_length);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!(cfg_to_wiphy(cfg)->interface_modes &\n\t\t\t\t\tBIT(NL80211_IFTYPE_ADHOC))) {\n\t\t\tif (le16_to_cpu(bss_info_le->capability) &\n\t\t\t\t\t\tWLAN_CAPABILITY_IBSS) {\n\t\t\t\tbrcmf_err(\"Ignoring IBSS result\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tlist = (struct brcmf_scan_results *)\n\t\t\t\tcfg->escan_info.escan_buf;\n\t\tif (bi_length > BRCMF_ESCAN_BUF_SIZE - list->buflen) {\n\t\t\tbrcmf_err(\"Buffer is too small: ignoring\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (i = 0; i < list->count; i++) {\n\t\t\tbss = bss ? (struct brcmf_bss_info_le *)\n\t\t\t\t((unsigned char *)bss +\n\t\t\t\tle32_to_cpu(bss->length)) : list->bss_info_le;\n\t\t\tif (brcmf_compare_update_same_bss(cfg, bss,\n\t\t\t\t\t\t\t  bss_info_le))\n\t\t\t\tgoto exit;\n\t\t}\n\t\tmemcpy(&cfg->escan_info.escan_buf[list->buflen], bss_info_le,\n\t\t       bi_length);\n\t\tlist->version = le32_to_cpu(bss_info_le->version);\n\t\tlist->buflen += bi_length;\n\t\tlist->count++;\n\t} else {\n\t\tcfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\n\t\tif (brcmf_p2p_scan_finding_common_channel(cfg, NULL))\n\t\t\tgoto exit;\n\t\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\t\tbrcmf_inform_bss(cfg);\n\t\t\taborted = status != BRCMF_E_STATUS_SUCCESS;\n\t\t\tbrcmf_notify_escan_complete(cfg, ifp, aborted, false);\n\t\t} else\n\t\t\tbrcmf_dbg(SCAN, \"Ignored scan complete result 0x%x\\n\",\n\t\t\t\t  status);\n\t}\nexit:\n\treturn 0;\n}\n\nstatic void brcmf_init_escan(struct brcmf_cfg80211_info *cfg)\n{\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ESCAN_RESULT,\n\t\t\t    brcmf_cfg80211_escan_handler);\n\tcfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\n\t/* Init scan_timeout timer */\n\tinit_timer(&cfg->escan_timeout);\n\tcfg->escan_timeout.data = (unsigned long) cfg;\n\tcfg->escan_timeout.function = brcmf_escan_timeout;\n\tINIT_WORK(&cfg->escan_timeout_work,\n\t\t  brcmf_cfg80211_escan_timeout_worker);\n}\n\nstatic struct cfg80211_scan_request *\nbrcmf_alloc_internal_escan_request(struct wiphy *wiphy, u32 n_netinfo) {\n\tstruct cfg80211_scan_request *req;\n\tsize_t req_size;\n\n\treq_size = sizeof(*req) +\n\t\t   n_netinfo * sizeof(req->channels[0]) +\n\t\t   n_netinfo * sizeof(*req->ssids);\n\n\treq = kzalloc(req_size, GFP_KERNEL);\n\tif (req) {\n\t\treq->wiphy = wiphy;\n\t\treq->ssids = (void *)(&req->channels[0]) +\n\t\t\t     n_netinfo * sizeof(req->channels[0]);\n\t}\n\treturn req;\n}\n\nstatic int brcmf_internal_escan_add_info(struct cfg80211_scan_request *req,\n\t\t\t\t\t u8 *ssid, u8 ssid_len, u8 channel)\n{\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_band band;\n\tint freq, i;\n\n\tif (channel <= CH_MAX_2G_CHANNEL)\n\t\tband = NL80211_BAND_2GHZ;\n\telse\n\t\tband = NL80211_BAND_5GHZ;\n\n\tfreq = ieee80211_channel_to_frequency(channel, band);\n\tif (!freq)\n\t\treturn -EINVAL;\n\n\tchan = ieee80211_get_channel(req->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (req->channels[i] == chan)\n\t\t\tbreak;\n\t}\n\tif (i == req->n_channels)\n\t\treq->channels[req->n_channels++] = chan;\n\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (req->ssids[i].ssid_len == ssid_len &&\n\t\t    !memcmp(req->ssids[i].ssid, ssid, ssid_len))\n\t\t\tbreak;\n\t}\n\tif (i == req->n_ssids) {\n\t\tmemcpy(req->ssids[req->n_ssids].ssid, ssid, ssid_len);\n\t\treq->ssids[req->n_ssids++].ssid_len = ssid_len;\n\t}\n\treturn 0;\n}\n\nstatic int brcmf_start_internal_escan(struct brcmf_if *ifp, u32 fwmap,\n\t\t\t\t      struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tint err;\n\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tif (cfg->int_escan_map)\n\t\t\tbrcmf_dbg(SCAN, \"aborting internal scan: map=%u\\n\",\n\t\t\t\t  cfg->int_escan_map);\n\t\t/* Abort any on-going scan */\n\t\tbrcmf_abort_scanning(cfg);\n\t}\n\n\tbrcmf_dbg(SCAN, \"start internal scan: map=%u\\n\", fwmap);\n\tset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tcfg->escan_info.run = brcmf_run_escan;\n\terr = brcmf_do_escan(ifp, request);\n\tif (err) {\n\t\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\t\treturn err;\n\t}\n\tcfg->int_escan_map = fwmap;\n\treturn 0;\n}\n\nstatic struct brcmf_pno_net_info_le *\nbrcmf_get_netinfo_array(struct brcmf_pno_scanresults_le *pfn_v1)\n{\n\tstruct brcmf_pno_scanresults_v2_le *pfn_v2;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tswitch (pfn_v1->version) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fall-thru */\n\tcase cpu_to_le32(1):\n\t\tnetinfo = (struct brcmf_pno_net_info_le *)(pfn_v1 + 1);\n\t\tbreak;\n\tcase cpu_to_le32(2):\n\t\tpfn_v2 = (struct brcmf_pno_scanresults_v2_le *)pfn_v1;\n\t\tnetinfo = (struct brcmf_pno_net_info_le *)(pfn_v2 + 1);\n\t\tbreak;\n\t}\n\n\treturn netinfo;\n}\n\n/* PFN result doesn't have all the info which are required by the supplicant\n * (For e.g IEs) Do a target Escan so that sched scan results are reported\n * via wl_inform_single_bss in the required format. Escan does require the\n * scan request in the form of cfg80211_scan_request. For timebeing, create\n * cfg80211_scan_request one out of the received PNO event.\n */\nstatic s32\nbrcmf_notify_sched_scan_results(struct brcmf_if *ifp,\n\t\t\t\tconst struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_pno_net_info_le *netinfo, *netinfo_start;\n\tstruct cfg80211_scan_request *request = NULL;\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tint i, err = 0;\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tu32 bucket_map;\n\tu32 result_count;\n\tu32 status;\n\tu32 datalen;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Do Nothing\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\tresult_count = le32_to_cpu(pfn_result->count);\n\tstatus = le32_to_cpu(pfn_result->status);\n\n\t/* PFN event is limited to fit 512 bytes so we may get\n\t * multiple NET_FOUND events. For now place a warning here.\n\t */\n\tWARN_ON(status != BRCMF_PNO_SCAN_COMPLETE);\n\tbrcmf_dbg(SCAN, \"PFN NET FOUND event. count: %d\\n\", result_count);\n\tif (!result_count) {\n\t\tbrcmf_err(\"FALSE PNO Event. (pfn_count == 0)\\n\");\n\t\tgoto out_err;\n\t}\n\n\tnetinfo_start = brcmf_get_netinfo_array(pfn_result);\n\tdatalen = e->datalen - ((void *)netinfo_start - (void *)pfn_result);\n\tif (datalen < result_count * sizeof(*netinfo)) {\n\t\tbrcmf_err(\"insufficient event data\\n\");\n\t\tgoto out_err;\n\t}\n\n\trequest = brcmf_alloc_internal_escan_request(wiphy,\n\t\t\t\t\t\t     result_count);\n\tif (!request) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tbucket_map = 0;\n\tfor (i = 0; i < result_count; i++) {\n\t\tnetinfo = &netinfo_start[i];\n\n\t\tif (netinfo->SSID_len > IEEE80211_MAX_SSID_LEN)\n\t\t\tnetinfo->SSID_len = IEEE80211_MAX_SSID_LEN;\n\t\tbrcmf_dbg(SCAN, \"SSID:%.32s Channel:%d\\n\",\n\t\t\t  netinfo->SSID, netinfo->channel);\n\t\tbucket_map |= brcmf_pno_get_bucket_map(cfg->pno, netinfo);\n\t\terr = brcmf_internal_escan_add_info(request,\n\t\t\t\t\t\t    netinfo->SSID,\n\t\t\t\t\t\t    netinfo->SSID_len,\n\t\t\t\t\t\t    netinfo->channel);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tif (!bucket_map)\n\t\tgoto free_req;\n\n\terr = brcmf_start_internal_escan(ifp, bucket_map, request);\n\tif (!err)\n\t\tgoto free_req;\n\nout_err:\n\tcfg80211_sched_scan_stopped(wiphy, 0);\nfree_req:\n\tkfree(request);\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_sched_scan_start(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *ndev,\n\t\t\t\tstruct cfg80211_sched_scan_request *req)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\n\tbrcmf_dbg(SCAN, \"Enter: n_match_sets=%d n_ssids=%d\\n\",\n\t\t  req->n_match_sets, req->n_ssids);\n\n\tif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning suppressed: status=%lu\\n\",\n\t\t\t  cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (req->n_match_sets <= 0) {\n\t\tbrcmf_dbg(SCAN, \"invalid number of matchsets specified: %d\\n\",\n\t\t\t  req->n_match_sets);\n\t\treturn -EINVAL;\n\t}\n\n\treturn brcmf_pno_start_sched_scan(ifp, req);\n}\n\nstatic int brcmf_cfg80211_sched_scan_stop(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *ndev, u64 reqid)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(SCAN, \"enter\\n\");\n\tbrcmf_pno_stop_sched_scan(ifp, reqid);\n\tif (cfg->int_escan_map)\n\t\tbrcmf_notify_escan_complete(cfg, ifp, true, true);\n\treturn 0;\n}\n\nstatic __always_inline void brcmf_delay(u32 ms)\n{\n\tif (ms < 1000 / HZ) {\n\t\tcond_resched();\n\t\tmdelay(ms);\n\t} else {\n\t\tmsleep(ms);\n\t}\n}\n\nstatic s32 brcmf_config_wowl_pattern(struct brcmf_if *ifp, u8 cmd[4],\n\t\t\t\t     u8 *pattern, u32 patternsize, u8 *mask,\n\t\t\t\t     u32 packet_offset)\n{\n\tstruct brcmf_fil_wowl_pattern_le *filter;\n\tu32 masksize;\n\tu32 patternoffset;\n\tu8 *buf;\n\tu32 bufsize;\n\ts32 ret;\n\n\tmasksize = (patternsize + 7) / 8;\n\tpatternoffset = sizeof(*filter) - sizeof(filter->cmd) + masksize;\n\n\tbufsize = sizeof(*filter) + patternsize + masksize;\n\tbuf = kzalloc(bufsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tfilter = (struct brcmf_fil_wowl_pattern_le *)buf;\n\n\tmemcpy(filter->cmd, cmd, 4);\n\tfilter->masksize = cpu_to_le32(masksize);\n\tfilter->offset = cpu_to_le32(packet_offset);\n\tfilter->patternoffset = cpu_to_le32(patternoffset);\n\tfilter->patternsize = cpu_to_le32(patternsize);\n\tfilter->type = cpu_to_le32(BRCMF_WOWL_PATTERN_TYPE_BITMAP);\n\n\tif ((mask) && (masksize))\n\t\tmemcpy(buf + sizeof(*filter), mask, masksize);\n\tif ((pattern) && (patternsize))\n\t\tmemcpy(buf + sizeof(*filter) + masksize, pattern, patternsize);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"wowl_pattern\", buf, bufsize);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic s32\nbrcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,\n\t\t      void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(pfn_result->count) < 1) {\n\t\tbrcmf_err(\"Invalid result count, expected 1 (%d)\\n\",\n\t\t\t  le32_to_cpu(pfn_result->count));\n\t\treturn -EINVAL;\n\t}\n\n\tnetinfo = brcmf_get_netinfo_array(pfn_result);\n\tmemcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len);\n\tcfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len;\n\tcfg->wowl.nd->n_channels = 1;\n\tcfg->wowl.nd->channels[0] =\n\t\tieee80211_channel_to_frequency(netinfo->channel,\n\t\t\tnetinfo->channel <= CH_MAX_2G_CHANNEL ?\n\t\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ);\n\tcfg->wowl.nd_info->n_matches = 1;\n\tcfg->wowl.nd_info->matches[0] = cfg->wowl.nd;\n\n\t/* Inform (the resume task) that the net detect information was recvd */\n\tcfg->wowl.nd_data_completed = true;\n\twake_up(&cfg->wowl.nd_data_wait);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_wowl_wakeind_le wake_ind_le;\n\tstruct cfg80211_wowlan_wakeup wakeup_data;\n\tstruct cfg80211_wowlan_wakeup *wakeup;\n\tu32 wakeind;\n\ts32 err;\n\tint timeout;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"wowl_wakeind\", &wake_ind_le,\n\t\t\t\t       sizeof(wake_ind_le));\n\tif (err) {\n\t\tbrcmf_err(\"Get wowl_wakeind failed, err = %d\\n\", err);\n\t\treturn;\n\t}\n\n\twakeind = le32_to_cpu(wake_ind_le.ucode_wakeind);\n\tif (wakeind & (BRCMF_WOWL_MAGIC | BRCMF_WOWL_DIS | BRCMF_WOWL_BCN |\n\t\t       BRCMF_WOWL_RETR | BRCMF_WOWL_NET |\n\t\t       BRCMF_WOWL_PFN_FOUND)) {\n\t\twakeup = &wakeup_data;\n\t\tmemset(&wakeup_data, 0, sizeof(wakeup_data));\n\t\twakeup_data.pattern_idx = -1;\n\n\t\tif (wakeind & BRCMF_WOWL_MAGIC) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_MAGIC\\n\");\n\t\t\twakeup_data.magic_pkt = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_DIS) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_DIS\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_BCN) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_BCN\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_RETR) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_RETR\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_NET) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_NET\\n\");\n\t\t\t/* For now always map to pattern 0, no API to get\n\t\t\t * correct information available at the moment.\n\t\t\t */\n\t\t\twakeup_data.pattern_idx = 0;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_PFN_FOUND) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_PFN_FOUND\\n\");\n\t\t\ttimeout = wait_event_timeout(cfg->wowl.nd_data_wait,\n\t\t\t\tcfg->wowl.nd_data_completed,\n\t\t\t\tBRCMF_ND_INFO_TIMEOUT);\n\t\t\tif (!timeout)\n\t\t\t\tbrcmf_err(\"No result for wowl net detect\\n\");\n\t\t\telse\n\t\t\t\twakeup_data.net_detect = cfg->wowl.nd_info;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_GTK_FAILURE) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_GTK_FAILURE\\n\");\n\t\t\twakeup_data.gtk_rekey_failure = true;\n\t\t}\n\t} else {\n\t\twakeup = NULL;\n\t}\n\tcfg80211_report_wowlan_wakeup(&ifp->vif->wdev, wakeup, GFP_KERNEL);\n}\n\n#else\n\nstatic void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n}\n\n#endif /* CONFIG_PM */\n\nstatic s32 brcmf_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (cfg->wowl.active) {\n\t\tbrcmf_report_wowl_wakeind(wiphy, ifp);\n\t\tbrcmf_fil_iovar_int_set(ifp, \"wowl_clear\", 0);\n\t\tbrcmf_config_wowl_pattern(ifp, \"clr\", NULL, 0, NULL, 0);\n\t\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM,\n\t\t\t\t      cfg->wowl.pre_pmmode);\n\t\tcfg->wowl.active = false;\n\t\tif (cfg->wowl.nd_enabled) {\n\t\t\tbrcmf_cfg80211_sched_scan_stop(cfg->wiphy, ifp->ndev, 0);\n\t\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t\t    brcmf_notify_sched_scan_results);\n\t\t\tcfg->wowl.nd_enabled = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void brcmf_configure_wowl(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t struct brcmf_if *ifp,\n\t\t\t\t struct cfg80211_wowlan *wowl)\n{\n\tu32 wowl_config;\n\tstruct brcmf_wowl_wakeind_le wowl_wakeind;\n\tu32 i;\n\n\tbrcmf_dbg(TRACE, \"Suspend, wowl config.\\n\");\n\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\tbrcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_PM, &cfg->wowl.pre_pmmode);\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, PM_MAX);\n\n\twowl_config = 0;\n\tif (wowl->disconnect)\n\t\twowl_config = BRCMF_WOWL_DIS | BRCMF_WOWL_BCN | BRCMF_WOWL_RETR;\n\tif (wowl->magic_pkt)\n\t\twowl_config |= BRCMF_WOWL_MAGIC;\n\tif ((wowl->patterns) && (wowl->n_patterns)) {\n\t\twowl_config |= BRCMF_WOWL_NET;\n\t\tfor (i = 0; i < wowl->n_patterns; i++) {\n\t\t\tbrcmf_config_wowl_pattern(ifp, \"add\",\n\t\t\t\t(u8 *)wowl->patterns[i].pattern,\n\t\t\t\twowl->patterns[i].pattern_len,\n\t\t\t\t(u8 *)wowl->patterns[i].mask,\n\t\t\t\twowl->patterns[i].pkt_offset);\n\t\t}\n\t}\n\tif (wowl->nd_config) {\n\t\tbrcmf_cfg80211_sched_scan_start(cfg->wiphy, ifp->ndev,\n\t\t\t\t\t\twowl->nd_config);\n\t\twowl_config |= BRCMF_WOWL_PFN_FOUND;\n\n\t\tcfg->wowl.nd_data_completed = false;\n\t\tcfg->wowl.nd_enabled = true;\n\t\t/* Now reroute the event for PFN to the wowl function. */\n\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t    brcmf_wowl_nd_results);\n\t}\n\tif (wowl->gtk_rekey_failure)\n\t\twowl_config |= BRCMF_WOWL_GTK_FAILURE;\n\tif (!test_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state))\n\t\twowl_config |= BRCMF_WOWL_UNASSOC;\n\n\tmemcpy(&wowl_wakeind, \"clear\", 6);\n\tbrcmf_fil_iovar_data_set(ifp, \"wowl_wakeind\", &wowl_wakeind,\n\t\t\t\t sizeof(wowl_wakeind));\n\tbrcmf_fil_iovar_int_set(ifp, \"wowl\", wowl_config);\n\tbrcmf_fil_iovar_int_set(ifp, \"wowl_activate\", 1);\n\tbrcmf_bus_wowl_config(cfg->pub->bus_if, true);\n\tcfg->wowl.active = true;\n}\n\nstatic s32 brcmf_cfg80211_suspend(struct wiphy *wiphy,\n\t\t\t\t  struct cfg80211_wowlan *wowl)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t/* if the primary net_device is not READY there is nothing\n\t * we can do but pray resume goes smoothly.\n\t */\n\tif (!check_vif_up(ifp->vif))\n\t\tgoto exit;\n\n\t/* Stop scheduled scan */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO))\n\t\tbrcmf_cfg80211_sched_scan_stop(wiphy, ndev, 0);\n\n\t/* end any scanning */\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\n\t\tbrcmf_abort_scanning(cfg);\n\n\tif (wowl == NULL) {\n\t\tbrcmf_bus_wowl_config(cfg->pub->bus_if, false);\n\t\tlist_for_each_entry(vif, &cfg->vif_list, list) {\n\t\t\tif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state))\n\t\t\t\tcontinue;\n\t\t\t/* While going to suspend if associated with AP\n\t\t\t * disassociate from AP to save power while system is\n\t\t\t * in suspended state\n\t\t\t */\n\t\t\tbrcmf_link_down(vif, WLAN_REASON_UNSPECIFIED);\n\t\t\t/* Make sure WPA_Supplicant receives all the event\n\t\t\t * generated due to DISASSOC call to the fw to keep\n\t\t\t * the state fw and WPA_Supplicant state consistent\n\t\t\t */\n\t\t\tbrcmf_delay(500);\n\t\t}\n\t\t/* Configure MPC */\n\t\tbrcmf_set_mpc(ifp, 1);\n\n\t} else {\n\t\t/* Configure WOWL paramaters */\n\t\tbrcmf_configure_wowl(cfg, ifp, wowl);\n\t}\n\nexit:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\t/* clear any scanning activity */\n\tcfg->scan_status = 0;\n\treturn 0;\n}\n\nstatic __used s32\nbrcmf_update_pmklist(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp)\n{\n\tstruct brcmf_pmk_list_le *pmk_list;\n\tint i;\n\tu32 npmk;\n\ts32 err;\n\n\tpmk_list = &cfg->pmk_list;\n\tnpmk = le32_to_cpu(pmk_list->npmk);\n\n\tbrcmf_dbg(CONN, \"No of elements %d\\n\", npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tbrcmf_dbg(CONN, \"PMK[%d]: %pM\\n\", i, &pmk_list->pmk[i].bssid);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"pmkid_info\", pmk_list,\n\t\t\t\t       sizeof(*pmk_list));\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t struct cfg80211_pmksa *pmksa)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];\n\ts32 err;\n\tu32 npmk, i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tnpmk = le32_to_cpu(cfg->pmk_list.npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tif (!memcmp(pmksa->bssid, pmk[i].bssid, ETH_ALEN))\n\t\t\tbreak;\n\tif (i < BRCMF_MAXPMKID) {\n\t\tmemcpy(pmk[i].bssid, pmksa->bssid, ETH_ALEN);\n\t\tmemcpy(pmk[i].pmkid, pmksa->pmkid, WLAN_PMKID_LEN);\n\t\tif (i == npmk) {\n\t\t\tnpmk++;\n\t\t\tcfg->pmk_list.npmk = cpu_to_le32(npmk);\n\t\t}\n\t} else {\n\t\tbrcmf_err(\"Too many PMKSA entries cached %d\\n\", npmk);\n\t\treturn -EINVAL;\n\t}\n\n\tbrcmf_dbg(CONN, \"set_pmksa - PMK bssid: %pM =\\n\", pmk[npmk].bssid);\n\tfor (i = 0; i < WLAN_PMKID_LEN; i += 4)\n\t\tbrcmf_dbg(CONN, \"%02x %02x %02x %02x\\n\", pmk[npmk].pmkid[i],\n\t\t\t  pmk[npmk].pmkid[i + 1], pmk[npmk].pmkid[i + 2],\n\t\t\t  pmk[npmk].pmkid[i + 3]);\n\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t struct cfg80211_pmksa *pmksa)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];\n\ts32 err;\n\tu32 npmk, i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tbrcmf_dbg(CONN, \"del_pmksa - PMK bssid = %pM\\n\", pmksa->bssid);\n\n\tnpmk = le32_to_cpu(cfg->pmk_list.npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tif (!memcmp(pmksa->bssid, pmk[i].bssid, ETH_ALEN))\n\t\t\tbreak;\n\n\tif ((npmk > 0) && (i < npmk)) {\n\t\tfor (; i < (npmk - 1); i++) {\n\t\t\tmemcpy(&pmk[i].bssid, &pmk[i + 1].bssid, ETH_ALEN);\n\t\t\tmemcpy(&pmk[i].pmkid, &pmk[i + 1].pmkid,\n\t\t\t       WLAN_PMKID_LEN);\n\t\t}\n\t\tmemset(&pmk[i], 0, sizeof(*pmk));\n\t\tcfg->pmk_list.npmk = cpu_to_le32(npmk - 1);\n\t} else {\n\t\tbrcmf_err(\"Cache entry not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n\n}\n\nstatic s32\nbrcmf_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemset(&cfg->pmk_list, 0, sizeof(cfg->pmk_list));\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n\n}\n\nstatic s32 brcmf_configure_opensecurity(struct brcmf_if *ifp)\n{\n\ts32 err;\n\n\t/* set auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", 0);\n\tif (err < 0) {\n\t\tbrcmf_err(\"auth error %d\\n\", err);\n\t\treturn err;\n\t}\n\t/* set wsec */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", 0);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wsec error %d\\n\", err);\n\t\treturn err;\n\t}\n\t/* set upper-layer auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wpa_auth\", WPA_AUTH_NONE);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wpa_auth error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie)\n{\n\tif (is_rsn_ie)\n\t\treturn (memcmp(oui, RSN_OUI, TLV_OUI_LEN) == 0);\n\n\treturn (memcmp(oui, WPA_OUI, TLV_OUI_LEN) == 0);\n}\n\nstatic s32\nbrcmf_configure_wpaie(struct brcmf_if *ifp,\n\t\t      const struct brcmf_vs_tlv *wpa_ie,\n\t\t      bool is_rsn_ie)\n{\n\tu32 auth = 0; /* d11 open authentication */\n\tu16 count;\n\ts32 err = 0;\n\ts32 len;\n\tu32 i;\n\tu32 wsec;\n\tu32 pval = 0;\n\tu32 gval = 0;\n\tu32 wpa_auth = 0;\n\tu32 offset;\n\tu8 *data;\n\tu16 rsn_cap;\n\tu32 wme_bss_disable;\n\tu32 mfp;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (wpa_ie == NULL)\n\t\tgoto exit;\n\n\tlen = wpa_ie->len + TLV_HDR_LEN;\n\tdata = (u8 *)wpa_ie;\n\toffset = TLV_HDR_LEN;\n\tif (!is_rsn_ie)\n\t\toffset += VS_IE_FIXED_HDR_LEN;\n\telse\n\t\toffset += WPA_IE_VERSION_LEN;\n\n\t/* check for multicast cipher suite */\n\tif (offset + WPA_IE_MIN_OUI_LEN > len) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"no multicast cipher suite\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"ivalid OUI\\n\");\n\t\tgoto exit;\n\t}\n\toffset += TLV_OUI_LEN;\n\n\t/* pick up multicast cipher */\n\tswitch (data[offset]) {\n\tcase WPA_CIPHER_NONE:\n\t\tgval = 0;\n\t\tbreak;\n\tcase WPA_CIPHER_WEP_40:\n\tcase WPA_CIPHER_WEP_104:\n\t\tgval = WEP_ENABLED;\n\t\tbreak;\n\tcase WPA_CIPHER_TKIP:\n\t\tgval = TKIP_ENABLED;\n\t\tbreak;\n\tcase WPA_CIPHER_AES_CCM:\n\t\tgval = AES_ENABLED;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"Invalid multi cast cipher info\\n\");\n\t\tgoto exit;\n\t}\n\n\toffset++;\n\t/* walk thru unicast cipher list and pick up what we recognize */\n\tcount = data[offset] + (data[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN;\n\t/* Check for unicast suite(s) */\n\tif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"no unicast cipher suite\\n\");\n\t\tgoto exit;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\t\terr = -EINVAL;\n\t\t\tbrcmf_err(\"ivalid OUI\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\toffset += TLV_OUI_LEN;\n\t\tswitch (data[offset]) {\n\t\tcase WPA_CIPHER_NONE:\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP_40:\n\t\tcase WPA_CIPHER_WEP_104:\n\t\t\tpval |= WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_TKIP:\n\t\t\tpval |= TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_AES_CCM:\n\t\t\tpval |= AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"Invalid unicast security info\\n\");\n\t\t}\n\t\toffset++;\n\t}\n\t/* walk thru auth management suite list and pick up what we recognize */\n\tcount = data[offset] + (data[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN;\n\t/* Check for auth key management suite(s) */\n\tif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"no auth key mgmt suite\\n\");\n\t\tgoto exit;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\t\terr = -EINVAL;\n\t\t\tbrcmf_err(\"ivalid OUI\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\toffset += TLV_OUI_LEN;\n\t\tswitch (data[offset]) {\n\t\tcase RSN_AKM_NONE:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_NONE\\n\");\n\t\t\twpa_auth |= WPA_AUTH_NONE;\n\t\t\tbreak;\n\t\tcase RSN_AKM_UNSPECIFIED:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_UNSPECIFIED\\n\");\n\t\t\tis_rsn_ie ? (wpa_auth |= WPA2_AUTH_UNSPECIFIED) :\n\t\t\t\t    (wpa_auth |= WPA_AUTH_UNSPECIFIED);\n\t\t\tbreak;\n\t\tcase RSN_AKM_PSK:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_PSK\\n\");\n\t\t\tis_rsn_ie ? (wpa_auth |= WPA2_AUTH_PSK) :\n\t\t\t\t    (wpa_auth |= WPA_AUTH_PSK);\n\t\t\tbreak;\n\t\tcase RSN_AKM_SHA256_PSK:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_MFP_PSK\\n\");\n\t\t\twpa_auth |= WPA2_AUTH_PSK_SHA256;\n\t\t\tbreak;\n\t\tcase RSN_AKM_SHA256_1X:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_MFP_1X\\n\");\n\t\t\twpa_auth |= WPA2_AUTH_1X_SHA256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"Invalid key mgmt info\\n\");\n\t\t}\n\t\toffset++;\n\t}\n\n\tmfp = BRCMF_MFP_NONE;\n\tif (is_rsn_ie) {\n\t\twme_bss_disable = 1;\n\t\tif ((offset + RSN_CAP_LEN) <= len) {\n\t\t\trsn_cap = data[offset] + (data[offset + 1] << 8);\n\t\t\tif (rsn_cap & RSN_CAP_PTK_REPLAY_CNTR_MASK)\n\t\t\t\twme_bss_disable = 0;\n\t\t\tif (rsn_cap & RSN_CAP_MFPR_MASK) {\n\t\t\t\tbrcmf_dbg(TRACE, \"MFP Required\\n\");\n\t\t\t\tmfp = BRCMF_MFP_REQUIRED;\n\t\t\t\t/* Firmware only supports mfp required in\n\t\t\t\t * combination with WPA2_AUTH_PSK_SHA256 or\n\t\t\t\t * WPA2_AUTH_1X_SHA256.\n\t\t\t\t */\n\t\t\t\tif (!(wpa_auth & (WPA2_AUTH_PSK_SHA256 |\n\t\t\t\t\t\t  WPA2_AUTH_1X_SHA256))) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\t/* Firmware has requirement that WPA2_AUTH_PSK/\n\t\t\t\t * WPA2_AUTH_UNSPECIFIED be set, if SHA256 OUI\n\t\t\t\t * is to be included in the rsn ie.\n\t\t\t\t */\n\t\t\t\tif (wpa_auth & WPA2_AUTH_PSK_SHA256)\n\t\t\t\t\twpa_auth |= WPA2_AUTH_PSK;\n\t\t\t\telse if (wpa_auth & WPA2_AUTH_1X_SHA256)\n\t\t\t\t\twpa_auth |= WPA2_AUTH_UNSPECIFIED;\n\t\t\t} else if (rsn_cap & RSN_CAP_MFPC_MASK) {\n\t\t\t\tbrcmf_dbg(TRACE, \"MFP Capable\\n\");\n\t\t\t\tmfp = BRCMF_MFP_CAPABLE;\n\t\t\t}\n\t\t}\n\t\toffset += RSN_CAP_LEN;\n\t\t/* set wme_bss_disable to sync RSN Capabilities */\n\t\terr = brcmf_fil_bsscfg_int_set(ifp, \"wme_bss_disable\",\n\t\t\t\t\t       wme_bss_disable);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"wme_bss_disable error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Skip PMKID cnt as it is know to be 0 for AP. */\n\t\toffset += RSN_PMKID_COUNT_LEN;\n\n\t\t/* See if there is BIP wpa suite left for MFP */\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP) &&\n\t\t    ((offset + WPA_IE_MIN_OUI_LEN) <= len)) {\n\t\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"bip\",\n\t\t\t\t\t\t\t&data[offset],\n\t\t\t\t\t\t\tWPA_IE_MIN_OUI_LEN);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"bip error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\t/* FOR WPS , set SES_OW_ENABLED */\n\twsec = (pval | gval | SES_OW_ENABLED);\n\n\t/* set auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", auth);\n\tif (err < 0) {\n\t\tbrcmf_err(\"auth error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\t/* set wsec */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wsec error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\t/* Configure MFP, this needs to go after wsec otherwise the wsec command\n\t * will overwrite the values set by MFP\n\t */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP)) {\n\t\terr = brcmf_fil_bsscfg_int_set(ifp, \"mfp\", mfp);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"mfp error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\t/* set upper-layer auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wpa_auth\", wpa_auth);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wpa_auth error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn err;\n}\n\nstatic s32\nbrcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32 vndr_ie_len,\n\t\t     struct parsed_vndr_ies *vndr_ies)\n{\n\tstruct brcmf_vs_tlv *vndrie;\n\tstruct brcmf_tlv *ie;\n\tstruct parsed_vndr_ie_info *parsed_info;\n\ts32 remaining_len;\n\n\tremaining_len = (s32)vndr_ie_len;\n\tmemset(vndr_ies, 0, sizeof(*vndr_ies));\n\n\tie = (struct brcmf_tlv *)vndr_ie_buf;\n\twhile (ie) {\n\t\tif (ie->id != WLAN_EID_VENDOR_SPECIFIC)\n\t\t\tgoto next;\n\t\tvndrie = (struct brcmf_vs_tlv *)ie;\n\t\t/* len should be bigger than OUI length + one */\n\t\tif (vndrie->len < (VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1)) {\n\t\t\tbrcmf_err(\"invalid vndr ie. length is too small %d\\n\",\n\t\t\t\t  vndrie->len);\n\t\t\tgoto next;\n\t\t}\n\t\t/* if wpa or wme ie, do not add ie */\n\t\tif (!memcmp(vndrie->oui, (u8 *)WPA_OUI, TLV_OUI_LEN) &&\n\t\t    ((vndrie->oui_type == WPA_OUI_TYPE) ||\n\t\t    (vndrie->oui_type == WME_OUI_TYPE))) {\n\t\t\tbrcmf_dbg(TRACE, \"Found WPA/WME oui. Do not add it\\n\");\n\t\t\tgoto next;\n\t\t}\n\n\t\tparsed_info = &vndr_ies->ie_info[vndr_ies->count];\n\n\t\t/* save vndr ie information */\n\t\tparsed_info->ie_ptr = (char *)vndrie;\n\t\tparsed_info->ie_len = vndrie->len + TLV_HDR_LEN;\n\t\tmemcpy(&parsed_info->vndrie, vndrie, sizeof(*vndrie));\n\n\t\tvndr_ies->count++;\n\n\t\tbrcmf_dbg(TRACE, \"** OUI %02x %02x %02x, type 0x%02x\\n\",\n\t\t\t  parsed_info->vndrie.oui[0],\n\t\t\t  parsed_info->vndrie.oui[1],\n\t\t\t  parsed_info->vndrie.oui[2],\n\t\t\t  parsed_info->vndrie.oui_type);\n\n\t\tif (vndr_ies->count >= VNDR_IE_PARSE_LIMIT)\n\t\t\tbreak;\nnext:\n\t\tremaining_len -= (ie->len + TLV_HDR_LEN);\n\t\tif (remaining_len <= TLV_HDR_LEN)\n\t\t\tie = NULL;\n\t\telse\n\t\t\tie = (struct brcmf_tlv *)(((u8 *)ie) + ie->len +\n\t\t\t\tTLV_HDR_LEN);\n\t}\n\treturn 0;\n}\n\nstatic u32\nbrcmf_vndr_ie(u8 *iebuf, s32 pktflag, u8 *ie_ptr, u32 ie_len, s8 *add_del_cmd)\n{\n\n\tstrncpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN - 1);\n\tiebuf[VNDR_IE_CMD_LEN - 1] = '\\0';\n\n\tput_unaligned_le32(1, &iebuf[VNDR_IE_COUNT_OFFSET]);\n\n\tput_unaligned_le32(pktflag, &iebuf[VNDR_IE_PKTFLAG_OFFSET]);\n\n\tmemcpy(&iebuf[VNDR_IE_VSIE_OFFSET], ie_ptr, ie_len);\n\n\treturn ie_len + VNDR_IE_HDR_SIZE;\n}\n\ns32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,\n\t\t\t  const u8 *vndr_ie_buf, u32 vndr_ie_len)\n{\n\tstruct brcmf_if *ifp;\n\tstruct vif_saved_ie *saved_ie;\n\ts32 err = 0;\n\tu8  *iovar_ie_buf;\n\tu8  *curr_ie_buf;\n\tu8  *mgmt_ie_buf = NULL;\n\tint mgmt_ie_buf_len;\n\tu32 *mgmt_ie_len;\n\tu32 del_add_ie_buf_len = 0;\n\tu32 total_ie_buf_len = 0;\n\tu32 parsed_ie_buf_len = 0;\n\tstruct parsed_vndr_ies old_vndr_ies;\n\tstruct parsed_vndr_ies new_vndr_ies;\n\tstruct parsed_vndr_ie_info *vndrie_info;\n\ts32 i;\n\tu8 *ptr;\n\tint remained_buf_len;\n\n\tif (!vif)\n\t\treturn -ENODEV;\n\tifp = vif->ifp;\n\tsaved_ie = &vif->saved_ie;\n\n\tbrcmf_dbg(TRACE, \"bsscfgidx %d, pktflag : 0x%02X\\n\", ifp->bsscfgidx,\n\t\t  pktflag);\n\tiovar_ie_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!iovar_ie_buf)\n\t\treturn -ENOMEM;\n\tcurr_ie_buf = iovar_ie_buf;\n\tswitch (pktflag) {\n\tcase BRCMF_VNDR_IE_PRBREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_req_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_req_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_PRBRSP_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_res_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_res_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_res_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_BEACON_FLAG:\n\t\tmgmt_ie_buf = saved_ie->beacon_ie;\n\t\tmgmt_ie_len = &saved_ie->beacon_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->beacon_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_ASSOCREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->assoc_req_ie;\n\t\tmgmt_ie_len = &saved_ie->assoc_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);\n\t\tbreak;\n\tdefault:\n\t\terr = -EPERM;\n\t\tbrcmf_err(\"not suitable type\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (vndr_ie_len > mgmt_ie_buf_len) {\n\t\terr = -ENOMEM;\n\t\tbrcmf_err(\"extra IE size too big\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* parse and save new vndr_ie in curr_ie_buff before comparing it */\n\tif (vndr_ie_buf && vndr_ie_len && curr_ie_buf) {\n\t\tptr = curr_ie_buf;\n\t\tbrcmf_parse_vndr_ies(vndr_ie_buf, vndr_ie_len, &new_vndr_ies);\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\t\t\tmemcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\tparsed_ie_buf_len += vndrie_info->ie_len;\n\t\t}\n\t}\n\n\tif (mgmt_ie_buf && *mgmt_ie_len) {\n\t\tif (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len) &&\n\t\t    (memcmp(mgmt_ie_buf, curr_ie_buf,\n\t\t\t    parsed_ie_buf_len) == 0)) {\n\t\t\tbrcmf_dbg(TRACE, \"Previous mgmt IE equals to current IE\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* parse old vndr_ie */\n\t\tbrcmf_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len, &old_vndr_ies);\n\n\t\t/* make a command to delete old ie */\n\t\tfor (i = 0; i < old_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &old_vndr_ies.ie_info[i];\n\n\t\t\tbrcmf_dbg(TRACE, \"DEL ID : %d, Len: %d , OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"del\");\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\n\t*mgmt_ie_len = 0;\n\t/* Add if there is any extra IE */\n\tif (mgmt_ie_buf && parsed_ie_buf_len) {\n\t\tptr = mgmt_ie_buf;\n\n\t\tremained_buf_len = mgmt_ie_buf_len;\n\n\t\t/* make a command to add new ie */\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\n\t\t\t/* verify remained buf size before copy data */\n\t\t\tif (remained_buf_len < (vndrie_info->vndrie.len +\n\t\t\t\t\t\t\tVNDR_IE_VSIE_OFFSET)) {\n\t\t\t\tbrcmf_err(\"no space in mgmt_ie_buf: len left %d\",\n\t\t\t\t\t  remained_buf_len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tremained_buf_len -= (vndrie_info->ie_len +\n\t\t\t\t\t     VNDR_IE_VSIE_OFFSET);\n\n\t\t\tbrcmf_dbg(TRACE, \"ADDED ID : %d, Len: %d, OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"add\");\n\n\t\t\t/* save the parsed IE in wl struct */\n\t\t\tmemcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\t*mgmt_ie_len += vndrie_info->ie_len;\n\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\tif (total_ie_buf_len) {\n\t\terr  = brcmf_fil_bsscfg_data_set(ifp, \"vndr_ie\", iovar_ie_buf,\n\t\t\t\t\t\t total_ie_buf_len);\n\t\tif (err)\n\t\t\tbrcmf_err(\"vndr ie set error : %d\\n\", err);\n\t}\n\nexit:\n\tkfree(iovar_ie_buf);\n\treturn err;\n}\n\ns32 brcmf_vif_clear_mgmt_ies(struct brcmf_cfg80211_vif *vif)\n{\n\ts32 pktflags[] = {\n\t\tBRCMF_VNDR_IE_PRBREQ_FLAG,\n\t\tBRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\tBRCMF_VNDR_IE_BEACON_FLAG\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pktflags); i++)\n\t\tbrcmf_vif_set_mgmt_ie(vif, pktflags[i], NULL, 0);\n\n\tmemset(&vif->saved_ie, 0, sizeof(vif->saved_ie));\n\treturn 0;\n}\n\nstatic s32\nbrcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,\n\t\t\tstruct cfg80211_beacon_data *beacon)\n{\n\ts32 err;\n\n\t/* Set Beacon IEs to FW */\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_BEACON_FLAG,\n\t\t\t\t    beacon->tail, beacon->tail_len);\n\tif (err) {\n\t\tbrcmf_err(\"Set Beacon IE Failed\\n\");\n\t\treturn err;\n\t}\n\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Beacon\\n\");\n\n\t/* Set Probe Response IEs to FW */\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t    beacon->proberesp_ies,\n\t\t\t\t    beacon->proberesp_ies_len);\n\tif (err)\n\t\tbrcmf_err(\"Set Probe Resp IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Probe Resp\\n\");\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\tstruct cfg80211_ap_settings *settings)\n{\n\ts32 ie_offset;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tconst struct brcmf_tlv *ssid_ie;\n\tconst struct brcmf_tlv *country_ie;\n\tstruct brcmf_ssid_le ssid_le;\n\ts32 err = -EPERM;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tstruct brcmf_join_params join_params;\n\tenum nl80211_iftype dev_role;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tu16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef);\n\tbool mbss;\n\tint is_11d;\n\tbool supports_11d;\n\n\tbrcmf_dbg(TRACE, \"ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\\n\",\n\t\t  settings->chandef.chan->hw_value,\n\t\t  settings->chandef.center_freq1, settings->chandef.width,\n\t\t  settings->beacon_interval, settings->dtim_period);\n\tbrcmf_dbg(TRACE, \"ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\\n\",\n\t\t  settings->ssid, settings->ssid_len, settings->auth_type,\n\t\t  settings->inactivity_timeout);\n\tdev_role = ifp->vif->wdev.iftype;\n\tmbss = ifp->vif->mbss;\n\n\t/* store current 11d setting */\n\tif (brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY,\n\t\t\t\t  &ifp->vif->is_11d)) {\n\t\tis_11d = supports_11d = false;\n\t} else {\n\t\tcountry_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t\t      settings->beacon.tail_len,\n\t\t\t\t\t      WLAN_EID_COUNTRY);\n\t\tis_11d = country_ie ? 1 : 0;\n\t\tsupports_11d = true;\n\t}\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n\n\tif (!mbss) {\n\t\tbrcmf_set_mpc(ifp, 0);\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\t}\n\n\t/* find the RSN_IE */\n\trsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len, WLAN_EID_RSN);\n\n\t/* find the WPA_IE */\n\twpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len);\n\n\tif ((wpa_ie != NULL || rsn_ie != NULL)) {\n\t\tbrcmf_dbg(TRACE, \"WPA(2) IE is found\\n\");\n\t\tif (wpa_ie != NULL) {\n\t\t\t/* WPA IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, wpa_ie, false);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tstruct brcmf_vs_tlv *tmp_ie;\n\n\t\t\ttmp_ie = (struct brcmf_vs_tlv *)rsn_ie;\n\n\t\t\t/* RSN IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, tmp_ie, true);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"No WPA(2) IEs found\\n\");\n\t\tbrcmf_configure_opensecurity(ifp);\n\t}\n\n\t/* Parameters shared by all radio interfaces */\n\tif (!mbss) {\n\t\tif ((supports_11d) && (is_11d != ifp->vif->is_11d)) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t\t\t    is_11d);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Regulatory Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->beacon_interval) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,\n\t\t\t\t\t\t    settings->beacon_interval);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Beacon Interval Set Error, %d\\n\",\n\t\t\t\t\t  err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->dtim_period) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,\n\t\t\t\t\t\t    settings->dtim_period);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"DTIM Interval Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif ((dev_role == NL80211_IFTYPE_AP) &&\n\t\t    ((ifp->ifidx == 0) ||\n\t\t     !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"BRCMF_C_DOWN error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"apsta\", 0);\n\t\t}\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET INFRA error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (WARN_ON(supports_11d && (is_11d != ifp->vif->is_11d))) {\n\t\t/* Multiple-BSS should use same 11d configuration */\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Interface specific setup */\n\tif (dev_role == NL80211_IFTYPE_AP) {\n\t\tif ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 1);\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting AP mode failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!mbss) {\n\t\t\t/* Firmware 10.x requires setting channel after enabling\n\t\t\t * AP and before bringing interface up.\n\t\t\t */\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t\t  chanspec, err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"BRCMF_C_UP error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\t/* On DOWN the firmware removes the WEP keys, reconfigure\n\t\t * them if they were set.\n\t\t */\n\t\tbrcmf_cfg80211_reconfigure_wep(ifp);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\t/* join parameters starts with ssid */\n\t\tmemcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le));\n\t\t/* create softap */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET SSID error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (settings->hidden_ssid) {\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"closednet\", 1);\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"closednet error (%d)\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"AP mode configuration complete\\n\");\n\t} else if (dev_role == NL80211_IFTYPE_P2P_GO) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t  chanspec, err);\n\t\t\tgoto exit;\n\t\t}\n\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"ssid\", &ssid_le,\n\t\t\t\t\t\tsizeof(ssid_le));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting ssid failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(1);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"bss_enable config failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"GO mode configuration complete\\n\");\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\tbrcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);\n\tset_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, true);\n\nexit:\n\tif ((err) && (!mbss)) {\n\t\tbrcmf_set_mpc(ifp, 1);\n\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t}\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tstruct brcmf_join_params join_params;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {\n\t\t/* Due to most likely deauths outstanding we sleep */\n\t\t/* first to make sure they get processed by fw. */\n\t\tmsleep(400);\n\n\t\tif (ifp->vif->mbss) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\treturn err;\n\t\t}\n\n\t\t/* First BSS doesn't get a full reset */\n\t\tif (ifp->bsscfgidx == 0)\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"closednet\", 0);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"SET SSID error (%d)\\n\", err);\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"BRCMF_C_DOWN error %d\\n\", err);\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"setting AP mode failed %d\\n\", err);\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 0);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t      ifp->vif->is_11d);\n\t\t/* Bring device back up so it can be used again */\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"BRCMF_C_UP error %d\\n\", err);\n\n\t\tbrcmf_vif_clear_mgmt_ies(ifp->vif);\n\t} else {\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(0);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"bss_enable config failed %d\\n\", err);\n\t}\n\tbrcmf_set_mpc(ifp, 1);\n\tbrcmf_configure_arp_nd_offload(ifp, true);\n\tclear_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, false);\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t     struct cfg80211_beacon_data *info)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\terr = brcmf_config_ap_mgmt_ie(ifp->vif, info);\n\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_del_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   struct station_del_parameters *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tif (!params->mac)\n\t\treturn -EFAULT;\n\n\tbrcmf_dbg(TRACE, \"Enter %pM\\n\", params->mac);\n\n\tif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\tifp = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemcpy(&scbval.ea, params->mac, ETH_ALEN);\n\tscbval.val = cpu_to_le32(params->reason_code);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCB_DEAUTHENTICATE_FOR_REASON,\n\t\t\t\t     &scbval, sizeof(scbval));\n\tif (err)\n\t\tbrcmf_err(\"SCB_DEAUTHENTICATE_FOR_REASON failed %d\\n\", err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_change_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t      const u8 *mac, struct station_parameters *params)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, MAC %pM, mask 0x%04x set 0x%04x\\n\", mac,\n\t\t  params->sta_flags_mask, params->sta_flags_set);\n\n\t/* Ignore all 00 MAC */\n\tif (is_zero_ether_addr(mac))\n\t\treturn 0;\n\n\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\treturn 0;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_AUTHORIZE,\n\t\t\t\t\t     (void *)mac, ETH_ALEN);\n\telse\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_DEAUTHORIZE,\n\t\t\t\t\t     (void *)mac, ETH_ALEN);\n\tif (err < 0)\n\t\tbrcmf_err(\"Setting SCB (de-)authorize failed, %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void\nbrcmf_cfg80211_mgmt_frame_register(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t   u16 frame_type, bool reg)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tu16 mgmt_type;\n\n\tbrcmf_dbg(TRACE, \"Enter, frame_type %04x, reg=%d\\n\", frame_type, reg);\n\n\tmgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tif (reg)\n\t\tvif->mgmt_rx_reg |= BIT(mgmt_type);\n\telse\n\t\tvif->mgmt_rx_reg &= ~BIT(mgmt_type);\n}\n\n\nstatic int\nbrcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t       struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct ieee80211_channel *chan = params->chan;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\ts32 ie_offset;\n\ts32 ie_len;\n\tstruct brcmf_fil_action_frame_le *action_frame;\n\tstruct brcmf_fil_af_params_le *af_params;\n\tbool ack;\n\ts32 chan_nr;\n\tu32 freq;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t*cookie = 0;\n\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control)) {\n\t\tbrcmf_err(\"Driver only allows MGMT packet type\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\t/* Right now the only reason to get a probe response */\n\t\t/* is for p2p listen response or for p2p GO from     */\n\t\t/* wpa_supplicant. Unfortunately the probe is send   */\n\t\t/* on primary ndev, while dongle wants it on the p2p */\n\t\t/* vif. Since this is only reason for a probe        */\n\t\t/* response to be sent, the vif is taken from cfg.   */\n\t\t/* If ever desired to send proberesp for non p2p     */\n\t\t/* response then data should be checked for          */\n\t\t/* \"DIRECT-\". Note in future supplicant will take    */\n\t\t/* dedicated p2p wdev to do this and then this 'hack'*/\n\t\t/* is not needed anymore.                            */\n\t\tie_offset =  DOT11_MGMT_HDR_LEN +\n\t\t\t     DOT11_BCN_PRB_FIXED_LEN;\n\t\tie_len = len - ie_offset;\n\t\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)\n\t\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\t\terr = brcmf_vif_set_mgmt_ie(vif,\n\t\t\t\t\t    BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t\t    &buf[ie_offset],\n\t\t\t\t\t    ie_len);\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,\n\t\t\t\t\tGFP_KERNEL);\n\t} else if (ieee80211_is_action(mgmt->frame_control)) {\n\t\taf_params = kzalloc(sizeof(*af_params), GFP_KERNEL);\n\t\tif (af_params == NULL) {\n\t\t\tbrcmf_err(\"unable to allocate frame\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\taction_frame = &af_params->action_frame;\n\t\t/* Add the packet Id */\n\t\taction_frame->packet_id = cpu_to_le32(*cookie);\n\t\t/* Add BSSID */\n\t\tmemcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);\n\t\tmemcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);\n\t\t/* Add the length exepted for 802.11 header  */\n\t\taction_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);\n\t\t/* Add the channel. Use the one specified as parameter if any or\n\t\t * the current one (got from the firmware) otherwise\n\t\t */\n\t\tif (chan)\n\t\t\tfreq = chan->center_freq;\n\t\telse\n\t\t\tbrcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,\n\t\t\t\t\t      &freq);\n\t\tchan_nr = ieee80211_frequency_to_channel(freq);\n\t\taf_params->channel = cpu_to_le32(chan_nr);\n\n\t\tmemcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],\n\t\t       le16_to_cpu(action_frame->len));\n\n\t\tbrcmf_dbg(TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\",\n\t\t\t  *cookie, le16_to_cpu(action_frame->len), freq);\n\n\t\tack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),\n\t\t\t\t\t\t  af_params);\n\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,\n\t\t\t\t\tGFP_KERNEL);\n\t\tkfree(af_params);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control);\n\t\tbrcmf_dbg_hex_dump(true, buf, len, \"payload, len=%zu\\n\", len);\n\t}\n\nexit:\n\treturn err;\n}\n\n\nstatic int\nbrcmf_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\t\tu64 cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\tint err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter p2p listen cancel\\n\");\n\n\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\tif (vif == NULL) {\n\t\tbrcmf_err(\"No p2p device available for probe response\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\tbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\nexit:\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_get_channel(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\tstruct brcmf_if *ifp;\n\tstruct brcmu_chan ch;\n\tenum nl80211_band band = 0;\n\tenum nl80211_chan_width width = 0;\n\tu32 chanspec;\n\tint freq, err;\n\n\tif (!ndev)\n\t\treturn -ENODEV;\n\tifp = netdev_priv(ndev);\n\n\terr = brcmf_fil_iovar_int_get(ifp, \"chanspec\", &chanspec);\n\tif (err) {\n\t\tbrcmf_err(\"chanspec failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tch.chspec = chanspec;\n\tcfg->d11inf.decchspec(&ch);\n\n\tswitch (ch.band) {\n\tcase BRCMU_CHAN_BAND_2G:\n\t\tband = NL80211_BAND_2GHZ;\n\t\tbreak;\n\tcase BRCMU_CHAN_BAND_5G:\n\t\tband = NL80211_BAND_5GHZ;\n\t\tbreak;\n\t}\n\n\tswitch (ch.bw) {\n\tcase BRCMU_CHAN_BW_80:\n\t\twidth = NL80211_CHAN_WIDTH_80;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_40:\n\t\twidth = NL80211_CHAN_WIDTH_40;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_20:\n\t\twidth = NL80211_CHAN_WIDTH_20;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_80P80:\n\t\twidth = NL80211_CHAN_WIDTH_80P80;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_160:\n\t\twidth = NL80211_CHAN_WIDTH_160;\n\t\tbreak;\n\t}\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band);\n\tchandef->chan = ieee80211_get_channel(wiphy, freq);\n\tchandef->width = width;\n\tchandef->center_freq1 = ieee80211_channel_to_frequency(ch.chnum, band);\n\tchandef->center_freq2 = 0;\n\n\treturn 0;\n}\n\nstatic int brcmf_cfg80211_crit_proto_start(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_crit_proto_id proto,\n\t\t\t\t\t   u16 duration)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\t/* only DHCP support for now */\n\tif (proto != NL80211_CRIT_PROTO_DHCP)\n\t\treturn -EINVAL;\n\n\t/* suppress and abort scanning */\n\tset_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n\tbrcmf_abort_scanning(cfg);\n\n\treturn brcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_DISABLED, duration);\n}\n\nstatic void brcmf_cfg80211_crit_proto_stop(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\n\tclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n}\n\nstatic s32\nbrcmf_notify_tdls_peer_event(struct brcmf_if *ifp,\n\t\t\t     const struct brcmf_event_msg *e, void *data)\n{\n\tswitch (e->reason) {\n\tcase BRCMF_E_REASON_TDLS_PEER_DISCOVERED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Discovered\\n\");\n\t\tbreak;\n\tcase BRCMF_E_REASON_TDLS_PEER_CONNECTED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Connected\\n\");\n\t\tbrcmf_proto_add_tdls_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t\tbreak;\n\tcase BRCMF_E_REASON_TDLS_PEER_DISCONNECTED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Disconnected\\n\");\n\t\tbrcmf_proto_delete_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmf_convert_nl80211_tdls_oper(enum nl80211_tdls_operation oper)\n{\n\tint ret;\n\n\tswitch (oper) {\n\tcase NL80211_TDLS_DISCOVERY_REQ:\n\t\tret = BRCMF_TDLS_MANUAL_EP_DISCOVERY;\n\t\tbreak;\n\tcase NL80211_TDLS_SETUP:\n\t\tret = BRCMF_TDLS_MANUAL_EP_CREATE;\n\t\tbreak;\n\tcase NL80211_TDLS_TEARDOWN:\n\t\tret = BRCMF_TDLS_MANUAL_EP_DELETE;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"unsupported operation: %d\\n\", oper);\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nstatic int brcmf_cfg80211_tdls_oper(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *ndev, const u8 *peer,\n\t\t\t\t    enum nl80211_tdls_operation oper)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_tdls_iovar_le info;\n\tint ret = 0;\n\n\tret = brcmf_convert_nl80211_tdls_oper(oper);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tifp = netdev_priv(ndev);\n\tmemset(&info, 0, sizeof(info));\n\tinfo.mode = (u8)ret;\n\tif (peer)\n\t\tmemcpy(info.ea, peer, ETH_ALEN);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"tdls_endpoint\",\n\t\t\t\t       &info, sizeof(info));\n\tif (ret < 0)\n\t\tbrcmf_err(\"tdls_endpoint iovar failed: ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int\nbrcmf_cfg80211_update_conn_params(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *ndev,\n\t\t\t\t  struct cfg80211_connect_params *sme,\n\t\t\t\t  u32 changed)\n{\n\tstruct brcmf_if *ifp;\n\tint err;\n\n\tif (!(changed & UPDATE_ASSOC_IES))\n\t\treturn 0;\n\n\tifp = netdev_priv(ndev);\n\terr = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,\n\t\t\t\t    sme->ie, sme->ie_len);\n\tif (err)\n\t\tbrcmf_err(\"Set Assoc REQ IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Assoc request\\n\");\n\n\treturn err;\n}\n\n#ifdef CONFIG_PM\nstatic int\nbrcmf_cfg80211_set_rekey_data(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t      struct cfg80211_gtk_rekey_data *gtk)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_gtk_keyinfo_le gtk_le;\n\tint ret;\n\n\tbrcmf_dbg(TRACE, \"Enter, bssidx=%d\\n\", ifp->bsscfgidx);\n\n\tmemcpy(gtk_le.kck, gtk->kck, sizeof(gtk_le.kck));\n\tmemcpy(gtk_le.kek, gtk->kek, sizeof(gtk_le.kek));\n\tmemcpy(gtk_le.replay_counter, gtk->replay_ctr,\n\t       sizeof(gtk_le.replay_counter));\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"gtk_key_info\", &gtk_le,\n\t\t\t\t       sizeof(gtk_le));\n\tif (ret < 0)\n\t\tbrcmf_err(\"gtk_key_info iovar failed: ret=%d\\n\", ret);\n\n\treturn ret;\n}\n#endif\n\nstatic int brcmf_cfg80211_set_pmk(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const struct cfg80211_pmk_conf *conf)\n{\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\t/* expect using firmware supplicant for 1X */\n\tifp = netdev_priv(dev);\n\tif (WARN_ON(ifp->vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_1X))\n\t\treturn -EINVAL;\n\n\treturn brcmf_set_pmk(ifp, conf->pmk, conf->pmk_len);\n}\n\nstatic int brcmf_cfg80211_del_pmk(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *aa)\n{\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\tifp = netdev_priv(dev);\n\tif (WARN_ON(ifp->vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_1X))\n\t\treturn -EINVAL;\n\n\treturn brcmf_set_pmk(ifp, NULL, 0);\n}\n\nstatic struct cfg80211_ops brcmf_cfg80211_ops = {\n\t.add_virtual_intf = brcmf_cfg80211_add_iface,\n\t.del_virtual_intf = brcmf_cfg80211_del_iface,\n\t.change_virtual_intf = brcmf_cfg80211_change_iface,\n\t.scan = brcmf_cfg80211_scan,\n\t.set_wiphy_params = brcmf_cfg80211_set_wiphy_params,\n\t.join_ibss = brcmf_cfg80211_join_ibss,\n\t.leave_ibss = brcmf_cfg80211_leave_ibss,\n\t.get_station = brcmf_cfg80211_get_station,\n\t.dump_station = brcmf_cfg80211_dump_station,\n\t.set_tx_power = brcmf_cfg80211_set_tx_power,\n\t.get_tx_power = brcmf_cfg80211_get_tx_power,\n\t.add_key = brcmf_cfg80211_add_key,\n\t.del_key = brcmf_cfg80211_del_key,\n\t.get_key = brcmf_cfg80211_get_key,\n\t.set_default_key = brcmf_cfg80211_config_default_key,\n\t.set_default_mgmt_key = brcmf_cfg80211_config_default_mgmt_key,\n\t.set_power_mgmt = brcmf_cfg80211_set_power_mgmt,\n\t.connect = brcmf_cfg80211_connect,\n\t.disconnect = brcmf_cfg80211_disconnect,\n\t.suspend = brcmf_cfg80211_suspend,\n\t.resume = brcmf_cfg80211_resume,\n\t.set_pmksa = brcmf_cfg80211_set_pmksa,\n\t.del_pmksa = brcmf_cfg80211_del_pmksa,\n\t.flush_pmksa = brcmf_cfg80211_flush_pmksa,\n\t.start_ap = brcmf_cfg80211_start_ap,\n\t.stop_ap = brcmf_cfg80211_stop_ap,\n\t.change_beacon = brcmf_cfg80211_change_beacon,\n\t.del_station = brcmf_cfg80211_del_station,\n\t.change_station = brcmf_cfg80211_change_station,\n\t.sched_scan_start = brcmf_cfg80211_sched_scan_start,\n\t.sched_scan_stop = brcmf_cfg80211_sched_scan_stop,\n\t.mgmt_frame_register = brcmf_cfg80211_mgmt_frame_register,\n\t.mgmt_tx = brcmf_cfg80211_mgmt_tx,\n\t.remain_on_channel = brcmf_p2p_remain_on_channel,\n\t.cancel_remain_on_channel = brcmf_cfg80211_cancel_remain_on_channel,\n\t.get_channel = brcmf_cfg80211_get_channel,\n\t.start_p2p_device = brcmf_p2p_start_device,\n\t.stop_p2p_device = brcmf_p2p_stop_device,\n\t.crit_proto_start = brcmf_cfg80211_crit_proto_start,\n\t.crit_proto_stop = brcmf_cfg80211_crit_proto_stop,\n\t.tdls_oper = brcmf_cfg80211_tdls_oper,\n\t.update_connect_params = brcmf_cfg80211_update_conn_params,\n\t.set_pmk = brcmf_cfg80211_set_pmk,\n\t.del_pmk = brcmf_cfg80211_del_pmk,\n};\n\nstruct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t\t   enum nl80211_iftype type)\n{\n\tstruct brcmf_cfg80211_vif *vif_walk;\n\tstruct brcmf_cfg80211_vif *vif;\n\tbool mbss;\n\n\tbrcmf_dbg(TRACE, \"allocating virtual interface (size=%zu)\\n\",\n\t\t  sizeof(*vif));\n\tvif = kzalloc(sizeof(*vif), GFP_KERNEL);\n\tif (!vif)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvif->wdev.wiphy = cfg->wiphy;\n\tvif->wdev.iftype = type;\n\n\tbrcmf_init_prof(&vif->profile);\n\n\tif (type == NL80211_IFTYPE_AP) {\n\t\tmbss = false;\n\t\tlist_for_each_entry(vif_walk, &cfg->vif_list, list) {\n\t\t\tif (vif_walk->wdev.iftype == NL80211_IFTYPE_AP) {\n\t\t\t\tmbss = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvif->mbss = mbss;\n\t}\n\n\tlist_add_tail(&vif->list, &cfg->vif_list);\n\treturn vif;\n}\n\nvoid brcmf_free_vif(struct brcmf_cfg80211_vif *vif)\n{\n\tlist_del(&vif->list);\n\tkfree(vif);\n}\n\nvoid brcmf_cfg80211_free_netdev(struct net_device *ndev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tifp = netdev_priv(ndev);\n\tvif = ifp->vif;\n\n\tif (vif)\n\t\tbrcmf_free_vif(vif);\n}\n\nstatic bool brcmf_is_linkup(struct brcmf_cfg80211_vif *vif,\n\t\t\t    const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (vif->profile.use_fwsup == BRCMF_PROFILE_FWSUP_PSK &&\n\t    event == BRCMF_E_PSK_SUP &&\n\t    status == BRCMF_E_STATUS_FWSUP_COMPLETED)\n\t\tset_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);\n\tif (event == BRCMF_E_SET_SSID && status == BRCMF_E_STATUS_SUCCESS) {\n\t\tbrcmf_dbg(CONN, \"Processing set ssid\\n\");\n\t\tmemcpy(vif->profile.bssid, e->addr, ETH_ALEN);\n\t\tif (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_PSK)\n\t\t\treturn true;\n\n\t\tset_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);\n\t}\n\n\tif (test_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state) &&\n\t    test_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state)) {\n\t\tclear_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);\n\t\tclear_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool brcmf_is_linkdown(const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu16 flags = e->flags;\n\n\tif ((event == BRCMF_E_DEAUTH) || (event == BRCMF_E_DEAUTH_IND) ||\n\t    (event == BRCMF_E_DISASSOC_IND) ||\n\t    ((event == BRCMF_E_LINK) && (!(flags & BRCMF_EVENT_MSG_LINK)))) {\n\t\tbrcmf_dbg(CONN, \"Processing link down\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool brcmf_is_nonetwork(struct brcmf_cfg80211_info *cfg,\n\t\t\t       const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (event == BRCMF_E_LINK && status == BRCMF_E_STATUS_NO_NETWORKS) {\n\t\tbrcmf_dbg(CONN, \"Processing Link %s & no network found\\n\",\n\t\t\t  e->flags & BRCMF_EVENT_MSG_LINK ? \"up\" : \"down\");\n\t\treturn true;\n\t}\n\n\tif (event == BRCMF_E_SET_SSID && status != BRCMF_E_STATUS_SUCCESS) {\n\t\tbrcmf_dbg(CONN, \"Processing connecting & no network found\\n\");\n\t\treturn true;\n\t}\n\n\tif (event == BRCMF_E_PSK_SUP &&\n\t    status != BRCMF_E_STATUS_FWSUP_COMPLETED) {\n\t\tbrcmf_dbg(CONN, \"Processing failed supplicant state: %u\\n\",\n\t\t\t  status);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void brcmf_clear_assoc_ies(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\n\tkfree(conn_info->req_ie);\n\tconn_info->req_ie = NULL;\n\tconn_info->req_ie_len = 0;\n\tkfree(conn_info->resp_ie);\n\tconn_info->resp_ie = NULL;\n\tconn_info->resp_ie_len = 0;\n}\n\nstatic s32 brcmf_get_assoc_ies(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_assoc_ielen_le *assoc_info;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tu32 req_len;\n\tu32 resp_len;\n\ts32 err = 0;\n\n\tbrcmf_clear_assoc_ies(cfg);\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_info\",\n\t\t\t\t       cfg->extra_buf, WL_ASSOC_INFO_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"could not get assoc info (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tassoc_info =\n\t\t(struct brcmf_cfg80211_assoc_ielen_le *)cfg->extra_buf;\n\treq_len = le32_to_cpu(assoc_info->req_len);\n\tresp_len = le32_to_cpu(assoc_info->resp_len);\n\tif (req_len) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_req_ies\",\n\t\t\t\t\t       cfg->extra_buf,\n\t\t\t\t\t       WL_ASSOC_INFO_MAX);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"could not get assoc req (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tconn_info->req_ie_len = req_len;\n\t\tconn_info->req_ie =\n\t\t    kmemdup(cfg->extra_buf, conn_info->req_ie_len,\n\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tconn_info->req_ie_len = 0;\n\t\tconn_info->req_ie = NULL;\n\t}\n\tif (resp_len) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_resp_ies\",\n\t\t\t\t\t       cfg->extra_buf,\n\t\t\t\t\t       WL_ASSOC_INFO_MAX);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"could not get assoc resp (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tconn_info->resp_ie_len = resp_len;\n\t\tconn_info->resp_ie =\n\t\t    kmemdup(cfg->extra_buf, conn_info->resp_ie_len,\n\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tconn_info->resp_ie_len = 0;\n\t\tconn_info->resp_ie = NULL;\n\t}\n\tbrcmf_dbg(CONN, \"req len (%d) resp len (%d)\\n\",\n\t\t  conn_info->req_ie_len, conn_info->resp_ie_len);\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_bss_roaming_done(struct brcmf_cfg80211_info *cfg,\n\t\t       struct net_device *ndev,\n\t\t       const struct brcmf_event_msg *e)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct ieee80211_channel *notify_channel = NULL;\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmf_bss_info_le *bi;\n\tstruct brcmu_chan ch;\n\tstruct cfg80211_roam_info roam_info = {};\n\tu32 freq;\n\ts32 err = 0;\n\tu8 *buf;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tbrcmf_get_assoc_ies(cfg, ifp);\n\tmemcpy(profile->bssid, e->addr, ETH_ALEN);\n\tbrcmf_update_bss_info(cfg, ifp);\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t/* data sent to dongle has to be little endian */\n\t*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     buf, WL_BSS_INFO_MAX);\n\n\tif (err)\n\t\tgoto done;\n\n\tbi = (struct brcmf_bss_info_le *)(buf + 4);\n\tch.chspec = le16_to_cpu(bi->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\n\tif (ch.band == BRCMU_CHAN_BAND_2G)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\ndone:\n\tkfree(buf);\n\n\troam_info.channel = notify_channel;\n\troam_info.bssid = profile->bssid;\n\troam_info.req_ie = conn_info->req_ie;\n\troam_info.req_ie_len = conn_info->req_ie_len;\n\troam_info.resp_ie = conn_info->resp_ie;\n\troam_info.resp_ie_len = conn_info->resp_ie_len;\n\n\tcfg80211_roamed(ndev, &roam_info, GFP_KERNEL);\n\tbrcmf_dbg(CONN, \"Report roaming result\\n\");\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_bss_connect_done(struct brcmf_cfg80211_info *cfg,\n\t\t       struct net_device *ndev, const struct brcmf_event_msg *e,\n\t\t       bool completed)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tstruct cfg80211_connect_resp_params conn_params;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t       &ifp->vif->sme_state)) {\n\t\tmemset(&conn_params, 0, sizeof(conn_params));\n\t\tif (completed) {\n\t\t\tbrcmf_get_assoc_ies(cfg, ifp);\n\t\t\tbrcmf_update_bss_info(cfg, ifp);\n\t\t\tset_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t\t&ifp->vif->sme_state);\n\t\t\tconn_params.status = WLAN_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tconn_params.status = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t}\n\t\tconn_params.bssid = profile->bssid;\n\t\tconn_params.req_ie = conn_info->req_ie;\n\t\tconn_params.req_ie_len = conn_info->req_ie_len;\n\t\tconn_params.resp_ie = conn_info->resp_ie;\n\t\tconn_params.resp_ie_len = conn_info->resp_ie_len;\n\t\tcfg80211_connect_done(ndev, &conn_params, GFP_KERNEL);\n\t\tbrcmf_dbg(CONN, \"Report connect result - connection %s\\n\",\n\t\t\t  completed ? \"succeeded\" : \"failed\");\n\t}\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_connect_status_ap(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct net_device *ndev,\n\t\t\t       const struct brcmf_event_msg *e, void *data)\n{\n\tstatic int generation;\n\tu32 event = e->event_code;\n\tu32 reason = e->reason;\n\tstruct station_info sinfo;\n\n\tbrcmf_dbg(CONN, \"event %s (%u), reason %d\\n\",\n\t\t  brcmf_fweh_event_name(event), event, reason);\n\tif (event == BRCMF_E_LINK && reason == BRCMF_E_REASON_LINK_BSSCFG_DIS &&\n\t    ndev != cfg_to_ndev(cfg)) {\n\t\tbrcmf_dbg(CONN, \"AP mode link down\\n\");\n\t\tcomplete(&cfg->vif_disabled);\n\t\treturn 0;\n\t}\n\n\tif (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&\n\t    (reason == BRCMF_E_STATUS_SUCCESS)) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tif (!data) {\n\t\t\tbrcmf_err(\"No IEs present in ASSOC/REASSOC_IND\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsinfo.assoc_req_ies = data;\n\t\tsinfo.assoc_req_ies_len = e->datalen;\n\t\tgeneration++;\n\t\tsinfo.generation = generation;\n\t\tcfg80211_new_sta(ndev, e->addr, &sinfo, GFP_KERNEL);\n\t} else if ((event == BRCMF_E_DISASSOC_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH)) {\n\t\tcfg80211_del_sta(ndev, e->addr, GFP_KERNEL);\n\t}\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_connect_status(struct brcmf_if *ifp,\n\t\t\t    const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct net_device *ndev = ifp->ndev;\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct ieee80211_channel *chan;\n\ts32 err = 0;\n\n\tif ((e->event_code == BRCMF_E_DEAUTH) ||\n\t    (e->event_code == BRCMF_E_DEAUTH_IND) ||\n\t    (e->event_code == BRCMF_E_DISASSOC_IND) ||\n\t    ((e->event_code == BRCMF_E_LINK) && (!e->flags))) {\n\t\tbrcmf_proto_delete_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t}\n\n\tif (brcmf_is_apmode(ifp->vif)) {\n\t\terr = brcmf_notify_connect_status_ap(cfg, ndev, e, data);\n\t} else if (brcmf_is_linkup(ifp->vif, e)) {\n\t\tbrcmf_dbg(CONN, \"Linkup\\n\");\n\t\tif (brcmf_is_ibssmode(ifp->vif)) {\n\t\t\tbrcmf_inform_ibss(cfg, ndev, e->addr);\n\t\t\tchan = ieee80211_get_channel(cfg->wiphy, cfg->channel);\n\t\t\tmemcpy(profile->bssid, e->addr, ETH_ALEN);\n\t\t\tcfg80211_ibss_joined(ndev, e->addr, chan, GFP_KERNEL);\n\t\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t\t  &ifp->vif->sme_state);\n\t\t\tset_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t\t&ifp->vif->sme_state);\n\t\t} else\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, true);\n\t\tbrcmf_net_setcarrier(ifp, true);\n\t} else if (brcmf_is_linkdown(e)) {\n\t\tbrcmf_dbg(CONN, \"Linkdown\\n\");\n\t\tif (!brcmf_is_ibssmode(ifp->vif)) {\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, false);\n\t\t\tbrcmf_link_down(ifp->vif,\n\t\t\t\t\tbrcmf_map_fw_linkdown_reason(e));\n\t\t\tbrcmf_init_prof(ndev_to_prof(ndev));\n\t\t\tif (ndev != cfg_to_ndev(cfg))\n\t\t\t\tcomplete(&cfg->vif_disabled);\n\t\t\tbrcmf_net_setcarrier(ifp, false);\n\t\t}\n\t} else if (brcmf_is_nonetwork(cfg, e)) {\n\t\tif (brcmf_is_ibssmode(ifp->vif))\n\t\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t\t  &ifp->vif->sme_state);\n\t\telse\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, false);\n\t}\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_notify_roaming_status(struct brcmf_if *ifp,\n\t\t\t    const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (event == BRCMF_E_ROAM && status == BRCMF_E_STATUS_SUCCESS) {\n\t\tif (test_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state))\n\t\t\tbrcmf_bss_roaming_done(cfg, ifp->ndev, e);\n\t\telse\n\t\t\tbrcmf_bss_connect_done(cfg, ifp->ndev, e, true);\n\t}\n\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_mic_status(struct brcmf_if *ifp,\n\t\t\tconst struct brcmf_event_msg *e, void *data)\n{\n\tu16 flags = e->flags;\n\tenum nl80211_key_type key_type;\n\n\tif (flags & BRCMF_EVENT_MSG_GROUP)\n\t\tkey_type = NL80211_KEYTYPE_GROUP;\n\telse\n\t\tkey_type = NL80211_KEYTYPE_PAIRWISE;\n\n\tcfg80211_michael_mic_failure(ifp->ndev, (u8 *)&e->addr, key_type, -1,\n\t\t\t\t     NULL, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic s32 brcmf_notify_vif_event(struct brcmf_if *ifp,\n\t\t\t\t  const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_if_event *ifevent = (struct brcmf_if_event *)data;\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(TRACE, \"Enter: action %u flags %u ifidx %u bsscfgidx %u\\n\",\n\t\t  ifevent->action, ifevent->flags, ifevent->ifidx,\n\t\t  ifevent->bsscfgidx);\n\n\tspin_lock(&event->vif_event_lock);\n\tevent->action = ifevent->action;\n\tvif = event->vif;\n\n\tswitch (ifevent->action) {\n\tcase BRCMF_E_IF_ADD:\n\t\t/* waiting process may have timed out */\n\t\tif (!cfg->vif_event.vif) {\n\t\t\tspin_unlock(&event->vif_event_lock);\n\t\t\treturn -EBADF;\n\t\t}\n\n\t\tifp->vif = vif;\n\t\tvif->ifp = ifp;\n\t\tif (ifp->ndev) {\n\t\t\tvif->wdev.netdev = ifp->ndev;\n\t\t\tifp->ndev->ieee80211_ptr = &vif->wdev;\n\t\t\tSET_NETDEV_DEV(ifp->ndev, wiphy_dev(cfg->wiphy));\n\t\t}\n\t\tspin_unlock(&event->vif_event_lock);\n\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tcase BRCMF_E_IF_DEL:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\t/* event may not be upon user request */\n\t\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tcase BRCMF_E_IF_CHANGE:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tdefault:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void brcmf_init_conf(struct brcmf_cfg80211_conf *conf)\n{\n\tconf->frag_threshold = (u32)-1;\n\tconf->rts_threshold = (u32)-1;\n\tconf->retry_short = (u32)-1;\n\tconf->retry_long = (u32)-1;\n}\n\nstatic void brcmf_register_event_handlers(struct brcmf_cfg80211_info *cfg)\n{\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_LINK,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DISASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_REASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ROAM,\n\t\t\t    brcmf_notify_roaming_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_MIC_ERROR,\n\t\t\t    brcmf_notify_mic_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_SET_SSID,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t    brcmf_notify_sched_scan_results);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_IF,\n\t\t\t    brcmf_notify_vif_event);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_PROBEREQ_MSG,\n\t\t\t    brcmf_p2p_notify_rx_mgmt_p2p_probereq);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_DISC_LISTEN_COMPLETE,\n\t\t\t    brcmf_p2p_notify_listen_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_RX,\n\t\t\t    brcmf_p2p_notify_action_frame_rx);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_COMPLETE,\n\t\t\t    brcmf_p2p_notify_action_tx_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_OFF_CHAN_COMPLETE,\n\t\t\t    brcmf_p2p_notify_action_tx_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PSK_SUP,\n\t\t\t    brcmf_notify_connect_status);\n}\n\nstatic void brcmf_deinit_priv_mem(struct brcmf_cfg80211_info *cfg)\n{\n\tkfree(cfg->conf);\n\tcfg->conf = NULL;\n\tkfree(cfg->extra_buf);\n\tcfg->extra_buf = NULL;\n\tkfree(cfg->wowl.nd);\n\tcfg->wowl.nd = NULL;\n\tkfree(cfg->wowl.nd_info);\n\tcfg->wowl.nd_info = NULL;\n\tkfree(cfg->escan_info.escan_buf);\n\tcfg->escan_info.escan_buf = NULL;\n}\n\nstatic s32 brcmf_init_priv_mem(struct brcmf_cfg80211_info *cfg)\n{\n\tcfg->conf = kzalloc(sizeof(*cfg->conf), GFP_KERNEL);\n\tif (!cfg->conf)\n\t\tgoto init_priv_mem_out;\n\tcfg->extra_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!cfg->extra_buf)\n\t\tgoto init_priv_mem_out;\n\tcfg->wowl.nd = kzalloc(sizeof(*cfg->wowl.nd) + sizeof(u32), GFP_KERNEL);\n\tif (!cfg->wowl.nd)\n\t\tgoto init_priv_mem_out;\n\tcfg->wowl.nd_info = kzalloc(sizeof(*cfg->wowl.nd_info) +\n\t\t\t\t    sizeof(struct cfg80211_wowlan_nd_match *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!cfg->wowl.nd_info)\n\t\tgoto init_priv_mem_out;\n\tcfg->escan_info.escan_buf = kzalloc(BRCMF_ESCAN_BUF_SIZE, GFP_KERNEL);\n\tif (!cfg->escan_info.escan_buf)\n\t\tgoto init_priv_mem_out;\n\n\treturn 0;\n\ninit_priv_mem_out:\n\tbrcmf_deinit_priv_mem(cfg);\n\n\treturn -ENOMEM;\n}\n\nstatic s32 wl_init_priv(struct brcmf_cfg80211_info *cfg)\n{\n\ts32 err = 0;\n\n\tcfg->scan_request = NULL;\n\tcfg->pwr_save = true;\n\tcfg->active_scan = true;\t/* we do active scan per default */\n\tcfg->dongle_up = false;\t\t/* dongle is not up yet */\n\terr = brcmf_init_priv_mem(cfg);\n\tif (err)\n\t\treturn err;\n\tbrcmf_register_event_handlers(cfg);\n\tmutex_init(&cfg->usr_sync);\n\tbrcmf_init_escan(cfg);\n\tbrcmf_init_conf(cfg->conf);\n\tinit_completion(&cfg->vif_disabled);\n\treturn err;\n}\n\nstatic void wl_deinit_priv(struct brcmf_cfg80211_info *cfg)\n{\n\tcfg->dongle_up = false;\t/* dongle down */\n\tbrcmf_abort_scanning(cfg);\n\tbrcmf_deinit_priv_mem(cfg);\n}\n\nstatic void init_vif_event(struct brcmf_cfg80211_vif_event *event)\n{\n\tinit_waitqueue_head(&event->vif_wq);\n\tspin_lock_init(&event->vif_event_lock);\n}\n\nstatic s32 brcmf_dongle_roam(struct brcmf_if *ifp)\n{\n\ts32 err;\n\tu32 bcn_timeout;\n\t__le32 roamtrigger[2];\n\t__le32 roam_delta[2];\n\n\t/* Configure beacon timeout value based upon roaming setting */\n\tif (ifp->drvr->settings->roamoff)\n\t\tbcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_OFF;\n\telse\n\t\tbcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_ON;\n\terr = brcmf_fil_iovar_int_set(ifp, \"bcn_timeout\", bcn_timeout);\n\tif (err) {\n\t\tbrcmf_err(\"bcn_timeout error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\t/* Enable/Disable built-in roaming to allow supplicant to take care of\n\t * roaming.\n\t */\n\tbrcmf_dbg(INFO, \"Internal Roaming = %s\\n\",\n\t\t  ifp->drvr->settings->roamoff ? \"Off\" : \"On\");\n\terr = brcmf_fil_iovar_int_set(ifp, \"roam_off\",\n\t\t\t\t      ifp->drvr->settings->roamoff);\n\tif (err) {\n\t\tbrcmf_err(\"roam_off error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\troamtrigger[0] = cpu_to_le32(WL_ROAM_TRIGGER_LEVEL);\n\troamtrigger[1] = cpu_to_le32(BRCM_BAND_ALL);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,\n\t\t\t\t     (void *)roamtrigger, sizeof(roamtrigger));\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_ROAM_TRIGGER error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\troam_delta[0] = cpu_to_le32(WL_ROAM_DELTA);\n\troam_delta[1] = cpu_to_le32(BRCM_BAND_ALL);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,\n\t\t\t\t     (void *)roam_delta, sizeof(roam_delta));\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_ROAM_DELTA error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\nroam_setup_done:\n\treturn err;\n}\n\nstatic s32\nbrcmf_dongle_scantime(struct brcmf_if *ifp)\n{\n\ts32 err = 0;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,\n\t\t\t\t    BRCMF_SCAN_CHANNEL_TIME);\n\tif (err) {\n\t\tbrcmf_err(\"Scan assoc time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,\n\t\t\t\t    BRCMF_SCAN_UNASSOC_TIME);\n\tif (err) {\n\t\tbrcmf_err(\"Scan unassoc time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_PASSIVE_TIME,\n\t\t\t\t    BRCMF_SCAN_PASSIVE_TIME);\n\tif (err) {\n\t\tbrcmf_err(\"Scan passive time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\ndongle_scantime_out:\n\treturn err;\n}\n\nstatic void brcmf_update_bw40_channel_flag(struct ieee80211_channel *channel,\n\t\t\t\t\t   struct brcmu_chan *ch)\n{\n\tu32 ht40_flag;\n\n\tht40_flag = channel->flags & IEEE80211_CHAN_NO_HT40;\n\tif (ch->sb == BRCMU_CHAN_SB_U) {\n\t\tif (ht40_flag == IEEE80211_CHAN_NO_HT40)\n\t\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40;\n\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40PLUS;\n\t} else {\n\t\t/* It should be one of\n\t\t * IEEE80211_CHAN_NO_HT40 or\n\t\t * IEEE80211_CHAN_NO_HT40PLUS\n\t\t */\n\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40;\n\t\tif (ht40_flag == IEEE80211_CHAN_NO_HT40)\n\t\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40MINUS;\n\t}\n}\n\nstatic int brcmf_construct_chaninfo(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t    u32 bw_cap[])\n{\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct ieee80211_supported_band *band;\n\tstruct ieee80211_channel *channel;\n\tstruct wiphy *wiphy;\n\tstruct brcmf_chanspec_list *list;\n\tstruct brcmu_chan ch;\n\tint err;\n\tu8 *pbuf;\n\tu32 i, j;\n\tu32 total;\n\tu32 chaninfo;\n\n\tpbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\n\n\tif (pbuf == NULL)\n\t\treturn -ENOMEM;\n\n\tlist = (struct brcmf_chanspec_list *)pbuf;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"chanspecs\", pbuf,\n\t\t\t\t       BRCMF_DCMD_MEDLEN);\n\tif (err) {\n\t\tbrcmf_err(\"get chanspecs error (%d)\\n\", err);\n\t\tgoto fail_pbuf;\n\t}\n\n\twiphy = cfg_to_wiphy(cfg);\n\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\tif (band)\n\t\tfor (i = 0; i < band->n_channels; i++)\n\t\t\tband->channels[i].flags = IEEE80211_CHAN_DISABLED;\n\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\tif (band)\n\t\tfor (i = 0; i < band->n_channels; i++)\n\t\t\tband->channels[i].flags = IEEE80211_CHAN_DISABLED;\n\n\ttotal = le32_to_cpu(list->count);\n\tfor (i = 0; i < total; i++) {\n\t\tch.chspec = (u16)le32_to_cpu(list->element[i]);\n\t\tcfg->d11inf.decchspec(&ch);\n\n\t\tif (ch.band == BRCMU_CHAN_BAND_2G) {\n\t\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\t\t} else if (ch.band == BRCMU_CHAN_BAND_5G) {\n\t\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\t\t} else {\n\t\t\tbrcmf_err(\"Invalid channel Spec. 0x%x.\\n\", ch.chspec);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!band)\n\t\t\tcontinue;\n\t\tif (!(bw_cap[band->band] & WLC_BW_40MHZ_BIT) &&\n\t\t    ch.bw == BRCMU_CHAN_BW_40)\n\t\t\tcontinue;\n\t\tif (!(bw_cap[band->band] & WLC_BW_80MHZ_BIT) &&\n\t\t    ch.bw == BRCMU_CHAN_BW_80)\n\t\t\tcontinue;\n\n\t\tchannel = NULL;\n\t\tfor (j = 0; j < band->n_channels; j++) {\n\t\t\tif (band->channels[j].hw_value == ch.control_ch_num) {\n\t\t\t\tchannel = &band->channels[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!channel) {\n\t\t\t/* It seems firmware supports some channel we never\n\t\t\t * considered. Something new in IEEE standard?\n\t\t\t */\n\t\t\tbrcmf_err(\"Ignoring unexpected firmware channel %d\\n\",\n\t\t\t\t  ch.control_ch_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (channel->orig_flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* assuming the chanspecs order is HT20,\n\t\t * HT40 upper, HT40 lower, and VHT80.\n\t\t */\n\t\tif (ch.bw == BRCMU_CHAN_BW_80) {\n\t\t\tchannel->flags &= ~IEEE80211_CHAN_NO_80MHZ;\n\t\t} else if (ch.bw == BRCMU_CHAN_BW_40) {\n\t\t\tbrcmf_update_bw40_channel_flag(channel, &ch);\n\t\t} else {\n\t\t\t/* enable the channel and disable other bandwidths\n\t\t\t * for now as mentioned order assure they are enabled\n\t\t\t * for subsequent chanspecs.\n\t\t\t */\n\t\t\tchannel->flags = IEEE80211_CHAN_NO_HT40 |\n\t\t\t\t\t IEEE80211_CHAN_NO_80MHZ;\n\t\t\tch.bw = BRCMU_CHAN_BW_20;\n\t\t\tcfg->d11inf.encchspec(&ch);\n\t\t\tchaninfo = ch.chspec;\n\t\t\terr = brcmf_fil_bsscfg_int_get(ifp, \"per_chan_info\",\n\t\t\t\t\t\t       &chaninfo);\n\t\t\tif (!err) {\n\t\t\t\tif (chaninfo & WL_CHAN_RADAR)\n\t\t\t\t\tchannel->flags |=\n\t\t\t\t\t\t(IEEE80211_CHAN_RADAR |\n\t\t\t\t\t\t IEEE80211_CHAN_NO_IR);\n\t\t\t\tif (chaninfo & WL_CHAN_PASSIVE)\n\t\t\t\t\tchannel->flags |=\n\t\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\t}\n\t\t}\n\t}\n\nfail_pbuf:\n\tkfree(pbuf);\n\treturn err;\n}\n\nstatic int brcmf_enable_bw40_2g(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmf_fil_bwcap_le band_bwcap;\n\tstruct brcmf_chanspec_list *list;\n\tu8 *pbuf;\n\tu32 val;\n\tint err;\n\tstruct brcmu_chan ch;\n\tu32 num_chan;\n\tint i, j;\n\n\t/* verify support for bw_cap command */\n\tval = WLC_BAND_5G;\n\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &val);\n\n\tif (!err) {\n\t\t/* only set 2G bandwidth using bw_cap command */\n\t\tband_bwcap.band = cpu_to_le32(WLC_BAND_2G);\n\t\tband_bwcap.bw_cap = cpu_to_le32(WLC_BW_CAP_40MHZ);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bw_cap\", &band_bwcap,\n\t\t\t\t\t       sizeof(band_bwcap));\n\t} else {\n\t\tbrcmf_dbg(INFO, \"fallback to mimo_bw_cap\\n\");\n\t\tval = WLC_N_BW_40ALL;\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"mimo_bw_cap\", val);\n\t}\n\n\tif (!err) {\n\t\t/* update channel info in 2G band */\n\t\tpbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\n\n\t\tif (pbuf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tch.band = BRCMU_CHAN_BAND_2G;\n\t\tch.bw = BRCMU_CHAN_BW_40;\n\t\tch.sb = BRCMU_CHAN_SB_NONE;\n\t\tch.chnum = 0;\n\t\tcfg->d11inf.encchspec(&ch);\n\n\t\t/* pass encoded chanspec in query */\n\t\t*(__le16 *)pbuf = cpu_to_le16(ch.chspec);\n\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"chanspecs\", pbuf,\n\t\t\t\t\t       BRCMF_DCMD_MEDLEN);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"get chanspecs error (%d)\\n\", err);\n\t\t\tkfree(pbuf);\n\t\t\treturn err;\n\t\t}\n\n\t\tband = cfg_to_wiphy(cfg)->bands[NL80211_BAND_2GHZ];\n\t\tlist = (struct brcmf_chanspec_list *)pbuf;\n\t\tnum_chan = le32_to_cpu(list->count);\n\t\tfor (i = 0; i < num_chan; i++) {\n\t\t\tch.chspec = (u16)le32_to_cpu(list->element[i]);\n\t\t\tcfg->d11inf.decchspec(&ch);\n\t\t\tif (WARN_ON(ch.band != BRCMU_CHAN_BAND_2G))\n\t\t\t\tcontinue;\n\t\t\tif (WARN_ON(ch.bw != BRCMU_CHAN_BW_40))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < band->n_channels; j++) {\n\t\t\t\tif (band->channels[j].hw_value == ch.control_ch_num)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (WARN_ON(j == band->n_channels))\n\t\t\t\tcontinue;\n\n\t\t\tbrcmf_update_bw40_channel_flag(&band->channels[j], &ch);\n\t\t}\n\t\tkfree(pbuf);\n\t}\n\treturn err;\n}\n\nstatic void brcmf_get_bwcap(struct brcmf_if *ifp, u32 bw_cap[])\n{\n\tu32 band, mimo_bwcap;\n\tint err;\n\n\tband = WLC_BAND_2G;\n\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &band);\n\tif (!err) {\n\t\tbw_cap[NL80211_BAND_2GHZ] = band;\n\t\tband = WLC_BAND_5G;\n\t\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &band);\n\t\tif (!err) {\n\t\t\tbw_cap[NL80211_BAND_5GHZ] = band;\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tbrcmf_dbg(INFO, \"fallback to mimo_bw_cap info\\n\");\n\tmimo_bwcap = 0;\n\terr = brcmf_fil_iovar_int_get(ifp, \"mimo_bw_cap\", &mimo_bwcap);\n\tif (err)\n\t\t/* assume 20MHz if firmware does not give a clue */\n\t\tmimo_bwcap = WLC_N_BW_20ALL;\n\n\tswitch (mimo_bwcap) {\n\tcase WLC_N_BW_40ALL:\n\t\tbw_cap[NL80211_BAND_2GHZ] |= WLC_BW_40MHZ_BIT;\n\t\t/* fall-thru */\n\tcase WLC_N_BW_20IN2G_40IN5G:\n\t\tbw_cap[NL80211_BAND_5GHZ] |= WLC_BW_40MHZ_BIT;\n\t\t/* fall-thru */\n\tcase WLC_N_BW_20ALL:\n\t\tbw_cap[NL80211_BAND_2GHZ] |= WLC_BW_20MHZ_BIT;\n\t\tbw_cap[NL80211_BAND_5GHZ] |= WLC_BW_20MHZ_BIT;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"invalid mimo_bw_cap value\\n\");\n\t}\n}\n\nstatic void brcmf_update_ht_cap(struct ieee80211_supported_band *band,\n\t\t\t\tu32 bw_cap[2], u32 nchain)\n{\n\tband->ht_cap.ht_supported = true;\n\tif (bw_cap[band->band] & WLC_BW_40MHZ_BIT) {\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\n\tband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\tmemset(band->ht_cap.mcs.rx_mask, 0xff, nchain);\n\tband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n}\n\nstatic __le16 brcmf_get_mcs_map(u32 nchain, enum ieee80211_vht_mcs_support supp)\n{\n\tu16 mcs_map;\n\tint i;\n\n\tfor (i = 0, mcs_map = 0xFFFF; i < nchain; i++)\n\t\tmcs_map = (mcs_map << 2) | supp;\n\n\treturn cpu_to_le16(mcs_map);\n}\n\nstatic void brcmf_update_vht_cap(struct ieee80211_supported_band *band,\n\t\t\t\t u32 bw_cap[2], u32 nchain, u32 txstreams,\n\t\t\t\t u32 txbf_bfe_cap, u32 txbf_bfr_cap)\n{\n\t__le16 mcs_map;\n\n\t/* not allowed in 2.4G band */\n\tif (band->band == NL80211_BAND_2GHZ)\n\t\treturn;\n\n\tband->vht_cap.vht_supported = true;\n\t/* 80MHz is mandatory */\n\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_80;\n\tif (bw_cap[band->band] & WLC_BW_160MHZ_BIT) {\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_160;\n\t}\n\t/* all support 256-QAM */\n\tmcs_map = brcmf_get_mcs_map(nchain, IEEE80211_VHT_MCS_SUPPORT_0_9);\n\tband->vht_cap.vht_mcs.rx_mcs_map = mcs_map;\n\tband->vht_cap.vht_mcs.tx_mcs_map = mcs_map;\n\n\t/* Beamforming support information */\n\tif (txbf_bfe_cap & BRCMF_TXBF_SU_BFE_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE;\n\tif (txbf_bfe_cap & BRCMF_TXBF_MU_BFE_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\tif (txbf_bfr_cap & BRCMF_TXBF_SU_BFR_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE;\n\tif (txbf_bfr_cap & BRCMF_TXBF_MU_BFR_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE;\n\n\tif ((txbf_bfe_cap || txbf_bfr_cap) && (txstreams > 1)) {\n\t\tband->vht_cap.cap |=\n\t\t\t(2 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT);\n\t\tband->vht_cap.cap |= ((txstreams - 1) <<\n\t\t\t\tIEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT);\n\t\tband->vht_cap.cap |=\n\t\t\tIEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB;\n\t}\n}\n\nstatic int brcmf_setup_wiphybands(struct wiphy *wiphy)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tu32 nmode = 0;\n\tu32 vhtmode = 0;\n\tu32 bw_cap[2] = { WLC_BW_20MHZ_BIT, WLC_BW_20MHZ_BIT };\n\tu32 rxchain;\n\tu32 nchain;\n\tint err;\n\ts32 i;\n\tstruct ieee80211_supported_band *band;\n\tu32 txstreams = 0;\n\tu32 txbf_bfe_cap = 0;\n\tu32 txbf_bfr_cap = 0;\n\n\t(void)brcmf_fil_iovar_int_get(ifp, \"vhtmode\", &vhtmode);\n\terr = brcmf_fil_iovar_int_get(ifp, \"nmode\", &nmode);\n\tif (err) {\n\t\tbrcmf_err(\"nmode error (%d)\\n\", err);\n\t} else {\n\t\tbrcmf_get_bwcap(ifp, bw_cap);\n\t}\n\tbrcmf_dbg(INFO, \"nmode=%d, vhtmode=%d, bw_cap=(%d, %d)\\n\",\n\t\t  nmode, vhtmode, bw_cap[NL80211_BAND_2GHZ],\n\t\t  bw_cap[NL80211_BAND_5GHZ]);\n\n\terr = brcmf_fil_iovar_int_get(ifp, \"rxchain\", &rxchain);\n\tif (err) {\n\t\tbrcmf_err(\"rxchain error (%d)\\n\", err);\n\t\tnchain = 1;\n\t} else {\n\t\tfor (nchain = 0; rxchain; nchain++)\n\t\t\trxchain = rxchain & (rxchain - 1);\n\t}\n\tbrcmf_dbg(INFO, \"nchain=%d\\n\", nchain);\n\n\terr = brcmf_construct_chaninfo(cfg, bw_cap);\n\tif (err) {\n\t\tbrcmf_err(\"brcmf_construct_chaninfo failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (vhtmode) {\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txstreams\", &txstreams);\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txbf_bfe_cap\",\n\t\t\t\t\t      &txbf_bfe_cap);\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txbf_bfr_cap\",\n\t\t\t\t\t      &txbf_bfr_cap);\n\t}\n\n\twiphy = cfg_to_wiphy(cfg);\n\tfor (i = 0; i < ARRAY_SIZE(wiphy->bands); i++) {\n\t\tband = wiphy->bands[i];\n\t\tif (band == NULL)\n\t\t\tcontinue;\n\n\t\tif (nmode)\n\t\t\tbrcmf_update_ht_cap(band, bw_cap, nchain);\n\t\tif (vhtmode)\n\t\t\tbrcmf_update_vht_cap(band, bw_cap, nchain, txstreams,\n\t\t\t\t\t     txbf_bfe_cap, txbf_bfr_cap);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_txrx_stypes\nbrcmf_txrx_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_DEVICE] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t}\n};\n\n/**\n * brcmf_setup_ifmodes() - determine interface modes and combinations.\n *\n * @wiphy: wiphy object.\n * @ifp: interface object needed for feat module api.\n *\n * The interface modes and combinations are determined dynamically here\n * based on firmware functionality.\n *\n * no p2p and no mbss:\n *\n *\t#STA <= 1, #AP <= 1, channels = 1, 2 total\n *\n * no p2p and mbss:\n *\n *\t#STA <= 1, #AP <= 1, channels = 1, 2 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n *\n * p2p, no mchan, and mbss:\n *\n *\t#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 1, 3 total\n *\t#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n *\n * p2p, mchan, and mbss:\n *\n *\t#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 2, 3 total\n *\t#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n */\nstatic int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct ieee80211_iface_combination *combo = NULL;\n\tstruct ieee80211_iface_limit *c0_limits = NULL;\n\tstruct ieee80211_iface_limit *p2p_limits = NULL;\n\tstruct ieee80211_iface_limit *mbss_limits = NULL;\n\tbool mbss, p2p;\n\tint i, c, n_combos;\n\n\tmbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);\n\tp2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);\n\n\tn_combos = 1 + !!p2p + !!mbss;\n\tcombo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);\n\tif (!combo)\n\t\tgoto err;\n\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP);\n\n\tc = 0;\n\ti = 0;\n\tc0_limits = kcalloc(p2p ? 3 : 2, sizeof(*c0_limits), GFP_KERNEL);\n\tif (!c0_limits)\n\t\tgoto err;\n\tc0_limits[i].max = 1;\n\tc0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);\n\tif (p2p) {\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN))\n\t\t\tcombo[c].num_different_channels = 2;\n\t\twiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t       BIT(NL80211_IFTYPE_P2P_GO);\n\t} else {\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t}\n\tcombo[c].num_different_channels = 1;\n\tcombo[c].max_interfaces = i;\n\tcombo[c].n_limits = i;\n\tcombo[c].limits = c0_limits;\n\n\tif (p2p) {\n\t\tc++;\n\t\ti = 0;\n\t\tp2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);\n\t\tif (!p2p_limits)\n\t\t\tgoto err;\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_STATION);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tcombo[c].num_different_channels = 1;\n\t\tcombo[c].max_interfaces = i;\n\t\tcombo[c].n_limits = i;\n\t\tcombo[c].limits = p2p_limits;\n\t}\n\n\tif (mbss) {\n\t\tc++;\n\t\ti = 0;\n\t\tmbss_limits = kcalloc(1, sizeof(*mbss_limits), GFP_KERNEL);\n\t\tif (!mbss_limits)\n\t\t\tgoto err;\n\t\tmbss_limits[i].max = 4;\n\t\tmbss_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tcombo[c].beacon_int_infra_match = true;\n\t\tcombo[c].num_different_channels = 1;\n\t\tcombo[c].max_interfaces = 4;\n\t\tcombo[c].n_limits = i;\n\t\tcombo[c].limits = mbss_limits;\n\t}\n\n\twiphy->n_iface_combinations = n_combos;\n\twiphy->iface_combinations = combo;\n\treturn 0;\n\nerr:\n\tkfree(c0_limits);\n\tkfree(p2p_limits);\n\tkfree(mbss_limits);\n\tkfree(combo);\n\treturn -ENOMEM;\n}\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support brcmf_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT,\n\t.n_patterns = BRCMF_WOWL_MAXPATTERNS,\n\t.pattern_max_len = BRCMF_WOWL_MAXPATTERNSIZE,\n\t.pattern_min_len = 1,\n\t.max_pkt_offset = 1500,\n};\n#endif\n\nstatic void brcmf_wiphy_wowl_params(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n#ifdef CONFIG_PM\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct wiphy_wowlan_support *wowl;\n\n\twowl = kmemdup(&brcmf_wowlan_support, sizeof(brcmf_wowlan_support),\n\t\t       GFP_KERNEL);\n\tif (!wowl) {\n\t\tbrcmf_err(\"only support basic wowlan features\\n\");\n\t\twiphy->wowlan = &brcmf_wowlan_support;\n\t\treturn;\n\t}\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO)) {\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ND)) {\n\t\t\twowl->flags |= WIPHY_WOWLAN_NET_DETECT;\n\t\t\twowl->max_nd_match_sets = BRCMF_PNO_MAX_PFN_COUNT;\n\t\t\tinit_waitqueue_head(&cfg->wowl.nd_data_wait);\n\t\t}\n\t}\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK)) {\n\t\twowl->flags |= WIPHY_WOWLAN_SUPPORTS_GTK_REKEY;\n\t\twowl->flags |= WIPHY_WOWLAN_GTK_REKEY_FAILURE;\n\t}\n\n\twiphy->wowlan = wowl;\n#endif\n}\n\nstatic int brcmf_setup_wiphy(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tconst struct ieee80211_iface_combination *combo;\n\tstruct ieee80211_supported_band *band;\n\tu16 max_interfaces = 0;\n\tbool gscan;\n\t__le32 bandlist[3];\n\tu32 n_bands;\n\tint err, i;\n\n\twiphy->max_scan_ssids = WL_NUM_SCAN_MAX;\n\twiphy->max_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\n\twiphy->max_num_pmkids = BRCMF_MAXPMKID;\n\n\terr = brcmf_setup_ifmodes(wiphy, ifp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0, combo = wiphy->iface_combinations;\n\t     i < wiphy->n_iface_combinations; i++, combo++) {\n\t\tmax_interfaces = max(max_interfaces, combo->max_interfaces);\n\t}\n\n\tfor (i = 0; i < max_interfaces && i < ARRAY_SIZE(drvr->addresses);\n\t     i++) {\n\t\tu8 *addr = drvr->addresses[i].addr;\n\n\t\tmemcpy(addr, drvr->mac, ETH_ALEN);\n\t\tif (i) {\n\t\t\taddr[0] |= BIT(1);\n\t\t\taddr[ETH_ALEN - 1] ^= i;\n\t\t}\n\t}\n\twiphy->addresses = drvr->addresses;\n\twiphy->n_addresses = i;\n\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->cipher_suites = brcmf_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(brcmf_cipher_suites);\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\twiphy->n_cipher_suites--;\n\twiphy->bss_select_support = BIT(NL80211_BSS_SELECT_ATTR_RSSI) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_BAND_PREF) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_RSSI_ADJUST);\n\n\twiphy->flags |= WIPHY_FLAG_NETNS_OK |\n\t\t\tWIPHY_FLAG_PS_ON_BY_DEFAULT |\n\t\t\tWIPHY_FLAG_OFFCHAN_TX |\n\t\t\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TDLS))\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\tif (!ifp->drvr->settings->roamoff)\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_FWSUP)) {\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK);\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X);\n\t}\n\twiphy->mgmt_stypes = brcmf_txrx_stypes;\n\twiphy->max_remain_on_channel_duration = 5000;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO)) {\n\t\tgscan = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_GSCAN);\n\t\tbrcmf_pno_wiphy_params(wiphy, gscan);\n\t}\n\t/* vendor commands/events support */\n\twiphy->vendor_commands = brcmf_vendor_cmds;\n\twiphy->n_vendor_commands = BRCMF_VNDR_CMDS_LAST - 1;\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL))\n\t\tbrcmf_wiphy_wowl_params(wiphy, ifp);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BANDLIST, &bandlist,\n\t\t\t\t     sizeof(bandlist));\n\tif (err) {\n\t\tbrcmf_err(\"could not obtain band info: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\t/* first entry in bandlist is number of bands */\n\tn_bands = le32_to_cpu(bandlist[0]);\n\tfor (i = 1; i <= n_bands && i < ARRAY_SIZE(bandlist); i++) {\n\t\tif (bandlist[i] == cpu_to_le32(WLC_BAND_2G)) {\n\t\t\tband = kmemdup(&__wl_band_2ghz, sizeof(__wl_band_2ghz),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!band)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tband->channels = kmemdup(&__wl_2ghz_channels,\n\t\t\t\t\t\t sizeof(__wl_2ghz_channels),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!band->channels) {\n\t\t\t\tkfree(band);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tband->n_channels = ARRAY_SIZE(__wl_2ghz_channels);\n\t\t\twiphy->bands[NL80211_BAND_2GHZ] = band;\n\t\t}\n\t\tif (bandlist[i] == cpu_to_le32(WLC_BAND_5G)) {\n\t\t\tband = kmemdup(&__wl_band_5ghz, sizeof(__wl_band_5ghz),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!band)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tband->channels = kmemdup(&__wl_5ghz_channels,\n\t\t\t\t\t\t sizeof(__wl_5ghz_channels),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!band->channels) {\n\t\t\t\tkfree(band);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tband->n_channels = ARRAY_SIZE(__wl_5ghz_channels);\n\t\t\twiphy->bands[NL80211_BAND_5GHZ] = band;\n\t\t}\n\t}\n\n\twiphy_read_of_freq_limits(wiphy);\n\n\treturn 0;\n}\n\nstatic s32 brcmf_config_dongle(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct net_device *ndev;\n\tstruct wireless_dev *wdev;\n\tstruct brcmf_if *ifp;\n\ts32 power_mode;\n\ts32 err = 0;\n\n\tif (cfg->dongle_up)\n\t\treturn err;\n\n\tndev = cfg_to_ndev(cfg);\n\twdev = ndev->ieee80211_ptr;\n\tifp = netdev_priv(ndev);\n\n\t/* make sure RF is ready for work */\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 0);\n\n\tbrcmf_dongle_scantime(ifp);\n\n\tpower_mode = cfg->pwr_save ? PM_FAST : PM_OFF;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, power_mode);\n\tif (err)\n\t\tgoto default_conf_out;\n\tbrcmf_dbg(INFO, \"power save set to %s\\n\",\n\t\t  (power_mode ? \"enabled\" : \"disabled\"));\n\n\terr = brcmf_dongle_roam(ifp);\n\tif (err)\n\t\tgoto default_conf_out;\n\terr = brcmf_cfg80211_change_iface(wdev->wiphy, ndev, wdev->iftype,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\tgoto default_conf_out;\n\n\tbrcmf_configure_arp_nd_offload(ifp, true);\n\n\tcfg->dongle_up = true;\ndefault_conf_out:\n\n\treturn err;\n\n}\n\nstatic s32 __brcmf_cfg80211_up(struct brcmf_if *ifp)\n{\n\tset_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\n\n\treturn brcmf_config_dongle(ifp->drvr->config);\n}\n\nstatic s32 __brcmf_cfg80211_down(struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\n\t/*\n\t * While going down, if associated with AP disassociate\n\t * from AP to save power\n\t */\n\tif (check_vif_up(ifp->vif)) {\n\t\tbrcmf_link_down(ifp->vif, WLAN_REASON_UNSPECIFIED);\n\n\t\t/* Make sure WPA_Supplicant receives all the event\n\t\t   generated due to DISASSOC call to the fw to keep\n\t\t   the state fw and WPA_Supplicant state consistent\n\t\t */\n\t\tbrcmf_delay(500);\n\t}\n\n\tbrcmf_abort_scanning(cfg);\n\tclear_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\n\n\treturn 0;\n}\n\ns32 brcmf_cfg80211_up(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err = 0;\n\n\tmutex_lock(&cfg->usr_sync);\n\terr = __brcmf_cfg80211_up(ifp);\n\tmutex_unlock(&cfg->usr_sync);\n\n\treturn err;\n}\n\ns32 brcmf_cfg80211_down(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err = 0;\n\n\tmutex_lock(&cfg->usr_sync);\n\terr = __brcmf_cfg80211_down(ifp);\n\tmutex_unlock(&cfg->usr_sync);\n\n\treturn err;\n}\n\nenum nl80211_iftype brcmf_cfg80211_get_iftype(struct brcmf_if *ifp)\n{\n\tstruct wireless_dev *wdev = &ifp->vif->wdev;\n\n\treturn wdev->iftype;\n}\n\nbool brcmf_get_vif_state_any(struct brcmf_cfg80211_info *cfg,\n\t\t\t     unsigned long state)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tlist_for_each_entry(vif, &cfg->vif_list, list) {\n\t\tif (test_bit(state, &vif->sme_state))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool vif_event_equals(struct brcmf_cfg80211_vif_event *event,\n\t\t\t\t    u8 action)\n{\n\tu8 evt_action;\n\n\tspin_lock(&event->vif_event_lock);\n\tevt_action = event->action;\n\tspin_unlock(&event->vif_event_lock);\n\treturn evt_action == action;\n}\n\nvoid brcmf_cfg80211_arm_vif_event(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  struct brcmf_cfg80211_vif *vif)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\n\tspin_lock(&event->vif_event_lock);\n\tevent->vif = vif;\n\tevent->action = 0;\n\tspin_unlock(&event->vif_event_lock);\n}\n\nbool brcmf_cfg80211_vif_event_armed(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\tbool armed;\n\n\tspin_lock(&event->vif_event_lock);\n\tarmed = event->vif != NULL;\n\tspin_unlock(&event->vif_event_lock);\n\n\treturn armed;\n}\n\nint brcmf_cfg80211_wait_vif_event(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  u8 action, ulong timeout)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\n\treturn wait_event_timeout(event->vif_wq,\n\t\t\t\t  vif_event_equals(event, action), timeout);\n}\n\nstatic s32 brcmf_translate_country_code(struct brcmf_pub *drvr, char alpha2[2],\n\t\t\t\t\tstruct brcmf_fil_country_le *ccreq)\n{\n\tstruct brcmfmac_pd_cc *country_codes;\n\tstruct brcmfmac_pd_cc_entry *cc;\n\ts32 found_index;\n\tint i;\n\n\tcountry_codes = drvr->settings->country_codes;\n\tif (!country_codes) {\n\t\tbrcmf_dbg(TRACE, \"No country codes configured for device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((alpha2[0] == ccreq->country_abbrev[0]) &&\n\t    (alpha2[1] == ccreq->country_abbrev[1])) {\n\t\tbrcmf_dbg(TRACE, \"Country code already set\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tfound_index = -1;\n\tfor (i = 0; i < country_codes->table_size; i++) {\n\t\tcc = &country_codes->table[i];\n\t\tif ((cc->iso3166[0] == '\\0') && (found_index == -1))\n\t\t\tfound_index = i;\n\t\tif ((cc->iso3166[0] == alpha2[0]) &&\n\t\t    (cc->iso3166[1] == alpha2[1])) {\n\t\t\tfound_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_index == -1) {\n\t\tbrcmf_dbg(TRACE, \"No country code match found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(ccreq, 0, sizeof(*ccreq));\n\tccreq->rev = cpu_to_le32(country_codes->table[found_index].rev);\n\tmemcpy(ccreq->ccode, country_codes->table[found_index].cc,\n\t       BRCMF_COUNTRY_BUF_SZ);\n\tccreq->country_abbrev[0] = alpha2[0];\n\tccreq->country_abbrev[1] = alpha2[1];\n\tccreq->country_abbrev[2] = 0;\n\n\treturn 0;\n}\n\nstatic void brcmf_cfg80211_reg_notifier(struct wiphy *wiphy,\n\t\t\t\t\tstruct regulatory_request *req)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct brcmf_fil_country_le ccreq;\n\ts32 err;\n\tint i;\n\n\t/* The country code gets set to \"00\" by default at boot, ignore */\n\tif (req->alpha2[0] == '0' && req->alpha2[1] == '0')\n\t\treturn;\n\n\t/* ignore non-ISO3166 country codes */\n\tfor (i = 0; i < sizeof(req->alpha2); i++)\n\t\tif (req->alpha2[i] < 'A' || req->alpha2[i] > 'Z') {\n\t\t\tbrcmf_err(\"not an ISO3166 code (0x%02x 0x%02x)\\n\",\n\t\t\t\t  req->alpha2[0], req->alpha2[1]);\n\t\t\treturn;\n\t\t}\n\n\tbrcmf_dbg(TRACE, \"Enter: initiator=%d, alpha=%c%c\\n\", req->initiator,\n\t\t  req->alpha2[0], req->alpha2[1]);\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"country\", &ccreq, sizeof(ccreq));\n\tif (err) {\n\t\tbrcmf_err(\"Country code iovar returned err = %d\\n\", err);\n\t\treturn;\n\t}\n\n\terr = brcmf_translate_country_code(ifp->drvr, req->alpha2, &ccreq);\n\tif (err)\n\t\treturn;\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"country\", &ccreq, sizeof(ccreq));\n\tif (err) {\n\t\tbrcmf_err(\"Firmware rejected country setting\\n\");\n\t\treturn;\n\t}\n\tbrcmf_setup_wiphybands(wiphy);\n}\n\nstatic void brcmf_free_wiphy(struct wiphy *wiphy)\n{\n\tint i;\n\n\tif (!wiphy)\n\t\treturn;\n\n\tif (wiphy->iface_combinations) {\n\t\tfor (i = 0; i < wiphy->n_iface_combinations; i++)\n\t\t\tkfree(wiphy->iface_combinations[i].limits);\n\t}\n\tkfree(wiphy->iface_combinations);\n\tif (wiphy->bands[NL80211_BAND_2GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]);\n\t}\n\tif (wiphy->bands[NL80211_BAND_5GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]);\n\t}\n#if IS_ENABLED(CONFIG_PM)\n\tif (wiphy->wowlan != &brcmf_wowlan_support)\n\t\tkfree(wiphy->wowlan);\n#endif\n\twiphy_free(wiphy);\n}\n\nstruct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,\n\t\t\t\t\t\t  struct device *busdev,\n\t\t\t\t\t\t  bool p2pdev_forced)\n{\n\tstruct net_device *ndev = brcmf_get_ifp(drvr, 0)->ndev;\n\tstruct brcmf_cfg80211_info *cfg;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_ops *ops;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\ts32 err = 0;\n\ts32 io_type;\n\tu16 *cap = NULL;\n\n\tif (!ndev) {\n\t\tbrcmf_err(\"ndev is invalid\\n\");\n\t\treturn NULL;\n\t}\n\n\tops = kmemdup(&brcmf_cfg80211_ops, sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn NULL;\n\n\tifp = netdev_priv(ndev);\n#ifdef CONFIG_PM\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK))\n\t\tops->set_rekey_data = brcmf_cfg80211_set_rekey_data;\n#endif\n\twiphy = wiphy_new(ops, sizeof(struct brcmf_cfg80211_info));\n\tif (!wiphy) {\n\t\tbrcmf_err(\"Could not allocate wiphy device\\n\");\n\t\tgoto ops_out;\n\t}\n\tmemcpy(wiphy->perm_addr, drvr->mac, ETH_ALEN);\n\tset_wiphy_dev(wiphy, busdev);\n\n\tcfg = wiphy_priv(wiphy);\n\tcfg->wiphy = wiphy;\n\tcfg->ops = ops;\n\tcfg->pub = drvr;\n\tinit_vif_event(&cfg->vif_event);\n\tINIT_LIST_HEAD(&cfg->vif_list);\n\n\tvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_STATION);\n\tif (IS_ERR(vif))\n\t\tgoto wiphy_out;\n\n\tvif->ifp = ifp;\n\tvif->wdev.netdev = ndev;\n\tndev->ieee80211_ptr = &vif->wdev;\n\tSET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));\n\n\terr = wl_init_priv(cfg);\n\tif (err) {\n\t\tbrcmf_err(\"Failed to init iwm_priv (%d)\\n\", err);\n\t\tbrcmf_free_vif(vif);\n\t\tgoto wiphy_out;\n\t}\n\tifp->vif = vif;\n\n\t/* determine d11 io type before wiphy setup */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_VERSION, &io_type);\n\tif (err) {\n\t\tbrcmf_err(\"Failed to get D11 version (%d)\\n\", err);\n\t\tgoto priv_out;\n\t}\n\tcfg->d11inf.io_type = (u8)io_type;\n\tbrcmu_d11_attach(&cfg->d11inf);\n\n\terr = brcmf_setup_wiphy(wiphy, ifp);\n\tif (err < 0)\n\t\tgoto priv_out;\n\n\tbrcmf_dbg(INFO, \"Registering custom regulatory\\n\");\n\twiphy->reg_notifier = brcmf_cfg80211_reg_notifier;\n\twiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;\n\twiphy_apply_custom_regulatory(wiphy, &brcmf_regdom);\n\n\t/* firmware defaults to 40MHz disabled in 2G band. We signal\n\t * cfg80211 here that we do and have it decide we can enable\n\t * it. But first check if device does support 2G operation.\n\t */\n\tif (wiphy->bands[NL80211_BAND_2GHZ]) {\n\t\tcap = &wiphy->bands[NL80211_BAND_2GHZ]->ht_cap.cap;\n\t\t*cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\terr = wiphy_register(wiphy);\n\tif (err < 0) {\n\t\tbrcmf_err(\"Could not register wiphy device (%d)\\n\", err);\n\t\tgoto priv_out;\n\t}\n\n\terr = brcmf_setup_wiphybands(wiphy);\n\tif (err) {\n\t\tbrcmf_err(\"Setting wiphy bands failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\t/* If cfg80211 didn't disable 40MHz HT CAP in wiphy_register(),\n\t * setup 40MHz in 2GHz band and enable OBSS scanning.\n\t */\n\tif (cap && (*cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)) {\n\t\terr = brcmf_enable_bw40_2g(cfg);\n\t\tif (!err)\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"obss_coex\",\n\t\t\t\t\t\t      BRCMF_OBSS_COEX_AUTO);\n\t\telse\n\t\t\t*cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\t/* p2p might require that \"if-events\" get processed by fweh. So\n\t * activate the already registered event handlers now and activate\n\t * the rest when initialization has completed. drvr->config needs to\n\t * be assigned before activating events.\n\t */\n\tdrvr->config = cfg;\n\terr = brcmf_fweh_activate_events(ifp);\n\tif (err) {\n\t\tbrcmf_err(\"FWEH activation failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\terr = brcmf_p2p_attach(cfg, p2pdev_forced);\n\tif (err) {\n\t\tbrcmf_err(\"P2P initialisation failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\terr = brcmf_btcoex_attach(cfg);\n\tif (err) {\n\t\tbrcmf_err(\"BT-coex initialisation failed (%d)\\n\", err);\n\t\tbrcmf_p2p_detach(&cfg->p2p);\n\t\tgoto wiphy_unreg_out;\n\t}\n\terr = brcmf_pno_attach(cfg);\n\tif (err) {\n\t\tbrcmf_err(\"PNO initialisation failed (%d)\\n\", err);\n\t\tbrcmf_btcoex_detach(cfg);\n\t\tbrcmf_p2p_detach(&cfg->p2p);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TDLS)) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"tdls_enable\", 1);\n\t\tif (err) {\n\t\t\tbrcmf_dbg(INFO, \"TDLS not enabled (%d)\\n\", err);\n\t\t\twiphy->flags &= ~WIPHY_FLAG_SUPPORTS_TDLS;\n\t\t} else {\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_TDLS_PEER_EVENT,\n\t\t\t\t\t    brcmf_notify_tdls_peer_event);\n\t\t}\n\t}\n\n\t/* (re-) activate FWEH event handling */\n\terr = brcmf_fweh_activate_events(ifp);\n\tif (err) {\n\t\tbrcmf_err(\"FWEH activation failed (%d)\\n\", err);\n\t\tgoto detach;\n\t}\n\n\t/* Fill in some of the advertised nl80211 supported features */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_SCAN_RANDOM_MAC)) {\n\t\twiphy->features |= NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR;\n#ifdef CONFIG_PM\n\t\tif (wiphy->wowlan &&\n\t\t    wiphy->wowlan->flags & WIPHY_WOWLAN_NET_DETECT)\n\t\t\twiphy->features |= NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n#endif\n\t}\n\n\treturn cfg;\n\ndetach:\n\tbrcmf_pno_detach(cfg);\n\tbrcmf_btcoex_detach(cfg);\n\tbrcmf_p2p_detach(&cfg->p2p);\nwiphy_unreg_out:\n\twiphy_unregister(cfg->wiphy);\npriv_out:\n\twl_deinit_priv(cfg);\n\tbrcmf_free_vif(vif);\n\tifp->vif = NULL;\nwiphy_out:\n\tbrcmf_free_wiphy(wiphy);\nops_out:\n\tkfree(ops);\n\treturn NULL;\n}\n\nvoid brcmf_cfg80211_detach(struct brcmf_cfg80211_info *cfg)\n{\n\tif (!cfg)\n\t\treturn;\n\n\tbrcmf_pno_detach(cfg);\n\tbrcmf_btcoex_detach(cfg);\n\twiphy_unregister(cfg->wiphy);\n\tkfree(cfg->ops);\n\twl_deinit_priv(cfg);\n\tbrcmf_free_wiphy(cfg->wiphy);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2010 Broadcom Corporation\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* Toplevel file. Relies on dhd_linux.c to send commands to the dongle. */\n\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <net/cfg80211.h>\n#include <net/netlink.h>\n\n#include <brcmu_utils.h>\n#include <defs.h>\n#include <brcmu_wifi.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"tracepoint.h\"\n#include \"fwil_types.h\"\n#include \"p2p.h\"\n#include \"btcoex.h\"\n#include \"pno.h\"\n#include \"cfg80211.h\"\n#include \"feature.h\"\n#include \"fwil.h\"\n#include \"proto.h\"\n#include \"vendor.h\"\n#include \"bus.h\"\n#include \"common.h\"\n\n#define BRCMF_SCAN_IE_LEN_MAX\t\t2048\n\n#define WPA_OUI\t\t\t\t\"\\x00\\x50\\xF2\"\t/* WPA OUI */\n#define WPA_OUI_TYPE\t\t\t1\n#define RSN_OUI\t\t\t\t\"\\x00\\x0F\\xAC\"\t/* RSN OUI */\n#define\tWME_OUI_TYPE\t\t\t2\n#define WPS_OUI_TYPE\t\t\t4\n\n#define VS_IE_FIXED_HDR_LEN\t\t6\n#define WPA_IE_VERSION_LEN\t\t2\n#define WPA_IE_MIN_OUI_LEN\t\t4\n#define WPA_IE_SUITE_COUNT_LEN\t\t2\n\n#define WPA_CIPHER_NONE\t\t\t0\t/* None */\n#define WPA_CIPHER_WEP_40\t\t1\t/* WEP (40-bit) */\n#define WPA_CIPHER_TKIP\t\t\t2\t/* TKIP: default for WPA */\n#define WPA_CIPHER_AES_CCM\t\t4\t/* AES (CCM) */\n#define WPA_CIPHER_WEP_104\t\t5\t/* WEP (104-bit) */\n\n#define RSN_AKM_NONE\t\t\t0\t/* None (IBSS) */\n#define RSN_AKM_UNSPECIFIED\t\t1\t/* Over 802.1x */\n#define RSN_AKM_PSK\t\t\t2\t/* Pre-shared Key */\n#define RSN_AKM_SHA256_1X\t\t5\t/* SHA256, 802.1X */\n#define RSN_AKM_SHA256_PSK\t\t6\t/* SHA256, Pre-shared Key */\n#define RSN_CAP_LEN\t\t\t2\t/* Length of RSN capabilities */\n#define RSN_CAP_PTK_REPLAY_CNTR_MASK\t(BIT(2) | BIT(3))\n#define RSN_CAP_MFPR_MASK\t\tBIT(6)\n#define RSN_CAP_MFPC_MASK\t\tBIT(7)\n#define RSN_PMKID_COUNT_LEN\t\t2\n\n#define VNDR_IE_CMD_LEN\t\t\t4\t/* length of the set command\n\t\t\t\t\t\t * string :\"add\", \"del\" (+ NUL)\n\t\t\t\t\t\t */\n#define VNDR_IE_COUNT_OFFSET\t\t4\n#define VNDR_IE_PKTFLAG_OFFSET\t\t8\n#define VNDR_IE_VSIE_OFFSET\t\t12\n#define VNDR_IE_HDR_SIZE\t\t12\n#define VNDR_IE_PARSE_LIMIT\t\t5\n\n#define\tDOT11_MGMT_HDR_LEN\t\t24\t/* d11 management header len */\n#define\tDOT11_BCN_PRB_FIXED_LEN\t\t12\t/* beacon/probe fixed length */\n\n#define BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS\t320\n#define BRCMF_SCAN_JOIN_PASSIVE_DWELL_TIME_MS\t400\n#define BRCMF_SCAN_JOIN_PROBE_INTERVAL_MS\t20\n\n#define BRCMF_SCAN_CHANNEL_TIME\t\t40\n#define BRCMF_SCAN_UNASSOC_TIME\t\t40\n#define BRCMF_SCAN_PASSIVE_TIME\t\t120\n\n#define BRCMF_ND_INFO_TIMEOUT\t\tmsecs_to_jiffies(2000)\n\n#define BRCMF_ASSOC_PARAMS_FIXED_SIZE \\\n\t(sizeof(struct brcmf_assoc_params_le) - sizeof(u16))\n\nstatic bool check_vif_up(struct brcmf_cfg80211_vif *vif)\n{\n\tif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state)) {\n\t\tbrcmf_dbg(INFO, \"device is not ready : status (%lu)\\n\",\n\t\t\t  vif->sme_state);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#define RATE_TO_BASE100KBPS(rate)   (((rate) * 10) / 2)\n#define RATETAB_ENT(_rateid, _flags) \\\n\t{                                                               \\\n\t\t.bitrate        = RATE_TO_BASE100KBPS(_rateid),     \\\n\t\t.hw_value       = (_rateid),                            \\\n\t\t.flags          = (_flags),                             \\\n\t}\n\nstatic struct ieee80211_rate __wl_rates[] = {\n\tRATETAB_ENT(BRCM_RATE_1M, 0),\n\tRATETAB_ENT(BRCM_RATE_2M, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_5M5, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_11M, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_6M, 0),\n\tRATETAB_ENT(BRCM_RATE_9M, 0),\n\tRATETAB_ENT(BRCM_RATE_12M, 0),\n\tRATETAB_ENT(BRCM_RATE_18M, 0),\n\tRATETAB_ENT(BRCM_RATE_24M, 0),\n\tRATETAB_ENT(BRCM_RATE_36M, 0),\n\tRATETAB_ENT(BRCM_RATE_48M, 0),\n\tRATETAB_ENT(BRCM_RATE_54M, 0),\n};\n\n#define wl_g_rates\t\t(__wl_rates + 0)\n#define wl_g_rates_size\t\tARRAY_SIZE(__wl_rates)\n#define wl_a_rates\t\t(__wl_rates + 4)\n#define wl_a_rates_size\t\t(wl_g_rates_size - 4)\n\n#define CHAN2G(_channel, _freq) {\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq\t\t= (_freq),\t\t\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\n#define CHAN5G(_channel) {\t\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_5GHZ,\t\t\\\n\t.center_freq\t\t= 5000 + (5 * (_channel)),\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\nstatic struct ieee80211_channel __wl_2ghz_channels[] = {\n\tCHAN2G(1, 2412), CHAN2G(2, 2417), CHAN2G(3, 2422), CHAN2G(4, 2427),\n\tCHAN2G(5, 2432), CHAN2G(6, 2437), CHAN2G(7, 2442), CHAN2G(8, 2447),\n\tCHAN2G(9, 2452), CHAN2G(10, 2457), CHAN2G(11, 2462), CHAN2G(12, 2467),\n\tCHAN2G(13, 2472), CHAN2G(14, 2484)\n};\n\nstatic struct ieee80211_channel __wl_5ghz_channels[] = {\n\tCHAN5G(34), CHAN5G(36), CHAN5G(38), CHAN5G(40), CHAN5G(42),\n\tCHAN5G(44), CHAN5G(46), CHAN5G(48), CHAN5G(52), CHAN5G(56),\n\tCHAN5G(60), CHAN5G(64), CHAN5G(100), CHAN5G(104), CHAN5G(108),\n\tCHAN5G(112), CHAN5G(116), CHAN5G(120), CHAN5G(124), CHAN5G(128),\n\tCHAN5G(132), CHAN5G(136), CHAN5G(140), CHAN5G(144), CHAN5G(149),\n\tCHAN5G(153), CHAN5G(157), CHAN5G(161), CHAN5G(165)\n};\n\n/* Band templates duplicated per wiphy. The channel info\n * above is added to the band during setup.\n */\nstatic const struct ieee80211_supported_band __wl_band_2ghz = {\n\t.band = NL80211_BAND_2GHZ,\n\t.bitrates = wl_g_rates,\n\t.n_bitrates = wl_g_rates_size,\n};\n\nstatic const struct ieee80211_supported_band __wl_band_5ghz = {\n\t.band = NL80211_BAND_5GHZ,\n\t.bitrates = wl_a_rates,\n\t.n_bitrates = wl_a_rates_size,\n};\n\n/* This is to override regulatory domains defined in cfg80211 module (reg.c)\n * By default world regulatory domain defined in reg.c puts the flags\n * NL80211_RRF_NO_IR for 5GHz channels (for * 36..48 and 149..165).\n * With respect to these flags, wpa_supplicant doesn't * start p2p\n * operations on 5GHz channels. All the changes in world regulatory\n * domain are to be done here.\n */\nstatic const struct ieee80211_regdomain brcmf_regdom = {\n\t.n_reg_rules = 4,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\t/* IEEE 802.11b/g, channels 1..11 */\n\t\tREG_RULE(2412-10, 2472+10, 40, 6, 20, 0),\n\t\t/* If any */\n\t\t/* IEEE 802.11 channel 14 - Only JP enables\n\t\t * this and for 802.11b only\n\t\t */\n\t\tREG_RULE(2484-10, 2484+10, 20, 6, 20, 0),\n\t\t/* IEEE 802.11a, channel 36..64 */\n\t\tREG_RULE(5150-10, 5350+10, 80, 6, 20, 0),\n\t\t/* IEEE 802.11a, channel 100..165 */\n\t\tREG_RULE(5470-10, 5850+10, 80, 6, 20, 0), }\n};\n\n/* Note: brcmf_cipher_suites is an array of int defining which cipher suites\n * are supported. A pointer to this array and the number of entries is passed\n * on to upper layers. AES_CMAC defines whether or not the driver supports MFP.\n * So the cipher suite AES_CMAC has to be the last one in the array, and when\n * device does not support MFP then the number of suites will be decreased by 1\n */\nstatic const u32 brcmf_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\t/* Keep as last entry: */\n\tWLAN_CIPHER_SUITE_AES_CMAC\n};\n\n/* Vendor specific ie. id = 221, oui and type defines exact ie */\nstruct brcmf_vs_tlv {\n\tu8 id;\n\tu8 len;\n\tu8 oui[3];\n\tu8 oui_type;\n};\n\nstruct parsed_vndr_ie_info {\n\tu8 *ie_ptr;\n\tu32 ie_len;\t/* total length including id & length field */\n\tstruct brcmf_vs_tlv vndrie;\n};\n\nstruct parsed_vndr_ies {\n\tu32 count;\n\tstruct parsed_vndr_ie_info ie_info[VNDR_IE_PARSE_LIMIT];\n};\n\nstatic u8 nl80211_band_to_fwil(enum nl80211_band band)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\treturn WLC_BAND_2G;\n\tcase NL80211_BAND_5GHZ:\n\t\treturn WLC_BAND_5G;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u16 chandef_to_chanspec(struct brcmu_d11inf *d11inf,\n\t\t\t       struct cfg80211_chan_def *ch)\n{\n\tstruct brcmu_chan ch_inf;\n\ts32 primary_offset;\n\n\tbrcmf_dbg(TRACE, \"chandef: control %d center %d width %d\\n\",\n\t\t  ch->chan->center_freq, ch->center_freq1, ch->width);\n\tch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq1);\n\tprimary_offset = ch->chan->center_freq - ch->center_freq1;\n\tswitch (ch->width) {\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tch_inf.bw = BRCMU_CHAN_BW_20;\n\t\tWARN_ON(primary_offset != 0);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tch_inf.bw = BRCMU_CHAN_BW_40;\n\t\tif (primary_offset > 0)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_U;\n\t\telse\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_L;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tch_inf.bw = BRCMU_CHAN_BW_80;\n\t\tif (primary_offset == -30)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LL;\n\t\telse if (primary_offset == -10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LU;\n\t\telse if (primary_offset == 10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UL;\n\t\telse\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UU;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\tswitch (ch->chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tch_inf.band = BRCMU_CHAN_BAND_2G;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tch_inf.band = BRCMU_CHAN_BAND_5G;\n\t\tbreak;\n\tcase NL80211_BAND_60GHZ:\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\td11inf->encchspec(&ch_inf);\n\n\treturn ch_inf.chspec;\n}\n\nu16 channel_to_chanspec(struct brcmu_d11inf *d11inf,\n\t\t\tstruct ieee80211_channel *ch)\n{\n\tstruct brcmu_chan ch_inf;\n\n\tch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq);\n\tch_inf.bw = BRCMU_CHAN_BW_20;\n\td11inf->encchspec(&ch_inf);\n\n\treturn ch_inf.chspec;\n}\n\n/* Traverse a string of 1-byte tag/1-byte length/variable-length value\n * triples, returning a pointer to the substring whose first element\n * matches tag\n */\nstatic const struct brcmf_tlv *\nbrcmf_parse_tlvs(const void *buf, int buflen, uint key)\n{\n\tconst struct brcmf_tlv *elt = buf;\n\tint totlen = buflen;\n\n\t/* find tagged parameter */\n\twhile (totlen >= TLV_HDR_LEN) {\n\t\tint len = elt->len;\n\n\t\t/* validate remaining totlen */\n\t\tif ((elt->id == key) && (totlen >= (len + TLV_HDR_LEN)))\n\t\t\treturn elt;\n\n\t\telt = (struct brcmf_tlv *)((u8 *)elt + (len + TLV_HDR_LEN));\n\t\ttotlen -= (len + TLV_HDR_LEN);\n\t}\n\n\treturn NULL;\n}\n\n/* Is any of the tlvs the expected entry? If\n * not update the tlvs buffer pointer/length.\n */\nstatic bool\nbrcmf_tlv_has_ie(const u8 *ie, const u8 **tlvs, u32 *tlvs_len,\n\t\t const u8 *oui, u32 oui_len, u8 type)\n{\n\t/* If the contents match the OUI and the type */\n\tif (ie[TLV_LEN_OFF] >= oui_len + 1 &&\n\t    !memcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&\n\t    type == ie[TLV_BODY_OFF + oui_len]) {\n\t\treturn true;\n\t}\n\n\tif (tlvs == NULL)\n\t\treturn false;\n\t/* point to the next ie */\n\tie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;\n\t/* calculate the length of the rest of the buffer */\n\t*tlvs_len -= (int)(ie - *tlvs);\n\t/* update the pointer to the start of the buffer */\n\t*tlvs = ie;\n\n\treturn false;\n}\n\nstatic struct brcmf_vs_tlv *\nbrcmf_find_wpaie(const u8 *parse, u32 len)\n{\n\tconst struct brcmf_tlv *ie;\n\n\twhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\n\t\tif (brcmf_tlv_has_ie((const u8 *)ie, &parse, &len,\n\t\t\t\t     WPA_OUI, TLV_OUI_LEN, WPA_OUI_TYPE))\n\t\t\treturn (struct brcmf_vs_tlv *)ie;\n\t}\n\treturn NULL;\n}\n\nstatic struct brcmf_vs_tlv *\nbrcmf_find_wpsie(const u8 *parse, u32 len)\n{\n\tconst struct brcmf_tlv *ie;\n\n\twhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\n\t\tif (brcmf_tlv_has_ie((u8 *)ie, &parse, &len,\n\t\t\t\t     WPA_OUI, TLV_OUI_LEN, WPS_OUI_TYPE))\n\t\t\treturn (struct brcmf_vs_tlv *)ie;\n\t}\n\treturn NULL;\n}\n\nstatic int brcmf_vif_change_validate(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t     struct brcmf_cfg80211_vif *vif,\n\t\t\t\t     enum nl80211_iftype new_type)\n{\n\tstruct brcmf_cfg80211_vif *pos;\n\tbool check_combos = false;\n\tint ret = 0;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tlist_for_each_entry(pos, &cfg->vif_list, list)\n\t\tif (pos == vif) {\n\t\t\tparams.iftype_num[new_type]++;\n\t\t} else {\n\t\t\t/* concurrent interfaces so need check combinations */\n\t\t\tcheck_combos = true;\n\t\t\tparams.iftype_num[pos->wdev.iftype]++;\n\t\t}\n\n\tif (check_combos)\n\t\tret = cfg80211_check_combinations(cfg->wiphy, &params);\n\n\treturn ret;\n}\n\nstatic int brcmf_vif_add_validate(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  enum nl80211_iftype new_type)\n{\n\tstruct brcmf_cfg80211_vif *pos;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tlist_for_each_entry(pos, &cfg->vif_list, list)\n\t\tparams.iftype_num[pos->wdev.iftype]++;\n\n\tparams.iftype_num[new_type]++;\n\treturn cfg80211_check_combinations(cfg->wiphy, &params);\n}\n\nstatic void convert_key_from_CPU(struct brcmf_wsec_key *key,\n\t\t\t\t struct brcmf_wsec_key_le *key_le)\n{\n\tkey_le->index = cpu_to_le32(key->index);\n\tkey_le->len = cpu_to_le32(key->len);\n\tkey_le->algo = cpu_to_le32(key->algo);\n\tkey_le->flags = cpu_to_le32(key->flags);\n\tkey_le->rxiv.hi = cpu_to_le32(key->rxiv.hi);\n\tkey_le->rxiv.lo = cpu_to_le16(key->rxiv.lo);\n\tkey_le->iv_initialized = cpu_to_le32(key->iv_initialized);\n\tmemcpy(key_le->data, key->data, sizeof(key->data));\n\tmemcpy(key_le->ea, key->ea, sizeof(key->ea));\n}\n\nstatic int\nsend_key_to_dongle(struct brcmf_if *ifp, struct brcmf_wsec_key *key)\n{\n\tint err;\n\tstruct brcmf_wsec_key_le key_le;\n\n\tconvert_key_from_CPU(key, &key_le);\n\n\tbrcmf_netdev_wait_pend8021x(ifp);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"wsec_key\", &key_le,\n\t\t\t\t\tsizeof(key_le));\n\n\tif (err)\n\t\tbrcmf_err(\"wsec_key error (%d)\\n\", err);\n\treturn err;\n}\n\nstatic s32\nbrcmf_configure_arp_nd_offload(struct brcmf_if *ifp, bool enable)\n{\n\ts32 err;\n\tu32 mode;\n\n\tif (enable)\n\t\tmode = BRCMF_ARP_OL_AGENT | BRCMF_ARP_OL_PEER_AUTO_REPLY;\n\telse\n\t\tmode = 0;\n\n\t/* Try to set and enable ARP offload feature, this may fail, then it  */\n\t/* is simply not supported and err 0 will be returned                 */\n\terr = brcmf_fil_iovar_int_set(ifp, \"arp_ol\", mode);\n\tif (err) {\n\t\tbrcmf_dbg(TRACE, \"failed to set ARP offload mode to 0x%x, err = %d\\n\",\n\t\t\t  mode, err);\n\t\terr = 0;\n\t} else {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"arpoe\", enable);\n\t\tif (err) {\n\t\t\tbrcmf_dbg(TRACE, \"failed to configure (%d) ARP offload err = %d\\n\",\n\t\t\t\t  enable, err);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tbrcmf_dbg(TRACE, \"successfully configured (%d) ARP offload to 0x%x\\n\",\n\t\t\t\t  enable, mode);\n\t}\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"ndoe\", enable);\n\tif (err) {\n\t\tbrcmf_dbg(TRACE, \"failed to configure (%d) ND offload err = %d\\n\",\n\t\t\t  enable, err);\n\t\terr = 0;\n\t} else\n\t\tbrcmf_dbg(TRACE, \"successfully configured (%d) ND offload to 0x%x\\n\",\n\t\t\t  enable, mode);\n\n\treturn err;\n}\n\nstatic void\nbrcmf_cfg80211_update_proto_addr_mode(struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tifp = vif->ifp;\n\n\tif ((wdev->iftype == NL80211_IFTYPE_ADHOC) ||\n\t    (wdev->iftype == NL80211_IFTYPE_AP) ||\n\t    (wdev->iftype == NL80211_IFTYPE_P2P_GO))\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_DIRECT);\n\telse\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_INDIRECT);\n}\n\nstatic int brcmf_get_first_free_bsscfgidx(struct brcmf_pub *drvr)\n{\n\tint bsscfgidx;\n\n\tfor (bsscfgidx = 0; bsscfgidx < BRCMF_MAX_IFS; bsscfgidx++) {\n\t\t/* bsscfgidx 1 is reserved for legacy P2P */\n\t\tif (bsscfgidx == 1)\n\t\t\tcontinue;\n\t\tif (!drvr->iflist[bsscfgidx])\n\t\t\treturn bsscfgidx;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)\n{\n\tstruct brcmf_mbss_ssid_le mbss_ssid_le;\n\tint bsscfgidx;\n\tint err;\n\n\tmemset(&mbss_ssid_le, 0, sizeof(mbss_ssid_le));\n\tbsscfgidx = brcmf_get_first_free_bsscfgidx(ifp->drvr);\n\tif (bsscfgidx < 0)\n\t\treturn bsscfgidx;\n\n\tmbss_ssid_le.bsscfgidx = cpu_to_le32(bsscfgidx);\n\tmbss_ssid_le.SSID_len = cpu_to_le32(5);\n\tsprintf(mbss_ssid_le.SSID, \"ssid%d\" , bsscfgidx);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"bsscfg:ssid\", &mbss_ssid_le,\n\t\t\t\t\tsizeof(mbss_ssid_le));\n\tif (err < 0)\n\t\tbrcmf_err(\"setting ssid failed %d\\n\", err);\n\n\treturn err;\n}\n\n/**\n * brcmf_ap_add_vif() - create a new AP virtual interface for multiple BSS\n *\n * @wiphy: wiphy device of new interface.\n * @name: name of the new interface.\n * @params: contains mac address for AP device.\n */\nstatic\nstruct wireless_dev *brcmf_ap_add_vif(struct wiphy *wiphy, const char *name,\n\t\t\t\t      struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct brcmf_cfg80211_vif *vif;\n\tint err;\n\n\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tbrcmf_dbg(INFO, \"Adding vif \\\"%s\\\"\\n\", name);\n\n\tvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_AP);\n\tif (IS_ERR(vif))\n\t\treturn (struct wireless_dev *)vif;\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, vif);\n\n\terr = brcmf_cfg80211_request_ap_if(ifp);\n\tif (err) {\n\t\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\t\tgoto fail;\n\t}\n\n\t/* wait for firmware event */\n\terr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_ADD,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\tif (!err) {\n\t\tbrcmf_err(\"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\t/* interface created in firmware */\n\tifp = vif->ifp;\n\tif (!ifp) {\n\t\tbrcmf_err(\"no if pointer provided\\n\");\n\t\terr = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tstrncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);\n\terr = brcmf_net_attach(ifp, true);\n\tif (err) {\n\t\tbrcmf_err(\"Registering netdevice failed\\n\");\n\t\tfree_netdev(ifp->ndev);\n\t\tgoto fail;\n\t}\n\n\treturn &ifp->vif->wdev;\n\nfail:\n\tbrcmf_free_vif(vif);\n\treturn ERR_PTR(err);\n}\n\nstatic bool brcmf_is_apmode(struct brcmf_cfg80211_vif *vif)\n{\n\tenum nl80211_iftype iftype;\n\n\tiftype = vif->wdev.iftype;\n\treturn iftype == NL80211_IFTYPE_AP || iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nstatic bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif)\n{\n\treturn vif->wdev.iftype == NL80211_IFTYPE_ADHOC;\n}\n\nstatic struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t\t\t     struct vif_params *params)\n{\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"enter: %s type %d\\n\", name, type);\n\terr = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);\n\tif (err) {\n\t\tbrcmf_err(\"iface validation failed: err=%d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tcase NL80211_IFTYPE_AP:\n\t\twdev = brcmf_ap_add_vif(wiphy, name, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\twdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (IS_ERR(wdev))\n\t\tbrcmf_err(\"add iface %s type %d failed: err=%d\\n\",\n\t\t\t  name, type, (int)PTR_ERR(wdev));\n\telse\n\t\tbrcmf_cfg80211_update_proto_addr_mode(wdev);\n\n\treturn wdev;\n}\n\nstatic void brcmf_scan_config_mpc(struct brcmf_if *ifp, int mpc)\n{\n\tif (brcmf_feat_is_quirk_enabled(ifp, BRCMF_FEAT_QUIRK_NEED_MPC))\n\t\tbrcmf_set_mpc(ifp, mpc);\n}\n\nvoid brcmf_set_mpc(struct brcmf_if *ifp, int mpc)\n{\n\ts32 err = 0;\n\n\tif (check_vif_up(ifp->vif)) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"mpc\", mpc);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"fail to set mpc\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"MPC : %d\\n\", mpc);\n\t}\n}\n\ns32 brcmf_notify_escan_complete(struct brcmf_cfg80211_info *cfg,\n\t\t\t\tstruct brcmf_if *ifp, bool aborted,\n\t\t\t\tbool fw_abort)\n{\n\tstruct brcmf_scan_params_le params_le;\n\tstruct cfg80211_scan_request *scan_request;\n\tu64 reqid;\n\tu32 bucket;\n\ts32 err = 0;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\t/* clear scan request, because the FW abort can cause a second call */\n\t/* to this functon and might cause a double cfg80211_scan_done      */\n\tscan_request = cfg->scan_request;\n\tcfg->scan_request = NULL;\n\n\tif (timer_pending(&cfg->escan_timeout))\n\t\tdel_timer_sync(&cfg->escan_timeout);\n\n\tif (fw_abort) {\n\t\t/* Do a scan abort to stop the driver's scan engine */\n\t\tbrcmf_dbg(SCAN, \"ABORT scan in firmware\\n\");\n\t\tmemset(&params_le, 0, sizeof(params_le));\n\t\teth_broadcast_addr(params_le.bssid);\n\t\tparams_le.bss_type = DOT11_BSSTYPE_ANY;\n\t\tparams_le.scan_type = 0;\n\t\tparams_le.channel_num = cpu_to_le32(1);\n\t\tparams_le.nprobes = cpu_to_le32(1);\n\t\tparams_le.active_time = cpu_to_le32(-1);\n\t\tparams_le.passive_time = cpu_to_le32(-1);\n\t\tparams_le.home_time = cpu_to_le32(-1);\n\t\t/* Scan is aborted by setting channel_list[0] to -1 */\n\t\tparams_le.channel_list[0] = cpu_to_le16(-1);\n\t\t/* E-Scan (or anyother type) can be aborted by SCAN */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN,\n\t\t\t\t\t     &params_le, sizeof(params_le));\n\t\tif (err)\n\t\t\tbrcmf_err(\"Scan abort failed\\n\");\n\t}\n\n\tbrcmf_scan_config_mpc(ifp, 1);\n\n\t/*\n\t * e-scan can be initiated internally\n\t * which takes precedence.\n\t */\n\tif (cfg->int_escan_map) {\n\t\tbrcmf_dbg(SCAN, \"scheduled scan completed (%x)\\n\",\n\t\t\t  cfg->int_escan_map);\n\t\twhile (cfg->int_escan_map) {\n\t\t\tbucket = __ffs(cfg->int_escan_map);\n\t\t\tcfg->int_escan_map &= ~BIT(bucket);\n\t\t\treqid = brcmf_pno_find_reqid_by_bucket(cfg->pno,\n\t\t\t\t\t\t\t       bucket);\n\t\t\tif (!aborted) {\n\t\t\t\tbrcmf_dbg(SCAN, \"report results: reqid=%llu\\n\",\n\t\t\t\t\t  reqid);\n\t\t\t\tcfg80211_sched_scan_results(cfg_to_wiphy(cfg),\n\t\t\t\t\t\t\t    reqid);\n\t\t\t}\n\t\t}\n\t} else if (scan_request) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = aborted,\n\t\t};\n\n\t\tbrcmf_dbg(SCAN, \"ESCAN Completed scan: %s\\n\",\n\t\t\t  aborted ? \"Aborted\" : \"Done\");\n\t\tcfg80211_scan_done(scan_request, &info);\n\t}\n\tif (!test_and_clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\n\t\tbrcmf_dbg(SCAN, \"Scan complete, probably P2P scan\\n\");\n\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_del_ap_iface(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tint ret;\n\tint err;\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, ifp->vif);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"interface_remove\", NULL, 0);\n\tif (err) {\n\t\tbrcmf_err(\"interface_remove failed %d\\n\", err);\n\t\tgoto err_unarm;\n\t}\n\n\t/* wait for firmware event */\n\tret = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tif (!ret) {\n\t\tbrcmf_err(\"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto err_unarm;\n\t}\n\n\tbrcmf_remove_interface(ifp, true);\n\nerr_unarm:\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\treturn err;\n}\n\nstatic\nint brcmf_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\n\tif (ndev && ndev == cfg_to_ndev(cfg))\n\t\treturn -ENOTSUPP;\n\n\t/* vif event pending in firmware */\n\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\treturn -EBUSY;\n\n\tif (ndev) {\n\t\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status) &&\n\t\t    cfg->escan_info.ifp == netdev_priv(ndev))\n\t\t\tbrcmf_notify_escan_complete(cfg, netdev_priv(ndev),\n\t\t\t\t\t\t    true, true);\n\n\t\tbrcmf_fil_iovar_int_set(netdev_priv(ndev), \"mpc\", 1);\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn -EOPNOTSUPP;\n\tcase NL80211_IFTYPE_AP:\n\t\treturn brcmf_cfg80211_del_ap_iface(wiphy, wdev);\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn brcmf_p2p_del_vif(wiphy, wdev);\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic s32\nbrcmf_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t enum nl80211_iftype type,\n\t\t\t struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_vif *vif = ifp->vif;\n\ts32 infra = 0;\n\ts32 ap = 0;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d, type=%d\\n\", ifp->bsscfgidx,\n\t\t  type);\n\n\t/* WAR: There are a number of p2p interface related problems which\n\t * need to be handled initially (before doing the validate).\n\t * wpa_supplicant tends to do iface changes on p2p device/client/go\n\t * which are not always possible/allowed. However we need to return\n\t * OK otherwise the wpa_supplicant wont start. The situation differs\n\t * on configuration and setup (p2pon=1 module param). The first check\n\t * is to see if the request is a change to station for p2p iface.\n\t */\n\tif ((type == NL80211_IFTYPE_STATION) &&\n\t    ((vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) ||\n\t     (vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) ||\n\t     (vif->wdev.iftype == NL80211_IFTYPE_P2P_DEVICE))) {\n\t\tbrcmf_dbg(TRACE, \"Ignoring cmd for p2p if\\n\");\n\t\t/* Now depending on whether module param p2pon=1 was used the\n\t\t * response needs to be either 0 or EOPNOTSUPP. The reason is\n\t\t * that if p2pon=1 is used, but a newer supplicant is used then\n\t\t * we should return an error, as this combination wont work.\n\t\t * In other situations 0 is returned and supplicant will start\n\t\t * normally. It will give a trace in cfg80211, but it is the\n\t\t * only way to get it working. Unfortunately this will result\n\t\t * in situation where we wont support new supplicant in\n\t\t * combination with module param p2pon=1, but that is the way\n\t\t * it is. If the user tries this then unloading of driver might\n\t\t * fail/lock.\n\t\t */\n\t\tif (cfg->p2p.p2pdev_dynamically)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn 0;\n\t}\n\terr = brcmf_vif_change_validate(wiphy_to_cfg(wiphy), vif, type);\n\tif (err) {\n\t\tbrcmf_err(\"iface validation failed: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_WDS:\n\t\tbrcmf_err(\"type (%d) : currently we do not support this type\\n\",\n\t\t\t  type);\n\t\treturn -EOPNOTSUPP;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tinfra = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tinfra = 1;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tap = 1;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (ap) {\n\t\tif (type == NL80211_IFTYPE_P2P_GO) {\n\t\t\tbrcmf_dbg(INFO, \"IF Type = P2P GO\\n\");\n\t\t\terr = brcmf_p2p_ifchange(cfg, BRCMF_FIL_P2P_IF_GO);\n\t\t}\n\t\tif (!err) {\n\t\t\tbrcmf_dbg(INFO, \"IF Type = AP\\n\");\n\t\t}\n\t} else {\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, infra);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_INFRA error (%d)\\n\", err);\n\t\t\terr = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"IF Type = %s\\n\", brcmf_is_ibssmode(vif) ?\n\t\t\t  \"Adhoc\" : \"Infra\");\n\t}\n\tndev->ieee80211_ptr->iftype = type;\n\n\tbrcmf_cfg80211_update_proto_addr_mode(&vif->wdev);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn err;\n}\n\nstatic void brcmf_escan_prep(struct brcmf_cfg80211_info *cfg,\n\t\t\t     struct brcmf_scan_params_le *params_le,\n\t\t\t     struct cfg80211_scan_request *request)\n{\n\tu32 n_ssids;\n\tu32 n_channels;\n\ts32 i;\n\ts32 offset;\n\tu16 chanspec;\n\tchar *ptr;\n\tstruct brcmf_ssid_le ssid_le;\n\n\teth_broadcast_addr(params_le->bssid);\n\tparams_le->bss_type = DOT11_BSSTYPE_ANY;\n\tparams_le->scan_type = 0;\n\tparams_le->channel_num = 0;\n\tparams_le->nprobes = cpu_to_le32(-1);\n\tparams_le->active_time = cpu_to_le32(-1);\n\tparams_le->passive_time = cpu_to_le32(-1);\n\tparams_le->home_time = cpu_to_le32(-1);\n\tmemset(&params_le->ssid_le, 0, sizeof(params_le->ssid_le));\n\n\t/* if request is null exit so it will be all channel broadcast scan */\n\tif (!request)\n\t\treturn;\n\n\tn_ssids = request->n_ssids;\n\tn_channels = request->n_channels;\n\t/* Copy channel array if applicable */\n\tbrcmf_dbg(SCAN, \"### List of channelspecs to scan ### %d\\n\",\n\t\t  n_channels);\n\tif (n_channels > 0) {\n\t\tfor (i = 0; i < n_channels; i++) {\n\t\t\tchanspec = channel_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       request->channels[i]);\n\t\t\tbrcmf_dbg(SCAN, \"Chan : %d, Channel spec: %x\\n\",\n\t\t\t\t  request->channels[i]->hw_value, chanspec);\n\t\t\tparams_le->channel_list[i] = cpu_to_le16(chanspec);\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"Scanning all channels\\n\");\n\t}\n\t/* Copy ssid array if applicable */\n\tbrcmf_dbg(SCAN, \"### List of SSIDs to scan ### %d\\n\", n_ssids);\n\tif (n_ssids > 0) {\n\t\toffset = offsetof(struct brcmf_scan_params_le, channel_list) +\n\t\t\t\tn_channels * sizeof(u16);\n\t\toffset = roundup(offset, sizeof(u32));\n\t\tptr = (char *)params_le + offset;\n\t\tfor (i = 0; i < n_ssids; i++) {\n\t\t\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\t\t\tssid_le.SSID_len =\n\t\t\t\t\tcpu_to_le32(request->ssids[i].ssid_len);\n\t\t\tmemcpy(ssid_le.SSID, request->ssids[i].ssid,\n\t\t\t       request->ssids[i].ssid_len);\n\t\t\tif (!ssid_le.SSID_len)\n\t\t\t\tbrcmf_dbg(SCAN, \"%d: Broadcast scan\\n\", i);\n\t\t\telse\n\t\t\t\tbrcmf_dbg(SCAN, \"%d: scan for  %.32s size=%d\\n\",\n\t\t\t\t\t  i, ssid_le.SSID, ssid_le.SSID_len);\n\t\t\tmemcpy(ptr, &ssid_le, sizeof(ssid_le));\n\t\t\tptr += sizeof(ssid_le);\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"Broadcast scan %p\\n\", request->ssids);\n\t\tif ((request->ssids) && request->ssids->ssid_len) {\n\t\t\tbrcmf_dbg(SCAN, \"SSID %s len=%d\\n\",\n\t\t\t\t  params_le->ssid_le.SSID,\n\t\t\t\t  request->ssids->ssid_len);\n\t\t\tparams_le->ssid_le.SSID_len =\n\t\t\t\tcpu_to_le32(request->ssids->ssid_len);\n\t\t\tmemcpy(&params_le->ssid_le.SSID, request->ssids->ssid,\n\t\t\t\trequest->ssids->ssid_len);\n\t\t}\n\t}\n\t/* Adding mask to channel numbers */\n\tparams_le->channel_num =\n\t\tcpu_to_le32((n_ssids << BRCMF_SCAN_PARAMS_NSSID_SHIFT) |\n\t\t\t(n_channels & BRCMF_SCAN_PARAMS_COUNT_MASK));\n}\n\nstatic s32\nbrcmf_run_escan(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp,\n\t\tstruct cfg80211_scan_request *request)\n{\n\ts32 params_size = BRCMF_SCAN_PARAMS_FIXED_SIZE +\n\t\t\t  offsetof(struct brcmf_escan_params_le, params_le);\n\tstruct brcmf_escan_params_le *params;\n\ts32 err = 0;\n\n\tbrcmf_dbg(SCAN, \"E-SCAN START\\n\");\n\n\tif (request != NULL) {\n\t\t/* Allocate space for populating ssids in struct */\n\t\tparams_size += sizeof(u32) * ((request->n_channels + 1) / 2);\n\n\t\t/* Allocate space for populating ssids in struct */\n\t\tparams_size += sizeof(struct brcmf_ssid_le) * request->n_ssids;\n\t}\n\n\tparams = kzalloc(params_size, GFP_KERNEL);\n\tif (!params) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tBUG_ON(params_size + sizeof(\"escan\") >= BRCMF_DCMD_MEDLEN);\n\tbrcmf_escan_prep(cfg, &params->params_le, request);\n\tparams->version = cpu_to_le32(BRCMF_ESCAN_REQ_VERSION);\n\tparams->action = cpu_to_le16(WL_ESCAN_ACTION_START);\n\tparams->sync_id = cpu_to_le16(0x1234);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"escan\", params, params_size);\n\tif (err) {\n\t\tif (err == -EBUSY)\n\t\t\tbrcmf_dbg(INFO, \"system busy : escan canceled\\n\");\n\t\telse\n\t\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t}\n\n\tkfree(params);\nexit:\n\treturn err;\n}\n\nstatic s32\nbrcmf_do_escan(struct brcmf_if *ifp, struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err;\n\tu32 passive_scan;\n\tstruct brcmf_scan_results *results;\n\tstruct escan_info *escan = &cfg->escan_info;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\tescan->ifp = ifp;\n\tescan->wiphy = cfg->wiphy;\n\tescan->escan_state = WL_ESCAN_STATE_SCANNING;\n\tpassive_scan = cfg->active_scan ? 0 : 1;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PASSIVE_SCAN,\n\t\t\t\t    passive_scan);\n\tif (err) {\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tbrcmf_scan_config_mpc(ifp, 0);\n\tresults = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\n\tresults->version = 0;\n\tresults->count = 0;\n\tresults->buflen = WL_ESCAN_RESULTS_FIXED_SIZE;\n\n\terr = escan->run(cfg, ifp, request);\n\tif (err)\n\t\tbrcmf_scan_config_mpc(ifp, 1);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_escan(struct wiphy *wiphy, struct brcmf_cfg80211_vif *vif,\n\t\t     struct cfg80211_scan_request *request,\n\t\t     struct cfg80211_ssid *this_ssid)\n{\n\tstruct brcmf_if *ifp = vif->ifp;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct cfg80211_ssid *ssids;\n\tu32 passive_scan;\n\tbool escan_req;\n\tbool spec_scan;\n\ts32 err;\n\tstruct brcmf_ssid_le ssid_le;\n\tu32 SSID_len;\n\n\tbrcmf_dbg(SCAN, \"START ESCAN\\n\");\n\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning already: status (%lu)\\n\", cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning being aborted: status (%lu)\\n\",\n\t\t\t  cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning suppressed: status (%lu)\\n\",\n\t\t\t  cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state)) {\n\t\tbrcmf_err(\"Connecting: status (%lu)\\n\", ifp->vif->sme_state);\n\t\treturn -EAGAIN;\n\t}\n\n\t/* If scan req comes for p2p0, send it over primary I/F */\n\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\n\n\tescan_req = false;\n\tif (request) {\n\t\t/* scan bss */\n\t\tssids = request->ssids;\n\t\tescan_req = true;\n\t} else {\n\t\t/* scan in ibss */\n\t\t/* we don't do escan in ibss */\n\t\tssids = this_ssid;\n\t}\n\n\tcfg->scan_request = request;\n\tset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tif (escan_req) {\n\t\tcfg->escan_info.run = brcmf_run_escan;\n\t\terr = brcmf_p2p_scan_prep(wiphy, request, vif);\n\t\tif (err)\n\t\t\tgoto scan_out;\n\n\t\terr = brcmf_do_escan(vif->ifp, request);\n\t\tif (err)\n\t\t\tgoto scan_out;\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"ssid \\\"%s\\\", ssid_len (%d)\\n\",\n\t\t\t  ssids->ssid, ssids->ssid_len);\n\t\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\t\tSSID_len = min_t(u8, sizeof(ssid_le.SSID), ssids->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32(0);\n\t\tspec_scan = false;\n\t\tif (SSID_len) {\n\t\t\tmemcpy(ssid_le.SSID, ssids->ssid, SSID_len);\n\t\t\tssid_le.SSID_len = cpu_to_le32(SSID_len);\n\t\t\tspec_scan = true;\n\t\t} else\n\t\t\tbrcmf_dbg(SCAN, \"Broadcast scan\\n\");\n\n\t\tpassive_scan = cfg->active_scan ? 0 : 1;\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PASSIVE_SCAN,\n\t\t\t\t\t    passive_scan);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_PASSIVE_SCAN error (%d)\\n\", err);\n\t\t\tgoto scan_out;\n\t\t}\n\t\tbrcmf_scan_config_mpc(ifp, 0);\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN, &ssid_le,\n\t\t\t\t\t     sizeof(ssid_le));\n\t\tif (err) {\n\t\t\tif (err == -EBUSY)\n\t\t\t\tbrcmf_dbg(INFO, \"BUSY: scan for \\\"%s\\\" canceled\\n\",\n\t\t\t\t\t  ssid_le.SSID);\n\t\t\telse\n\t\t\t\tbrcmf_err(\"WLC_SCAN error (%d)\\n\", err);\n\n\t\t\tbrcmf_scan_config_mpc(ifp, 1);\n\t\t\tgoto scan_out;\n\t\t}\n\t}\n\n\t/* Arm scan timeout timer */\n\tmod_timer(&cfg->escan_timeout, jiffies +\n\t\t\tBRCMF_ESCAN_TIMER_INTERVAL_MS * HZ / 1000);\n\n\treturn 0;\n\nscan_out:\n\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tcfg->scan_request = NULL;\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tvif = container_of(request->wdev, struct brcmf_cfg80211_vif, wdev);\n\tif (!check_vif_up(vif))\n\t\treturn -EIO;\n\n\terr = brcmf_cfg80211_escan(wiphy, vif, request, NULL);\n\n\tif (err)\n\t\tbrcmf_err(\"scan error (%d)\\n\", err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32 brcmf_set_rts(struct net_device *ndev, u32 rts_threshold)\n{\n\ts32 err = 0;\n\n\terr = brcmf_fil_iovar_int_set(netdev_priv(ndev), \"rtsthresh\",\n\t\t\t\t      rts_threshold);\n\tif (err)\n\t\tbrcmf_err(\"Error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic s32 brcmf_set_frag(struct net_device *ndev, u32 frag_threshold)\n{\n\ts32 err = 0;\n\n\terr = brcmf_fil_iovar_int_set(netdev_priv(ndev), \"fragthresh\",\n\t\t\t\t      frag_threshold);\n\tif (err)\n\t\tbrcmf_err(\"Error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic s32 brcmf_set_retry(struct net_device *ndev, u32 retry, bool l)\n{\n\ts32 err = 0;\n\tu32 cmd = (l ? BRCMF_C_SET_LRL : BRCMF_C_SET_SRL);\n\n\terr = brcmf_fil_cmd_int_set(netdev_priv(ndev), cmd, retry);\n\tif (err) {\n\t\tbrcmf_err(\"cmd (%d) , error (%d)\\n\", cmd, err);\n\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic s32 brcmf_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD &&\n\t    (cfg->conf->rts_threshold != wiphy->rts_threshold)) {\n\t\tcfg->conf->rts_threshold = wiphy->rts_threshold;\n\t\terr = brcmf_set_rts(ndev, cfg->conf->rts_threshold);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD &&\n\t    (cfg->conf->frag_threshold != wiphy->frag_threshold)) {\n\t\tcfg->conf->frag_threshold = wiphy->frag_threshold;\n\t\terr = brcmf_set_frag(ndev, cfg->conf->frag_threshold);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_LONG\n\t    && (cfg->conf->retry_long != wiphy->retry_long)) {\n\t\tcfg->conf->retry_long = wiphy->retry_long;\n\t\terr = brcmf_set_retry(ndev, cfg->conf->retry_long, true);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_SHORT\n\t    && (cfg->conf->retry_short != wiphy->retry_short)) {\n\t\tcfg->conf->retry_short = wiphy->retry_short;\n\t\terr = brcmf_set_retry(ndev, cfg->conf->retry_short, false);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic void brcmf_init_prof(struct brcmf_cfg80211_profile *prof)\n{\n\tmemset(prof, 0, sizeof(*prof));\n}\n\nstatic u16 brcmf_map_fw_linkdown_reason(const struct brcmf_event_msg *e)\n{\n\tu16 reason;\n\n\tswitch (e->event_code) {\n\tcase BRCMF_E_DEAUTH:\n\tcase BRCMF_E_DEAUTH_IND:\n\tcase BRCMF_E_DISASSOC_IND:\n\t\treason = e->reason;\n\t\tbreak;\n\tcase BRCMF_E_LINK:\n\tdefault:\n\t\treason = 0;\n\t\tbreak;\n\t}\n\treturn reason;\n}\n\nstatic int brcmf_set_pmk(struct brcmf_if *ifp, const u8 *pmk_data, u16 pmk_len)\n{\n\tstruct brcmf_wsec_pmk_le pmk;\n\tint i, err;\n\n\t/* convert to firmware key format */\n\tpmk.key_len = cpu_to_le16(pmk_len << 1);\n\tpmk.flags = cpu_to_le16(BRCMF_WSEC_PASSPHRASE);\n\tfor (i = 0; i < pmk_len; i++)\n\t\tsnprintf(&pmk.key[2 * i], 3, \"%02x\", pmk_data[i]);\n\n\t/* store psk in firmware */\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_WSEC_PMK,\n\t\t\t\t     &pmk, sizeof(pmk));\n\tif (err < 0)\n\t\tbrcmf_err(\"failed to change PSK in firmware (len=%u)\\n\",\n\t\t\t  pmk_len);\n\n\treturn err;\n}\n\nstatic void brcmf_link_down(struct brcmf_cfg80211_vif *vif, u16 reason)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTED, &vif->sme_state)) {\n\t\tbrcmf_dbg(INFO, \"Call WLC_DISASSOC to stop excess roaming\\n \");\n\t\terr = brcmf_fil_cmd_data_set(vif->ifp,\n\t\t\t\t\t     BRCMF_C_DISASSOC, NULL, 0);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_DISASSOC failed (%d)\\n\", err);\n\t\t}\n\t\tif ((vif->wdev.iftype == NL80211_IFTYPE_STATION) ||\n\t\t    (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT))\n\t\t\tcfg80211_disconnected(vif->wdev.netdev, reason, NULL, 0,\n\t\t\t\t\t      true, GFP_KERNEL);\n\t}\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state);\n\tclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n\tbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\n\tif (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {\n\t\tbrcmf_set_pmk(vif->ifp, NULL, 0);\n\t\tvif->profile.use_fwsup = BRCMF_PROFILE_FWSUP_NONE;\n\t}\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n}\n\nstatic s32\nbrcmf_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\n\t\t      struct cfg80211_ibss_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size = 0;\n\ts32 err = 0;\n\ts32 wsec = 0;\n\ts32 bcnprd;\n\tu16 chanspec;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (params->ssid)\n\t\tbrcmf_dbg(CONN, \"SSID: %s\\n\", params->ssid);\n\telse {\n\t\tbrcmf_dbg(CONN, \"SSID: NULL, Not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (params->bssid)\n\t\tbrcmf_dbg(CONN, \"BSSID: %pM\\n\", params->bssid);\n\telse\n\t\tbrcmf_dbg(CONN, \"No BSSID specified\\n\");\n\n\tif (params->chandef.chan)\n\t\tbrcmf_dbg(CONN, \"channel: %d\\n\",\n\t\t\t  params->chandef.chan->center_freq);\n\telse\n\t\tbrcmf_dbg(CONN, \"no channel specified\\n\");\n\n\tif (params->channel_fixed)\n\t\tbrcmf_dbg(CONN, \"fixed channel required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no fixed channel required\\n\");\n\n\tif (params->ie && params->ie_len)\n\t\tbrcmf_dbg(CONN, \"ie len: %d\\n\", params->ie_len);\n\telse\n\t\tbrcmf_dbg(CONN, \"no ie specified\\n\");\n\n\tif (params->beacon_interval)\n\t\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\",\n\t\t\t  params->beacon_interval);\n\telse\n\t\tbrcmf_dbg(CONN, \"no beacon interval specified\\n\");\n\n\tif (params->basic_rates)\n\t\tbrcmf_dbg(CONN, \"basic rates: %08X\\n\", params->basic_rates);\n\telse\n\t\tbrcmf_dbg(CONN, \"no basic rates specified\\n\");\n\n\tif (params->privacy)\n\t\tbrcmf_dbg(CONN, \"privacy required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no privacy required\\n\");\n\n\t/* Configure Privacy for starter */\n\tif (params->privacy)\n\t\twsec |= WEP_ENABLED;\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"wsec failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure Beacon Interval for starter */\n\tif (params->beacon_interval)\n\t\tbcnprd = params->beacon_interval;\n\telse\n\t\tbcnprd = 100;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_BCNPRD failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure required join parameter */\n\tmemset(&join_params, 0, sizeof(struct brcmf_join_params));\n\n\t/* SSID */\n\tssid_len = min_t(u32, params->ssid_len, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(join_params.ssid_le.SSID, params->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\t/* BSSID */\n\tif (params->bssid) {\n\t\tmemcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);\n\t\tjoin_params_size += BRCMF_ASSOC_PARAMS_FIXED_SIZE;\n\t\tmemcpy(profile->bssid, params->bssid, ETH_ALEN);\n\t} else {\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\t\teth_zero_addr(profile->bssid);\n\t}\n\n\t/* Channel */\n\tif (params->chandef.chan) {\n\t\tu32 target_channel;\n\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(\n\t\t\t\tparams->chandef.chan->center_freq);\n\t\tif (params->channel_fixed) {\n\t\t\t/* adding chanspec */\n\t\t\tchanspec = chandef_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       &params->chandef);\n\t\t\tjoin_params.params_le.chanspec_list[0] =\n\t\t\t\tcpu_to_le16(chanspec);\n\t\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\t\tjoin_params_size += sizeof(join_params.params_le);\n\t\t}\n\n\t\t/* set channel for starter */\n\t\ttarget_channel = cfg->channel;\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,\n\t\t\t\t\t    target_channel);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_CHANNEL failed (%d)\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tcfg->channel = 0;\n\n\tcfg->ibss_starter = false;\n\n\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_SSID failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif)) {\n\t\t/* When driver is being unloaded, it can end up here. If an\n\t\t * error is returned then later on a debug trace in the wireless\n\t\t * core module will be printed. To avoid this 0 is returned.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tbrcmf_link_down(ifp->vif, WLAN_REASON_DEAUTH_LEAVING);\n\tbrcmf_net_setcarrier(ifp, false);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn 0;\n}\n\nstatic s32 brcmf_set_wpa_version(struct net_device *ndev,\n\t\t\t\t struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 val = 0;\n\ts32 err = 0;\n\n\tif (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\tval = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;\n\telse if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\tval = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;\n\telse\n\t\tval = WPA_AUTH_DISABLED;\n\tbrcmf_dbg(CONN, \"setting wpa_auth to 0x%0x\\n\", val);\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"wpa_auth\", val);\n\tif (err) {\n\t\tbrcmf_err(\"set wpa_auth failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsec = &profile->sec;\n\tsec->wpa_versions = sme->crypto.wpa_versions;\n\treturn err;\n}\n\nstatic s32 brcmf_set_auth_type(struct net_device *ndev,\n\t\t\t       struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 val = 0;\n\ts32 err = 0;\n\n\tswitch (sme->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tval = 0;\n\t\tbrcmf_dbg(CONN, \"open system\\n\");\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tval = 1;\n\t\tbrcmf_dbg(CONN, \"shared key\\n\");\n\t\tbreak;\n\tdefault:\n\t\tval = 2;\n\t\tbrcmf_dbg(CONN, \"automatic, auth type (%d)\\n\", sme->auth_type);\n\t\tbreak;\n\t}\n\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"auth\", val);\n\tif (err) {\n\t\tbrcmf_err(\"set auth failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsec = &profile->sec;\n\tsec->auth_type = sme->auth_type;\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_wsec_mode(struct net_device *ndev,\n\t\t    struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 pval = 0;\n\ts32 gval = 0;\n\ts32 wsec;\n\ts32 err = 0;\n\n\tif (sme->crypto.n_ciphers_pairwise) {\n\t\tswitch (sme->crypto.ciphers_pairwise[0]) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tpval = WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tpval = TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tpval = AES_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tpval = AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher pairwise (%d)\\n\",\n\t\t\t\t  sme->crypto.ciphers_pairwise[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sme->crypto.cipher_group) {\n\t\tswitch (sme->crypto.cipher_group) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tgval = WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tgval = TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tgval = AES_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tgval = AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher group (%d)\\n\",\n\t\t\t\t  sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbrcmf_dbg(CONN, \"pval (%d) gval (%d)\\n\", pval, gval);\n\t/* In case of privacy, but no security and WPS then simulate */\n\t/* setting AES. WPS-2.0 allows no security                   */\n\tif (brcmf_find_wpsie(sme->ie, sme->ie_len) && !pval && !gval &&\n\t    sme->privacy)\n\t\tpval = AES_ENABLED;\n\n\twsec = pval | gval;\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tsec = &profile->sec;\n\tsec->cipher_pairwise = sme->crypto.ciphers_pairwise[0];\n\tsec->cipher_group = sme->crypto.cipher_group;\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\ts32 val;\n\ts32 err;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst u8 *ie;\n\tu32 ie_len;\n\tu32 offset;\n\tu16 rsn_cap;\n\tu32 mfp;\n\tu16 count;\n\n\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_NONE;\n\n\tif (!sme->crypto.n_akm_suites)\n\t\treturn 0;\n\n\terr = brcmf_fil_bsscfg_int_get(netdev_priv(ndev), \"wpa_auth\", &val);\n\tif (err) {\n\t\tbrcmf_err(\"could not get wpa_auth (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tif (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {\n\t\tswitch (sme->crypto.akm_suites[0]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tval = WPA_AUTH_UNSPECIFIED;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tval = WPA_AUTH_PSK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher group (%d)\\n\",\n\t\t\t\t  sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {\n\t\tswitch (sme->crypto.akm_suites[0]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tval = WPA2_AUTH_UNSPECIFIED;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_8021X_SHA256:\n\t\t\tval = WPA2_AUTH_1X_SHA256;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK_SHA256:\n\t\t\tval = WPA2_AUTH_PSK_SHA256;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tval = WPA2_AUTH_PSK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"invalid cipher group (%d)\\n\",\n\t\t\t\t  sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (profile->use_fwsup == BRCMF_PROFILE_FWSUP_1X)\n\t\tbrcmf_dbg(INFO, \"using 1X offload\\n\");\n\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\tgoto skip_mfp_config;\n\t/* The MFP mode (1 or 2) needs to be determined, parse IEs. The\n\t * IE will not be verified, just a quick search for MFP config\n\t */\n\trsn_ie = brcmf_parse_tlvs((const u8 *)sme->ie, sme->ie_len,\n\t\t\t\t  WLAN_EID_RSN);\n\tif (!rsn_ie)\n\t\tgoto skip_mfp_config;\n\tie = (const u8 *)rsn_ie;\n\tie_len = rsn_ie->len + TLV_HDR_LEN;\n\t/* Skip unicast suite */\n\toffset = TLV_HDR_LEN + WPA_IE_VERSION_LEN + WPA_IE_MIN_OUI_LEN;\n\tif (offset + WPA_IE_SUITE_COUNT_LEN >= ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Skip multicast suite */\n\tcount = ie[offset] + (ie[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN + (count * WPA_IE_MIN_OUI_LEN);\n\tif (offset + WPA_IE_SUITE_COUNT_LEN >= ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Skip auth key management suite(s) */\n\tcount = ie[offset] + (ie[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN + (count * WPA_IE_MIN_OUI_LEN);\n\tif (offset + WPA_IE_SUITE_COUNT_LEN > ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Ready to read capabilities */\n\tmfp = BRCMF_MFP_NONE;\n\trsn_cap = ie[offset] + (ie[offset + 1] << 8);\n\tif (rsn_cap & RSN_CAP_MFPR_MASK)\n\t\tmfp = BRCMF_MFP_REQUIRED;\n\telse if (rsn_cap & RSN_CAP_MFPC_MASK)\n\t\tmfp = BRCMF_MFP_CAPABLE;\n\tbrcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"mfp\", mfp);\n\nskip_mfp_config:\n\tbrcmf_dbg(CONN, \"setting wpa_auth to %d\\n\", val);\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"wpa_auth\", val);\n\tif (err) {\n\t\tbrcmf_err(\"could not set wpa_auth (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_sharedkey(struct net_device *ndev,\n\t\t    struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\tstruct brcmf_wsec_key key;\n\ts32 val;\n\ts32 err = 0;\n\n\tbrcmf_dbg(CONN, \"key len (%d)\\n\", sme->key_len);\n\n\tif (sme->key_len == 0)\n\t\treturn 0;\n\n\tsec = &profile->sec;\n\tbrcmf_dbg(CONN, \"wpa_versions 0x%x cipher_pairwise 0x%x\\n\",\n\t\t  sec->wpa_versions, sec->cipher_pairwise);\n\n\tif (sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))\n\t\treturn 0;\n\n\tif (!(sec->cipher_pairwise &\n\t    (WLAN_CIPHER_SUITE_WEP40 | WLAN_CIPHER_SUITE_WEP104)))\n\t\treturn 0;\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.len = (u32) sme->key_len;\n\tkey.index = (u32) sme->key_idx;\n\tif (key.len > sizeof(key.data)) {\n\t\tbrcmf_err(\"Too long key length (%u)\\n\", key.len);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(key.data, sme->key, key.len);\n\tkey.flags = BRCMF_PRIMARY_KEY;\n\tswitch (sec->cipher_pairwise) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey.algo = CRYPTO_ALGO_WEP1;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey.algo = CRYPTO_ALGO_WEP128;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"Invalid algorithm (%d)\\n\",\n\t\t\t  sme->crypto.ciphers_pairwise[0]);\n\t\treturn -EINVAL;\n\t}\n\t/* Set the new key/index */\n\tbrcmf_dbg(CONN, \"key length (%d) key index (%d) algo (%d)\\n\",\n\t\t  key.len, key.index, key.algo);\n\tbrcmf_dbg(CONN, \"key \\\"%s\\\"\\n\", key.data);\n\terr = send_key_to_dongle(netdev_priv(ndev), &key);\n\tif (err)\n\t\treturn err;\n\n\tif (sec->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {\n\t\tbrcmf_dbg(CONN, \"set auth_type to shared key\\n\");\n\t\tval = WL_AUTH_SHARED_KEY;\t/* shared key */\n\t\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"auth\", val);\n\t\tif (err)\n\t\t\tbrcmf_err(\"set auth failed (%d)\\n\", err);\n\t}\n\treturn err;\n}\n\nstatic\nenum nl80211_auth_type brcmf_war_auth_type(struct brcmf_if *ifp,\n\t\t\t\t\t   enum nl80211_auth_type type)\n{\n\tif (type == NL80211_AUTHTYPE_AUTOMATIC &&\n\t    brcmf_feat_is_quirk_enabled(ifp, BRCMF_FEAT_QUIRK_AUTO_AUTH)) {\n\t\tbrcmf_dbg(CONN, \"WAR: use OPEN instead of AUTO\\n\");\n\t\ttype = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t}\n\treturn type;\n}\n\nstatic void brcmf_set_join_pref(struct brcmf_if *ifp,\n\t\t\t\tstruct cfg80211_bss_selection *bss_select)\n{\n\tstruct brcmf_join_pref_params join_pref_params[2];\n\tenum nl80211_band band;\n\tint err, i = 0;\n\n\tjoin_pref_params[i].len = 2;\n\tjoin_pref_params[i].rssi_gain = 0;\n\n\tif (bss_select->behaviour != NL80211_BSS_SELECT_ATTR_BAND_PREF)\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_ASSOC_PREFER, WLC_BAND_AUTO);\n\n\tswitch (bss_select->behaviour) {\n\tcase __NL80211_BSS_SELECT_ATTR_INVALID:\n\t\tbrcmf_c_set_joinpref_default(ifp);\n\t\treturn;\n\tcase NL80211_BSS_SELECT_ATTR_BAND_PREF:\n\t\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_BAND;\n\t\tband = bss_select->param.band_pref;\n\t\tjoin_pref_params[i].band = nl80211_band_to_fwil(band);\n\t\ti++;\n\t\tbreak;\n\tcase NL80211_BSS_SELECT_ATTR_RSSI_ADJUST:\n\t\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_RSSI_DELTA;\n\t\tband = bss_select->param.adjust.band;\n\t\tjoin_pref_params[i].band = nl80211_band_to_fwil(band);\n\t\tjoin_pref_params[i].rssi_gain = bss_select->param.adjust.delta;\n\t\ti++;\n\t\tbreak;\n\tcase NL80211_BSS_SELECT_ATTR_RSSI:\n\tdefault:\n\t\tbreak;\n\t}\n\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_RSSI;\n\tjoin_pref_params[i].len = 2;\n\tjoin_pref_params[i].rssi_gain = 0;\n\tjoin_pref_params[i].band = 0;\n\terr = brcmf_fil_iovar_data_set(ifp, \"join_pref\", join_pref_params,\n\t\t\t\t       sizeof(join_pref_params));\n\tif (err)\n\t\tbrcmf_err(\"Set join_pref error (%d)\\n\", err);\n}\n\nstatic s32\nbrcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct ieee80211_channel *chan = sme->channel;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tconst void *ie;\n\tu32 ie_len;\n\tstruct brcmf_ext_join_params_le *ext_join_params;\n\tu16 chanspec;\n\ts32 err = 0;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (!sme->ssid) {\n\t\tbrcmf_err(\"Invalid ssid\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif) {\n\t\t/* A normal (non P2P) connection request setup. */\n\t\tie = NULL;\n\t\tie_len = 0;\n\t\t/* find the WPA_IE */\n\t\twpa_ie = brcmf_find_wpaie((u8 *)sme->ie, sme->ie_len);\n\t\tif (wpa_ie) {\n\t\t\tie = wpa_ie;\n\t\t\tie_len = wpa_ie->len + TLV_HDR_LEN;\n\t\t} else {\n\t\t\t/* find the RSN_IE */\n\t\t\trsn_ie = brcmf_parse_tlvs((const u8 *)sme->ie,\n\t\t\t\t\t\t  sme->ie_len,\n\t\t\t\t\t\t  WLAN_EID_RSN);\n\t\t\tif (rsn_ie) {\n\t\t\t\tie = rsn_ie;\n\t\t\t\tie_len = rsn_ie->len + TLV_HDR_LEN;\n\t\t\t}\n\t\t}\n\t\tbrcmf_fil_iovar_data_set(ifp, \"wpaie\", ie, ie_len);\n\t}\n\n\terr = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,\n\t\t\t\t    sme->ie, sme->ie_len);\n\tif (err)\n\t\tbrcmf_err(\"Set Assoc REQ IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Assoc request\\n\");\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (chan) {\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(chan->center_freq);\n\t\tchanspec = channel_to_chanspec(&cfg->d11inf, chan);\n\t\tbrcmf_dbg(CONN, \"channel=%d, center_req=%d, chanspec=0x%04x\\n\",\n\t\t\t  cfg->channel, chan->center_freq, chanspec);\n\t} else {\n\t\tcfg->channel = 0;\n\t\tchanspec = 0;\n\t}\n\n\tbrcmf_dbg(INFO, \"ie (%p), ie_len (%zd)\\n\", sme->ie, sme->ie_len);\n\n\terr = brcmf_set_wpa_version(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_wpa_version failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tsme->auth_type = brcmf_war_auth_type(ifp, sme->auth_type);\n\terr = brcmf_set_auth_type(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_auth_type failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_wsec_mode(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_set_cipher failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_key_mgmt(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"wl_set_key_mgmt failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_sharedkey(ndev, sme);\n\tif (err) {\n\t\tbrcmf_err(\"brcmf_set_sharedkey failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tif (sme->crypto.psk) {\n\t\tif (WARN_ON(profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"using PSK offload\\n\");\n\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_PSK;\n\t}\n\n\tif (profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {\n\t\t/* enable firmware supplicant for this interface */\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"sup_wpa\", 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"failed to enable fw supplicant\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (profile->use_fwsup == BRCMF_PROFILE_FWSUP_PSK) {\n\t\terr = brcmf_set_pmk(ifp, sme->crypto.psk,\n\t\t\t\t    BRCMF_WSEC_MAX_PSK_LEN);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\t/* Join with specific BSSID and cached SSID\n\t * If SSID is zero join based on BSSID only\n\t */\n\tjoin_params_size = offsetof(struct brcmf_ext_join_params_le, assoc_le) +\n\t\toffsetof(struct brcmf_assoc_params_le, chanspec_list);\n\tif (cfg->channel)\n\t\tjoin_params_size += sizeof(u16);\n\text_join_params = kzalloc(join_params_size, GFP_KERNEL);\n\tif (ext_join_params == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tssid_len = min_t(u32, sme->ssid_len, IEEE80211_MAX_SSID_LEN);\n\text_join_params->ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tmemcpy(&ext_join_params->ssid_le.SSID, sme->ssid, ssid_len);\n\tif (ssid_len < IEEE80211_MAX_SSID_LEN)\n\t\tbrcmf_dbg(CONN, \"SSID \\\"%s\\\", len (%d)\\n\",\n\t\t\t  ext_join_params->ssid_le.SSID, ssid_len);\n\n\t/* Set up join scan parameters */\n\text_join_params->scan_le.scan_type = -1;\n\text_join_params->scan_le.home_time = cpu_to_le32(-1);\n\n\tif (sme->bssid)\n\t\tmemcpy(&ext_join_params->assoc_le.bssid, sme->bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(ext_join_params->assoc_le.bssid);\n\n\tif (cfg->channel) {\n\t\text_join_params->assoc_le.chanspec_num = cpu_to_le32(1);\n\n\t\text_join_params->assoc_le.chanspec_list[0] =\n\t\t\tcpu_to_le16(chanspec);\n\t\t/* Increase dwell time to receive probe response or detect\n\t\t * beacon from target AP at a noisy air only during connect\n\t\t * command.\n\t\t */\n\t\text_join_params->scan_le.active_time =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS);\n\t\text_join_params->scan_le.passive_time =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_PASSIVE_DWELL_TIME_MS);\n\t\t/* To sync with presence period of VSDB GO send probe request\n\t\t * more frequently. Probe request will be stopped when it gets\n\t\t * probe response from target AP/GO.\n\t\t */\n\t\text_join_params->scan_le.nprobes =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS /\n\t\t\t\t    BRCMF_SCAN_JOIN_PROBE_INTERVAL_MS);\n\t} else {\n\t\text_join_params->scan_le.active_time = cpu_to_le32(-1);\n\t\text_join_params->scan_le.passive_time = cpu_to_le32(-1);\n\t\text_join_params->scan_le.nprobes = cpu_to_le32(-1);\n\t}\n\n\tbrcmf_set_join_pref(ifp, &sme->bss_select);\n\n\terr  = brcmf_fil_bsscfg_data_set(ifp, \"join\", ext_join_params,\n\t\t\t\t\t join_params_size);\n\tkfree(ext_join_params);\n\tif (!err)\n\t\t/* This is it. join command worked, we are done */\n\t\tgoto done;\n\n\t/* join command failed, fallback to set ssid */\n\tmemset(&join_params, 0, sizeof(join_params));\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\tmemcpy(&join_params.ssid_le.SSID, sme->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\n\tif (sme->bssid)\n\t\tmemcpy(join_params.params_le.bssid, sme->bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\n\tif (cfg->channel) {\n\t\tjoin_params.params_le.chanspec_list[0] = cpu_to_le16(chanspec);\n\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\tjoin_params_size += sizeof(join_params.params_le);\n\t}\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err)\n\t\tbrcmf_err(\"BRCMF_C_SET_SSID failed (%d)\\n\", err);\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u16 reason_code)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_scb_val_le scbval;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter. Reason code = %d\\n\", reason_code);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tcfg80211_disconnected(ndev, reason_code, NULL, 0, true, GFP_KERNEL);\n\n\tmemcpy(&scbval.ea, &profile->bssid, ETH_ALEN);\n\tscbval.val = cpu_to_le32(reason_code);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_DISASSOC,\n\t\t\t\t     &scbval, sizeof(scbval));\n\tif (err)\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t    enum nl80211_tx_power_setting type, s32 mbm)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\ts32 disable;\n\tu32 qdbm = 127;\n\n\tbrcmf_dbg(TRACE, \"Enter %d %d\\n\", type, mbm);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tswitch (type) {\n\tcase NL80211_TX_POWER_AUTOMATIC:\n\t\tbreak;\n\tcase NL80211_TX_POWER_LIMITED:\n\tcase NL80211_TX_POWER_FIXED:\n\t\tif (mbm < 0) {\n\t\t\tbrcmf_err(\"TX_POWER_FIXED - dbm is negative\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tqdbm =  MBM_TO_DBM(4 * mbm);\n\t\tif (qdbm > 127)\n\t\t\tqdbm = 127;\n\t\tqdbm |= WL_TXPWR_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"Unsupported type %d\\n\", type);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\t/* Make sure radio is off or on as far as software is concerned */\n\tdisable = WL_RADIO_SW_DISABLE << 16;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_RADIO, disable);\n\tif (err)\n\t\tbrcmf_err(\"WLC_SET_RADIO error (%d)\\n\", err);\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"qtxpower\", qdbm);\n\tif (err)\n\t\tbrcmf_err(\"qtxpower error (%d)\\n\", err);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit %d (qdbm)\\n\", qdbm & ~WL_TXPWR_OVERRIDE);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t    s32 *dbm)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 qdbm = 0;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\terr = brcmf_fil_iovar_int_get(ifp, \"qtxpower\", &qdbm);\n\tif (err) {\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\t*dbm = (qdbm & ~WL_TXPWR_OVERRIDE) / 4;\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit (0x%x %d)\\n\", qdbm, *dbm);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t  u8 key_idx, bool unicast, bool multicast)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tu32 index;\n\tu32 wsec;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_GET_WSEC error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tif (wsec & WEP_ENABLED) {\n\t\t/* Just select a new current key */\n\t\tindex = key_idx;\n\t\terr = brcmf_fil_cmd_int_set(ifp,\n\t\t\t\t\t    BRCMF_C_SET_KEY_PRIMARY, index);\n\t\tif (err)\n\t\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u8 key_idx, bool pairwise, const u8 *mac_addr)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_wsec_key *key;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {\n\t\t/* we ignore this key index in this case */\n\t\treturn -EINVAL;\n\t}\n\n\tkey = &ifp->vif->profile.key[key_idx];\n\n\tif (key->algo == CRYPTO_ALGO_OFF) {\n\t\tbrcmf_dbg(CONN, \"Ignore clearing of (never configured) key\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(key, 0, sizeof(*key));\n\tkey->index = (u32)key_idx;\n\tkey->flags = BRCMF_PRIMARY_KEY;\n\n\t/* Clear the key/index */\n\terr = send_key_to_dongle(ifp, key);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u8 key_idx, bool pairwise, const u8 *mac_addr,\n\t\t       struct key_params *params)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_wsec_key *key;\n\ts32 val;\n\ts32 wsec;\n\ts32 err;\n\tu8 keybuf[8];\n\tbool ext_key;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {\n\t\t/* we ignore this key index in this case */\n\t\tbrcmf_err(\"invalid key index (%d)\\n\", key_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (params->key_len == 0)\n\t\treturn brcmf_cfg80211_del_key(wiphy, ndev, key_idx, pairwise,\n\t\t\t\t\t      mac_addr);\n\n\tif (params->key_len > sizeof(key->data)) {\n\t\tbrcmf_err(\"Too long key length (%u)\\n\", params->key_len);\n\t\treturn -EINVAL;\n\t}\n\n\text_key = false;\n\tif (mac_addr && (params->cipher != WLAN_CIPHER_SUITE_WEP40) &&\n\t    (params->cipher != WLAN_CIPHER_SUITE_WEP104)) {\n\t\tbrcmf_dbg(TRACE, \"Ext key, mac %pM\", mac_addr);\n\t\text_key = true;\n\t}\n\n\tkey = &ifp->vif->profile.key[key_idx];\n\tmemset(key, 0, sizeof(*key));\n\tif ((ext_key) && (!is_multicast_ether_addr(mac_addr)))\n\t\tmemcpy((char *)&key->ea, (void *)mac_addr, ETH_ALEN);\n\tkey->len = params->key_len;\n\tkey->index = key_idx;\n\tmemcpy(key->data, params->key, key->len);\n\tif (!ext_key)\n\t\tkey->flags = BRCMF_PRIMARY_KEY;\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey->algo = CRYPTO_ALGO_WEP1;\n\t\tval = WEP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP40\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey->algo = CRYPTO_ALGO_WEP128;\n\t\tval = WEP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP104\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (!brcmf_is_apmode(ifp->vif)) {\n\t\t\tbrcmf_dbg(CONN, \"Swapping RX/TX MIC key\\n\");\n\t\t\tmemcpy(keybuf, &key->data[24], sizeof(keybuf));\n\t\t\tmemcpy(&key->data[24], &key->data[16], sizeof(keybuf));\n\t\t\tmemcpy(&key->data[16], keybuf, sizeof(keybuf));\n\t\t}\n\t\tkey->algo = CRYPTO_ALGO_TKIP;\n\t\tval = TKIP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_TKIP\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tkey->algo = CRYPTO_ALGO_AES_CCM;\n\t\tval = AES_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_AES_CMAC\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey->algo = CRYPTO_ALGO_AES_CCM;\n\t\tval = AES_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_CCMP\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"Invalid cipher (0x%x)\\n\", params->cipher);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\terr = send_key_to_dongle(ifp, key);\n\tif (ext_key || err)\n\t\tgoto done;\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"get wsec error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\twsec |= val;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"set wsec error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev, u8 key_idx,\n\t\t       bool pairwise, const u8 *mac_addr, void *cookie,\n\t\t       void (*callback)(void *cookie,\n\t\t\t\t\tstruct key_params *params))\n{\n\tstruct key_params params;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 wsec;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemset(&params, 0, sizeof(params));\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_GET_WSEC error (%d)\\n\", err);\n\t\t/* Ignore this error, may happen during DISASSOC */\n\t\terr = -EAGAIN;\n\t\tgoto done;\n\t}\n\tif (wsec & WEP_ENABLED) {\n\t\tsec = &profile->sec;\n\t\tif (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {\n\t\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP40;\n\t\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP40\\n\");\n\t\t} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP104;\n\t\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP104\\n\");\n\t\t}\n\t} else if (wsec & TKIP_ENABLED) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_TKIP\\n\");\n\t} else if (wsec & AES_ENABLED) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_AES_CMAC;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_AES_CMAC\\n\");\n\t} else  {\n\t\tbrcmf_err(\"Invalid algo (0x%x)\\n\", wsec);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tcallback(cookie, &params);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *ndev, u8 key_idx)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter key_idx %d\\n\", key_idx);\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\treturn 0;\n\n\tbrcmf_dbg(INFO, \"Not supported\\n\");\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nbrcmf_cfg80211_reconfigure_wep(struct brcmf_if *ifp)\n{\n\ts32 err;\n\tu8 key_idx;\n\tstruct brcmf_wsec_key *key;\n\ts32 wsec;\n\n\tfor (key_idx = 0; key_idx < BRCMF_MAX_DEFAULT_KEYS; key_idx++) {\n\t\tkey = &ifp->vif->profile.key[key_idx];\n\t\tif ((key->algo == CRYPTO_ALGO_WEP1) ||\n\t\t    (key->algo == CRYPTO_ALGO_WEP128))\n\t\t\tbreak;\n\t}\n\tif (key_idx == BRCMF_MAX_DEFAULT_KEYS)\n\t\treturn;\n\n\terr = send_key_to_dongle(ifp, key);\n\tif (err) {\n\t\tbrcmf_err(\"Setting WEP key failed (%d)\\n\", err);\n\t\treturn;\n\t}\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbrcmf_err(\"get wsec error (%d)\\n\", err);\n\t\treturn;\n\t}\n\twsec |= WEP_ENABLED;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err)\n\t\tbrcmf_err(\"set wsec error (%d)\\n\", err);\n}\n\nstatic void brcmf_convert_sta_flags(u32 fw_sta_flags, struct station_info *si)\n{\n\tstruct nl80211_sta_flag_update *sfu;\n\n\tbrcmf_dbg(TRACE, \"flags %08x\\n\", fw_sta_flags);\n\tsi->filled |= BIT(NL80211_STA_INFO_STA_FLAGS);\n\tsfu = &si->sta_flags;\n\tsfu->mask = BIT(NL80211_STA_FLAG_WME) |\n\t\t    BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t    BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t    BIT(NL80211_STA_FLAG_AUTHORIZED);\n\tif (fw_sta_flags & BRCMF_STA_WME)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_WME);\n\tif (fw_sta_flags & BRCMF_STA_AUTHE)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);\n\tif (fw_sta_flags & BRCMF_STA_ASSOC)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\tif (fw_sta_flags & BRCMF_STA_AUTHO)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_AUTHORIZED);\n}\n\nstatic void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)\n{\n\tstruct {\n\t\t__le32 len;\n\t\tstruct brcmf_bss_info_le bss_le;\n\t} *buf;\n\tu16 capability;\n\tint err;\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tbuf->len = cpu_to_le32(WL_BSS_INFO_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO, buf,\n\t\t\t\t     WL_BSS_INFO_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"Failed to get bss info (%d)\\n\", err);\n\t\tgoto out_kfree;\n\t}\n\tsi->filled |= BIT(NL80211_STA_INFO_BSS_PARAM);\n\tsi->bss_param.beacon_interval = le16_to_cpu(buf->bss_le.beacon_period);\n\tsi->bss_param.dtim_period = buf->bss_le.dtim_period;\n\tcapability = le16_to_cpu(buf->bss_le.capability);\n\tif (capability & IEEE80211_HT_STBC_PARAM_DUAL_CTS_PROT)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_CTS_PROT;\n\tif (capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;\n\tif (capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;\n\nout_kfree:\n\tkfree(buf);\n}\n\nstatic s32\nbrcmf_cfg80211_get_station_ibss(struct brcmf_if *ifp,\n\t\t\t\tstruct station_info *sinfo)\n{\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_pktcnt_le pktcnt;\n\ts32 err;\n\tu32 rate;\n\tu32 rssi;\n\n\t/* Get the current tx rate */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);\n\tif (err < 0) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RATE error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\n\tsinfo->txrate.legacy = rate * 5;\n\n\tmemset(&scbval, 0, sizeof(scbval));\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI, &scbval,\n\t\t\t\t     sizeof(scbval));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RSSI error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\trssi = le32_to_cpu(scbval.val);\n\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\tsinfo->signal = rssi;\n\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_GET_PKTCNTS, &pktcnt,\n\t\t\t\t     sizeof(pktcnt));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_GET_PKTCNTS error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_RX_DROP_MISC) |\n\t\t\t BIT(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_TX_FAILED);\n\tsinfo->rx_packets = le32_to_cpu(pktcnt.rx_good_pkt);\n\tsinfo->rx_dropped_misc = le32_to_cpu(pktcnt.rx_bad_pkt);\n\tsinfo->tx_packets = le32_to_cpu(pktcnt.tx_good_pkt);\n\tsinfo->tx_failed  = le32_to_cpu(pktcnt.tx_bad_pkt);\n\n\treturn 0;\n}\n\nstatic s32\nbrcmf_cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   const u8 *mac, struct station_info *sinfo)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_scb_val_le scb_val;\n\ts32 err = 0;\n\tstruct brcmf_sta_info_le sta_info_le;\n\tu32 sta_flags;\n\tu32 is_tdls_peer;\n\ts32 total_rssi;\n\ts32 count_rssi;\n\tint rssi;\n\tu32 i;\n\n\tbrcmf_dbg(TRACE, \"Enter, MAC %pM\\n\", mac);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (brcmf_is_ibssmode(ifp->vif))\n\t\treturn brcmf_cfg80211_get_station_ibss(ifp, sinfo);\n\n\tmemset(&sta_info_le, 0, sizeof(sta_info_le));\n\tmemcpy(&sta_info_le, mac, ETH_ALEN);\n\terr = brcmf_fil_iovar_data_get(ifp, \"tdls_sta_info\",\n\t\t\t\t       &sta_info_le,\n\t\t\t\t       sizeof(sta_info_le));\n\tis_tdls_peer = !err;\n\tif (err) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"sta_info\",\n\t\t\t\t\t       &sta_info_le,\n\t\t\t\t\t       sizeof(sta_info_le));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"GET STA INFO failed, %d\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tbrcmf_dbg(TRACE, \"version %d\\n\", le16_to_cpu(sta_info_le.ver));\n\tsinfo->filled = BIT(NL80211_STA_INFO_INACTIVE_TIME);\n\tsinfo->inactive_time = le32_to_cpu(sta_info_le.idle) * 1000;\n\tsta_flags = le32_to_cpu(sta_info_le.flags);\n\tbrcmf_convert_sta_flags(sta_flags, sinfo);\n\tsinfo->sta_flags.mask |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\tif (is_tdls_peer)\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\telse\n\t\tsinfo->sta_flags.set &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\tif (sta_flags & BRCMF_STA_ASSOC) {\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_CONNECTED_TIME);\n\t\tsinfo->connected_time = le32_to_cpu(sta_info_le.in);\n\t\tbrcmf_fill_bss_param(ifp, sinfo);\n\t}\n\tif (sta_flags & BRCMF_STA_SCBSTATS) {\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_FAILED);\n\t\tsinfo->tx_failed = le32_to_cpu(sta_info_le.tx_failures);\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);\n\t\tsinfo->tx_packets = le32_to_cpu(sta_info_le.tx_pkts);\n\t\tsinfo->tx_packets += le32_to_cpu(sta_info_le.tx_mcast_pkts);\n\t\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);\n\t\tsinfo->rx_packets = le32_to_cpu(sta_info_le.rx_ucast_pkts);\n\t\tsinfo->rx_packets += le32_to_cpu(sta_info_le.rx_mcast_pkts);\n\t\tif (sinfo->tx_packets) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\n\t\t\tsinfo->txrate.legacy =\n\t\t\t\tle32_to_cpu(sta_info_le.tx_rate) / 100;\n\t\t}\n\t\tif (sinfo->rx_packets) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_BITRATE);\n\t\t\tsinfo->rxrate.legacy =\n\t\t\t\tle32_to_cpu(sta_info_le.rx_rate) / 100;\n\t\t}\n\t\tif (le16_to_cpu(sta_info_le.ver) >= 4) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES);\n\t\t\tsinfo->tx_bytes = le64_to_cpu(sta_info_le.tx_tot_bytes);\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_BYTES);\n\t\t\tsinfo->rx_bytes = le64_to_cpu(sta_info_le.rx_tot_bytes);\n\t\t}\n\t\ttotal_rssi = 0;\n\t\tcount_rssi = 0;\n\t\tfor (i = 0; i < BRCMF_ANT_MAX; i++) {\n\t\t\tif (sta_info_le.rssi[i]) {\n\t\t\t\tsinfo->chain_signal_avg[count_rssi] =\n\t\t\t\t\tsta_info_le.rssi[i];\n\t\t\t\tsinfo->chain_signal[count_rssi] =\n\t\t\t\t\tsta_info_le.rssi[i];\n\t\t\t\ttotal_rssi += sta_info_le.rssi[i];\n\t\t\t\tcount_rssi++;\n\t\t\t}\n\t\t}\n\t\tif (count_rssi) {\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_CHAIN_SIGNAL);\n\t\t\tsinfo->chains = count_rssi;\n\n\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\t\t\ttotal_rssi /= count_rssi;\n\t\t\tsinfo->signal = total_rssi;\n\t\t} else if (test_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t&ifp->vif->sme_state)) {\n\t\t\tmemset(&scb_val, 0, sizeof(scb_val));\n\t\t\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,\n\t\t\t\t\t\t     &scb_val, sizeof(scb_val));\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"Could not get rssi (%d)\\n\", err);\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\trssi = le32_to_cpu(scb_val.val);\n\t\t\t\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\t\t\t\tsinfo->signal = rssi;\n\t\t\t\tbrcmf_dbg(CONN, \"RSSI %d dBm\\n\", rssi);\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t    int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, idx %d\\n\", idx);\n\n\tif (idx == 0) {\n\t\tcfg->assoclist.count = cpu_to_le32(BRCMF_MAX_ASSOCLIST);\n\t\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_ASSOCLIST,\n\t\t\t\t\t     &cfg->assoclist,\n\t\t\t\t\t     sizeof(cfg->assoclist));\n\t\tif (err) {\n\t\t\tbrcmf_err(\"BRCMF_C_GET_ASSOCLIST unsupported, err=%d\\n\",\n\t\t\t\t  err);\n\t\t\tcfg->assoclist.count = 0;\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (idx < le32_to_cpu(cfg->assoclist.count)) {\n\t\tmemcpy(mac, cfg->assoclist.mac[idx], ETH_ALEN);\n\t\treturn brcmf_cfg80211_get_station(wiphy, ndev, mac, sinfo);\n\t}\n\treturn -ENOENT;\n}\n\nstatic s32\nbrcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   bool enabled, s32 timeout)\n{\n\ts32 pm;\n\ts32 err = 0;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t/*\n\t * Powersave enable/disable request is coming from the\n\t * cfg80211 even before the interface is up. In that\n\t * scenario, driver will be storing the power save\n\t * preference in cfg struct to apply this to\n\t * FW later while initializing the dongle\n\t */\n\tcfg->pwr_save = enabled;\n\tif (!check_vif_up(ifp->vif)) {\n\n\t\tbrcmf_dbg(INFO, \"Device is not ready, storing the value in cfg_info struct\\n\");\n\t\tgoto done;\n\t}\n\n\tpm = enabled ? PM_FAST : PM_OFF;\n\t/* Do not enable the power save after assoc if it is a p2p interface */\n\tif (ifp->vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tbrcmf_dbg(INFO, \"Do not enable power save for P2P clients\\n\");\n\t\tpm = PM_OFF;\n\t}\n\tbrcmf_dbg(INFO, \"power save %s\\n\", (pm ? \"enabled\" : \"disabled\"));\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, pm);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tbrcmf_err(\"net_device is not ready yet\\n\");\n\t\telse\n\t\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t   struct brcmf_bss_info_le *bi)\n{\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct ieee80211_channel *notify_channel;\n\tstruct cfg80211_bss *bss;\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmu_chan ch;\n\tu16 channel;\n\tu32 freq;\n\tu16 notify_capability;\n\tu16 notify_interval;\n\tu8 *notify_ie;\n\tsize_t notify_ielen;\n\ts32 notify_signal;\n\n\tif (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {\n\t\tbrcmf_err(\"Bss info is larger than buffer. Discarding\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!bi->ctl_ch) {\n\t\tch.chspec = le16_to_cpu(bi->chanspec);\n\t\tcfg->d11inf.decchspec(&ch);\n\t\tbi->ctl_ch = ch.control_ch_num;\n\t}\n\tchannel = bi->ctl_ch;\n\n\tif (channel <= CH_MAX_2G_CHANNEL)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(channel, band->band);\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\n\tnotify_capability = le16_to_cpu(bi->capability);\n\tnotify_interval = le16_to_cpu(bi->beacon_period);\n\tnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\n\tnotify_ielen = le32_to_cpu(bi->ie_length);\n\tnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\n\n\tbrcmf_dbg(CONN, \"bssid: %pM\\n\", bi->BSSID);\n\tbrcmf_dbg(CONN, \"Channel: %d(%d)\\n\", channel, freq);\n\tbrcmf_dbg(CONN, \"Capability: %X\\n\", notify_capability);\n\tbrcmf_dbg(CONN, \"Beacon interval: %d\\n\", notify_interval);\n\tbrcmf_dbg(CONN, \"Signal: %d\\n\", notify_signal);\n\n\tbss = cfg80211_inform_bss(wiphy, notify_channel,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t  (const u8 *)bi->BSSID,\n\t\t\t\t  0, notify_capability,\n\t\t\t\t  notify_interval, notify_ie,\n\t\t\t\t  notify_ielen, notify_signal,\n\t\t\t\t  GFP_KERNEL);\n\n\tif (!bss)\n\t\treturn -ENOMEM;\n\n\tcfg80211_put_bss(wiphy, bss);\n\n\treturn 0;\n}\n\nstatic struct brcmf_bss_info_le *\nnext_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)\n{\n\tif (bss == NULL)\n\t\treturn list->bss_info_le;\n\treturn (struct brcmf_bss_info_le *)((unsigned long)bss +\n\t\t\t\t\t    le32_to_cpu(bss->length));\n}\n\nstatic s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_scan_results *bss_list;\n\tstruct brcmf_bss_info_le *bi = NULL;\t/* must be initialized */\n\ts32 err = 0;\n\tint i;\n\n\tbss_list = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\n\tif (bss_list->count != 0 &&\n\t    bss_list->version != BRCMF_BSS_INFO_VERSION) {\n\t\tbrcmf_err(\"Version %d != WL_BSS_INFO_VERSION\\n\",\n\t\t\t  bss_list->version);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tbrcmf_dbg(SCAN, \"scanned AP count (%d)\\n\", bss_list->count);\n\tfor (i = 0; i < bss_list->count; i++) {\n\t\tbi = next_bss_le(bss_list, bi);\n\t\terr = brcmf_inform_single_bss(cfg, bi);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic s32 brcmf_inform_ibss(struct brcmf_cfg80211_info *cfg,\n\t\t\t     struct net_device *ndev, const u8 *bssid)\n{\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct ieee80211_channel *notify_channel;\n\tstruct brcmf_bss_info_le *bi = NULL;\n\tstruct ieee80211_supported_band *band;\n\tstruct cfg80211_bss *bss;\n\tstruct brcmu_chan ch;\n\tu8 *buf = NULL;\n\ts32 err = 0;\n\tu32 freq;\n\tu16 notify_capability;\n\tu16 notify_interval;\n\tu8 *notify_ie;\n\tsize_t notify_ielen;\n\ts32 notify_signal;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto CleanUp;\n\t}\n\n\t*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\n\n\terr = brcmf_fil_cmd_data_get(netdev_priv(ndev), BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     buf, WL_BSS_INFO_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_GET_BSS_INFO failed: %d\\n\", err);\n\t\tgoto CleanUp;\n\t}\n\n\tbi = (struct brcmf_bss_info_le *)(buf + 4);\n\n\tch.chspec = le16_to_cpu(bi->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\n\tif (ch.band == BRCMU_CHAN_BAND_2G)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);\n\tcfg->channel = freq;\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\n\tnotify_capability = le16_to_cpu(bi->capability);\n\tnotify_interval = le16_to_cpu(bi->beacon_period);\n\tnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\n\tnotify_ielen = le32_to_cpu(bi->ie_length);\n\tnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\n\n\tbrcmf_dbg(CONN, \"channel: %d(%d)\\n\", ch.control_ch_num, freq);\n\tbrcmf_dbg(CONN, \"capability: %X\\n\", notify_capability);\n\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\", notify_interval);\n\tbrcmf_dbg(CONN, \"signal: %d\\n\", notify_signal);\n\n\tbss = cfg80211_inform_bss(wiphy, notify_channel,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN, bssid, 0,\n\t\t\t\t  notify_capability, notify_interval,\n\t\t\t\t  notify_ie, notify_ielen, notify_signal,\n\t\t\t\t  GFP_KERNEL);\n\n\tif (!bss) {\n\t\terr = -ENOMEM;\n\t\tgoto CleanUp;\n\t}\n\n\tcfg80211_put_bss(wiphy, bss);\n\nCleanUp:\n\n\tkfree(buf);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn err;\n}\n\nstatic s32 brcmf_update_bss_info(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t struct brcmf_if *ifp)\n{\n\tstruct brcmf_bss_info_le *bi;\n\tconst struct brcmf_tlv *tim;\n\tu16 beacon_interval;\n\tu8 dtim_period;\n\tsize_t ie_len;\n\tu8 *ie;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (brcmf_is_ibssmode(ifp->vif))\n\t\treturn err;\n\n\t*(__le32 *)cfg->extra_buf = cpu_to_le32(WL_EXTRA_BUF_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     cfg->extra_buf, WL_EXTRA_BUF_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"Could not get bss info %d\\n\", err);\n\t\tgoto update_bss_info_out;\n\t}\n\n\tbi = (struct brcmf_bss_info_le *)(cfg->extra_buf + 4);\n\terr = brcmf_inform_single_bss(cfg, bi);\n\tif (err)\n\t\tgoto update_bss_info_out;\n\n\tie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);\n\tie_len = le32_to_cpu(bi->ie_length);\n\tbeacon_interval = le16_to_cpu(bi->beacon_period);\n\n\ttim = brcmf_parse_tlvs(ie, ie_len, WLAN_EID_TIM);\n\tif (tim)\n\t\tdtim_period = tim->data[1];\n\telse {\n\t\t/*\n\t\t* active scan was done so we could not get dtim\n\t\t* information out of probe response.\n\t\t* so we speficially query dtim information to dongle.\n\t\t*/\n\t\tu32 var;\n\t\terr = brcmf_fil_iovar_int_get(ifp, \"dtim_assoc\", &var);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"wl dtim_assoc failed (%d)\\n\", err);\n\t\t\tgoto update_bss_info_out;\n\t\t}\n\t\tdtim_period = (u8)var;\n\t}\n\nupdate_bss_info_out:\n\tbrcmf_dbg(TRACE, \"Exit\");\n\treturn err;\n}\n\nvoid brcmf_abort_scanning(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct escan_info *escan = &cfg->escan_info;\n\n\tset_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\n\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\tescan->escan_state = WL_ESCAN_STATE_IDLE;\n\t\tbrcmf_notify_escan_complete(cfg, escan->ifp, true, true);\n\t}\n\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tclear_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\n}\n\nstatic void brcmf_cfg80211_escan_timeout_worker(struct work_struct *work)\n{\n\tstruct brcmf_cfg80211_info *cfg =\n\t\t\tcontainer_of(work, struct brcmf_cfg80211_info,\n\t\t\t\t     escan_timeout_work);\n\n\tbrcmf_inform_bss(cfg);\n\tbrcmf_notify_escan_complete(cfg, cfg->escan_info.ifp, true, true);\n}\n\nstatic void brcmf_escan_timeout(unsigned long data)\n{\n\tstruct brcmf_cfg80211_info *cfg =\n\t\t\t(struct brcmf_cfg80211_info *)data;\n\n\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\tbrcmf_err(\"timer expired\\n\");\n\t\tschedule_work(&cfg->escan_timeout_work);\n\t}\n}\n\nstatic s32\nbrcmf_compare_update_same_bss(struct brcmf_cfg80211_info *cfg,\n\t\t\t      struct brcmf_bss_info_le *bss,\n\t\t\t      struct brcmf_bss_info_le *bss_info_le)\n{\n\tstruct brcmu_chan ch_bss, ch_bss_info_le;\n\n\tch_bss.chspec = le16_to_cpu(bss->chanspec);\n\tcfg->d11inf.decchspec(&ch_bss);\n\tch_bss_info_le.chspec = le16_to_cpu(bss_info_le->chanspec);\n\tcfg->d11inf.decchspec(&ch_bss_info_le);\n\n\tif (!memcmp(&bss_info_le->BSSID, &bss->BSSID, ETH_ALEN) &&\n\t\tch_bss.band == ch_bss_info_le.band &&\n\t\tbss_info_le->SSID_len == bss->SSID_len &&\n\t\t!memcmp(bss_info_le->SSID, bss->SSID, bss_info_le->SSID_len)) {\n\t\tif ((bss->flags & BRCMF_BSS_RSSI_ON_CHANNEL) ==\n\t\t\t(bss_info_le->flags & BRCMF_BSS_RSSI_ON_CHANNEL)) {\n\t\t\ts16 bss_rssi = le16_to_cpu(bss->RSSI);\n\t\t\ts16 bss_info_rssi = le16_to_cpu(bss_info_le->RSSI);\n\n\t\t\t/* preserve max RSSI if the measurements are\n\t\t\t* both on-channel or both off-channel\n\t\t\t*/\n\t\t\tif (bss_info_rssi > bss_rssi)\n\t\t\t\tbss->RSSI = bss_info_le->RSSI;\n\t\t} else if ((bss->flags & BRCMF_BSS_RSSI_ON_CHANNEL) &&\n\t\t\t(bss_info_le->flags & BRCMF_BSS_RSSI_ON_CHANNEL) == 0) {\n\t\t\t/* preserve the on-channel rssi measurement\n\t\t\t* if the new measurement is off channel\n\t\t\t*/\n\t\t\tbss->RSSI = bss_info_le->RSSI;\n\t\t\tbss->flags |= BRCMF_BSS_RSSI_ON_CHANNEL;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic s32\nbrcmf_cfg80211_escan_handler(struct brcmf_if *ifp,\n\t\t\t     const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 status;\n\tstruct brcmf_escan_result_le *escan_result_le;\n\tstruct brcmf_bss_info_le *bss_info_le;\n\tstruct brcmf_bss_info_le *bss = NULL;\n\tu32 bi_length;\n\tstruct brcmf_scan_results *list;\n\tu32 i;\n\tbool aborted;\n\n\tstatus = e->status;\n\n\tif (status == BRCMF_E_STATUS_ABORT)\n\t\tgoto exit;\n\n\tif (!test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tbrcmf_err(\"scan not ready, bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\t\treturn -EPERM;\n\t}\n\n\tif (status == BRCMF_E_STATUS_PARTIAL) {\n\t\tbrcmf_dbg(SCAN, \"ESCAN Partial result\\n\");\n\t\tescan_result_le = (struct brcmf_escan_result_le *) data;\n\t\tif (!escan_result_le) {\n\t\t\tbrcmf_err(\"Invalid escan result (NULL pointer)\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (le16_to_cpu(escan_result_le->bss_count) != 1) {\n\t\t\tbrcmf_err(\"Invalid bss_count %d: ignoring\\n\",\n\t\t\t\t  escan_result_le->bss_count);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_info_le = &escan_result_le->bss_info_le;\n\n\t\tif (brcmf_p2p_scan_finding_common_channel(cfg, bss_info_le))\n\t\t\tgoto exit;\n\n\t\tif (!cfg->int_escan_map && !cfg->scan_request) {\n\t\t\tbrcmf_dbg(SCAN, \"result without cfg80211 request\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbi_length = le32_to_cpu(bss_info_le->length);\n\t\tif (bi_length != (le32_to_cpu(escan_result_le->buflen) -\n\t\t\t\t\tWL_ESCAN_RESULTS_FIXED_SIZE)) {\n\t\t\tbrcmf_err(\"Invalid bss_info length %d: ignoring\\n\",\n\t\t\t\t  bi_length);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!(cfg_to_wiphy(cfg)->interface_modes &\n\t\t\t\t\tBIT(NL80211_IFTYPE_ADHOC))) {\n\t\t\tif (le16_to_cpu(bss_info_le->capability) &\n\t\t\t\t\t\tWLAN_CAPABILITY_IBSS) {\n\t\t\t\tbrcmf_err(\"Ignoring IBSS result\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tlist = (struct brcmf_scan_results *)\n\t\t\t\tcfg->escan_info.escan_buf;\n\t\tif (bi_length > BRCMF_ESCAN_BUF_SIZE - list->buflen) {\n\t\t\tbrcmf_err(\"Buffer is too small: ignoring\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (i = 0; i < list->count; i++) {\n\t\t\tbss = bss ? (struct brcmf_bss_info_le *)\n\t\t\t\t((unsigned char *)bss +\n\t\t\t\tle32_to_cpu(bss->length)) : list->bss_info_le;\n\t\t\tif (brcmf_compare_update_same_bss(cfg, bss,\n\t\t\t\t\t\t\t  bss_info_le))\n\t\t\t\tgoto exit;\n\t\t}\n\t\tmemcpy(&cfg->escan_info.escan_buf[list->buflen], bss_info_le,\n\t\t       bi_length);\n\t\tlist->version = le32_to_cpu(bss_info_le->version);\n\t\tlist->buflen += bi_length;\n\t\tlist->count++;\n\t} else {\n\t\tcfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\n\t\tif (brcmf_p2p_scan_finding_common_channel(cfg, NULL))\n\t\t\tgoto exit;\n\t\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\t\tbrcmf_inform_bss(cfg);\n\t\t\taborted = status != BRCMF_E_STATUS_SUCCESS;\n\t\t\tbrcmf_notify_escan_complete(cfg, ifp, aborted, false);\n\t\t} else\n\t\t\tbrcmf_dbg(SCAN, \"Ignored scan complete result 0x%x\\n\",\n\t\t\t\t  status);\n\t}\nexit:\n\treturn 0;\n}\n\nstatic void brcmf_init_escan(struct brcmf_cfg80211_info *cfg)\n{\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ESCAN_RESULT,\n\t\t\t    brcmf_cfg80211_escan_handler);\n\tcfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\n\t/* Init scan_timeout timer */\n\tinit_timer(&cfg->escan_timeout);\n\tcfg->escan_timeout.data = (unsigned long) cfg;\n\tcfg->escan_timeout.function = brcmf_escan_timeout;\n\tINIT_WORK(&cfg->escan_timeout_work,\n\t\t  brcmf_cfg80211_escan_timeout_worker);\n}\n\nstatic struct cfg80211_scan_request *\nbrcmf_alloc_internal_escan_request(struct wiphy *wiphy, u32 n_netinfo) {\n\tstruct cfg80211_scan_request *req;\n\tsize_t req_size;\n\n\treq_size = sizeof(*req) +\n\t\t   n_netinfo * sizeof(req->channels[0]) +\n\t\t   n_netinfo * sizeof(*req->ssids);\n\n\treq = kzalloc(req_size, GFP_KERNEL);\n\tif (req) {\n\t\treq->wiphy = wiphy;\n\t\treq->ssids = (void *)(&req->channels[0]) +\n\t\t\t     n_netinfo * sizeof(req->channels[0]);\n\t}\n\treturn req;\n}\n\nstatic int brcmf_internal_escan_add_info(struct cfg80211_scan_request *req,\n\t\t\t\t\t u8 *ssid, u8 ssid_len, u8 channel)\n{\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_band band;\n\tint freq, i;\n\n\tif (channel <= CH_MAX_2G_CHANNEL)\n\t\tband = NL80211_BAND_2GHZ;\n\telse\n\t\tband = NL80211_BAND_5GHZ;\n\n\tfreq = ieee80211_channel_to_frequency(channel, band);\n\tif (!freq)\n\t\treturn -EINVAL;\n\n\tchan = ieee80211_get_channel(req->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (req->channels[i] == chan)\n\t\t\tbreak;\n\t}\n\tif (i == req->n_channels)\n\t\treq->channels[req->n_channels++] = chan;\n\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (req->ssids[i].ssid_len == ssid_len &&\n\t\t    !memcmp(req->ssids[i].ssid, ssid, ssid_len))\n\t\t\tbreak;\n\t}\n\tif (i == req->n_ssids) {\n\t\tmemcpy(req->ssids[req->n_ssids].ssid, ssid, ssid_len);\n\t\treq->ssids[req->n_ssids++].ssid_len = ssid_len;\n\t}\n\treturn 0;\n}\n\nstatic int brcmf_start_internal_escan(struct brcmf_if *ifp, u32 fwmap,\n\t\t\t\t      struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tint err;\n\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tif (cfg->int_escan_map)\n\t\t\tbrcmf_dbg(SCAN, \"aborting internal scan: map=%u\\n\",\n\t\t\t\t  cfg->int_escan_map);\n\t\t/* Abort any on-going scan */\n\t\tbrcmf_abort_scanning(cfg);\n\t}\n\n\tbrcmf_dbg(SCAN, \"start internal scan: map=%u\\n\", fwmap);\n\tset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tcfg->escan_info.run = brcmf_run_escan;\n\terr = brcmf_do_escan(ifp, request);\n\tif (err) {\n\t\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\t\treturn err;\n\t}\n\tcfg->int_escan_map = fwmap;\n\treturn 0;\n}\n\nstatic struct brcmf_pno_net_info_le *\nbrcmf_get_netinfo_array(struct brcmf_pno_scanresults_le *pfn_v1)\n{\n\tstruct brcmf_pno_scanresults_v2_le *pfn_v2;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tswitch (pfn_v1->version) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fall-thru */\n\tcase cpu_to_le32(1):\n\t\tnetinfo = (struct brcmf_pno_net_info_le *)(pfn_v1 + 1);\n\t\tbreak;\n\tcase cpu_to_le32(2):\n\t\tpfn_v2 = (struct brcmf_pno_scanresults_v2_le *)pfn_v1;\n\t\tnetinfo = (struct brcmf_pno_net_info_le *)(pfn_v2 + 1);\n\t\tbreak;\n\t}\n\n\treturn netinfo;\n}\n\n/* PFN result doesn't have all the info which are required by the supplicant\n * (For e.g IEs) Do a target Escan so that sched scan results are reported\n * via wl_inform_single_bss in the required format. Escan does require the\n * scan request in the form of cfg80211_scan_request. For timebeing, create\n * cfg80211_scan_request one out of the received PNO event.\n */\nstatic s32\nbrcmf_notify_sched_scan_results(struct brcmf_if *ifp,\n\t\t\t\tconst struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_pno_net_info_le *netinfo, *netinfo_start;\n\tstruct cfg80211_scan_request *request = NULL;\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tint i, err = 0;\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tu32 bucket_map;\n\tu32 result_count;\n\tu32 status;\n\tu32 datalen;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Do Nothing\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\tresult_count = le32_to_cpu(pfn_result->count);\n\tstatus = le32_to_cpu(pfn_result->status);\n\n\t/* PFN event is limited to fit 512 bytes so we may get\n\t * multiple NET_FOUND events. For now place a warning here.\n\t */\n\tWARN_ON(status != BRCMF_PNO_SCAN_COMPLETE);\n\tbrcmf_dbg(SCAN, \"PFN NET FOUND event. count: %d\\n\", result_count);\n\tif (!result_count) {\n\t\tbrcmf_err(\"FALSE PNO Event. (pfn_count == 0)\\n\");\n\t\tgoto out_err;\n\t}\n\n\tnetinfo_start = brcmf_get_netinfo_array(pfn_result);\n\tdatalen = e->datalen - ((void *)netinfo_start - (void *)pfn_result);\n\tif (datalen < result_count * sizeof(*netinfo)) {\n\t\tbrcmf_err(\"insufficient event data\\n\");\n\t\tgoto out_err;\n\t}\n\n\trequest = brcmf_alloc_internal_escan_request(wiphy,\n\t\t\t\t\t\t     result_count);\n\tif (!request) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tbucket_map = 0;\n\tfor (i = 0; i < result_count; i++) {\n\t\tnetinfo = &netinfo_start[i];\n\n\t\tif (netinfo->SSID_len > IEEE80211_MAX_SSID_LEN)\n\t\t\tnetinfo->SSID_len = IEEE80211_MAX_SSID_LEN;\n\t\tbrcmf_dbg(SCAN, \"SSID:%.32s Channel:%d\\n\",\n\t\t\t  netinfo->SSID, netinfo->channel);\n\t\tbucket_map |= brcmf_pno_get_bucket_map(cfg->pno, netinfo);\n\t\terr = brcmf_internal_escan_add_info(request,\n\t\t\t\t\t\t    netinfo->SSID,\n\t\t\t\t\t\t    netinfo->SSID_len,\n\t\t\t\t\t\t    netinfo->channel);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tif (!bucket_map)\n\t\tgoto free_req;\n\n\terr = brcmf_start_internal_escan(ifp, bucket_map, request);\n\tif (!err)\n\t\tgoto free_req;\n\nout_err:\n\tcfg80211_sched_scan_stopped(wiphy, 0);\nfree_req:\n\tkfree(request);\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_sched_scan_start(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *ndev,\n\t\t\t\tstruct cfg80211_sched_scan_request *req)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\n\tbrcmf_dbg(SCAN, \"Enter: n_match_sets=%d n_ssids=%d\\n\",\n\t\t  req->n_match_sets, req->n_ssids);\n\n\tif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\n\t\tbrcmf_err(\"Scanning suppressed: status=%lu\\n\",\n\t\t\t  cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (req->n_match_sets <= 0) {\n\t\tbrcmf_dbg(SCAN, \"invalid number of matchsets specified: %d\\n\",\n\t\t\t  req->n_match_sets);\n\t\treturn -EINVAL;\n\t}\n\n\treturn brcmf_pno_start_sched_scan(ifp, req);\n}\n\nstatic int brcmf_cfg80211_sched_scan_stop(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *ndev, u64 reqid)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(SCAN, \"enter\\n\");\n\tbrcmf_pno_stop_sched_scan(ifp, reqid);\n\tif (cfg->int_escan_map)\n\t\tbrcmf_notify_escan_complete(cfg, ifp, true, true);\n\treturn 0;\n}\n\nstatic __always_inline void brcmf_delay(u32 ms)\n{\n\tif (ms < 1000 / HZ) {\n\t\tcond_resched();\n\t\tmdelay(ms);\n\t} else {\n\t\tmsleep(ms);\n\t}\n}\n\nstatic s32 brcmf_config_wowl_pattern(struct brcmf_if *ifp, u8 cmd[4],\n\t\t\t\t     u8 *pattern, u32 patternsize, u8 *mask,\n\t\t\t\t     u32 packet_offset)\n{\n\tstruct brcmf_fil_wowl_pattern_le *filter;\n\tu32 masksize;\n\tu32 patternoffset;\n\tu8 *buf;\n\tu32 bufsize;\n\ts32 ret;\n\n\tmasksize = (patternsize + 7) / 8;\n\tpatternoffset = sizeof(*filter) - sizeof(filter->cmd) + masksize;\n\n\tbufsize = sizeof(*filter) + patternsize + masksize;\n\tbuf = kzalloc(bufsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tfilter = (struct brcmf_fil_wowl_pattern_le *)buf;\n\n\tmemcpy(filter->cmd, cmd, 4);\n\tfilter->masksize = cpu_to_le32(masksize);\n\tfilter->offset = cpu_to_le32(packet_offset);\n\tfilter->patternoffset = cpu_to_le32(patternoffset);\n\tfilter->patternsize = cpu_to_le32(patternsize);\n\tfilter->type = cpu_to_le32(BRCMF_WOWL_PATTERN_TYPE_BITMAP);\n\n\tif ((mask) && (masksize))\n\t\tmemcpy(buf + sizeof(*filter), mask, masksize);\n\tif ((pattern) && (patternsize))\n\t\tmemcpy(buf + sizeof(*filter) + masksize, pattern, patternsize);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"wowl_pattern\", buf, bufsize);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic s32\nbrcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,\n\t\t      void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(pfn_result->count) < 1) {\n\t\tbrcmf_err(\"Invalid result count, expected 1 (%d)\\n\",\n\t\t\t  le32_to_cpu(pfn_result->count));\n\t\treturn -EINVAL;\n\t}\n\n\tnetinfo = brcmf_get_netinfo_array(pfn_result);\n\tmemcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len);\n\tcfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len;\n\tcfg->wowl.nd->n_channels = 1;\n\tcfg->wowl.nd->channels[0] =\n\t\tieee80211_channel_to_frequency(netinfo->channel,\n\t\t\tnetinfo->channel <= CH_MAX_2G_CHANNEL ?\n\t\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ);\n\tcfg->wowl.nd_info->n_matches = 1;\n\tcfg->wowl.nd_info->matches[0] = cfg->wowl.nd;\n\n\t/* Inform (the resume task) that the net detect information was recvd */\n\tcfg->wowl.nd_data_completed = true;\n\twake_up(&cfg->wowl.nd_data_wait);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_wowl_wakeind_le wake_ind_le;\n\tstruct cfg80211_wowlan_wakeup wakeup_data;\n\tstruct cfg80211_wowlan_wakeup *wakeup;\n\tu32 wakeind;\n\ts32 err;\n\tint timeout;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"wowl_wakeind\", &wake_ind_le,\n\t\t\t\t       sizeof(wake_ind_le));\n\tif (err) {\n\t\tbrcmf_err(\"Get wowl_wakeind failed, err = %d\\n\", err);\n\t\treturn;\n\t}\n\n\twakeind = le32_to_cpu(wake_ind_le.ucode_wakeind);\n\tif (wakeind & (BRCMF_WOWL_MAGIC | BRCMF_WOWL_DIS | BRCMF_WOWL_BCN |\n\t\t       BRCMF_WOWL_RETR | BRCMF_WOWL_NET |\n\t\t       BRCMF_WOWL_PFN_FOUND)) {\n\t\twakeup = &wakeup_data;\n\t\tmemset(&wakeup_data, 0, sizeof(wakeup_data));\n\t\twakeup_data.pattern_idx = -1;\n\n\t\tif (wakeind & BRCMF_WOWL_MAGIC) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_MAGIC\\n\");\n\t\t\twakeup_data.magic_pkt = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_DIS) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_DIS\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_BCN) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_BCN\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_RETR) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_RETR\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_NET) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_NET\\n\");\n\t\t\t/* For now always map to pattern 0, no API to get\n\t\t\t * correct information available at the moment.\n\t\t\t */\n\t\t\twakeup_data.pattern_idx = 0;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_PFN_FOUND) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_PFN_FOUND\\n\");\n\t\t\ttimeout = wait_event_timeout(cfg->wowl.nd_data_wait,\n\t\t\t\tcfg->wowl.nd_data_completed,\n\t\t\t\tBRCMF_ND_INFO_TIMEOUT);\n\t\t\tif (!timeout)\n\t\t\t\tbrcmf_err(\"No result for wowl net detect\\n\");\n\t\t\telse\n\t\t\t\twakeup_data.net_detect = cfg->wowl.nd_info;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_GTK_FAILURE) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_GTK_FAILURE\\n\");\n\t\t\twakeup_data.gtk_rekey_failure = true;\n\t\t}\n\t} else {\n\t\twakeup = NULL;\n\t}\n\tcfg80211_report_wowlan_wakeup(&ifp->vif->wdev, wakeup, GFP_KERNEL);\n}\n\n#else\n\nstatic void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n}\n\n#endif /* CONFIG_PM */\n\nstatic s32 brcmf_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (cfg->wowl.active) {\n\t\tbrcmf_report_wowl_wakeind(wiphy, ifp);\n\t\tbrcmf_fil_iovar_int_set(ifp, \"wowl_clear\", 0);\n\t\tbrcmf_config_wowl_pattern(ifp, \"clr\", NULL, 0, NULL, 0);\n\t\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM,\n\t\t\t\t      cfg->wowl.pre_pmmode);\n\t\tcfg->wowl.active = false;\n\t\tif (cfg->wowl.nd_enabled) {\n\t\t\tbrcmf_cfg80211_sched_scan_stop(cfg->wiphy, ifp->ndev, 0);\n\t\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t\t    brcmf_notify_sched_scan_results);\n\t\t\tcfg->wowl.nd_enabled = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void brcmf_configure_wowl(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t struct brcmf_if *ifp,\n\t\t\t\t struct cfg80211_wowlan *wowl)\n{\n\tu32 wowl_config;\n\tstruct brcmf_wowl_wakeind_le wowl_wakeind;\n\tu32 i;\n\n\tbrcmf_dbg(TRACE, \"Suspend, wowl config.\\n\");\n\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\tbrcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_PM, &cfg->wowl.pre_pmmode);\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, PM_MAX);\n\n\twowl_config = 0;\n\tif (wowl->disconnect)\n\t\twowl_config = BRCMF_WOWL_DIS | BRCMF_WOWL_BCN | BRCMF_WOWL_RETR;\n\tif (wowl->magic_pkt)\n\t\twowl_config |= BRCMF_WOWL_MAGIC;\n\tif ((wowl->patterns) && (wowl->n_patterns)) {\n\t\twowl_config |= BRCMF_WOWL_NET;\n\t\tfor (i = 0; i < wowl->n_patterns; i++) {\n\t\t\tbrcmf_config_wowl_pattern(ifp, \"add\",\n\t\t\t\t(u8 *)wowl->patterns[i].pattern,\n\t\t\t\twowl->patterns[i].pattern_len,\n\t\t\t\t(u8 *)wowl->patterns[i].mask,\n\t\t\t\twowl->patterns[i].pkt_offset);\n\t\t}\n\t}\n\tif (wowl->nd_config) {\n\t\tbrcmf_cfg80211_sched_scan_start(cfg->wiphy, ifp->ndev,\n\t\t\t\t\t\twowl->nd_config);\n\t\twowl_config |= BRCMF_WOWL_PFN_FOUND;\n\n\t\tcfg->wowl.nd_data_completed = false;\n\t\tcfg->wowl.nd_enabled = true;\n\t\t/* Now reroute the event for PFN to the wowl function. */\n\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t    brcmf_wowl_nd_results);\n\t}\n\tif (wowl->gtk_rekey_failure)\n\t\twowl_config |= BRCMF_WOWL_GTK_FAILURE;\n\tif (!test_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state))\n\t\twowl_config |= BRCMF_WOWL_UNASSOC;\n\n\tmemcpy(&wowl_wakeind, \"clear\", 6);\n\tbrcmf_fil_iovar_data_set(ifp, \"wowl_wakeind\", &wowl_wakeind,\n\t\t\t\t sizeof(wowl_wakeind));\n\tbrcmf_fil_iovar_int_set(ifp, \"wowl\", wowl_config);\n\tbrcmf_fil_iovar_int_set(ifp, \"wowl_activate\", 1);\n\tbrcmf_bus_wowl_config(cfg->pub->bus_if, true);\n\tcfg->wowl.active = true;\n}\n\nstatic s32 brcmf_cfg80211_suspend(struct wiphy *wiphy,\n\t\t\t\t  struct cfg80211_wowlan *wowl)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t/* if the primary net_device is not READY there is nothing\n\t * we can do but pray resume goes smoothly.\n\t */\n\tif (!check_vif_up(ifp->vif))\n\t\tgoto exit;\n\n\t/* Stop scheduled scan */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO))\n\t\tbrcmf_cfg80211_sched_scan_stop(wiphy, ndev, 0);\n\n\t/* end any scanning */\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\n\t\tbrcmf_abort_scanning(cfg);\n\n\tif (wowl == NULL) {\n\t\tbrcmf_bus_wowl_config(cfg->pub->bus_if, false);\n\t\tlist_for_each_entry(vif, &cfg->vif_list, list) {\n\t\t\tif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state))\n\t\t\t\tcontinue;\n\t\t\t/* While going to suspend if associated with AP\n\t\t\t * disassociate from AP to save power while system is\n\t\t\t * in suspended state\n\t\t\t */\n\t\t\tbrcmf_link_down(vif, WLAN_REASON_UNSPECIFIED);\n\t\t\t/* Make sure WPA_Supplicant receives all the event\n\t\t\t * generated due to DISASSOC call to the fw to keep\n\t\t\t * the state fw and WPA_Supplicant state consistent\n\t\t\t */\n\t\t\tbrcmf_delay(500);\n\t\t}\n\t\t/* Configure MPC */\n\t\tbrcmf_set_mpc(ifp, 1);\n\n\t} else {\n\t\t/* Configure WOWL paramaters */\n\t\tbrcmf_configure_wowl(cfg, ifp, wowl);\n\t}\n\nexit:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\t/* clear any scanning activity */\n\tcfg->scan_status = 0;\n\treturn 0;\n}\n\nstatic __used s32\nbrcmf_update_pmklist(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp)\n{\n\tstruct brcmf_pmk_list_le *pmk_list;\n\tint i;\n\tu32 npmk;\n\ts32 err;\n\n\tpmk_list = &cfg->pmk_list;\n\tnpmk = le32_to_cpu(pmk_list->npmk);\n\n\tbrcmf_dbg(CONN, \"No of elements %d\\n\", npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tbrcmf_dbg(CONN, \"PMK[%d]: %pM\\n\", i, &pmk_list->pmk[i].bssid);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"pmkid_info\", pmk_list,\n\t\t\t\t       sizeof(*pmk_list));\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t struct cfg80211_pmksa *pmksa)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];\n\ts32 err;\n\tu32 npmk, i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tnpmk = le32_to_cpu(cfg->pmk_list.npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tif (!memcmp(pmksa->bssid, pmk[i].bssid, ETH_ALEN))\n\t\t\tbreak;\n\tif (i < BRCMF_MAXPMKID) {\n\t\tmemcpy(pmk[i].bssid, pmksa->bssid, ETH_ALEN);\n\t\tmemcpy(pmk[i].pmkid, pmksa->pmkid, WLAN_PMKID_LEN);\n\t\tif (i == npmk) {\n\t\t\tnpmk++;\n\t\t\tcfg->pmk_list.npmk = cpu_to_le32(npmk);\n\t\t}\n\t} else {\n\t\tbrcmf_err(\"Too many PMKSA entries cached %d\\n\", npmk);\n\t\treturn -EINVAL;\n\t}\n\n\tbrcmf_dbg(CONN, \"set_pmksa - PMK bssid: %pM =\\n\", pmk[npmk].bssid);\n\tfor (i = 0; i < WLAN_PMKID_LEN; i += 4)\n\t\tbrcmf_dbg(CONN, \"%02x %02x %02x %02x\\n\", pmk[npmk].pmkid[i],\n\t\t\t  pmk[npmk].pmkid[i + 1], pmk[npmk].pmkid[i + 2],\n\t\t\t  pmk[npmk].pmkid[i + 3]);\n\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t struct cfg80211_pmksa *pmksa)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];\n\ts32 err;\n\tu32 npmk, i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tbrcmf_dbg(CONN, \"del_pmksa - PMK bssid = %pM\\n\", pmksa->bssid);\n\n\tnpmk = le32_to_cpu(cfg->pmk_list.npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tif (!memcmp(pmksa->bssid, pmk[i].bssid, ETH_ALEN))\n\t\t\tbreak;\n\n\tif ((npmk > 0) && (i < npmk)) {\n\t\tfor (; i < (npmk - 1); i++) {\n\t\t\tmemcpy(&pmk[i].bssid, &pmk[i + 1].bssid, ETH_ALEN);\n\t\t\tmemcpy(&pmk[i].pmkid, &pmk[i + 1].pmkid,\n\t\t\t       WLAN_PMKID_LEN);\n\t\t}\n\t\tmemset(&pmk[i], 0, sizeof(*pmk));\n\t\tcfg->pmk_list.npmk = cpu_to_le32(npmk - 1);\n\t} else {\n\t\tbrcmf_err(\"Cache entry not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n\n}\n\nstatic s32\nbrcmf_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemset(&cfg->pmk_list, 0, sizeof(cfg->pmk_list));\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n\n}\n\nstatic s32 brcmf_configure_opensecurity(struct brcmf_if *ifp)\n{\n\ts32 err;\n\n\t/* set auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", 0);\n\tif (err < 0) {\n\t\tbrcmf_err(\"auth error %d\\n\", err);\n\t\treturn err;\n\t}\n\t/* set wsec */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", 0);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wsec error %d\\n\", err);\n\t\treturn err;\n\t}\n\t/* set upper-layer auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wpa_auth\", WPA_AUTH_NONE);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wpa_auth error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie)\n{\n\tif (is_rsn_ie)\n\t\treturn (memcmp(oui, RSN_OUI, TLV_OUI_LEN) == 0);\n\n\treturn (memcmp(oui, WPA_OUI, TLV_OUI_LEN) == 0);\n}\n\nstatic s32\nbrcmf_configure_wpaie(struct brcmf_if *ifp,\n\t\t      const struct brcmf_vs_tlv *wpa_ie,\n\t\t      bool is_rsn_ie)\n{\n\tu32 auth = 0; /* d11 open authentication */\n\tu16 count;\n\ts32 err = 0;\n\ts32 len;\n\tu32 i;\n\tu32 wsec;\n\tu32 pval = 0;\n\tu32 gval = 0;\n\tu32 wpa_auth = 0;\n\tu32 offset;\n\tu8 *data;\n\tu16 rsn_cap;\n\tu32 wme_bss_disable;\n\tu32 mfp;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (wpa_ie == NULL)\n\t\tgoto exit;\n\n\tlen = wpa_ie->len + TLV_HDR_LEN;\n\tdata = (u8 *)wpa_ie;\n\toffset = TLV_HDR_LEN;\n\tif (!is_rsn_ie)\n\t\toffset += VS_IE_FIXED_HDR_LEN;\n\telse\n\t\toffset += WPA_IE_VERSION_LEN;\n\n\t/* check for multicast cipher suite */\n\tif (offset + WPA_IE_MIN_OUI_LEN > len) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"no multicast cipher suite\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"ivalid OUI\\n\");\n\t\tgoto exit;\n\t}\n\toffset += TLV_OUI_LEN;\n\n\t/* pick up multicast cipher */\n\tswitch (data[offset]) {\n\tcase WPA_CIPHER_NONE:\n\t\tgval = 0;\n\t\tbreak;\n\tcase WPA_CIPHER_WEP_40:\n\tcase WPA_CIPHER_WEP_104:\n\t\tgval = WEP_ENABLED;\n\t\tbreak;\n\tcase WPA_CIPHER_TKIP:\n\t\tgval = TKIP_ENABLED;\n\t\tbreak;\n\tcase WPA_CIPHER_AES_CCM:\n\t\tgval = AES_ENABLED;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"Invalid multi cast cipher info\\n\");\n\t\tgoto exit;\n\t}\n\n\toffset++;\n\t/* walk thru unicast cipher list and pick up what we recognize */\n\tcount = data[offset] + (data[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN;\n\t/* Check for unicast suite(s) */\n\tif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"no unicast cipher suite\\n\");\n\t\tgoto exit;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\t\terr = -EINVAL;\n\t\t\tbrcmf_err(\"ivalid OUI\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\toffset += TLV_OUI_LEN;\n\t\tswitch (data[offset]) {\n\t\tcase WPA_CIPHER_NONE:\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP_40:\n\t\tcase WPA_CIPHER_WEP_104:\n\t\t\tpval |= WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_TKIP:\n\t\t\tpval |= TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_AES_CCM:\n\t\t\tpval |= AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"Invalid unicast security info\\n\");\n\t\t}\n\t\toffset++;\n\t}\n\t/* walk thru auth management suite list and pick up what we recognize */\n\tcount = data[offset] + (data[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN;\n\t/* Check for auth key management suite(s) */\n\tif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\n\t\terr = -EINVAL;\n\t\tbrcmf_err(\"no auth key mgmt suite\\n\");\n\t\tgoto exit;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\t\terr = -EINVAL;\n\t\t\tbrcmf_err(\"ivalid OUI\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\toffset += TLV_OUI_LEN;\n\t\tswitch (data[offset]) {\n\t\tcase RSN_AKM_NONE:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_NONE\\n\");\n\t\t\twpa_auth |= WPA_AUTH_NONE;\n\t\t\tbreak;\n\t\tcase RSN_AKM_UNSPECIFIED:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_UNSPECIFIED\\n\");\n\t\t\tis_rsn_ie ? (wpa_auth |= WPA2_AUTH_UNSPECIFIED) :\n\t\t\t\t    (wpa_auth |= WPA_AUTH_UNSPECIFIED);\n\t\t\tbreak;\n\t\tcase RSN_AKM_PSK:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_PSK\\n\");\n\t\t\tis_rsn_ie ? (wpa_auth |= WPA2_AUTH_PSK) :\n\t\t\t\t    (wpa_auth |= WPA_AUTH_PSK);\n\t\t\tbreak;\n\t\tcase RSN_AKM_SHA256_PSK:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_MFP_PSK\\n\");\n\t\t\twpa_auth |= WPA2_AUTH_PSK_SHA256;\n\t\t\tbreak;\n\t\tcase RSN_AKM_SHA256_1X:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_MFP_1X\\n\");\n\t\t\twpa_auth |= WPA2_AUTH_1X_SHA256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_err(\"Invalid key mgmt info\\n\");\n\t\t}\n\t\toffset++;\n\t}\n\n\tmfp = BRCMF_MFP_NONE;\n\tif (is_rsn_ie) {\n\t\twme_bss_disable = 1;\n\t\tif ((offset + RSN_CAP_LEN) <= len) {\n\t\t\trsn_cap = data[offset] + (data[offset + 1] << 8);\n\t\t\tif (rsn_cap & RSN_CAP_PTK_REPLAY_CNTR_MASK)\n\t\t\t\twme_bss_disable = 0;\n\t\t\tif (rsn_cap & RSN_CAP_MFPR_MASK) {\n\t\t\t\tbrcmf_dbg(TRACE, \"MFP Required\\n\");\n\t\t\t\tmfp = BRCMF_MFP_REQUIRED;\n\t\t\t\t/* Firmware only supports mfp required in\n\t\t\t\t * combination with WPA2_AUTH_PSK_SHA256 or\n\t\t\t\t * WPA2_AUTH_1X_SHA256.\n\t\t\t\t */\n\t\t\t\tif (!(wpa_auth & (WPA2_AUTH_PSK_SHA256 |\n\t\t\t\t\t\t  WPA2_AUTH_1X_SHA256))) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\t/* Firmware has requirement that WPA2_AUTH_PSK/\n\t\t\t\t * WPA2_AUTH_UNSPECIFIED be set, if SHA256 OUI\n\t\t\t\t * is to be included in the rsn ie.\n\t\t\t\t */\n\t\t\t\tif (wpa_auth & WPA2_AUTH_PSK_SHA256)\n\t\t\t\t\twpa_auth |= WPA2_AUTH_PSK;\n\t\t\t\telse if (wpa_auth & WPA2_AUTH_1X_SHA256)\n\t\t\t\t\twpa_auth |= WPA2_AUTH_UNSPECIFIED;\n\t\t\t} else if (rsn_cap & RSN_CAP_MFPC_MASK) {\n\t\t\t\tbrcmf_dbg(TRACE, \"MFP Capable\\n\");\n\t\t\t\tmfp = BRCMF_MFP_CAPABLE;\n\t\t\t}\n\t\t}\n\t\toffset += RSN_CAP_LEN;\n\t\t/* set wme_bss_disable to sync RSN Capabilities */\n\t\terr = brcmf_fil_bsscfg_int_set(ifp, \"wme_bss_disable\",\n\t\t\t\t\t       wme_bss_disable);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"wme_bss_disable error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Skip PMKID cnt as it is know to be 0 for AP. */\n\t\toffset += RSN_PMKID_COUNT_LEN;\n\n\t\t/* See if there is BIP wpa suite left for MFP */\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP) &&\n\t\t    ((offset + WPA_IE_MIN_OUI_LEN) <= len)) {\n\t\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"bip\",\n\t\t\t\t\t\t\t&data[offset],\n\t\t\t\t\t\t\tWPA_IE_MIN_OUI_LEN);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"bip error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\t/* FOR WPS , set SES_OW_ENABLED */\n\twsec = (pval | gval | SES_OW_ENABLED);\n\n\t/* set auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", auth);\n\tif (err < 0) {\n\t\tbrcmf_err(\"auth error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\t/* set wsec */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wsec error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\t/* Configure MFP, this needs to go after wsec otherwise the wsec command\n\t * will overwrite the values set by MFP\n\t */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP)) {\n\t\terr = brcmf_fil_bsscfg_int_set(ifp, \"mfp\", mfp);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"mfp error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\t/* set upper-layer auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wpa_auth\", wpa_auth);\n\tif (err < 0) {\n\t\tbrcmf_err(\"wpa_auth error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn err;\n}\n\nstatic s32\nbrcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32 vndr_ie_len,\n\t\t     struct parsed_vndr_ies *vndr_ies)\n{\n\tstruct brcmf_vs_tlv *vndrie;\n\tstruct brcmf_tlv *ie;\n\tstruct parsed_vndr_ie_info *parsed_info;\n\ts32 remaining_len;\n\n\tremaining_len = (s32)vndr_ie_len;\n\tmemset(vndr_ies, 0, sizeof(*vndr_ies));\n\n\tie = (struct brcmf_tlv *)vndr_ie_buf;\n\twhile (ie) {\n\t\tif (ie->id != WLAN_EID_VENDOR_SPECIFIC)\n\t\t\tgoto next;\n\t\tvndrie = (struct brcmf_vs_tlv *)ie;\n\t\t/* len should be bigger than OUI length + one */\n\t\tif (vndrie->len < (VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1)) {\n\t\t\tbrcmf_err(\"invalid vndr ie. length is too small %d\\n\",\n\t\t\t\t  vndrie->len);\n\t\t\tgoto next;\n\t\t}\n\t\t/* if wpa or wme ie, do not add ie */\n\t\tif (!memcmp(vndrie->oui, (u8 *)WPA_OUI, TLV_OUI_LEN) &&\n\t\t    ((vndrie->oui_type == WPA_OUI_TYPE) ||\n\t\t    (vndrie->oui_type == WME_OUI_TYPE))) {\n\t\t\tbrcmf_dbg(TRACE, \"Found WPA/WME oui. Do not add it\\n\");\n\t\t\tgoto next;\n\t\t}\n\n\t\tparsed_info = &vndr_ies->ie_info[vndr_ies->count];\n\n\t\t/* save vndr ie information */\n\t\tparsed_info->ie_ptr = (char *)vndrie;\n\t\tparsed_info->ie_len = vndrie->len + TLV_HDR_LEN;\n\t\tmemcpy(&parsed_info->vndrie, vndrie, sizeof(*vndrie));\n\n\t\tvndr_ies->count++;\n\n\t\tbrcmf_dbg(TRACE, \"** OUI %02x %02x %02x, type 0x%02x\\n\",\n\t\t\t  parsed_info->vndrie.oui[0],\n\t\t\t  parsed_info->vndrie.oui[1],\n\t\t\t  parsed_info->vndrie.oui[2],\n\t\t\t  parsed_info->vndrie.oui_type);\n\n\t\tif (vndr_ies->count >= VNDR_IE_PARSE_LIMIT)\n\t\t\tbreak;\nnext:\n\t\tremaining_len -= (ie->len + TLV_HDR_LEN);\n\t\tif (remaining_len <= TLV_HDR_LEN)\n\t\t\tie = NULL;\n\t\telse\n\t\t\tie = (struct brcmf_tlv *)(((u8 *)ie) + ie->len +\n\t\t\t\tTLV_HDR_LEN);\n\t}\n\treturn 0;\n}\n\nstatic u32\nbrcmf_vndr_ie(u8 *iebuf, s32 pktflag, u8 *ie_ptr, u32 ie_len, s8 *add_del_cmd)\n{\n\n\tstrncpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN - 1);\n\tiebuf[VNDR_IE_CMD_LEN - 1] = '\\0';\n\n\tput_unaligned_le32(1, &iebuf[VNDR_IE_COUNT_OFFSET]);\n\n\tput_unaligned_le32(pktflag, &iebuf[VNDR_IE_PKTFLAG_OFFSET]);\n\n\tmemcpy(&iebuf[VNDR_IE_VSIE_OFFSET], ie_ptr, ie_len);\n\n\treturn ie_len + VNDR_IE_HDR_SIZE;\n}\n\ns32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,\n\t\t\t  const u8 *vndr_ie_buf, u32 vndr_ie_len)\n{\n\tstruct brcmf_if *ifp;\n\tstruct vif_saved_ie *saved_ie;\n\ts32 err = 0;\n\tu8  *iovar_ie_buf;\n\tu8  *curr_ie_buf;\n\tu8  *mgmt_ie_buf = NULL;\n\tint mgmt_ie_buf_len;\n\tu32 *mgmt_ie_len;\n\tu32 del_add_ie_buf_len = 0;\n\tu32 total_ie_buf_len = 0;\n\tu32 parsed_ie_buf_len = 0;\n\tstruct parsed_vndr_ies old_vndr_ies;\n\tstruct parsed_vndr_ies new_vndr_ies;\n\tstruct parsed_vndr_ie_info *vndrie_info;\n\ts32 i;\n\tu8 *ptr;\n\tint remained_buf_len;\n\n\tif (!vif)\n\t\treturn -ENODEV;\n\tifp = vif->ifp;\n\tsaved_ie = &vif->saved_ie;\n\n\tbrcmf_dbg(TRACE, \"bsscfgidx %d, pktflag : 0x%02X\\n\", ifp->bsscfgidx,\n\t\t  pktflag);\n\tiovar_ie_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!iovar_ie_buf)\n\t\treturn -ENOMEM;\n\tcurr_ie_buf = iovar_ie_buf;\n\tswitch (pktflag) {\n\tcase BRCMF_VNDR_IE_PRBREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_req_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_req_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_PRBRSP_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_res_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_res_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_res_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_BEACON_FLAG:\n\t\tmgmt_ie_buf = saved_ie->beacon_ie;\n\t\tmgmt_ie_len = &saved_ie->beacon_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->beacon_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_ASSOCREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->assoc_req_ie;\n\t\tmgmt_ie_len = &saved_ie->assoc_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);\n\t\tbreak;\n\tdefault:\n\t\terr = -EPERM;\n\t\tbrcmf_err(\"not suitable type\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (vndr_ie_len > mgmt_ie_buf_len) {\n\t\terr = -ENOMEM;\n\t\tbrcmf_err(\"extra IE size too big\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* parse and save new vndr_ie in curr_ie_buff before comparing it */\n\tif (vndr_ie_buf && vndr_ie_len && curr_ie_buf) {\n\t\tptr = curr_ie_buf;\n\t\tbrcmf_parse_vndr_ies(vndr_ie_buf, vndr_ie_len, &new_vndr_ies);\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\t\t\tmemcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\tparsed_ie_buf_len += vndrie_info->ie_len;\n\t\t}\n\t}\n\n\tif (mgmt_ie_buf && *mgmt_ie_len) {\n\t\tif (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len) &&\n\t\t    (memcmp(mgmt_ie_buf, curr_ie_buf,\n\t\t\t    parsed_ie_buf_len) == 0)) {\n\t\t\tbrcmf_dbg(TRACE, \"Previous mgmt IE equals to current IE\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* parse old vndr_ie */\n\t\tbrcmf_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len, &old_vndr_ies);\n\n\t\t/* make a command to delete old ie */\n\t\tfor (i = 0; i < old_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &old_vndr_ies.ie_info[i];\n\n\t\t\tbrcmf_dbg(TRACE, \"DEL ID : %d, Len: %d , OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"del\");\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\n\t*mgmt_ie_len = 0;\n\t/* Add if there is any extra IE */\n\tif (mgmt_ie_buf && parsed_ie_buf_len) {\n\t\tptr = mgmt_ie_buf;\n\n\t\tremained_buf_len = mgmt_ie_buf_len;\n\n\t\t/* make a command to add new ie */\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\n\t\t\t/* verify remained buf size before copy data */\n\t\t\tif (remained_buf_len < (vndrie_info->vndrie.len +\n\t\t\t\t\t\t\tVNDR_IE_VSIE_OFFSET)) {\n\t\t\t\tbrcmf_err(\"no space in mgmt_ie_buf: len left %d\",\n\t\t\t\t\t  remained_buf_len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tremained_buf_len -= (vndrie_info->ie_len +\n\t\t\t\t\t     VNDR_IE_VSIE_OFFSET);\n\n\t\t\tbrcmf_dbg(TRACE, \"ADDED ID : %d, Len: %d, OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"add\");\n\n\t\t\t/* save the parsed IE in wl struct */\n\t\t\tmemcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\t*mgmt_ie_len += vndrie_info->ie_len;\n\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\tif (total_ie_buf_len) {\n\t\terr  = brcmf_fil_bsscfg_data_set(ifp, \"vndr_ie\", iovar_ie_buf,\n\t\t\t\t\t\t total_ie_buf_len);\n\t\tif (err)\n\t\t\tbrcmf_err(\"vndr ie set error : %d\\n\", err);\n\t}\n\nexit:\n\tkfree(iovar_ie_buf);\n\treturn err;\n}\n\ns32 brcmf_vif_clear_mgmt_ies(struct brcmf_cfg80211_vif *vif)\n{\n\ts32 pktflags[] = {\n\t\tBRCMF_VNDR_IE_PRBREQ_FLAG,\n\t\tBRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\tBRCMF_VNDR_IE_BEACON_FLAG\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pktflags); i++)\n\t\tbrcmf_vif_set_mgmt_ie(vif, pktflags[i], NULL, 0);\n\n\tmemset(&vif->saved_ie, 0, sizeof(vif->saved_ie));\n\treturn 0;\n}\n\nstatic s32\nbrcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,\n\t\t\tstruct cfg80211_beacon_data *beacon)\n{\n\ts32 err;\n\n\t/* Set Beacon IEs to FW */\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_BEACON_FLAG,\n\t\t\t\t    beacon->tail, beacon->tail_len);\n\tif (err) {\n\t\tbrcmf_err(\"Set Beacon IE Failed\\n\");\n\t\treturn err;\n\t}\n\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Beacon\\n\");\n\n\t/* Set Probe Response IEs to FW */\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t    beacon->proberesp_ies,\n\t\t\t\t    beacon->proberesp_ies_len);\n\tif (err)\n\t\tbrcmf_err(\"Set Probe Resp IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Probe Resp\\n\");\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\tstruct cfg80211_ap_settings *settings)\n{\n\ts32 ie_offset;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tconst struct brcmf_tlv *ssid_ie;\n\tconst struct brcmf_tlv *country_ie;\n\tstruct brcmf_ssid_le ssid_le;\n\ts32 err = -EPERM;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tstruct brcmf_join_params join_params;\n\tenum nl80211_iftype dev_role;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tu16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef);\n\tbool mbss;\n\tint is_11d;\n\tbool supports_11d;\n\n\tbrcmf_dbg(TRACE, \"ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\\n\",\n\t\t  settings->chandef.chan->hw_value,\n\t\t  settings->chandef.center_freq1, settings->chandef.width,\n\t\t  settings->beacon_interval, settings->dtim_period);\n\tbrcmf_dbg(TRACE, \"ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\\n\",\n\t\t  settings->ssid, settings->ssid_len, settings->auth_type,\n\t\t  settings->inactivity_timeout);\n\tdev_role = ifp->vif->wdev.iftype;\n\tmbss = ifp->vif->mbss;\n\n\t/* store current 11d setting */\n\tif (brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY,\n\t\t\t\t  &ifp->vif->is_11d)) {\n\t\tis_11d = supports_11d = false;\n\t} else {\n\t\tcountry_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t\t      settings->beacon.tail_len,\n\t\t\t\t\t      WLAN_EID_COUNTRY);\n\t\tis_11d = country_ie ? 1 : 0;\n\t\tsupports_11d = true;\n\t}\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n\n\tif (!mbss) {\n\t\tbrcmf_set_mpc(ifp, 0);\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\t}\n\n\t/* find the RSN_IE */\n\trsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len, WLAN_EID_RSN);\n\n\t/* find the WPA_IE */\n\twpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len);\n\n\tif ((wpa_ie != NULL || rsn_ie != NULL)) {\n\t\tbrcmf_dbg(TRACE, \"WPA(2) IE is found\\n\");\n\t\tif (wpa_ie != NULL) {\n\t\t\t/* WPA IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, wpa_ie, false);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tstruct brcmf_vs_tlv *tmp_ie;\n\n\t\t\ttmp_ie = (struct brcmf_vs_tlv *)rsn_ie;\n\n\t\t\t/* RSN IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, tmp_ie, true);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"No WPA(2) IEs found\\n\");\n\t\tbrcmf_configure_opensecurity(ifp);\n\t}\n\n\t/* Parameters shared by all radio interfaces */\n\tif (!mbss) {\n\t\tif ((supports_11d) && (is_11d != ifp->vif->is_11d)) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t\t\t    is_11d);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Regulatory Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->beacon_interval) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,\n\t\t\t\t\t\t    settings->beacon_interval);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Beacon Interval Set Error, %d\\n\",\n\t\t\t\t\t  err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->dtim_period) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,\n\t\t\t\t\t\t    settings->dtim_period);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"DTIM Interval Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif ((dev_role == NL80211_IFTYPE_AP) &&\n\t\t    ((ifp->ifidx == 0) ||\n\t\t     !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"BRCMF_C_DOWN error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"apsta\", 0);\n\t\t}\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET INFRA error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (WARN_ON(supports_11d && (is_11d != ifp->vif->is_11d))) {\n\t\t/* Multiple-BSS should use same 11d configuration */\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Interface specific setup */\n\tif (dev_role == NL80211_IFTYPE_AP) {\n\t\tif ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 1);\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting AP mode failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!mbss) {\n\t\t\t/* Firmware 10.x requires setting channel after enabling\n\t\t\t * AP and before bringing interface up.\n\t\t\t */\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t\t  chanspec, err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"BRCMF_C_UP error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\t/* On DOWN the firmware removes the WEP keys, reconfigure\n\t\t * them if they were set.\n\t\t */\n\t\tbrcmf_cfg80211_reconfigure_wep(ifp);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\t/* join parameters starts with ssid */\n\t\tmemcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le));\n\t\t/* create softap */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET SSID error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (settings->hidden_ssid) {\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"closednet\", 1);\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"closednet error (%d)\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"AP mode configuration complete\\n\");\n\t} else if (dev_role == NL80211_IFTYPE_P2P_GO) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t  chanspec, err);\n\t\t\tgoto exit;\n\t\t}\n\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"ssid\", &ssid_le,\n\t\t\t\t\t\tsizeof(ssid_le));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting ssid failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(1);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"bss_enable config failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"GO mode configuration complete\\n\");\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\tbrcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);\n\tset_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, true);\n\nexit:\n\tif ((err) && (!mbss)) {\n\t\tbrcmf_set_mpc(ifp, 1);\n\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t}\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tstruct brcmf_join_params join_params;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {\n\t\t/* Due to most likely deauths outstanding we sleep */\n\t\t/* first to make sure they get processed by fw. */\n\t\tmsleep(400);\n\n\t\tif (ifp->vif->mbss) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\treturn err;\n\t\t}\n\n\t\t/* First BSS doesn't get a full reset */\n\t\tif (ifp->bsscfgidx == 0)\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"closednet\", 0);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"SET SSID error (%d)\\n\", err);\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"BRCMF_C_DOWN error %d\\n\", err);\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"setting AP mode failed %d\\n\", err);\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 0);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t      ifp->vif->is_11d);\n\t\t/* Bring device back up so it can be used again */\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"BRCMF_C_UP error %d\\n\", err);\n\n\t\tbrcmf_vif_clear_mgmt_ies(ifp->vif);\n\t} else {\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(0);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0)\n\t\t\tbrcmf_err(\"bss_enable config failed %d\\n\", err);\n\t}\n\tbrcmf_set_mpc(ifp, 1);\n\tbrcmf_configure_arp_nd_offload(ifp, true);\n\tclear_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, false);\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t     struct cfg80211_beacon_data *info)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\terr = brcmf_config_ap_mgmt_ie(ifp->vif, info);\n\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_del_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   struct station_del_parameters *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tif (!params->mac)\n\t\treturn -EFAULT;\n\n\tbrcmf_dbg(TRACE, \"Enter %pM\\n\", params->mac);\n\n\tif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\tifp = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemcpy(&scbval.ea, params->mac, ETH_ALEN);\n\tscbval.val = cpu_to_le32(params->reason_code);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCB_DEAUTHENTICATE_FOR_REASON,\n\t\t\t\t     &scbval, sizeof(scbval));\n\tif (err)\n\t\tbrcmf_err(\"SCB_DEAUTHENTICATE_FOR_REASON failed %d\\n\", err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_change_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t      const u8 *mac, struct station_parameters *params)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, MAC %pM, mask 0x%04x set 0x%04x\\n\", mac,\n\t\t  params->sta_flags_mask, params->sta_flags_set);\n\n\t/* Ignore all 00 MAC */\n\tif (is_zero_ether_addr(mac))\n\t\treturn 0;\n\n\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\treturn 0;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_AUTHORIZE,\n\t\t\t\t\t     (void *)mac, ETH_ALEN);\n\telse\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_DEAUTHORIZE,\n\t\t\t\t\t     (void *)mac, ETH_ALEN);\n\tif (err < 0)\n\t\tbrcmf_err(\"Setting SCB (de-)authorize failed, %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void\nbrcmf_cfg80211_mgmt_frame_register(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t   u16 frame_type, bool reg)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tu16 mgmt_type;\n\n\tbrcmf_dbg(TRACE, \"Enter, frame_type %04x, reg=%d\\n\", frame_type, reg);\n\n\tmgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tif (reg)\n\t\tvif->mgmt_rx_reg |= BIT(mgmt_type);\n\telse\n\t\tvif->mgmt_rx_reg &= ~BIT(mgmt_type);\n}\n\n\nstatic int\nbrcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t       struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct ieee80211_channel *chan = params->chan;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\ts32 ie_offset;\n\ts32 ie_len;\n\tstruct brcmf_fil_action_frame_le *action_frame;\n\tstruct brcmf_fil_af_params_le *af_params;\n\tbool ack;\n\ts32 chan_nr;\n\tu32 freq;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t*cookie = 0;\n\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control)) {\n\t\tbrcmf_err(\"Driver only allows MGMT packet type\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\t/* Right now the only reason to get a probe response */\n\t\t/* is for p2p listen response or for p2p GO from     */\n\t\t/* wpa_supplicant. Unfortunately the probe is send   */\n\t\t/* on primary ndev, while dongle wants it on the p2p */\n\t\t/* vif. Since this is only reason for a probe        */\n\t\t/* response to be sent, the vif is taken from cfg.   */\n\t\t/* If ever desired to send proberesp for non p2p     */\n\t\t/* response then data should be checked for          */\n\t\t/* \"DIRECT-\". Note in future supplicant will take    */\n\t\t/* dedicated p2p wdev to do this and then this 'hack'*/\n\t\t/* is not needed anymore.                            */\n\t\tie_offset =  DOT11_MGMT_HDR_LEN +\n\t\t\t     DOT11_BCN_PRB_FIXED_LEN;\n\t\tie_len = len - ie_offset;\n\t\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)\n\t\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\t\terr = brcmf_vif_set_mgmt_ie(vif,\n\t\t\t\t\t    BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t\t    &buf[ie_offset],\n\t\t\t\t\t    ie_len);\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,\n\t\t\t\t\tGFP_KERNEL);\n\t} else if (ieee80211_is_action(mgmt->frame_control)) {\n\t\tif (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {\n\t\t\tbrcmf_err(\"invalid action frame length\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\taf_params = kzalloc(sizeof(*af_params), GFP_KERNEL);\n\t\tif (af_params == NULL) {\n\t\t\tbrcmf_err(\"unable to allocate frame\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\taction_frame = &af_params->action_frame;\n\t\t/* Add the packet Id */\n\t\taction_frame->packet_id = cpu_to_le32(*cookie);\n\t\t/* Add BSSID */\n\t\tmemcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);\n\t\tmemcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);\n\t\t/* Add the length exepted for 802.11 header  */\n\t\taction_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);\n\t\t/* Add the channel. Use the one specified as parameter if any or\n\t\t * the current one (got from the firmware) otherwise\n\t\t */\n\t\tif (chan)\n\t\t\tfreq = chan->center_freq;\n\t\telse\n\t\t\tbrcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,\n\t\t\t\t\t      &freq);\n\t\tchan_nr = ieee80211_frequency_to_channel(freq);\n\t\taf_params->channel = cpu_to_le32(chan_nr);\n\n\t\tmemcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],\n\t\t       le16_to_cpu(action_frame->len));\n\n\t\tbrcmf_dbg(TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\",\n\t\t\t  *cookie, le16_to_cpu(action_frame->len), freq);\n\n\t\tack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),\n\t\t\t\t\t\t  af_params);\n\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,\n\t\t\t\t\tGFP_KERNEL);\n\t\tkfree(af_params);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control);\n\t\tbrcmf_dbg_hex_dump(true, buf, len, \"payload, len=%zu\\n\", len);\n\t}\n\nexit:\n\treturn err;\n}\n\n\nstatic int\nbrcmf_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\t\tu64 cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\tint err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter p2p listen cancel\\n\");\n\n\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\tif (vif == NULL) {\n\t\tbrcmf_err(\"No p2p device available for probe response\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\tbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\nexit:\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_get_channel(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\tstruct brcmf_if *ifp;\n\tstruct brcmu_chan ch;\n\tenum nl80211_band band = 0;\n\tenum nl80211_chan_width width = 0;\n\tu32 chanspec;\n\tint freq, err;\n\n\tif (!ndev)\n\t\treturn -ENODEV;\n\tifp = netdev_priv(ndev);\n\n\terr = brcmf_fil_iovar_int_get(ifp, \"chanspec\", &chanspec);\n\tif (err) {\n\t\tbrcmf_err(\"chanspec failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tch.chspec = chanspec;\n\tcfg->d11inf.decchspec(&ch);\n\n\tswitch (ch.band) {\n\tcase BRCMU_CHAN_BAND_2G:\n\t\tband = NL80211_BAND_2GHZ;\n\t\tbreak;\n\tcase BRCMU_CHAN_BAND_5G:\n\t\tband = NL80211_BAND_5GHZ;\n\t\tbreak;\n\t}\n\n\tswitch (ch.bw) {\n\tcase BRCMU_CHAN_BW_80:\n\t\twidth = NL80211_CHAN_WIDTH_80;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_40:\n\t\twidth = NL80211_CHAN_WIDTH_40;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_20:\n\t\twidth = NL80211_CHAN_WIDTH_20;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_80P80:\n\t\twidth = NL80211_CHAN_WIDTH_80P80;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_160:\n\t\twidth = NL80211_CHAN_WIDTH_160;\n\t\tbreak;\n\t}\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band);\n\tchandef->chan = ieee80211_get_channel(wiphy, freq);\n\tchandef->width = width;\n\tchandef->center_freq1 = ieee80211_channel_to_frequency(ch.chnum, band);\n\tchandef->center_freq2 = 0;\n\n\treturn 0;\n}\n\nstatic int brcmf_cfg80211_crit_proto_start(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_crit_proto_id proto,\n\t\t\t\t\t   u16 duration)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\t/* only DHCP support for now */\n\tif (proto != NL80211_CRIT_PROTO_DHCP)\n\t\treturn -EINVAL;\n\n\t/* suppress and abort scanning */\n\tset_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n\tbrcmf_abort_scanning(cfg);\n\n\treturn brcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_DISABLED, duration);\n}\n\nstatic void brcmf_cfg80211_crit_proto_stop(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\n\tclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n}\n\nstatic s32\nbrcmf_notify_tdls_peer_event(struct brcmf_if *ifp,\n\t\t\t     const struct brcmf_event_msg *e, void *data)\n{\n\tswitch (e->reason) {\n\tcase BRCMF_E_REASON_TDLS_PEER_DISCOVERED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Discovered\\n\");\n\t\tbreak;\n\tcase BRCMF_E_REASON_TDLS_PEER_CONNECTED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Connected\\n\");\n\t\tbrcmf_proto_add_tdls_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t\tbreak;\n\tcase BRCMF_E_REASON_TDLS_PEER_DISCONNECTED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Disconnected\\n\");\n\t\tbrcmf_proto_delete_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmf_convert_nl80211_tdls_oper(enum nl80211_tdls_operation oper)\n{\n\tint ret;\n\n\tswitch (oper) {\n\tcase NL80211_TDLS_DISCOVERY_REQ:\n\t\tret = BRCMF_TDLS_MANUAL_EP_DISCOVERY;\n\t\tbreak;\n\tcase NL80211_TDLS_SETUP:\n\t\tret = BRCMF_TDLS_MANUAL_EP_CREATE;\n\t\tbreak;\n\tcase NL80211_TDLS_TEARDOWN:\n\t\tret = BRCMF_TDLS_MANUAL_EP_DELETE;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"unsupported operation: %d\\n\", oper);\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nstatic int brcmf_cfg80211_tdls_oper(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *ndev, const u8 *peer,\n\t\t\t\t    enum nl80211_tdls_operation oper)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_tdls_iovar_le info;\n\tint ret = 0;\n\n\tret = brcmf_convert_nl80211_tdls_oper(oper);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tifp = netdev_priv(ndev);\n\tmemset(&info, 0, sizeof(info));\n\tinfo.mode = (u8)ret;\n\tif (peer)\n\t\tmemcpy(info.ea, peer, ETH_ALEN);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"tdls_endpoint\",\n\t\t\t\t       &info, sizeof(info));\n\tif (ret < 0)\n\t\tbrcmf_err(\"tdls_endpoint iovar failed: ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int\nbrcmf_cfg80211_update_conn_params(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *ndev,\n\t\t\t\t  struct cfg80211_connect_params *sme,\n\t\t\t\t  u32 changed)\n{\n\tstruct brcmf_if *ifp;\n\tint err;\n\n\tif (!(changed & UPDATE_ASSOC_IES))\n\t\treturn 0;\n\n\tifp = netdev_priv(ndev);\n\terr = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,\n\t\t\t\t    sme->ie, sme->ie_len);\n\tif (err)\n\t\tbrcmf_err(\"Set Assoc REQ IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Assoc request\\n\");\n\n\treturn err;\n}\n\n#ifdef CONFIG_PM\nstatic int\nbrcmf_cfg80211_set_rekey_data(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t      struct cfg80211_gtk_rekey_data *gtk)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_gtk_keyinfo_le gtk_le;\n\tint ret;\n\n\tbrcmf_dbg(TRACE, \"Enter, bssidx=%d\\n\", ifp->bsscfgidx);\n\n\tmemcpy(gtk_le.kck, gtk->kck, sizeof(gtk_le.kck));\n\tmemcpy(gtk_le.kek, gtk->kek, sizeof(gtk_le.kek));\n\tmemcpy(gtk_le.replay_counter, gtk->replay_ctr,\n\t       sizeof(gtk_le.replay_counter));\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"gtk_key_info\", &gtk_le,\n\t\t\t\t       sizeof(gtk_le));\n\tif (ret < 0)\n\t\tbrcmf_err(\"gtk_key_info iovar failed: ret=%d\\n\", ret);\n\n\treturn ret;\n}\n#endif\n\nstatic int brcmf_cfg80211_set_pmk(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const struct cfg80211_pmk_conf *conf)\n{\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\t/* expect using firmware supplicant for 1X */\n\tifp = netdev_priv(dev);\n\tif (WARN_ON(ifp->vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_1X))\n\t\treturn -EINVAL;\n\n\treturn brcmf_set_pmk(ifp, conf->pmk, conf->pmk_len);\n}\n\nstatic int brcmf_cfg80211_del_pmk(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *aa)\n{\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\tifp = netdev_priv(dev);\n\tif (WARN_ON(ifp->vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_1X))\n\t\treturn -EINVAL;\n\n\treturn brcmf_set_pmk(ifp, NULL, 0);\n}\n\nstatic struct cfg80211_ops brcmf_cfg80211_ops = {\n\t.add_virtual_intf = brcmf_cfg80211_add_iface,\n\t.del_virtual_intf = brcmf_cfg80211_del_iface,\n\t.change_virtual_intf = brcmf_cfg80211_change_iface,\n\t.scan = brcmf_cfg80211_scan,\n\t.set_wiphy_params = brcmf_cfg80211_set_wiphy_params,\n\t.join_ibss = brcmf_cfg80211_join_ibss,\n\t.leave_ibss = brcmf_cfg80211_leave_ibss,\n\t.get_station = brcmf_cfg80211_get_station,\n\t.dump_station = brcmf_cfg80211_dump_station,\n\t.set_tx_power = brcmf_cfg80211_set_tx_power,\n\t.get_tx_power = brcmf_cfg80211_get_tx_power,\n\t.add_key = brcmf_cfg80211_add_key,\n\t.del_key = brcmf_cfg80211_del_key,\n\t.get_key = brcmf_cfg80211_get_key,\n\t.set_default_key = brcmf_cfg80211_config_default_key,\n\t.set_default_mgmt_key = brcmf_cfg80211_config_default_mgmt_key,\n\t.set_power_mgmt = brcmf_cfg80211_set_power_mgmt,\n\t.connect = brcmf_cfg80211_connect,\n\t.disconnect = brcmf_cfg80211_disconnect,\n\t.suspend = brcmf_cfg80211_suspend,\n\t.resume = brcmf_cfg80211_resume,\n\t.set_pmksa = brcmf_cfg80211_set_pmksa,\n\t.del_pmksa = brcmf_cfg80211_del_pmksa,\n\t.flush_pmksa = brcmf_cfg80211_flush_pmksa,\n\t.start_ap = brcmf_cfg80211_start_ap,\n\t.stop_ap = brcmf_cfg80211_stop_ap,\n\t.change_beacon = brcmf_cfg80211_change_beacon,\n\t.del_station = brcmf_cfg80211_del_station,\n\t.change_station = brcmf_cfg80211_change_station,\n\t.sched_scan_start = brcmf_cfg80211_sched_scan_start,\n\t.sched_scan_stop = brcmf_cfg80211_sched_scan_stop,\n\t.mgmt_frame_register = brcmf_cfg80211_mgmt_frame_register,\n\t.mgmt_tx = brcmf_cfg80211_mgmt_tx,\n\t.remain_on_channel = brcmf_p2p_remain_on_channel,\n\t.cancel_remain_on_channel = brcmf_cfg80211_cancel_remain_on_channel,\n\t.get_channel = brcmf_cfg80211_get_channel,\n\t.start_p2p_device = brcmf_p2p_start_device,\n\t.stop_p2p_device = brcmf_p2p_stop_device,\n\t.crit_proto_start = brcmf_cfg80211_crit_proto_start,\n\t.crit_proto_stop = brcmf_cfg80211_crit_proto_stop,\n\t.tdls_oper = brcmf_cfg80211_tdls_oper,\n\t.update_connect_params = brcmf_cfg80211_update_conn_params,\n\t.set_pmk = brcmf_cfg80211_set_pmk,\n\t.del_pmk = brcmf_cfg80211_del_pmk,\n};\n\nstruct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t\t   enum nl80211_iftype type)\n{\n\tstruct brcmf_cfg80211_vif *vif_walk;\n\tstruct brcmf_cfg80211_vif *vif;\n\tbool mbss;\n\n\tbrcmf_dbg(TRACE, \"allocating virtual interface (size=%zu)\\n\",\n\t\t  sizeof(*vif));\n\tvif = kzalloc(sizeof(*vif), GFP_KERNEL);\n\tif (!vif)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvif->wdev.wiphy = cfg->wiphy;\n\tvif->wdev.iftype = type;\n\n\tbrcmf_init_prof(&vif->profile);\n\n\tif (type == NL80211_IFTYPE_AP) {\n\t\tmbss = false;\n\t\tlist_for_each_entry(vif_walk, &cfg->vif_list, list) {\n\t\t\tif (vif_walk->wdev.iftype == NL80211_IFTYPE_AP) {\n\t\t\t\tmbss = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvif->mbss = mbss;\n\t}\n\n\tlist_add_tail(&vif->list, &cfg->vif_list);\n\treturn vif;\n}\n\nvoid brcmf_free_vif(struct brcmf_cfg80211_vif *vif)\n{\n\tlist_del(&vif->list);\n\tkfree(vif);\n}\n\nvoid brcmf_cfg80211_free_netdev(struct net_device *ndev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tifp = netdev_priv(ndev);\n\tvif = ifp->vif;\n\n\tif (vif)\n\t\tbrcmf_free_vif(vif);\n}\n\nstatic bool brcmf_is_linkup(struct brcmf_cfg80211_vif *vif,\n\t\t\t    const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (vif->profile.use_fwsup == BRCMF_PROFILE_FWSUP_PSK &&\n\t    event == BRCMF_E_PSK_SUP &&\n\t    status == BRCMF_E_STATUS_FWSUP_COMPLETED)\n\t\tset_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);\n\tif (event == BRCMF_E_SET_SSID && status == BRCMF_E_STATUS_SUCCESS) {\n\t\tbrcmf_dbg(CONN, \"Processing set ssid\\n\");\n\t\tmemcpy(vif->profile.bssid, e->addr, ETH_ALEN);\n\t\tif (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_PSK)\n\t\t\treturn true;\n\n\t\tset_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);\n\t}\n\n\tif (test_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state) &&\n\t    test_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state)) {\n\t\tclear_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);\n\t\tclear_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool brcmf_is_linkdown(const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu16 flags = e->flags;\n\n\tif ((event == BRCMF_E_DEAUTH) || (event == BRCMF_E_DEAUTH_IND) ||\n\t    (event == BRCMF_E_DISASSOC_IND) ||\n\t    ((event == BRCMF_E_LINK) && (!(flags & BRCMF_EVENT_MSG_LINK)))) {\n\t\tbrcmf_dbg(CONN, \"Processing link down\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool brcmf_is_nonetwork(struct brcmf_cfg80211_info *cfg,\n\t\t\t       const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (event == BRCMF_E_LINK && status == BRCMF_E_STATUS_NO_NETWORKS) {\n\t\tbrcmf_dbg(CONN, \"Processing Link %s & no network found\\n\",\n\t\t\t  e->flags & BRCMF_EVENT_MSG_LINK ? \"up\" : \"down\");\n\t\treturn true;\n\t}\n\n\tif (event == BRCMF_E_SET_SSID && status != BRCMF_E_STATUS_SUCCESS) {\n\t\tbrcmf_dbg(CONN, \"Processing connecting & no network found\\n\");\n\t\treturn true;\n\t}\n\n\tif (event == BRCMF_E_PSK_SUP &&\n\t    status != BRCMF_E_STATUS_FWSUP_COMPLETED) {\n\t\tbrcmf_dbg(CONN, \"Processing failed supplicant state: %u\\n\",\n\t\t\t  status);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void brcmf_clear_assoc_ies(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\n\tkfree(conn_info->req_ie);\n\tconn_info->req_ie = NULL;\n\tconn_info->req_ie_len = 0;\n\tkfree(conn_info->resp_ie);\n\tconn_info->resp_ie = NULL;\n\tconn_info->resp_ie_len = 0;\n}\n\nstatic s32 brcmf_get_assoc_ies(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_assoc_ielen_le *assoc_info;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tu32 req_len;\n\tu32 resp_len;\n\ts32 err = 0;\n\n\tbrcmf_clear_assoc_ies(cfg);\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_info\",\n\t\t\t\t       cfg->extra_buf, WL_ASSOC_INFO_MAX);\n\tif (err) {\n\t\tbrcmf_err(\"could not get assoc info (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tassoc_info =\n\t\t(struct brcmf_cfg80211_assoc_ielen_le *)cfg->extra_buf;\n\treq_len = le32_to_cpu(assoc_info->req_len);\n\tresp_len = le32_to_cpu(assoc_info->resp_len);\n\tif (req_len) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_req_ies\",\n\t\t\t\t\t       cfg->extra_buf,\n\t\t\t\t\t       WL_ASSOC_INFO_MAX);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"could not get assoc req (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tconn_info->req_ie_len = req_len;\n\t\tconn_info->req_ie =\n\t\t    kmemdup(cfg->extra_buf, conn_info->req_ie_len,\n\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tconn_info->req_ie_len = 0;\n\t\tconn_info->req_ie = NULL;\n\t}\n\tif (resp_len) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_resp_ies\",\n\t\t\t\t\t       cfg->extra_buf,\n\t\t\t\t\t       WL_ASSOC_INFO_MAX);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"could not get assoc resp (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tconn_info->resp_ie_len = resp_len;\n\t\tconn_info->resp_ie =\n\t\t    kmemdup(cfg->extra_buf, conn_info->resp_ie_len,\n\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tconn_info->resp_ie_len = 0;\n\t\tconn_info->resp_ie = NULL;\n\t}\n\tbrcmf_dbg(CONN, \"req len (%d) resp len (%d)\\n\",\n\t\t  conn_info->req_ie_len, conn_info->resp_ie_len);\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_bss_roaming_done(struct brcmf_cfg80211_info *cfg,\n\t\t       struct net_device *ndev,\n\t\t       const struct brcmf_event_msg *e)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct ieee80211_channel *notify_channel = NULL;\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmf_bss_info_le *bi;\n\tstruct brcmu_chan ch;\n\tstruct cfg80211_roam_info roam_info = {};\n\tu32 freq;\n\ts32 err = 0;\n\tu8 *buf;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tbrcmf_get_assoc_ies(cfg, ifp);\n\tmemcpy(profile->bssid, e->addr, ETH_ALEN);\n\tbrcmf_update_bss_info(cfg, ifp);\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t/* data sent to dongle has to be little endian */\n\t*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     buf, WL_BSS_INFO_MAX);\n\n\tif (err)\n\t\tgoto done;\n\n\tbi = (struct brcmf_bss_info_le *)(buf + 4);\n\tch.chspec = le16_to_cpu(bi->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\n\tif (ch.band == BRCMU_CHAN_BAND_2G)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\ndone:\n\tkfree(buf);\n\n\troam_info.channel = notify_channel;\n\troam_info.bssid = profile->bssid;\n\troam_info.req_ie = conn_info->req_ie;\n\troam_info.req_ie_len = conn_info->req_ie_len;\n\troam_info.resp_ie = conn_info->resp_ie;\n\troam_info.resp_ie_len = conn_info->resp_ie_len;\n\n\tcfg80211_roamed(ndev, &roam_info, GFP_KERNEL);\n\tbrcmf_dbg(CONN, \"Report roaming result\\n\");\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_bss_connect_done(struct brcmf_cfg80211_info *cfg,\n\t\t       struct net_device *ndev, const struct brcmf_event_msg *e,\n\t\t       bool completed)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tstruct cfg80211_connect_resp_params conn_params;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t       &ifp->vif->sme_state)) {\n\t\tmemset(&conn_params, 0, sizeof(conn_params));\n\t\tif (completed) {\n\t\t\tbrcmf_get_assoc_ies(cfg, ifp);\n\t\t\tbrcmf_update_bss_info(cfg, ifp);\n\t\t\tset_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t\t&ifp->vif->sme_state);\n\t\t\tconn_params.status = WLAN_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tconn_params.status = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t}\n\t\tconn_params.bssid = profile->bssid;\n\t\tconn_params.req_ie = conn_info->req_ie;\n\t\tconn_params.req_ie_len = conn_info->req_ie_len;\n\t\tconn_params.resp_ie = conn_info->resp_ie;\n\t\tconn_params.resp_ie_len = conn_info->resp_ie_len;\n\t\tcfg80211_connect_done(ndev, &conn_params, GFP_KERNEL);\n\t\tbrcmf_dbg(CONN, \"Report connect result - connection %s\\n\",\n\t\t\t  completed ? \"succeeded\" : \"failed\");\n\t}\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_connect_status_ap(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct net_device *ndev,\n\t\t\t       const struct brcmf_event_msg *e, void *data)\n{\n\tstatic int generation;\n\tu32 event = e->event_code;\n\tu32 reason = e->reason;\n\tstruct station_info sinfo;\n\n\tbrcmf_dbg(CONN, \"event %s (%u), reason %d\\n\",\n\t\t  brcmf_fweh_event_name(event), event, reason);\n\tif (event == BRCMF_E_LINK && reason == BRCMF_E_REASON_LINK_BSSCFG_DIS &&\n\t    ndev != cfg_to_ndev(cfg)) {\n\t\tbrcmf_dbg(CONN, \"AP mode link down\\n\");\n\t\tcomplete(&cfg->vif_disabled);\n\t\treturn 0;\n\t}\n\n\tif (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&\n\t    (reason == BRCMF_E_STATUS_SUCCESS)) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tif (!data) {\n\t\t\tbrcmf_err(\"No IEs present in ASSOC/REASSOC_IND\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsinfo.assoc_req_ies = data;\n\t\tsinfo.assoc_req_ies_len = e->datalen;\n\t\tgeneration++;\n\t\tsinfo.generation = generation;\n\t\tcfg80211_new_sta(ndev, e->addr, &sinfo, GFP_KERNEL);\n\t} else if ((event == BRCMF_E_DISASSOC_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH)) {\n\t\tcfg80211_del_sta(ndev, e->addr, GFP_KERNEL);\n\t}\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_connect_status(struct brcmf_if *ifp,\n\t\t\t    const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct net_device *ndev = ifp->ndev;\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct ieee80211_channel *chan;\n\ts32 err = 0;\n\n\tif ((e->event_code == BRCMF_E_DEAUTH) ||\n\t    (e->event_code == BRCMF_E_DEAUTH_IND) ||\n\t    (e->event_code == BRCMF_E_DISASSOC_IND) ||\n\t    ((e->event_code == BRCMF_E_LINK) && (!e->flags))) {\n\t\tbrcmf_proto_delete_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t}\n\n\tif (brcmf_is_apmode(ifp->vif)) {\n\t\terr = brcmf_notify_connect_status_ap(cfg, ndev, e, data);\n\t} else if (brcmf_is_linkup(ifp->vif, e)) {\n\t\tbrcmf_dbg(CONN, \"Linkup\\n\");\n\t\tif (brcmf_is_ibssmode(ifp->vif)) {\n\t\t\tbrcmf_inform_ibss(cfg, ndev, e->addr);\n\t\t\tchan = ieee80211_get_channel(cfg->wiphy, cfg->channel);\n\t\t\tmemcpy(profile->bssid, e->addr, ETH_ALEN);\n\t\t\tcfg80211_ibss_joined(ndev, e->addr, chan, GFP_KERNEL);\n\t\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t\t  &ifp->vif->sme_state);\n\t\t\tset_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t\t&ifp->vif->sme_state);\n\t\t} else\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, true);\n\t\tbrcmf_net_setcarrier(ifp, true);\n\t} else if (brcmf_is_linkdown(e)) {\n\t\tbrcmf_dbg(CONN, \"Linkdown\\n\");\n\t\tif (!brcmf_is_ibssmode(ifp->vif)) {\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, false);\n\t\t\tbrcmf_link_down(ifp->vif,\n\t\t\t\t\tbrcmf_map_fw_linkdown_reason(e));\n\t\t\tbrcmf_init_prof(ndev_to_prof(ndev));\n\t\t\tif (ndev != cfg_to_ndev(cfg))\n\t\t\t\tcomplete(&cfg->vif_disabled);\n\t\t\tbrcmf_net_setcarrier(ifp, false);\n\t\t}\n\t} else if (brcmf_is_nonetwork(cfg, e)) {\n\t\tif (brcmf_is_ibssmode(ifp->vif))\n\t\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t\t  &ifp->vif->sme_state);\n\t\telse\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, false);\n\t}\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_notify_roaming_status(struct brcmf_if *ifp,\n\t\t\t    const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (event == BRCMF_E_ROAM && status == BRCMF_E_STATUS_SUCCESS) {\n\t\tif (test_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state))\n\t\t\tbrcmf_bss_roaming_done(cfg, ifp->ndev, e);\n\t\telse\n\t\t\tbrcmf_bss_connect_done(cfg, ifp->ndev, e, true);\n\t}\n\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_mic_status(struct brcmf_if *ifp,\n\t\t\tconst struct brcmf_event_msg *e, void *data)\n{\n\tu16 flags = e->flags;\n\tenum nl80211_key_type key_type;\n\n\tif (flags & BRCMF_EVENT_MSG_GROUP)\n\t\tkey_type = NL80211_KEYTYPE_GROUP;\n\telse\n\t\tkey_type = NL80211_KEYTYPE_PAIRWISE;\n\n\tcfg80211_michael_mic_failure(ifp->ndev, (u8 *)&e->addr, key_type, -1,\n\t\t\t\t     NULL, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic s32 brcmf_notify_vif_event(struct brcmf_if *ifp,\n\t\t\t\t  const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_if_event *ifevent = (struct brcmf_if_event *)data;\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(TRACE, \"Enter: action %u flags %u ifidx %u bsscfgidx %u\\n\",\n\t\t  ifevent->action, ifevent->flags, ifevent->ifidx,\n\t\t  ifevent->bsscfgidx);\n\n\tspin_lock(&event->vif_event_lock);\n\tevent->action = ifevent->action;\n\tvif = event->vif;\n\n\tswitch (ifevent->action) {\n\tcase BRCMF_E_IF_ADD:\n\t\t/* waiting process may have timed out */\n\t\tif (!cfg->vif_event.vif) {\n\t\t\tspin_unlock(&event->vif_event_lock);\n\t\t\treturn -EBADF;\n\t\t}\n\n\t\tifp->vif = vif;\n\t\tvif->ifp = ifp;\n\t\tif (ifp->ndev) {\n\t\t\tvif->wdev.netdev = ifp->ndev;\n\t\t\tifp->ndev->ieee80211_ptr = &vif->wdev;\n\t\t\tSET_NETDEV_DEV(ifp->ndev, wiphy_dev(cfg->wiphy));\n\t\t}\n\t\tspin_unlock(&event->vif_event_lock);\n\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tcase BRCMF_E_IF_DEL:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\t/* event may not be upon user request */\n\t\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tcase BRCMF_E_IF_CHANGE:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tdefault:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void brcmf_init_conf(struct brcmf_cfg80211_conf *conf)\n{\n\tconf->frag_threshold = (u32)-1;\n\tconf->rts_threshold = (u32)-1;\n\tconf->retry_short = (u32)-1;\n\tconf->retry_long = (u32)-1;\n}\n\nstatic void brcmf_register_event_handlers(struct brcmf_cfg80211_info *cfg)\n{\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_LINK,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DISASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_REASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ROAM,\n\t\t\t    brcmf_notify_roaming_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_MIC_ERROR,\n\t\t\t    brcmf_notify_mic_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_SET_SSID,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t    brcmf_notify_sched_scan_results);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_IF,\n\t\t\t    brcmf_notify_vif_event);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_PROBEREQ_MSG,\n\t\t\t    brcmf_p2p_notify_rx_mgmt_p2p_probereq);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_DISC_LISTEN_COMPLETE,\n\t\t\t    brcmf_p2p_notify_listen_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_RX,\n\t\t\t    brcmf_p2p_notify_action_frame_rx);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_COMPLETE,\n\t\t\t    brcmf_p2p_notify_action_tx_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_OFF_CHAN_COMPLETE,\n\t\t\t    brcmf_p2p_notify_action_tx_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PSK_SUP,\n\t\t\t    brcmf_notify_connect_status);\n}\n\nstatic void brcmf_deinit_priv_mem(struct brcmf_cfg80211_info *cfg)\n{\n\tkfree(cfg->conf);\n\tcfg->conf = NULL;\n\tkfree(cfg->extra_buf);\n\tcfg->extra_buf = NULL;\n\tkfree(cfg->wowl.nd);\n\tcfg->wowl.nd = NULL;\n\tkfree(cfg->wowl.nd_info);\n\tcfg->wowl.nd_info = NULL;\n\tkfree(cfg->escan_info.escan_buf);\n\tcfg->escan_info.escan_buf = NULL;\n}\n\nstatic s32 brcmf_init_priv_mem(struct brcmf_cfg80211_info *cfg)\n{\n\tcfg->conf = kzalloc(sizeof(*cfg->conf), GFP_KERNEL);\n\tif (!cfg->conf)\n\t\tgoto init_priv_mem_out;\n\tcfg->extra_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!cfg->extra_buf)\n\t\tgoto init_priv_mem_out;\n\tcfg->wowl.nd = kzalloc(sizeof(*cfg->wowl.nd) + sizeof(u32), GFP_KERNEL);\n\tif (!cfg->wowl.nd)\n\t\tgoto init_priv_mem_out;\n\tcfg->wowl.nd_info = kzalloc(sizeof(*cfg->wowl.nd_info) +\n\t\t\t\t    sizeof(struct cfg80211_wowlan_nd_match *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!cfg->wowl.nd_info)\n\t\tgoto init_priv_mem_out;\n\tcfg->escan_info.escan_buf = kzalloc(BRCMF_ESCAN_BUF_SIZE, GFP_KERNEL);\n\tif (!cfg->escan_info.escan_buf)\n\t\tgoto init_priv_mem_out;\n\n\treturn 0;\n\ninit_priv_mem_out:\n\tbrcmf_deinit_priv_mem(cfg);\n\n\treturn -ENOMEM;\n}\n\nstatic s32 wl_init_priv(struct brcmf_cfg80211_info *cfg)\n{\n\ts32 err = 0;\n\n\tcfg->scan_request = NULL;\n\tcfg->pwr_save = true;\n\tcfg->active_scan = true;\t/* we do active scan per default */\n\tcfg->dongle_up = false;\t\t/* dongle is not up yet */\n\terr = brcmf_init_priv_mem(cfg);\n\tif (err)\n\t\treturn err;\n\tbrcmf_register_event_handlers(cfg);\n\tmutex_init(&cfg->usr_sync);\n\tbrcmf_init_escan(cfg);\n\tbrcmf_init_conf(cfg->conf);\n\tinit_completion(&cfg->vif_disabled);\n\treturn err;\n}\n\nstatic void wl_deinit_priv(struct brcmf_cfg80211_info *cfg)\n{\n\tcfg->dongle_up = false;\t/* dongle down */\n\tbrcmf_abort_scanning(cfg);\n\tbrcmf_deinit_priv_mem(cfg);\n}\n\nstatic void init_vif_event(struct brcmf_cfg80211_vif_event *event)\n{\n\tinit_waitqueue_head(&event->vif_wq);\n\tspin_lock_init(&event->vif_event_lock);\n}\n\nstatic s32 brcmf_dongle_roam(struct brcmf_if *ifp)\n{\n\ts32 err;\n\tu32 bcn_timeout;\n\t__le32 roamtrigger[2];\n\t__le32 roam_delta[2];\n\n\t/* Configure beacon timeout value based upon roaming setting */\n\tif (ifp->drvr->settings->roamoff)\n\t\tbcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_OFF;\n\telse\n\t\tbcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_ON;\n\terr = brcmf_fil_iovar_int_set(ifp, \"bcn_timeout\", bcn_timeout);\n\tif (err) {\n\t\tbrcmf_err(\"bcn_timeout error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\t/* Enable/Disable built-in roaming to allow supplicant to take care of\n\t * roaming.\n\t */\n\tbrcmf_dbg(INFO, \"Internal Roaming = %s\\n\",\n\t\t  ifp->drvr->settings->roamoff ? \"Off\" : \"On\");\n\terr = brcmf_fil_iovar_int_set(ifp, \"roam_off\",\n\t\t\t\t      ifp->drvr->settings->roamoff);\n\tif (err) {\n\t\tbrcmf_err(\"roam_off error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\troamtrigger[0] = cpu_to_le32(WL_ROAM_TRIGGER_LEVEL);\n\troamtrigger[1] = cpu_to_le32(BRCM_BAND_ALL);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,\n\t\t\t\t     (void *)roamtrigger, sizeof(roamtrigger));\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_ROAM_TRIGGER error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\troam_delta[0] = cpu_to_le32(WL_ROAM_DELTA);\n\troam_delta[1] = cpu_to_le32(BRCM_BAND_ALL);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,\n\t\t\t\t     (void *)roam_delta, sizeof(roam_delta));\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_ROAM_DELTA error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\nroam_setup_done:\n\treturn err;\n}\n\nstatic s32\nbrcmf_dongle_scantime(struct brcmf_if *ifp)\n{\n\ts32 err = 0;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,\n\t\t\t\t    BRCMF_SCAN_CHANNEL_TIME);\n\tif (err) {\n\t\tbrcmf_err(\"Scan assoc time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,\n\t\t\t\t    BRCMF_SCAN_UNASSOC_TIME);\n\tif (err) {\n\t\tbrcmf_err(\"Scan unassoc time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_PASSIVE_TIME,\n\t\t\t\t    BRCMF_SCAN_PASSIVE_TIME);\n\tif (err) {\n\t\tbrcmf_err(\"Scan passive time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\ndongle_scantime_out:\n\treturn err;\n}\n\nstatic void brcmf_update_bw40_channel_flag(struct ieee80211_channel *channel,\n\t\t\t\t\t   struct brcmu_chan *ch)\n{\n\tu32 ht40_flag;\n\n\tht40_flag = channel->flags & IEEE80211_CHAN_NO_HT40;\n\tif (ch->sb == BRCMU_CHAN_SB_U) {\n\t\tif (ht40_flag == IEEE80211_CHAN_NO_HT40)\n\t\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40;\n\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40PLUS;\n\t} else {\n\t\t/* It should be one of\n\t\t * IEEE80211_CHAN_NO_HT40 or\n\t\t * IEEE80211_CHAN_NO_HT40PLUS\n\t\t */\n\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40;\n\t\tif (ht40_flag == IEEE80211_CHAN_NO_HT40)\n\t\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40MINUS;\n\t}\n}\n\nstatic int brcmf_construct_chaninfo(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t    u32 bw_cap[])\n{\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct ieee80211_supported_band *band;\n\tstruct ieee80211_channel *channel;\n\tstruct wiphy *wiphy;\n\tstruct brcmf_chanspec_list *list;\n\tstruct brcmu_chan ch;\n\tint err;\n\tu8 *pbuf;\n\tu32 i, j;\n\tu32 total;\n\tu32 chaninfo;\n\n\tpbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\n\n\tif (pbuf == NULL)\n\t\treturn -ENOMEM;\n\n\tlist = (struct brcmf_chanspec_list *)pbuf;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"chanspecs\", pbuf,\n\t\t\t\t       BRCMF_DCMD_MEDLEN);\n\tif (err) {\n\t\tbrcmf_err(\"get chanspecs error (%d)\\n\", err);\n\t\tgoto fail_pbuf;\n\t}\n\n\twiphy = cfg_to_wiphy(cfg);\n\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\tif (band)\n\t\tfor (i = 0; i < band->n_channels; i++)\n\t\t\tband->channels[i].flags = IEEE80211_CHAN_DISABLED;\n\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\tif (band)\n\t\tfor (i = 0; i < band->n_channels; i++)\n\t\t\tband->channels[i].flags = IEEE80211_CHAN_DISABLED;\n\n\ttotal = le32_to_cpu(list->count);\n\tfor (i = 0; i < total; i++) {\n\t\tch.chspec = (u16)le32_to_cpu(list->element[i]);\n\t\tcfg->d11inf.decchspec(&ch);\n\n\t\tif (ch.band == BRCMU_CHAN_BAND_2G) {\n\t\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\t\t} else if (ch.band == BRCMU_CHAN_BAND_5G) {\n\t\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\t\t} else {\n\t\t\tbrcmf_err(\"Invalid channel Spec. 0x%x.\\n\", ch.chspec);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!band)\n\t\t\tcontinue;\n\t\tif (!(bw_cap[band->band] & WLC_BW_40MHZ_BIT) &&\n\t\t    ch.bw == BRCMU_CHAN_BW_40)\n\t\t\tcontinue;\n\t\tif (!(bw_cap[band->band] & WLC_BW_80MHZ_BIT) &&\n\t\t    ch.bw == BRCMU_CHAN_BW_80)\n\t\t\tcontinue;\n\n\t\tchannel = NULL;\n\t\tfor (j = 0; j < band->n_channels; j++) {\n\t\t\tif (band->channels[j].hw_value == ch.control_ch_num) {\n\t\t\t\tchannel = &band->channels[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!channel) {\n\t\t\t/* It seems firmware supports some channel we never\n\t\t\t * considered. Something new in IEEE standard?\n\t\t\t */\n\t\t\tbrcmf_err(\"Ignoring unexpected firmware channel %d\\n\",\n\t\t\t\t  ch.control_ch_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (channel->orig_flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* assuming the chanspecs order is HT20,\n\t\t * HT40 upper, HT40 lower, and VHT80.\n\t\t */\n\t\tif (ch.bw == BRCMU_CHAN_BW_80) {\n\t\t\tchannel->flags &= ~IEEE80211_CHAN_NO_80MHZ;\n\t\t} else if (ch.bw == BRCMU_CHAN_BW_40) {\n\t\t\tbrcmf_update_bw40_channel_flag(channel, &ch);\n\t\t} else {\n\t\t\t/* enable the channel and disable other bandwidths\n\t\t\t * for now as mentioned order assure they are enabled\n\t\t\t * for subsequent chanspecs.\n\t\t\t */\n\t\t\tchannel->flags = IEEE80211_CHAN_NO_HT40 |\n\t\t\t\t\t IEEE80211_CHAN_NO_80MHZ;\n\t\t\tch.bw = BRCMU_CHAN_BW_20;\n\t\t\tcfg->d11inf.encchspec(&ch);\n\t\t\tchaninfo = ch.chspec;\n\t\t\terr = brcmf_fil_bsscfg_int_get(ifp, \"per_chan_info\",\n\t\t\t\t\t\t       &chaninfo);\n\t\t\tif (!err) {\n\t\t\t\tif (chaninfo & WL_CHAN_RADAR)\n\t\t\t\t\tchannel->flags |=\n\t\t\t\t\t\t(IEEE80211_CHAN_RADAR |\n\t\t\t\t\t\t IEEE80211_CHAN_NO_IR);\n\t\t\t\tif (chaninfo & WL_CHAN_PASSIVE)\n\t\t\t\t\tchannel->flags |=\n\t\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\t}\n\t\t}\n\t}\n\nfail_pbuf:\n\tkfree(pbuf);\n\treturn err;\n}\n\nstatic int brcmf_enable_bw40_2g(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmf_fil_bwcap_le band_bwcap;\n\tstruct brcmf_chanspec_list *list;\n\tu8 *pbuf;\n\tu32 val;\n\tint err;\n\tstruct brcmu_chan ch;\n\tu32 num_chan;\n\tint i, j;\n\n\t/* verify support for bw_cap command */\n\tval = WLC_BAND_5G;\n\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &val);\n\n\tif (!err) {\n\t\t/* only set 2G bandwidth using bw_cap command */\n\t\tband_bwcap.band = cpu_to_le32(WLC_BAND_2G);\n\t\tband_bwcap.bw_cap = cpu_to_le32(WLC_BW_CAP_40MHZ);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bw_cap\", &band_bwcap,\n\t\t\t\t\t       sizeof(band_bwcap));\n\t} else {\n\t\tbrcmf_dbg(INFO, \"fallback to mimo_bw_cap\\n\");\n\t\tval = WLC_N_BW_40ALL;\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"mimo_bw_cap\", val);\n\t}\n\n\tif (!err) {\n\t\t/* update channel info in 2G band */\n\t\tpbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\n\n\t\tif (pbuf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tch.band = BRCMU_CHAN_BAND_2G;\n\t\tch.bw = BRCMU_CHAN_BW_40;\n\t\tch.sb = BRCMU_CHAN_SB_NONE;\n\t\tch.chnum = 0;\n\t\tcfg->d11inf.encchspec(&ch);\n\n\t\t/* pass encoded chanspec in query */\n\t\t*(__le16 *)pbuf = cpu_to_le16(ch.chspec);\n\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"chanspecs\", pbuf,\n\t\t\t\t\t       BRCMF_DCMD_MEDLEN);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"get chanspecs error (%d)\\n\", err);\n\t\t\tkfree(pbuf);\n\t\t\treturn err;\n\t\t}\n\n\t\tband = cfg_to_wiphy(cfg)->bands[NL80211_BAND_2GHZ];\n\t\tlist = (struct brcmf_chanspec_list *)pbuf;\n\t\tnum_chan = le32_to_cpu(list->count);\n\t\tfor (i = 0; i < num_chan; i++) {\n\t\t\tch.chspec = (u16)le32_to_cpu(list->element[i]);\n\t\t\tcfg->d11inf.decchspec(&ch);\n\t\t\tif (WARN_ON(ch.band != BRCMU_CHAN_BAND_2G))\n\t\t\t\tcontinue;\n\t\t\tif (WARN_ON(ch.bw != BRCMU_CHAN_BW_40))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < band->n_channels; j++) {\n\t\t\t\tif (band->channels[j].hw_value == ch.control_ch_num)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (WARN_ON(j == band->n_channels))\n\t\t\t\tcontinue;\n\n\t\t\tbrcmf_update_bw40_channel_flag(&band->channels[j], &ch);\n\t\t}\n\t\tkfree(pbuf);\n\t}\n\treturn err;\n}\n\nstatic void brcmf_get_bwcap(struct brcmf_if *ifp, u32 bw_cap[])\n{\n\tu32 band, mimo_bwcap;\n\tint err;\n\n\tband = WLC_BAND_2G;\n\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &band);\n\tif (!err) {\n\t\tbw_cap[NL80211_BAND_2GHZ] = band;\n\t\tband = WLC_BAND_5G;\n\t\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &band);\n\t\tif (!err) {\n\t\t\tbw_cap[NL80211_BAND_5GHZ] = band;\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tbrcmf_dbg(INFO, \"fallback to mimo_bw_cap info\\n\");\n\tmimo_bwcap = 0;\n\terr = brcmf_fil_iovar_int_get(ifp, \"mimo_bw_cap\", &mimo_bwcap);\n\tif (err)\n\t\t/* assume 20MHz if firmware does not give a clue */\n\t\tmimo_bwcap = WLC_N_BW_20ALL;\n\n\tswitch (mimo_bwcap) {\n\tcase WLC_N_BW_40ALL:\n\t\tbw_cap[NL80211_BAND_2GHZ] |= WLC_BW_40MHZ_BIT;\n\t\t/* fall-thru */\n\tcase WLC_N_BW_20IN2G_40IN5G:\n\t\tbw_cap[NL80211_BAND_5GHZ] |= WLC_BW_40MHZ_BIT;\n\t\t/* fall-thru */\n\tcase WLC_N_BW_20ALL:\n\t\tbw_cap[NL80211_BAND_2GHZ] |= WLC_BW_20MHZ_BIT;\n\t\tbw_cap[NL80211_BAND_5GHZ] |= WLC_BW_20MHZ_BIT;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"invalid mimo_bw_cap value\\n\");\n\t}\n}\n\nstatic void brcmf_update_ht_cap(struct ieee80211_supported_band *band,\n\t\t\t\tu32 bw_cap[2], u32 nchain)\n{\n\tband->ht_cap.ht_supported = true;\n\tif (bw_cap[band->band] & WLC_BW_40MHZ_BIT) {\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\n\tband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\tmemset(band->ht_cap.mcs.rx_mask, 0xff, nchain);\n\tband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n}\n\nstatic __le16 brcmf_get_mcs_map(u32 nchain, enum ieee80211_vht_mcs_support supp)\n{\n\tu16 mcs_map;\n\tint i;\n\n\tfor (i = 0, mcs_map = 0xFFFF; i < nchain; i++)\n\t\tmcs_map = (mcs_map << 2) | supp;\n\n\treturn cpu_to_le16(mcs_map);\n}\n\nstatic void brcmf_update_vht_cap(struct ieee80211_supported_band *band,\n\t\t\t\t u32 bw_cap[2], u32 nchain, u32 txstreams,\n\t\t\t\t u32 txbf_bfe_cap, u32 txbf_bfr_cap)\n{\n\t__le16 mcs_map;\n\n\t/* not allowed in 2.4G band */\n\tif (band->band == NL80211_BAND_2GHZ)\n\t\treturn;\n\n\tband->vht_cap.vht_supported = true;\n\t/* 80MHz is mandatory */\n\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_80;\n\tif (bw_cap[band->band] & WLC_BW_160MHZ_BIT) {\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_160;\n\t}\n\t/* all support 256-QAM */\n\tmcs_map = brcmf_get_mcs_map(nchain, IEEE80211_VHT_MCS_SUPPORT_0_9);\n\tband->vht_cap.vht_mcs.rx_mcs_map = mcs_map;\n\tband->vht_cap.vht_mcs.tx_mcs_map = mcs_map;\n\n\t/* Beamforming support information */\n\tif (txbf_bfe_cap & BRCMF_TXBF_SU_BFE_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE;\n\tif (txbf_bfe_cap & BRCMF_TXBF_MU_BFE_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\tif (txbf_bfr_cap & BRCMF_TXBF_SU_BFR_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE;\n\tif (txbf_bfr_cap & BRCMF_TXBF_MU_BFR_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE;\n\n\tif ((txbf_bfe_cap || txbf_bfr_cap) && (txstreams > 1)) {\n\t\tband->vht_cap.cap |=\n\t\t\t(2 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT);\n\t\tband->vht_cap.cap |= ((txstreams - 1) <<\n\t\t\t\tIEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT);\n\t\tband->vht_cap.cap |=\n\t\t\tIEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB;\n\t}\n}\n\nstatic int brcmf_setup_wiphybands(struct wiphy *wiphy)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tu32 nmode = 0;\n\tu32 vhtmode = 0;\n\tu32 bw_cap[2] = { WLC_BW_20MHZ_BIT, WLC_BW_20MHZ_BIT };\n\tu32 rxchain;\n\tu32 nchain;\n\tint err;\n\ts32 i;\n\tstruct ieee80211_supported_band *band;\n\tu32 txstreams = 0;\n\tu32 txbf_bfe_cap = 0;\n\tu32 txbf_bfr_cap = 0;\n\n\t(void)brcmf_fil_iovar_int_get(ifp, \"vhtmode\", &vhtmode);\n\terr = brcmf_fil_iovar_int_get(ifp, \"nmode\", &nmode);\n\tif (err) {\n\t\tbrcmf_err(\"nmode error (%d)\\n\", err);\n\t} else {\n\t\tbrcmf_get_bwcap(ifp, bw_cap);\n\t}\n\tbrcmf_dbg(INFO, \"nmode=%d, vhtmode=%d, bw_cap=(%d, %d)\\n\",\n\t\t  nmode, vhtmode, bw_cap[NL80211_BAND_2GHZ],\n\t\t  bw_cap[NL80211_BAND_5GHZ]);\n\n\terr = brcmf_fil_iovar_int_get(ifp, \"rxchain\", &rxchain);\n\tif (err) {\n\t\tbrcmf_err(\"rxchain error (%d)\\n\", err);\n\t\tnchain = 1;\n\t} else {\n\t\tfor (nchain = 0; rxchain; nchain++)\n\t\t\trxchain = rxchain & (rxchain - 1);\n\t}\n\tbrcmf_dbg(INFO, \"nchain=%d\\n\", nchain);\n\n\terr = brcmf_construct_chaninfo(cfg, bw_cap);\n\tif (err) {\n\t\tbrcmf_err(\"brcmf_construct_chaninfo failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (vhtmode) {\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txstreams\", &txstreams);\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txbf_bfe_cap\",\n\t\t\t\t\t      &txbf_bfe_cap);\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txbf_bfr_cap\",\n\t\t\t\t\t      &txbf_bfr_cap);\n\t}\n\n\twiphy = cfg_to_wiphy(cfg);\n\tfor (i = 0; i < ARRAY_SIZE(wiphy->bands); i++) {\n\t\tband = wiphy->bands[i];\n\t\tif (band == NULL)\n\t\t\tcontinue;\n\n\t\tif (nmode)\n\t\t\tbrcmf_update_ht_cap(band, bw_cap, nchain);\n\t\tif (vhtmode)\n\t\t\tbrcmf_update_vht_cap(band, bw_cap, nchain, txstreams,\n\t\t\t\t\t     txbf_bfe_cap, txbf_bfr_cap);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_txrx_stypes\nbrcmf_txrx_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_DEVICE] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t}\n};\n\n/**\n * brcmf_setup_ifmodes() - determine interface modes and combinations.\n *\n * @wiphy: wiphy object.\n * @ifp: interface object needed for feat module api.\n *\n * The interface modes and combinations are determined dynamically here\n * based on firmware functionality.\n *\n * no p2p and no mbss:\n *\n *\t#STA <= 1, #AP <= 1, channels = 1, 2 total\n *\n * no p2p and mbss:\n *\n *\t#STA <= 1, #AP <= 1, channels = 1, 2 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n *\n * p2p, no mchan, and mbss:\n *\n *\t#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 1, 3 total\n *\t#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n *\n * p2p, mchan, and mbss:\n *\n *\t#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 2, 3 total\n *\t#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n */\nstatic int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct ieee80211_iface_combination *combo = NULL;\n\tstruct ieee80211_iface_limit *c0_limits = NULL;\n\tstruct ieee80211_iface_limit *p2p_limits = NULL;\n\tstruct ieee80211_iface_limit *mbss_limits = NULL;\n\tbool mbss, p2p;\n\tint i, c, n_combos;\n\n\tmbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);\n\tp2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);\n\n\tn_combos = 1 + !!p2p + !!mbss;\n\tcombo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);\n\tif (!combo)\n\t\tgoto err;\n\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP);\n\n\tc = 0;\n\ti = 0;\n\tc0_limits = kcalloc(p2p ? 3 : 2, sizeof(*c0_limits), GFP_KERNEL);\n\tif (!c0_limits)\n\t\tgoto err;\n\tc0_limits[i].max = 1;\n\tc0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);\n\tif (p2p) {\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN))\n\t\t\tcombo[c].num_different_channels = 2;\n\t\twiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t       BIT(NL80211_IFTYPE_P2P_GO);\n\t} else {\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t}\n\tcombo[c].num_different_channels = 1;\n\tcombo[c].max_interfaces = i;\n\tcombo[c].n_limits = i;\n\tcombo[c].limits = c0_limits;\n\n\tif (p2p) {\n\t\tc++;\n\t\ti = 0;\n\t\tp2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);\n\t\tif (!p2p_limits)\n\t\t\tgoto err;\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_STATION);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tcombo[c].num_different_channels = 1;\n\t\tcombo[c].max_interfaces = i;\n\t\tcombo[c].n_limits = i;\n\t\tcombo[c].limits = p2p_limits;\n\t}\n\n\tif (mbss) {\n\t\tc++;\n\t\ti = 0;\n\t\tmbss_limits = kcalloc(1, sizeof(*mbss_limits), GFP_KERNEL);\n\t\tif (!mbss_limits)\n\t\t\tgoto err;\n\t\tmbss_limits[i].max = 4;\n\t\tmbss_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tcombo[c].beacon_int_infra_match = true;\n\t\tcombo[c].num_different_channels = 1;\n\t\tcombo[c].max_interfaces = 4;\n\t\tcombo[c].n_limits = i;\n\t\tcombo[c].limits = mbss_limits;\n\t}\n\n\twiphy->n_iface_combinations = n_combos;\n\twiphy->iface_combinations = combo;\n\treturn 0;\n\nerr:\n\tkfree(c0_limits);\n\tkfree(p2p_limits);\n\tkfree(mbss_limits);\n\tkfree(combo);\n\treturn -ENOMEM;\n}\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support brcmf_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT,\n\t.n_patterns = BRCMF_WOWL_MAXPATTERNS,\n\t.pattern_max_len = BRCMF_WOWL_MAXPATTERNSIZE,\n\t.pattern_min_len = 1,\n\t.max_pkt_offset = 1500,\n};\n#endif\n\nstatic void brcmf_wiphy_wowl_params(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n#ifdef CONFIG_PM\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct wiphy_wowlan_support *wowl;\n\n\twowl = kmemdup(&brcmf_wowlan_support, sizeof(brcmf_wowlan_support),\n\t\t       GFP_KERNEL);\n\tif (!wowl) {\n\t\tbrcmf_err(\"only support basic wowlan features\\n\");\n\t\twiphy->wowlan = &brcmf_wowlan_support;\n\t\treturn;\n\t}\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO)) {\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ND)) {\n\t\t\twowl->flags |= WIPHY_WOWLAN_NET_DETECT;\n\t\t\twowl->max_nd_match_sets = BRCMF_PNO_MAX_PFN_COUNT;\n\t\t\tinit_waitqueue_head(&cfg->wowl.nd_data_wait);\n\t\t}\n\t}\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK)) {\n\t\twowl->flags |= WIPHY_WOWLAN_SUPPORTS_GTK_REKEY;\n\t\twowl->flags |= WIPHY_WOWLAN_GTK_REKEY_FAILURE;\n\t}\n\n\twiphy->wowlan = wowl;\n#endif\n}\n\nstatic int brcmf_setup_wiphy(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tconst struct ieee80211_iface_combination *combo;\n\tstruct ieee80211_supported_band *band;\n\tu16 max_interfaces = 0;\n\tbool gscan;\n\t__le32 bandlist[3];\n\tu32 n_bands;\n\tint err, i;\n\n\twiphy->max_scan_ssids = WL_NUM_SCAN_MAX;\n\twiphy->max_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\n\twiphy->max_num_pmkids = BRCMF_MAXPMKID;\n\n\terr = brcmf_setup_ifmodes(wiphy, ifp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0, combo = wiphy->iface_combinations;\n\t     i < wiphy->n_iface_combinations; i++, combo++) {\n\t\tmax_interfaces = max(max_interfaces, combo->max_interfaces);\n\t}\n\n\tfor (i = 0; i < max_interfaces && i < ARRAY_SIZE(drvr->addresses);\n\t     i++) {\n\t\tu8 *addr = drvr->addresses[i].addr;\n\n\t\tmemcpy(addr, drvr->mac, ETH_ALEN);\n\t\tif (i) {\n\t\t\taddr[0] |= BIT(1);\n\t\t\taddr[ETH_ALEN - 1] ^= i;\n\t\t}\n\t}\n\twiphy->addresses = drvr->addresses;\n\twiphy->n_addresses = i;\n\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->cipher_suites = brcmf_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(brcmf_cipher_suites);\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\twiphy->n_cipher_suites--;\n\twiphy->bss_select_support = BIT(NL80211_BSS_SELECT_ATTR_RSSI) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_BAND_PREF) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_RSSI_ADJUST);\n\n\twiphy->flags |= WIPHY_FLAG_NETNS_OK |\n\t\t\tWIPHY_FLAG_PS_ON_BY_DEFAULT |\n\t\t\tWIPHY_FLAG_OFFCHAN_TX |\n\t\t\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TDLS))\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\tif (!ifp->drvr->settings->roamoff)\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_FWSUP)) {\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK);\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X);\n\t}\n\twiphy->mgmt_stypes = brcmf_txrx_stypes;\n\twiphy->max_remain_on_channel_duration = 5000;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO)) {\n\t\tgscan = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_GSCAN);\n\t\tbrcmf_pno_wiphy_params(wiphy, gscan);\n\t}\n\t/* vendor commands/events support */\n\twiphy->vendor_commands = brcmf_vendor_cmds;\n\twiphy->n_vendor_commands = BRCMF_VNDR_CMDS_LAST - 1;\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL))\n\t\tbrcmf_wiphy_wowl_params(wiphy, ifp);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BANDLIST, &bandlist,\n\t\t\t\t     sizeof(bandlist));\n\tif (err) {\n\t\tbrcmf_err(\"could not obtain band info: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\t/* first entry in bandlist is number of bands */\n\tn_bands = le32_to_cpu(bandlist[0]);\n\tfor (i = 1; i <= n_bands && i < ARRAY_SIZE(bandlist); i++) {\n\t\tif (bandlist[i] == cpu_to_le32(WLC_BAND_2G)) {\n\t\t\tband = kmemdup(&__wl_band_2ghz, sizeof(__wl_band_2ghz),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!band)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tband->channels = kmemdup(&__wl_2ghz_channels,\n\t\t\t\t\t\t sizeof(__wl_2ghz_channels),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!band->channels) {\n\t\t\t\tkfree(band);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tband->n_channels = ARRAY_SIZE(__wl_2ghz_channels);\n\t\t\twiphy->bands[NL80211_BAND_2GHZ] = band;\n\t\t}\n\t\tif (bandlist[i] == cpu_to_le32(WLC_BAND_5G)) {\n\t\t\tband = kmemdup(&__wl_band_5ghz, sizeof(__wl_band_5ghz),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!band)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tband->channels = kmemdup(&__wl_5ghz_channels,\n\t\t\t\t\t\t sizeof(__wl_5ghz_channels),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!band->channels) {\n\t\t\t\tkfree(band);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tband->n_channels = ARRAY_SIZE(__wl_5ghz_channels);\n\t\t\twiphy->bands[NL80211_BAND_5GHZ] = band;\n\t\t}\n\t}\n\n\twiphy_read_of_freq_limits(wiphy);\n\n\treturn 0;\n}\n\nstatic s32 brcmf_config_dongle(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct net_device *ndev;\n\tstruct wireless_dev *wdev;\n\tstruct brcmf_if *ifp;\n\ts32 power_mode;\n\ts32 err = 0;\n\n\tif (cfg->dongle_up)\n\t\treturn err;\n\n\tndev = cfg_to_ndev(cfg);\n\twdev = ndev->ieee80211_ptr;\n\tifp = netdev_priv(ndev);\n\n\t/* make sure RF is ready for work */\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 0);\n\n\tbrcmf_dongle_scantime(ifp);\n\n\tpower_mode = cfg->pwr_save ? PM_FAST : PM_OFF;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, power_mode);\n\tif (err)\n\t\tgoto default_conf_out;\n\tbrcmf_dbg(INFO, \"power save set to %s\\n\",\n\t\t  (power_mode ? \"enabled\" : \"disabled\"));\n\n\terr = brcmf_dongle_roam(ifp);\n\tif (err)\n\t\tgoto default_conf_out;\n\terr = brcmf_cfg80211_change_iface(wdev->wiphy, ndev, wdev->iftype,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\tgoto default_conf_out;\n\n\tbrcmf_configure_arp_nd_offload(ifp, true);\n\n\tcfg->dongle_up = true;\ndefault_conf_out:\n\n\treturn err;\n\n}\n\nstatic s32 __brcmf_cfg80211_up(struct brcmf_if *ifp)\n{\n\tset_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\n\n\treturn brcmf_config_dongle(ifp->drvr->config);\n}\n\nstatic s32 __brcmf_cfg80211_down(struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\n\t/*\n\t * While going down, if associated with AP disassociate\n\t * from AP to save power\n\t */\n\tif (check_vif_up(ifp->vif)) {\n\t\tbrcmf_link_down(ifp->vif, WLAN_REASON_UNSPECIFIED);\n\n\t\t/* Make sure WPA_Supplicant receives all the event\n\t\t   generated due to DISASSOC call to the fw to keep\n\t\t   the state fw and WPA_Supplicant state consistent\n\t\t */\n\t\tbrcmf_delay(500);\n\t}\n\n\tbrcmf_abort_scanning(cfg);\n\tclear_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\n\n\treturn 0;\n}\n\ns32 brcmf_cfg80211_up(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err = 0;\n\n\tmutex_lock(&cfg->usr_sync);\n\terr = __brcmf_cfg80211_up(ifp);\n\tmutex_unlock(&cfg->usr_sync);\n\n\treturn err;\n}\n\ns32 brcmf_cfg80211_down(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err = 0;\n\n\tmutex_lock(&cfg->usr_sync);\n\terr = __brcmf_cfg80211_down(ifp);\n\tmutex_unlock(&cfg->usr_sync);\n\n\treturn err;\n}\n\nenum nl80211_iftype brcmf_cfg80211_get_iftype(struct brcmf_if *ifp)\n{\n\tstruct wireless_dev *wdev = &ifp->vif->wdev;\n\n\treturn wdev->iftype;\n}\n\nbool brcmf_get_vif_state_any(struct brcmf_cfg80211_info *cfg,\n\t\t\t     unsigned long state)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tlist_for_each_entry(vif, &cfg->vif_list, list) {\n\t\tif (test_bit(state, &vif->sme_state))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool vif_event_equals(struct brcmf_cfg80211_vif_event *event,\n\t\t\t\t    u8 action)\n{\n\tu8 evt_action;\n\n\tspin_lock(&event->vif_event_lock);\n\tevt_action = event->action;\n\tspin_unlock(&event->vif_event_lock);\n\treturn evt_action == action;\n}\n\nvoid brcmf_cfg80211_arm_vif_event(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  struct brcmf_cfg80211_vif *vif)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\n\tspin_lock(&event->vif_event_lock);\n\tevent->vif = vif;\n\tevent->action = 0;\n\tspin_unlock(&event->vif_event_lock);\n}\n\nbool brcmf_cfg80211_vif_event_armed(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\tbool armed;\n\n\tspin_lock(&event->vif_event_lock);\n\tarmed = event->vif != NULL;\n\tspin_unlock(&event->vif_event_lock);\n\n\treturn armed;\n}\n\nint brcmf_cfg80211_wait_vif_event(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  u8 action, ulong timeout)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\n\treturn wait_event_timeout(event->vif_wq,\n\t\t\t\t  vif_event_equals(event, action), timeout);\n}\n\nstatic s32 brcmf_translate_country_code(struct brcmf_pub *drvr, char alpha2[2],\n\t\t\t\t\tstruct brcmf_fil_country_le *ccreq)\n{\n\tstruct brcmfmac_pd_cc *country_codes;\n\tstruct brcmfmac_pd_cc_entry *cc;\n\ts32 found_index;\n\tint i;\n\n\tcountry_codes = drvr->settings->country_codes;\n\tif (!country_codes) {\n\t\tbrcmf_dbg(TRACE, \"No country codes configured for device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((alpha2[0] == ccreq->country_abbrev[0]) &&\n\t    (alpha2[1] == ccreq->country_abbrev[1])) {\n\t\tbrcmf_dbg(TRACE, \"Country code already set\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tfound_index = -1;\n\tfor (i = 0; i < country_codes->table_size; i++) {\n\t\tcc = &country_codes->table[i];\n\t\tif ((cc->iso3166[0] == '\\0') && (found_index == -1))\n\t\t\tfound_index = i;\n\t\tif ((cc->iso3166[0] == alpha2[0]) &&\n\t\t    (cc->iso3166[1] == alpha2[1])) {\n\t\t\tfound_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_index == -1) {\n\t\tbrcmf_dbg(TRACE, \"No country code match found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(ccreq, 0, sizeof(*ccreq));\n\tccreq->rev = cpu_to_le32(country_codes->table[found_index].rev);\n\tmemcpy(ccreq->ccode, country_codes->table[found_index].cc,\n\t       BRCMF_COUNTRY_BUF_SZ);\n\tccreq->country_abbrev[0] = alpha2[0];\n\tccreq->country_abbrev[1] = alpha2[1];\n\tccreq->country_abbrev[2] = 0;\n\n\treturn 0;\n}\n\nstatic void brcmf_cfg80211_reg_notifier(struct wiphy *wiphy,\n\t\t\t\t\tstruct regulatory_request *req)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct brcmf_fil_country_le ccreq;\n\ts32 err;\n\tint i;\n\n\t/* The country code gets set to \"00\" by default at boot, ignore */\n\tif (req->alpha2[0] == '0' && req->alpha2[1] == '0')\n\t\treturn;\n\n\t/* ignore non-ISO3166 country codes */\n\tfor (i = 0; i < sizeof(req->alpha2); i++)\n\t\tif (req->alpha2[i] < 'A' || req->alpha2[i] > 'Z') {\n\t\t\tbrcmf_err(\"not an ISO3166 code (0x%02x 0x%02x)\\n\",\n\t\t\t\t  req->alpha2[0], req->alpha2[1]);\n\t\t\treturn;\n\t\t}\n\n\tbrcmf_dbg(TRACE, \"Enter: initiator=%d, alpha=%c%c\\n\", req->initiator,\n\t\t  req->alpha2[0], req->alpha2[1]);\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"country\", &ccreq, sizeof(ccreq));\n\tif (err) {\n\t\tbrcmf_err(\"Country code iovar returned err = %d\\n\", err);\n\t\treturn;\n\t}\n\n\terr = brcmf_translate_country_code(ifp->drvr, req->alpha2, &ccreq);\n\tif (err)\n\t\treturn;\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"country\", &ccreq, sizeof(ccreq));\n\tif (err) {\n\t\tbrcmf_err(\"Firmware rejected country setting\\n\");\n\t\treturn;\n\t}\n\tbrcmf_setup_wiphybands(wiphy);\n}\n\nstatic void brcmf_free_wiphy(struct wiphy *wiphy)\n{\n\tint i;\n\n\tif (!wiphy)\n\t\treturn;\n\n\tif (wiphy->iface_combinations) {\n\t\tfor (i = 0; i < wiphy->n_iface_combinations; i++)\n\t\t\tkfree(wiphy->iface_combinations[i].limits);\n\t}\n\tkfree(wiphy->iface_combinations);\n\tif (wiphy->bands[NL80211_BAND_2GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]);\n\t}\n\tif (wiphy->bands[NL80211_BAND_5GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]);\n\t}\n#if IS_ENABLED(CONFIG_PM)\n\tif (wiphy->wowlan != &brcmf_wowlan_support)\n\t\tkfree(wiphy->wowlan);\n#endif\n\twiphy_free(wiphy);\n}\n\nstruct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,\n\t\t\t\t\t\t  struct device *busdev,\n\t\t\t\t\t\t  bool p2pdev_forced)\n{\n\tstruct net_device *ndev = brcmf_get_ifp(drvr, 0)->ndev;\n\tstruct brcmf_cfg80211_info *cfg;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_ops *ops;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\ts32 err = 0;\n\ts32 io_type;\n\tu16 *cap = NULL;\n\n\tif (!ndev) {\n\t\tbrcmf_err(\"ndev is invalid\\n\");\n\t\treturn NULL;\n\t}\n\n\tops = kmemdup(&brcmf_cfg80211_ops, sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn NULL;\n\n\tifp = netdev_priv(ndev);\n#ifdef CONFIG_PM\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK))\n\t\tops->set_rekey_data = brcmf_cfg80211_set_rekey_data;\n#endif\n\twiphy = wiphy_new(ops, sizeof(struct brcmf_cfg80211_info));\n\tif (!wiphy) {\n\t\tbrcmf_err(\"Could not allocate wiphy device\\n\");\n\t\tgoto ops_out;\n\t}\n\tmemcpy(wiphy->perm_addr, drvr->mac, ETH_ALEN);\n\tset_wiphy_dev(wiphy, busdev);\n\n\tcfg = wiphy_priv(wiphy);\n\tcfg->wiphy = wiphy;\n\tcfg->ops = ops;\n\tcfg->pub = drvr;\n\tinit_vif_event(&cfg->vif_event);\n\tINIT_LIST_HEAD(&cfg->vif_list);\n\n\tvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_STATION);\n\tif (IS_ERR(vif))\n\t\tgoto wiphy_out;\n\n\tvif->ifp = ifp;\n\tvif->wdev.netdev = ndev;\n\tndev->ieee80211_ptr = &vif->wdev;\n\tSET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));\n\n\terr = wl_init_priv(cfg);\n\tif (err) {\n\t\tbrcmf_err(\"Failed to init iwm_priv (%d)\\n\", err);\n\t\tbrcmf_free_vif(vif);\n\t\tgoto wiphy_out;\n\t}\n\tifp->vif = vif;\n\n\t/* determine d11 io type before wiphy setup */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_VERSION, &io_type);\n\tif (err) {\n\t\tbrcmf_err(\"Failed to get D11 version (%d)\\n\", err);\n\t\tgoto priv_out;\n\t}\n\tcfg->d11inf.io_type = (u8)io_type;\n\tbrcmu_d11_attach(&cfg->d11inf);\n\n\terr = brcmf_setup_wiphy(wiphy, ifp);\n\tif (err < 0)\n\t\tgoto priv_out;\n\n\tbrcmf_dbg(INFO, \"Registering custom regulatory\\n\");\n\twiphy->reg_notifier = brcmf_cfg80211_reg_notifier;\n\twiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;\n\twiphy_apply_custom_regulatory(wiphy, &brcmf_regdom);\n\n\t/* firmware defaults to 40MHz disabled in 2G band. We signal\n\t * cfg80211 here that we do and have it decide we can enable\n\t * it. But first check if device does support 2G operation.\n\t */\n\tif (wiphy->bands[NL80211_BAND_2GHZ]) {\n\t\tcap = &wiphy->bands[NL80211_BAND_2GHZ]->ht_cap.cap;\n\t\t*cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\terr = wiphy_register(wiphy);\n\tif (err < 0) {\n\t\tbrcmf_err(\"Could not register wiphy device (%d)\\n\", err);\n\t\tgoto priv_out;\n\t}\n\n\terr = brcmf_setup_wiphybands(wiphy);\n\tif (err) {\n\t\tbrcmf_err(\"Setting wiphy bands failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\t/* If cfg80211 didn't disable 40MHz HT CAP in wiphy_register(),\n\t * setup 40MHz in 2GHz band and enable OBSS scanning.\n\t */\n\tif (cap && (*cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)) {\n\t\terr = brcmf_enable_bw40_2g(cfg);\n\t\tif (!err)\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"obss_coex\",\n\t\t\t\t\t\t      BRCMF_OBSS_COEX_AUTO);\n\t\telse\n\t\t\t*cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\t/* p2p might require that \"if-events\" get processed by fweh. So\n\t * activate the already registered event handlers now and activate\n\t * the rest when initialization has completed. drvr->config needs to\n\t * be assigned before activating events.\n\t */\n\tdrvr->config = cfg;\n\terr = brcmf_fweh_activate_events(ifp);\n\tif (err) {\n\t\tbrcmf_err(\"FWEH activation failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\terr = brcmf_p2p_attach(cfg, p2pdev_forced);\n\tif (err) {\n\t\tbrcmf_err(\"P2P initialisation failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\terr = brcmf_btcoex_attach(cfg);\n\tif (err) {\n\t\tbrcmf_err(\"BT-coex initialisation failed (%d)\\n\", err);\n\t\tbrcmf_p2p_detach(&cfg->p2p);\n\t\tgoto wiphy_unreg_out;\n\t}\n\terr = brcmf_pno_attach(cfg);\n\tif (err) {\n\t\tbrcmf_err(\"PNO initialisation failed (%d)\\n\", err);\n\t\tbrcmf_btcoex_detach(cfg);\n\t\tbrcmf_p2p_detach(&cfg->p2p);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TDLS)) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"tdls_enable\", 1);\n\t\tif (err) {\n\t\t\tbrcmf_dbg(INFO, \"TDLS not enabled (%d)\\n\", err);\n\t\t\twiphy->flags &= ~WIPHY_FLAG_SUPPORTS_TDLS;\n\t\t} else {\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_TDLS_PEER_EVENT,\n\t\t\t\t\t    brcmf_notify_tdls_peer_event);\n\t\t}\n\t}\n\n\t/* (re-) activate FWEH event handling */\n\terr = brcmf_fweh_activate_events(ifp);\n\tif (err) {\n\t\tbrcmf_err(\"FWEH activation failed (%d)\\n\", err);\n\t\tgoto detach;\n\t}\n\n\t/* Fill in some of the advertised nl80211 supported features */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_SCAN_RANDOM_MAC)) {\n\t\twiphy->features |= NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR;\n#ifdef CONFIG_PM\n\t\tif (wiphy->wowlan &&\n\t\t    wiphy->wowlan->flags & WIPHY_WOWLAN_NET_DETECT)\n\t\t\twiphy->features |= NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n#endif\n\t}\n\n\treturn cfg;\n\ndetach:\n\tbrcmf_pno_detach(cfg);\n\tbrcmf_btcoex_detach(cfg);\n\tbrcmf_p2p_detach(&cfg->p2p);\nwiphy_unreg_out:\n\twiphy_unregister(cfg->wiphy);\npriv_out:\n\twl_deinit_priv(cfg);\n\tbrcmf_free_vif(vif);\n\tifp->vif = NULL;\nwiphy_out:\n\tbrcmf_free_wiphy(wiphy);\nops_out:\n\tkfree(ops);\n\treturn NULL;\n}\n\nvoid brcmf_cfg80211_detach(struct brcmf_cfg80211_info *cfg)\n{\n\tif (!cfg)\n\t\treturn;\n\n\tbrcmf_pno_detach(cfg);\n\tbrcmf_btcoex_detach(cfg);\n\twiphy_unregister(cfg->wiphy);\n\tkfree(cfg->ops);\n\twl_deinit_priv(cfg);\n\tbrcmf_free_wiphy(cfg->wiphy);\n}\n"], "filenames": ["drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c"], "buggy_code_start_loc": [4936], "buggy_code_end_loc": [4936], "fixing_code_start_loc": [4937], "fixing_code_end_loc": [4942], "type": "CWE-119", "message": "The brcmf_cfg80211_mgmt_tx function in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux kernel before 4.12.3 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted NL80211_CMD_FRAME Netlink packet.", "other": {"cve": {"id": "CVE-2017-7541", "sourceIdentifier": "secalert@redhat.com", "published": "2017-07-25T04:29:00.177", "lastModified": "2023-02-14T21:37:40.083", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The brcmf_cfg80211_mgmt_tx function in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux kernel before 4.12.3 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted NL80211_CMD_FRAME Netlink packet."}, {"lang": "es", "value": "La funci\u00f3n brcmf_cfg80211_mgmt_tx en el archivo drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c en el kernel de Linux anterior a la versi\u00f3n 4.12.3, permite a los usuarios locales causar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer y bloqueo del sistema) o posiblemente alcanzar privilegios por medio de un paquete de Netlink  NL80211_CMD_FRAME creado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.9", "versionEndExcluding": "3.10.108", "matchCriteriaId": "EA344106-6A14-4E25-BCAF-456232B0EC3F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.16.48", "matchCriteriaId": "60F94CD7-8A37-47E5-8E46-8CE5E862C739"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.62", "matchCriteriaId": "61D7C16A-92B3-4598-A2A0-4C4795AF0491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.43", "matchCriteriaId": "5F6B255F-0933-4983-B3F6-AD5B128A8F04"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.78", "matchCriteriaId": "53D588E8-41E9-45DB-A106-D0D6FAFBEAEA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.39", "matchCriteriaId": "894EA787-0B3C-4729-9CE9-4CA86309E37A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.11.12", "matchCriteriaId": "6070460C-3FAE-457B-9A3E-5ADF3AA3CC1D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.12", "versionEndExcluding": "4.12.3", "matchCriteriaId": "0D1EC748-85AE-40F3-A67C-3F634135A2F6"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8f44c9a41386729fea410e688959ddaa9d51be7c", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://openwall.com/lists/oss-security/2017/07/24/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3927", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3945", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.12.3", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/99955", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038981", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2863", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2918", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2930", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2931", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=1049645", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1473198", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/8f44c9a41386729fea410e688959ddaa9d51be7c", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-11-01", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.spinics.net/lists/stable/msg180994.html", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8f44c9a41386729fea410e688959ddaa9d51be7c"}}