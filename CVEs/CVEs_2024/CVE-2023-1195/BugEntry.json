{"buggy_code": ["// SPDX-License-Identifier: LGPL-2.1\n/*\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2011\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <linux/uuid.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <linux/module.h>\n#include <keys/user-type.h>\n#include <net/ipv6.h>\n#include <linux/parser.h>\n#include <linux/bvec.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fscache.h\"\n#include \"smb2proto.h\"\n#include \"smbdirect.h\"\n#include \"dns_resolve.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n#include \"fs_context.h\"\n#include \"cifs_swn.h\"\n\nextern mempool_t *cifs_req_poolp;\nextern bool disable_legacy_dialects;\n\n/* FIXME: should these be tunable? */\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\n/* Drop the connection to not overload the server */\n#define NUM_STATUS_IO_TIMEOUT   5\n\nstruct mount_ctx {\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct smb3_fs_context *fs_ctx;\n\tunsigned int xid;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct cifs_ses *root_ses;\n\tuuid_t mount_id;\n\tchar *origin_fullpath, *leaf_fullpath;\n#endif\n};\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\n/*\n * Resolve hostname and set ip addr in tcp ses. Useful for hostnames that may\n * get their ip addresses changed at some point.\n *\n * This should be called with server->srv_mutex held.\n */\nstatic int reconn_set_ipaddr_from_hostname(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tint len;\n\tchar *unc, *ipaddr = NULL;\n\ttime64_t expiry, now;\n\tunsigned long ttl = SMB_DNS_RESOLVE_INTERVAL_DEFAULT;\n\n\tif (!server->hostname)\n\t\treturn -EINVAL;\n\n\t/* if server hostname isn't populated, there's nothing to do here */\n\tif (server->hostname[0] == '\\0')\n\t\treturn 0;\n\n\tlen = strlen(server->hostname) + 3;\n\n\tunc = kmalloc(len, GFP_KERNEL);\n\tif (!unc) {\n\t\tcifs_dbg(FYI, \"%s: failed to create UNC path\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tscnprintf(unc, len, \"\\\\\\\\%s\", server->hostname);\n\n\trc = dns_resolve_server_name_to_ip(unc, &ipaddr, &expiry);\n\tkfree(unc);\n\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, server->hostname, rc);\n\t\tgoto requeue_resolve;\n\t}\n\n\tspin_lock(&server->srv_lock);\n\trc = cifs_convert_address((struct sockaddr *)&server->dstaddr, ipaddr,\n\t\t\t\t  strlen(ipaddr));\n\tspin_unlock(&server->srv_lock);\n\tkfree(ipaddr);\n\n\t/* rc == 1 means success here */\n\tif (rc) {\n\t\tnow = ktime_get_real_seconds();\n\t\tif (expiry && expiry > now)\n\t\t\t/*\n\t\t\t * To make sure we don't use the cached entry, retry 1s\n\t\t\t * after expiry.\n\t\t\t */\n\t\t\tttl = max_t(unsigned long, expiry - now, SMB_DNS_RESOLVE_INTERVAL_MIN) + 1;\n\t}\n\trc = !rc ? -1 : 0;\n\nrequeue_resolve:\n\tcifs_dbg(FYI, \"%s: next dns resolution scheduled for %lu seconds in the future\\n\",\n\t\t __func__, ttl);\n\tmod_delayed_work(cifsiod_wq, &server->resolve, (ttl * HZ));\n\n\treturn rc;\n}\n\nstatic void smb2_query_server_interfaces(struct work_struct *work)\n{\n\tint rc;\n\tstruct cifs_tcon *tcon = container_of(work,\n\t\t\t\t\tstruct cifs_tcon,\n\t\t\t\t\tquery_interfaces.work);\n\n\t/*\n\t * query server network interfaces, in case they change\n\t */\n\trc = SMB3_request_interfaces(0, tcon, false);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: failed to query server interfaces: %d\\n\",\n\t\t\t\t__func__, rc);\n\t}\n\n\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n}\n\nstatic void cifs_resolve_server(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, resolve.work);\n\n\tcifs_server_lock(server);\n\n\t/*\n\t * Resolve the hostname again to make sure that IP address is up-to-date.\n\t */\n\trc = reconn_set_ipaddr_from_hostname(server);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: failed to resolve hostname: %d\\n\",\n\t\t\t\t__func__, rc);\n\t}\n\n\tcifs_server_unlock(server);\n}\n\n/*\n * Update the tcpStatus for the server.\n * This is used to signal the cifsd thread to call cifs_reconnect\n * ONLY cifsd thread should call cifs_reconnect. For any other\n * thread, use this function\n *\n * @server: the tcp ses for which reconnect is needed\n * @all_channels: if this needs to be done for all channels\n */\nvoid\ncifs_signal_cifsd_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\tbool all_channels)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tint i;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\tspin_lock(&pserver->srv_lock);\n\tif (!all_channels) {\n\t\tpserver->tcpStatus = CifsNeedReconnect;\n\t\tspin_unlock(&pserver->srv_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&pserver->srv_lock);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tspin_lock(&ses->chan_lock);\n\t\tfor (i = 0; i < ses->chan_count; i++) {\n\t\t\tspin_lock(&ses->chans[i].server->srv_lock);\n\t\t\tses->chans[i].server->tcpStatus = CifsNeedReconnect;\n\t\t\tspin_unlock(&ses->chans[i].server->srv_lock);\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n}\n\n/*\n * Mark all sessions and tcons for reconnect.\n * IMPORTANT: make sure that this gets called only from\n * cifsd thread. For any other thread, use\n * cifs_signal_cifsd_for_reconnect\n *\n * @server: the tcp ses for which reconnect is needed\n * @server needs to be previously set to CifsNeedReconnect.\n * @mark_smb_session: whether even sessions need to be marked\n */\nvoid\ncifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\t      bool mark_smb_session)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses, *nses;\n\tstruct cifs_tcon *tcon;\n\n\t/*\n\t * before reconnecting the tcp session, mark the smb session (uid) and the tid bad so they\n\t * are not used until reconnected.\n\t */\n\tcifs_dbg(FYI, \"%s: marking necessary sessions and tcons for reconnect\\n\", __func__);\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry_safe(ses, nses, &pserver->smb_ses_list, smb_ses_list) {\n\t\t/* check if iface is still active */\n\t\tif (!cifs_chan_is_iface_active(ses, server))\n\t\t\tcifs_chan_update_iface(ses, server);\n\n\t\tspin_lock(&ses->chan_lock);\n\t\tif (!mark_smb_session && cifs_chan_needs_reconnect(ses, server))\n\t\t\tgoto next_session;\n\n\t\tif (mark_smb_session)\n\t\t\tCIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);\n\t\telse\n\t\t\tcifs_chan_set_need_reconnect(ses, server);\n\n\t\t/* If all channels need reconnect, then tcon needs reconnect */\n\t\tif (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses))\n\t\t\tgoto next_session;\n\n\t\tses->ses_status = SES_NEED_RECON;\n\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\ttcon->need_reconnect = true;\n\t\t\ttcon->status = TID_NEED_RECON;\n\t\t}\n\t\tif (ses->tcon_ipc)\n\t\t\tses->tcon_ipc->need_reconnect = true;\n\nnext_session:\n\t\tspin_unlock(&ses->chan_lock);\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n}\n\nstatic void\ncifs_abort_connection(struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *mid, *nmid;\n\tstruct list_head retry_list;\n\n\tserver->maxBuf = 0;\n\tserver->max_read = 0;\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tcifs_server_lock(server);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\", server->ssocket->state,\n\t\t\t server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\", server->ssocket->state,\n\t\t\t server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&server->mid_lock);\n\tlist_for_each_entry_safe(mid, nmid, &server->pending_mid_q, qhead) {\n\t\tkref_get(&mid->refcount);\n\t\tif (mid->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid->qhead, &retry_list);\n\t\tmid->mid_flags |= MID_DELETED;\n\t}\n\tspin_unlock(&server->mid_lock);\n\tcifs_server_unlock(server);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_entry_safe(mid, nmid, &retry_list, qhead) {\n\t\tlist_del_init(&mid->qhead);\n\t\tmid->callback(mid);\n\t\trelease_mid(mid);\n\t}\n\n\tif (cifs_rdma_enabled(server)) {\n\t\tcifs_server_lock(server);\n\t\tsmbd_destroy(server);\n\t\tcifs_server_unlock(server);\n\t}\n}\n\nstatic bool cifs_tcp_ses_needs_reconnect(struct TCP_Server_Info *server, int num_targets)\n{\n\tspin_lock(&server->srv_lock);\n\tserver->nr_targets = num_targets;\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally next time through the loop */\n\t\tspin_unlock(&server->srv_lock);\n\t\twake_up(&server->response_q);\n\t\treturn false;\n\t}\n\n\tcifs_dbg(FYI, \"Mark tcp session as need reconnect\\n\");\n\ttrace_smb3_reconnect(server->CurrentMid, server->conn_id,\n\t\t\t     server->hostname);\n\tserver->tcpStatus = CifsNeedReconnect;\n\n\tspin_unlock(&server->srv_lock);\n\treturn true;\n}\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n *\n * if mark_smb_session is passed as true, unconditionally mark\n * the smb session (and tcon) for reconnect as well. This value\n * doesn't really matter for non-multichannel scenario.\n *\n */\nstatic int __cifs_reconnect(struct TCP_Server_Info *server,\n\t\t\t    bool mark_smb_session)\n{\n\tint rc = 0;\n\n\tif (!cifs_tcp_ses_needs_reconnect(server, 1))\n\t\treturn 0;\n\n\tcifs_mark_tcp_ses_conns_for_reconnect(server, mark_smb_session);\n\n\tcifs_abort_connection(server);\n\n\tdo {\n\t\ttry_to_freeze();\n\t\tcifs_server_lock(server);\n\n\t\tif (!cifs_swn_set_server_dstaddr(server)) {\n\t\t\t/* resolve the hostname again to make sure that IP address is up-to-date */\n\t\t\trc = reconn_set_ipaddr_from_hostname(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconn_set_ipaddr_from_hostname: rc=%d\\n\", __func__, rc);\n\t\t}\n\n\t\tif (cifs_rdma_enabled(server))\n\t\t\trc = smbd_reconnect(server);\n\t\telse\n\t\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_server_unlock(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconnect error %d\\n\", __func__, rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tset_credits(server, 1);\n\t\t\tspin_lock(&server->srv_lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcifs_swn_reset_server_dstaddr(server);\n\t\t\tcifs_server_unlock(server);\n\t\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t\t}\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\tmod_delayed_work(cifsiod_wq, &server->echo, 0);\n\tspin_unlock(&server->srv_lock);\n\n\twake_up(&server->response_q);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nstatic int __reconnect_target_unlocked(struct TCP_Server_Info *server, const char *target)\n{\n\tint rc;\n\tchar *hostname;\n\n\tif (!cifs_swn_set_server_dstaddr(server)) {\n\t\tif (server->hostname != target) {\n\t\t\thostname = extract_hostname(target);\n\t\t\tif (!IS_ERR(hostname)) {\n\t\t\t\tkfree(server->hostname);\n\t\t\t\tserver->hostname = hostname;\n\t\t\t} else {\n\t\t\t\tcifs_dbg(FYI, \"%s: couldn't extract hostname or address from dfs target: %ld\\n\",\n\t\t\t\t\t __func__, PTR_ERR(hostname));\n\t\t\t\tcifs_dbg(FYI, \"%s: default to last target server: %s\\n\", __func__,\n\t\t\t\t\t server->hostname);\n\t\t\t}\n\t\t}\n\t\t/* resolve the hostname again to make sure that IP address is up-to-date. */\n\t\trc = reconn_set_ipaddr_from_hostname(server);\n\t\tcifs_dbg(FYI, \"%s: reconn_set_ipaddr_from_hostname: rc=%d\\n\", __func__, rc);\n\t}\n\t/* Reconnect the socket */\n\tif (cifs_rdma_enabled(server))\n\t\trc = smbd_reconnect(server);\n\telse\n\t\trc = generic_ip_connect(server);\n\n\treturn rc;\n}\n\nstatic int reconnect_target_unlocked(struct TCP_Server_Info *server, struct dfs_cache_tgt_list *tl,\n\t\t\t\t     struct dfs_cache_tgt_iterator **target_hint)\n{\n\tint rc;\n\tstruct dfs_cache_tgt_iterator *tit;\n\n\t*target_hint = NULL;\n\n\t/* If dfs target list is empty, then reconnect to last server */\n\ttit = dfs_cache_get_tgt_iterator(tl);\n\tif (!tit)\n\t\treturn __reconnect_target_unlocked(server, server->hostname);\n\n\t/* Otherwise, try every dfs target in @tl */\n\tfor (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {\n\t\trc = __reconnect_target_unlocked(server, dfs_cache_get_tgt_name(tit));\n\t\tif (!rc) {\n\t\t\t*target_hint = tit;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int reconnect_dfs_server(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tconst char *refpath = server->current_fullpath + 1;\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tstruct dfs_cache_tgt_iterator *target_hint = NULL;\n\tint num_targets = 0;\n\n\t/*\n\t * Determine the number of dfs targets the referral path in @cifs_sb resolves to.\n\t *\n\t * smb2_reconnect() needs to know how long it should wait based upon the number of dfs\n\t * targets (server->nr_targets).  It's also possible that the cached referral was cleared\n\t * through /proc/fs/cifs/dfscache or the target list is empty due to server settings after\n\t * refreshing the referral, so, in this case, default it to 1.\n\t */\n\tif (!dfs_cache_noreq_find(refpath, NULL, &tl))\n\t\tnum_targets = dfs_cache_get_nr_tgts(&tl);\n\tif (!num_targets)\n\t\tnum_targets = 1;\n\n\tif (!cifs_tcp_ses_needs_reconnect(server, num_targets))\n\t\treturn 0;\n\n\t/*\n\t * Unconditionally mark all sessions & tcons for reconnect as we might be connecting to a\n\t * different server or share during failover.  It could be improved by adding some logic to\n\t * only do that in case it connects to a different server or share, though.\n\t */\n\tcifs_mark_tcp_ses_conns_for_reconnect(server, true);\n\n\tcifs_abort_connection(server);\n\n\tdo {\n\t\ttry_to_freeze();\n\t\tcifs_server_lock(server);\n\n\t\trc = reconnect_target_unlocked(server, &tl, &target_hint);\n\t\tif (rc) {\n\t\t\t/* Failed to reconnect socket */\n\t\t\tcifs_server_unlock(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconnect error %d\\n\", __func__, rc);\n\t\t\tmsleep(3000);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Socket was created.  Update tcp session status to CifsNeedNegotiate so that a\n\t\t * process waiting for reconnect will know it needs to re-establish session and tcon\n\t\t * through the reconnected target server.\n\t\t */\n\t\tatomic_inc(&tcpSesReconnectCount);\n\t\tset_credits(server, 1);\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\tspin_unlock(&server->srv_lock);\n\t\tcifs_swn_reset_server_dstaddr(server);\n\t\tcifs_server_unlock(server);\n\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\tif (target_hint)\n\t\tdfs_cache_noreq_update_tgthint(refpath, target_hint);\n\n\tdfs_cache_free_tgts(&tl);\n\n\t/* Need to set up echo worker again once connection has been established */\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\tmod_delayed_work(cifsiod_wq, &server->echo, 0);\n\tspin_unlock(&server->srv_lock);\n\n\twake_up(&server->response_q);\n\treturn rc;\n}\n\nint cifs_reconnect(struct TCP_Server_Info *server, bool mark_smb_session)\n{\n\t/* If tcp session is not an dfs connection, then reconnect to last target server */\n\tspin_lock(&server->srv_lock);\n\tif (!server->is_dfs_conn) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn __cifs_reconnect(server, mark_smb_session);\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tmutex_lock(&server->refpath_lock);\n\tif (!server->origin_fullpath || !server->leaf_fullpath) {\n\t\tmutex_unlock(&server->refpath_lock);\n\t\treturn __cifs_reconnect(server, mark_smb_session);\n\t}\n\tmutex_unlock(&server->refpath_lock);\n\n\treturn reconnect_dfs_server(server);\n}\n#else\nint cifs_reconnect(struct TCP_Server_Info *server, bool mark_smb_session)\n{\n\treturn __cifs_reconnect(server, mark_smb_session);\n}\n#endif\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo if it is disabled.\n\t * Also, no need to ping if we got a response recently.\n\t */\n\n\tif (server->tcpStatus == CifsNeedReconnect ||\n\t    server->tcpStatus == CifsExiting ||\n\t    server->tcpStatus == CifsNew ||\n\t    (server->ops->can_echo && !server->ops->can_echo(server)) ||\n\t    time_before(jiffies, server->lstrp + server->echo_interval - HZ))\n\t\tgoto requeue_echo;\n\n\trc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Unable to send echo request to server: %s\\n\",\n\t\t\t server->hostname);\n\n\t/* Check witness registrations */\n\tcifs_swn_check();\n\nrequeue_echo:\n\tqueue_delayed_work(cifsiod_wq, &server->echo, server->echo_interval);\n}\n\nstatic bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_server_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_server_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}\n\nstatic bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 3 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tspin_lock(&server->srv_lock);\n\tif ((server->tcpStatus == CifsGood ||\n\t    server->tcpStatus == CifsNeedNegotiate) &&\n\t    (!server->ops->can_echo || server->ops->can_echo(server)) &&\n\t    time_after(jiffies, server->lstrp + 3 * server->echo_interval)) {\n\t\tspin_unlock(&server->srv_lock);\n\t\tcifs_server_dbg(VFS, \"has not responded in %lu seconds. Reconnecting...\\n\",\n\t\t\t (3 * server->echo_interval) / HZ);\n\t\tcifs_reconnect(server, false);\n\t\treturn true;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\treturn false;\n}\n\nstatic inline bool\nzero_credits(struct TCP_Server_Info *server)\n{\n\tint val;\n\n\tspin_lock(&server->req_lock);\n\tval = server->credits + server->echo_credits + server->oplock_credits;\n\tif (server->in_flight == 0 && val == 0) {\n\t\tspin_unlock(&server->req_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&server->req_lock);\n\treturn false;\n}\n\nstatic int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct msghdr *smb_msg)\n{\n\tint length = 0;\n\tint total_read;\n\n\tfor (total_read = 0; msg_data_left(smb_msg); total_read += length) {\n\t\ttry_to_freeze();\n\n\t\t/* reconnect if no credits and no requests in flight */\n\t\tif (zero_credits(server)) {\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\n\t\tif (server_unresponsive(server))\n\t\t\treturn -ECONNABORTED;\n\t\tif (cifs_rdma_enabled(server) && server->smbd_conn)\n\t\t\tlength = smbd_recv(server->smbd_conn, smb_msg);\n\t\telse\n\t\t\tlength = sock_recvmsg(server->ssocket, smb_msg, 0);\n\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\treturn -ESHUTDOWN;\n\t\t}\n\n\t\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\tif (length == -ERESTARTSYS ||\n\t\t    length == -EAGAIN ||\n\t\t    length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: %d\\n\", length);\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\t}\n\treturn total_read;\n}\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct msghdr smb_msg = {};\n\tstruct kvec iov = {.iov_base = buf, .iov_len = to_read};\n\tiov_iter_kvec(&smb_msg.msg_iter, READ, &iov, 1, to_read);\n\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nssize_t\ncifs_discard_from_socket(struct TCP_Server_Info *server, size_t to_read)\n{\n\tstruct msghdr smb_msg = {};\n\n\t/*\n\t *  iov_iter_discard already sets smb_msg.type and count and iov_offset\n\t *  and cifs_readv_from_socket sets msg_control and msg_controllen\n\t *  so little to initialize in struct msghdr\n\t */\n\tiov_iter_discard(&smb_msg.msg_iter, READ, to_read);\n\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nint\ncifs_read_page_from_socket(struct TCP_Server_Info *server, struct page *page,\n\tunsigned int page_offset, unsigned int to_read)\n{\n\tstruct msghdr smb_msg = {};\n\tstruct bio_vec bv = {\n\t\t.bv_page = page, .bv_len = to_read, .bv_offset = page_offset};\n\tiov_iter_bvec(&smb_msg.msg_iter, READ, &bv, 1, to_read);\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nstatic bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server, true);\n\t\tbreak;\n\tdefault:\n\t\tcifs_server_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server, true);\n\t}\n\n\treturn false;\n}\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&mid->server->mid_lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t/*\n\t * Trying to handle/dequeue a mid after the send_recv()\n\t * function has finished processing it is a bug.\n\t */\n\tif (mid->mid_flags & MID_DELETED) {\n\t\tspin_unlock(&mid->server->mid_lock);\n\t\tpr_warn_once(\"trying to dequeue a deleted mid\\n\");\n\t} else {\n\t\tlist_del_init(&mid->qhead);\n\t\tmid->mid_flags |= MID_DELETED;\n\t\tspin_unlock(&mid->server->mid_lock);\n\t}\n}\n\nstatic unsigned int\nsmb2_get_credits_from_hdr(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buffer;\n\n\t/*\n\t * SMB1 does not use credits.\n\t */\n\tif (is_smb1(server))\n\t\treturn 0;\n\n\treturn le16_to_cpu(shdr->CreditRequest);\n}\n\nstatic void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->credits_received = smb2_get_credits_from_hdr(buf, server);\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}\n\nint\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\tif (cifs_rdma_enabled(server) && server->sign)\n\t\tcifs_dbg(VFS, \"Signing is enabled, and RDMA read/write will be disabled\\n\");\n\n\treturn 0;\n}\n\n\nstatic void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&server->srv_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&server->srv_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\tif (cifs_rdma_enabled(server))\n\t\tsmbd_destroy(server);\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&server->mid_lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid %llu\\n\", mid_entry->mid);\n\t\t\tkref_get(&mid_entry->refcount);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t\tmid_entry->mid_flags |= MID_DELETED;\n\t\t}\n\t\tspin_unlock(&server->mid_lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid %llu\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t\trelease_mid(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tkfree(server->origin_fullpath);\n\tkfree(server->leaf_fullpath);\n#endif\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\n}\n\nstatic int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) -\n\t    HEADER_PREAMBLE_SIZE(server)) {\n\t\tcifs_server_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\t       pdu_length - MID_HEADER_SIZE(server));\n\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\treturn cifs_handle_standard(server, mid);\n}\n\nint\ncifs_handle_standard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tchar *buf = server->large_buf ? server->bigbuf : server->smallbuf;\n\tint rc;\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\trc = server->ops->check_message(buf, server->total_read, server);\n\tif (rc)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_session_expired &&\n\t    server->ops->is_session_expired(buf)) {\n\t\tcifs_reconnect(server, true);\n\t\treturn -1;\n\t}\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn rc;\n\n\thandle_mid(mid, server, buf, rc);\n\treturn 0;\n}\n\nstatic void\nsmb2_add_credits_from_hdr(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buffer;\n\tint scredits, in_flight;\n\n\t/*\n\t * SMB1 does not use credits.\n\t */\n\tif (is_smb1(server))\n\t\treturn;\n\n\tif (shdr->CreditRequest) {\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += le16_to_cpu(shdr->CreditRequest);\n\t\tscredits = server->credits;\n\t\tin_flight = server->in_flight;\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\n\t\ttrace_smb3_hdr_credits(server->CurrentMid,\n\t\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\t\tle16_to_cpu(shdr->CreditRequest), in_flight);\n\t\tcifs_server_dbg(FYI, \"%s: added %u credits total=%d\\n\",\n\t\t\t\t__func__, le16_to_cpu(shdr->CreditRequest),\n\t\t\t\tscredits);\n\t}\n}\n\n\nstatic int\ncifs_demultiplex_thread(void *p)\n{\n\tint i, num_mids, length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tunsigned int next_offset;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mids[MAX_COMPOUND];\n\tchar *bufs[MAX_COMPOUND];\n\tunsigned int noreclaim_flag, num_io_timeout = 0;\n\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tcifs_dbg(FYI, \"Demultiplex PID: %d\\n\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\n\n\tset_freezable();\n\tallow_kernel_signal(SIGKILL);\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (is_smb1(server))\n\t\t\tserver->total_read = length;\n\t\telse\n\t\t\tserver->total_read = 0;\n\n\t\t/*\n\t\t * The right amount was read from socket - 4 bytes,\n\t\t * so we can now interpret the length field.\n\t\t */\n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, \"RFC1002 header 0x%x\\n\", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\nnext_pdu:\n\t\tserver->pdu_size = pdu_length;\n\n\t\t/* make sure we have enough to get to the MID */\n\t\tif (server->pdu_size < MID_HEADER_SIZE(server)) {\n\t\t\tcifs_server_dbg(VFS, \"SMB response too short (%u bytes)\\n\",\n\t\t\t\t server->pdu_size);\n\t\t\tcifs_reconnect(server, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* read down to the MID */\n\t\tlength = cifs_read_from_socket(server,\n\t\t\t     buf + HEADER_PREAMBLE_SIZE(server),\n\t\t\t     MID_HEADER_SIZE(server));\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tif (server->ops->next_header) {\n\t\t\tnext_offset = server->ops->next_header(buf);\n\t\t\tif (next_offset)\n\t\t\t\tserver->pdu_size = next_offset;\n\t\t}\n\n\t\tmemset(mids, 0, sizeof(mids));\n\t\tmemset(bufs, 0, sizeof(bufs));\n\t\tnum_mids = 0;\n\n\t\tif (server->ops->is_transform_hdr &&\n\t\t    server->ops->receive_transform &&\n\t\t    server->ops->is_transform_hdr(buf)) {\n\t\t\tlength = server->ops->receive_transform(server,\n\t\t\t\t\t\t\t\tmids,\n\t\t\t\t\t\t\t\tbufs,\n\t\t\t\t\t\t\t\t&num_mids);\n\t\t} else {\n\t\t\tmids[0] = server->ops->find_mid(server, buf);\n\t\t\tbufs[0] = buf;\n\t\t\tnum_mids = 1;\n\n\t\t\tif (!mids[0] || !mids[0]->receive)\n\t\t\t\tlength = standard_receive3(server, mids[0]);\n\t\t\telse\n\t\t\t\tlength = mids[0]->receive(server, mids[0]);\n\t\t}\n\n\t\tif (length < 0) {\n\t\t\tfor (i = 0; i < num_mids; i++)\n\t\t\t\tif (mids[i])\n\t\t\t\t\trelease_mid(mids[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (server->ops->is_status_io_timeout &&\n\t\t    server->ops->is_status_io_timeout(buf)) {\n\t\t\tnum_io_timeout++;\n\t\t\tif (num_io_timeout > NUM_STATUS_IO_TIMEOUT) {\n\t\t\t\tcifs_reconnect(server, false);\n\t\t\t\tnum_io_timeout = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tserver->lstrp = jiffies;\n\n\t\tfor (i = 0; i < num_mids; i++) {\n\t\t\tif (mids[i] != NULL) {\n\t\t\t\tmids[i]->resp_buf_size = server->pdu_size;\n\n\t\t\t\tif (bufs[i] && server->ops->is_network_name_deleted)\n\t\t\t\t\tserver->ops->is_network_name_deleted(bufs[i],\n\t\t\t\t\t\t\t\t\tserver);\n\n\t\t\t\tif (!mids[i]->multiRsp || mids[i]->multiEnd)\n\t\t\t\t\tmids[i]->callback(mids[i]);\n\n\t\t\t\trelease_mid(mids[i]);\n\t\t\t} else if (server->ops->is_oplock_break &&\n\t\t\t\t   server->ops->is_oplock_break(bufs[i],\n\t\t\t\t\t\t\t\tserver)) {\n\t\t\t\tsmb2_add_credits_from_hdr(bufs[i], server);\n\t\t\t\tcifs_dbg(FYI, \"Received oplock break\\n\");\n\t\t\t} else {\n\t\t\t\tcifs_server_dbg(VFS, \"No task to wake, unknown frame received! NumMids %d\\n\",\n\t\t\t\t\t\tatomic_read(&mid_count));\n\t\t\t\tcifs_dump_mem(\"Received Data is: \", bufs[i],\n\t\t\t\t\t      HEADER_SIZE(server));\n\t\t\t\tsmb2_add_credits_from_hdr(bufs[i], server);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\t\tif (server->ops->dump_detail)\n\t\t\t\t\tserver->ops->dump_detail(bufs[i],\n\t\t\t\t\t\t\t\t server);\n\t\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\t\t\t}\n\t\t}\n\n\t\tif (pdu_length > server->pdu_size) {\n\t\t\tif (!allocate_buffers(server))\n\t\t\t\tcontinue;\n\t\t\tpdu_length -= server->pdu_size;\n\t\t\tserver->total_read = 0;\n\t\t\tserver->large_buf = false;\n\t\t\tbuf = server->smallbuf;\n\t\t\tgoto next_pdu;\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* buffer usually freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(server->bigbuf);\n\tif (server->smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(server->smallbuf);\n\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tclean_demultiplex_info(server);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tmodule_put_and_kthread_exit(0);\n}\n\n/*\n * Returns true if srcaddr isn't specified and rhs isn't specified, or\n * if srcaddr is specified and matches the IP address of the rhs argument\n */\nbool\ncifs_match_ipaddr(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}\n\n/*\n * If no port is specified in addr structure, we try to match with 445 port\n * and if it fails - with 139 ports. It should be called only if address\n * families of server and addr are equal.\n */\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\t/* SMBDirect manages its own ports, don't match it here */\n\tif (server->rdma)\n\t\treturn true;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!cifs_match_ipaddr(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\t/*\n\t * The select_sectype function should either return the ctx->sectype\n\t * that was specified, or \"Unspecified\" if that sectype was not\n\t * compatible with the given NEGOTIATE request.\n\t */\n\tif (server->ops->select_sectype(server, ctx->sectype)\n\t     == Unspecified)\n\t\treturn false;\n\n\t/*\n\t * Now check if signing mode is acceptable. No need to check\n\t * global_secflags at this point since if MUST_SIGN is set then\n\t * the server->sign had better be too.\n\t */\n\tif (ctx->sign && !server->sign)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* this function must be called with srv_lock held */\nstatic int match_server(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&ctx->dstaddr;\n\n\tif (ctx->nosharesock)\n\t\treturn 0;\n\n\t/* this server does not share socket */\n\tif (server->nosharesock)\n\t\treturn 0;\n\n\t/* If multidialect negotiation see if existing sessions match one */\n\tif (strcmp(ctx->vals->version_string, SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (server->vals->protocol_id < SMB30_PROT_ID)\n\t\t\treturn 0;\n\t} else if (strcmp(ctx->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (server->vals->protocol_id < SMB21_PROT_ID)\n\t\t\treturn 0;\n\t} else if ((server->vals != ctx->vals) || (server->ops != ctx->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (strcasecmp(server->hostname, ctx->server_hostname))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&ctx->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, ctx))\n\t\treturn 0;\n\n\tif (server->echo_interval != ctx->echo_interval * HZ)\n\t\treturn 0;\n\n\tif (server->rdma != ctx->rdma)\n\t\treturn 0;\n\n\tif (server->ignore_signature != ctx->ignore_signature)\n\t\treturn 0;\n\n\tif (server->min_offload != ctx->min_offload)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct TCP_Server_Info *\ncifs_find_tcp_session(struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tspin_lock(&server->srv_lock);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\t/*\n\t\t * DFS failover implementation in cifs_reconnect() requires unique tcp sessions for\n\t\t * DFS connections to do failover properly, so avoid sharing them with regular\n\t\t * shares or even links that may connect to same server but having completely\n\t\t * different failover targets.\n\t\t */\n\t\tif (server->is_dfs_conn) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t/*\n\t\t * Skip ses channels since they're only handled in lower layers\n\t\t * (e.g. cifs_send_recv).\n\t\t */\n\t\tif (CIFS_SERVER_IS_CHAN(server) || !match_server(server, ctx)) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid\ncifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\t/* srv_count can never go negative */\n\tWARN_ON(server->srv_count < 0);\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* For secondary channels, we pick up ref-count on the primary server */\n\tif (CIFS_SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server->primary_server, from_reconnect);\n\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\n\tif (from_reconnect)\n\t\t/*\n\t\t * Avoid deadlock here: reconnect work calls\n\t\t * cifs_put_tcp_session() at its end. Need to be sure\n\t\t * that reconnect work does nothing with server pointer after\n\t\t * that step.\n\t\t */\n\t\tcancel_delayed_work(&server->reconnect);\n\telse\n\t\tcancel_delayed_work_sync(&server->reconnect);\n\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\n\tcifs_crypto_secmech_release(server);\n\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tkfree(server->hostname);\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tsend_sig(SIGKILL, task, 1);\n}\n\nstruct TCP_Server_Info *\ncifs_get_tcp_session(struct smb3_fs_context *ctx,\n\t\t     struct TCP_Server_Info *primary_server)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", ctx->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(ctx);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->hostname = kstrdup(ctx->server_hostname, GFP_KERNEL);\n\tif (!tcp_ses->hostname) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (ctx->nosharesock)\n\t\ttcp_ses->nosharesock = true;\n\n\ttcp_ses->ops = ctx->ops;\n\ttcp_ses->vals = ctx->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\n\ttcp_ses->conn_id = atomic_inc_return(&tcpSesNextId);\n\ttcp_ses->noblockcnt = ctx->rootfs;\n\ttcp_ses->noblocksnd = ctx->noblocksnd || ctx->rootfs;\n\ttcp_ses->noautotune = ctx->noautotune;\n\ttcp_ses->tcp_nodelay = ctx->sockopt_tcp_nodelay;\n\ttcp_ses->rdma = ctx->rdma;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->max_in_flight = 0;\n\ttcp_ses->credits = 1;\n\tif (primary_server) {\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\t++primary_server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\ttcp_ses->primary_server = primary_server;\n\t}\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->_srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tctx->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tctx->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->reconnect_instance = 1;\n\ttcp_ses->lstrp = jiffies;\n\ttcp_ses->compress_algorithm = cpu_to_le16(ctx->compression);\n\tspin_lock_init(&tcp_ses->req_lock);\n\tspin_lock_init(&tcp_ses->srv_lock);\n\tspin_lock_init(&tcp_ses->mid_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tINIT_DELAYED_WORK(&tcp_ses->resolve, cifs_resolve_server);\n\tINIT_DELAYED_WORK(&tcp_ses->reconnect, smb2_reconnect_server);\n\tmutex_init(&tcp_ses->reconnect_mutex);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tmutex_init(&tcp_ses->refpath_lock);\n#endif\n\tmemcpy(&tcp_ses->srcaddr, &ctx->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &ctx->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n\tif (ctx->use_client_guid)\n\t\tmemcpy(tcp_ses->client_guid, ctx->client_guid,\n\t\t       SMB2_CLIENT_GUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(tcp_ses->client_guid);\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\tif (ctx->echo_interval >= SMB_ECHO_INTERVAL_MIN &&\n\t\tctx->echo_interval <= SMB_ECHO_INTERVAL_MAX)\n\t\ttcp_ses->echo_interval = ctx->echo_interval * HZ;\n\telse\n\t\ttcp_ses->echo_interval = SMB_ECHO_INTERVAL_DEFAULT * HZ;\n\tif (tcp_ses->rdma) {\n#ifndef CONFIG_CIFS_SMB_DIRECT\n\t\tcifs_dbg(VFS, \"CONFIG_CIFS_SMB_DIRECT is not enabled\\n\");\n\t\trc = -ENOENT;\n\t\tgoto out_err_crypto_release;\n#endif\n\t\ttcp_ses->smbd_conn = smbd_get_connection(\n\t\t\ttcp_ses, (struct sockaddr *)&ctx->dstaddr);\n\t\tif (tcp_ses->smbd_conn) {\n\t\t\tcifs_dbg(VFS, \"RDMA transport established\\n\");\n\t\t\trc = 0;\n\t\t\tgoto smbd_connected;\n\t\t} else {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err_crypto_release;\n\t\t}\n\t}\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\nsmbd_connected:\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->min_offload = ctx->min_offload;\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this update of tcpStatus\n\t */\n\tspin_lock(&tcp_ses->srv_lock);\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\tspin_unlock(&tcp_ses->srv_lock);\n\n\tif ((ctx->max_credits < 20) || (ctx->max_credits > 60000))\n\t\ttcp_ses->max_credits = SMB2_MAX_CREDITS_AVAILABLE;\n\telse\n\t\ttcp_ses->max_credits = ctx->max_credits;\n\n\ttcp_ses->nr_targets = 1;\n\ttcp_ses->ignore_signature = ctx->ignore_signature;\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, tcp_ses->echo_interval);\n\n\t/* queue dns resolution delayed work */\n\tcifs_dbg(FYI, \"%s: next dns resolution scheduled for %d seconds in the future\\n\",\n\t\t __func__, SMB_DNS_RESOLVE_INTERVAL_DEFAULT);\n\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->resolve, (SMB_DNS_RESOLVE_INTERVAL_DEFAULT * HZ));\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_secmech_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (CIFS_SERVER_IS_CHAN(tcp_ses))\n\t\t\tcifs_put_tcp_session(tcp_ses->primary_server, false);\n\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\n/* this function must be called with ses_lock held */\nstatic int match_session(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tif (ctx->sectype != Unspecified &&\n\t    ctx->sectype != ses->sectype)\n\t\treturn 0;\n\n\t/*\n\t * If an existing session is limited to less channels than\n\t * requested, it should not be reused\n\t */\n\tspin_lock(&ses->chan_lock);\n\tif (ses->chan_max < ctx->max_channels) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(ctx->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!ctx->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    ctx->username ? ctx->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((ctx->username && strlen(ctx->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    ctx->password ? ctx->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/**\n * cifs_setup_ipc - helper to setup the IPC tcon for the session\n * @ses: smb session to issue the request on\n * @ctx: the superblock configuration context to use for building the\n *       new tree connection for the IPC (interprocess communication RPC)\n *\n * A new IPC connection is made and stored in the session\n * tcon_ipc. The IPC tcon has the same lifetime as the session.\n */\nstatic int\ncifs_setup_ipc(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tint rc = 0, xid;\n\tstruct cifs_tcon *tcon;\n\tchar unc[SERVER_NAME_LENGTH + sizeof(\"//x/IPC$\")] = {0};\n\tbool seal = false;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\t/*\n\t * If the mount request that resulted in the creation of the\n\t * session requires encryption, force IPC to be encrypted too.\n\t */\n\tif (ctx->seal) {\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION)\n\t\t\tseal = true;\n\t\telse {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t \"IPC: server doesn't support encryption\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL)\n\t\treturn -ENOMEM;\n\n\tscnprintf(unc, sizeof(unc), \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\n\txid = get_xid();\n\ttcon->ses = ses;\n\ttcon->ipc = true;\n\ttcon->seal = seal;\n\trc = server->ops->tree_connect(xid, ses, unc, tcon, ctx->local_nls);\n\tfree_xid(xid);\n\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"failed to connect to IPC (rc=%d)\\n\", rc);\n\t\ttconInfoFree(tcon);\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"IPC tcon rc=%d ipc tid=0x%x\\n\", rc, tcon->tid);\n\n\tses->tcon_ipc = tcon;\nout:\n\treturn rc;\n}\n\n/**\n * cifs_free_ipc - helper to release the session IPC tcon\n * @ses: smb session to unmount the IPC from\n *\n * Needs to be called everytime a session is destroyed.\n *\n * On session close, the IPC is closed and the server must release all tcons of the session.\n * No need to send a tree disconnect here.\n *\n * Besides, it will make the server to not close durable and resilient files on session close, as\n * specified in MS-SMB2 3.3.5.6 Receiving an SMB2 LOGOFF Request.\n */\nstatic int\ncifs_free_ipc(struct cifs_ses *ses)\n{\n\tstruct cifs_tcon *tcon = ses->tcon_ipc;\n\n\tif (tcon == NULL)\n\t\treturn 0;\n\n\ttconInfoFree(tcon);\n\tses->tcon_ipc = NULL;\n\treturn 0;\n}\n\nstatic struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_EXITING) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!match_session(ses, ctx)) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ses->ses_lock);\n\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid cifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tunsigned int chan_count;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_EXITING) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\tcifs_dbg(FYI,\n\t\t \"%s: ses ipc: %s\\n\", __func__, ses->tcon_ipc ? ses->tcon_ipc->tree_name : \"NONE\");\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* ses_count can never go negative */\n\tWARN_ON(ses->ses_count < 0);\n\n\tif (ses->ses_status == SES_GOOD)\n\t\tses->ses_status = SES_EXITING;\n\n\tcifs_free_ipc(ses);\n\n\tif (ses->ses_status == SES_EXITING && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_server_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tchan_count = ses->chan_count;\n\n\t/* close any extra channels */\n\tif (chan_count > 1) {\n\t\tint i;\n\n\t\tfor (i = 1; i < chan_count; i++) {\n\t\t\tif (ses->chans[i].iface) {\n\t\t\t\tkref_put(&ses->chans[i].iface->refcount, release_iface);\n\t\t\t\tses->chans[i].iface = NULL;\n\t\t\t}\n\t\t\tcifs_put_tcp_session(ses->chans[i].server, 0);\n\t\t\tses->chans[i].server = NULL;\n\t\t}\n\t}\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server, 0);\n}\n\n#ifdef CONFIG_KEYS\n\n/* strlen(\"cifs:a:\") + CIFS_MAX_DOMAINNAME_LEN + 1 */\n#define CIFSCREDS_DESC_SIZE (7 + CIFS_MAX_DOMAINNAME_LEN + 1)\n\n/* Populate username and pw fields from keyring if possible */\nstatic int\ncifs_set_cifscreds(struct smb3_fs_context *ctx, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tint is_domain = 0;\n\tconst char *delim, *payload;\n\tchar *desc;\n\tssize_t len;\n\tstruct key *key;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tconst struct user_key_payload *upayload;\n\n\tdesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t/* try to find an address key first */\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tsa = (struct sockaddr_in *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsa6 = (struct sockaddr_in6 *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI6c\", &sa6->sin6_addr.s6_addr);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Bad ss_family (%hu)\\n\",\n\t\t\t server->dstaddr.ss_family);\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\tkey = request_key(&key_type_logon, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (!ses->domainName) {\n\t\t\tcifs_dbg(FYI, \"domainName is NULL\\n\");\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t/* didn't work, try to find a domain key */\n\t\tsprintf(desc, \"cifs:d:%s\", ses->domainName);\n\t\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\t\tkey = request_key(&key_type_logon, desc, \"\");\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\t\tis_domain = 1;\n\t}\n\n\tdown_read(&key->sem);\n\tupayload = user_key_payload_locked(key);\n\tif (IS_ERR_OR_NULL(upayload)) {\n\t\trc = upayload ? PTR_ERR(upayload) : -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\t/* find first : in payload */\n\tpayload = upayload->data;\n\tdelim = strnchr(payload, upayload->datalen, ':');\n\tcifs_dbg(FYI, \"payload=%s\\n\", payload);\n\tif (!delim) {\n\t\tcifs_dbg(FYI, \"Unable to find ':' in payload (datalen=%d)\\n\",\n\t\t\t upayload->datalen);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tlen = delim - payload;\n\tif (len > CIFS_MAX_USERNAME_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad value from username search (len=%zd)\\n\",\n\t\t\t len);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tctx->username = kstrndup(payload, len, GFP_KERNEL);\n\tif (!ctx->username) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for username\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tgoto out_key_put;\n\t}\n\tcifs_dbg(FYI, \"%s: username=%s\\n\", __func__, ctx->username);\n\n\tlen = key->datalen - (len + 1);\n\tif (len > CIFS_MAX_PASSWORD_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad len for password search (len=%zd)\\n\", len);\n\t\trc = -EINVAL;\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t++delim;\n\tctx->password = kstrndup(delim, len, GFP_KERNEL);\n\tif (!ctx->password) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for password\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t/*\n\t * If we have a domain key then we must set the domainName in the\n\t * for the request.\n\t */\n\tif (is_domain && ses->domainName) {\n\t\tctx->domainname = kstrdup(ses->domainName, GFP_KERNEL);\n\t\tif (!ctx->domainname) {\n\t\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for domain\\n\",\n\t\t\t\t len);\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(ctx->username);\n\t\t\tctx->username = NULL;\n\t\t\tkfree_sensitive(ctx->password);\n\t\t\tctx->password = NULL;\n\t\t\tgoto out_key_put;\n\t\t}\n\t}\n\n\tstrscpy(ctx->workstation_name, ses->workstation_name, sizeof(ctx->workstation_name));\n\nout_key_put:\n\tup_read(&key->sem);\n\tkey_put(key);\nout_err:\n\tkfree(desc);\n\tcifs_dbg(FYI, \"%s: returning %d\\n\", __func__, rc);\n\treturn rc;\n}\n#else /* ! CONFIG_KEYS */\nstatic inline int\ncifs_set_cifscreds(struct smb3_fs_context *ctx __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}\n#endif /* CONFIG_KEYS */\n\n/**\n * cifs_get_smb_ses - get a session matching @ctx data from @server\n * @server: server to setup the session to\n * @ctx: superblock configuration context to use to setup the session\n *\n * This function assumes it is being called from cifs_mount() where we\n * already got a server reference (server refcount +1). See\n * cifs_get_tcon() for refcount explanations.\n */\nstruct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, ctx);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->ses_status);\n\n\t\tspin_lock(&ses->chan_lock);\n\t\tif (cifs_chan_needs_reconnect(ses, server)) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\n\t\t\tmutex_lock(&ses->session_mutex);\n\t\t\trc = cifs_negotiate_protocol(xid, ses, server);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our ses reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\n\t\t\trc = cifs_setup_session(xid, ses, server,\n\t\t\t\t\t\tctx->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t\tspin_lock(&ses->chan_lock);\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server, 0);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->ip_addr, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->ip_addr, \"%pI4\", &addr->sin_addr);\n\n\tif (ctx->username) {\n\t\tses->user_name = kstrdup(ctx->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* ctx->password freed at unmount */\n\tif (ctx->password) {\n\t\tses->password = kstrdup(ctx->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (ctx->domainname) {\n\t\tses->domainName = kstrdup(ctx->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\tstrscpy(ses->workstation_name, ctx->workstation_name, sizeof(ses->workstation_name));\n\n\tif (ctx->domainauto)\n\t\tses->domainAuto = ctx->domainauto;\n\tses->cred_uid = ctx->cred_uid;\n\tses->linux_uid = ctx->linux_uid;\n\n\tses->sectype = ctx->sectype;\n\tses->sign = ctx->sign;\n\n\t/* add server as first channel */\n\tspin_lock(&ses->chan_lock);\n\tses->chans[0].server = server;\n\tses->chan_count = 1;\n\tses->chan_max = ctx->multichannel ? ctx->max_channels:1;\n\tses->chans_need_reconnect = 1;\n\tspin_unlock(&ses->chan_lock);\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses, server);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, server, ctx->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* each channel uses a different signing key */\n\tspin_lock(&ses->chan_lock);\n\tmemcpy(ses->chans[0].signkey, ses->smb3signingkey,\n\t       sizeof(ses->smb3signingkey));\n\tspin_unlock(&ses->chan_lock);\n\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/*\n\t * success, put it on the list and add it as first channel\n\t * note: the session becomes active soon after this. So you'll\n\t * need to lock before changing something in the session.\n\t */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\n\tcifs_setup_ipc(ses, ctx);\n\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}\n\n/* this function must be called with tc_lock held */\nstatic int match_tcon(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tif (tcon->status == TID_EXITING)\n\t\treturn 0;\n\tif (strncmp(tcon->tree_name, ctx->UNC, MAX_TREE_SIZE))\n\t\treturn 0;\n\tif (tcon->seal != ctx->seal)\n\t\treturn 0;\n\tif (tcon->snapshot_time != ctx->snapshot_time)\n\t\treturn 0;\n\tif (tcon->handle_timeout != ctx->handle_timeout)\n\t\treturn 0;\n\tif (tcon->no_lease != ctx->no_lease)\n\t\treturn 0;\n\tif (tcon->nodelete != ctx->nodelete)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (!match_tcon(tcon, ctx)) {\n\t\t\tspin_unlock(&tcon->tc_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&tcon->tc_lock);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\n\t/*\n\t * IPC tcon share the lifetime of their session and are\n\t * destroyed in the session put function\n\t */\n\tif (tcon == NULL || tcon->ipc)\n\t\treturn;\n\n\tses = tcon->ses;\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tspin_lock(&tcon->tc_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\t/* tc_count can never go negative */\n\tWARN_ON(tcon->tc_count < 0);\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&tcon->tc_lock);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel polling of interfaces */\n\tcancel_delayed_work_sync(&tcon->query_interfaces);\n\n\tif (tcon->use_witness) {\n\t\tint rc;\n\n\t\trc = cifs_swn_unregister(tcon);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"%s: Failed to unregister for witness notifications: %d\\n\",\n\t\t\t\t\t__func__, rc);\n\t\t}\n\t}\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\n/**\n * cifs_get_tcon - get a tcon matching @ctx data from @ses\n * @ses: smb session to issue the request on\n * @ctx: the superblock configuration context to use for building the\n *\n * - tcon refcount is the number of mount points using the tcon.\n * - ses refcount is the number of tcon using the session.\n *\n * 1. This function assumes it is being called from cifs_mount() where\n *    we already got a session reference (ses refcount +1).\n *\n * 2. Since we're in the context of adding a mount point, the end\n *    result should be either:\n *\n * a) a new tcon already allocated with refcount=1 (1 mount point) and\n *    its session refcount incremented (1 new tcon). This +1 was\n *    already done in (1).\n *\n * b) an existing tcon with refcount+1 (add a mount point to it) and\n *    identical ses refcount (no new tcon). Because of (1) we need to\n *    decrement the ses refcount.\n */\nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, ctx);\n\tif (tcon) {\n\t\t/*\n\t\t * tcon has refcount already incremented but we need to\n\t\t * decrement extra ses reference gotten by caller (case b)\n\t\t */\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\tcifs_put_smb_ses(ses);\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\tif (ctx->snapshot_time) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"Use SMB2 or later for snapshot mount option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->snapshot_time = ctx->snapshot_time;\n\t}\n\n\tif (ctx->handle_timeout) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"Use SMB2.1 or later for handle timeout option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->handle_timeout = ctx->handle_timeout;\n\t}\n\n\ttcon->ses = ses;\n\tif (ctx->password) {\n\t\ttcon->password = kstrdup(ctx->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (ctx->seal) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t \"SMB3 or later required for encryption\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else if (tcon->ses->server->capabilities &\n\t\t\t\t\tSMB2_GLOBAL_CAP_ENCRYPTION)\n\t\t\ttcon->seal = true;\n\t\telse {\n\t\t\tcifs_dbg(VFS, \"Encryption is not supported on share\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (ctx->linux_ext) {\n\t\tif (ses->server->posix_ext_supported) {\n\t\t\ttcon->posix_extensions = true;\n\t\t\tpr_warn_once(\"SMB3.11 POSIX Extensions are experimental\\n\");\n\t\t} else if ((ses->server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMB3ANY_VERSION_STRING) == 0) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0)) {\n\t\t\tcifs_dbg(VFS, \"Server does not support mounting with posix SMB3.11 extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Check vers= mount option. SMB3.11 \"\n\t\t\t\t\"disabled but required for POSIX extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, ctx->UNC, tcon,\n\t\t\t\t\t    ctx->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\ttcon->use_persistent = false;\n\t/* check if SMB2 or later, CIFS does not support persistent handles */\n\tif (ctx->persistent) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"SMB3 or later required for persistent handles\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else if (ses->server->capabilities &\n\t\t\t   SMB2_GLOBAL_CAP_PERSISTENT_HANDLES)\n\t\t\ttcon->use_persistent = true;\n\t\telse /* persistent handles requested but not supported */ {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"Persistent handles not supported on share\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t} else if ((tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\t     && (ses->server->capabilities & SMB2_GLOBAL_CAP_PERSISTENT_HANDLES)\n\t     && (ctx->nopersistent == false)) {\n\t\tcifs_dbg(FYI, \"enabling persistent handles\\n\");\n\t\ttcon->use_persistent = true;\n\t} else if (ctx->resilient) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"SMB2.1 or later required for resilient handles\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t\ttcon->use_resilient = true;\n\t}\n\n\ttcon->use_witness = false;\n\tif (IS_ENABLED(CONFIG_CIFS_SWN_UPCALL) && ctx->witness) {\n\t\tif (ses->server->vals->protocol_id >= SMB30_PROT_ID) {\n\t\t\tif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER) {\n\t\t\t\t/*\n\t\t\t\t * Set witness in use flag in first place\n\t\t\t\t * to retry registration in the echo task\n\t\t\t\t */\n\t\t\t\ttcon->use_witness = true;\n\t\t\t\t/* And try to register immediately */\n\t\t\t\trc = cifs_swn_register(tcon);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tcifs_dbg(VFS, \"Failed to register for witness notifications: %d\\n\", rc);\n\t\t\t\t\tgoto out_fail;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* TODO: try to extend for non-cluster uses (eg multichannel) */\n\t\t\t\tcifs_dbg(VFS, \"witness requested on mount but no CLUSTER capability on share\\n\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"SMB3 or later required for witness option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/* If the user really knows what they are doing they can override */\n\tif (tcon->share_flags & SMB2_SHAREFLAG_NO_CACHING) {\n\t\tif (ctx->cache_ro)\n\t\t\tcifs_dbg(VFS, \"cache=ro requested on mount but NO_CACHING flag set on share\\n\");\n\t\telse if (ctx->cache_rw)\n\t\t\tcifs_dbg(VFS, \"cache=singleclient requested on mount but NO_CACHING flag set on share\\n\");\n\t}\n\n\tif (ctx->no_lease) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 or later required for nolease option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->no_lease = ctx->no_lease;\n\t}\n\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = ctx->retry;\n\ttcon->nocase = ctx->nocase;\n\ttcon->broken_sparse_sup = ctx->no_sparse;\n\tif (ses->server->capabilities & SMB2_GLOBAL_CAP_DIRECTORY_LEASING)\n\t\ttcon->nohandlecache = ctx->nohandlecache;\n\telse\n\t\ttcon->nohandlecache = true;\n\ttcon->nodelete = ctx->nodelete;\n\ttcon->local_lease = ctx->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\t/* schedule query interfaces poll */\n\tINIT_DELAYED_WORK(&tcon->query_interfaces,\n\t\t\t  smb2_query_server_interfaces);\n\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}\n\nstatic int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\tunsigned int oldflags = old->mnt_cifs_flags & CIFS_MOUNT_MASK;\n\tunsigned int newflags = new->mnt_cifs_flags & CIFS_MOUNT_MASK;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif (old->mnt_cifs_serverino_autodisabled)\n\t\tnewflags &= ~CIFS_MOUNT_SERVER_INUM;\n\n\tif (oldflags != newflags)\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->ctx->wsize && new->ctx->wsize < old->ctx->wsize)\n\t\treturn 0;\n\n\tif (new->ctx->rsize && new->ctx->rsize < old->ctx->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->ctx->linux_uid, new->ctx->linux_uid) ||\n\t    !gid_eq(old->ctx->linux_gid, new->ctx->linux_gid))\n\t\treturn 0;\n\n\tif (old->ctx->file_mode != new->ctx->file_mode ||\n\t    old->ctx->dir_mode != new->ctx->dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->ctx->acregmax != new->ctx->acregmax)\n\t\treturn 0;\n\tif (old->ctx->acdirmax != new->ctx->acdirmax)\n\t\treturn 0;\n\tif (old->ctx->closetimeo != new->ctx->closetimeo)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nmatch_prepath(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\tbool old_set = (old->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH) &&\n\t\told->prepath;\n\tbool new_set = (new->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH) &&\n\t\tnew->prepath;\n\n\tif (old_set && new_set && !strcmp(new->prepath, old->prepath))\n\t\treturn 1;\n\telse if (!old_set && !new_set)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint\ncifs_match_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = data;\n\tstruct smb3_fs_context *ctx;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *tcp_srv;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tcifs_sb = CIFS_SB(sb);\n\ttlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\tif (tlink == NULL) {\n\t\t/* can not match superblock if tlink were ever null */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn 0;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tses = tcon->ses;\n\ttcp_srv = ses->server;\n\n\tctx = mnt_data->ctx;\n\n\tspin_lock(&tcp_srv->srv_lock);\n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&tcon->tc_lock);\n\tif (!match_server(tcp_srv, ctx) ||\n\t    !match_session(ses, ctx) ||\n\t    !match_tcon(tcon, ctx) ||\n\t    !match_prepath(sb, mnt_data)) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = compare_mount_options(sb, mnt_data);\nout:\n\tspin_unlock(&tcon->tc_lock);\n\tspin_unlock(&ses->ses_lock);\n\tspin_unlock(&tcp_srv->srv_lock);\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(!sock_allow_reclassification(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(!sock_allow_reclassification(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_server_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_server_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tunsigned int req_noscope_len;\n\tstruct smb_hdr *smb_buf;\n\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scopes */\n\t\treq_noscope_len = sizeof(struct rfc1002_session_packet) - 2;\n\n\t\t/* == cpu_to_be32(0x81000044) */\n\t\tsmb_buf->smb_buf_length =\n\t\t\tcpu_to_be32((RFC1002_SESSION_REQUEST << 24) | req_noscope_len);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tsport = ipv6->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t\tcifs_dbg(FYI, \"%s: connecting to [%pI6]:%d\\n\", __func__, &ipv6->sin6_addr,\n\t\t\t\tntohs(sport));\n\t} else {\n\t\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)&server->dstaddr;\n\n\t\tsport = ipv4->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t\tcifs_dbg(FYI, \"%s: connecting to %pI4:%d\\n\", __func__, &ipv4->sin_addr,\n\t\t\t\tntohs(sport));\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_server_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay)\n\t\ttcp_sock_set_nodelay(socket->sk);\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen,\n\t\t\t\t  server->noblockcnt ? O_NONBLOCK : 0);\n\t/*\n\t * When mounting SMB root file systems, we do not want to block in\n\t * connect. Otherwise bail out and then let cifs_reconnect() perform\n\t * reconnect failover - if possible.\n\t */\n\tif (server->noblockcnt && rc == -EINPROGRESS)\n\t\trc = 0;\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\ttrace_smb3_connect_err(server->hostname, server->conn_id, &server->dstaddr, rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\ttrace_smb3_connect_done(server->hostname, server->conn_id, &server->dstaddr);\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\t/*\n\t * If we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths?\n\t */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (ctx && ctx->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (ctx)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (!tcon->unix_ext) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/*\n\t\t * check for reconnect case in which we do not\n\t\t * want to change the mount behavior if we can avoid it\n\t\t */\n\t\tif (ctx == NULL) {\n\t\t\t/*\n\t\t\t * turn off POSIX ACL and PATHNAMES if not set\n\t\t\t * originally at mount time\n\t\t\t */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (ctx && ctx->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (ctx && ctx->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (ctx == NULL)\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}\n#endif /* CONFIG_CIFS_ALLOW_INSECURE_LEGACY */\n\nint cifs_setup_cifs_sb(struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb3_fs_context *ctx = cifs_sb->ctx;\n\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\tcifs_dbg(FYI, \"file mode: %04ho  dir mode: %04ho\\n\",\n\t\t ctx->file_mode, ctx->dir_mode);\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (ctx->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tcifs_sb->local_nls = load_nls_default();\n\t} else {\n\t\tcifs_sb->local_nls = load_nls(ctx->iocharset);\n\t\tif (cifs_sb->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t ctx->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\tctx->local_nls = cifs_sb->local_nls;\n\n\tsmb3_update_mnt_flags(cifs_sb);\n\n\tif (ctx->direct_io)\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\tif (ctx->cache_ro) {\n\t\tcifs_dbg(VFS, \"mounting share with read only caching. Ensure that the share will not be modified while in use.\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RO_CACHE;\n\t} else if (ctx->cache_rw) {\n\t\tcifs_dbg(VFS, \"mounting share in single client RW caching mode. Ensure that no other systems will be accessing the share.\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_RO_CACHE |\n\t\t\t\t\t    CIFS_MOUNT_RW_CACHE);\n\t}\n\n\tif ((ctx->cifs_acl) && (ctx->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n\n\tif (ctx->prepath) {\n\t\tcifs_sb->prepath = kstrdup(ctx->prepath, GFP_KERNEL);\n\t\tif (cifs_sb->prepath == NULL)\n\t\t\treturn -ENOMEM;\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\t}\n\n\treturn 0;\n}\n\n/* Release all succeed connections */\nstatic inline void mount_put_conns(struct mount_ctx *mnt_ctx)\n{\n\tint rc = 0;\n\n\tif (mnt_ctx->tcon)\n\t\tcifs_put_tcon(mnt_ctx->tcon);\n\telse if (mnt_ctx->ses)\n\t\tcifs_put_smb_ses(mnt_ctx->ses);\n\telse if (mnt_ctx->server)\n\t\tcifs_put_tcp_session(mnt_ctx->server, 0);\n\tmnt_ctx->cifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_POSIX_PATHS;\n\tfree_xid(mnt_ctx->xid);\n}\n\n/* Get connections for tcp, ses and tcon */\nstatic int mount_get_conns(struct mount_ctx *mnt_ctx)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = NULL;\n\tstruct cifs_ses *ses = NULL;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(ctx, NULL);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tserver = NULL;\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, ctx);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto out;\n\t}\n\n\tif ((ctx->persistent == true) && (!(ses->server->capabilities &\n\t\t\t\t\t    SMB2_GLOBAL_CAP_PERSISTENT_HANDLES))) {\n\t\tcifs_server_dbg(VFS, \"persistent handles not supported by server\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, ctx);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto out;\n\t}\n\n\t/* if new SMB3.11 POSIX extensions are supported do not remap / and \\ */\n\tif (tcon->posix_extensions)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_POSIX_PATHS;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/*\n\t\t * reset of caps checks mount to see if unix extensions disabled\n\t\t * for just this mount.\n\t\t */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, ctx);\n\t\tspin_lock(&tcon->ses->server->srv_lock);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\tspin_unlock(&tcon->ses->server->srv_lock);\n\t\t\trc = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&tcon->ses->server->srv_lock);\n\t} else\n#endif /* CONFIG_CIFS_ALLOW_INSECURE_LEGACY */\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->pipe && server->ops->qfs_tcon) {\n\t\tserver->ops->qfs_tcon(xid, tcon, cifs_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE) {\n\t\t\tif (tcon->fsDevInfo.DeviceCharacteristics &\n\t\t\t    cpu_to_le32(FILE_READ_ONLY_DEVICE))\n\t\t\t\tcifs_dbg(VFS, \"mounted to read only share\\n\");\n\t\t\telse if ((cifs_sb->mnt_cifs_flags &\n\t\t\t\t  CIFS_MOUNT_RW_CACHE) == 0)\n\t\t\t\tcifs_dbg(VFS, \"read only mount of RW share\\n\");\n\t\t\t/* no need to log a RW mount of a typical RW share */\n\t\t}\n\t}\n\n\t/*\n\t * Clamp the rsize/wsize mount arguments if they are too big for the server\n\t * and set the rsize/wsize to the negotiated values if not passed in by\n\t * the user on mount\n\t */\n\tif ((cifs_sb->ctx->wsize == 0) ||\n\t    (cifs_sb->ctx->wsize > server->ops->negotiate_wsize(tcon, ctx)))\n\t\tcifs_sb->ctx->wsize = server->ops->negotiate_wsize(tcon, ctx);\n\tif ((cifs_sb->ctx->rsize == 0) ||\n\t    (cifs_sb->ctx->rsize > server->ops->negotiate_rsize(tcon, ctx)))\n\t\tcifs_sb->ctx->rsize = server->ops->negotiate_rsize(tcon, ctx);\n\n\t/*\n\t * The cookie is initialized from volume info returned above.\n\t * Inside cifs_fscache_get_super_cookie it checks\n\t * that we do not get super cookie twice.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)\n\t\tcifs_fscache_get_super_cookie(tcon);\n\nout:\n\tmnt_ctx->server = server;\n\tmnt_ctx->ses = ses;\n\tmnt_ctx->tcon = tcon;\n\tmnt_ctx->xid = xid;\n\n\treturn rc;\n}\n\nstatic int mount_setup_tlink(struct cifs_sb_info *cifs_sb, struct cifs_ses *ses,\n\t\t\t     struct cifs_tcon *tcon)\n{\n\tstruct tcon_link *tlink;\n\n\t/* hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\tif (tlink == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\treturn 0;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* Get unique dfs connections */\nstatic int mount_get_dfs_conns(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\n\tmnt_ctx->fs_ctx->nosharesock = true;\n\trc = mount_get_conns(mnt_ctx);\n\tif (mnt_ctx->server) {\n\t\tcifs_dbg(FYI, \"%s: marking tcp session as a dfs connection\\n\", __func__);\n\t\tspin_lock(&mnt_ctx->server->srv_lock);\n\t\tmnt_ctx->server->is_dfs_conn = true;\n\t\tspin_unlock(&mnt_ctx->server->srv_lock);\n\t}\n\treturn rc;\n}\n\n/*\n * cifs_build_path_to_root returns full path to root when we do not have an\n * existing connection (tcon)\n */\nstatic char *\nbuild_unc_path_to_root(const struct smb3_fs_context *ctx,\n\t\t       const struct cifs_sb_info *cifs_sb, bool useppath)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = useppath && ctx->prepath ?\n\t\tstrlen(ctx->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(ctx->UNC, MAX_TREE_SIZE + 1);\n\n\tif (unc_len > MAX_TREE_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(full_path, ctx->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tmemcpy(pos + 1, ctx->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}\n\n/*\n * expand_dfs_referral - Update cifs_sb from dfs referral path\n *\n * cifs_sb->ctx->mount_options will be (re-)allocated to a string containing updated options for the\n * submount.  Otherwise it will be left untouched.\n */\nstatic int expand_dfs_referral(struct mount_ctx *mnt_ctx, const char *full_path,\n\t\t\t       struct dfs_info3_param *referral)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *fake_devname = NULL, *mdata = NULL;\n\n\tmdata = cifs_compose_mount_options(cifs_sb->ctx->mount_options, full_path + 1, referral,\n\t\t\t\t\t   &fake_devname);\n\tif (IS_ERR(mdata)) {\n\t\trc = PTR_ERR(mdata);\n\t\tmdata = NULL;\n\t} else {\n\t\t/*\n\t\t * We can not clear out the whole structure since we no longer have an explicit\n\t\t * function to parse a mount-string. Instead we need to clear out the individual\n\t\t * fields that are no longer valid.\n\t\t */\n\t\tkfree(ctx->prepath);\n\t\tctx->prepath = NULL;\n\t\trc = cifs_setup_volume_info(ctx, mdata, fake_devname);\n\t}\n\tkfree(fake_devname);\n\tkfree(cifs_sb->ctx->mount_options);\n\tcifs_sb->ctx->mount_options = mdata;\n\n\treturn rc;\n}\n#endif\n\n/* TODO: all callers to this are broken. We are not parsing mount_options here\n * we should pass a clone of the original context?\n */\nint\ncifs_setup_volume_info(struct smb3_fs_context *ctx, const char *mntopts, const char *devname)\n{\n\tint rc;\n\n\tif (devname) {\n\t\tcifs_dbg(FYI, \"%s: devname=%s\\n\", __func__, devname);\n\t\trc = smb3_parse_devname(devname, ctx);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to parse %s: %d\\n\", __func__, devname, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (mntopts) {\n\t\tchar *ip;\n\n\t\trc = smb3_parse_opt(mntopts, \"ip\", &ip);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to parse ip options: %d\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = cifs_convert_address((struct sockaddr *)&ctx->dstaddr, ip, strlen(ip));\n\t\tkfree(ip);\n\t\tif (!rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to convert ip address\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ctx->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t} else if (ctx->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", ctx->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncifs_are_all_path_components_accessible(struct TCP_Server_Info *server,\n\t\t\t\t\tunsigned int xid,\n\t\t\t\t\tstruct cifs_tcon *tcon,\n\t\t\t\t\tstruct cifs_sb_info *cifs_sb,\n\t\t\t\t\tchar *full_path,\n\t\t\t\t\tint added_treename)\n{\n\tint rc;\n\tchar *s;\n\tchar sep, tmp;\n\tint skip = added_treename ? 1 : 0;\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\ts = full_path;\n\n\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb, \"\");\n\twhile (rc == 0) {\n\t\t/* skip separators */\n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\t/* next separator */\n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\t\t/*\n\t\t * if the treename is added, we then have to skip the first\n\t\t * part within the separators\n\t\t */\n\t\tif (skip) {\n\t\t\tskip = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * temporarily null-terminate the path at the end of\n\t\t * the current component\n\t\t */\n\t\ttmp = *s;\n\t\t*s = 0;\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\t*s = tmp;\n\t}\n\treturn rc;\n}\n\n/*\n * Check if path is remote (i.e. a DFS share).\n *\n * Return -EREMOTE if it is, otherwise 0 or -errno.\n */\nstatic int is_path_remote(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct TCP_Server_Info *server = mnt_ctx->server;\n\tunsigned int xid = mnt_ctx->xid;\n\tstruct cifs_tcon *tcon = mnt_ctx->tcon;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *full_path;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tbool nodfs = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS;\n#endif\n\n\tif (!server->ops->is_path_accessible)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * cifs_build_path_to_root works only when we have a valid tcon\n\t */\n\tfull_path = cifs_build_path_to_root(ctx, cifs_sb, tcon,\n\t\t\t\t\t    tcon->Flags & SMB_SHARE_IS_IN_DFS);\n\tif (full_path == NULL)\n\t\treturn -ENOMEM;\n\n\tcifs_dbg(FYI, \"%s: full_path: %s\\n\", __func__, full_path);\n\n\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t     full_path);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tif (nodfs) {\n\t\tif (rc == -EREMOTE)\n\t\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* path *might* exist with non-ASCII characters in DFS root\n\t * try again with full path (only if nodfs is not set) */\n\tif (rc == -ENOENT && is_tcon_dfs(tcon))\n\t\trc = cifs_dfs_query_info_nonascii_quirk(xid, tcon, cifs_sb,\n\t\t\t\t\t\t\tfull_path);\n#endif\n\tif (rc != 0 && rc != -EREMOTE)\n\t\tgoto out;\n\n\tif (rc != -EREMOTE) {\n\t\trc = cifs_are_all_path_components_accessible(server, xid, tcon,\n\t\t\tcifs_sb, full_path, tcon->Flags & SMB_SHARE_IS_IN_DFS);\n\t\tif (rc != 0) {\n\t\t\tcifs_server_dbg(VFS, \"cannot query dirs between root and final path, enabling CIFS_MOUNT_USE_PREFIX_PATH\\n\");\n\t\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\t\t\trc = 0;\n\t\t}\n\t}\n\nout:\n\tkfree(full_path);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nstatic void set_root_ses(struct mount_ctx *mnt_ctx)\n{\n\tif (mnt_ctx->ses) {\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tmnt_ctx->ses->ses_count++;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tdfs_cache_add_refsrv_session(&mnt_ctx->mount_id, mnt_ctx->ses);\n\t}\n\tmnt_ctx->root_ses = mnt_ctx->ses;\n}\n\nstatic int is_dfs_mount(struct mount_ctx *mnt_ctx, bool *isdfs, struct dfs_cache_tgt_list *root_tl)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\n\t*isdfs = true;\n\n\trc = mount_get_conns(mnt_ctx);\n\t/*\n\t * If called with 'nodfs' mount option, then skip DFS resolving.  Otherwise unconditionally\n\t * try to get an DFS referral (even cached) to determine whether it is an DFS mount.\n\t *\n\t * Skip prefix path to provide support for DFS referrals from w2k8 servers which don't seem\n\t * to respond with PATH_NOT_COVERED to requests that include the prefix.\n\t */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS) ||\n\t    dfs_cache_find(mnt_ctx->xid, mnt_ctx->ses, cifs_sb->local_nls, cifs_remap(cifs_sb),\n\t\t\t   ctx->UNC + 1, NULL, root_tl)) {\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/* Check if it is fully accessible and then mount it */\n\t\trc = is_path_remote(mnt_ctx);\n\t\tif (!rc)\n\t\t\t*isdfs = false;\n\t\telse if (rc != -EREMOTE)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int connect_dfs_target(struct mount_ctx *mnt_ctx, const char *full_path,\n\t\t\t      const char *ref_path, struct dfs_cache_tgt_iterator *tit)\n{\n\tint rc;\n\tstruct dfs_info3_param ref = {};\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tchar *oldmnt = cifs_sb->ctx->mount_options;\n\n\tcifs_dbg(FYI, \"%s: full_path=%s ref_path=%s target=%s\\n\", __func__, full_path, ref_path,\n\t\t dfs_cache_get_tgt_name(tit));\n\n\trc = dfs_cache_get_tgt_referral(ref_path, tit, &ref);\n\tif (rc)\n\t\tgoto out;\n\n\trc = expand_dfs_referral(mnt_ctx, full_path, &ref);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Connect to new target only if we were redirected (e.g. mount options changed) */\n\tif (oldmnt != cifs_sb->ctx->mount_options) {\n\t\tmount_put_conns(mnt_ctx);\n\t\trc = mount_get_dfs_conns(mnt_ctx);\n\t}\n\tif (!rc) {\n\t\tif (cifs_is_referral_server(mnt_ctx->tcon, &ref))\n\t\t\tset_root_ses(mnt_ctx);\n\t\trc = dfs_cache_update_tgthint(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,\n\t\t\t\t\t      cifs_remap(cifs_sb), ref_path, tit);\n\t}\n\nout:\n\tfree_dfs_info_param(&ref);\n\treturn rc;\n}\n\nstatic int connect_dfs_root(struct mount_ctx *mnt_ctx, struct dfs_cache_tgt_list *root_tl)\n{\n\tint rc;\n\tchar *full_path;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct dfs_cache_tgt_iterator *tit;\n\n\t/* Put initial connections as they might be shared with other mounts.  We need unique dfs\n\t * connections per mount to properly failover, so mount_get_dfs_conns() must be used from\n\t * now on.\n\t */\n\tmount_put_conns(mnt_ctx);\n\tmount_get_dfs_conns(mnt_ctx);\n\tset_root_ses(mnt_ctx);\n\n\tfull_path = build_unc_path_to_root(ctx, cifs_sb, true);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\tmnt_ctx->origin_fullpath = dfs_cache_canonical_path(ctx->UNC, cifs_sb->local_nls,\n\t\t\t\t\t\t\t    cifs_remap(cifs_sb));\n\tif (IS_ERR(mnt_ctx->origin_fullpath)) {\n\t\trc = PTR_ERR(mnt_ctx->origin_fullpath);\n\t\tmnt_ctx->origin_fullpath = NULL;\n\t\tgoto out;\n\t}\n\n\t/* Try all dfs root targets */\n\tfor (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(root_tl);\n\t     tit; tit = dfs_cache_get_next_tgt(root_tl, tit)) {\n\t\trc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->origin_fullpath + 1, tit);\n\t\tif (!rc) {\n\t\t\tmnt_ctx->leaf_fullpath = kstrdup(mnt_ctx->origin_fullpath, GFP_KERNEL);\n\t\t\tif (!mnt_ctx->leaf_fullpath)\n\t\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(full_path);\n\treturn rc;\n}\n\nstatic int __follow_dfs_link(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *full_path;\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tstruct dfs_cache_tgt_iterator *tit;\n\n\tfull_path = build_unc_path_to_root(ctx, cifs_sb, true);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\tkfree(mnt_ctx->leaf_fullpath);\n\tmnt_ctx->leaf_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,\n\t\t\t\t\t\t\t  cifs_remap(cifs_sb));\n\tif (IS_ERR(mnt_ctx->leaf_fullpath)) {\n\t\trc = PTR_ERR(mnt_ctx->leaf_fullpath);\n\t\tmnt_ctx->leaf_fullpath = NULL;\n\t\tgoto out;\n\t}\n\n\t/* Get referral from dfs link */\n\trc = dfs_cache_find(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,\n\t\t\t    cifs_remap(cifs_sb), mnt_ctx->leaf_fullpath + 1, NULL, &tl);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Try all dfs link targets.  If an I/O fails from currently connected DFS target with an\n\t * error other than STATUS_PATH_NOT_COVERED (-EREMOTE), then retry it from other targets as\n\t * specified in MS-DFSC \"3.1.5.2 I/O Operation to Target Fails with an Error Other Than\n\t * STATUS_PATH_NOT_COVERED.\"\n\t */\n\tfor (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(&tl);\n\t     tit; tit = dfs_cache_get_next_tgt(&tl, tit)) {\n\t\trc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->leaf_fullpath + 1, tit);\n\t\tif (!rc) {\n\t\t\trc = is_path_remote(mnt_ctx);\n\t\t\tif (!rc || rc == -EREMOTE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(full_path);\n\tdfs_cache_free_tgts(&tl);\n\treturn rc;\n}\n\nstatic int follow_dfs_link(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *full_path;\n\tint num_links = 0;\n\n\tfull_path = build_unc_path_to_root(ctx, cifs_sb, true);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\tkfree(mnt_ctx->origin_fullpath);\n\tmnt_ctx->origin_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,\n\t\t\t\t\t\t\t    cifs_remap(cifs_sb));\n\tkfree(full_path);\n\n\tif (IS_ERR(mnt_ctx->origin_fullpath)) {\n\t\trc = PTR_ERR(mnt_ctx->origin_fullpath);\n\t\tmnt_ctx->origin_fullpath = NULL;\n\t\treturn rc;\n\t}\n\n\tdo {\n\t\trc = __follow_dfs_link(mnt_ctx);\n\t\tif (!rc || rc != -EREMOTE)\n\t\t\tbreak;\n\t} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);\n\n\treturn rc;\n}\n\n/* Set up DFS referral paths for failover */\nstatic void setup_server_referral_paths(struct mount_ctx *mnt_ctx)\n{\n\tstruct TCP_Server_Info *server = mnt_ctx->server;\n\n\tmutex_lock(&server->refpath_lock);\n\tserver->origin_fullpath = mnt_ctx->origin_fullpath;\n\tserver->leaf_fullpath = mnt_ctx->leaf_fullpath;\n\tserver->current_fullpath = mnt_ctx->leaf_fullpath;\n\tmutex_unlock(&server->refpath_lock);\n\tmnt_ctx->origin_fullpath = mnt_ctx->leaf_fullpath = NULL;\n}\n\nint cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\tint rc;\n\tstruct mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tbool isdfs;\n\n\trc = is_dfs_mount(&mnt_ctx, &isdfs, &tl);\n\tif (rc)\n\t\tgoto error;\n\tif (!isdfs)\n\t\tgoto out;\n\n\t/* proceed as DFS mount */\n\tuuid_gen(&mnt_ctx.mount_id);\n\trc = connect_dfs_root(&mnt_ctx, &tl);\n\tdfs_cache_free_tgts(&tl);\n\n\tif (rc)\n\t\tgoto error;\n\n\trc = is_path_remote(&mnt_ctx);\n\tif (rc)\n\t\trc = follow_dfs_link(&mnt_ctx);\n\tif (rc)\n\t\tgoto error;\n\n\tsetup_server_referral_paths(&mnt_ctx);\n\t/*\n\t * After reconnecting to a different server, unique ids won't match anymore, so we disable\n\t * serverino. This prevents dentry revalidation to think the dentry are stale (ESTALE).\n\t */\n\tcifs_autodisable_serverino(cifs_sb);\n\t/*\n\t * Force the use of prefix path to support failover on DFS paths that resolve to targets\n\t * that have different prefix paths.\n\t */\n\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\tkfree(cifs_sb->prepath);\n\tcifs_sb->prepath = ctx->prepath;\n\tctx->prepath = NULL;\n\tuuid_copy(&cifs_sb->dfs_mount_id, &mnt_ctx.mount_id);\n\nout:\n\tfree_xid(mnt_ctx.xid);\n\tcifs_try_adding_channels(cifs_sb, mnt_ctx.ses);\n\treturn mount_setup_tlink(cifs_sb, mnt_ctx.ses, mnt_ctx.tcon);\n\nerror:\n\tdfs_cache_put_refsrv_sessions(&mnt_ctx.mount_id);\n\tkfree(mnt_ctx.origin_fullpath);\n\tkfree(mnt_ctx.leaf_fullpath);\n\tmount_put_conns(&mnt_ctx);\n\treturn rc;\n}\n#else\nint cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\tint rc = 0;\n\tstruct mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };\n\n\trc = mount_get_conns(&mnt_ctx);\n\tif (rc)\n\t\tgoto error;\n\n\tif (mnt_ctx.tcon) {\n\t\trc = is_path_remote(&mnt_ctx);\n\t\tif (rc == -EREMOTE)\n\t\t\trc = -EOPNOTSUPP;\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\tfree_xid(mnt_ctx.xid);\n\treturn mount_setup_tlink(cifs_sb, mnt_ctx.ses, mnt_ctx.tcon);\n\nerror:\n\tmount_put_conns(&mnt_ctx);\n\treturn rc;\n}\n#endif\n\n/*\n * Issue a TREE_CONNECT request.\n */\nint\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\n\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t*bcc_ptr = 0; /* password is null byte */\n\tbcc_ptr++;              /* skip password */\n\t/* already aligned so no need to do it below */\n\n\tif (ses->server->sign)\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tbe32_add_cpu(&pSMB->hdr.smb_buf_length, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif (rc == 0) {\n\t\tbool is_unicode;\n\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = true;\n\t\t\t\ttcon->pipe = true;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrscpy(tcon->tree_name, tree, sizeof(tcon->tree_name));\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nstatic void delayed_free(struct rcu_head *p)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(p, struct cifs_sb_info, rcu);\n\n\tunload_nls(cifs_sb->local_nls);\n\tsmb3_cleanup_fs_context(cifs_sb->ctx);\n\tkfree(cifs_sb);\n}\n\nvoid\ncifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tkfree(cifs_sb->prepath);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tdfs_cache_put_refsrv_sessions(&cifs_sb->dfs_mount_id);\n#endif\n\tcall_rcu(&cifs_sb->rcu, delayed_free);\n}\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses,\n\t\t\tstruct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tspin_lock(&server->srv_lock);\n\tif (!server->ops->need_neg(server) ||\n\t    server->tcpStatus != CifsNeedNegotiate) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn 0;\n\t}\n\tserver->tcpStatus = CifsInNegotiate;\n\tspin_unlock(&server->srv_lock);\n\n\trc = server->ops->negotiate(xid, ses, server);\n\tif (rc == 0) {\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsInNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&server->srv_lock);\n\t} else {\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsInNegotiate)\n\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\tspin_unlock(&server->srv_lock);\n\t}\n\n\treturn rc;\n}\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct TCP_Server_Info *server,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tbool is_binding = false;\n\n\tspin_lock(&ses->ses_lock);\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tscnprintf(ses->ip_addr, sizeof(ses->ip_addr), \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tscnprintf(ses->ip_addr, sizeof(ses->ip_addr), \"%pI4\", &addr->sin_addr);\n\n\tif (ses->ses_status != SES_GOOD &&\n\t    ses->ses_status != SES_NEW &&\n\t    ses->ses_status != SES_NEED_RECON) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn 0;\n\t}\n\n\t/* only send once per connect */\n\tspin_lock(&ses->chan_lock);\n\tif (CIFS_ALL_CHANS_GOOD(ses) ||\n\t    cifs_chan_in_reconnect(ses, server)) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn 0;\n\t}\n\tis_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);\n\tcifs_chan_set_in_reconnect(ses, server);\n\tspin_unlock(&ses->chan_lock);\n\n\tif (!is_binding)\n\t\tses->ses_status = SES_IN_SETUP;\n\tspin_unlock(&ses->ses_lock);\n\n\tif (!is_binding) {\n\t\tses->capabilities = server->capabilities;\n\t\tif (!linuxExtEnabled)\n\t\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\t\tif (ses->auth_key.response) {\n\t\t\tcifs_dbg(FYI, \"Free previous auth_key.response = %p\\n\",\n\t\t\t\t ses->auth_key.response);\n\t\t\tkfree_sensitive(ses->auth_key.response);\n\t\t\tses->auth_key.response = NULL;\n\t\t\tses->auth_key.len = 0;\n\t\t}\n\t}\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, server, nls_info);\n\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_IN_SETUP)\n\t\t\tses->ses_status = SES_NEED_RECON;\n\t\tspin_lock(&ses->chan_lock);\n\t\tcifs_chan_clear_in_reconnect(ses, server);\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t} else {\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_IN_SETUP)\n\t\t\tses->ses_status = SES_GOOD;\n\t\tspin_lock(&ses->chan_lock);\n\t\tcifs_chan_clear_in_reconnect(ses, server);\n\t\tcifs_chan_clear_need_reconnect(ses, server);\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_set_vol_auth(struct smb3_fs_context *ctx, struct cifs_ses *ses)\n{\n\tctx->sectype = ses->sectype;\n\n\t/* krb5 is special, since we don't need username or pw */\n\tif (ctx->sectype == Kerberos)\n\t\treturn 0;\n\n\treturn cifs_set_cifscreds(ctx, ses);\n}\n\nstatic struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb3_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->local_nls = cifs_sb->local_nls;\n\tctx->linux_uid = fsuid;\n\tctx->cred_uid = fsuid;\n\tctx->UNC = master_tcon->tree_name;\n\tctx->retry = master_tcon->retry;\n\tctx->nocase = master_tcon->nocase;\n\tctx->nohandlecache = master_tcon->nohandlecache;\n\tctx->local_lease = master_tcon->local_lease;\n\tctx->no_lease = master_tcon->no_lease;\n\tctx->resilient = master_tcon->use_resilient;\n\tctx->persistent = master_tcon->use_persistent;\n\tctx->handle_timeout = master_tcon->handle_timeout;\n\tctx->no_linux_ext = !master_tcon->unix_ext;\n\tctx->linux_ext = master_tcon->posix_extensions;\n\tctx->sectype = master_tcon->ses->sectype;\n\tctx->sign = master_tcon->ses->sign;\n\tctx->seal = master_tcon->seal;\n\tctx->witness = master_tcon->use_witness;\n\n\trc = cifs_set_vol_auth(ctx, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, ctx);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server, 0);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, ctx);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, ctx);\n#endif /* CONFIG_CIFS_ALLOW_INSECURE_LEGACY */\n\nout:\n\tkfree(ctx->username);\n\tkfree_sensitive(ctx->password);\n\tkfree(ctx);\n\n\treturn tcon;\n}\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}\n\n/* find and return a tlink with given uid */\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}\n\n/* insert a tcon_link into the tree */\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}\n\n/*\n * Find or construct an appropriate tcon given a cifs_sb and the fsuid of the\n * current task.\n *\n * If the superblock doesn't refer to a multiuser mount, then just return\n * the master tcon for the mount.\n *\n * First, search the rbtree for an existing tcon for this fsuid. If one\n * exists, then check to see if it's pending construction. If it is then wait\n * for construction to complete. Once it's no longer pending, check to see if\n * it failed and either return an error or retry construction, depending on\n * the timeout.\n *\n * If one doesn't exist then insert a new tcon_link struct into the tree and\n * try to construct a new one.\n */\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}\n\n/*\n * periodic workqueue job that scans tcon_tree for a superblock and closes\n * out tcons.\n */\nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* Update dfs referral path of superblock */\nstatic int update_server_fullpath(struct TCP_Server_Info *server, struct cifs_sb_info *cifs_sb,\n\t\t\t\t  const char *target)\n{\n\tint rc = 0;\n\tsize_t len = strlen(target);\n\tchar *refpath, *npath;\n\n\tif (unlikely(len < 2 || *target != '\\\\'))\n\t\treturn -EINVAL;\n\n\tif (target[1] == '\\\\') {\n\t\tlen += 1;\n\t\trefpath = kmalloc(len, GFP_KERNEL);\n\t\tif (!refpath)\n\t\t\treturn -ENOMEM;\n\n\t\tscnprintf(refpath, len, \"%s\", target);\n\t} else {\n\t\tlen += sizeof(\"\\\\\");\n\t\trefpath = kmalloc(len, GFP_KERNEL);\n\t\tif (!refpath)\n\t\t\treturn -ENOMEM;\n\n\t\tscnprintf(refpath, len, \"\\\\%s\", target);\n\t}\n\n\tnpath = dfs_cache_canonical_path(refpath, cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tkfree(refpath);\n\n\tif (IS_ERR(npath)) {\n\t\trc = PTR_ERR(npath);\n\t} else {\n\t\tmutex_lock(&server->refpath_lock);\n\t\tkfree(server->leaf_fullpath);\n\t\tserver->leaf_fullpath = npath;\n\t\tmutex_unlock(&server->refpath_lock);\n\t\tserver->current_fullpath = server->leaf_fullpath;\n\t}\n\treturn rc;\n}\n\nstatic int target_share_matches_server(struct TCP_Server_Info *server, const char *tcp_host,\n\t\t\t\t       size_t tcp_host_len, char *share, bool *target_match)\n{\n\tint rc = 0;\n\tconst char *dfs_host;\n\tsize_t dfs_host_len;\n\n\t*target_match = true;\n\textract_unc_hostname(share, &dfs_host, &dfs_host_len);\n\n\t/* Check if hostnames or addresses match */\n\tif (dfs_host_len != tcp_host_len || strncasecmp(dfs_host, tcp_host, dfs_host_len) != 0) {\n\t\tcifs_dbg(FYI, \"%s: %.*s doesn't match %.*s\\n\", __func__, (int)dfs_host_len,\n\t\t\t dfs_host, (int)tcp_host_len, tcp_host);\n\t\trc = match_target_ip(server, dfs_host, dfs_host_len, target_match);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: failed to match target ip: %d\\n\", __func__, rc);\n\t}\n\treturn rc;\n}\n\nstatic int __tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t     struct cifs_sb_info *cifs_sb, char *tree, bool islink,\n\t\t\t\t     struct dfs_cache_tgt_list *tl)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tconst struct smb_version_operations *ops = server->ops;\n\tstruct cifs_tcon *ipc = tcon->ses->tcon_ipc;\n\tchar *share = NULL, *prefix = NULL;\n\tconst char *tcp_host;\n\tsize_t tcp_host_len;\n\tstruct dfs_cache_tgt_iterator *tit;\n\tbool target_match;\n\n\textract_unc_hostname(server->hostname, &tcp_host, &tcp_host_len);\n\n\ttit = dfs_cache_get_tgt_iterator(tl);\n\tif (!tit) {\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Try to tree connect to all dfs targets */\n\tfor (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {\n\t\tconst char *target = dfs_cache_get_tgt_name(tit);\n\t\tstruct dfs_cache_tgt_list ntl = DFS_CACHE_TGT_LIST_INIT(ntl);\n\n\t\tkfree(share);\n\t\tkfree(prefix);\n\t\tshare = prefix = NULL;\n\n\t\t/* Check if share matches with tcp ses */\n\t\trc = dfs_cache_get_tgt_share(server->current_fullpath + 1, tit, &share, &prefix);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to parse target share: %d\\n\", __func__, rc);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = target_share_matches_server(server, tcp_host, tcp_host_len, share,\n\t\t\t\t\t\t &target_match);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (!target_match) {\n\t\t\trc = -EHOSTUNREACH;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ipc->need_reconnect) {\n\t\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\t\t\trc = ops->tree_connect(xid, ipc->ses, tree, ipc, cifs_sb->local_nls);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\%s\", share);\n\t\tif (!islink) {\n\t\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If no dfs referrals were returned from link target, then just do a TREE_CONNECT\n\t\t * to it.  Otherwise, cache the dfs referral and then mark current tcp ses for\n\t\t * reconnect so either the demultiplex thread or the echo worker will reconnect to\n\t\t * newly resolved target.\n\t\t */\n\t\tif (dfs_cache_find(xid, tcon->ses, cifs_sb->local_nls, cifs_remap(cifs_sb), target,\n\t\t\t\t   NULL, &ntl)) {\n\t\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = dfs_cache_noreq_update_tgthint(server->current_fullpath + 1, tit);\n\t\t\tif (!rc)\n\t\t\t\trc = cifs_update_super_prepath(cifs_sb, prefix);\n\t\t} else {\n\t\t\t/* Target is another dfs share */\n\t\t\trc = update_server_fullpath(server, cifs_sb, target);\n\t\t\tdfs_cache_free_tgts(tl);\n\n\t\t\tif (!rc) {\n\t\t\t\trc = -EREMOTE;\n\t\t\t\tlist_replace_init(&ntl.tl_list, &tl->tl_list);\n\t\t\t} else\n\t\t\t\tdfs_cache_free_tgts(&ntl);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tkfree(share);\n\tkfree(prefix);\n\n\treturn rc;\n}\n\nstatic int tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t   struct cifs_sb_info *cifs_sb, char *tree, bool islink,\n\t\t\t\t   struct dfs_cache_tgt_list *tl)\n{\n\tint rc;\n\tint num_links = 0;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tdo {\n\t\trc = __tree_connect_dfs_target(xid, tcon, cifs_sb, tree, islink, tl);\n\t\tif (!rc || rc != -EREMOTE)\n\t\t\tbreak;\n\t} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);\n\t/*\n\t * If we couldn't tree connect to any targets from last referral path, then retry from\n\t * original referral path.\n\t */\n\tif (rc && server->current_fullpath != server->origin_fullpath) {\n\t\tserver->current_fullpath = server->origin_fullpath;\n\t\tcifs_signal_cifsd_for_reconnect(server, true);\n\t}\n\n\tdfs_cache_free_tgts(tl);\n\treturn rc;\n}\n\nint cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tconst struct smb_version_operations *ops = server->ops;\n\tstruct super_block *sb = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tchar *tree;\n\tstruct dfs_info3_param ref = {0};\n\n\t/* only send once per connect */\n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->ses->ses_status != SES_GOOD ||\n\t    (tcon->status != TID_NEW &&\n\t    tcon->status != TID_NEED_TCON)) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn 0;\n\t}\n\ttcon->status = TID_IN_TCON;\n\tspin_unlock(&tcon->tc_lock);\n\n\ttree = kzalloc(MAX_TREE_SIZE, GFP_KERNEL);\n\tif (!tree) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->ipc) {\n\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, nlsc);\n\t\tgoto out;\n\t}\n\n\tsb = cifs_get_tcp_super(server);\n\tif (IS_ERR(sb)) {\n\t\trc = PTR_ERR(sb);\n\t\tcifs_dbg(VFS, \"%s: could not find superblock: %d\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\n\tcifs_sb = CIFS_SB(sb);\n\n\t/* If it is not dfs or there was no cached dfs referral, then reconnect to same share */\n\tif (!server->current_fullpath ||\n\t    dfs_cache_noreq_find(server->current_fullpath + 1, &ref, &tl)) {\n\t\trc = ops->tree_connect(xid, tcon->ses, tcon->tree_name, tcon, cifs_sb->local_nls);\n\t\tgoto out;\n\t}\n\n\trc = tree_connect_dfs_target(xid, tcon, cifs_sb, tree, ref.server_type == DFS_TYPE_LINK,\n\t\t\t\t     &tl);\n\tfree_dfs_info_param(&ref);\n\nout:\n\tkfree(tree);\n\tcifs_put_tcp_super(sb);\n\n\tif (rc) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_NEED_TCON;\n\t\tspin_unlock(&tcon->tc_lock);\n\t} else {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_GOOD;\n\t\tspin_unlock(&tcon->tc_lock);\n\t\ttcon->need_reconnect = false;\n\t}\n\n\treturn rc;\n}\n#else\nint cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)\n{\n\tint rc;\n\tconst struct smb_version_operations *ops = tcon->ses->server->ops;\n\n\t/* only send once per connect */\n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->ses->ses_status != SES_GOOD ||\n\t    (tcon->status != TID_NEW &&\n\t    tcon->status != TID_NEED_TCON)) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn 0;\n\t}\n\ttcon->status = TID_IN_TCON;\n\tspin_unlock(&tcon->tc_lock);\n\n\trc = ops->tree_connect(xid, tcon->ses, tcon->tree_name, tcon, nlsc);\n\tif (rc) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_NEED_TCON;\n\t\tspin_unlock(&tcon->tc_lock);\n\t} else {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_GOOD;\n\t\ttcon->need_reconnect = false;\n\t\tspin_unlock(&tcon->tc_lock);\n\t}\n\n\treturn rc;\n}\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: LGPL-2.1\n/*\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2011\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <linux/uuid.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <linux/module.h>\n#include <keys/user-type.h>\n#include <net/ipv6.h>\n#include <linux/parser.h>\n#include <linux/bvec.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fscache.h\"\n#include \"smb2proto.h\"\n#include \"smbdirect.h\"\n#include \"dns_resolve.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n#include \"fs_context.h\"\n#include \"cifs_swn.h\"\n\nextern mempool_t *cifs_req_poolp;\nextern bool disable_legacy_dialects;\n\n/* FIXME: should these be tunable? */\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\n/* Drop the connection to not overload the server */\n#define NUM_STATUS_IO_TIMEOUT   5\n\nstruct mount_ctx {\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct smb3_fs_context *fs_ctx;\n\tunsigned int xid;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct cifs_ses *root_ses;\n\tuuid_t mount_id;\n\tchar *origin_fullpath, *leaf_fullpath;\n#endif\n};\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\n/*\n * Resolve hostname and set ip addr in tcp ses. Useful for hostnames that may\n * get their ip addresses changed at some point.\n *\n * This should be called with server->srv_mutex held.\n */\nstatic int reconn_set_ipaddr_from_hostname(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tint len;\n\tchar *unc, *ipaddr = NULL;\n\ttime64_t expiry, now;\n\tunsigned long ttl = SMB_DNS_RESOLVE_INTERVAL_DEFAULT;\n\n\tif (!server->hostname)\n\t\treturn -EINVAL;\n\n\t/* if server hostname isn't populated, there's nothing to do here */\n\tif (server->hostname[0] == '\\0')\n\t\treturn 0;\n\n\tlen = strlen(server->hostname) + 3;\n\n\tunc = kmalloc(len, GFP_KERNEL);\n\tif (!unc) {\n\t\tcifs_dbg(FYI, \"%s: failed to create UNC path\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tscnprintf(unc, len, \"\\\\\\\\%s\", server->hostname);\n\n\trc = dns_resolve_server_name_to_ip(unc, &ipaddr, &expiry);\n\tkfree(unc);\n\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, server->hostname, rc);\n\t\tgoto requeue_resolve;\n\t}\n\n\tspin_lock(&server->srv_lock);\n\trc = cifs_convert_address((struct sockaddr *)&server->dstaddr, ipaddr,\n\t\t\t\t  strlen(ipaddr));\n\tspin_unlock(&server->srv_lock);\n\tkfree(ipaddr);\n\n\t/* rc == 1 means success here */\n\tif (rc) {\n\t\tnow = ktime_get_real_seconds();\n\t\tif (expiry && expiry > now)\n\t\t\t/*\n\t\t\t * To make sure we don't use the cached entry, retry 1s\n\t\t\t * after expiry.\n\t\t\t */\n\t\t\tttl = max_t(unsigned long, expiry - now, SMB_DNS_RESOLVE_INTERVAL_MIN) + 1;\n\t}\n\trc = !rc ? -1 : 0;\n\nrequeue_resolve:\n\tcifs_dbg(FYI, \"%s: next dns resolution scheduled for %lu seconds in the future\\n\",\n\t\t __func__, ttl);\n\tmod_delayed_work(cifsiod_wq, &server->resolve, (ttl * HZ));\n\n\treturn rc;\n}\n\nstatic void smb2_query_server_interfaces(struct work_struct *work)\n{\n\tint rc;\n\tstruct cifs_tcon *tcon = container_of(work,\n\t\t\t\t\tstruct cifs_tcon,\n\t\t\t\t\tquery_interfaces.work);\n\n\t/*\n\t * query server network interfaces, in case they change\n\t */\n\trc = SMB3_request_interfaces(0, tcon, false);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: failed to query server interfaces: %d\\n\",\n\t\t\t\t__func__, rc);\n\t}\n\n\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n}\n\nstatic void cifs_resolve_server(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, resolve.work);\n\n\tcifs_server_lock(server);\n\n\t/*\n\t * Resolve the hostname again to make sure that IP address is up-to-date.\n\t */\n\trc = reconn_set_ipaddr_from_hostname(server);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: failed to resolve hostname: %d\\n\",\n\t\t\t\t__func__, rc);\n\t}\n\n\tcifs_server_unlock(server);\n}\n\n/*\n * Update the tcpStatus for the server.\n * This is used to signal the cifsd thread to call cifs_reconnect\n * ONLY cifsd thread should call cifs_reconnect. For any other\n * thread, use this function\n *\n * @server: the tcp ses for which reconnect is needed\n * @all_channels: if this needs to be done for all channels\n */\nvoid\ncifs_signal_cifsd_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\tbool all_channels)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tint i;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\tspin_lock(&pserver->srv_lock);\n\tif (!all_channels) {\n\t\tpserver->tcpStatus = CifsNeedReconnect;\n\t\tspin_unlock(&pserver->srv_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&pserver->srv_lock);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tspin_lock(&ses->chan_lock);\n\t\tfor (i = 0; i < ses->chan_count; i++) {\n\t\t\tspin_lock(&ses->chans[i].server->srv_lock);\n\t\t\tses->chans[i].server->tcpStatus = CifsNeedReconnect;\n\t\t\tspin_unlock(&ses->chans[i].server->srv_lock);\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n}\n\n/*\n * Mark all sessions and tcons for reconnect.\n * IMPORTANT: make sure that this gets called only from\n * cifsd thread. For any other thread, use\n * cifs_signal_cifsd_for_reconnect\n *\n * @server: the tcp ses for which reconnect is needed\n * @server needs to be previously set to CifsNeedReconnect.\n * @mark_smb_session: whether even sessions need to be marked\n */\nvoid\ncifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\t      bool mark_smb_session)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses, *nses;\n\tstruct cifs_tcon *tcon;\n\n\t/*\n\t * before reconnecting the tcp session, mark the smb session (uid) and the tid bad so they\n\t * are not used until reconnected.\n\t */\n\tcifs_dbg(FYI, \"%s: marking necessary sessions and tcons for reconnect\\n\", __func__);\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry_safe(ses, nses, &pserver->smb_ses_list, smb_ses_list) {\n\t\t/* check if iface is still active */\n\t\tif (!cifs_chan_is_iface_active(ses, server))\n\t\t\tcifs_chan_update_iface(ses, server);\n\n\t\tspin_lock(&ses->chan_lock);\n\t\tif (!mark_smb_session && cifs_chan_needs_reconnect(ses, server))\n\t\t\tgoto next_session;\n\n\t\tif (mark_smb_session)\n\t\t\tCIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);\n\t\telse\n\t\t\tcifs_chan_set_need_reconnect(ses, server);\n\n\t\t/* If all channels need reconnect, then tcon needs reconnect */\n\t\tif (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses))\n\t\t\tgoto next_session;\n\n\t\tses->ses_status = SES_NEED_RECON;\n\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\ttcon->need_reconnect = true;\n\t\t\ttcon->status = TID_NEED_RECON;\n\t\t}\n\t\tif (ses->tcon_ipc)\n\t\t\tses->tcon_ipc->need_reconnect = true;\n\nnext_session:\n\t\tspin_unlock(&ses->chan_lock);\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n}\n\nstatic void\ncifs_abort_connection(struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *mid, *nmid;\n\tstruct list_head retry_list;\n\n\tserver->maxBuf = 0;\n\tserver->max_read = 0;\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tcifs_server_lock(server);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\", server->ssocket->state,\n\t\t\t server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\", server->ssocket->state,\n\t\t\t server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&server->mid_lock);\n\tlist_for_each_entry_safe(mid, nmid, &server->pending_mid_q, qhead) {\n\t\tkref_get(&mid->refcount);\n\t\tif (mid->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid->qhead, &retry_list);\n\t\tmid->mid_flags |= MID_DELETED;\n\t}\n\tspin_unlock(&server->mid_lock);\n\tcifs_server_unlock(server);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_entry_safe(mid, nmid, &retry_list, qhead) {\n\t\tlist_del_init(&mid->qhead);\n\t\tmid->callback(mid);\n\t\trelease_mid(mid);\n\t}\n\n\tif (cifs_rdma_enabled(server)) {\n\t\tcifs_server_lock(server);\n\t\tsmbd_destroy(server);\n\t\tcifs_server_unlock(server);\n\t}\n}\n\nstatic bool cifs_tcp_ses_needs_reconnect(struct TCP_Server_Info *server, int num_targets)\n{\n\tspin_lock(&server->srv_lock);\n\tserver->nr_targets = num_targets;\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally next time through the loop */\n\t\tspin_unlock(&server->srv_lock);\n\t\twake_up(&server->response_q);\n\t\treturn false;\n\t}\n\n\tcifs_dbg(FYI, \"Mark tcp session as need reconnect\\n\");\n\ttrace_smb3_reconnect(server->CurrentMid, server->conn_id,\n\t\t\t     server->hostname);\n\tserver->tcpStatus = CifsNeedReconnect;\n\n\tspin_unlock(&server->srv_lock);\n\treturn true;\n}\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n *\n * if mark_smb_session is passed as true, unconditionally mark\n * the smb session (and tcon) for reconnect as well. This value\n * doesn't really matter for non-multichannel scenario.\n *\n */\nstatic int __cifs_reconnect(struct TCP_Server_Info *server,\n\t\t\t    bool mark_smb_session)\n{\n\tint rc = 0;\n\n\tif (!cifs_tcp_ses_needs_reconnect(server, 1))\n\t\treturn 0;\n\n\tcifs_mark_tcp_ses_conns_for_reconnect(server, mark_smb_session);\n\n\tcifs_abort_connection(server);\n\n\tdo {\n\t\ttry_to_freeze();\n\t\tcifs_server_lock(server);\n\n\t\tif (!cifs_swn_set_server_dstaddr(server)) {\n\t\t\t/* resolve the hostname again to make sure that IP address is up-to-date */\n\t\t\trc = reconn_set_ipaddr_from_hostname(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconn_set_ipaddr_from_hostname: rc=%d\\n\", __func__, rc);\n\t\t}\n\n\t\tif (cifs_rdma_enabled(server))\n\t\t\trc = smbd_reconnect(server);\n\t\telse\n\t\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_server_unlock(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconnect error %d\\n\", __func__, rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tset_credits(server, 1);\n\t\t\tspin_lock(&server->srv_lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcifs_swn_reset_server_dstaddr(server);\n\t\t\tcifs_server_unlock(server);\n\t\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t\t}\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\tmod_delayed_work(cifsiod_wq, &server->echo, 0);\n\tspin_unlock(&server->srv_lock);\n\n\twake_up(&server->response_q);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nstatic int __reconnect_target_unlocked(struct TCP_Server_Info *server, const char *target)\n{\n\tint rc;\n\tchar *hostname;\n\n\tif (!cifs_swn_set_server_dstaddr(server)) {\n\t\tif (server->hostname != target) {\n\t\t\thostname = extract_hostname(target);\n\t\t\tif (!IS_ERR(hostname)) {\n\t\t\t\tkfree(server->hostname);\n\t\t\t\tserver->hostname = hostname;\n\t\t\t} else {\n\t\t\t\tcifs_dbg(FYI, \"%s: couldn't extract hostname or address from dfs target: %ld\\n\",\n\t\t\t\t\t __func__, PTR_ERR(hostname));\n\t\t\t\tcifs_dbg(FYI, \"%s: default to last target server: %s\\n\", __func__,\n\t\t\t\t\t server->hostname);\n\t\t\t}\n\t\t}\n\t\t/* resolve the hostname again to make sure that IP address is up-to-date. */\n\t\trc = reconn_set_ipaddr_from_hostname(server);\n\t\tcifs_dbg(FYI, \"%s: reconn_set_ipaddr_from_hostname: rc=%d\\n\", __func__, rc);\n\t}\n\t/* Reconnect the socket */\n\tif (cifs_rdma_enabled(server))\n\t\trc = smbd_reconnect(server);\n\telse\n\t\trc = generic_ip_connect(server);\n\n\treturn rc;\n}\n\nstatic int reconnect_target_unlocked(struct TCP_Server_Info *server, struct dfs_cache_tgt_list *tl,\n\t\t\t\t     struct dfs_cache_tgt_iterator **target_hint)\n{\n\tint rc;\n\tstruct dfs_cache_tgt_iterator *tit;\n\n\t*target_hint = NULL;\n\n\t/* If dfs target list is empty, then reconnect to last server */\n\ttit = dfs_cache_get_tgt_iterator(tl);\n\tif (!tit)\n\t\treturn __reconnect_target_unlocked(server, server->hostname);\n\n\t/* Otherwise, try every dfs target in @tl */\n\tfor (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {\n\t\trc = __reconnect_target_unlocked(server, dfs_cache_get_tgt_name(tit));\n\t\tif (!rc) {\n\t\t\t*target_hint = tit;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int reconnect_dfs_server(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tconst char *refpath = server->current_fullpath + 1;\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tstruct dfs_cache_tgt_iterator *target_hint = NULL;\n\tint num_targets = 0;\n\n\t/*\n\t * Determine the number of dfs targets the referral path in @cifs_sb resolves to.\n\t *\n\t * smb2_reconnect() needs to know how long it should wait based upon the number of dfs\n\t * targets (server->nr_targets).  It's also possible that the cached referral was cleared\n\t * through /proc/fs/cifs/dfscache or the target list is empty due to server settings after\n\t * refreshing the referral, so, in this case, default it to 1.\n\t */\n\tif (!dfs_cache_noreq_find(refpath, NULL, &tl))\n\t\tnum_targets = dfs_cache_get_nr_tgts(&tl);\n\tif (!num_targets)\n\t\tnum_targets = 1;\n\n\tif (!cifs_tcp_ses_needs_reconnect(server, num_targets))\n\t\treturn 0;\n\n\t/*\n\t * Unconditionally mark all sessions & tcons for reconnect as we might be connecting to a\n\t * different server or share during failover.  It could be improved by adding some logic to\n\t * only do that in case it connects to a different server or share, though.\n\t */\n\tcifs_mark_tcp_ses_conns_for_reconnect(server, true);\n\n\tcifs_abort_connection(server);\n\n\tdo {\n\t\ttry_to_freeze();\n\t\tcifs_server_lock(server);\n\n\t\trc = reconnect_target_unlocked(server, &tl, &target_hint);\n\t\tif (rc) {\n\t\t\t/* Failed to reconnect socket */\n\t\t\tcifs_server_unlock(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconnect error %d\\n\", __func__, rc);\n\t\t\tmsleep(3000);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Socket was created.  Update tcp session status to CifsNeedNegotiate so that a\n\t\t * process waiting for reconnect will know it needs to re-establish session and tcon\n\t\t * through the reconnected target server.\n\t\t */\n\t\tatomic_inc(&tcpSesReconnectCount);\n\t\tset_credits(server, 1);\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\tspin_unlock(&server->srv_lock);\n\t\tcifs_swn_reset_server_dstaddr(server);\n\t\tcifs_server_unlock(server);\n\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\tif (target_hint)\n\t\tdfs_cache_noreq_update_tgthint(refpath, target_hint);\n\n\tdfs_cache_free_tgts(&tl);\n\n\t/* Need to set up echo worker again once connection has been established */\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\tmod_delayed_work(cifsiod_wq, &server->echo, 0);\n\tspin_unlock(&server->srv_lock);\n\n\twake_up(&server->response_q);\n\treturn rc;\n}\n\nint cifs_reconnect(struct TCP_Server_Info *server, bool mark_smb_session)\n{\n\t/* If tcp session is not an dfs connection, then reconnect to last target server */\n\tspin_lock(&server->srv_lock);\n\tif (!server->is_dfs_conn) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn __cifs_reconnect(server, mark_smb_session);\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tmutex_lock(&server->refpath_lock);\n\tif (!server->origin_fullpath || !server->leaf_fullpath) {\n\t\tmutex_unlock(&server->refpath_lock);\n\t\treturn __cifs_reconnect(server, mark_smb_session);\n\t}\n\tmutex_unlock(&server->refpath_lock);\n\n\treturn reconnect_dfs_server(server);\n}\n#else\nint cifs_reconnect(struct TCP_Server_Info *server, bool mark_smb_session)\n{\n\treturn __cifs_reconnect(server, mark_smb_session);\n}\n#endif\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo if it is disabled.\n\t * Also, no need to ping if we got a response recently.\n\t */\n\n\tif (server->tcpStatus == CifsNeedReconnect ||\n\t    server->tcpStatus == CifsExiting ||\n\t    server->tcpStatus == CifsNew ||\n\t    (server->ops->can_echo && !server->ops->can_echo(server)) ||\n\t    time_before(jiffies, server->lstrp + server->echo_interval - HZ))\n\t\tgoto requeue_echo;\n\n\trc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Unable to send echo request to server: %s\\n\",\n\t\t\t server->hostname);\n\n\t/* Check witness registrations */\n\tcifs_swn_check();\n\nrequeue_echo:\n\tqueue_delayed_work(cifsiod_wq, &server->echo, server->echo_interval);\n}\n\nstatic bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_server_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_server_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}\n\nstatic bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 3 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tspin_lock(&server->srv_lock);\n\tif ((server->tcpStatus == CifsGood ||\n\t    server->tcpStatus == CifsNeedNegotiate) &&\n\t    (!server->ops->can_echo || server->ops->can_echo(server)) &&\n\t    time_after(jiffies, server->lstrp + 3 * server->echo_interval)) {\n\t\tspin_unlock(&server->srv_lock);\n\t\tcifs_server_dbg(VFS, \"has not responded in %lu seconds. Reconnecting...\\n\",\n\t\t\t (3 * server->echo_interval) / HZ);\n\t\tcifs_reconnect(server, false);\n\t\treturn true;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\treturn false;\n}\n\nstatic inline bool\nzero_credits(struct TCP_Server_Info *server)\n{\n\tint val;\n\n\tspin_lock(&server->req_lock);\n\tval = server->credits + server->echo_credits + server->oplock_credits;\n\tif (server->in_flight == 0 && val == 0) {\n\t\tspin_unlock(&server->req_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&server->req_lock);\n\treturn false;\n}\n\nstatic int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct msghdr *smb_msg)\n{\n\tint length = 0;\n\tint total_read;\n\n\tfor (total_read = 0; msg_data_left(smb_msg); total_read += length) {\n\t\ttry_to_freeze();\n\n\t\t/* reconnect if no credits and no requests in flight */\n\t\tif (zero_credits(server)) {\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\n\t\tif (server_unresponsive(server))\n\t\t\treturn -ECONNABORTED;\n\t\tif (cifs_rdma_enabled(server) && server->smbd_conn)\n\t\t\tlength = smbd_recv(server->smbd_conn, smb_msg);\n\t\telse\n\t\t\tlength = sock_recvmsg(server->ssocket, smb_msg, 0);\n\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\treturn -ESHUTDOWN;\n\t\t}\n\n\t\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\tif (length == -ERESTARTSYS ||\n\t\t    length == -EAGAIN ||\n\t\t    length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: %d\\n\", length);\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\t}\n\treturn total_read;\n}\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct msghdr smb_msg = {};\n\tstruct kvec iov = {.iov_base = buf, .iov_len = to_read};\n\tiov_iter_kvec(&smb_msg.msg_iter, READ, &iov, 1, to_read);\n\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nssize_t\ncifs_discard_from_socket(struct TCP_Server_Info *server, size_t to_read)\n{\n\tstruct msghdr smb_msg = {};\n\n\t/*\n\t *  iov_iter_discard already sets smb_msg.type and count and iov_offset\n\t *  and cifs_readv_from_socket sets msg_control and msg_controllen\n\t *  so little to initialize in struct msghdr\n\t */\n\tiov_iter_discard(&smb_msg.msg_iter, READ, to_read);\n\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nint\ncifs_read_page_from_socket(struct TCP_Server_Info *server, struct page *page,\n\tunsigned int page_offset, unsigned int to_read)\n{\n\tstruct msghdr smb_msg = {};\n\tstruct bio_vec bv = {\n\t\t.bv_page = page, .bv_len = to_read, .bv_offset = page_offset};\n\tiov_iter_bvec(&smb_msg.msg_iter, READ, &bv, 1, to_read);\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nstatic bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server, true);\n\t\tbreak;\n\tdefault:\n\t\tcifs_server_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server, true);\n\t}\n\n\treturn false;\n}\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&mid->server->mid_lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t/*\n\t * Trying to handle/dequeue a mid after the send_recv()\n\t * function has finished processing it is a bug.\n\t */\n\tif (mid->mid_flags & MID_DELETED) {\n\t\tspin_unlock(&mid->server->mid_lock);\n\t\tpr_warn_once(\"trying to dequeue a deleted mid\\n\");\n\t} else {\n\t\tlist_del_init(&mid->qhead);\n\t\tmid->mid_flags |= MID_DELETED;\n\t\tspin_unlock(&mid->server->mid_lock);\n\t}\n}\n\nstatic unsigned int\nsmb2_get_credits_from_hdr(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buffer;\n\n\t/*\n\t * SMB1 does not use credits.\n\t */\n\tif (is_smb1(server))\n\t\treturn 0;\n\n\treturn le16_to_cpu(shdr->CreditRequest);\n}\n\nstatic void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->credits_received = smb2_get_credits_from_hdr(buf, server);\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}\n\nint\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\tif (cifs_rdma_enabled(server) && server->sign)\n\t\tcifs_dbg(VFS, \"Signing is enabled, and RDMA read/write will be disabled\\n\");\n\n\treturn 0;\n}\n\n\nstatic void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&server->srv_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&server->srv_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\tif (cifs_rdma_enabled(server))\n\t\tsmbd_destroy(server);\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&server->mid_lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid %llu\\n\", mid_entry->mid);\n\t\t\tkref_get(&mid_entry->refcount);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t\tmid_entry->mid_flags |= MID_DELETED;\n\t\t}\n\t\tspin_unlock(&server->mid_lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid %llu\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t\trelease_mid(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tkfree(server->origin_fullpath);\n\tkfree(server->leaf_fullpath);\n#endif\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\n}\n\nstatic int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) -\n\t    HEADER_PREAMBLE_SIZE(server)) {\n\t\tcifs_server_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\t       pdu_length - MID_HEADER_SIZE(server));\n\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\treturn cifs_handle_standard(server, mid);\n}\n\nint\ncifs_handle_standard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tchar *buf = server->large_buf ? server->bigbuf : server->smallbuf;\n\tint rc;\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\trc = server->ops->check_message(buf, server->total_read, server);\n\tif (rc)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_session_expired &&\n\t    server->ops->is_session_expired(buf)) {\n\t\tcifs_reconnect(server, true);\n\t\treturn -1;\n\t}\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn rc;\n\n\thandle_mid(mid, server, buf, rc);\n\treturn 0;\n}\n\nstatic void\nsmb2_add_credits_from_hdr(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buffer;\n\tint scredits, in_flight;\n\n\t/*\n\t * SMB1 does not use credits.\n\t */\n\tif (is_smb1(server))\n\t\treturn;\n\n\tif (shdr->CreditRequest) {\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += le16_to_cpu(shdr->CreditRequest);\n\t\tscredits = server->credits;\n\t\tin_flight = server->in_flight;\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\n\t\ttrace_smb3_hdr_credits(server->CurrentMid,\n\t\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\t\tle16_to_cpu(shdr->CreditRequest), in_flight);\n\t\tcifs_server_dbg(FYI, \"%s: added %u credits total=%d\\n\",\n\t\t\t\t__func__, le16_to_cpu(shdr->CreditRequest),\n\t\t\t\tscredits);\n\t}\n}\n\n\nstatic int\ncifs_demultiplex_thread(void *p)\n{\n\tint i, num_mids, length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tunsigned int next_offset;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mids[MAX_COMPOUND];\n\tchar *bufs[MAX_COMPOUND];\n\tunsigned int noreclaim_flag, num_io_timeout = 0;\n\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tcifs_dbg(FYI, \"Demultiplex PID: %d\\n\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\n\n\tset_freezable();\n\tallow_kernel_signal(SIGKILL);\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (is_smb1(server))\n\t\t\tserver->total_read = length;\n\t\telse\n\t\t\tserver->total_read = 0;\n\n\t\t/*\n\t\t * The right amount was read from socket - 4 bytes,\n\t\t * so we can now interpret the length field.\n\t\t */\n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, \"RFC1002 header 0x%x\\n\", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\nnext_pdu:\n\t\tserver->pdu_size = pdu_length;\n\n\t\t/* make sure we have enough to get to the MID */\n\t\tif (server->pdu_size < MID_HEADER_SIZE(server)) {\n\t\t\tcifs_server_dbg(VFS, \"SMB response too short (%u bytes)\\n\",\n\t\t\t\t server->pdu_size);\n\t\t\tcifs_reconnect(server, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* read down to the MID */\n\t\tlength = cifs_read_from_socket(server,\n\t\t\t     buf + HEADER_PREAMBLE_SIZE(server),\n\t\t\t     MID_HEADER_SIZE(server));\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tif (server->ops->next_header) {\n\t\t\tnext_offset = server->ops->next_header(buf);\n\t\t\tif (next_offset)\n\t\t\t\tserver->pdu_size = next_offset;\n\t\t}\n\n\t\tmemset(mids, 0, sizeof(mids));\n\t\tmemset(bufs, 0, sizeof(bufs));\n\t\tnum_mids = 0;\n\n\t\tif (server->ops->is_transform_hdr &&\n\t\t    server->ops->receive_transform &&\n\t\t    server->ops->is_transform_hdr(buf)) {\n\t\t\tlength = server->ops->receive_transform(server,\n\t\t\t\t\t\t\t\tmids,\n\t\t\t\t\t\t\t\tbufs,\n\t\t\t\t\t\t\t\t&num_mids);\n\t\t} else {\n\t\t\tmids[0] = server->ops->find_mid(server, buf);\n\t\t\tbufs[0] = buf;\n\t\t\tnum_mids = 1;\n\n\t\t\tif (!mids[0] || !mids[0]->receive)\n\t\t\t\tlength = standard_receive3(server, mids[0]);\n\t\t\telse\n\t\t\t\tlength = mids[0]->receive(server, mids[0]);\n\t\t}\n\n\t\tif (length < 0) {\n\t\t\tfor (i = 0; i < num_mids; i++)\n\t\t\t\tif (mids[i])\n\t\t\t\t\trelease_mid(mids[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (server->ops->is_status_io_timeout &&\n\t\t    server->ops->is_status_io_timeout(buf)) {\n\t\t\tnum_io_timeout++;\n\t\t\tif (num_io_timeout > NUM_STATUS_IO_TIMEOUT) {\n\t\t\t\tcifs_reconnect(server, false);\n\t\t\t\tnum_io_timeout = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tserver->lstrp = jiffies;\n\n\t\tfor (i = 0; i < num_mids; i++) {\n\t\t\tif (mids[i] != NULL) {\n\t\t\t\tmids[i]->resp_buf_size = server->pdu_size;\n\n\t\t\t\tif (bufs[i] && server->ops->is_network_name_deleted)\n\t\t\t\t\tserver->ops->is_network_name_deleted(bufs[i],\n\t\t\t\t\t\t\t\t\tserver);\n\n\t\t\t\tif (!mids[i]->multiRsp || mids[i]->multiEnd)\n\t\t\t\t\tmids[i]->callback(mids[i]);\n\n\t\t\t\trelease_mid(mids[i]);\n\t\t\t} else if (server->ops->is_oplock_break &&\n\t\t\t\t   server->ops->is_oplock_break(bufs[i],\n\t\t\t\t\t\t\t\tserver)) {\n\t\t\t\tsmb2_add_credits_from_hdr(bufs[i], server);\n\t\t\t\tcifs_dbg(FYI, \"Received oplock break\\n\");\n\t\t\t} else {\n\t\t\t\tcifs_server_dbg(VFS, \"No task to wake, unknown frame received! NumMids %d\\n\",\n\t\t\t\t\t\tatomic_read(&mid_count));\n\t\t\t\tcifs_dump_mem(\"Received Data is: \", bufs[i],\n\t\t\t\t\t      HEADER_SIZE(server));\n\t\t\t\tsmb2_add_credits_from_hdr(bufs[i], server);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\t\tif (server->ops->dump_detail)\n\t\t\t\t\tserver->ops->dump_detail(bufs[i],\n\t\t\t\t\t\t\t\t server);\n\t\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\t\t\t}\n\t\t}\n\n\t\tif (pdu_length > server->pdu_size) {\n\t\t\tif (!allocate_buffers(server))\n\t\t\t\tcontinue;\n\t\t\tpdu_length -= server->pdu_size;\n\t\t\tserver->total_read = 0;\n\t\t\tserver->large_buf = false;\n\t\t\tbuf = server->smallbuf;\n\t\t\tgoto next_pdu;\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* buffer usually freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(server->bigbuf);\n\tif (server->smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(server->smallbuf);\n\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tclean_demultiplex_info(server);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tmodule_put_and_kthread_exit(0);\n}\n\n/*\n * Returns true if srcaddr isn't specified and rhs isn't specified, or\n * if srcaddr is specified and matches the IP address of the rhs argument\n */\nbool\ncifs_match_ipaddr(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}\n\n/*\n * If no port is specified in addr structure, we try to match with 445 port\n * and if it fails - with 139 ports. It should be called only if address\n * families of server and addr are equal.\n */\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\t/* SMBDirect manages its own ports, don't match it here */\n\tif (server->rdma)\n\t\treturn true;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!cifs_match_ipaddr(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\t/*\n\t * The select_sectype function should either return the ctx->sectype\n\t * that was specified, or \"Unspecified\" if that sectype was not\n\t * compatible with the given NEGOTIATE request.\n\t */\n\tif (server->ops->select_sectype(server, ctx->sectype)\n\t     == Unspecified)\n\t\treturn false;\n\n\t/*\n\t * Now check if signing mode is acceptable. No need to check\n\t * global_secflags at this point since if MUST_SIGN is set then\n\t * the server->sign had better be too.\n\t */\n\tif (ctx->sign && !server->sign)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* this function must be called with srv_lock held */\nstatic int match_server(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&ctx->dstaddr;\n\n\tif (ctx->nosharesock)\n\t\treturn 0;\n\n\t/* this server does not share socket */\n\tif (server->nosharesock)\n\t\treturn 0;\n\n\t/* If multidialect negotiation see if existing sessions match one */\n\tif (strcmp(ctx->vals->version_string, SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (server->vals->protocol_id < SMB30_PROT_ID)\n\t\t\treturn 0;\n\t} else if (strcmp(ctx->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (server->vals->protocol_id < SMB21_PROT_ID)\n\t\t\treturn 0;\n\t} else if ((server->vals != ctx->vals) || (server->ops != ctx->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (strcasecmp(server->hostname, ctx->server_hostname))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&ctx->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, ctx))\n\t\treturn 0;\n\n\tif (server->echo_interval != ctx->echo_interval * HZ)\n\t\treturn 0;\n\n\tif (server->rdma != ctx->rdma)\n\t\treturn 0;\n\n\tif (server->ignore_signature != ctx->ignore_signature)\n\t\treturn 0;\n\n\tif (server->min_offload != ctx->min_offload)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct TCP_Server_Info *\ncifs_find_tcp_session(struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tspin_lock(&server->srv_lock);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\t/*\n\t\t * DFS failover implementation in cifs_reconnect() requires unique tcp sessions for\n\t\t * DFS connections to do failover properly, so avoid sharing them with regular\n\t\t * shares or even links that may connect to same server but having completely\n\t\t * different failover targets.\n\t\t */\n\t\tif (server->is_dfs_conn) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t/*\n\t\t * Skip ses channels since they're only handled in lower layers\n\t\t * (e.g. cifs_send_recv).\n\t\t */\n\t\tif (CIFS_SERVER_IS_CHAN(server) || !match_server(server, ctx)) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid\ncifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\t/* srv_count can never go negative */\n\tWARN_ON(server->srv_count < 0);\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* For secondary channels, we pick up ref-count on the primary server */\n\tif (CIFS_SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server->primary_server, from_reconnect);\n\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\n\tif (from_reconnect)\n\t\t/*\n\t\t * Avoid deadlock here: reconnect work calls\n\t\t * cifs_put_tcp_session() at its end. Need to be sure\n\t\t * that reconnect work does nothing with server pointer after\n\t\t * that step.\n\t\t */\n\t\tcancel_delayed_work(&server->reconnect);\n\telse\n\t\tcancel_delayed_work_sync(&server->reconnect);\n\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\n\tcifs_crypto_secmech_release(server);\n\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tkfree(server->hostname);\n\tserver->hostname = NULL;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tsend_sig(SIGKILL, task, 1);\n}\n\nstruct TCP_Server_Info *\ncifs_get_tcp_session(struct smb3_fs_context *ctx,\n\t\t     struct TCP_Server_Info *primary_server)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", ctx->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(ctx);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->hostname = kstrdup(ctx->server_hostname, GFP_KERNEL);\n\tif (!tcp_ses->hostname) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (ctx->nosharesock)\n\t\ttcp_ses->nosharesock = true;\n\n\ttcp_ses->ops = ctx->ops;\n\ttcp_ses->vals = ctx->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\n\ttcp_ses->conn_id = atomic_inc_return(&tcpSesNextId);\n\ttcp_ses->noblockcnt = ctx->rootfs;\n\ttcp_ses->noblocksnd = ctx->noblocksnd || ctx->rootfs;\n\ttcp_ses->noautotune = ctx->noautotune;\n\ttcp_ses->tcp_nodelay = ctx->sockopt_tcp_nodelay;\n\ttcp_ses->rdma = ctx->rdma;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->max_in_flight = 0;\n\ttcp_ses->credits = 1;\n\tif (primary_server) {\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\t++primary_server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\ttcp_ses->primary_server = primary_server;\n\t}\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->_srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tctx->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tctx->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->reconnect_instance = 1;\n\ttcp_ses->lstrp = jiffies;\n\ttcp_ses->compress_algorithm = cpu_to_le16(ctx->compression);\n\tspin_lock_init(&tcp_ses->req_lock);\n\tspin_lock_init(&tcp_ses->srv_lock);\n\tspin_lock_init(&tcp_ses->mid_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tINIT_DELAYED_WORK(&tcp_ses->resolve, cifs_resolve_server);\n\tINIT_DELAYED_WORK(&tcp_ses->reconnect, smb2_reconnect_server);\n\tmutex_init(&tcp_ses->reconnect_mutex);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tmutex_init(&tcp_ses->refpath_lock);\n#endif\n\tmemcpy(&tcp_ses->srcaddr, &ctx->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &ctx->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n\tif (ctx->use_client_guid)\n\t\tmemcpy(tcp_ses->client_guid, ctx->client_guid,\n\t\t       SMB2_CLIENT_GUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(tcp_ses->client_guid);\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\tif (ctx->echo_interval >= SMB_ECHO_INTERVAL_MIN &&\n\t\tctx->echo_interval <= SMB_ECHO_INTERVAL_MAX)\n\t\ttcp_ses->echo_interval = ctx->echo_interval * HZ;\n\telse\n\t\ttcp_ses->echo_interval = SMB_ECHO_INTERVAL_DEFAULT * HZ;\n\tif (tcp_ses->rdma) {\n#ifndef CONFIG_CIFS_SMB_DIRECT\n\t\tcifs_dbg(VFS, \"CONFIG_CIFS_SMB_DIRECT is not enabled\\n\");\n\t\trc = -ENOENT;\n\t\tgoto out_err_crypto_release;\n#endif\n\t\ttcp_ses->smbd_conn = smbd_get_connection(\n\t\t\ttcp_ses, (struct sockaddr *)&ctx->dstaddr);\n\t\tif (tcp_ses->smbd_conn) {\n\t\t\tcifs_dbg(VFS, \"RDMA transport established\\n\");\n\t\t\trc = 0;\n\t\t\tgoto smbd_connected;\n\t\t} else {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err_crypto_release;\n\t\t}\n\t}\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\nsmbd_connected:\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->min_offload = ctx->min_offload;\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this update of tcpStatus\n\t */\n\tspin_lock(&tcp_ses->srv_lock);\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\tspin_unlock(&tcp_ses->srv_lock);\n\n\tif ((ctx->max_credits < 20) || (ctx->max_credits > 60000))\n\t\ttcp_ses->max_credits = SMB2_MAX_CREDITS_AVAILABLE;\n\telse\n\t\ttcp_ses->max_credits = ctx->max_credits;\n\n\ttcp_ses->nr_targets = 1;\n\ttcp_ses->ignore_signature = ctx->ignore_signature;\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, tcp_ses->echo_interval);\n\n\t/* queue dns resolution delayed work */\n\tcifs_dbg(FYI, \"%s: next dns resolution scheduled for %d seconds in the future\\n\",\n\t\t __func__, SMB_DNS_RESOLVE_INTERVAL_DEFAULT);\n\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->resolve, (SMB_DNS_RESOLVE_INTERVAL_DEFAULT * HZ));\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_secmech_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (CIFS_SERVER_IS_CHAN(tcp_ses))\n\t\t\tcifs_put_tcp_session(tcp_ses->primary_server, false);\n\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\n/* this function must be called with ses_lock held */\nstatic int match_session(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tif (ctx->sectype != Unspecified &&\n\t    ctx->sectype != ses->sectype)\n\t\treturn 0;\n\n\t/*\n\t * If an existing session is limited to less channels than\n\t * requested, it should not be reused\n\t */\n\tspin_lock(&ses->chan_lock);\n\tif (ses->chan_max < ctx->max_channels) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(ctx->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!ctx->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    ctx->username ? ctx->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((ctx->username && strlen(ctx->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    ctx->password ? ctx->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/**\n * cifs_setup_ipc - helper to setup the IPC tcon for the session\n * @ses: smb session to issue the request on\n * @ctx: the superblock configuration context to use for building the\n *       new tree connection for the IPC (interprocess communication RPC)\n *\n * A new IPC connection is made and stored in the session\n * tcon_ipc. The IPC tcon has the same lifetime as the session.\n */\nstatic int\ncifs_setup_ipc(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tint rc = 0, xid;\n\tstruct cifs_tcon *tcon;\n\tchar unc[SERVER_NAME_LENGTH + sizeof(\"//x/IPC$\")] = {0};\n\tbool seal = false;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\t/*\n\t * If the mount request that resulted in the creation of the\n\t * session requires encryption, force IPC to be encrypted too.\n\t */\n\tif (ctx->seal) {\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION)\n\t\t\tseal = true;\n\t\telse {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t \"IPC: server doesn't support encryption\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL)\n\t\treturn -ENOMEM;\n\n\tscnprintf(unc, sizeof(unc), \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\n\txid = get_xid();\n\ttcon->ses = ses;\n\ttcon->ipc = true;\n\ttcon->seal = seal;\n\trc = server->ops->tree_connect(xid, ses, unc, tcon, ctx->local_nls);\n\tfree_xid(xid);\n\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"failed to connect to IPC (rc=%d)\\n\", rc);\n\t\ttconInfoFree(tcon);\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"IPC tcon rc=%d ipc tid=0x%x\\n\", rc, tcon->tid);\n\n\tses->tcon_ipc = tcon;\nout:\n\treturn rc;\n}\n\n/**\n * cifs_free_ipc - helper to release the session IPC tcon\n * @ses: smb session to unmount the IPC from\n *\n * Needs to be called everytime a session is destroyed.\n *\n * On session close, the IPC is closed and the server must release all tcons of the session.\n * No need to send a tree disconnect here.\n *\n * Besides, it will make the server to not close durable and resilient files on session close, as\n * specified in MS-SMB2 3.3.5.6 Receiving an SMB2 LOGOFF Request.\n */\nstatic int\ncifs_free_ipc(struct cifs_ses *ses)\n{\n\tstruct cifs_tcon *tcon = ses->tcon_ipc;\n\n\tif (tcon == NULL)\n\t\treturn 0;\n\n\ttconInfoFree(tcon);\n\tses->tcon_ipc = NULL;\n\treturn 0;\n}\n\nstatic struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_EXITING) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!match_session(ses, ctx)) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ses->ses_lock);\n\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid cifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tunsigned int chan_count;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_EXITING) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\tcifs_dbg(FYI,\n\t\t \"%s: ses ipc: %s\\n\", __func__, ses->tcon_ipc ? ses->tcon_ipc->tree_name : \"NONE\");\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* ses_count can never go negative */\n\tWARN_ON(ses->ses_count < 0);\n\n\tif (ses->ses_status == SES_GOOD)\n\t\tses->ses_status = SES_EXITING;\n\n\tcifs_free_ipc(ses);\n\n\tif (ses->ses_status == SES_EXITING && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_server_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tchan_count = ses->chan_count;\n\n\t/* close any extra channels */\n\tif (chan_count > 1) {\n\t\tint i;\n\n\t\tfor (i = 1; i < chan_count; i++) {\n\t\t\tif (ses->chans[i].iface) {\n\t\t\t\tkref_put(&ses->chans[i].iface->refcount, release_iface);\n\t\t\t\tses->chans[i].iface = NULL;\n\t\t\t}\n\t\t\tcifs_put_tcp_session(ses->chans[i].server, 0);\n\t\t\tses->chans[i].server = NULL;\n\t\t}\n\t}\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server, 0);\n}\n\n#ifdef CONFIG_KEYS\n\n/* strlen(\"cifs:a:\") + CIFS_MAX_DOMAINNAME_LEN + 1 */\n#define CIFSCREDS_DESC_SIZE (7 + CIFS_MAX_DOMAINNAME_LEN + 1)\n\n/* Populate username and pw fields from keyring if possible */\nstatic int\ncifs_set_cifscreds(struct smb3_fs_context *ctx, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tint is_domain = 0;\n\tconst char *delim, *payload;\n\tchar *desc;\n\tssize_t len;\n\tstruct key *key;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tconst struct user_key_payload *upayload;\n\n\tdesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t/* try to find an address key first */\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tsa = (struct sockaddr_in *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsa6 = (struct sockaddr_in6 *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI6c\", &sa6->sin6_addr.s6_addr);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Bad ss_family (%hu)\\n\",\n\t\t\t server->dstaddr.ss_family);\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\tkey = request_key(&key_type_logon, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (!ses->domainName) {\n\t\t\tcifs_dbg(FYI, \"domainName is NULL\\n\");\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t/* didn't work, try to find a domain key */\n\t\tsprintf(desc, \"cifs:d:%s\", ses->domainName);\n\t\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\t\tkey = request_key(&key_type_logon, desc, \"\");\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\t\tis_domain = 1;\n\t}\n\n\tdown_read(&key->sem);\n\tupayload = user_key_payload_locked(key);\n\tif (IS_ERR_OR_NULL(upayload)) {\n\t\trc = upayload ? PTR_ERR(upayload) : -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\t/* find first : in payload */\n\tpayload = upayload->data;\n\tdelim = strnchr(payload, upayload->datalen, ':');\n\tcifs_dbg(FYI, \"payload=%s\\n\", payload);\n\tif (!delim) {\n\t\tcifs_dbg(FYI, \"Unable to find ':' in payload (datalen=%d)\\n\",\n\t\t\t upayload->datalen);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tlen = delim - payload;\n\tif (len > CIFS_MAX_USERNAME_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad value from username search (len=%zd)\\n\",\n\t\t\t len);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tctx->username = kstrndup(payload, len, GFP_KERNEL);\n\tif (!ctx->username) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for username\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tgoto out_key_put;\n\t}\n\tcifs_dbg(FYI, \"%s: username=%s\\n\", __func__, ctx->username);\n\n\tlen = key->datalen - (len + 1);\n\tif (len > CIFS_MAX_PASSWORD_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad len for password search (len=%zd)\\n\", len);\n\t\trc = -EINVAL;\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t++delim;\n\tctx->password = kstrndup(delim, len, GFP_KERNEL);\n\tif (!ctx->password) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for password\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t/*\n\t * If we have a domain key then we must set the domainName in the\n\t * for the request.\n\t */\n\tif (is_domain && ses->domainName) {\n\t\tctx->domainname = kstrdup(ses->domainName, GFP_KERNEL);\n\t\tif (!ctx->domainname) {\n\t\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for domain\\n\",\n\t\t\t\t len);\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(ctx->username);\n\t\t\tctx->username = NULL;\n\t\t\tkfree_sensitive(ctx->password);\n\t\t\tctx->password = NULL;\n\t\t\tgoto out_key_put;\n\t\t}\n\t}\n\n\tstrscpy(ctx->workstation_name, ses->workstation_name, sizeof(ctx->workstation_name));\n\nout_key_put:\n\tup_read(&key->sem);\n\tkey_put(key);\nout_err:\n\tkfree(desc);\n\tcifs_dbg(FYI, \"%s: returning %d\\n\", __func__, rc);\n\treturn rc;\n}\n#else /* ! CONFIG_KEYS */\nstatic inline int\ncifs_set_cifscreds(struct smb3_fs_context *ctx __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}\n#endif /* CONFIG_KEYS */\n\n/**\n * cifs_get_smb_ses - get a session matching @ctx data from @server\n * @server: server to setup the session to\n * @ctx: superblock configuration context to use to setup the session\n *\n * This function assumes it is being called from cifs_mount() where we\n * already got a server reference (server refcount +1). See\n * cifs_get_tcon() for refcount explanations.\n */\nstruct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, ctx);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->ses_status);\n\n\t\tspin_lock(&ses->chan_lock);\n\t\tif (cifs_chan_needs_reconnect(ses, server)) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\n\t\t\tmutex_lock(&ses->session_mutex);\n\t\t\trc = cifs_negotiate_protocol(xid, ses, server);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our ses reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\n\t\t\trc = cifs_setup_session(xid, ses, server,\n\t\t\t\t\t\tctx->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t\tspin_lock(&ses->chan_lock);\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server, 0);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->ip_addr, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->ip_addr, \"%pI4\", &addr->sin_addr);\n\n\tif (ctx->username) {\n\t\tses->user_name = kstrdup(ctx->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* ctx->password freed at unmount */\n\tif (ctx->password) {\n\t\tses->password = kstrdup(ctx->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (ctx->domainname) {\n\t\tses->domainName = kstrdup(ctx->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\tstrscpy(ses->workstation_name, ctx->workstation_name, sizeof(ses->workstation_name));\n\n\tif (ctx->domainauto)\n\t\tses->domainAuto = ctx->domainauto;\n\tses->cred_uid = ctx->cred_uid;\n\tses->linux_uid = ctx->linux_uid;\n\n\tses->sectype = ctx->sectype;\n\tses->sign = ctx->sign;\n\n\t/* add server as first channel */\n\tspin_lock(&ses->chan_lock);\n\tses->chans[0].server = server;\n\tses->chan_count = 1;\n\tses->chan_max = ctx->multichannel ? ctx->max_channels:1;\n\tses->chans_need_reconnect = 1;\n\tspin_unlock(&ses->chan_lock);\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses, server);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, server, ctx->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* each channel uses a different signing key */\n\tspin_lock(&ses->chan_lock);\n\tmemcpy(ses->chans[0].signkey, ses->smb3signingkey,\n\t       sizeof(ses->smb3signingkey));\n\tspin_unlock(&ses->chan_lock);\n\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/*\n\t * success, put it on the list and add it as first channel\n\t * note: the session becomes active soon after this. So you'll\n\t * need to lock before changing something in the session.\n\t */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\n\tcifs_setup_ipc(ses, ctx);\n\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}\n\n/* this function must be called with tc_lock held */\nstatic int match_tcon(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tif (tcon->status == TID_EXITING)\n\t\treturn 0;\n\tif (strncmp(tcon->tree_name, ctx->UNC, MAX_TREE_SIZE))\n\t\treturn 0;\n\tif (tcon->seal != ctx->seal)\n\t\treturn 0;\n\tif (tcon->snapshot_time != ctx->snapshot_time)\n\t\treturn 0;\n\tif (tcon->handle_timeout != ctx->handle_timeout)\n\t\treturn 0;\n\tif (tcon->no_lease != ctx->no_lease)\n\t\treturn 0;\n\tif (tcon->nodelete != ctx->nodelete)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (!match_tcon(tcon, ctx)) {\n\t\t\tspin_unlock(&tcon->tc_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&tcon->tc_lock);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\n\t/*\n\t * IPC tcon share the lifetime of their session and are\n\t * destroyed in the session put function\n\t */\n\tif (tcon == NULL || tcon->ipc)\n\t\treturn;\n\n\tses = tcon->ses;\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tspin_lock(&tcon->tc_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\t/* tc_count can never go negative */\n\tWARN_ON(tcon->tc_count < 0);\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&tcon->tc_lock);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel polling of interfaces */\n\tcancel_delayed_work_sync(&tcon->query_interfaces);\n\n\tif (tcon->use_witness) {\n\t\tint rc;\n\n\t\trc = cifs_swn_unregister(tcon);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"%s: Failed to unregister for witness notifications: %d\\n\",\n\t\t\t\t\t__func__, rc);\n\t\t}\n\t}\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\n/**\n * cifs_get_tcon - get a tcon matching @ctx data from @ses\n * @ses: smb session to issue the request on\n * @ctx: the superblock configuration context to use for building the\n *\n * - tcon refcount is the number of mount points using the tcon.\n * - ses refcount is the number of tcon using the session.\n *\n * 1. This function assumes it is being called from cifs_mount() where\n *    we already got a session reference (ses refcount +1).\n *\n * 2. Since we're in the context of adding a mount point, the end\n *    result should be either:\n *\n * a) a new tcon already allocated with refcount=1 (1 mount point) and\n *    its session refcount incremented (1 new tcon). This +1 was\n *    already done in (1).\n *\n * b) an existing tcon with refcount+1 (add a mount point to it) and\n *    identical ses refcount (no new tcon). Because of (1) we need to\n *    decrement the ses refcount.\n */\nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, ctx);\n\tif (tcon) {\n\t\t/*\n\t\t * tcon has refcount already incremented but we need to\n\t\t * decrement extra ses reference gotten by caller (case b)\n\t\t */\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\tcifs_put_smb_ses(ses);\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\tif (ctx->snapshot_time) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"Use SMB2 or later for snapshot mount option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->snapshot_time = ctx->snapshot_time;\n\t}\n\n\tif (ctx->handle_timeout) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"Use SMB2.1 or later for handle timeout option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->handle_timeout = ctx->handle_timeout;\n\t}\n\n\ttcon->ses = ses;\n\tif (ctx->password) {\n\t\ttcon->password = kstrdup(ctx->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (ctx->seal) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t \"SMB3 or later required for encryption\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else if (tcon->ses->server->capabilities &\n\t\t\t\t\tSMB2_GLOBAL_CAP_ENCRYPTION)\n\t\t\ttcon->seal = true;\n\t\telse {\n\t\t\tcifs_dbg(VFS, \"Encryption is not supported on share\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (ctx->linux_ext) {\n\t\tif (ses->server->posix_ext_supported) {\n\t\t\ttcon->posix_extensions = true;\n\t\t\tpr_warn_once(\"SMB3.11 POSIX Extensions are experimental\\n\");\n\t\t} else if ((ses->server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMB3ANY_VERSION_STRING) == 0) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0)) {\n\t\t\tcifs_dbg(VFS, \"Server does not support mounting with posix SMB3.11 extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Check vers= mount option. SMB3.11 \"\n\t\t\t\t\"disabled but required for POSIX extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, ctx->UNC, tcon,\n\t\t\t\t\t    ctx->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\ttcon->use_persistent = false;\n\t/* check if SMB2 or later, CIFS does not support persistent handles */\n\tif (ctx->persistent) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"SMB3 or later required for persistent handles\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else if (ses->server->capabilities &\n\t\t\t   SMB2_GLOBAL_CAP_PERSISTENT_HANDLES)\n\t\t\ttcon->use_persistent = true;\n\t\telse /* persistent handles requested but not supported */ {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"Persistent handles not supported on share\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t} else if ((tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\t     && (ses->server->capabilities & SMB2_GLOBAL_CAP_PERSISTENT_HANDLES)\n\t     && (ctx->nopersistent == false)) {\n\t\tcifs_dbg(FYI, \"enabling persistent handles\\n\");\n\t\ttcon->use_persistent = true;\n\t} else if (ctx->resilient) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"SMB2.1 or later required for resilient handles\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t\ttcon->use_resilient = true;\n\t}\n\n\ttcon->use_witness = false;\n\tif (IS_ENABLED(CONFIG_CIFS_SWN_UPCALL) && ctx->witness) {\n\t\tif (ses->server->vals->protocol_id >= SMB30_PROT_ID) {\n\t\t\tif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER) {\n\t\t\t\t/*\n\t\t\t\t * Set witness in use flag in first place\n\t\t\t\t * to retry registration in the echo task\n\t\t\t\t */\n\t\t\t\ttcon->use_witness = true;\n\t\t\t\t/* And try to register immediately */\n\t\t\t\trc = cifs_swn_register(tcon);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tcifs_dbg(VFS, \"Failed to register for witness notifications: %d\\n\", rc);\n\t\t\t\t\tgoto out_fail;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* TODO: try to extend for non-cluster uses (eg multichannel) */\n\t\t\t\tcifs_dbg(VFS, \"witness requested on mount but no CLUSTER capability on share\\n\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"SMB3 or later required for witness option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/* If the user really knows what they are doing they can override */\n\tif (tcon->share_flags & SMB2_SHAREFLAG_NO_CACHING) {\n\t\tif (ctx->cache_ro)\n\t\t\tcifs_dbg(VFS, \"cache=ro requested on mount but NO_CACHING flag set on share\\n\");\n\t\telse if (ctx->cache_rw)\n\t\t\tcifs_dbg(VFS, \"cache=singleclient requested on mount but NO_CACHING flag set on share\\n\");\n\t}\n\n\tif (ctx->no_lease) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 or later required for nolease option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->no_lease = ctx->no_lease;\n\t}\n\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = ctx->retry;\n\ttcon->nocase = ctx->nocase;\n\ttcon->broken_sparse_sup = ctx->no_sparse;\n\tif (ses->server->capabilities & SMB2_GLOBAL_CAP_DIRECTORY_LEASING)\n\t\ttcon->nohandlecache = ctx->nohandlecache;\n\telse\n\t\ttcon->nohandlecache = true;\n\ttcon->nodelete = ctx->nodelete;\n\ttcon->local_lease = ctx->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\t/* schedule query interfaces poll */\n\tINIT_DELAYED_WORK(&tcon->query_interfaces,\n\t\t\t  smb2_query_server_interfaces);\n\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}\n\nstatic int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\tunsigned int oldflags = old->mnt_cifs_flags & CIFS_MOUNT_MASK;\n\tunsigned int newflags = new->mnt_cifs_flags & CIFS_MOUNT_MASK;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif (old->mnt_cifs_serverino_autodisabled)\n\t\tnewflags &= ~CIFS_MOUNT_SERVER_INUM;\n\n\tif (oldflags != newflags)\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->ctx->wsize && new->ctx->wsize < old->ctx->wsize)\n\t\treturn 0;\n\n\tif (new->ctx->rsize && new->ctx->rsize < old->ctx->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->ctx->linux_uid, new->ctx->linux_uid) ||\n\t    !gid_eq(old->ctx->linux_gid, new->ctx->linux_gid))\n\t\treturn 0;\n\n\tif (old->ctx->file_mode != new->ctx->file_mode ||\n\t    old->ctx->dir_mode != new->ctx->dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->ctx->acregmax != new->ctx->acregmax)\n\t\treturn 0;\n\tif (old->ctx->acdirmax != new->ctx->acdirmax)\n\t\treturn 0;\n\tif (old->ctx->closetimeo != new->ctx->closetimeo)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nmatch_prepath(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\tbool old_set = (old->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH) &&\n\t\told->prepath;\n\tbool new_set = (new->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH) &&\n\t\tnew->prepath;\n\n\tif (old_set && new_set && !strcmp(new->prepath, old->prepath))\n\t\treturn 1;\n\telse if (!old_set && !new_set)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint\ncifs_match_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = data;\n\tstruct smb3_fs_context *ctx;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *tcp_srv;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tcifs_sb = CIFS_SB(sb);\n\ttlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\tif (tlink == NULL) {\n\t\t/* can not match superblock if tlink were ever null */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn 0;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tses = tcon->ses;\n\ttcp_srv = ses->server;\n\n\tctx = mnt_data->ctx;\n\n\tspin_lock(&tcp_srv->srv_lock);\n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&tcon->tc_lock);\n\tif (!match_server(tcp_srv, ctx) ||\n\t    !match_session(ses, ctx) ||\n\t    !match_tcon(tcon, ctx) ||\n\t    !match_prepath(sb, mnt_data)) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = compare_mount_options(sb, mnt_data);\nout:\n\tspin_unlock(&tcon->tc_lock);\n\tspin_unlock(&ses->ses_lock);\n\tspin_unlock(&tcp_srv->srv_lock);\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(!sock_allow_reclassification(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(!sock_allow_reclassification(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_server_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_server_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tunsigned int req_noscope_len;\n\tstruct smb_hdr *smb_buf;\n\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scopes */\n\t\treq_noscope_len = sizeof(struct rfc1002_session_packet) - 2;\n\n\t\t/* == cpu_to_be32(0x81000044) */\n\t\tsmb_buf->smb_buf_length =\n\t\t\tcpu_to_be32((RFC1002_SESSION_REQUEST << 24) | req_noscope_len);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tsport = ipv6->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t\tcifs_dbg(FYI, \"%s: connecting to [%pI6]:%d\\n\", __func__, &ipv6->sin6_addr,\n\t\t\t\tntohs(sport));\n\t} else {\n\t\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)&server->dstaddr;\n\n\t\tsport = ipv4->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t\tcifs_dbg(FYI, \"%s: connecting to %pI4:%d\\n\", __func__, &ipv4->sin_addr,\n\t\t\t\tntohs(sport));\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_server_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay)\n\t\ttcp_sock_set_nodelay(socket->sk);\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen,\n\t\t\t\t  server->noblockcnt ? O_NONBLOCK : 0);\n\t/*\n\t * When mounting SMB root file systems, we do not want to block in\n\t * connect. Otherwise bail out and then let cifs_reconnect() perform\n\t * reconnect failover - if possible.\n\t */\n\tif (server->noblockcnt && rc == -EINPROGRESS)\n\t\trc = 0;\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\ttrace_smb3_connect_err(server->hostname, server->conn_id, &server->dstaddr, rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\ttrace_smb3_connect_done(server->hostname, server->conn_id, &server->dstaddr);\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\t/*\n\t * If we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths?\n\t */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (ctx && ctx->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (ctx)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (!tcon->unix_ext) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/*\n\t\t * check for reconnect case in which we do not\n\t\t * want to change the mount behavior if we can avoid it\n\t\t */\n\t\tif (ctx == NULL) {\n\t\t\t/*\n\t\t\t * turn off POSIX ACL and PATHNAMES if not set\n\t\t\t * originally at mount time\n\t\t\t */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (ctx && ctx->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (ctx && ctx->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (ctx == NULL)\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}\n#endif /* CONFIG_CIFS_ALLOW_INSECURE_LEGACY */\n\nint cifs_setup_cifs_sb(struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb3_fs_context *ctx = cifs_sb->ctx;\n\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\tcifs_dbg(FYI, \"file mode: %04ho  dir mode: %04ho\\n\",\n\t\t ctx->file_mode, ctx->dir_mode);\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (ctx->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tcifs_sb->local_nls = load_nls_default();\n\t} else {\n\t\tcifs_sb->local_nls = load_nls(ctx->iocharset);\n\t\tif (cifs_sb->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t ctx->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\tctx->local_nls = cifs_sb->local_nls;\n\n\tsmb3_update_mnt_flags(cifs_sb);\n\n\tif (ctx->direct_io)\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\tif (ctx->cache_ro) {\n\t\tcifs_dbg(VFS, \"mounting share with read only caching. Ensure that the share will not be modified while in use.\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RO_CACHE;\n\t} else if (ctx->cache_rw) {\n\t\tcifs_dbg(VFS, \"mounting share in single client RW caching mode. Ensure that no other systems will be accessing the share.\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_RO_CACHE |\n\t\t\t\t\t    CIFS_MOUNT_RW_CACHE);\n\t}\n\n\tif ((ctx->cifs_acl) && (ctx->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n\n\tif (ctx->prepath) {\n\t\tcifs_sb->prepath = kstrdup(ctx->prepath, GFP_KERNEL);\n\t\tif (cifs_sb->prepath == NULL)\n\t\t\treturn -ENOMEM;\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\t}\n\n\treturn 0;\n}\n\n/* Release all succeed connections */\nstatic inline void mount_put_conns(struct mount_ctx *mnt_ctx)\n{\n\tint rc = 0;\n\n\tif (mnt_ctx->tcon)\n\t\tcifs_put_tcon(mnt_ctx->tcon);\n\telse if (mnt_ctx->ses)\n\t\tcifs_put_smb_ses(mnt_ctx->ses);\n\telse if (mnt_ctx->server)\n\t\tcifs_put_tcp_session(mnt_ctx->server, 0);\n\tmnt_ctx->cifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_POSIX_PATHS;\n\tfree_xid(mnt_ctx->xid);\n}\n\n/* Get connections for tcp, ses and tcon */\nstatic int mount_get_conns(struct mount_ctx *mnt_ctx)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = NULL;\n\tstruct cifs_ses *ses = NULL;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(ctx, NULL);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tserver = NULL;\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, ctx);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto out;\n\t}\n\n\tif ((ctx->persistent == true) && (!(ses->server->capabilities &\n\t\t\t\t\t    SMB2_GLOBAL_CAP_PERSISTENT_HANDLES))) {\n\t\tcifs_server_dbg(VFS, \"persistent handles not supported by server\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, ctx);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto out;\n\t}\n\n\t/* if new SMB3.11 POSIX extensions are supported do not remap / and \\ */\n\tif (tcon->posix_extensions)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_POSIX_PATHS;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/*\n\t\t * reset of caps checks mount to see if unix extensions disabled\n\t\t * for just this mount.\n\t\t */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, ctx);\n\t\tspin_lock(&tcon->ses->server->srv_lock);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\tspin_unlock(&tcon->ses->server->srv_lock);\n\t\t\trc = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&tcon->ses->server->srv_lock);\n\t} else\n#endif /* CONFIG_CIFS_ALLOW_INSECURE_LEGACY */\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->pipe && server->ops->qfs_tcon) {\n\t\tserver->ops->qfs_tcon(xid, tcon, cifs_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE) {\n\t\t\tif (tcon->fsDevInfo.DeviceCharacteristics &\n\t\t\t    cpu_to_le32(FILE_READ_ONLY_DEVICE))\n\t\t\t\tcifs_dbg(VFS, \"mounted to read only share\\n\");\n\t\t\telse if ((cifs_sb->mnt_cifs_flags &\n\t\t\t\t  CIFS_MOUNT_RW_CACHE) == 0)\n\t\t\t\tcifs_dbg(VFS, \"read only mount of RW share\\n\");\n\t\t\t/* no need to log a RW mount of a typical RW share */\n\t\t}\n\t}\n\n\t/*\n\t * Clamp the rsize/wsize mount arguments if they are too big for the server\n\t * and set the rsize/wsize to the negotiated values if not passed in by\n\t * the user on mount\n\t */\n\tif ((cifs_sb->ctx->wsize == 0) ||\n\t    (cifs_sb->ctx->wsize > server->ops->negotiate_wsize(tcon, ctx)))\n\t\tcifs_sb->ctx->wsize = server->ops->negotiate_wsize(tcon, ctx);\n\tif ((cifs_sb->ctx->rsize == 0) ||\n\t    (cifs_sb->ctx->rsize > server->ops->negotiate_rsize(tcon, ctx)))\n\t\tcifs_sb->ctx->rsize = server->ops->negotiate_rsize(tcon, ctx);\n\n\t/*\n\t * The cookie is initialized from volume info returned above.\n\t * Inside cifs_fscache_get_super_cookie it checks\n\t * that we do not get super cookie twice.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)\n\t\tcifs_fscache_get_super_cookie(tcon);\n\nout:\n\tmnt_ctx->server = server;\n\tmnt_ctx->ses = ses;\n\tmnt_ctx->tcon = tcon;\n\tmnt_ctx->xid = xid;\n\n\treturn rc;\n}\n\nstatic int mount_setup_tlink(struct cifs_sb_info *cifs_sb, struct cifs_ses *ses,\n\t\t\t     struct cifs_tcon *tcon)\n{\n\tstruct tcon_link *tlink;\n\n\t/* hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\tif (tlink == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\treturn 0;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* Get unique dfs connections */\nstatic int mount_get_dfs_conns(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\n\tmnt_ctx->fs_ctx->nosharesock = true;\n\trc = mount_get_conns(mnt_ctx);\n\tif (mnt_ctx->server) {\n\t\tcifs_dbg(FYI, \"%s: marking tcp session as a dfs connection\\n\", __func__);\n\t\tspin_lock(&mnt_ctx->server->srv_lock);\n\t\tmnt_ctx->server->is_dfs_conn = true;\n\t\tspin_unlock(&mnt_ctx->server->srv_lock);\n\t}\n\treturn rc;\n}\n\n/*\n * cifs_build_path_to_root returns full path to root when we do not have an\n * existing connection (tcon)\n */\nstatic char *\nbuild_unc_path_to_root(const struct smb3_fs_context *ctx,\n\t\t       const struct cifs_sb_info *cifs_sb, bool useppath)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = useppath && ctx->prepath ?\n\t\tstrlen(ctx->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(ctx->UNC, MAX_TREE_SIZE + 1);\n\n\tif (unc_len > MAX_TREE_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(full_path, ctx->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tmemcpy(pos + 1, ctx->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}\n\n/*\n * expand_dfs_referral - Update cifs_sb from dfs referral path\n *\n * cifs_sb->ctx->mount_options will be (re-)allocated to a string containing updated options for the\n * submount.  Otherwise it will be left untouched.\n */\nstatic int expand_dfs_referral(struct mount_ctx *mnt_ctx, const char *full_path,\n\t\t\t       struct dfs_info3_param *referral)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *fake_devname = NULL, *mdata = NULL;\n\n\tmdata = cifs_compose_mount_options(cifs_sb->ctx->mount_options, full_path + 1, referral,\n\t\t\t\t\t   &fake_devname);\n\tif (IS_ERR(mdata)) {\n\t\trc = PTR_ERR(mdata);\n\t\tmdata = NULL;\n\t} else {\n\t\t/*\n\t\t * We can not clear out the whole structure since we no longer have an explicit\n\t\t * function to parse a mount-string. Instead we need to clear out the individual\n\t\t * fields that are no longer valid.\n\t\t */\n\t\tkfree(ctx->prepath);\n\t\tctx->prepath = NULL;\n\t\trc = cifs_setup_volume_info(ctx, mdata, fake_devname);\n\t}\n\tkfree(fake_devname);\n\tkfree(cifs_sb->ctx->mount_options);\n\tcifs_sb->ctx->mount_options = mdata;\n\n\treturn rc;\n}\n#endif\n\n/* TODO: all callers to this are broken. We are not parsing mount_options here\n * we should pass a clone of the original context?\n */\nint\ncifs_setup_volume_info(struct smb3_fs_context *ctx, const char *mntopts, const char *devname)\n{\n\tint rc;\n\n\tif (devname) {\n\t\tcifs_dbg(FYI, \"%s: devname=%s\\n\", __func__, devname);\n\t\trc = smb3_parse_devname(devname, ctx);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to parse %s: %d\\n\", __func__, devname, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (mntopts) {\n\t\tchar *ip;\n\n\t\trc = smb3_parse_opt(mntopts, \"ip\", &ip);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to parse ip options: %d\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = cifs_convert_address((struct sockaddr *)&ctx->dstaddr, ip, strlen(ip));\n\t\tkfree(ip);\n\t\tif (!rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to convert ip address\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ctx->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t} else if (ctx->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", ctx->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncifs_are_all_path_components_accessible(struct TCP_Server_Info *server,\n\t\t\t\t\tunsigned int xid,\n\t\t\t\t\tstruct cifs_tcon *tcon,\n\t\t\t\t\tstruct cifs_sb_info *cifs_sb,\n\t\t\t\t\tchar *full_path,\n\t\t\t\t\tint added_treename)\n{\n\tint rc;\n\tchar *s;\n\tchar sep, tmp;\n\tint skip = added_treename ? 1 : 0;\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\ts = full_path;\n\n\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb, \"\");\n\twhile (rc == 0) {\n\t\t/* skip separators */\n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\t/* next separator */\n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\t\t/*\n\t\t * if the treename is added, we then have to skip the first\n\t\t * part within the separators\n\t\t */\n\t\tif (skip) {\n\t\t\tskip = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * temporarily null-terminate the path at the end of\n\t\t * the current component\n\t\t */\n\t\ttmp = *s;\n\t\t*s = 0;\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\t*s = tmp;\n\t}\n\treturn rc;\n}\n\n/*\n * Check if path is remote (i.e. a DFS share).\n *\n * Return -EREMOTE if it is, otherwise 0 or -errno.\n */\nstatic int is_path_remote(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct TCP_Server_Info *server = mnt_ctx->server;\n\tunsigned int xid = mnt_ctx->xid;\n\tstruct cifs_tcon *tcon = mnt_ctx->tcon;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *full_path;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tbool nodfs = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS;\n#endif\n\n\tif (!server->ops->is_path_accessible)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * cifs_build_path_to_root works only when we have a valid tcon\n\t */\n\tfull_path = cifs_build_path_to_root(ctx, cifs_sb, tcon,\n\t\t\t\t\t    tcon->Flags & SMB_SHARE_IS_IN_DFS);\n\tif (full_path == NULL)\n\t\treturn -ENOMEM;\n\n\tcifs_dbg(FYI, \"%s: full_path: %s\\n\", __func__, full_path);\n\n\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t     full_path);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tif (nodfs) {\n\t\tif (rc == -EREMOTE)\n\t\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* path *might* exist with non-ASCII characters in DFS root\n\t * try again with full path (only if nodfs is not set) */\n\tif (rc == -ENOENT && is_tcon_dfs(tcon))\n\t\trc = cifs_dfs_query_info_nonascii_quirk(xid, tcon, cifs_sb,\n\t\t\t\t\t\t\tfull_path);\n#endif\n\tif (rc != 0 && rc != -EREMOTE)\n\t\tgoto out;\n\n\tif (rc != -EREMOTE) {\n\t\trc = cifs_are_all_path_components_accessible(server, xid, tcon,\n\t\t\tcifs_sb, full_path, tcon->Flags & SMB_SHARE_IS_IN_DFS);\n\t\tif (rc != 0) {\n\t\t\tcifs_server_dbg(VFS, \"cannot query dirs between root and final path, enabling CIFS_MOUNT_USE_PREFIX_PATH\\n\");\n\t\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\t\t\trc = 0;\n\t\t}\n\t}\n\nout:\n\tkfree(full_path);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nstatic void set_root_ses(struct mount_ctx *mnt_ctx)\n{\n\tif (mnt_ctx->ses) {\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tmnt_ctx->ses->ses_count++;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tdfs_cache_add_refsrv_session(&mnt_ctx->mount_id, mnt_ctx->ses);\n\t}\n\tmnt_ctx->root_ses = mnt_ctx->ses;\n}\n\nstatic int is_dfs_mount(struct mount_ctx *mnt_ctx, bool *isdfs, struct dfs_cache_tgt_list *root_tl)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\n\t*isdfs = true;\n\n\trc = mount_get_conns(mnt_ctx);\n\t/*\n\t * If called with 'nodfs' mount option, then skip DFS resolving.  Otherwise unconditionally\n\t * try to get an DFS referral (even cached) to determine whether it is an DFS mount.\n\t *\n\t * Skip prefix path to provide support for DFS referrals from w2k8 servers which don't seem\n\t * to respond with PATH_NOT_COVERED to requests that include the prefix.\n\t */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS) ||\n\t    dfs_cache_find(mnt_ctx->xid, mnt_ctx->ses, cifs_sb->local_nls, cifs_remap(cifs_sb),\n\t\t\t   ctx->UNC + 1, NULL, root_tl)) {\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/* Check if it is fully accessible and then mount it */\n\t\trc = is_path_remote(mnt_ctx);\n\t\tif (!rc)\n\t\t\t*isdfs = false;\n\t\telse if (rc != -EREMOTE)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int connect_dfs_target(struct mount_ctx *mnt_ctx, const char *full_path,\n\t\t\t      const char *ref_path, struct dfs_cache_tgt_iterator *tit)\n{\n\tint rc;\n\tstruct dfs_info3_param ref = {};\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tchar *oldmnt = cifs_sb->ctx->mount_options;\n\n\tcifs_dbg(FYI, \"%s: full_path=%s ref_path=%s target=%s\\n\", __func__, full_path, ref_path,\n\t\t dfs_cache_get_tgt_name(tit));\n\n\trc = dfs_cache_get_tgt_referral(ref_path, tit, &ref);\n\tif (rc)\n\t\tgoto out;\n\n\trc = expand_dfs_referral(mnt_ctx, full_path, &ref);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Connect to new target only if we were redirected (e.g. mount options changed) */\n\tif (oldmnt != cifs_sb->ctx->mount_options) {\n\t\tmount_put_conns(mnt_ctx);\n\t\trc = mount_get_dfs_conns(mnt_ctx);\n\t}\n\tif (!rc) {\n\t\tif (cifs_is_referral_server(mnt_ctx->tcon, &ref))\n\t\t\tset_root_ses(mnt_ctx);\n\t\trc = dfs_cache_update_tgthint(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,\n\t\t\t\t\t      cifs_remap(cifs_sb), ref_path, tit);\n\t}\n\nout:\n\tfree_dfs_info_param(&ref);\n\treturn rc;\n}\n\nstatic int connect_dfs_root(struct mount_ctx *mnt_ctx, struct dfs_cache_tgt_list *root_tl)\n{\n\tint rc;\n\tchar *full_path;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct dfs_cache_tgt_iterator *tit;\n\n\t/* Put initial connections as they might be shared with other mounts.  We need unique dfs\n\t * connections per mount to properly failover, so mount_get_dfs_conns() must be used from\n\t * now on.\n\t */\n\tmount_put_conns(mnt_ctx);\n\tmount_get_dfs_conns(mnt_ctx);\n\tset_root_ses(mnt_ctx);\n\n\tfull_path = build_unc_path_to_root(ctx, cifs_sb, true);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\tmnt_ctx->origin_fullpath = dfs_cache_canonical_path(ctx->UNC, cifs_sb->local_nls,\n\t\t\t\t\t\t\t    cifs_remap(cifs_sb));\n\tif (IS_ERR(mnt_ctx->origin_fullpath)) {\n\t\trc = PTR_ERR(mnt_ctx->origin_fullpath);\n\t\tmnt_ctx->origin_fullpath = NULL;\n\t\tgoto out;\n\t}\n\n\t/* Try all dfs root targets */\n\tfor (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(root_tl);\n\t     tit; tit = dfs_cache_get_next_tgt(root_tl, tit)) {\n\t\trc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->origin_fullpath + 1, tit);\n\t\tif (!rc) {\n\t\t\tmnt_ctx->leaf_fullpath = kstrdup(mnt_ctx->origin_fullpath, GFP_KERNEL);\n\t\t\tif (!mnt_ctx->leaf_fullpath)\n\t\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(full_path);\n\treturn rc;\n}\n\nstatic int __follow_dfs_link(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *full_path;\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tstruct dfs_cache_tgt_iterator *tit;\n\n\tfull_path = build_unc_path_to_root(ctx, cifs_sb, true);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\tkfree(mnt_ctx->leaf_fullpath);\n\tmnt_ctx->leaf_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,\n\t\t\t\t\t\t\t  cifs_remap(cifs_sb));\n\tif (IS_ERR(mnt_ctx->leaf_fullpath)) {\n\t\trc = PTR_ERR(mnt_ctx->leaf_fullpath);\n\t\tmnt_ctx->leaf_fullpath = NULL;\n\t\tgoto out;\n\t}\n\n\t/* Get referral from dfs link */\n\trc = dfs_cache_find(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,\n\t\t\t    cifs_remap(cifs_sb), mnt_ctx->leaf_fullpath + 1, NULL, &tl);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Try all dfs link targets.  If an I/O fails from currently connected DFS target with an\n\t * error other than STATUS_PATH_NOT_COVERED (-EREMOTE), then retry it from other targets as\n\t * specified in MS-DFSC \"3.1.5.2 I/O Operation to Target Fails with an Error Other Than\n\t * STATUS_PATH_NOT_COVERED.\"\n\t */\n\tfor (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(&tl);\n\t     tit; tit = dfs_cache_get_next_tgt(&tl, tit)) {\n\t\trc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->leaf_fullpath + 1, tit);\n\t\tif (!rc) {\n\t\t\trc = is_path_remote(mnt_ctx);\n\t\t\tif (!rc || rc == -EREMOTE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(full_path);\n\tdfs_cache_free_tgts(&tl);\n\treturn rc;\n}\n\nstatic int follow_dfs_link(struct mount_ctx *mnt_ctx)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *full_path;\n\tint num_links = 0;\n\n\tfull_path = build_unc_path_to_root(ctx, cifs_sb, true);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\tkfree(mnt_ctx->origin_fullpath);\n\tmnt_ctx->origin_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,\n\t\t\t\t\t\t\t    cifs_remap(cifs_sb));\n\tkfree(full_path);\n\n\tif (IS_ERR(mnt_ctx->origin_fullpath)) {\n\t\trc = PTR_ERR(mnt_ctx->origin_fullpath);\n\t\tmnt_ctx->origin_fullpath = NULL;\n\t\treturn rc;\n\t}\n\n\tdo {\n\t\trc = __follow_dfs_link(mnt_ctx);\n\t\tif (!rc || rc != -EREMOTE)\n\t\t\tbreak;\n\t} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);\n\n\treturn rc;\n}\n\n/* Set up DFS referral paths for failover */\nstatic void setup_server_referral_paths(struct mount_ctx *mnt_ctx)\n{\n\tstruct TCP_Server_Info *server = mnt_ctx->server;\n\n\tmutex_lock(&server->refpath_lock);\n\tserver->origin_fullpath = mnt_ctx->origin_fullpath;\n\tserver->leaf_fullpath = mnt_ctx->leaf_fullpath;\n\tserver->current_fullpath = mnt_ctx->leaf_fullpath;\n\tmutex_unlock(&server->refpath_lock);\n\tmnt_ctx->origin_fullpath = mnt_ctx->leaf_fullpath = NULL;\n}\n\nint cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\tint rc;\n\tstruct mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tbool isdfs;\n\n\trc = is_dfs_mount(&mnt_ctx, &isdfs, &tl);\n\tif (rc)\n\t\tgoto error;\n\tif (!isdfs)\n\t\tgoto out;\n\n\t/* proceed as DFS mount */\n\tuuid_gen(&mnt_ctx.mount_id);\n\trc = connect_dfs_root(&mnt_ctx, &tl);\n\tdfs_cache_free_tgts(&tl);\n\n\tif (rc)\n\t\tgoto error;\n\n\trc = is_path_remote(&mnt_ctx);\n\tif (rc)\n\t\trc = follow_dfs_link(&mnt_ctx);\n\tif (rc)\n\t\tgoto error;\n\n\tsetup_server_referral_paths(&mnt_ctx);\n\t/*\n\t * After reconnecting to a different server, unique ids won't match anymore, so we disable\n\t * serverino. This prevents dentry revalidation to think the dentry are stale (ESTALE).\n\t */\n\tcifs_autodisable_serverino(cifs_sb);\n\t/*\n\t * Force the use of prefix path to support failover on DFS paths that resolve to targets\n\t * that have different prefix paths.\n\t */\n\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\tkfree(cifs_sb->prepath);\n\tcifs_sb->prepath = ctx->prepath;\n\tctx->prepath = NULL;\n\tuuid_copy(&cifs_sb->dfs_mount_id, &mnt_ctx.mount_id);\n\nout:\n\tfree_xid(mnt_ctx.xid);\n\tcifs_try_adding_channels(cifs_sb, mnt_ctx.ses);\n\treturn mount_setup_tlink(cifs_sb, mnt_ctx.ses, mnt_ctx.tcon);\n\nerror:\n\tdfs_cache_put_refsrv_sessions(&mnt_ctx.mount_id);\n\tkfree(mnt_ctx.origin_fullpath);\n\tkfree(mnt_ctx.leaf_fullpath);\n\tmount_put_conns(&mnt_ctx);\n\treturn rc;\n}\n#else\nint cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\tint rc = 0;\n\tstruct mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };\n\n\trc = mount_get_conns(&mnt_ctx);\n\tif (rc)\n\t\tgoto error;\n\n\tif (mnt_ctx.tcon) {\n\t\trc = is_path_remote(&mnt_ctx);\n\t\tif (rc == -EREMOTE)\n\t\t\trc = -EOPNOTSUPP;\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\tfree_xid(mnt_ctx.xid);\n\treturn mount_setup_tlink(cifs_sb, mnt_ctx.ses, mnt_ctx.tcon);\n\nerror:\n\tmount_put_conns(&mnt_ctx);\n\treturn rc;\n}\n#endif\n\n/*\n * Issue a TREE_CONNECT request.\n */\nint\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\n\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t*bcc_ptr = 0; /* password is null byte */\n\tbcc_ptr++;              /* skip password */\n\t/* already aligned so no need to do it below */\n\n\tif (ses->server->sign)\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tbe32_add_cpu(&pSMB->hdr.smb_buf_length, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif (rc == 0) {\n\t\tbool is_unicode;\n\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = true;\n\t\t\t\ttcon->pipe = true;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrscpy(tcon->tree_name, tree, sizeof(tcon->tree_name));\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nstatic void delayed_free(struct rcu_head *p)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(p, struct cifs_sb_info, rcu);\n\n\tunload_nls(cifs_sb->local_nls);\n\tsmb3_cleanup_fs_context(cifs_sb->ctx);\n\tkfree(cifs_sb);\n}\n\nvoid\ncifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tkfree(cifs_sb->prepath);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tdfs_cache_put_refsrv_sessions(&cifs_sb->dfs_mount_id);\n#endif\n\tcall_rcu(&cifs_sb->rcu, delayed_free);\n}\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses,\n\t\t\tstruct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tspin_lock(&server->srv_lock);\n\tif (!server->ops->need_neg(server) ||\n\t    server->tcpStatus != CifsNeedNegotiate) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn 0;\n\t}\n\tserver->tcpStatus = CifsInNegotiate;\n\tspin_unlock(&server->srv_lock);\n\n\trc = server->ops->negotiate(xid, ses, server);\n\tif (rc == 0) {\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsInNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&server->srv_lock);\n\t} else {\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsInNegotiate)\n\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\tspin_unlock(&server->srv_lock);\n\t}\n\n\treturn rc;\n}\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct TCP_Server_Info *server,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tbool is_binding = false;\n\n\tspin_lock(&ses->ses_lock);\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tscnprintf(ses->ip_addr, sizeof(ses->ip_addr), \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tscnprintf(ses->ip_addr, sizeof(ses->ip_addr), \"%pI4\", &addr->sin_addr);\n\n\tif (ses->ses_status != SES_GOOD &&\n\t    ses->ses_status != SES_NEW &&\n\t    ses->ses_status != SES_NEED_RECON) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn 0;\n\t}\n\n\t/* only send once per connect */\n\tspin_lock(&ses->chan_lock);\n\tif (CIFS_ALL_CHANS_GOOD(ses) ||\n\t    cifs_chan_in_reconnect(ses, server)) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn 0;\n\t}\n\tis_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);\n\tcifs_chan_set_in_reconnect(ses, server);\n\tspin_unlock(&ses->chan_lock);\n\n\tif (!is_binding)\n\t\tses->ses_status = SES_IN_SETUP;\n\tspin_unlock(&ses->ses_lock);\n\n\tif (!is_binding) {\n\t\tses->capabilities = server->capabilities;\n\t\tif (!linuxExtEnabled)\n\t\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\t\tif (ses->auth_key.response) {\n\t\t\tcifs_dbg(FYI, \"Free previous auth_key.response = %p\\n\",\n\t\t\t\t ses->auth_key.response);\n\t\t\tkfree_sensitive(ses->auth_key.response);\n\t\t\tses->auth_key.response = NULL;\n\t\t\tses->auth_key.len = 0;\n\t\t}\n\t}\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, server, nls_info);\n\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_IN_SETUP)\n\t\t\tses->ses_status = SES_NEED_RECON;\n\t\tspin_lock(&ses->chan_lock);\n\t\tcifs_chan_clear_in_reconnect(ses, server);\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t} else {\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_IN_SETUP)\n\t\t\tses->ses_status = SES_GOOD;\n\t\tspin_lock(&ses->chan_lock);\n\t\tcifs_chan_clear_in_reconnect(ses, server);\n\t\tcifs_chan_clear_need_reconnect(ses, server);\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_set_vol_auth(struct smb3_fs_context *ctx, struct cifs_ses *ses)\n{\n\tctx->sectype = ses->sectype;\n\n\t/* krb5 is special, since we don't need username or pw */\n\tif (ctx->sectype == Kerberos)\n\t\treturn 0;\n\n\treturn cifs_set_cifscreds(ctx, ses);\n}\n\nstatic struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb3_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->local_nls = cifs_sb->local_nls;\n\tctx->linux_uid = fsuid;\n\tctx->cred_uid = fsuid;\n\tctx->UNC = master_tcon->tree_name;\n\tctx->retry = master_tcon->retry;\n\tctx->nocase = master_tcon->nocase;\n\tctx->nohandlecache = master_tcon->nohandlecache;\n\tctx->local_lease = master_tcon->local_lease;\n\tctx->no_lease = master_tcon->no_lease;\n\tctx->resilient = master_tcon->use_resilient;\n\tctx->persistent = master_tcon->use_persistent;\n\tctx->handle_timeout = master_tcon->handle_timeout;\n\tctx->no_linux_ext = !master_tcon->unix_ext;\n\tctx->linux_ext = master_tcon->posix_extensions;\n\tctx->sectype = master_tcon->ses->sectype;\n\tctx->sign = master_tcon->ses->sign;\n\tctx->seal = master_tcon->seal;\n\tctx->witness = master_tcon->use_witness;\n\n\trc = cifs_set_vol_auth(ctx, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, ctx);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server, 0);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, ctx);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, ctx);\n#endif /* CONFIG_CIFS_ALLOW_INSECURE_LEGACY */\n\nout:\n\tkfree(ctx->username);\n\tkfree_sensitive(ctx->password);\n\tkfree(ctx);\n\n\treturn tcon;\n}\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}\n\n/* find and return a tlink with given uid */\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}\n\n/* insert a tcon_link into the tree */\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}\n\n/*\n * Find or construct an appropriate tcon given a cifs_sb and the fsuid of the\n * current task.\n *\n * If the superblock doesn't refer to a multiuser mount, then just return\n * the master tcon for the mount.\n *\n * First, search the rbtree for an existing tcon for this fsuid. If one\n * exists, then check to see if it's pending construction. If it is then wait\n * for construction to complete. Once it's no longer pending, check to see if\n * it failed and either return an error or retry construction, depending on\n * the timeout.\n *\n * If one doesn't exist then insert a new tcon_link struct into the tree and\n * try to construct a new one.\n */\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}\n\n/*\n * periodic workqueue job that scans tcon_tree for a superblock and closes\n * out tcons.\n */\nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* Update dfs referral path of superblock */\nstatic int update_server_fullpath(struct TCP_Server_Info *server, struct cifs_sb_info *cifs_sb,\n\t\t\t\t  const char *target)\n{\n\tint rc = 0;\n\tsize_t len = strlen(target);\n\tchar *refpath, *npath;\n\n\tif (unlikely(len < 2 || *target != '\\\\'))\n\t\treturn -EINVAL;\n\n\tif (target[1] == '\\\\') {\n\t\tlen += 1;\n\t\trefpath = kmalloc(len, GFP_KERNEL);\n\t\tif (!refpath)\n\t\t\treturn -ENOMEM;\n\n\t\tscnprintf(refpath, len, \"%s\", target);\n\t} else {\n\t\tlen += sizeof(\"\\\\\");\n\t\trefpath = kmalloc(len, GFP_KERNEL);\n\t\tif (!refpath)\n\t\t\treturn -ENOMEM;\n\n\t\tscnprintf(refpath, len, \"\\\\%s\", target);\n\t}\n\n\tnpath = dfs_cache_canonical_path(refpath, cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tkfree(refpath);\n\n\tif (IS_ERR(npath)) {\n\t\trc = PTR_ERR(npath);\n\t} else {\n\t\tmutex_lock(&server->refpath_lock);\n\t\tkfree(server->leaf_fullpath);\n\t\tserver->leaf_fullpath = npath;\n\t\tmutex_unlock(&server->refpath_lock);\n\t\tserver->current_fullpath = server->leaf_fullpath;\n\t}\n\treturn rc;\n}\n\nstatic int target_share_matches_server(struct TCP_Server_Info *server, const char *tcp_host,\n\t\t\t\t       size_t tcp_host_len, char *share, bool *target_match)\n{\n\tint rc = 0;\n\tconst char *dfs_host;\n\tsize_t dfs_host_len;\n\n\t*target_match = true;\n\textract_unc_hostname(share, &dfs_host, &dfs_host_len);\n\n\t/* Check if hostnames or addresses match */\n\tif (dfs_host_len != tcp_host_len || strncasecmp(dfs_host, tcp_host, dfs_host_len) != 0) {\n\t\tcifs_dbg(FYI, \"%s: %.*s doesn't match %.*s\\n\", __func__, (int)dfs_host_len,\n\t\t\t dfs_host, (int)tcp_host_len, tcp_host);\n\t\trc = match_target_ip(server, dfs_host, dfs_host_len, target_match);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: failed to match target ip: %d\\n\", __func__, rc);\n\t}\n\treturn rc;\n}\n\nstatic int __tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t     struct cifs_sb_info *cifs_sb, char *tree, bool islink,\n\t\t\t\t     struct dfs_cache_tgt_list *tl)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tconst struct smb_version_operations *ops = server->ops;\n\tstruct cifs_tcon *ipc = tcon->ses->tcon_ipc;\n\tchar *share = NULL, *prefix = NULL;\n\tconst char *tcp_host;\n\tsize_t tcp_host_len;\n\tstruct dfs_cache_tgt_iterator *tit;\n\tbool target_match;\n\n\textract_unc_hostname(server->hostname, &tcp_host, &tcp_host_len);\n\n\ttit = dfs_cache_get_tgt_iterator(tl);\n\tif (!tit) {\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Try to tree connect to all dfs targets */\n\tfor (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {\n\t\tconst char *target = dfs_cache_get_tgt_name(tit);\n\t\tstruct dfs_cache_tgt_list ntl = DFS_CACHE_TGT_LIST_INIT(ntl);\n\n\t\tkfree(share);\n\t\tkfree(prefix);\n\t\tshare = prefix = NULL;\n\n\t\t/* Check if share matches with tcp ses */\n\t\trc = dfs_cache_get_tgt_share(server->current_fullpath + 1, tit, &share, &prefix);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to parse target share: %d\\n\", __func__, rc);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = target_share_matches_server(server, tcp_host, tcp_host_len, share,\n\t\t\t\t\t\t &target_match);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (!target_match) {\n\t\t\trc = -EHOSTUNREACH;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ipc->need_reconnect) {\n\t\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\t\t\trc = ops->tree_connect(xid, ipc->ses, tree, ipc, cifs_sb->local_nls);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\%s\", share);\n\t\tif (!islink) {\n\t\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If no dfs referrals were returned from link target, then just do a TREE_CONNECT\n\t\t * to it.  Otherwise, cache the dfs referral and then mark current tcp ses for\n\t\t * reconnect so either the demultiplex thread or the echo worker will reconnect to\n\t\t * newly resolved target.\n\t\t */\n\t\tif (dfs_cache_find(xid, tcon->ses, cifs_sb->local_nls, cifs_remap(cifs_sb), target,\n\t\t\t\t   NULL, &ntl)) {\n\t\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = dfs_cache_noreq_update_tgthint(server->current_fullpath + 1, tit);\n\t\t\tif (!rc)\n\t\t\t\trc = cifs_update_super_prepath(cifs_sb, prefix);\n\t\t} else {\n\t\t\t/* Target is another dfs share */\n\t\t\trc = update_server_fullpath(server, cifs_sb, target);\n\t\t\tdfs_cache_free_tgts(tl);\n\n\t\t\tif (!rc) {\n\t\t\t\trc = -EREMOTE;\n\t\t\t\tlist_replace_init(&ntl.tl_list, &tl->tl_list);\n\t\t\t} else\n\t\t\t\tdfs_cache_free_tgts(&ntl);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tkfree(share);\n\tkfree(prefix);\n\n\treturn rc;\n}\n\nstatic int tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t   struct cifs_sb_info *cifs_sb, char *tree, bool islink,\n\t\t\t\t   struct dfs_cache_tgt_list *tl)\n{\n\tint rc;\n\tint num_links = 0;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tdo {\n\t\trc = __tree_connect_dfs_target(xid, tcon, cifs_sb, tree, islink, tl);\n\t\tif (!rc || rc != -EREMOTE)\n\t\t\tbreak;\n\t} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);\n\t/*\n\t * If we couldn't tree connect to any targets from last referral path, then retry from\n\t * original referral path.\n\t */\n\tif (rc && server->current_fullpath != server->origin_fullpath) {\n\t\tserver->current_fullpath = server->origin_fullpath;\n\t\tcifs_signal_cifsd_for_reconnect(server, true);\n\t}\n\n\tdfs_cache_free_tgts(tl);\n\treturn rc;\n}\n\nint cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tconst struct smb_version_operations *ops = server->ops;\n\tstruct super_block *sb = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);\n\tchar *tree;\n\tstruct dfs_info3_param ref = {0};\n\n\t/* only send once per connect */\n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->ses->ses_status != SES_GOOD ||\n\t    (tcon->status != TID_NEW &&\n\t    tcon->status != TID_NEED_TCON)) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn 0;\n\t}\n\ttcon->status = TID_IN_TCON;\n\tspin_unlock(&tcon->tc_lock);\n\n\ttree = kzalloc(MAX_TREE_SIZE, GFP_KERNEL);\n\tif (!tree) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->ipc) {\n\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, nlsc);\n\t\tgoto out;\n\t}\n\n\tsb = cifs_get_tcp_super(server);\n\tif (IS_ERR(sb)) {\n\t\trc = PTR_ERR(sb);\n\t\tcifs_dbg(VFS, \"%s: could not find superblock: %d\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\n\tcifs_sb = CIFS_SB(sb);\n\n\t/* If it is not dfs or there was no cached dfs referral, then reconnect to same share */\n\tif (!server->current_fullpath ||\n\t    dfs_cache_noreq_find(server->current_fullpath + 1, &ref, &tl)) {\n\t\trc = ops->tree_connect(xid, tcon->ses, tcon->tree_name, tcon, cifs_sb->local_nls);\n\t\tgoto out;\n\t}\n\n\trc = tree_connect_dfs_target(xid, tcon, cifs_sb, tree, ref.server_type == DFS_TYPE_LINK,\n\t\t\t\t     &tl);\n\tfree_dfs_info_param(&ref);\n\nout:\n\tkfree(tree);\n\tcifs_put_tcp_super(sb);\n\n\tif (rc) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_NEED_TCON;\n\t\tspin_unlock(&tcon->tc_lock);\n\t} else {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_GOOD;\n\t\tspin_unlock(&tcon->tc_lock);\n\t\ttcon->need_reconnect = false;\n\t}\n\n\treturn rc;\n}\n#else\nint cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)\n{\n\tint rc;\n\tconst struct smb_version_operations *ops = tcon->ses->server->ops;\n\n\t/* only send once per connect */\n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->ses->ses_status != SES_GOOD ||\n\t    (tcon->status != TID_NEW &&\n\t    tcon->status != TID_NEED_TCON)) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn 0;\n\t}\n\ttcon->status = TID_IN_TCON;\n\tspin_unlock(&tcon->tc_lock);\n\n\trc = ops->tree_connect(xid, tcon->ses, tcon->tree_name, tcon, nlsc);\n\tif (rc) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_NEED_TCON;\n\t\tspin_unlock(&tcon->tc_lock);\n\t} else {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_GOOD;\n\t\ttcon->need_reconnect = false;\n\t\tspin_unlock(&tcon->tc_lock);\n\t}\n\n\treturn rc;\n}\n#endif\n"], "filenames": ["fs/cifs/connect.c"], "buggy_code_start_loc": [1586], "buggy_code_end_loc": [1586], "fixing_code_start_loc": [1587], "fixing_code_end_loc": [1588], "type": "CWE-416", "message": "A use-after-free flaw was found in reconn_set_ipaddr_from_hostname in fs/cifs/connect.c in the Linux kernel. The issue occurs when it forgets to set the free pointer server->hostname to NULL, leading to an invalid pointer request.", "other": {"cve": {"id": "CVE-2023-1195", "sourceIdentifier": "secalert@redhat.com", "published": "2023-05-18T22:15:09.373", "lastModified": "2023-05-26T18:27:29.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use-after-free flaw was found in reconn_set_ipaddr_from_hostname in fs/cifs/connect.c in the Linux kernel. The issue occurs when it forgets to set the free pointer server->hostname to NULL, leading to an invalid pointer request."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1", "matchCriteriaId": "9064B383-DD48-40A2-8947-F5BA6E6B6713"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "E7E331DA-1FB0-4DEC-91AC-7DA69D461C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "17F0B248-42CF-4AE6-A469-BB1BAE7F4705"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/153695d36ead0ccc4d0256953c751cabf673e621", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/153695d36ead0ccc4d0256953c751cabf673e621"}}