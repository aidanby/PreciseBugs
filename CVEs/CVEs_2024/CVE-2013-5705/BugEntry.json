{"buggy_code": ["/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2013 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include <stdlib.h>\n\n#include \"apr_global_mutex.h\"\n\n#include \"modsecurity.h\"\n#include \"msc_parsers.h\"\n#include \"msc_util.h\"\n#include \"msc_xml.h\"\n#include \"apr_version.h\"\n\nunsigned long int DSOLOCAL unicode_codepage = 0;\n\nint DSOLOCAL *unicode_map_table = NULL;\n\n/**\n * Format an alert message.\n */\nconst char * msc_alert_message(modsec_rec *msr, msre_actionset *actionset, const char *action_message,\n    const char *rule_message)\n{\n    const char *message = NULL;\n\n    if (rule_message == NULL) rule_message = \"Unknown error.\";\n\n    if (action_message == NULL) {\n        message = apr_psprintf(msr->mp, \"%s%s\",\n            rule_message, msre_format_metadata(msr, actionset));\n    }\n    else {\n        message = apr_psprintf(msr->mp, \"%s %s%s\", action_message,\n            rule_message, msre_format_metadata(msr, actionset));\n    }\n\n    return message;\n}\n\n/**\n * Log an alert message to the log, adding the rule metadata at the end.\n */\nvoid msc_alert(modsec_rec *msr, int level, msre_actionset *actionset, const char *action_message,\n    const char *rule_message)\n{\n    const char *message = msc_alert_message(msr, actionset, action_message, rule_message);\n\n    msr_log(msr, level, \"%s\", message);\n}\n\n#if 0\n/**\n * Return phase name associated with the given phase number.\n */\nstatic const char *phase_name(int phase) {\n    switch(phase) {\n        case 1 :\n            return \"REQUEST_HEADERS\";\n            break;\n        case 2 :\n            return \"REQUEST_BODY\";\n            break;\n        case 3 :\n            return \"RESPONSE_HEADERS\";\n            break;\n        case 4 :\n            return \"RESPONSE_BODY\";\n            break;\n        case 5 :\n            return \"LOGGING\";\n            break;\n    }\n    \n    return \"INVALID\";\n}\n#endif\n\n/**\n * Creates and initialises a ModSecurity engine instance.\n */\nmsc_engine *modsecurity_create(apr_pool_t *mp, int processing_mode) {\n    msc_engine *msce = NULL;\n\n    msce = apr_pcalloc(mp, sizeof(msc_engine));\n    if (msce == NULL) return NULL;\n\n    msce->mp = mp;\n    msce->processing_mode = processing_mode;\n\n    msce->msre = msre_engine_create(msce->mp);\n    if (msce->msre == NULL) return NULL;\n    msre_engine_register_default_variables(msce->msre);\n    msre_engine_register_default_operators(msce->msre);\n    msre_engine_register_default_tfns(msce->msre);\n    msre_engine_register_default_actions(msce->msre);\n    // TODO: msre_engine_register_default_reqbody_processors(msce->msre);\n\n    return msce;\n}\n\n/**\n * Initialise the modsecurity engine. This function must be invoked\n * after configuration processing is complete as Apache needs to know the\n * username it is running as.\n */\nint modsecurity_init(msc_engine *msce, apr_pool_t *mp) {\n    apr_status_t rc;\n\n    /* Serial audit log mutext */\n    rc = apr_global_mutex_create(&msce->auditlog_lock, NULL, APR_LOCK_DEFAULT, mp);\n    if (rc != APR_SUCCESS) {\n        //ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, \"mod_security: Could not create modsec_auditlog_lock\");\n        //return HTTP_INTERNAL_SERVER_ERROR;\n        return -1;\n    }\n\n#if !defined(MSC_TEST)\n#ifdef __SET_MUTEX_PERMS\n#if AP_SERVER_MAJORVERSION_NUMBER > 1 && AP_SERVER_MINORVERSION_NUMBER > 2\n    rc = ap_unixd_set_global_mutex_perms(msce->auditlog_lock);\n#else\n    rc = unixd_set_global_mutex_perms(msce->auditlog_lock);\n#endif\n    if (rc != APR_SUCCESS) {\n        // ap_log_error(APLOG_MARK, APLOG_ERR, rc, s, \"mod_security: Could not set permissions on modsec_auditlog_lock; check User and Group directives\");\n        // return HTTP_INTERNAL_SERVER_ERROR;\n        return -1;\n    }\n#endif /* SET_MUTEX_PERMS */\n\n    rc = apr_global_mutex_create(&msce->geo_lock, NULL, APR_LOCK_DEFAULT, mp);\n    if (rc != APR_SUCCESS) {\n        return -1;\n    }\n\n#ifdef __SET_MUTEX_PERMS\n#if AP_SERVER_MAJORVERSION_NUMBER > 1 && AP_SERVER_MINORVERSION_NUMBER > 2\n    rc = ap_unixd_set_global_mutex_perms(msce->geo_lock);\n#else\n    rc = unixd_set_global_mutex_perms(msce->geo_lock);\n#endif\n    if (rc != APR_SUCCESS) {\n        return -1;\n    }\n#endif /* SET_MUTEX_PERMS */\n#endif\n\n    return 1;\n}\n\n/**\n * Performs per-child (new process) initialisation.\n */\nvoid modsecurity_child_init(msc_engine *msce) {\n    /* Need to call this once per process before any other XML calls. */\n    xmlInitParser();\n\n    if (msce->auditlog_lock != NULL) {\n        apr_status_t rc = apr_global_mutex_child_init(&msce->auditlog_lock, NULL, msce->mp);\n        if (rc != APR_SUCCESS) {\n            // ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, \"Failed to child-init auditlog mutex\");\n        }\n    }\n\n    if (msce->geo_lock != NULL) {\n        apr_status_t rc = apr_global_mutex_child_init(&msce->geo_lock, NULL, msce->mp);\n        if (rc != APR_SUCCESS) {\n            // ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, \"Failed to child-init geo mutex\");\n        }\n    }\n\n}\n\n/**\n * Releases resources held by engine instance.\n */\nvoid modsecurity_shutdown(msc_engine *msce) {\n    if (msce == NULL) return;\n}\n\n/**\n *\n */\nstatic void modsecurity_persist_data(modsec_rec *msr) {\n    const apr_array_header_t *arr;\n    apr_table_entry_t *te;\n    apr_time_t time_before, time_after;\n    int i;\n\n    time_before = apr_time_now();\n\n    /* Collections, store & remove stale. */\n    arr = apr_table_elts(msr->collections);\n    te = (apr_table_entry_t *)arr->elts;\n    for (i = 0; i < arr->nelts; i++) {\n        apr_table_t *col = (apr_table_t *)te[i].val;\n\n        /* Only store those collections that changed. */\n        if (apr_table_get(msr->collections_dirty, te[i].key)) {\n            collection_store(msr, col);\n        }\n    }\n\n    time_after = apr_time_now();\n\n    msr->time_storage_write += time_after - time_before;\n\n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Recording persistent data took %\" APR_TIME_T_FMT\n            \" microseconds.\", msr->time_gc);\n    }\n\n    /* Remove stale collections. */\n    srand(time(NULL));\n\n    if (rand() < RAND_MAX/100) {\n        arr = apr_table_elts(msr->collections);\n        te = (apr_table_entry_t *)arr->elts;\n        for (i = 0; i < arr->nelts; i++) {\n            collections_remove_stale(msr, te[i].key);\n        }\n\n        msr->time_gc = apr_time_now() - time_after;\n\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Garbage collection took %\" APR_TIME_T_FMT\n                \" microseconds.\", msr->time_gc);\n        }\n    }\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_tx_cleanup(void *data) {\n    modsec_rec *msr = (modsec_rec *)data;\n    char *my_error_msg = NULL;\n    \n    if (msr == NULL) return APR_SUCCESS;    \n\n    /* Multipart processor cleanup. */\n    if (msr->mpd != NULL) multipart_cleanup(msr);\n\n    /* XML processor cleanup. */\n    if (msr->xml != NULL) xml_cleanup(msr);\n\n    // TODO: Why do we ignore return code here?\n    modsecurity_request_body_clear(msr, &my_error_msg);\n    if (my_error_msg != NULL) {\n        msr_log(msr, 1, \"%s\", my_error_msg);\n    }\n\n#if defined(WITH_LUA)\n    #ifdef CACHE_LUA\n    if(msr->L != NULL)  lua_close(msr->L);\n    #endif\n#endif\n\n    return APR_SUCCESS;\n}\n\n/**\n *\n */\napr_status_t modsecurity_tx_init(modsec_rec *msr) {\n    const char *s = NULL;\n    const apr_array_header_t *arr;\n    char *semicolon = NULL;\n    char *comma = NULL;\n    apr_table_entry_t *te;\n    int i;\n\n    /* Register TX cleanup */\n    apr_pool_cleanup_register(msr->mp, msr, modsecurity_tx_cleanup, apr_pool_cleanup_null);\n\n    /* Initialise C-L */\n    msr->request_content_length = -1;\n    s = apr_table_get(msr->request_headers, \"Content-Length\");\n    if (s != NULL) {\n        msr->request_content_length = strtol(s, NULL, 10);\n    }\n\n    /* Figure out whether this request has a body */\n    msr->reqbody_chunked = 0;\n    msr->reqbody_should_exist = 0;\n    if (msr->request_content_length == -1) {\n        /* There's no C-L, but is chunked encoding used? */\n        char *transfer_encoding = (char *)apr_table_get(msr->request_headers, \"Transfer-Encoding\");\n        if ((transfer_encoding != NULL)&&(strstr(transfer_encoding, \"chunked\") != NULL)) {\n            msr->reqbody_should_exist = 1;\n            msr->reqbody_chunked = 1;\n        }\n    } else {\n        /* C-L found */\n        msr->reqbody_should_exist = 1;\n    }\n\n    /* Initialise C-T */\n    msr->request_content_type = NULL;\n    s = apr_table_get(msr->request_headers, \"Content-Type\");\n    if (s != NULL) msr->request_content_type = s;\n\n    /* Decide what to do with the request body. */\n    if ((msr->request_content_type != NULL)\n       && (strncasecmp(msr->request_content_type, \"application/x-www-form-urlencoded\", 33) == 0))\n    {\n        /* Always place POST requests with\n         * \"application/x-www-form-urlencoded\" payloads in memory.\n         */\n        msr->msc_reqbody_storage = MSC_REQBODY_MEMORY;\n        msr->msc_reqbody_spilltodisk = 0;\n        msr->msc_reqbody_processor = \"URLENCODED\";\n    } else {\n        /* If the C-L is known and there's more data than\n         * our limit go to disk straight away.\n         */\n        if ((msr->request_content_length != -1)\n           && (msr->request_content_length > msr->txcfg->reqbody_inmemory_limit))\n        {\n            msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        }\n\n        /* In all other cases, try using the memory first\n         * but switch over to disk for larger bodies.\n         */\n        msr->msc_reqbody_storage = MSC_REQBODY_MEMORY;\n        msr->msc_reqbody_spilltodisk = 1;\n\n        if (msr->request_content_type != NULL) {\n            if (strncasecmp(msr->request_content_type, \"multipart/form-data\", 19) == 0) {\n                msr->msc_reqbody_processor = \"MULTIPART\";\n            }\n        }\n    }\n\n    /* Check if we are forcing buffering, then use memory only. */\n    if (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF) {\n        msr->msc_reqbody_storage = MSC_REQBODY_MEMORY;\n        msr->msc_reqbody_spilltodisk = 0;\n    }\n\n    /* Initialise arguments */\n    msr->arguments = apr_table_make(msr->mp, 32);\n    if (msr->arguments == NULL) return -1;\n    if (msr->query_string != NULL) {\n        int invalid_count = 0;\n\n        if (parse_arguments(msr, msr->query_string, strlen(msr->query_string),\n            msr->txcfg->argument_separator, \"QUERY_STRING\", msr->arguments,\n            &invalid_count) < 0)\n        {\n            msr_log(msr, 1, \"Initialisation: Error occurred while parsing QUERY_STRING arguments.\");\n            return -1;\n        }\n\n        if (invalid_count) {\n            msr->urlencoded_error = 1;\n        }\n    }\n\n    msr->arguments_to_sanitize = apr_table_make(msr->mp, 16);\n    if (msr->arguments_to_sanitize == NULL) return -1;\n    msr->request_headers_to_sanitize = apr_table_make(msr->mp, 16);\n    if (msr->request_headers_to_sanitize == NULL) return -1;\n    msr->response_headers_to_sanitize = apr_table_make(msr->mp, 16);\n    if (msr->response_headers_to_sanitize == NULL) return -1;\n    msr->pattern_to_sanitize = apr_table_make(msr->mp, 32);\n    if (msr->pattern_to_sanitize == NULL) return -1;\n\n    /* remove targets */\n    msr->removed_targets = apr_table_make(msr->mp, 16);\n    if (msr->removed_targets == NULL) return -1;\n\n    /* Initialise cookies */\n    msr->request_cookies = apr_table_make(msr->mp, 16);\n    if (msr->request_cookies == NULL) return -1;\n\n    /* Initialize matched vars */\n    msr->matched_vars = apr_table_make(msr->mp, 8);\n    if (msr->matched_vars == NULL) return -1;\n    apr_table_clear(msr->matched_vars);\n\n    msr->perf_rules = apr_table_make(msr->mp, 8);\n    if (msr->perf_rules == NULL) return -1;\n    apr_table_clear(msr->perf_rules);\n\n    /* Locate the cookie headers and parse them */\n    arr = apr_table_elts(msr->request_headers);\n    te = (apr_table_entry_t *)arr->elts;\n    for (i = 0; i < arr->nelts; i++) {\n        if (strcasecmp(te[i].key, \"Cookie\") == 0) {\n            if (msr->txcfg->cookie_format == COOKIES_V0) {\n                semicolon = apr_pstrdup(msr->mp, te[i].val);\n                while((*semicolon != 0)&&(*semicolon != ';')) semicolon++;\n                if(*semicolon == ';')    {\n                    parse_cookies_v0(msr, te[i].val, msr->request_cookies, \";\");\n                } else  {\n                    comma = apr_pstrdup(msr->mp, te[i].val);\n                    while((*comma != 0)&&(*comma != ',')) comma++;\n                    if(*comma == ',')    {\n                        comma++;\n                        if(*comma == 0x20)   {// looks like comma is the separator\n                            if (msr->txcfg->debuglog_level >= 5) {\n                                msr_log(msr, 5, \"Cookie v0 parser: Using comma as a separator. Semi-colon was not identified!\");\n                            }\n                            parse_cookies_v0(msr, te[i].val, msr->request_cookies, \",\");\n                        } else {\n                            parse_cookies_v0(msr, te[i].val, msr->request_cookies, \";\");\n                        }\n                    } else  {\n                        parse_cookies_v0(msr, te[i].val, msr->request_cookies, \";\");\n                    }\n                }\n            } else {\n                parse_cookies_v1(msr, te[i].val, msr->request_cookies);\n            }\n        }\n    }\n\n    /* Collections. */\n    msr->tx_vars = apr_table_make(msr->mp, 32);\n    if (msr->tx_vars == NULL) return -1;\n\n    msr->geo_vars = apr_table_make(msr->mp, 8);\n    if (msr->geo_vars == NULL) return -1;\n\n    msr->collections_original = apr_table_make(msr->mp, 8);\n    if (msr->collections_original == NULL) return -1;\n    msr->collections = apr_table_make(msr->mp, 8);\n    if (msr->collections == NULL) return -1;\n    msr->collections_dirty = apr_table_make(msr->mp, 8);\n    if (msr->collections_dirty == NULL) return -1;\n\n    /* Other */\n    msr->tcache = NULL;\n    msr->tcache_items = 0;\n\n    msr->matched_rules = apr_array_make(msr->mp, 16, sizeof(void *));\n    if (msr->matched_rules == NULL) return -1;\n\n    msr->matched_var = (msc_string *)apr_pcalloc(msr->mp, sizeof(msc_string));\n    if (msr->matched_var == NULL) return -1;\n\n    msr->highest_severity = 255; /* high, invalid value */\n\n    msr->removed_rules = apr_array_make(msr->mp, 16, sizeof(char *));\n    if (msr->removed_rules == NULL) return -1;\n\n    msr->removed_rules_tag = apr_array_make(msr->mp, 16, sizeof(char *));\n    if (msr->removed_rules_tag == NULL) return -1;\n\n    msr->removed_rules_msg = apr_array_make(msr->mp, 16, sizeof(char *));\n    if (msr->removed_rules_msg == NULL) return -1;\n\n    return 1;\n}\n\n/**\n *\n */\nstatic int is_response_status_relevant(modsec_rec *msr, int status) {\n    char *my_error_msg = NULL;\n    apr_status_t rc;\n    char buf[32];\n\n    /* ENH: Setting is_relevant here will cause an audit even if noauditlog\n     * was set for the last rule that matched.  Is this what we want?\n     */\n\n    if ((msr->txcfg->auditlog_relevant_regex == NULL)\n        ||(msr->txcfg->auditlog_relevant_regex == NOT_SET_P))\n    {\n        return 0;\n    }\n\n    apr_snprintf(buf, sizeof(buf), \"%d\", status);\n\n    rc = msc_regexec(msr->txcfg->auditlog_relevant_regex, buf, strlen(buf), &my_error_msg);\n    if (rc >= 0) return 1;\n    if (rc == PCRE_ERROR_NOMATCH) return 0;\n\n    msr_log(msr, 1, \"Regex processing failed (rc %d): %s\", rc, my_error_msg);\n    \n    return 0;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_request_headers(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n    \n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Starting phase REQUEST_HEADERS.\");\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase1 = apr_time_now() - time_before;\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_request_body(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n\n    \n    if ((msr->allow_scope == ACTION_ALLOW_REQUEST)||(msr->allow_scope == ACTION_ALLOW)) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase REQUEST_BODY (allow used).\");\n        }\n        \n        return 0;\n    } else {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Starting phase REQUEST_BODY.\");\n        }\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase2 = apr_time_now() - time_before;\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_response_headers(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n    \n    if (msr->allow_scope == ACTION_ALLOW) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase RESPONSE_HEADERS (allow used).\");\n        }\n        \n        return 0;\n    } else {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Starting phase RESPONSE_HEADERS.\");\n        }\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase3 = apr_time_now() - time_before;\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_response_body(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n    \n    if (msr->allow_scope == ACTION_ALLOW) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase RESPONSE_BODY (allow used).\");\n        }\n        \n        return 0;\n    } else {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Starting phase RESPONSE_BODY.\");\n        }\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase4 = apr_time_now() - time_before;\n\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_logging(modsec_rec *msr) {\n    apr_time_t time_before, time_after;\n    \n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Starting phase LOGGING.\");\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    modsecurity_persist_data(msr);\n    \n    time_after = apr_time_now();\n    msr->time_phase5 = time_after - time_before;\n\n    /* Is this request relevant for logging purposes? */\n    if (msr->is_relevant == 0) {\n        /* Check the status */\n        msr->is_relevant += is_response_status_relevant(msr, msr->r->status);\n\n        /* If we processed two requests and statuses are different then\n         * check the other status too.\n         */\n        if (msr->r_early->status != msr->r->status) {\n            msr->is_relevant += is_response_status_relevant(msr, msr->r_early->status);\n        }\n    }\n\n    /* Figure out if we want to keep the files (if there are any, of course). */\n    if ((msr->txcfg->upload_keep_files == KEEP_FILES_ON)\n        || ((msr->txcfg->upload_keep_files == KEEP_FILES_RELEVANT_ONLY)&&(msr->is_relevant)))\n    {\n        msr->upload_remove_files = 0;\n    } else {\n        msr->upload_remove_files = 1;\n    }\n\n    /* Are we configured for audit logging? */\n    switch(msr->txcfg->auditlog_flag) {\n        case AUDITLOG_OFF :\n            if (msr->txcfg->debuglog_level >= 4) {\n                msr_log(msr, 4, \"Audit log: Not configured to run for this request.\");\n            }\n            \n            return DECLINED;\n            break;\n\n        case AUDITLOG_RELEVANT :\n            if (msr->is_relevant == 0) {\n                if (msr->txcfg->debuglog_level >= 4) {\n                    msr_log(msr, 4, \"Audit log: Ignoring a non-relevant request.\");\n                }\n                \n                return DECLINED;\n            }\n            break;\n\n        case AUDITLOG_ON :\n            /* All right, do nothing */\n            break;\n\n        default :\n            msr_log(msr, 1, \"Internal error: Could not determine if auditing is needed, so forcing auditing.\");\n            break;\n    }\n\n    /* Invoke the Audit logger */\n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Audit log: Logging this transaction.\");\n    }\n\n    sec_audit_logger(msr);\n    \n    msr->time_logging = apr_time_now() - time_after;    \n\n    return 0;\n}\n\n/**\n * Processes one transaction phase. The phase number does not\n * need to be explicitly provided since it's already available\n * in the modsec_rec structure.\n */\napr_status_t modsecurity_process_phase(modsec_rec *msr, unsigned int phase) {\n    /* Check if we should run. */\n    if ((msr->was_intercepted)&&(phase != PHASE_LOGGING)) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase %d as request was already intercepted.\", phase);\n        }\n        \n        return 0;\n    }\n\n    /* Do not process the same phase twice. */\n    if (msr->phase >= phase) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase %d because it was previously run (at %d now).\",\n                phase, msr->phase);\n        }\n        \n        return 0;\n    }\n\n    msr->phase = phase;\n\n    /* Clear out the transformation cache at the start of each phase */\n    if (msr->txcfg->cache_trans == MODSEC_CACHE_ENABLED) {\n        if (msr->tcache) {\n            apr_hash_index_t *hi;\n            void *dummy;\n            apr_table_t *tab;\n            const void *key;\n            apr_ssize_t klen;\n            #ifdef CACHE_DEBUG\n            apr_pool_t *mp = msr->msc_rule_mptmp;\n            const apr_array_header_t *ctarr;\n            const apr_table_entry_t *ctelts;\n            msre_cache_rec *rec;\n            int cn = 0;\n            int ri;\n            #else\n            apr_pool_t *mp = msr->mp;\n            #endif\n\n            for (hi = apr_hash_first(mp, msr->tcache); hi; hi = apr_hash_next(hi)) {\n                apr_hash_this(hi, &key, &klen, &dummy);\n                tab = (apr_table_t *)dummy;\n\n                if (tab == NULL) continue;\n\n                #ifdef CACHE_DEBUG\n                /* Dump the cache out as we clear */\n                ctarr = apr_table_elts(tab);\n                ctelts = (const apr_table_entry_t*)ctarr->elts;\n                for (ri = 0; ri < ctarr->nelts; ri++) {\n                    cn++;\n                    rec = (msre_cache_rec *)ctelts[ri].val;\n                    if (rec->changed) {\n                        if (msr->txcfg->debuglog_level >= 9) {\n                            msr_log(msr, 9, \"CACHE: %5d) hits=%d key=%pp %x;%s=\\\"%s\\\" (%pp - %pp)\",\n                                cn, rec->hits, key, rec->num, rec->path, log_escape_nq_ex(mp, rec->val, rec->val_len),\n                                rec->val, rec->val + rec->val_len);\n                        }\n                    }\n                    else {\n                        if (msr->txcfg->debuglog_level >= 9) {\n                            msr_log(msr, 9, \"CACHE: %5d) hits=%d key=%pp %x;%s=<no change>\",\n                                cn, rec->hits, key, rec->num, rec->path);\n                        }\n                    }\n                }\n                #endif\n\n                apr_table_clear(tab);\n                apr_hash_set(msr->tcache, key, klen, NULL);\n            }\n\n            if (msr->txcfg->debuglog_level >= 9) {\n                msr_log(msr, 9, \"Cleared transformation cache for phase %d\", msr->phase);\n            }\n        }\n\n        msr->tcache_items = 0;\n        msr->tcache = apr_hash_make(msr->mp);\n        if (msr->tcache == NULL) return -1;\n    }\n\n    switch(phase) {\n        case 1 :\n            return modsecurity_process_phase_request_headers(msr);\n        case 2 :\n            return modsecurity_process_phase_request_body(msr);\n        case 3 :\n            return modsecurity_process_phase_response_headers(msr);\n        case 4 :\n            return modsecurity_process_phase_response_body(msr);\n        case 5 :\n            return modsecurity_process_phase_logging(msr);\n        default :\n            msr_log(msr, 1, \"Invalid processing phase: %d\", msr->phase);\n            break;\n    }\n\n    return -1;\n}\n"], "fixing_code": ["/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2013 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include <stdlib.h>\n\n#include \"apr_global_mutex.h\"\n\n#include \"modsecurity.h\"\n#include \"msc_parsers.h\"\n#include \"msc_util.h\"\n#include \"msc_xml.h\"\n#include \"apr_version.h\"\n\nunsigned long int DSOLOCAL unicode_codepage = 0;\n\nint DSOLOCAL *unicode_map_table = NULL;\n\n/**\n * Format an alert message.\n */\nconst char * msc_alert_message(modsec_rec *msr, msre_actionset *actionset, const char *action_message,\n    const char *rule_message)\n{\n    const char *message = NULL;\n\n    if (rule_message == NULL) rule_message = \"Unknown error.\";\n\n    if (action_message == NULL) {\n        message = apr_psprintf(msr->mp, \"%s%s\",\n            rule_message, msre_format_metadata(msr, actionset));\n    }\n    else {\n        message = apr_psprintf(msr->mp, \"%s %s%s\", action_message,\n            rule_message, msre_format_metadata(msr, actionset));\n    }\n\n    return message;\n}\n\n/**\n * Log an alert message to the log, adding the rule metadata at the end.\n */\nvoid msc_alert(modsec_rec *msr, int level, msre_actionset *actionset, const char *action_message,\n    const char *rule_message)\n{\n    const char *message = msc_alert_message(msr, actionset, action_message, rule_message);\n\n    msr_log(msr, level, \"%s\", message);\n}\n\n#if 0\n/**\n * Return phase name associated with the given phase number.\n */\nstatic const char *phase_name(int phase) {\n    switch(phase) {\n        case 1 :\n            return \"REQUEST_HEADERS\";\n            break;\n        case 2 :\n            return \"REQUEST_BODY\";\n            break;\n        case 3 :\n            return \"RESPONSE_HEADERS\";\n            break;\n        case 4 :\n            return \"RESPONSE_BODY\";\n            break;\n        case 5 :\n            return \"LOGGING\";\n            break;\n    }\n    \n    return \"INVALID\";\n}\n#endif\n\n/**\n * Creates and initialises a ModSecurity engine instance.\n */\nmsc_engine *modsecurity_create(apr_pool_t *mp, int processing_mode) {\n    msc_engine *msce = NULL;\n\n    msce = apr_pcalloc(mp, sizeof(msc_engine));\n    if (msce == NULL) return NULL;\n\n    msce->mp = mp;\n    msce->processing_mode = processing_mode;\n\n    msce->msre = msre_engine_create(msce->mp);\n    if (msce->msre == NULL) return NULL;\n    msre_engine_register_default_variables(msce->msre);\n    msre_engine_register_default_operators(msce->msre);\n    msre_engine_register_default_tfns(msce->msre);\n    msre_engine_register_default_actions(msce->msre);\n    // TODO: msre_engine_register_default_reqbody_processors(msce->msre);\n\n    return msce;\n}\n\n/**\n * Initialise the modsecurity engine. This function must be invoked\n * after configuration processing is complete as Apache needs to know the\n * username it is running as.\n */\nint modsecurity_init(msc_engine *msce, apr_pool_t *mp) {\n    apr_status_t rc;\n\n    /* Serial audit log mutext */\n    rc = apr_global_mutex_create(&msce->auditlog_lock, NULL, APR_LOCK_DEFAULT, mp);\n    if (rc != APR_SUCCESS) {\n        //ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, \"mod_security: Could not create modsec_auditlog_lock\");\n        //return HTTP_INTERNAL_SERVER_ERROR;\n        return -1;\n    }\n\n#if !defined(MSC_TEST)\n#ifdef __SET_MUTEX_PERMS\n#if AP_SERVER_MAJORVERSION_NUMBER > 1 && AP_SERVER_MINORVERSION_NUMBER > 2\n    rc = ap_unixd_set_global_mutex_perms(msce->auditlog_lock);\n#else\n    rc = unixd_set_global_mutex_perms(msce->auditlog_lock);\n#endif\n    if (rc != APR_SUCCESS) {\n        // ap_log_error(APLOG_MARK, APLOG_ERR, rc, s, \"mod_security: Could not set permissions on modsec_auditlog_lock; check User and Group directives\");\n        // return HTTP_INTERNAL_SERVER_ERROR;\n        return -1;\n    }\n#endif /* SET_MUTEX_PERMS */\n\n    rc = apr_global_mutex_create(&msce->geo_lock, NULL, APR_LOCK_DEFAULT, mp);\n    if (rc != APR_SUCCESS) {\n        return -1;\n    }\n\n#ifdef __SET_MUTEX_PERMS\n#if AP_SERVER_MAJORVERSION_NUMBER > 1 && AP_SERVER_MINORVERSION_NUMBER > 2\n    rc = ap_unixd_set_global_mutex_perms(msce->geo_lock);\n#else\n    rc = unixd_set_global_mutex_perms(msce->geo_lock);\n#endif\n    if (rc != APR_SUCCESS) {\n        return -1;\n    }\n#endif /* SET_MUTEX_PERMS */\n#endif\n\n    return 1;\n}\n\n/**\n * Performs per-child (new process) initialisation.\n */\nvoid modsecurity_child_init(msc_engine *msce) {\n    /* Need to call this once per process before any other XML calls. */\n    xmlInitParser();\n\n    if (msce->auditlog_lock != NULL) {\n        apr_status_t rc = apr_global_mutex_child_init(&msce->auditlog_lock, NULL, msce->mp);\n        if (rc != APR_SUCCESS) {\n            // ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, \"Failed to child-init auditlog mutex\");\n        }\n    }\n\n    if (msce->geo_lock != NULL) {\n        apr_status_t rc = apr_global_mutex_child_init(&msce->geo_lock, NULL, msce->mp);\n        if (rc != APR_SUCCESS) {\n            // ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, \"Failed to child-init geo mutex\");\n        }\n    }\n\n}\n\n/**\n * Releases resources held by engine instance.\n */\nvoid modsecurity_shutdown(msc_engine *msce) {\n    if (msce == NULL) return;\n}\n\n/**\n *\n */\nstatic void modsecurity_persist_data(modsec_rec *msr) {\n    const apr_array_header_t *arr;\n    apr_table_entry_t *te;\n    apr_time_t time_before, time_after;\n    int i;\n\n    time_before = apr_time_now();\n\n    /* Collections, store & remove stale. */\n    arr = apr_table_elts(msr->collections);\n    te = (apr_table_entry_t *)arr->elts;\n    for (i = 0; i < arr->nelts; i++) {\n        apr_table_t *col = (apr_table_t *)te[i].val;\n\n        /* Only store those collections that changed. */\n        if (apr_table_get(msr->collections_dirty, te[i].key)) {\n            collection_store(msr, col);\n        }\n    }\n\n    time_after = apr_time_now();\n\n    msr->time_storage_write += time_after - time_before;\n\n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Recording persistent data took %\" APR_TIME_T_FMT\n            \" microseconds.\", msr->time_gc);\n    }\n\n    /* Remove stale collections. */\n    srand(time(NULL));\n\n    if (rand() < RAND_MAX/100) {\n        arr = apr_table_elts(msr->collections);\n        te = (apr_table_entry_t *)arr->elts;\n        for (i = 0; i < arr->nelts; i++) {\n            collections_remove_stale(msr, te[i].key);\n        }\n\n        msr->time_gc = apr_time_now() - time_after;\n\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Garbage collection took %\" APR_TIME_T_FMT\n                \" microseconds.\", msr->time_gc);\n        }\n    }\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_tx_cleanup(void *data) {\n    modsec_rec *msr = (modsec_rec *)data;\n    char *my_error_msg = NULL;\n    \n    if (msr == NULL) return APR_SUCCESS;    \n\n    /* Multipart processor cleanup. */\n    if (msr->mpd != NULL) multipart_cleanup(msr);\n\n    /* XML processor cleanup. */\n    if (msr->xml != NULL) xml_cleanup(msr);\n\n    // TODO: Why do we ignore return code here?\n    modsecurity_request_body_clear(msr, &my_error_msg);\n    if (my_error_msg != NULL) {\n        msr_log(msr, 1, \"%s\", my_error_msg);\n    }\n\n#if defined(WITH_LUA)\n    #ifdef CACHE_LUA\n    if(msr->L != NULL)  lua_close(msr->L);\n    #endif\n#endif\n\n    return APR_SUCCESS;\n}\n\n/**\n *\n */\napr_status_t modsecurity_tx_init(modsec_rec *msr) {\n    const char *s = NULL;\n    const apr_array_header_t *arr;\n    char *semicolon = NULL;\n    char *comma = NULL;\n    apr_table_entry_t *te;\n    int i;\n\n    /* Register TX cleanup */\n    apr_pool_cleanup_register(msr->mp, msr, modsecurity_tx_cleanup, apr_pool_cleanup_null);\n\n    /* Initialise C-L */\n    msr->request_content_length = -1;\n    s = apr_table_get(msr->request_headers, \"Content-Length\");\n    if (s != NULL) {\n        msr->request_content_length = strtol(s, NULL, 10);\n    }\n\n    /* Figure out whether this request has a body */\n    msr->reqbody_chunked = 0;\n    msr->reqbody_should_exist = 0;\n    if (msr->request_content_length == -1) {\n        /* There's no C-L, but is chunked encoding used? */\n        char *transfer_encoding = (char *)apr_table_get(msr->request_headers, \"Transfer-Encoding\");\n        if ((transfer_encoding != NULL)&&(m_strcasestr(transfer_encoding, \"chunked\") != NULL)) {\n            msr->reqbody_should_exist = 1;\n            msr->reqbody_chunked = 1;\n        }\n    } else {\n        /* C-L found */\n        msr->reqbody_should_exist = 1;\n    }\n\n    /* Initialise C-T */\n    msr->request_content_type = NULL;\n    s = apr_table_get(msr->request_headers, \"Content-Type\");\n    if (s != NULL) msr->request_content_type = s;\n\n    /* Decide what to do with the request body. */\n    if ((msr->request_content_type != NULL)\n       && (strncasecmp(msr->request_content_type, \"application/x-www-form-urlencoded\", 33) == 0))\n    {\n        /* Always place POST requests with\n         * \"application/x-www-form-urlencoded\" payloads in memory.\n         */\n        msr->msc_reqbody_storage = MSC_REQBODY_MEMORY;\n        msr->msc_reqbody_spilltodisk = 0;\n        msr->msc_reqbody_processor = \"URLENCODED\";\n    } else {\n        /* If the C-L is known and there's more data than\n         * our limit go to disk straight away.\n         */\n        if ((msr->request_content_length != -1)\n           && (msr->request_content_length > msr->txcfg->reqbody_inmemory_limit))\n        {\n            msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        }\n\n        /* In all other cases, try using the memory first\n         * but switch over to disk for larger bodies.\n         */\n        msr->msc_reqbody_storage = MSC_REQBODY_MEMORY;\n        msr->msc_reqbody_spilltodisk = 1;\n\n        if (msr->request_content_type != NULL) {\n            if (strncasecmp(msr->request_content_type, \"multipart/form-data\", 19) == 0) {\n                msr->msc_reqbody_processor = \"MULTIPART\";\n            }\n        }\n    }\n\n    /* Check if we are forcing buffering, then use memory only. */\n    if (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF) {\n        msr->msc_reqbody_storage = MSC_REQBODY_MEMORY;\n        msr->msc_reqbody_spilltodisk = 0;\n    }\n\n    /* Initialise arguments */\n    msr->arguments = apr_table_make(msr->mp, 32);\n    if (msr->arguments == NULL) return -1;\n    if (msr->query_string != NULL) {\n        int invalid_count = 0;\n\n        if (parse_arguments(msr, msr->query_string, strlen(msr->query_string),\n            msr->txcfg->argument_separator, \"QUERY_STRING\", msr->arguments,\n            &invalid_count) < 0)\n        {\n            msr_log(msr, 1, \"Initialisation: Error occurred while parsing QUERY_STRING arguments.\");\n            return -1;\n        }\n\n        if (invalid_count) {\n            msr->urlencoded_error = 1;\n        }\n    }\n\n    msr->arguments_to_sanitize = apr_table_make(msr->mp, 16);\n    if (msr->arguments_to_sanitize == NULL) return -1;\n    msr->request_headers_to_sanitize = apr_table_make(msr->mp, 16);\n    if (msr->request_headers_to_sanitize == NULL) return -1;\n    msr->response_headers_to_sanitize = apr_table_make(msr->mp, 16);\n    if (msr->response_headers_to_sanitize == NULL) return -1;\n    msr->pattern_to_sanitize = apr_table_make(msr->mp, 32);\n    if (msr->pattern_to_sanitize == NULL) return -1;\n\n    /* remove targets */\n    msr->removed_targets = apr_table_make(msr->mp, 16);\n    if (msr->removed_targets == NULL) return -1;\n\n    /* Initialise cookies */\n    msr->request_cookies = apr_table_make(msr->mp, 16);\n    if (msr->request_cookies == NULL) return -1;\n\n    /* Initialize matched vars */\n    msr->matched_vars = apr_table_make(msr->mp, 8);\n    if (msr->matched_vars == NULL) return -1;\n    apr_table_clear(msr->matched_vars);\n\n    msr->perf_rules = apr_table_make(msr->mp, 8);\n    if (msr->perf_rules == NULL) return -1;\n    apr_table_clear(msr->perf_rules);\n\n    /* Locate the cookie headers and parse them */\n    arr = apr_table_elts(msr->request_headers);\n    te = (apr_table_entry_t *)arr->elts;\n    for (i = 0; i < arr->nelts; i++) {\n        if (strcasecmp(te[i].key, \"Cookie\") == 0) {\n            if (msr->txcfg->cookie_format == COOKIES_V0) {\n                semicolon = apr_pstrdup(msr->mp, te[i].val);\n                while((*semicolon != 0)&&(*semicolon != ';')) semicolon++;\n                if(*semicolon == ';')    {\n                    parse_cookies_v0(msr, te[i].val, msr->request_cookies, \";\");\n                } else  {\n                    comma = apr_pstrdup(msr->mp, te[i].val);\n                    while((*comma != 0)&&(*comma != ',')) comma++;\n                    if(*comma == ',')    {\n                        comma++;\n                        if(*comma == 0x20)   {// looks like comma is the separator\n                            if (msr->txcfg->debuglog_level >= 5) {\n                                msr_log(msr, 5, \"Cookie v0 parser: Using comma as a separator. Semi-colon was not identified!\");\n                            }\n                            parse_cookies_v0(msr, te[i].val, msr->request_cookies, \",\");\n                        } else {\n                            parse_cookies_v0(msr, te[i].val, msr->request_cookies, \";\");\n                        }\n                    } else  {\n                        parse_cookies_v0(msr, te[i].val, msr->request_cookies, \";\");\n                    }\n                }\n            } else {\n                parse_cookies_v1(msr, te[i].val, msr->request_cookies);\n            }\n        }\n    }\n\n    /* Collections. */\n    msr->tx_vars = apr_table_make(msr->mp, 32);\n    if (msr->tx_vars == NULL) return -1;\n\n    msr->geo_vars = apr_table_make(msr->mp, 8);\n    if (msr->geo_vars == NULL) return -1;\n\n    msr->collections_original = apr_table_make(msr->mp, 8);\n    if (msr->collections_original == NULL) return -1;\n    msr->collections = apr_table_make(msr->mp, 8);\n    if (msr->collections == NULL) return -1;\n    msr->collections_dirty = apr_table_make(msr->mp, 8);\n    if (msr->collections_dirty == NULL) return -1;\n\n    /* Other */\n    msr->tcache = NULL;\n    msr->tcache_items = 0;\n\n    msr->matched_rules = apr_array_make(msr->mp, 16, sizeof(void *));\n    if (msr->matched_rules == NULL) return -1;\n\n    msr->matched_var = (msc_string *)apr_pcalloc(msr->mp, sizeof(msc_string));\n    if (msr->matched_var == NULL) return -1;\n\n    msr->highest_severity = 255; /* high, invalid value */\n\n    msr->removed_rules = apr_array_make(msr->mp, 16, sizeof(char *));\n    if (msr->removed_rules == NULL) return -1;\n\n    msr->removed_rules_tag = apr_array_make(msr->mp, 16, sizeof(char *));\n    if (msr->removed_rules_tag == NULL) return -1;\n\n    msr->removed_rules_msg = apr_array_make(msr->mp, 16, sizeof(char *));\n    if (msr->removed_rules_msg == NULL) return -1;\n\n    return 1;\n}\n\n/**\n *\n */\nstatic int is_response_status_relevant(modsec_rec *msr, int status) {\n    char *my_error_msg = NULL;\n    apr_status_t rc;\n    char buf[32];\n\n    /* ENH: Setting is_relevant here will cause an audit even if noauditlog\n     * was set for the last rule that matched.  Is this what we want?\n     */\n\n    if ((msr->txcfg->auditlog_relevant_regex == NULL)\n        ||(msr->txcfg->auditlog_relevant_regex == NOT_SET_P))\n    {\n        return 0;\n    }\n\n    apr_snprintf(buf, sizeof(buf), \"%d\", status);\n\n    rc = msc_regexec(msr->txcfg->auditlog_relevant_regex, buf, strlen(buf), &my_error_msg);\n    if (rc >= 0) return 1;\n    if (rc == PCRE_ERROR_NOMATCH) return 0;\n\n    msr_log(msr, 1, \"Regex processing failed (rc %d): %s\", rc, my_error_msg);\n    \n    return 0;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_request_headers(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n    \n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Starting phase REQUEST_HEADERS.\");\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase1 = apr_time_now() - time_before;\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_request_body(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n\n    \n    if ((msr->allow_scope == ACTION_ALLOW_REQUEST)||(msr->allow_scope == ACTION_ALLOW)) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase REQUEST_BODY (allow used).\");\n        }\n        \n        return 0;\n    } else {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Starting phase REQUEST_BODY.\");\n        }\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase2 = apr_time_now() - time_before;\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_response_headers(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n    \n    if (msr->allow_scope == ACTION_ALLOW) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase RESPONSE_HEADERS (allow used).\");\n        }\n        \n        return 0;\n    } else {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Starting phase RESPONSE_HEADERS.\");\n        }\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase3 = apr_time_now() - time_before;\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_response_body(modsec_rec *msr) {\n    apr_time_t time_before;\n    apr_status_t rc = 0;\n    \n    if (msr->allow_scope == ACTION_ALLOW) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase RESPONSE_BODY (allow used).\");\n        }\n        \n        return 0;\n    } else {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Starting phase RESPONSE_BODY.\");\n        }\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        rc = msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    msr->time_phase4 = apr_time_now() - time_before;\n\n\n    return rc;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_process_phase_logging(modsec_rec *msr) {\n    apr_time_t time_before, time_after;\n    \n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Starting phase LOGGING.\");\n    }\n    \n    time_before = apr_time_now();\n\n    if (msr->txcfg->ruleset != NULL) {\n        msre_ruleset_process_phase(msr->txcfg->ruleset, msr);\n    }\n    \n    modsecurity_persist_data(msr);\n    \n    time_after = apr_time_now();\n    msr->time_phase5 = time_after - time_before;\n\n    /* Is this request relevant for logging purposes? */\n    if (msr->is_relevant == 0) {\n        /* Check the status */\n        msr->is_relevant += is_response_status_relevant(msr, msr->r->status);\n\n        /* If we processed two requests and statuses are different then\n         * check the other status too.\n         */\n        if (msr->r_early->status != msr->r->status) {\n            msr->is_relevant += is_response_status_relevant(msr, msr->r_early->status);\n        }\n    }\n\n    /* Figure out if we want to keep the files (if there are any, of course). */\n    if ((msr->txcfg->upload_keep_files == KEEP_FILES_ON)\n        || ((msr->txcfg->upload_keep_files == KEEP_FILES_RELEVANT_ONLY)&&(msr->is_relevant)))\n    {\n        msr->upload_remove_files = 0;\n    } else {\n        msr->upload_remove_files = 1;\n    }\n\n    /* Are we configured for audit logging? */\n    switch(msr->txcfg->auditlog_flag) {\n        case AUDITLOG_OFF :\n            if (msr->txcfg->debuglog_level >= 4) {\n                msr_log(msr, 4, \"Audit log: Not configured to run for this request.\");\n            }\n            \n            return DECLINED;\n            break;\n\n        case AUDITLOG_RELEVANT :\n            if (msr->is_relevant == 0) {\n                if (msr->txcfg->debuglog_level >= 4) {\n                    msr_log(msr, 4, \"Audit log: Ignoring a non-relevant request.\");\n                }\n                \n                return DECLINED;\n            }\n            break;\n\n        case AUDITLOG_ON :\n            /* All right, do nothing */\n            break;\n\n        default :\n            msr_log(msr, 1, \"Internal error: Could not determine if auditing is needed, so forcing auditing.\");\n            break;\n    }\n\n    /* Invoke the Audit logger */\n    if (msr->txcfg->debuglog_level >= 4) {\n        msr_log(msr, 4, \"Audit log: Logging this transaction.\");\n    }\n\n    sec_audit_logger(msr);\n    \n    msr->time_logging = apr_time_now() - time_after;    \n\n    return 0;\n}\n\n/**\n * Processes one transaction phase. The phase number does not\n * need to be explicitly provided since it's already available\n * in the modsec_rec structure.\n */\napr_status_t modsecurity_process_phase(modsec_rec *msr, unsigned int phase) {\n    /* Check if we should run. */\n    if ((msr->was_intercepted)&&(phase != PHASE_LOGGING)) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase %d as request was already intercepted.\", phase);\n        }\n        \n        return 0;\n    }\n\n    /* Do not process the same phase twice. */\n    if (msr->phase >= phase) {\n        if (msr->txcfg->debuglog_level >= 4) {\n            msr_log(msr, 4, \"Skipping phase %d because it was previously run (at %d now).\",\n                phase, msr->phase);\n        }\n        \n        return 0;\n    }\n\n    msr->phase = phase;\n\n    /* Clear out the transformation cache at the start of each phase */\n    if (msr->txcfg->cache_trans == MODSEC_CACHE_ENABLED) {\n        if (msr->tcache) {\n            apr_hash_index_t *hi;\n            void *dummy;\n            apr_table_t *tab;\n            const void *key;\n            apr_ssize_t klen;\n            #ifdef CACHE_DEBUG\n            apr_pool_t *mp = msr->msc_rule_mptmp;\n            const apr_array_header_t *ctarr;\n            const apr_table_entry_t *ctelts;\n            msre_cache_rec *rec;\n            int cn = 0;\n            int ri;\n            #else\n            apr_pool_t *mp = msr->mp;\n            #endif\n\n            for (hi = apr_hash_first(mp, msr->tcache); hi; hi = apr_hash_next(hi)) {\n                apr_hash_this(hi, &key, &klen, &dummy);\n                tab = (apr_table_t *)dummy;\n\n                if (tab == NULL) continue;\n\n                #ifdef CACHE_DEBUG\n                /* Dump the cache out as we clear */\n                ctarr = apr_table_elts(tab);\n                ctelts = (const apr_table_entry_t*)ctarr->elts;\n                for (ri = 0; ri < ctarr->nelts; ri++) {\n                    cn++;\n                    rec = (msre_cache_rec *)ctelts[ri].val;\n                    if (rec->changed) {\n                        if (msr->txcfg->debuglog_level >= 9) {\n                            msr_log(msr, 9, \"CACHE: %5d) hits=%d key=%pp %x;%s=\\\"%s\\\" (%pp - %pp)\",\n                                cn, rec->hits, key, rec->num, rec->path, log_escape_nq_ex(mp, rec->val, rec->val_len),\n                                rec->val, rec->val + rec->val_len);\n                        }\n                    }\n                    else {\n                        if (msr->txcfg->debuglog_level >= 9) {\n                            msr_log(msr, 9, \"CACHE: %5d) hits=%d key=%pp %x;%s=<no change>\",\n                                cn, rec->hits, key, rec->num, rec->path);\n                        }\n                    }\n                }\n                #endif\n\n                apr_table_clear(tab);\n                apr_hash_set(msr->tcache, key, klen, NULL);\n            }\n\n            if (msr->txcfg->debuglog_level >= 9) {\n                msr_log(msr, 9, \"Cleared transformation cache for phase %d\", msr->phase);\n            }\n        }\n\n        msr->tcache_items = 0;\n        msr->tcache = apr_hash_make(msr->mp);\n        if (msr->tcache == NULL) return -1;\n    }\n\n    switch(phase) {\n        case 1 :\n            return modsecurity_process_phase_request_headers(msr);\n        case 2 :\n            return modsecurity_process_phase_request_body(msr);\n        case 3 :\n            return modsecurity_process_phase_response_headers(msr);\n        case 4 :\n            return modsecurity_process_phase_response_body(msr);\n        case 5 :\n            return modsecurity_process_phase_logging(msr);\n        default :\n            msr_log(msr, 1, \"Invalid processing phase: %d\", msr->phase);\n            break;\n    }\n\n    return -1;\n}\n"], "filenames": ["apache2/modsecurity.c"], "buggy_code_start_loc": [300], "buggy_code_end_loc": [301], "fixing_code_start_loc": [300], "fixing_code_end_loc": [301], "type": "NVD-CWE-noinfo", "message": "apache2/modsecurity.c in ModSecurity before 2.7.6 allows remote attackers to bypass rules by using chunked transfer coding with a capitalized Chunked value in the Transfer-Encoding HTTP header.", "other": {"cve": {"id": "CVE-2013-5705", "sourceIdentifier": "cve@mitre.org", "published": "2014-04-15T10:55:11.197", "lastModified": "2021-02-12T17:26:58.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "apache2/modsecurity.c in ModSecurity before 2.7.6 allows remote attackers to bypass rules by using chunked transfer coding with a capitalized Chunked value in the Transfer-Encoding HTTP header."}, {"lang": "es", "value": "apache2/modsecurity.c en ModSecurity anterior a 2.7.6 permite a atacantes remotos evadir reglas mediante el uso de codificaci\u00f3n de transferencia fragmentada con un valor convertido a may\u00fasculas fragmentado en la cabecera HTTP Transfer-Encoding."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trustwave:modsecurity:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.6", "matchCriteriaId": "85785C8D-D5E1-4E5B-9504-A82AF8370B71"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://martin.swende.se/blog/HTTPChunked.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-2991", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/SpiderLabs/ModSecurity/commit/f8d441cd25172fdfe5b613442fedfc0da3cc333d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SpiderLabs/ModSecurity/commit/f8d441cd25172fdfe5b613442fedfc0da3cc333d"}}