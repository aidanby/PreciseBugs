{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/linalg_ops.cc.\n// TODO(shamanDevel): Enable complex inputs. This will require a specialization\n//                    of Gesvd for complex inputs as well as a new kernel\n//                    definition to output the singular values as reals\n//                    instead of complex values. The current CPU implementation\n//                    outputs the singular values as complex values and then\n//                    casts them to reals in the python wrapper.\n// TODO(rmlarsen/shamanDevel): This could use a bit of cleanup. We don't need to\n// pass quite as many raw pointers around. Would also be nice to reduce code\n// duplication.\n\n#if GOOGLE_CUDA\n#define EIGEN_USE_GPU\n\n#include <algorithm>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/linalg/eye_functor.h\"\n#include \"tensorflow/core/kernels/linalg/linalg_ops_common.h\"\n#include \"tensorflow/core/kernels/transpose_functor.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/determinism.h\"\n#include \"tensorflow/core/util/gpu_kernel_helper.h\"\n#include \"tensorflow/core/util/gpu_solvers.h\"\n\nnamespace tensorflow {\n\nstatic const char kErrMsg[] =\n    \"Singular Value Decomposition was not successful. The input might not be \"\n    \"valid.\";\n\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace {\n// This kernel computes the reduction\n// V' = sum_i (M_i * U_i,1 * S_i).\n// The result is stored in V[batch] and has the same sign as the\n// real value of V (which should be computed)\ntemplate <class Scalar>\n__global__ void ComputeValueOfVKernel(Gpu2DLaunchConfig config, int64 m,\n                                      int64 ldu, const Scalar* __restrict__ M,\n                                      const Scalar* __restrict__ U,\n                                      const Scalar* __restrict__ S,\n                                      Scalar* __restrict__ V) {\n  GPU_AXIS_KERNEL_LOOP(batch, config.virtual_thread_count.x, X) {\n    GPU_AXIS_KERNEL_LOOP(i, config.virtual_thread_count.y, Y) {\n      Scalar v = M[i + m * batch] * U[ldu * (i + m * batch)] * S[batch];\n      GpuAtomicAdd(V + batch, v);\n    }\n  }\n}\n\n// Extracts the sign of V\n// V[i] = V[i]>=0 ? 1 : 0\ntemplate <class Scalar>\n__global__ void ExtractSignOfVKernel(GpuLaunchConfig config,\n                                     Scalar* __restrict__ V) {\n  GPU_1D_KERNEL_LOOP(i, config.virtual_thread_count) {\n    V[i] = V[i] >= 0 ? Scalar(1) : Scalar(-1);\n  }\n}\n}  // namespace\n\n// Scalar: The input scalar type (can be complex)\ntemplate <class Scalar>\nclass SvdOpGpu : public AsyncOpKernel {\n public:\n  using RealScalar = typename Eigen::NumTraits<Scalar>::Real;\n\n  explicit SvdOpGpu(OpKernelConstruction* context) : AsyncOpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"compute_uv\", &compute_uv_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"full_matrices\", &full_matrices_));\n    OP_REQUIRES(context, !tensorflow::OpDeterminismRequired(),\n                errors::Unimplemented(\"Determinism is not yet supported \"\n                                      \"for Svd.\"));\n  }\n\n  void RunSVD(OpKernelContext* context, DoneCallback done, int64 m, int64 n,\n              int64 p, Tensor& M_copy, Tensor* S, Tensor* U, Tensor* V,\n              std::unique_ptr<GpuSolver> solver) {\n    // Compute U S V* = M.\n    // 1. cuSolver works in column-major rather than row-major.\n    // 2. Gesvd returns V*. GesvdjBatched returns V.\n    // 3. Hence M should be transposed before input and\n    //    a) U (rather than V) should be transposed on output with Gesvd.\n    //    b) U and V should be transposed on output with GesvdjBatched.\n\n    // get the pointers to input data\n    Scalar* input_ptr;\n    RealScalar* outputS_ptr;\n    auto input_reshaped = M_copy.template flat_inner_dims<Scalar, 3>();\n    input_ptr = input_reshaped.data();\n    const int64 batch_size =\n        M_copy.dims() > 2 ? input_reshaped.dimension(0) : 1;\n    // Gesvdjbatched handles matrices up to 32x32.\n    // TODO(jamessspencer): if not full_matrices, compute full U and V matrices\n    // using Gesvdjbatched and return slices.\n    const bool batched =\n        m <= 32 && n <= 32 && batch_size > 1 && (full_matrices_ || m == n);\n\n    // Copies of U and V if required so can take transposes after SVD.\n    Tensor u_copy, v_copy;\n    Scalar* outputU_ptr = NULL;\n    Scalar* outputV_ptr = NULL;\n    if (compute_uv_ || batched) {\n      TensorShape u_shape, v_shape;\n      if (batched) {\n        // Gesvdjbatched seems to require U and V matrices even if the vectors\n        // aren't computed.\n        TensorShape shapeRaw = M_copy.shape();\n        shapeRaw.RemoveLastDims(2);\n        u_shape = shapeRaw;\n        u_shape.AddDim(m);\n        u_shape.AddDim(m);\n        v_shape = shapeRaw;\n        v_shape.AddDim(n);\n        v_shape.AddDim(n);\n      } else if (full_matrices_) {\n        u_shape = U->shape();\n        v_shape = V->shape();\n      } else {\n        TensorShape shapeRaw = M_copy.shape();\n        shapeRaw.RemoveLastDims(2);\n        u_shape = shapeRaw;\n        u_shape.AddDim(p);\n        u_shape.AddDim(m);\n        v_shape = shapeRaw;\n        v_shape.AddDim(p);\n        v_shape.AddDim(n);\n      }\n      OP_REQUIRES_OK_ASYNC(\n          context, solver->allocate_scoped_tensor(U->dtype(), u_shape, &u_copy),\n          done);\n      if (batched) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->allocate_scoped_tensor(V->dtype(), v_shape, &v_copy), done);\n      }\n      outputU_ptr = u_copy.template flat_inner_dims<Scalar, 3>().data();\n      if (batched) {\n        outputV_ptr = v_copy.template flat_inner_dims<Scalar, 3>().data();\n      } else {\n        outputV_ptr = V->template flat_inner_dims<Scalar, 3>().data();\n      }\n    }\n\n    outputS_ptr = S->template flat_inner_dims<RealScalar, 2>().data();\n    std::vector<DeviceLapackInfo> dev_info;\n    dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"gesvd\"));\n    int* dev_info_ptr = dev_info.back().mutable_data();\n\n    // Save the input matrix\n    // Needed for the n=1 fix, see below, since SVD destroys the input\n    Tensor input_copy;\n    if (compute_uv_ && n == 1) {\n      OP_REQUIRES_OK_ASYNC(context,\n                           solver->allocate_scoped_tensor(\n                               DataTypeToEnum<Scalar>::v(),\n                               TensorShape({batch_size, m}), &input_copy),\n                           done);\n      const GPUDevice& d = context->eigen_device<GPUDevice>();\n      d.memcpy(input_copy.flat<Scalar>().data(), input_ptr,\n               batch_size * m * sizeof(Scalar));\n    }\n\n    if (batched) {\n      cusolverEigMode_t jobz = CUSOLVER_EIG_MODE_NOVECTOR;\n      if (compute_uv_) jobz = CUSOLVER_EIG_MODE_VECTOR;\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->GesvdjBatched(jobz, m, n, input_ptr, m, outputS_ptr,\n                                outputU_ptr, m, outputV_ptr, n, dev_info_ptr,\n                                batch_size),\n          done);\n    } else {\n      for (int64 batch = 0; batch < batch_size; ++batch) {\n        Scalar* input = input_ptr + batch * m * n;\n        RealScalar* outputS = outputS_ptr + batch * p;\n        Scalar* outputU = NULL;\n        Scalar* outputVT = NULL;\n        char jobu = 'N';\n        char jobvt = 'N';\n\n        if (compute_uv_) {\n          if (full_matrices_) {\n            outputU = outputU_ptr + batch * m * m;\n            outputVT = outputV_ptr + batch * n * n;\n            jobu = 'A';\n            jobvt = 'A';\n          } else {\n            outputU = outputU_ptr + batch * m * p;\n            outputVT = outputV_ptr + batch * n * p;\n            jobu = 'S';\n            jobvt = 'S';\n          }\n        }\n\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->Gesvd(jobu, jobvt, m, n, input, m, outputS, outputU, m,\n                          outputVT, n, dev_info_ptr + batch),\n            done);\n      }\n    }\n\n    // This is a bug in cuSolver:\n    // If n is one, then outputVT only contains zeros instead of ones.\n    // Hence, I need to fill outputVT manually\n    // The question is: +1 or -1?\n    // -> Compute U*S and compare sign against M\n    // But because S is zero except for the first entry, the multiplication\n    // simplifies a lot.\n    // However, what happens if M contains zeros? At these indices, it is\n    // impossible to determine the value of V.\n    // -> Compute V for all rows in M to cope for zeros.\n    // 1. V' = sum_i (M_i * U_i,1 * S_i)\n    // 2. V = {1, V'>=0, -1, V'<0}\n    // TODO: what is with complex values?\n    if (compute_uv_ && n == 1) {\n      // 1. compute the (batched) sum\n      const GPUDevice& d = context->eigen_device<GPUDevice>();\n      d.memset(outputV_ptr, 0, batch_size * sizeof(Scalar));\n      Gpu2DLaunchConfig cfg2D = GetGpu2DLaunchConfig(batch_size, m, d);\n      TF_CHECK_OK(GpuLaunchKernel(ComputeValueOfVKernel<Scalar>,\n                                  cfg2D.block_count, cfg2D.thread_per_block, 0,\n                                  d.stream(), cfg2D, m, full_matrices_ ? m : p,\n                                  input_copy.flat<Scalar>().data(), outputU_ptr,\n                                  outputS_ptr, outputV_ptr));\n      // 2. clamp V to -1 or +1\n      GpuLaunchConfig cfg1D = GetGpuLaunchConfig(batch_size, d);\n      TF_CHECK_OK(GpuLaunchKernel(ExtractSignOfVKernel<Scalar>,\n                                  cfg1D.block_count, cfg1D.thread_per_block, 0,\n                                  d.stream(), cfg1D, outputV_ptr));\n    }\n\n    if (compute_uv_) {\n      auto device = context->eigen_device<GPUDevice>();\n      OP_REQUIRES_OK_ASYNC(context, DoMatrixTranspose(device, u_copy, U), done);\n      if (batched) {\n        OP_REQUIRES_OK_ASYNC(context, DoMatrixTranspose(device, v_copy, V),\n                             done);\n      }\n    }\n\n    CheckResult(context, std::move(done), dev_info, std::move(solver));\n  }\n\n  void CheckResult(OpKernelContext* context, DoneCallback done,\n                   const std::vector<DeviceLapackInfo>& dev_info,\n                   std::unique_ptr<GpuSolver> solver) {\n    auto info_checker = [context, done](\n                            const Status& status,\n                            const std::vector<HostLapackInfo>& /* unused */) {\n      Status full_status = status;\n      if (!full_status.ok()) {\n        full_status.Update(errors::InvalidArgument(kErrMsg));\n      }\n      OP_REQUIRES_OK_ASYNC(context, full_status, done);\n      done();\n    };\n\n    GpuSolver::CheckLapackInfoAndDeleteSolverAsync(std::move(solver), dev_info,\n                                                   std::move(info_checker));\n  }\n\n  // The SVD if m >= n\n  // TODO: can the two cases (MgeqN and MlessN) be simplified,\n  //   common boilerplate be reduced, or even combined in one method?\n  void PerformSVD_MgeqN(OpKernelContext* context, DoneCallback done, int64 m,\n                        int64 n, int64 p, const Tensor& M, Tensor* S, Tensor* U,\n                        Tensor* V) {\n    // Transpose M, because cuSolver expects it to be column-major\n    TensorShape shapeRaw = M.shape();\n    shapeRaw.RemoveLastDims(2);\n    TensorShape input_shape = shapeRaw;\n    input_shape.AddDim(n);\n    input_shape.AddDim(m);\n    Tensor input_copy;\n    // TODO(rmlarsen): Convert to std::make_unique when available.\n    std::unique_ptr<GpuSolver> solver(new GpuSolver(context));\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->allocate_scoped_tensor(M.dtype(), input_shape, &input_copy),\n        done);\n    auto device = context->eigen_device<GPUDevice>();\n    OP_REQUIRES_OK_ASYNC(context, DoMatrixTranspose(device, M, &input_copy),\n                         done);\n\n    // Call the SVD: compute U S V* = M.\n    RunSVD(context, done, m, n, p, input_copy, S, U, V, std::move(solver));\n  }\n\n  // The SVD if m < n\n  void PerformSVD_MlessN(OpKernelContext* context, DoneCallback done, int64 m,\n                         int64 n, int64 p, const Tensor& M, Tensor* S,\n                         Tensor* U, Tensor* V) {\n    // Perform the SVD on M'. cuSolver works column major so don't need to\n    // transpose M.\n\n    // Reuse the input buffer or make a copy for the SVD depending on whether\n    // this op owns the input buffer exclusively. This is needed because the\n    // SVD modifies the input\n    // TODO(rmlarsen): Convert to std::make_unique when available.\n    std::unique_ptr<GpuSolver> solver(new GpuSolver(context));\n    Tensor input_copy;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->forward_input_or_allocate_scoped_tensor(\n            {0}, DataTypeToEnum<Scalar>::value, M.shape(), &input_copy),\n        done);\n\n    if (!M.SharesBufferWith(input_copy)) {\n      const GPUDevice& d = context->eigen_device<GPUDevice>();\n      d.memcpy(input_copy.flat<Scalar>().data(), M.flat<Scalar>().data(),\n               M.NumElements() * sizeof(Scalar));\n    }\n\n    // Call the SVD: compute V S U* = M*.\n    // Note (m, n) and (U, V) are swapped accordingly.\n    RunSVD(context, done, n, m, p, input_copy, S, V, U, std::move(solver));\n  }\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) final {\n    const Tensor& input = context->input(0);\n    const int ndims = input.dims();\n\n    // Validate inputs.\n    OP_REQUIRES_ASYNC(\n        context, ndims >= 2,\n        errors::InvalidArgument(\"Input must have rank >= 2, got \", ndims),\n        done);\n\n    const int64 m = input.dim_size(ndims - 2);\n    const int64 n = input.dim_size(ndims - 1);\n    const int64 p = std::min(m, n);\n\n    // output tensors.\n    Tensor* outputU = NULL;\n    Tensor* outputS = NULL;\n    Tensor* outputV = NULL;\n\n    // compute  shapes\n    TensorShape shapeRaw = input.shape();\n    shapeRaw.RemoveLastDims(2);\n    TensorShape shapeS = shapeRaw;\n    TensorShape shapeU = shapeRaw;\n    TensorShape shapeV = shapeRaw;\n    shapeS.AddDim(p);\n    if (compute_uv_) {\n      if (full_matrices_) {\n        shapeU.AddDim(m);\n        shapeU.AddDim(m);\n        shapeV.AddDim(n);\n        shapeV.AddDim(n);\n      } else {\n        shapeU.AddDim(m);\n        shapeU.AddDim(p);\n        shapeV.AddDim(n);\n        shapeV.AddDim(p);\n      }\n    } else {\n      shapeU = TensorShape({0});\n      shapeV = TensorShape({0});\n    }\n\n    // allocate output\n    OP_REQUIRES_OK_ASYNC(context, context->allocate_output(0, shapeS, &outputS),\n                         done);\n    OP_REQUIRES_OK_ASYNC(context, context->allocate_output(1, shapeU, &outputU),\n                         done);\n    OP_REQUIRES_OK_ASYNC(context, context->allocate_output(2, shapeV, &outputV),\n                         done);\n\n    if (n == 0 || m == 0) {\n      if (n == m || !compute_uv_ || !full_matrices_) {\n        // S, U, and V are all empty. Nothing to do.\n        done();\n        return;\n      }\n      auto device = context->eigen_device<GPUDevice>();\n      functor::EyeFunctor<GPUDevice, Scalar> eye;\n      if (m > 0) {\n        // Return a full canonical basis for the column space.\n        auto outputU_reshaped = outputU->flat_inner_dims<Scalar, 3>();\n        eye(device, outputU_reshaped);\n      } else if (n > 0) {\n        // Return a full canonical basis for the row space.\n        auto outputV_reshaped = outputV->flat_inner_dims<Scalar, 3>();\n        eye(device, outputV_reshaped);\n      }\n      done();\n      return;\n    }\n\n    // call implementations\n    if (m >= n) {\n      PerformSVD_MgeqN(context, done, m, n, p, input, outputS, outputU,\n                       outputV);\n    } else {\n      PerformSVD_MlessN(context, done, m, n, p, input, outputS, outputU,\n                        outputV);\n    }\n  }\n\n private:\n  bool compute_uv_;\n  bool full_matrices_;\n};\n\n// TODO: add support for complex types\nREGISTER_LINALG_OP_GPU(\"Svd\", (SvdOpGpu<float>), float);\nREGISTER_LINALG_OP_GPU(\"Svd\", (SvdOpGpu<double>), double);\n\n// Deprecated kernels.\nREGISTER_LINALG_OP_GPU(\"BatchSvd\", (SvdOpGpu<float>), float);\nREGISTER_LINALG_OP_GPU(\"BatchSvd\", (SvdOpGpu<double>), double);\n\n}  // namespace tensorflow\n\n#endif  // GOOGLE_CUDA\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.ops.math_ops.matrix_inverse.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.client import session\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import gradient_checker_v2\nfrom tensorflow.python.ops import gradients_impl\nfrom tensorflow.python.ops import linalg_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import stateless_random_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import benchmark\nfrom tensorflow.python.platform import test\n\n\ndef _AddTest(test_class, op_name, testcase_name, fn):\n  test_name = \"_\".join([\"test\", op_name, testcase_name])\n  if hasattr(test_class, test_name):\n    raise RuntimeError(\"Test %s defined more than once\" % test_name)\n  setattr(test_class, test_name, fn)\n\n\nclass SvdOpTest(test.TestCase):\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def testWrongDimensions(self):\n    # The input to svd should be a tensor of at least rank 2.\n    scalar = constant_op.constant(1.)\n    with self.assertRaisesRegex((ValueError, errors_impl.InvalidArgumentError),\n                                \"rank.* 2.*0\"):\n      linalg_ops.svd(scalar)\n    vector = constant_op.constant([1., 2.])\n    with self.assertRaisesRegex((ValueError, errors_impl.InvalidArgumentError),\n                                \"rank.* 2.*1\"):\n      linalg_ops.svd(vector)\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def testThrowDeterminismError(self):\n    shape = [6, 5]\n    seed = [42, 24]\n    matrix1 = stateless_random_ops.stateless_random_normal(shape, seed)\n    with test_util.deterministic_ops():\n      if test_util.is_gpu_available(cuda_only=True):\n        with self.assertRaisesRegex(\n            errors_impl.UnimplementedError, \"Determinism is not yet supported \"\n            \"for Svd.\"):\n          self.evaluate(linalg_ops.svd(matrix1))\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def DISABLED_testBadInputs(self):\n    # TODO(b/185822300): re-enable after the bug is fixed in CUDA-11.x\n    # The input to svd should be a tensor of at least rank 2.\n    for bad_val in [np.nan, np.inf]:\n      matrix = np.array([[1, bad_val], [0, 1]])\n      s, u, v = linalg_ops.svd(matrix, compute_uv=True)\n      s, u, v = self.evaluate([s, u, v])\n      for i in range(2):\n        self.assertTrue(np.isnan(s[i]))\n        for j in range(2):\n          self.assertTrue(np.isnan(u[i, j]))\n          self.assertTrue(np.isnan(v[i, j]))\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def testExecuteMultipleWithoutError(self):\n    all_ops = []\n    shape = [6, 5]\n    seed = [42, 24]\n    for compute_uv_ in True, False:\n      for full_matrices_ in True, False:\n        matrix1 = stateless_random_ops.stateless_random_normal(shape, seed)\n        matrix2 = stateless_random_ops.stateless_random_normal(shape, seed)\n        self.assertAllEqual(matrix1, matrix2)\n        if compute_uv_:\n          s1, u1, v1 = linalg_ops.svd(\n              matrix1, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          s2, u2, v2 = linalg_ops.svd(\n              matrix2, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          all_ops += [s1, s2, u1, u2, v1, v2]\n        else:\n          s1 = linalg_ops.svd(\n              matrix1, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          s2 = linalg_ops.svd(\n              matrix2, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          all_ops += [s1, s2]\n    val = self.evaluate(all_ops)\n    for i in range(0, len(val), 2):\n      self.assertAllEqual(val[i], val[i + 1])\n\n\ndef _GetSvdOpTest(dtype_, shape_, use_static_shape_, compute_uv_,\n                  full_matrices_):\n\n  def CompareSingularValues(self, x, y, tol):\n    atol = (x[0] + y[0]) * tol if len(x) else tol\n    self.assertAllClose(x, y, atol=atol)\n\n  def CompareSingularVectors(self, x, y, rank, tol):\n    # We only compare the first 'rank' singular vectors since the\n    # remainder form an arbitrary orthonormal basis for the\n    # (row- or column-) null space, whose exact value depends on\n    # implementation details. Notice that since we check that the\n    # matrices of singular vectors are unitary elsewhere, we do\n    # implicitly test that the trailing vectors of x and y span the\n    # same space.\n    x = x[..., 0:rank]\n    y = y[..., 0:rank]\n    # Singular vectors are only unique up to sign (complex phase factor for\n    # complex matrices), so we normalize the sign first.\n    sum_of_ratios = np.sum(np.divide(y, x), -2, keepdims=True)\n    phases = np.divide(sum_of_ratios, np.abs(sum_of_ratios))\n    x *= phases\n    self.assertAllClose(x, y, atol=2 * tol)\n\n  def CheckApproximation(self, a, u, s, v, full_matrices_, tol):\n    # Tests that a ~= u*diag(s)*transpose(v).\n    batch_shape = a.shape[:-2]\n    m = a.shape[-2]\n    n = a.shape[-1]\n    diag_s = math_ops.cast(array_ops.matrix_diag(s), dtype=dtype_)\n    if full_matrices_:\n      if m > n:\n        zeros = array_ops.zeros(batch_shape + (m - n, n), dtype=dtype_)\n        diag_s = array_ops.concat([diag_s, zeros], a.ndim - 2)\n      elif n > m:\n        zeros = array_ops.zeros(batch_shape + (m, n - m), dtype=dtype_)\n        diag_s = array_ops.concat([diag_s, zeros], a.ndim - 1)\n    a_recon = math_ops.matmul(u, diag_s)\n    a_recon = math_ops.matmul(a_recon, v, adjoint_b=True)\n    self.assertAllClose(a_recon, a, rtol=tol, atol=tol)\n\n  def CheckUnitary(self, x, tol):\n    # Tests that x[...,:,:]^H * x[...,:,:] is close to the identity.\n    xx = math_ops.matmul(x, x, adjoint_a=True)\n    identity = array_ops.matrix_band_part(array_ops.ones_like(xx), 0, 0)\n    self.assertAllClose(identity, xx, atol=tol)\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def Test(self):\n    if not use_static_shape_ and context.executing_eagerly():\n      return\n    is_complex = dtype_ in (np.complex64, np.complex128)\n    is_single = dtype_ in (np.float32, np.complex64)\n    tol = 3e-4 if is_single else 1e-12\n    if test.is_gpu_available():\n      # The gpu version returns results that are much less accurate.\n      tol *= 200\n    np.random.seed(42)\n    x_np = np.random.uniform(\n        low=-1.0, high=1.0, size=np.prod(shape_)).reshape(shape_).astype(dtype_)\n    if is_complex:\n      x_np += 1j * np.random.uniform(\n          low=-1.0, high=1.0,\n          size=np.prod(shape_)).reshape(shape_).astype(dtype_)\n\n    if use_static_shape_:\n      x_tf = constant_op.constant(x_np)\n    else:\n      x_tf = array_ops.placeholder(dtype_)\n\n    if compute_uv_:\n      s_tf, u_tf, v_tf = linalg_ops.svd(\n          x_tf, compute_uv=compute_uv_, full_matrices=full_matrices_)\n      if use_static_shape_:\n        s_tf_val, u_tf_val, v_tf_val = self.evaluate([s_tf, u_tf, v_tf])\n      else:\n        with self.session() as sess:\n          s_tf_val, u_tf_val, v_tf_val = sess.run(\n              [s_tf, u_tf, v_tf], feed_dict={x_tf: x_np})\n    else:\n      s_tf = linalg_ops.svd(\n          x_tf, compute_uv=compute_uv_, full_matrices=full_matrices_)\n      if use_static_shape_:\n        s_tf_val = self.evaluate(s_tf)\n      else:\n        with self.session() as sess:\n          s_tf_val = sess.run(s_tf, feed_dict={x_tf: x_np})\n\n    if compute_uv_:\n      u_np, s_np, v_np = np.linalg.svd(\n          x_np, compute_uv=compute_uv_, full_matrices=full_matrices_)\n    else:\n      s_np = np.linalg.svd(\n          x_np, compute_uv=compute_uv_, full_matrices=full_matrices_)\n    # We explicitly avoid the situation where numpy eliminates a first\n    # dimension that is equal to one.\n    s_np = np.reshape(s_np, s_tf_val.shape)\n\n    CompareSingularValues(self, s_np, s_tf_val, tol)\n    if compute_uv_:\n      CompareSingularVectors(self, u_np, u_tf_val, min(shape_[-2:]), tol)\n      CompareSingularVectors(self, np.conj(np.swapaxes(v_np, -2, -1)), v_tf_val,\n                             min(shape_[-2:]), tol)\n      CheckApproximation(self, x_np, u_tf_val, s_tf_val, v_tf_val,\n                         full_matrices_, tol)\n      CheckUnitary(self, u_tf_val, tol)\n      CheckUnitary(self, v_tf_val, tol)\n\n  return Test\n\n\nclass SvdGradOpTest(test.TestCase):\n  pass  # Filled in below\n\n\ndef _NormalizingSvd(tf_a, full_matrices_):\n  tf_s, tf_u, tf_v = linalg_ops.svd(\n      tf_a, compute_uv=True, full_matrices=full_matrices_)\n  # Singular vectors are only unique up to an arbitrary phase. We normalize\n  # the vectors such that the first component of u (if m >=n) or v (if n > m)\n  # have phase 0.\n  m = tf_a.shape[-2]\n  n = tf_a.shape[-1]\n  if m >= n:\n    top_rows = tf_u[..., 0:1, :]\n  else:\n    top_rows = tf_v[..., 0:1, :]\n  if tf_u.dtype.is_complex:\n    angle = -math_ops.angle(top_rows)\n    phase = math_ops.complex(math_ops.cos(angle), math_ops.sin(angle))\n  else:\n    phase = math_ops.sign(top_rows)\n  tf_u *= phase[..., :m]\n  tf_v *= phase[..., :n]\n  return tf_s, tf_u, tf_v\n\n\ndef _GetSvdGradOpTest(dtype_, shape_, compute_uv_, full_matrices_):\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def Test(self):\n\n    def RandomInput():\n      np.random.seed(42)\n      a = np.random.uniform(low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      if dtype_ in [np.complex64, np.complex128]:\n        a += 1j * np.random.uniform(\n            low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      return a\n\n    # Optimal stepsize for central difference is O(epsilon^{1/3}).\n    # See Equation (21) in:\n    # http://www.karenkopecky.net/Teaching/eco613614/Notes_NumericalDifferentiation.pdf\n    # TODO(rmlarsen): Move step size control to gradient checker.\n    epsilon = np.finfo(dtype_).eps\n    delta = 0.25 * epsilon**(1.0 / 3.0)\n    if dtype_ in [np.float32, np.complex64]:\n      tol = 3e-2\n    else:\n      tol = 1e-6\n    if compute_uv_:\n      funcs = [\n          lambda a: _NormalizingSvd(a, full_matrices_)[0],\n          lambda a: _NormalizingSvd(a, full_matrices_)[1],\n          lambda a: _NormalizingSvd(a, full_matrices_)[2]\n      ]\n    else:\n      funcs = [lambda a: linalg_ops.svd(a, compute_uv=False)]\n\n    for f in funcs:\n      theoretical, numerical = gradient_checker_v2.compute_gradient(\n          f, [RandomInput()], delta=delta)\n      self.assertAllClose(theoretical, numerical, atol=tol, rtol=tol)\n\n  return Test\n\n\nclass SvdGradGradOpTest(test.TestCase):\n  pass  # Filled in below\n\n\ndef _GetSvdGradGradOpTest(dtype_, shape_, compute_uv_, full_matrices_):\n\n  @test_util.run_v1_only(\"b/120545219\")\n  def Test(self):\n    np.random.seed(42)\n    a = np.random.uniform(low=-1.0, high=1.0, size=shape_).astype(dtype_)\n    if dtype_ in [np.complex64, np.complex128]:\n      a += 1j * np.random.uniform(\n          low=-1.0, high=1.0, size=shape_).astype(dtype_)\n    # Optimal stepsize for central difference is O(epsilon^{1/3}).\n    # See Equation (21) in:\n    # http://www.karenkopecky.net/Teaching/eco613614/Notes_NumericalDifferentiation.pdf\n    # TODO(rmlarsen): Move step size control to gradient checker.\n    epsilon = np.finfo(dtype_).eps\n    delta = 0.1 * epsilon**(1.0 / 3.0)\n    tol = 1e-5\n    with self.session():\n      tf_a = constant_op.constant(a)\n      if compute_uv_:\n        tf_s, tf_u, tf_v = _NormalizingSvd(tf_a, full_matrices_)\n        outputs = [tf_s, tf_u, tf_v]\n      else:\n        tf_s = linalg_ops.svd(tf_a, compute_uv=False)\n        outputs = [tf_s]\n      outputs_sums = [math_ops.reduce_sum(o) for o in outputs]\n      tf_func_outputs = math_ops.add_n(outputs_sums)\n      grad = gradients_impl.gradients(tf_func_outputs, tf_a)[0]\n      x_init = np.random.uniform(\n          low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      if dtype_ in [np.complex64, np.complex128]:\n        x_init += 1j * np.random.uniform(\n            low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      theoretical, numerical = gradient_checker.compute_gradient(\n          tf_a,\n          tf_a.get_shape().as_list(),\n          grad,\n          grad.get_shape().as_list(),\n          x_init_value=x_init,\n          delta=delta)\n      self.assertAllClose(theoretical, numerical, atol=tol, rtol=tol)\n  return Test\n\n\nclass SVDBenchmark(test.Benchmark):\n\n  shapes = [\n      (4, 4),\n      (8, 8),\n      (16, 16),\n      (101, 101),\n      (256, 256),\n      (1024, 1024),\n      (2048, 2048),\n      (1, 8, 8),\n      (10, 8, 8),\n      (100, 8, 8),\n      (1000, 8, 8),\n      (1, 32, 32),\n      (10, 32, 32),\n      (100, 32, 32),\n      (1000, 32, 32),\n      (1, 256, 256),\n      (10, 256, 256),\n      (100, 256, 256),\n  ]\n\n  def benchmarkSVDOp(self):\n    for shape_ in self.shapes:\n      with ops.Graph().as_default(), \\\n          session.Session(config=benchmark.benchmark_config()) as sess, \\\n          ops.device(\"/cpu:0\"):\n        matrix_value = np.random.uniform(\n            low=-1.0, high=1.0, size=shape_).astype(np.float32)\n        matrix = variables.Variable(matrix_value)\n        u, s, v = linalg_ops.svd(matrix)\n        self.evaluate(variables.global_variables_initializer())\n        self.run_op_benchmark(\n            sess,\n            control_flow_ops.group(u, s, v),\n            min_iters=25,\n            name=\"SVD_cpu_{shape}\".format(shape=shape_))\n\n      if test.is_gpu_available(True):\n        with ops.Graph().as_default(), \\\n            session.Session(config=benchmark.benchmark_config()) as sess, \\\n            ops.device(\"/device:GPU:0\"):\n          matrix_value = np.random.uniform(\n              low=-1.0, high=1.0, size=shape_).astype(np.float32)\n          matrix = variables.Variable(matrix_value)\n          u, s, v = linalg_ops.svd(matrix)\n          self.evaluate(variables.global_variables_initializer())\n          self.run_op_benchmark(\n              sess,\n              control_flow_ops.group(u, s, v),\n              min_iters=25,\n              name=\"SVD_gpu_{shape}\".format(shape=shape_))\n\n\nif __name__ == \"__main__\":\n  dtypes_to_test = [np.float32, np.float64, np.complex64, np.complex128]\n  for compute_uv in False, True:\n    for full_matrices in False, True:\n      for dtype in dtypes_to_test:\n        for rows in 0, 1, 2, 5, 10, 32, 100:\n          for cols in 0, 1, 2, 5, 10, 32, 100:\n            for batch_dims in [(), (3,)] + [(3, 2)] * (max(rows, cols) < 10):\n              full_shape = batch_dims + (rows, cols)\n              for use_static_shape in set([True, False]):\n                name = \"%s_%s_static_shape_%s__compute_uv_%s_full_%s\" % (\n                    dtype.__name__, \"_\".join(map(str, full_shape)),\n                    use_static_shape, compute_uv, full_matrices)\n                _AddTest(\n                    SvdOpTest, \"Svd\", name,\n                    _GetSvdOpTest(dtype, full_shape, use_static_shape,\n                                  compute_uv, full_matrices))\n  for compute_uv in False, True:\n    for full_matrices in False, True:\n      dtypes = ([np.float32, np.float64] + [np.complex64, np.complex128] *\n                (not compute_uv))\n      for dtype in dtypes:\n        mat_shapes = [(10, 11), (11, 10), (11, 11), (2, 2, 2, 3)]\n        if not full_matrices or not compute_uv:\n          mat_shapes += [(5, 11), (11, 5)]\n        for mat_shape in mat_shapes:\n          for batch_dims in [(), (3,)]:\n            full_shape = batch_dims + mat_shape\n            name = \"%s_%s_compute_uv_%s_full_%s\" % (dtype.__name__, \"_\".join(\n                map(str, full_shape)), compute_uv, full_matrices)\n            _AddTest(\n                SvdGradOpTest, \"SvdGrad\", name,\n                _GetSvdGradOpTest(dtype, full_shape, compute_uv, full_matrices))\n            # The results are too inaccurate for float32.\n            if dtype in (np.float64, np.complex128):\n              _AddTest(\n                  SvdGradGradOpTest, \"SvdGradGrad\", name,\n                  _GetSvdGradGradOpTest(dtype, full_shape, compute_uv,\n                                        full_matrices))\n  test.main()\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/linalg_ops.cc.\n// TODO(shamanDevel): Enable complex inputs. This will require a specialization\n//                    of Gesvd for complex inputs as well as a new kernel\n//                    definition to output the singular values as reals\n//                    instead of complex values. The current CPU implementation\n//                    outputs the singular values as complex values and then\n//                    casts them to reals in the python wrapper.\n// TODO(rmlarsen/shamanDevel): This could use a bit of cleanup. We don't need to\n// pass quite as many raw pointers around. Would also be nice to reduce code\n// duplication.\n\n#if GOOGLE_CUDA\n#define EIGEN_USE_GPU\n\n#include <algorithm>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/linalg/eye_functor.h\"\n#include \"tensorflow/core/kernels/linalg/linalg_ops_common.h\"\n#include \"tensorflow/core/kernels/transpose_functor.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/determinism.h\"\n#include \"tensorflow/core/util/gpu_kernel_helper.h\"\n#include \"tensorflow/core/util/gpu_solvers.h\"\n\nnamespace tensorflow {\n\nstatic const char kErrMsg[] =\n    \"Singular Value Decomposition was not successful. The input might not be \"\n    \"valid.\";\n\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace {\n// This kernel computes the reduction\n// V' = sum_i (M_i * U_i,1 * S_i).\n// The result is stored in V[batch] and has the same sign as the\n// real value of V (which should be computed)\ntemplate <class Scalar>\n__global__ void ComputeValueOfVKernel(Gpu2DLaunchConfig config, int64 m,\n                                      int64 ldu, const Scalar* __restrict__ M,\n                                      const Scalar* __restrict__ U,\n                                      const Scalar* __restrict__ S,\n                                      Scalar* __restrict__ V) {\n  GPU_AXIS_KERNEL_LOOP(batch, config.virtual_thread_count.x, X) {\n    GPU_AXIS_KERNEL_LOOP(i, config.virtual_thread_count.y, Y) {\n      Scalar v = M[i + m * batch] * U[ldu * (i + m * batch)] * S[batch];\n      GpuAtomicAdd(V + batch, v);\n    }\n  }\n}\n\n// Extracts the sign of V\n// V[i] = V[i]>=0 ? 1 : 0\ntemplate <class Scalar>\n__global__ void ExtractSignOfVKernel(GpuLaunchConfig config,\n                                     Scalar* __restrict__ V) {\n  GPU_1D_KERNEL_LOOP(i, config.virtual_thread_count) {\n    V[i] = V[i] >= 0 ? Scalar(1) : Scalar(-1);\n  }\n}\n}  // namespace\n\n// Scalar: The input scalar type (can be complex)\ntemplate <class Scalar>\nclass SvdOpGpu : public AsyncOpKernel {\n public:\n  using RealScalar = typename Eigen::NumTraits<Scalar>::Real;\n\n  explicit SvdOpGpu(OpKernelConstruction* context) : AsyncOpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"compute_uv\", &compute_uv_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"full_matrices\", &full_matrices_));\n    OP_REQUIRES(context, !tensorflow::OpDeterminismRequired(),\n                errors::Unimplemented(\"Determinism is not yet supported \"\n                                      \"for Svd.\"));\n  }\n\n  void RunSVD(OpKernelContext* context, DoneCallback done, int64 m, int64 n,\n              int64 p, Tensor& M_copy, Tensor* S, Tensor* U, Tensor* V,\n              std::unique_ptr<GpuSolver> solver) {\n    // Compute U S V* = M.\n    // 1. cuSolver works in column-major rather than row-major.\n    // 2. Gesvd returns V*. GesvdjBatched returns V.\n    // 3. Hence M should be transposed before input and\n    //    a) U (rather than V) should be transposed on output with Gesvd.\n    //    b) U and V should be transposed on output with GesvdjBatched.\n\n    // get the pointers to input data\n    Scalar* input_ptr;\n    RealScalar* outputS_ptr;\n    auto input_reshaped = M_copy.template flat_inner_dims<Scalar, 3>();\n    input_ptr = input_reshaped.data();\n    const int64 batch_size =\n        M_copy.dims() > 2 ? input_reshaped.dimension(0) : 1;\n    // Gesvdjbatched handles matrices up to 32x32.\n    // TODO(jamessspencer): if not full_matrices, compute full U and V matrices\n    // using Gesvdjbatched and return slices.\n    const bool batched =\n        m <= 32 && n <= 32 && batch_size > 1 && (full_matrices_ || m == n);\n\n    // Copies of U and V if required so can take transposes after SVD.\n    Tensor u_copy, v_copy;\n    Scalar* outputU_ptr = NULL;\n    Scalar* outputV_ptr = NULL;\n    if (compute_uv_ || batched) {\n      TensorShape u_shape, v_shape;\n      if (batched) {\n        // Gesvdjbatched seems to require U and V matrices even if the vectors\n        // aren't computed.\n        TensorShape shapeRaw = M_copy.shape();\n        shapeRaw.RemoveLastDims(2);\n        u_shape = shapeRaw;\n        u_shape.AddDim(m);\n        u_shape.AddDim(m);\n        v_shape = shapeRaw;\n        v_shape.AddDim(n);\n        v_shape.AddDim(n);\n      } else if (full_matrices_) {\n        u_shape = U->shape();\n        v_shape = V->shape();\n      } else {\n        TensorShape shapeRaw = M_copy.shape();\n        shapeRaw.RemoveLastDims(2);\n        u_shape = shapeRaw;\n        u_shape.AddDim(p);\n        u_shape.AddDim(m);\n        v_shape = shapeRaw;\n        v_shape.AddDim(p);\n        v_shape.AddDim(n);\n      }\n      OP_REQUIRES_OK_ASYNC(\n          context, solver->allocate_scoped_tensor(U->dtype(), u_shape, &u_copy),\n          done);\n      if (batched) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->allocate_scoped_tensor(V->dtype(), v_shape, &v_copy), done);\n      }\n      outputU_ptr = u_copy.template flat_inner_dims<Scalar, 3>().data();\n      if (batched) {\n        outputV_ptr = v_copy.template flat_inner_dims<Scalar, 3>().data();\n      } else {\n        outputV_ptr = V->template flat_inner_dims<Scalar, 3>().data();\n      }\n    }\n\n    outputS_ptr = S->template flat_inner_dims<RealScalar, 2>().data();\n    std::vector<DeviceLapackInfo> dev_info;\n    dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"gesvd\"));\n    int* dev_info_ptr = dev_info.back().mutable_data();\n\n    // Save the input matrix\n    // Needed for the n=1 fix, see below, since SVD destroys the input\n    Tensor input_copy;\n    if (compute_uv_ && n == 1) {\n      OP_REQUIRES_OK_ASYNC(context,\n                           solver->allocate_scoped_tensor(\n                               DataTypeToEnum<Scalar>::v(),\n                               TensorShape({batch_size, m}), &input_copy),\n                           done);\n      const GPUDevice& d = context->eigen_device<GPUDevice>();\n      d.memcpy(input_copy.flat<Scalar>().data(), input_ptr,\n               batch_size * m * sizeof(Scalar));\n    }\n\n    if (batched) {\n      cusolverEigMode_t jobz = CUSOLVER_EIG_MODE_NOVECTOR;\n      if (compute_uv_) jobz = CUSOLVER_EIG_MODE_VECTOR;\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->GesvdjBatched(jobz, m, n, input_ptr, m, outputS_ptr,\n                                outputU_ptr, m, outputV_ptr, n, dev_info_ptr,\n                                batch_size),\n          done);\n    } else {\n      for (int64 batch = 0; batch < batch_size; ++batch) {\n        Scalar* input = input_ptr + batch * m * n;\n        RealScalar* outputS = outputS_ptr + batch * p;\n        Scalar* outputU = NULL;\n        Scalar* outputVT = NULL;\n        char jobu = 'N';\n        char jobvt = 'N';\n\n        if (compute_uv_) {\n          if (full_matrices_) {\n            outputU = outputU_ptr + batch * m * m;\n            outputVT = outputV_ptr + batch * n * n;\n            jobu = 'A';\n            jobvt = 'A';\n          } else {\n            outputU = outputU_ptr + batch * m * p;\n            outputVT = outputV_ptr + batch * n * p;\n            jobu = 'S';\n            jobvt = 'S';\n          }\n        }\n\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->Gesvd(jobu, jobvt, m, n, input, m, outputS, outputU, m,\n                          outputVT, n, dev_info_ptr + batch),\n            done);\n      }\n    }\n\n    // This is a bug in cuSolver:\n    // If n is one, then outputVT only contains zeros instead of ones.\n    // Hence, I need to fill outputVT manually\n    // The question is: +1 or -1?\n    // -> Compute U*S and compare sign against M\n    // But because S is zero except for the first entry, the multiplication\n    // simplifies a lot.\n    // However, what happens if M contains zeros? At these indices, it is\n    // impossible to determine the value of V.\n    // -> Compute V for all rows in M to cope for zeros.\n    // 1. V' = sum_i (M_i * U_i,1 * S_i)\n    // 2. V = {1, V'>=0, -1, V'<0}\n    // TODO: what is with complex values?\n    if (compute_uv_ && n == 1) {\n      // 1. compute the (batched) sum\n      const GPUDevice& d = context->eigen_device<GPUDevice>();\n      d.memset(outputV_ptr, 0, batch_size * sizeof(Scalar));\n      Gpu2DLaunchConfig cfg2D = GetGpu2DLaunchConfig(batch_size, m, d);\n      TF_CHECK_OK(GpuLaunchKernel(ComputeValueOfVKernel<Scalar>,\n                                  cfg2D.block_count, cfg2D.thread_per_block, 0,\n                                  d.stream(), cfg2D, m, full_matrices_ ? m : p,\n                                  input_copy.flat<Scalar>().data(), outputU_ptr,\n                                  outputS_ptr, outputV_ptr));\n      // 2. clamp V to -1 or +1\n      GpuLaunchConfig cfg1D = GetGpuLaunchConfig(batch_size, d);\n      TF_CHECK_OK(GpuLaunchKernel(ExtractSignOfVKernel<Scalar>,\n                                  cfg1D.block_count, cfg1D.thread_per_block, 0,\n                                  d.stream(), cfg1D, outputV_ptr));\n    }\n\n    if (compute_uv_) {\n      auto device = context->eigen_device<GPUDevice>();\n      OP_REQUIRES_OK_ASYNC(context, DoMatrixTranspose(device, u_copy, U), done);\n      if (batched) {\n        OP_REQUIRES_OK_ASYNC(context, DoMatrixTranspose(device, v_copy, V),\n                             done);\n      }\n    }\n\n    CheckResult(context, std::move(done), dev_info, std::move(solver));\n  }\n\n  void CheckResult(OpKernelContext* context, DoneCallback done,\n                   const std::vector<DeviceLapackInfo>& dev_info,\n                   std::unique_ptr<GpuSolver> solver) {\n    auto info_checker = [context, done](\n                            const Status& status,\n                            const std::vector<HostLapackInfo>& /* unused */) {\n      Status full_status = status;\n      if (!full_status.ok()) {\n        full_status.Update(errors::InvalidArgument(kErrMsg));\n      }\n      OP_REQUIRES_OK_ASYNC(context, full_status, done);\n      done();\n    };\n\n    GpuSolver::CheckLapackInfoAndDeleteSolverAsync(std::move(solver), dev_info,\n                                                   std::move(info_checker));\n  }\n\n  // The SVD if m >= n\n  // TODO: can the two cases (MgeqN and MlessN) be simplified,\n  //   common boilerplate be reduced, or even combined in one method?\n  void PerformSVD_MgeqN(OpKernelContext* context, DoneCallback done, int64 m,\n                        int64 n, int64 p, const Tensor& M, Tensor* S, Tensor* U,\n                        Tensor* V) {\n    // Transpose M, because cuSolver expects it to be column-major\n    TensorShape shapeRaw = M.shape();\n    shapeRaw.RemoveLastDims(2);\n    TensorShape input_shape = shapeRaw;\n    input_shape.AddDim(n);\n    input_shape.AddDim(m);\n    Tensor input_copy;\n    // TODO(rmlarsen): Convert to std::make_unique when available.\n    std::unique_ptr<GpuSolver> solver(new GpuSolver(context));\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->allocate_scoped_tensor(M.dtype(), input_shape, &input_copy),\n        done);\n    auto device = context->eigen_device<GPUDevice>();\n    OP_REQUIRES_OK_ASYNC(context, DoMatrixTranspose(device, M, &input_copy),\n                         done);\n\n    // Call the SVD: compute U S V* = M.\n    RunSVD(context, done, m, n, p, input_copy, S, U, V, std::move(solver));\n  }\n\n  // The SVD if m < n\n  void PerformSVD_MlessN(OpKernelContext* context, DoneCallback done, int64 m,\n                         int64 n, int64 p, const Tensor& M, Tensor* S,\n                         Tensor* U, Tensor* V) {\n    // Perform the SVD on M'. cuSolver works column major so don't need to\n    // transpose M.\n\n    // Reuse the input buffer or make a copy for the SVD depending on whether\n    // this op owns the input buffer exclusively. This is needed because the\n    // SVD modifies the input\n    // TODO(rmlarsen): Convert to std::make_unique when available.\n    std::unique_ptr<GpuSolver> solver(new GpuSolver(context));\n    Tensor input_copy;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->forward_input_or_allocate_scoped_tensor(\n            {0}, DataTypeToEnum<Scalar>::value, M.shape(), &input_copy),\n        done);\n\n    if (!M.SharesBufferWith(input_copy)) {\n      const GPUDevice& d = context->eigen_device<GPUDevice>();\n      d.memcpy(input_copy.flat<Scalar>().data(), M.flat<Scalar>().data(),\n               M.NumElements() * sizeof(Scalar));\n    }\n\n    // Call the SVD: compute V S U* = M*.\n    // Note (m, n) and (U, V) are swapped accordingly.\n    RunSVD(context, done, n, m, p, input_copy, S, V, U, std::move(solver));\n  }\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) final {\n    const Tensor& input = context->input(0);\n    const int ndims = input.dims();\n\n    // Validate inputs.\n    OP_REQUIRES_ASYNC(\n        context, ndims >= 2,\n        errors::InvalidArgument(\"Input must have rank >= 2, got \", ndims),\n        done);\n\n    const int64 m = input.dim_size(ndims - 2);\n    const int64 n = input.dim_size(ndims - 1);\n    const int64 p = std::min(m, n);\n\n    // output tensors.\n    Tensor* outputU = NULL;\n    Tensor* outputS = NULL;\n    Tensor* outputV = NULL;\n\n    // compute  shapes\n    TensorShape shapeRaw = input.shape();\n    shapeRaw.RemoveLastDims(2);\n    TensorShape shapeS = shapeRaw;\n    TensorShape shapeU = shapeRaw;\n    TensorShape shapeV = shapeRaw;\n    shapeS.AddDim(p);\n    if (compute_uv_) {\n      if (full_matrices_) {\n        shapeU.AddDim(m);\n        shapeU.AddDim(m);\n        shapeV.AddDim(n);\n        shapeV.AddDim(n);\n      } else {\n        shapeU.AddDim(m);\n        shapeU.AddDim(p);\n        shapeV.AddDim(n);\n        shapeV.AddDim(p);\n      }\n    } else {\n      shapeU = TensorShape({0});\n      shapeV = TensorShape({0});\n    }\n\n    // allocate output\n    OP_REQUIRES_OK_ASYNC(context, context->allocate_output(0, shapeS, &outputS),\n                         done);\n    OP_REQUIRES_OK_ASYNC(context, context->allocate_output(1, shapeU, &outputU),\n                         done);\n    OP_REQUIRES_OK_ASYNC(context, context->allocate_output(2, shapeV, &outputV),\n                         done);\n\n    // If there are zero batches, we are done.\n    if (shapeRaw.num_elements() == 0) {\n      done();\n      return;\n    }\n\n    if (n == 0 || m == 0) {\n      if (n == m || !compute_uv_ || !full_matrices_) {\n        // S, U, and V are all empty. Nothing to do.\n        done();\n        return;\n      }\n      auto device = context->eigen_device<GPUDevice>();\n      functor::EyeFunctor<GPUDevice, Scalar> eye;\n      if (m > 0) {\n        // Return a full canonical basis for the column space.\n        auto outputU_reshaped = outputU->flat_inner_dims<Scalar, 3>();\n        eye(device, outputU_reshaped);\n      } else if (n > 0) {\n        // Return a full canonical basis for the row space.\n        auto outputV_reshaped = outputV->flat_inner_dims<Scalar, 3>();\n        eye(device, outputV_reshaped);\n      }\n      done();\n      return;\n    }\n\n    // call implementations\n    if (m >= n) {\n      PerformSVD_MgeqN(context, done, m, n, p, input, outputS, outputU,\n                       outputV);\n    } else {\n      PerformSVD_MlessN(context, done, m, n, p, input, outputS, outputU,\n                        outputV);\n    }\n  }\n\n private:\n  bool compute_uv_;\n  bool full_matrices_;\n};\n\n// TODO: add support for complex types\nREGISTER_LINALG_OP_GPU(\"Svd\", (SvdOpGpu<float>), float);\nREGISTER_LINALG_OP_GPU(\"Svd\", (SvdOpGpu<double>), double);\n\n// Deprecated kernels.\nREGISTER_LINALG_OP_GPU(\"BatchSvd\", (SvdOpGpu<float>), float);\nREGISTER_LINALG_OP_GPU(\"BatchSvd\", (SvdOpGpu<double>), double);\n\n}  // namespace tensorflow\n\n#endif  // GOOGLE_CUDA\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.ops.math_ops.matrix_inverse.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.client import session\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import gradient_checker_v2\nfrom tensorflow.python.ops import gradients_impl\nfrom tensorflow.python.ops import linalg_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import stateless_random_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import benchmark\nfrom tensorflow.python.platform import test\n\n\ndef _AddTest(test_class, op_name, testcase_name, fn):\n  test_name = \"_\".join([\"test\", op_name, testcase_name])\n  if hasattr(test_class, test_name):\n    raise RuntimeError(\"Test %s defined more than once\" % test_name)\n  setattr(test_class, test_name, fn)\n\n\nclass SvdOpTest(test.TestCase):\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def testWrongDimensions(self):\n    # The input to svd should be a tensor of at least rank 2.\n    scalar = constant_op.constant(1.)\n    with self.assertRaisesRegex((ValueError, errors_impl.InvalidArgumentError),\n                                \"rank.* 2.*0\"):\n      linalg_ops.svd(scalar)\n    vector = constant_op.constant([1., 2.])\n    with self.assertRaisesRegex((ValueError, errors_impl.InvalidArgumentError),\n                                \"rank.* 2.*1\"):\n      linalg_ops.svd(vector)\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def testThrowDeterminismError(self):\n    shape = [6, 5]\n    seed = [42, 24]\n    matrix1 = stateless_random_ops.stateless_random_normal(shape, seed)\n    with test_util.deterministic_ops():\n      if test_util.is_gpu_available(cuda_only=True):\n        with self.assertRaisesRegex(\n            errors_impl.UnimplementedError, \"Determinism is not yet supported \"\n            \"for Svd.\"):\n          self.evaluate(linalg_ops.svd(matrix1))\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def DISABLED_testBadInputs(self):\n    # TODO(b/185822300): re-enable after the bug is fixed in CUDA-11.x\n    # The input to svd should be a tensor of at least rank 2.\n    for bad_val in [np.nan, np.inf]:\n      matrix = np.array([[1, bad_val], [0, 1]])\n      s, u, v = linalg_ops.svd(matrix, compute_uv=True)\n      s, u, v = self.evaluate([s, u, v])\n      for i in range(2):\n        self.assertTrue(np.isnan(s[i]))\n        for j in range(2):\n          self.assertTrue(np.isnan(u[i, j]))\n          self.assertTrue(np.isnan(v[i, j]))\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def testExecuteMultipleWithoutError(self):\n    all_ops = []\n    shape = [6, 5]\n    seed = [42, 24]\n    for compute_uv_ in True, False:\n      for full_matrices_ in True, False:\n        matrix1 = stateless_random_ops.stateless_random_normal(shape, seed)\n        matrix2 = stateless_random_ops.stateless_random_normal(shape, seed)\n        self.assertAllEqual(matrix1, matrix2)\n        if compute_uv_:\n          s1, u1, v1 = linalg_ops.svd(\n              matrix1, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          s2, u2, v2 = linalg_ops.svd(\n              matrix2, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          all_ops += [s1, s2, u1, u2, v1, v2]\n        else:\n          s1 = linalg_ops.svd(\n              matrix1, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          s2 = linalg_ops.svd(\n              matrix2, compute_uv=compute_uv_, full_matrices=full_matrices_)\n          all_ops += [s1, s2]\n    val = self.evaluate(all_ops)\n    for i in range(0, len(val), 2):\n      self.assertAllEqual(val[i], val[i + 1])\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def testEmptyBatches(self):\n    matrices = constant_op.constant(1.0, shape=[0, 2, 2])\n    s, u, v = self.evaluate(linalg_ops.svd(matrices))\n    self.assertAllEqual(s, np.zeros([0, 2]))\n    self.assertAllEqual(u, np.zeros([0, 2, 2]))\n    self.assertAllEqual(v, np.zeros([0, 2, 2]))\n\n\ndef _GetSvdOpTest(dtype_, shape_, use_static_shape_, compute_uv_,\n                  full_matrices_):\n\n  def CompareSingularValues(self, x, y, tol):\n    atol = (x[0] + y[0]) * tol if len(x) else tol\n    self.assertAllClose(x, y, atol=atol)\n\n  def CompareSingularVectors(self, x, y, rank, tol):\n    # We only compare the first 'rank' singular vectors since the\n    # remainder form an arbitrary orthonormal basis for the\n    # (row- or column-) null space, whose exact value depends on\n    # implementation details. Notice that since we check that the\n    # matrices of singular vectors are unitary elsewhere, we do\n    # implicitly test that the trailing vectors of x and y span the\n    # same space.\n    x = x[..., 0:rank]\n    y = y[..., 0:rank]\n    # Singular vectors are only unique up to sign (complex phase factor for\n    # complex matrices), so we normalize the sign first.\n    sum_of_ratios = np.sum(np.divide(y, x), -2, keepdims=True)\n    phases = np.divide(sum_of_ratios, np.abs(sum_of_ratios))\n    x *= phases\n    self.assertAllClose(x, y, atol=2 * tol)\n\n  def CheckApproximation(self, a, u, s, v, full_matrices_, tol):\n    # Tests that a ~= u*diag(s)*transpose(v).\n    batch_shape = a.shape[:-2]\n    m = a.shape[-2]\n    n = a.shape[-1]\n    diag_s = math_ops.cast(array_ops.matrix_diag(s), dtype=dtype_)\n    if full_matrices_:\n      if m > n:\n        zeros = array_ops.zeros(batch_shape + (m - n, n), dtype=dtype_)\n        diag_s = array_ops.concat([diag_s, zeros], a.ndim - 2)\n      elif n > m:\n        zeros = array_ops.zeros(batch_shape + (m, n - m), dtype=dtype_)\n        diag_s = array_ops.concat([diag_s, zeros], a.ndim - 1)\n    a_recon = math_ops.matmul(u, diag_s)\n    a_recon = math_ops.matmul(a_recon, v, adjoint_b=True)\n    self.assertAllClose(a_recon, a, rtol=tol, atol=tol)\n\n  def CheckUnitary(self, x, tol):\n    # Tests that x[...,:,:]^H * x[...,:,:] is close to the identity.\n    xx = math_ops.matmul(x, x, adjoint_a=True)\n    identity = array_ops.matrix_band_part(array_ops.ones_like(xx), 0, 0)\n    self.assertAllClose(identity, xx, atol=tol)\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def Test(self):\n    if not use_static_shape_ and context.executing_eagerly():\n      return\n    is_complex = dtype_ in (np.complex64, np.complex128)\n    is_single = dtype_ in (np.float32, np.complex64)\n    tol = 3e-4 if is_single else 1e-12\n    if test.is_gpu_available():\n      # The gpu version returns results that are much less accurate.\n      tol *= 200\n    np.random.seed(42)\n    x_np = np.random.uniform(\n        low=-1.0, high=1.0, size=np.prod(shape_)).reshape(shape_).astype(dtype_)\n    if is_complex:\n      x_np += 1j * np.random.uniform(\n          low=-1.0, high=1.0,\n          size=np.prod(shape_)).reshape(shape_).astype(dtype_)\n\n    if use_static_shape_:\n      x_tf = constant_op.constant(x_np)\n    else:\n      x_tf = array_ops.placeholder(dtype_)\n\n    if compute_uv_:\n      s_tf, u_tf, v_tf = linalg_ops.svd(\n          x_tf, compute_uv=compute_uv_, full_matrices=full_matrices_)\n      if use_static_shape_:\n        s_tf_val, u_tf_val, v_tf_val = self.evaluate([s_tf, u_tf, v_tf])\n      else:\n        with self.session() as sess:\n          s_tf_val, u_tf_val, v_tf_val = sess.run(\n              [s_tf, u_tf, v_tf], feed_dict={x_tf: x_np})\n    else:\n      s_tf = linalg_ops.svd(\n          x_tf, compute_uv=compute_uv_, full_matrices=full_matrices_)\n      if use_static_shape_:\n        s_tf_val = self.evaluate(s_tf)\n      else:\n        with self.session() as sess:\n          s_tf_val = sess.run(s_tf, feed_dict={x_tf: x_np})\n\n    if compute_uv_:\n      u_np, s_np, v_np = np.linalg.svd(\n          x_np, compute_uv=compute_uv_, full_matrices=full_matrices_)\n    else:\n      s_np = np.linalg.svd(\n          x_np, compute_uv=compute_uv_, full_matrices=full_matrices_)\n    # We explicitly avoid the situation where numpy eliminates a first\n    # dimension that is equal to one.\n    s_np = np.reshape(s_np, s_tf_val.shape)\n\n    CompareSingularValues(self, s_np, s_tf_val, tol)\n    if compute_uv_:\n      CompareSingularVectors(self, u_np, u_tf_val, min(shape_[-2:]), tol)\n      CompareSingularVectors(self, np.conj(np.swapaxes(v_np, -2, -1)), v_tf_val,\n                             min(shape_[-2:]), tol)\n      CheckApproximation(self, x_np, u_tf_val, s_tf_val, v_tf_val,\n                         full_matrices_, tol)\n      CheckUnitary(self, u_tf_val, tol)\n      CheckUnitary(self, v_tf_val, tol)\n\n  return Test\n\n\nclass SvdGradOpTest(test.TestCase):\n  pass  # Filled in below\n\n\ndef _NormalizingSvd(tf_a, full_matrices_):\n  tf_s, tf_u, tf_v = linalg_ops.svd(\n      tf_a, compute_uv=True, full_matrices=full_matrices_)\n  # Singular vectors are only unique up to an arbitrary phase. We normalize\n  # the vectors such that the first component of u (if m >=n) or v (if n > m)\n  # have phase 0.\n  m = tf_a.shape[-2]\n  n = tf_a.shape[-1]\n  if m >= n:\n    top_rows = tf_u[..., 0:1, :]\n  else:\n    top_rows = tf_v[..., 0:1, :]\n  if tf_u.dtype.is_complex:\n    angle = -math_ops.angle(top_rows)\n    phase = math_ops.complex(math_ops.cos(angle), math_ops.sin(angle))\n  else:\n    phase = math_ops.sign(top_rows)\n  tf_u *= phase[..., :m]\n  tf_v *= phase[..., :n]\n  return tf_s, tf_u, tf_v\n\n\ndef _GetSvdGradOpTest(dtype_, shape_, compute_uv_, full_matrices_):\n\n  @test_util.run_in_graph_and_eager_modes(use_gpu=True)\n  def Test(self):\n\n    def RandomInput():\n      np.random.seed(42)\n      a = np.random.uniform(low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      if dtype_ in [np.complex64, np.complex128]:\n        a += 1j * np.random.uniform(\n            low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      return a\n\n    # Optimal stepsize for central difference is O(epsilon^{1/3}).\n    # See Equation (21) in:\n    # http://www.karenkopecky.net/Teaching/eco613614/Notes_NumericalDifferentiation.pdf\n    # TODO(rmlarsen): Move step size control to gradient checker.\n    epsilon = np.finfo(dtype_).eps\n    delta = 0.25 * epsilon**(1.0 / 3.0)\n    if dtype_ in [np.float32, np.complex64]:\n      tol = 3e-2\n    else:\n      tol = 1e-6\n    if compute_uv_:\n      funcs = [\n          lambda a: _NormalizingSvd(a, full_matrices_)[0],\n          lambda a: _NormalizingSvd(a, full_matrices_)[1],\n          lambda a: _NormalizingSvd(a, full_matrices_)[2]\n      ]\n    else:\n      funcs = [lambda a: linalg_ops.svd(a, compute_uv=False)]\n\n    for f in funcs:\n      theoretical, numerical = gradient_checker_v2.compute_gradient(\n          f, [RandomInput()], delta=delta)\n      self.assertAllClose(theoretical, numerical, atol=tol, rtol=tol)\n\n  return Test\n\n\nclass SvdGradGradOpTest(test.TestCase):\n  pass  # Filled in below\n\n\ndef _GetSvdGradGradOpTest(dtype_, shape_, compute_uv_, full_matrices_):\n\n  @test_util.run_v1_only(\"b/120545219\")\n  def Test(self):\n    np.random.seed(42)\n    a = np.random.uniform(low=-1.0, high=1.0, size=shape_).astype(dtype_)\n    if dtype_ in [np.complex64, np.complex128]:\n      a += 1j * np.random.uniform(\n          low=-1.0, high=1.0, size=shape_).astype(dtype_)\n    # Optimal stepsize for central difference is O(epsilon^{1/3}).\n    # See Equation (21) in:\n    # http://www.karenkopecky.net/Teaching/eco613614/Notes_NumericalDifferentiation.pdf\n    # TODO(rmlarsen): Move step size control to gradient checker.\n    epsilon = np.finfo(dtype_).eps\n    delta = 0.1 * epsilon**(1.0 / 3.0)\n    tol = 1e-5\n    with self.session():\n      tf_a = constant_op.constant(a)\n      if compute_uv_:\n        tf_s, tf_u, tf_v = _NormalizingSvd(tf_a, full_matrices_)\n        outputs = [tf_s, tf_u, tf_v]\n      else:\n        tf_s = linalg_ops.svd(tf_a, compute_uv=False)\n        outputs = [tf_s]\n      outputs_sums = [math_ops.reduce_sum(o) for o in outputs]\n      tf_func_outputs = math_ops.add_n(outputs_sums)\n      grad = gradients_impl.gradients(tf_func_outputs, tf_a)[0]\n      x_init = np.random.uniform(\n          low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      if dtype_ in [np.complex64, np.complex128]:\n        x_init += 1j * np.random.uniform(\n            low=-1.0, high=1.0, size=shape_).astype(dtype_)\n      theoretical, numerical = gradient_checker.compute_gradient(\n          tf_a,\n          tf_a.get_shape().as_list(),\n          grad,\n          grad.get_shape().as_list(),\n          x_init_value=x_init,\n          delta=delta)\n      self.assertAllClose(theoretical, numerical, atol=tol, rtol=tol)\n  return Test\n\n\nclass SVDBenchmark(test.Benchmark):\n\n  shapes = [\n      (4, 4),\n      (8, 8),\n      (16, 16),\n      (101, 101),\n      (256, 256),\n      (1024, 1024),\n      (2048, 2048),\n      (1, 8, 8),\n      (10, 8, 8),\n      (100, 8, 8),\n      (1000, 8, 8),\n      (1, 32, 32),\n      (10, 32, 32),\n      (100, 32, 32),\n      (1000, 32, 32),\n      (1, 256, 256),\n      (10, 256, 256),\n      (100, 256, 256),\n  ]\n\n  def benchmarkSVDOp(self):\n    for shape_ in self.shapes:\n      with ops.Graph().as_default(), \\\n          session.Session(config=benchmark.benchmark_config()) as sess, \\\n          ops.device(\"/cpu:0\"):\n        matrix_value = np.random.uniform(\n            low=-1.0, high=1.0, size=shape_).astype(np.float32)\n        matrix = variables.Variable(matrix_value)\n        u, s, v = linalg_ops.svd(matrix)\n        self.evaluate(variables.global_variables_initializer())\n        self.run_op_benchmark(\n            sess,\n            control_flow_ops.group(u, s, v),\n            min_iters=25,\n            name=\"SVD_cpu_{shape}\".format(shape=shape_))\n\n      if test.is_gpu_available(True):\n        with ops.Graph().as_default(), \\\n            session.Session(config=benchmark.benchmark_config()) as sess, \\\n            ops.device(\"/device:GPU:0\"):\n          matrix_value = np.random.uniform(\n              low=-1.0, high=1.0, size=shape_).astype(np.float32)\n          matrix = variables.Variable(matrix_value)\n          u, s, v = linalg_ops.svd(matrix)\n          self.evaluate(variables.global_variables_initializer())\n          self.run_op_benchmark(\n              sess,\n              control_flow_ops.group(u, s, v),\n              min_iters=25,\n              name=\"SVD_gpu_{shape}\".format(shape=shape_))\n\n\nif __name__ == \"__main__\":\n  dtypes_to_test = [np.float32, np.float64, np.complex64, np.complex128]\n  for compute_uv in False, True:\n    for full_matrices in False, True:\n      for dtype in dtypes_to_test:\n        for rows in 0, 1, 2, 5, 10, 32, 100:\n          for cols in 0, 1, 2, 5, 10, 32, 100:\n            for batch_dims in [(), (3,)] + [(3, 2)] * (max(rows, cols) < 10):\n              full_shape = batch_dims + (rows, cols)\n              for use_static_shape in set([True, False]):\n                name = \"%s_%s_static_shape_%s__compute_uv_%s_full_%s\" % (\n                    dtype.__name__, \"_\".join(map(str, full_shape)),\n                    use_static_shape, compute_uv, full_matrices)\n                _AddTest(\n                    SvdOpTest, \"Svd\", name,\n                    _GetSvdOpTest(dtype, full_shape, use_static_shape,\n                                  compute_uv, full_matrices))\n  for compute_uv in False, True:\n    for full_matrices in False, True:\n      dtypes = ([np.float32, np.float64] + [np.complex64, np.complex128] *\n                (not compute_uv))\n      for dtype in dtypes:\n        mat_shapes = [(10, 11), (11, 10), (11, 11), (2, 2, 2, 3)]\n        if not full_matrices or not compute_uv:\n          mat_shapes += [(5, 11), (11, 5)]\n        for mat_shape in mat_shapes:\n          for batch_dims in [(), (3,)]:\n            full_shape = batch_dims + mat_shape\n            name = \"%s_%s_compute_uv_%s_full_%s\" % (dtype.__name__, \"_\".join(\n                map(str, full_shape)), compute_uv, full_matrices)\n            _AddTest(\n                SvdGradOpTest, \"SvdGrad\", name,\n                _GetSvdGradOpTest(dtype, full_shape, compute_uv, full_matrices))\n            # The results are too inaccurate for float32.\n            if dtype in (np.float64, np.complex128):\n              _AddTest(\n                  SvdGradGradOpTest, \"SvdGradGrad\", name,\n                  _GetSvdGradGradOpTest(dtype, full_shape, compute_uv,\n                                        full_matrices))\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/linalg/svd_op_gpu.cu.cc", "tensorflow/python/kernel_tests/linalg/svd_op_test.py"], "buggy_code_start_loc": [397, 109], "buggy_code_end_loc": [397, 109], "fixing_code_start_loc": [398, 110], "fixing_code_end_loc": [404, 118], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. When `tf.linalg.matrix_rank` receives an empty input `a`, the GPU kernel gives a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit c55b476aa0e0bd4ee99d0f3ad18d9d706cd1260a. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35988", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T22:15:11.607", "lastModified": "2022-09-20T14:54:36.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. When `tf.linalg.matrix_rank` receives an empty input `a`, the GPU kernel gives a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit c55b476aa0e0bd4ee99d0f3ad18d9d706cd1260a. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. Cuando \"tf.linalg.matrix_rank\" recibe una entrada vac\u00eda \"a\", el kernel de la GPU da un fallo \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit de GitHub c55b476aa0e0bd4ee99d0f3ad18d9d706cd1260a. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/c55b476aa0e0bd4ee99d0f3ad18d9d706cd1260a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-9vqj-64pv-w55c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/c55b476aa0e0bd4ee99d0f3ad18d9d706cd1260a"}}