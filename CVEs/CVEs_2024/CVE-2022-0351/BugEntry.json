{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\n#ifdef FEAT_CMDWIN\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\n#endif\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\nEXTERN char e_src_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= N_(\"E38: Null argument\"));\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= N_(\"E43: Damaged match string\"));\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= N_(\"E44: Corrupted regexp program\"));\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\nEXTERN char e_nr_more_file_to_edit[]\n\tINIT(= N_(\"E173: %d more file to edit\"));\nEXTERN char e_nr_more_files_to_edit[]\n\tINIT(= N_(\"E173: %d more files to edit\"));\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\n#ifdef FEAT_CMDWIN\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\n#endif\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= N_(\"E222: Add to internal buffer that was already read from\"));\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= N_(\"E228: makemap: Illegal mode\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= N_(\"E232: Cannot create BalloonEval with both message and callback\"));\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: no registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: no matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= N_(\"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\"));\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= N_(\"E292: Invalid count for del_bytes(): %ld\"));\nEXTERN char e_block_was_not_locked[]\n\tINIT(= N_(\"E293: block was not locked\"));\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= N_(\"E298: Didn't get block nr 0?\"));\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= N_(\"E298: Didn't get block nr 1?\"));\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= N_(\"E298: Didn't get block nr 2?\"));\n// E299 unused\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= N_(\"E304: ml_upd_block0(): Didn't get block 0??\"));\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= N_(\"E315: ml_get: invalid lnum: %ld\"));\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= N_(\"E316: ml_get: cannot find line %ld in buffer %d %s\"));\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= N_(\"E317: pointer block id wrong\"));\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= N_(\"E317: pointer block id wrong 2\"));\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= N_(\"E317: pointer block id wrong 3\"));\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= N_(\"E317: pointer block id wrong 4\"));\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= N_(\"E318: Updated too many blocks?\"));\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= N_(\"E320: Cannot find line %ld\"));\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= N_(\"E322: line number out of range: %ld past the end\"));\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= N_(\"E323: line count wrong in block %ld\"));\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\n// E340 unused\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= N_(\"E341: Internal error: lalloc(0, )\"));\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\n#ifdef FEAT_PATH_EXTRA\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\n#endif\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\n#endif\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= N_(\"E356: get_varp ERROR\"));\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\n#endif\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_canot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= N_(\"E438: u_undo: line numbers wrong\"));\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= N_(\"E439: undo list corrupt\"));\nEXTERN char e_undo_line_missing[]\n\tINIT(= N_(\"E440: undo line missing\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#endif\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= N_(\"E473: Internal error in regexp\"));\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: no call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: json decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: no autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_name_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: no autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: no autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: no :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_canot_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: netbeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\n// E538 unused\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: at bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: at top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: no cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= N_(\"E570: fatal error in cs_manage_matches\"));\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_here[]\n\tINIT(= N_(\"E578: Not allowed to change text here\"));\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_vim_selfile_cant_return_to_current_directory[]\n\tINIT(= N_(\"E614: vim_SelFile: can't return to current directory\"));\nEXTERN char e_vim_selfile_cant_get_current_directory[]\n\tINIT(= N_(\"E615: vim_SelFile: can't get current directory\"));\nEXTERN char e_vim_selfile_cant_get_font_str[]\n\tINIT(= N_(\"E616: vim_SelFile: can't get font %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: file \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: file \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= \"E627: missing colon: %s\");\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= \"E628: missing ! or / in: %s\");\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= \"E632: invalid buffer identifier in getLength\");\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= \"E633: invalid buffer identifier in getText\");\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= \"E634: invalid buffer identifier in remove\");\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= \"E635: invalid buffer identifier in insert\");\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= \"E636: invalid buffer identifier in create\");\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= \"E637: invalid buffer identifier in startDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= \"E638: invalid buffer identifier in stopDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= \"E639: invalid buffer identifier in setTitle\");\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= \"E640: invalid buffer identifier in initDone\");\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= \"E641: invalid buffer identifier in setBufferNumber\");\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= \"E642: File %s not found in setBufferNumber\");\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= \"E643: invalid buffer identifier in setFullName\");\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= \"E644: invalid buffer identifier in editFile\");\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= \"E645: invalid buffer identifier in setVisible\");\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= \"E646: invalid buffer identifier in setModified\");\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= \"E647: invalid buffer identifier in setDot\");\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= \"E648: invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= \"E649: invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= \"E650: invalid buffer identifier in defineAnnoType\");\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= \"E651: invalid buffer identifier in addAnno\");\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= \"E652: Invalid buffer identifier in getAnno\");\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_acwrite_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for acwrite buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: list index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_can_only_index_list_dictionary_or_blob[]\n\tINIT(= N_(\"E689: Can only index a List, Dictionary or Blob\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\n// E693 unused\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\n// E706 unused\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dicitonary[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n# ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n\t// E796\n# ifdef MSWIN\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: using Float as a String\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\n#endif\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= N_(\"E831: bf_key_init() called with empty password\"));\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: netbeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: no line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= N_(\"E877: (NFA regexp) Invalid character class: %d\"));\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: not an open channel\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\nEXTERN char e_expected_dict[]\n\tINIT(= N_(\"E922: expected a dict\"));\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= N_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: no line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: setting %s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= N_(\"E967: text property info corrupted\"));\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_type_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\n# ifdef FEAT_FLOAT\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\n# endif\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type[]\n\tINIT(= N_(\"E1008: Missing <type>\"));\nEXTERN char e_missing_gt_after_type[]\n\tINIT(= N_(\"E1009: Missing > after type\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item %s\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\n#ifdef FEAT_EVAL\n// E1065 unused\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n#ifndef FEAT_FLOAT\nEXTERN char e_this_vim_is_not_compiled_with_float_support[]\n\tINIT(= N_(\"E1076: This Vim is not compiled with float support\"));\n#endif\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n// E1078 unused\n// E1079 unused\n// E1080 unused\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\nEXTERN char e_function_reference_invalid[]\n\tINIT(= N_(\"E1086: Function reference invalid\"));\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\n// E1088 unused\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\n// E1092 unused\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_return[]\n\tINIT(= N_(\"E1095: Unreachable code after :return\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\nEXTERN char e_one_argument_too_many[]\n\tINIT(= N_(\"E1106: One argument too many\"));\nEXTERN char e_nr_arguments_too_many[]\n\tINIT(= N_(\"E1106: %d arguments too many\"));\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\nEXTERN char e_item_not_found_str[]\n\tINIT(= N_(\"E1108: Item not found: %s\"));\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x100_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x100 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_list[]\n\tINIT(= N_(\"E1118: Cannot change list\"));\nEXTERN char e_cannot_change_list_item[]\n\tINIT(= N_(\"E1119: Cannot change list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\nEXTERN char e_cmd_maping_must_not_include_str_key[]\n\tINIT(= N_(\"E1137: <Cmd> mapping must not include %s key\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\n// E1169 unused\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_blob_required[]\n\tINIT(= N_(\"E1182: Blob required\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1185: Cannot nest :redir\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL) && defined(FEAT_CMDWIN)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\nEXTERN char e_one_argument_too_few[]\n\tINIT(= N_(\"E1190: One argument too few\"));\nEXTERN char e_nr_arguments_too_few[]\n\tINIT(= N_(\"E1190: %d arguments too few\"));\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_can_only_be_used_on_dictionary_str[]\n\tINIT(= N_(\"E1203: Dot can only be used on a dictionary: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS) && defined(FEAT_EVAL)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_reference_is_not_set[]\n\tINIT(= N_(\"E1235: Function reference is not set\"));\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\nEXTERN char e_string_expected_for_argument_nr[]\n\tINIT(= N_(\"E1253: String expected for argument %d\"));\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_using_autoload_name_in_non_autoload_script_str[]\n\tINIT(= N_(\"E1263: Using autoload name in a non-autoload script: %s\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * eval.c: Expression evaluation.\n */\n#define USING_FLOAT_STUFF\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n#ifdef VMS\n# include <float.h>\n#endif\n\n#define NAMESPACE_CHAR\t(char_u *)\"abglstvw\"\n\n/*\n * When recursively copying lists and dicts we need to remember which ones we\n * have done to avoid endless recursiveness.  This unique ID is used for that.\n * The last bit is used for previous_funccal, ignored when comparing.\n */\nstatic int current_copyID = 0;\n\n/*\n * Info used by a \":for\" loop.\n */\ntypedef struct\n{\n    int\t\tfi_semicolon;\t// TRUE if ending in '; var]'\n    int\t\tfi_varcount;\t// nr of variables in the list\n    int\t\tfi_break_count;\t// nr of line breaks encountered\n    listwatch_T\tfi_lw;\t\t// keep an eye on the item used.\n    list_T\t*fi_list;\t// list being used\n    int\t\tfi_bi;\t\t// index of blob\n    blob_T\t*fi_blob;\t// blob being used\n    char_u\t*fi_string;\t// copy of string being used\n    int\t\tfi_byte_idx;\t// byte index in fi_string\n} forinfo_T;\n\nstatic int eval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval7t(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval7(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval7_leader(typval_T *rettv, int numeric_only, char_u *start_leader, char_u **end_leaderp);\n\nstatic int free_unref_items(int copyID);\nstatic char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);\n\n/*\n * Return \"n1\" divided by \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_divide(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    varnumber_T\tresult;\n\n    if (n2 == 0)\n    {\n\tif (in_vim9script())\n\t{\n\t    emsg(_(e_divide_by_zero));\n\t    if (failed != NULL)\n\t\t*failed = TRUE;\n\t}\n\tif (n1 == 0)\n\t    result = VARNUM_MIN; // similar to NaN\n\telse if (n1 < 0)\n\t    result = -VARNUM_MAX;\n\telse\n\t    result = VARNUM_MAX;\n    }\n    else\n\tresult = n1 / n2;\n\n    return result;\n}\n\n/*\n * Return \"n1\" modulus \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_modulus(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    if (n2 == 0 && in_vim9script())\n    {\n\temsg(_(e_divide_by_zero));\n\tif (failed != NULL)\n\t    *failed = TRUE;\n    }\n    return (n2 == 0) ? 0 : (n1 % n2);\n}\n\n/*\n * Initialize the global and v: variables.\n */\n    void\neval_init(void)\n{\n    evalvars_init();\n    func_init();\n\n#ifdef EBCDIC\n    /*\n     * Sort the function table, to enable binary search.\n     */\n    sortFunctions();\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\neval_clear(void)\n{\n    evalvars_clear();\n    free_scriptnames();  // must come after evalvars_clear().\n    free_locales();\n\n    // autoloaded script names\n    free_autoload_scriptnames();\n\n    // unreferenced lists and dicts\n    (void)garbage_collect(FALSE);\n\n    // functions not garbage collected\n    free_all_functions();\n}\n#endif\n\n    void\nfill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (getline_equal(eap->getline, eap->cookie, getsourceline))\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}\n\n/*\n * Top level evaluation function, returning a boolean.\n * Sets \"error\" to TRUE if there was an error.\n * Return TRUE or FALSE.\n */\n    int\neval_to_bool(\n    char_u\t*arg,\n    int\t\t*error,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    varnumber_T\tretval = FALSE;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL)\n\t*error = TRUE;\n    else\n    {\n\t*error = FALSE;\n\tif (!skip)\n\t{\n\t    if (in_vim9script())\n\t\tretval = tv_get_bool_chk(&tv, error);\n\t    else\n\t\tretval = (tv_get_number_chk(&tv, error) != 0);\n\t    clear_tv(&tv);\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return (int)retval;\n}\n\n/*\n * Call eval1() and give an error message if not done at a lower level.\n */\n    static int\neval1_emsg(char_u **arg, typval_T *rettv, exarg_T *eap)\n{\n    char_u\t*start = *arg;\n    int\t\tret;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    ret = eval1(arg, rettv, &evalarg);\n    if (ret == FAIL)\n    {\n\t// Report the invalid expression unless the expression evaluation has\n\t// been cancelled due to an aborting error, an interrupt, or an\n\t// exception, or we already gave a more specific error.\n\t// Also check called_emsg for when using assert_fails().\n\tif (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t    semsg(_(e_invalid_expression_str), start);\n    }\n    clear_evalarg(&evalarg, eap);\n    return ret;\n}\n\n/*\n * Return whether a typval is a valid expression to pass to eval_expr_typval()\n * or eval_expr_to_bool().  An empty string returns FALSE;\n */\n    int\neval_expr_valid_arg(typval_T *tv)\n{\n    return tv->v_type != VAR_UNKNOWN\n\t    && (tv->v_type != VAR_STRING\n\t\t  || (tv->vval.v_string != NULL && *tv->vval.v_string != NUL));\n}\n\n/*\n * Evaluate an expression, which can be a function, partial or string.\n * Pass arguments \"argv[argc]\".\n * Return the result in \"rettv\" and OK or FAIL.\n */\n    int\neval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n{\n    char_u\t*s;\n    char_u\tbuf[NUMBUFLEN];\n    funcexe_T\tfuncexe;\n\n    if (expr->v_type == VAR_FUNC)\n    {\n\ts = expr->vval.v_string;\n\tif (s == NULL || *s == NUL)\n\t    return FAIL;\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_evaluate = TRUE;\n\tif (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t    return FAIL;\n    }\n    else if (expr->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *partial = expr->vval.v_partial;\n\n\tif (partial == NULL)\n\t    return FAIL;\n\n\tif (partial->pt_func != NULL\n\t\t\t  && partial->pt_func->uf_def_status != UF_NOT_COMPILED)\n\t{\n\t    if (call_def_function(partial->pt_func, argc, argv,\n\t\t\t\t\t\t       partial, rettv) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    s = partial_name(partial);\n\t    if (s == NULL || *s == NUL)\n\t\treturn FAIL;\n\t    CLEAR_FIELD(funcexe);\n\t    funcexe.fe_evaluate = TRUE;\n\t    funcexe.fe_partial = partial;\n\t    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (expr->v_type == VAR_INSTR)\n    {\n\treturn exe_typval_instr(expr, rettv);\n    }\n    else\n    {\n\ts = tv_get_string_buf_chk(expr, buf);\n\tif (s == NULL)\n\t    return FAIL;\n\ts = skipwhite(s);\n\tif (eval1_emsg(&s, rettv, NULL) == FAIL)\n\t    return FAIL;\n\tif (*skipwhite(s) != NUL)  // check for trailing chars after expr\n\t{\n\t    clear_tv(rettv);\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Like eval_to_bool() but using a typval_T instead of a string.\n * Works for string, funcref and partial.\n */\n    int\neval_expr_to_bool(typval_T *expr, int *error)\n{\n    typval_T\trettv;\n    int\t\tres;\n\n    if (eval_expr_typval(expr, NULL, 0, &rettv) == FAIL)\n    {\n\t*error = TRUE;\n\treturn FALSE;\n    }\n    res = (tv_get_bool_chk(&rettv, error) != 0);\n    clear_tv(&rettv);\n    return res;\n}\n\n/*\n * Top level evaluation function, returning a string.  If \"skip\" is TRUE,\n * only parsing to \"nextcmd\" is done, without reporting errors.  Return\n * pointer to allocated memory, or NULL for failure or when \"skip\" is TRUE.\n */\n    char_u *\neval_to_string_skip(\n    char_u\t*arg,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL || skip)\n\tretval = NULL;\n    else\n    {\n\tretval = vim_strsave(tv_get_string(&tv));\n\tclear_tv(&tv);\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return retval;\n}\n\n/*\n * Skip over an expression at \"*pp\".\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr(char_u **pp, evalarg_T *evalarg)\n{\n    typval_T\trettv;\n\n    *pp = skipwhite(*pp);\n    return eval1(pp, &rettv, evalarg);\n}\n\n/*\n * Skip over an expression at \"*arg\".\n * If in Vim9 script and line breaks are encountered, the lines are\n * concatenated.  \"evalarg->eval_tofree\" will be set accordingly.\n * \"arg\" is advanced to just after the expression.\n * \"start\" is set to the start of the expression, \"end\" to just after the end.\n * Also when the expression is copied to allocated memory.\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\t// leave room for \"start\"\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n    // Don't evaluate the expression.\n    if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t    // just the one line, no need to concatenate\n\t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t    // Line breaks encountered, concatenate all the lines.\n\t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t    // free the lines only when using getsourceline()\n\t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t// Do not free the first line, the caller can still use it.\n\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t// Do not free the last line, \"arg\" points into it, free it\n\t\t// later.\n\t\tvim_free(evalarg->eval_tofree);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t// free lines that were explicitly marked for freeing\n\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t    // Compute \"end\" relative to the end.\n\t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Convert \"tv\" to a string.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Returns an allocated string (NULL when out of memory).\n */\n    char_u *\ntypval2string(typval_T *tv, int convert)\n{\n    garray_T\tga;\n    char_u\t*retval;\n#ifdef FEAT_FLOAT\n    char_u\tnumbuf[NUMBUFLEN];\n#endif\n\n    if (convert && tv->v_type == VAR_LIST)\n    {\n\tga_init2(&ga, sizeof(char), 80);\n\tif (tv->vval.v_list != NULL)\n\t{\n\t    list_join(&ga, tv->vval.v_list, (char_u *)\"\\n\", TRUE, FALSE, 0);\n\t    if (tv->vval.v_list->lv_len > 0)\n\t\tga_append(&ga, NL);\n\t}\n\tga_append(&ga, NUL);\n\tretval = (char_u *)ga.ga_data;\n    }\n#ifdef FEAT_FLOAT\n    else if (convert && tv->v_type == VAR_FLOAT)\n    {\n\tvim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\tretval = vim_strsave(numbuf);\n    }\n#endif\n    else\n\tretval = vim_strsave(tv_get_string(tv));\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a string.  Does not handle line\n * breaks.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Return pointer to allocated memory, or NULL for failure.\n */\n    char_u *\neval_to_string_eap(\n    char_u\t*arg,\n    int\t\tconvert,\n    exarg_T\t*eap)\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n    if (eval0(arg, &tv, NULL, &evalarg) == FAIL)\n\tretval = NULL;\n    else\n    {\n\tretval = typval2string(&tv, convert);\n\tclear_tv(&tv);\n    }\n    clear_evalarg(&evalarg, NULL);\n\n    return retval;\n}\n\n    char_u *\neval_to_string(\n    char_u\t*arg,\n    int\t\tconvert)\n{\n    return eval_to_string_eap(arg, convert, NULL);\n}\n\n/*\n * Call eval_to_string() without using current local variables and using\n * textwinlock.  When \"use_sandbox\" is TRUE use the sandbox.\n * Use legacy Vim script syntax.\n */\n    char_u *\neval_to_string_safe(\n    char_u\t*arg,\n    int\t\tuse_sandbox,\n    int\t\tkeep_script_version)\n{\n    char_u\t*retval;\n    funccal_entry_T funccal_entry;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n    int\t\tsave_garbage = may_garbage_collect;\n\n    if (!keep_script_version)\n\tcurrent_sctx.sc_version = 1;\n    save_funccal(&funccal_entry);\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n    may_garbage_collect = FALSE;\n    retval = eval_to_string(arg, FALSE);\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n    may_garbage_collect = save_garbage;\n    restore_funccal();\n    current_sctx.sc_version = save_sc_version;\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a number.\n * Evaluates \"expr\" silently.\n * Returns -1 for an error.\n */\n    varnumber_T\neval_to_number(char_u *expr)\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n    char_u\t*p = skipwhite(expr);\n\n    ++emsg_off;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == FAIL)\n\tretval = -1;\n    else\n    {\n\tretval = tv_get_number_chk(&rettv, NULL);\n\tclear_tv(&rettv);\n    }\n    --emsg_off;\n\n    return retval;\n}\n\n/*\n * Top level evaluation function.\n * Returns an allocated typval_T with the result.\n * Returns NULL when there is an error.\n */\n    typval_T *\neval_expr(char_u *arg, exarg_T *eap)\n{\n    typval_T\t*tv;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    tv = ALLOC_ONE(typval_T);\n    if (tv != NULL && eval0(arg, tv, eap, &evalarg) == FAIL)\n\tVIM_CLEAR(tv);\n\n    clear_evalarg(&evalarg, eap);\n    return tv;\n}\n\n/*\n * \"*arg\" points to what can be a function name in the form of \"import.Name\" or\n * \"Funcref\".  Return the name of the function.  Set \"tofree\" to something that\n * was allocated.\n * If \"verbose\" is FALSE no errors are given.\n * Return NULL for any failure.\n */\n    static char_u *\nderef_function_name(\n\t    char_u **arg,\n\t    char_u **tofree,\n\t    evalarg_T *evalarg,\n\t    int verbose)\n{\n    typval_T\tref;\n    char_u\t*name = *arg;\n\n    ref.v_type = VAR_UNKNOWN;\n    if (eval7(arg, &ref, evalarg, FALSE) == FAIL)\n\treturn NULL;\n    if (*skipwhite(*arg) != NUL)\n    {\n\tif (verbose)\n\t    semsg(_(e_trailing_characters_str), *arg);\n\tname = NULL;\n    }\n    else if (ref.v_type == VAR_FUNC && ref.vval.v_string != NULL)\n    {\n\tname = ref.vval.v_string;\n\tref.vval.v_string = NULL;\n\t*tofree = name;\n    }\n    else if (ref.v_type == VAR_PARTIAL && ref.vval.v_partial != NULL)\n    {\n\tif (ref.vval.v_partial->pt_argc > 0\n\t\t|| ref.vval.v_partial->pt_dict != NULL)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_use_partial_here));\n\t    name = NULL;\n\t}\n\telse\n\t{\n\t    name = vim_strsave(partial_name(ref.vval.v_partial));\n\t    *tofree = name;\n\t}\n    }\n    else\n    {\n\tif (verbose)\n\t    semsg(_(e_not_callable_type_str), name);\n\tname = NULL;\n    }\n    clear_tv(&ref);\n    return name;\n}\n\n/*\n * Call some Vim script function and return the result in \"*rettv\".\n * Uses argv[0] to argv[argc - 1] for the function arguments.  argv[argc]\n * should have type VAR_UNKNOWN.\n * Returns OK or FAIL.\n */\n    int\ncall_vim_function(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv,\n    typval_T\t*rettv)\n{\n    int\t\tret;\n    funcexe_T\tfuncexe;\n    char_u\t*arg;\n    char_u\t*name;\n    char_u\t*tofree = NULL;\n\n    rettv->v_type = VAR_UNKNOWN;\t\t// clear_tv() uses this\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = TRUE;\n\n    // The name might be \"import.Func\" or \"Funcref\".\n    arg = func;\n    ++emsg_off;\n    name = deref_function_name(&arg, &tofree, &EVALARG_EVALUATE, FALSE);\n    --emsg_off;\n    if (name == NULL)\n\tname = func;\n\n    ret = call_func(name, -1, rettv, argc, argv, &funcexe);\n\n    if (ret == FAIL)\n\tclear_tv(rettv);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a string.\n * Uses \"argv[0]\" to \"argv[argc - 1]\" for the function arguments. \"argv[argc]\"\n * should have type VAR_UNKNOWN.\n * Returns NULL when calling the function fails.\n */\n    void *\ncall_func_retstr(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n    char_u\t*retval;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    retval = vim_strsave(tv_get_string(&rettv));\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a List.\n * Uses \"argv\" and \"argc\" as call_func_retstr().\n * Returns NULL when there is something wrong.\n */\n    void *\ncall_func_retlist(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    if (rettv.v_type != VAR_LIST)\n    {\n\tclear_tv(&rettv);\n\treturn NULL;\n    }\n\n    return rettv.vval.v_list;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Evaluate \"arg\", which is 'foldexpr'.\n * Note: caller must set \"curwin\" to match \"arg\".\n * Returns the foldlevel, and any character preceding it in \"*cp\".  Doesn't\n * give error messages.\n */\n    int\neval_foldexpr(win_T *wp, int *cp)\n{\n    char_u\t*arg;\n    typval_T\ttv;\n    varnumber_T\tretval;\n    char_u\t*s;\n    sctx_T\tsaved_sctx = current_sctx;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"foldexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    arg = wp->w_p_fde;\n    current_sctx = wp->w_p_script_ctx[WV_FDE];\n\n    ++emsg_off;\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n    *cp = NUL;\n    if (eval0(arg, &tv, NULL, &EVALARG_EVALUATE) == FAIL)\n\tretval = 0;\n    else\n    {\n\t// If the result is a number, just return the number.\n\tif (tv.v_type == VAR_NUMBER)\n\t    retval = tv.vval.v_number;\n\telse if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL)\n\t    retval = 0;\n\telse\n\t{\n\t    // If the result is a string, check if there is a non-digit before\n\t    // the number.\n\t    s = tv.vval.v_string;\n\t    if (!VIM_ISDIGIT(*s) && *s != '-')\n\t\t*cp = *s++;\n\t    retval = atol((char *)s);\n\t}\n\tclear_tv(&tv);\n    }\n    --emsg_off;\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n    clear_evalarg(&EVALARG_EVALUATE, NULL);\n    current_sctx = saved_sctx;\n\n    return (int)retval;\n}\n#endif\n\n/*\n * Get an lval: variable, Dict item or List item that can be assigned a value\n * to: \"name\", \"na{me}\", \"name[expr]\", \"name[expr:expr]\", \"name[expr][expr]\",\n * \"name.key\", \"name.key[expr]\" etc.\n * Indexing only works if \"name\" is an existing List or Dictionary.\n * \"name\" points to the start of the name.\n * If \"rettv\" is not NULL it points to the value to be assigned.\n * \"unlet\" is TRUE for \":unlet\": slightly different behavior when something is\n * wrong; must end in space or cmd separator.\n *\n * flags:\n *  GLV_QUIET:       do not give error messages\n *  GLV_READ_ONLY:   will not change the variable\n *  GLV_NO_AUTOLOAD: do not use script autoloading\n *\n * Returns a pointer to just after the name, including indexes.\n * When an evaluation error occurs \"lp->ll_name\" is NULL;\n * Returns NULL for a parsing error.  Still need to free items in \"lp\"!\n */\n    char_u *\nget_lval(\n    char_u\t*name,\n    typval_T\t*rettv,\n    lval_T\t*lp,\n    int\t\tunlet,\n    int\t\tskip,\n    int\t\tflags,\t    // GLV_ values\n    int\t\tfne_flags)  // flags for find_name_end()\n{\n    char_u\t*p;\n    char_u\t*expr_start, *expr_end;\n    int\t\tcc;\n    dictitem_T\t*v;\n    typval_T\tvar1;\n    typval_T\tvar2;\n    int\t\tempty1 = FALSE;\n    char_u\t*key = NULL;\n    int\t\tlen;\n    hashtab_T\t*ht = NULL;\n    int\t\tquiet = flags & GLV_QUIET;\n    int\t\twriting;\n\n    // Clear everything in \"lp\".\n    CLEAR_POINTER(lp);\n\n    if (skip || (flags & GLV_COMPILING))\n    {\n\t// When skipping or compiling just find the end of the name.\n\tlp->ll_name = name;\n\tlp->ll_name_end = find_name_end(name, NULL, NULL,\n\t\t\t\t\t\t      FNE_INCL_BR | fne_flags);\n\treturn lp->ll_name_end;\n    }\n\n    // Find the end of the name.\n    p = find_name_end(name, &expr_start, &expr_end, fne_flags);\n    lp->ll_name_end = p;\n    if (expr_start != NULL)\n    {\n\t// Don't expand the name when we already know there is an error.\n\tif (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)\n\t\t\t\t\t\t    && *p != '[' && *p != '.')\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\n\tlp->ll_exp_name = make_expanded_name(name, expr_start, expr_end, p);\n\tif (lp->ll_exp_name == NULL)\n\t{\n\t    // Report an invalid expression in braces, unless the\n\t    // expression evaluation has been cancelled due to an\n\t    // aborting error, an interrupt, or an exception.\n\t    if (!aborting() && !quiet)\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_invalid_argument_str), name);\n\t\treturn NULL;\n\t    }\n\t}\n\tlp->ll_name = lp->ll_exp_name;\n    }\n    else\n    {\n\tlp->ll_name = name;\n\n\tif (in_vim9script())\n\t{\n\t    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n\t    if (p == name + 2 && p[-1] == ':')\n\t    {\n\t\t--p;\n\t\tlp->ll_name_end = p;\n\t    }\n\t    if (*p == ':')\n\t    {\n\t\tgarray_T    tmp_type_list;\n\t\tgarray_T    *type_list;\n\t\tchar_u\t    *tp = skipwhite(p + 1);\n\n\t\tif (tp == p + 1 && !quiet)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \":\", p);\n\t\t    return NULL;\n\t\t}\n\n\t\tif (SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t\t    type_list = &SCRIPT_ITEM(current_sctx.sc_sid)->sn_type_list;\n\t\telse\n\t\t{\n\t\t    type_list = &tmp_type_list;\n\t\t    ga_init2(type_list, sizeof(type_T), 10);\n\t\t}\n\n\t\t// parse the type after the name\n\t\tlp->ll_type = parse_type(&tp, type_list, !quiet);\n\t\tif (lp->ll_type == NULL && !quiet)\n\t\t    return NULL;\n\t\tlp->ll_name_end = tp;\n\n\t\t// drop the type when not in a script\n\t\tif (type_list == &tmp_type_list)\n\t\t{\n\t\t    lp->ll_type = NULL;\n\t\t    clear_type_list(type_list);\n\t\t}\n\t    }\n\t}\n    }\n    if (lp->ll_name == NULL)\n\treturn p;\n\n    if (*p == '.' && in_vim9script())\n    {\n\timported_T *import = find_imported(lp->ll_name, p - lp->ll_name,\n\t\t\t\t\t\t\t\t   TRUE, NULL);\n\n\tif (import != NULL)\n\t{\n\t    ufunc_T *ufunc;\n\t    type_T *type;\n\n\t    lp->ll_sid = import->imp_sid;\n\t    lp->ll_name = skipwhite(p + 1);\n\t    p = find_name_end(lp->ll_name, NULL, NULL, fne_flags);\n\t    lp->ll_name_end = p;\n\n\t    // check the item is exported\n\t    cc = *p;\n\t    *p = NUL;\n\t    if (find_exported(import->imp_sid, lp->ll_name, &ufunc, &type,\n\t\t\t\t\t\t\t     NULL, TRUE) == -1)\n\t    {\n\t\t*p = cc;\n\t\treturn NULL;\n\t    }\n\t    *p = cc;\n\t}\n    }\n\n    // Without [idx] or .key we are done.\n    if ((*p != '[' && *p != '.'))\n\treturn p;\n\n    if (in_vim9script() && lval_root != NULL)\n    {\n\t// using local variable\n\tlp->ll_tv = lval_root;\n\tv = NULL;\n    }\n    else\n    {\n\tcc = *p;\n\t*p = NUL;\n\t// When we would write to the variable pass &ht and prevent autoload.\n\twriting = !(flags & GLV_READ_ONLY);\n\tv = find_var(lp->ll_name, writing ? &ht : NULL,\n\t\t\t\t\t (flags & GLV_NO_AUTOLOAD) || writing);\n\tif (v == NULL && !quiet)\n\t    semsg(_(e_undefined_variable_str), lp->ll_name);\n\t*p = cc;\n\tif (v == NULL)\n\t    return NULL;\n\tlp->ll_tv = &v->di_tv;\n    }\n\n    if (in_vim9script() && (flags & GLV_NO_DECL) == 0)\n    {\n\tif (!quiet)\n\t    semsg(_(e_variable_already_declared), lp->ll_name);\n\treturn NULL;\n    }\n\n    /*\n     * Loop until no more [idx] or .key is following.\n     */\n    var1.v_type = VAR_UNKNOWN;\n    var2.v_type = VAR_UNKNOWN;\n    while (*p == '[' || (*p == '.' && p[1] != '=' && p[1] != '.'))\n    {\n\tif (*p == '.' && lp->ll_tv->v_type != VAR_DICT)\n\t{\n\t    if (!quiet)\n\t\tsemsg(_(e_dot_can_only_be_used_on_dictionary_str), name);\n\t    return NULL;\n\t}\n\tif (lp->ll_tv->v_type != VAR_LIST\n\t\t&& lp->ll_tv->v_type != VAR_DICT\n\t\t&& lp->ll_tv->v_type != VAR_BLOB)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_can_only_index_list_dictionary_or_blob));\n\t    return NULL;\n\t}\n\n\t// a NULL list/blob works like an empty list/blob, allocate one now.\n\tif (lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list == NULL)\n\t    rettv_list_alloc(lp->ll_tv);\n\telse if (lp->ll_tv->v_type == VAR_BLOB\n\t\t\t\t\t     && lp->ll_tv->vval.v_blob == NULL)\n\t    rettv_blob_alloc(lp->ll_tv);\n\n\tif (lp->ll_range)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_slice_must_come_last));\n\t    return NULL;\n\t}\n\n\tif (in_vim9script() && lp->ll_valtype == NULL\n\t\t&& v != NULL\n\t\t&& lp->ll_tv == &v->di_tv\n\t\t&& ht != NULL && ht == get_script_local_ht())\n\t{\n\t    svar_T  *sv = find_typval_in_script(lp->ll_tv, 0);\n\n\t    // Vim9 script local variable: get the type\n\t    if (sv != NULL)\n\t\tlp->ll_valtype = sv->sv_type;\n\t}\n\n\tlen = -1;\n\tif (*p == '.')\n\t{\n\t    key = p + 1;\n\t    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)\n\t\t;\n\t    if (len == 0)\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_cannot_use_empty_key_for_dictionary));\n\t\treturn NULL;\n\t    }\n\t    p = key + len;\n\t}\n\telse\n\t{\n\t    // Get the index [expr] or the first index [expr: ].\n\t    p = skipwhite(p + 1);\n\t    if (*p == ':')\n\t\tempty1 = TRUE;\n\t    else\n\t    {\n\t\tempty1 = FALSE;\n\t\tif (eval1(&p, &var1, &EVALARG_EVALUATE) == FAIL)  // recursive!\n\t\t    return NULL;\n\t\tif (tv_get_string_chk(&var1) == NULL)\n\t\t{\n\t\t    // not a number or string\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\n\t    // Optionally get the second index [ :expr].\n\t    if (*p == ':')\n\t    {\n\t\tif (lp->ll_tv->v_type == VAR_DICT)\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_cannot_slice_dictionary));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (rettv != NULL\n\t\t\t&& !(rettv->v_type == VAR_LIST\n\t\t\t\t\t\t && rettv->vval.v_list != NULL)\n\t\t\t&& !(rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t&& rettv->vval.v_blob != NULL))\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_slice_requires_list_or_blob_value));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p + 1);\n\t\tif (*p == ']')\n\t\t    lp->ll_empty2 = TRUE;\n\t\telse\n\t\t{\n\t\t    lp->ll_empty2 = FALSE;\n\t\t    // recursive!\n\t\t    if (eval1(&p, &var2, &EVALARG_EVALUATE) == FAIL)\n\t\t    {\n\t\t\tclear_tv(&var1);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (tv_get_string_chk(&var2) == NULL)\n\t\t    {\n\t\t\t// not a number or string\n\t\t\tclear_tv(&var1);\n\t\t\tclear_tv(&var2);\n\t\t\treturn NULL;\n\t\t    }\n\t\t}\n\t\tlp->ll_range = TRUE;\n\t    }\n\t    else\n\t\tlp->ll_range = FALSE;\n\n\t    if (*p != ']')\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_missing_closing_square_brace));\n\t\tclear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    // Skip to past ']'.\n\t    ++p;\n\t}\n\n\tif (lp->ll_tv->v_type == VAR_DICT)\n\t{\n\t    if (len == -1)\n\t    {\n\t\t// \"[key]\": get key from \"var1\"\n\t\tkey = tv_get_string_chk(&var1);\t// is number or string\n\t\tif (key == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t    lp->ll_list = NULL;\n\n\t    // a NULL dict is equivalent with an empty dict\n\t    if (lp->ll_tv->vval.v_dict == NULL)\n\t    {\n\t\tlp->ll_tv->vval.v_dict = dict_alloc();\n\t\tif (lp->ll_tv->vval.v_dict == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\t++lp->ll_tv->vval.v_dict->dv_refcount;\n\t    }\n\t    lp->ll_dict = lp->ll_tv->vval.v_dict;\n\n\t    lp->ll_di = dict_find(lp->ll_dict, key, len);\n\n\t    // When assigning to a scope dictionary check that a function and\n\t    // variable name is valid (only variable name unless it is l: or\n\t    // g: dictionary). Disallow overwriting a builtin function.\n\t    if (rettv != NULL && lp->ll_dict->dv_scope != 0)\n\t    {\n\t\tint prevval;\n\t\tint wrong;\n\n\t\tif (len != -1)\n\t\t{\n\t\t    prevval = key[len];\n\t\t    key[len] = NUL;\n\t\t}\n\t\telse\n\t\t    prevval = 0; // avoid compiler warning\n\t\twrong = (lp->ll_dict->dv_scope == VAR_DEF_SCOPE\n\t\t\t       && rettv->v_type == VAR_FUNC\n\t\t\t       && var_wrong_func_name(key, lp->ll_di == NULL))\n\t\t\t|| !valid_varname(key, -1, TRUE);\n\t\tif (len != -1)\n\t\t    key[len] = prevval;\n\t\tif (wrong)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    if (lp->ll_di == NULL)\n\t    {\n\t\t// Can't add \"v:\" or \"a:\" variable.\n\t\tif (lp->ll_dict == get_vimvar_dict()\n\t\t\t || &lp->ll_dict->dv_hashtab == get_funccal_args_ht())\n\t\t{\n\t\t    semsg(_(e_illegal_variable_name_str), name);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\n\t\t// Key does not exist in dict: may need to add it.\n\t\tif (*p == '[' || *p == '.' || unlet)\n\t\t{\n\t\t    if (!quiet)\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (len == -1)\n\t\t    lp->ll_newkey = vim_strsave(key);\n\t\telse\n\t\t    lp->ll_newkey = vim_strnsave(key, len);\n\t\tclear_tv(&var1);\n\t\tif (lp->ll_newkey == NULL)\n\t\t    p = NULL;\n\t\tbreak;\n\t    }\n\t    // existing variable, need to check if it can be changed\n\t    else if ((flags & GLV_READ_ONLY) == 0\n\t\t\t&& (var_check_ro(lp->ll_di->di_flags, name, FALSE)\n\t\t\t  || var_check_lock(lp->ll_di->di_flags, name, FALSE)))\n\t    {\n\t\tclear_tv(&var1);\n\t\treturn NULL;\n\t    }\n\n\t    clear_tv(&var1);\n\t    lp->ll_tv = &lp->ll_di->di_tv;\n\t}\n\telse if (lp->ll_tv->v_type == VAR_BLOB)\n\t{\n\t    long bloblen = blob_len(lp->ll_tv->vval.v_blob);\n\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    if (check_blob_index(bloblen, lp->ll_n1, quiet) == FAIL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\tclear_tv(&var2);\n\t\tif (check_blob_range(bloblen, lp->ll_n1, lp->ll_n2, quiet)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return NULL;\n\t    }\n\t    lp->ll_blob = lp->ll_tv->vval.v_blob;\n\t    lp->ll_tv = NULL;\n\t    break;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    lp->ll_dict = NULL;\n\t    lp->ll_list = lp->ll_tv->vval.v_list;\n\t    lp->ll_li = check_range_index_one(lp->ll_list, &lp->ll_n1, quiet);\n\t    if (lp->ll_li == NULL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    /*\n\t     * May need to find the item or absolute index for the second\n\t     * index of a range.\n\t     * When no index given: \"lp->ll_empty2\" is TRUE.\n\t     * Otherwise \"lp->ll_n2\" is set to the second index.\n\t     */\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\t\t\t\t\t    // is number or string\n\t\tclear_tv(&var2);\n\t\tif (check_range_index_two(lp->ll_list,\n\t\t\t\t\t    &lp->ll_n1, lp->ll_li,\n\t\t\t\t\t    &lp->ll_n2, quiet) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    lp->ll_tv = &lp->ll_li->li_tv;\n\t}\n    }\n\n    clear_tv(&var1);\n    lp->ll_name_end = p;\n    return p;\n}\n\n/*\n * Clear lval \"lp\" that was filled by get_lval().\n */\n    void\nclear_lval(lval_T *lp)\n{\n    vim_free(lp->ll_exp_name);\n    vim_free(lp->ll_newkey);\n}\n\n/*\n * Set a variable that was parsed by get_lval() to \"rettv\".\n * \"endp\" points to just after the parsed name.\n * \"op\" is NULL, \"+\" for \"+=\", \"-\" for \"-=\", \"*\" for \"*=\", \"/\" for \"/=\",\n * \"%\" for \"%=\", \".\" for \".=\" or \"=\" for \"=\".\n */\n    void\nset_var_lval(\n    lval_T\t*lp,\n    char_u\t*endp,\n    typval_T\t*rettv,\n    int\t\tcopy,\n    int\t\tflags,\t    // ASSIGN_CONST, ASSIGN_NO_DECL\n    char_u\t*op,\n    int\t\tvar_idx)    // index for \"let [a, b] = list\"\n{\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *endp;\n\t*endp = NUL;\n\tif (in_vim9script() && check_reserved_name(lp->ll_name) == FAIL)\n\t    return;\n\n\tif (lp->ll_blob != NULL)\n\t{\n\t    int\t    error = FALSE, val;\n\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\treturn;\n\t    }\n\t    if (value_check_lock(lp->ll_blob->bv_lock, lp->ll_name, FALSE))\n\t\treturn;\n\n\t    if (lp->ll_range && rettv->v_type == VAR_BLOB)\n\t    {\n\t\tif (lp->ll_empty2)\n\t\t    lp->ll_n2 = blob_len(lp->ll_blob) - 1;\n\n\t\tif (blob_set_range(lp->ll_blob, lp->ll_n1, lp->ll_n2,\n\t\t\t\t\t\t\t\trettv) == FAIL)\n\t\t    return;\n\t    }\n\t    else\n\t    {\n\t\tval = (int)tv_get_number_chk(rettv, &error);\n\t\tif (!error)\n\t\t    blob_set_append(lp->ll_blob, lp->ll_n1, val);\n\t    }\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    typval_T tv;\n\n\t    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t    {\n\t\temsg(_(e_cannot_modify_existing_variable));\n\t\t*endp = cc;\n\t\treturn;\n\t    }\n\n\t    // handle +=, -=, *=, /=, %= and .=\n\t    di = NULL;\n\t    if (eval_variable(lp->ll_name, (int)STRLEN(lp->ll_name),\n\t\t\t\t lp->ll_sid, &tv, &di, EVAL_VAR_VERBOSE) == OK)\n\t    {\n\t\tif ((di == NULL\n\t\t\t || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)\n\t\t\t   && !tv_check_lock(&di->di_tv, lp->ll_name, FALSE)))\n\t\t\t&& tv_op(&tv, rettv, op) == OK)\n\t\t    set_var_const(lp->ll_name, lp->ll_sid, NULL, &tv, FALSE,\n\t\t\t\t\t\t\t    ASSIGN_NO_DECL, 0);\n\t\tclear_tv(&tv);\n\t    }\n\t}\n\telse\n\t{\n\t    if (lp->ll_type != NULL && check_typval_arg_type(lp->ll_type, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t\treturn;\n\t    set_var_const(lp->ll_name, lp->ll_sid, lp->ll_type, rettv, copy,\n\t\t\t\t\t\t\t       flags, var_idx);\n\t}\n\t*endp = cc;\n    }\n    else if (value_check_lock(lp->ll_newkey == NULL\n\t\t? lp->ll_tv->v_lock\n\t\t: lp->ll_tv->vval.v_dict->dv_lock, lp->ll_name, FALSE))\n\t;\n    else if (lp->ll_range)\n    {\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_range));\n\t    return;\n\t}\n\n\t(void)list_assign_range(lp->ll_list, rettv->vval.v_list,\n\t\t\t lp->ll_n1, lp->ll_n2, lp->ll_empty2, op, lp->ll_name);\n    }\n    else\n    {\n\t/*\n\t * Assign to a List or Dictionary item.\n\t */\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_list_or_dict));\n\t    return;\n\t}\n\n\tif (lp->ll_valtype != NULL\n\t\t    && check_typval_arg_type(lp->ll_valtype, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t    return;\n\n\tif (lp->ll_newkey != NULL)\n\t{\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_key_not_present_in_dictionary), lp->ll_newkey);\n\t\treturn;\n\t    }\n\t    if (dict_wrong_func_name(lp->ll_tv->vval.v_dict, rettv,\n\t\t\t\t\t\t\t\tlp->ll_newkey))\n\t\treturn;\n\n\t    // Need to add an item to the Dictionary.\n\t    di = dictitem_alloc(lp->ll_newkey);\n\t    if (di == NULL)\n\t\treturn;\n\t    if (dict_add(lp->ll_tv->vval.v_dict, di) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\treturn;\n\t    }\n\t    lp->ll_tv = &di->di_tv;\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    tv_op(lp->ll_tv, rettv, op);\n\t    return;\n\t}\n\telse\n\t    clear_tv(lp->ll_tv);\n\n\t/*\n\t * Assign the value to the variable or list item.\n\t */\n\tif (copy)\n\t    copy_tv(rettv, lp->ll_tv);\n\telse\n\t{\n\t    *lp->ll_tv = *rettv;\n\t    lp->ll_tv->v_lock = 0;\n\t    init_tv(rettv);\n\t}\n    }\n}\n\n/*\n * Handle \"tv1 += tv2\", \"tv1 -= tv2\", \"tv1 *= tv2\", \"tv1 /= tv2\", \"tv1 %= tv2\"\n * and \"tv1 .= tv2\"\n * Returns OK or FAIL.\n */\n    int\ntv_op(typval_T *tv1, typval_T *tv2, char_u *op)\n{\n    varnumber_T\tn;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*s;\n    int\t\tfailed = FALSE;\n\n    // Can't do anything with a Funcref or Dict on the right.\n    // v:true and friends only work with \"..=\".\n    if (tv2->v_type != VAR_FUNC && tv2->v_type != VAR_DICT\n\t\t    && ((tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)\n\t\t\t\t\t\t\t\t|| *op == '.'))\n    {\n\tswitch (tv1->v_type)\n\t{\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t    case VAR_DICT:\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\n\t    case VAR_BLOB:\n\t\tif (*op != '+' || tv2->v_type != VAR_BLOB)\n\t\t    break;\n\t\t// BLOB += BLOB\n\t\tif (tv1->vval.v_blob != NULL && tv2->vval.v_blob != NULL)\n\t\t{\n\t\t    blob_T  *b1 = tv1->vval.v_blob;\n\t\t    blob_T  *b2 = tv2->vval.v_blob;\n\t\t    int\ti, len = blob_len(b2);\n\t\t    for (i = 0; i < len; i++)\n\t\t\tga_append(&b1->bv_ga, blob_get(b2, i));\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_LIST:\n\t\tif (*op != '+' || tv2->v_type != VAR_LIST)\n\t\t    break;\n\t\t// List += List\n\t\tif (tv2->vval.v_list != NULL)\n\t\t{\n\t\t    if (tv1->vval.v_list == NULL)\n\t\t    {\n\t\t\ttv1->vval.v_list = tv2->vval.v_list;\n\t\t\t++tv1->vval.v_list->lv_refcount;\n\t\t    }\n\t\t    else\n\t\t\tlist_extend(tv1->vval.v_list, tv2->vval.v_list, NULL);\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_NUMBER:\n\t    case VAR_STRING:\n\t\tif (tv2->v_type == VAR_LIST)\n\t\t    break;\n\t\tif (vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t\t{\n\t\t    // nr += nr , nr -= nr , nr *=nr , nr /= nr , nr %= nr\n\t\t    n = tv_get_number(tv1);\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tfloat_T f = n;\n\n\t\t\tif (*op == '%')\n\t\t\t    break;\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': f += tv2->vval.v_float; break;\n\t\t\t    case '-': f -= tv2->vval.v_float; break;\n\t\t\t    case '*': f *= tv2->vval.v_float; break;\n\t\t\t    case '/': f /= tv2->vval.v_float; break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': n += tv_get_number(tv2); break;\n\t\t\t    case '-': n -= tv_get_number(tv2); break;\n\t\t\t    case '*': n *= tv_get_number(tv2); break;\n\t\t\t    case '/': n = num_divide(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t    case '%': n = num_modulus(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tbreak;\n\n\t\t    // str .= str\n\t\t    s = tv_get_string(tv1);\n\t\t    s = concat_str(s, tv_get_string_buf(tv2, numbuf));\n\t\t    clear_tv(tv1);\n\t\t    tv1->v_type = VAR_STRING;\n\t\t    tv1->vval.v_string = s;\n\t\t}\n\t\treturn failed ? FAIL : OK;\n\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    float_T f;\n\n\t\t    if (*op == '%' || *op == '.'\n\t\t\t\t   || (tv2->v_type != VAR_FLOAT\n\t\t\t\t    && tv2->v_type != VAR_NUMBER\n\t\t\t\t    && tv2->v_type != VAR_STRING))\n\t\t\tbreak;\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tf = tv2->vval.v_float;\n\t\t    else\n\t\t\tf = tv_get_number(tv2);\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': tv1->vval.v_float += f; break;\n\t\t\tcase '-': tv1->vval.v_float -= f; break;\n\t\t\tcase '*': tv1->vval.v_float *= f; break;\n\t\t\tcase '/': tv1->vval.v_float /= f; break;\n\t\t    }\n\t\t}\n#endif\n\t\treturn OK;\n\t}\n    }\n\n    semsg(_(e_wrong_variable_type_for_str_equal), op);\n    return FAIL;\n}\n\n/*\n * Evaluate the expression used in a \":for var in expr\" command.\n * \"arg\" points to \"var\".\n * Set \"*errp\" to TRUE for an error, FALSE otherwise;\n * Return a pointer that holds the info.  Null when there is an error.\n */\n    void *\neval_for_line(\n    char_u\t*arg,\n    int\t\t*errp,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    forinfo_T\t*fi;\n    char_u\t*var_list_end;\n    char_u\t*expr;\n    typval_T\ttv;\n    list_T\t*l;\n    int\t\tskip = !(evalarg->eval_flags & EVAL_EVALUATE);\n\n    *errp = TRUE;\t// default: there is an error\n\n    fi = ALLOC_CLEAR_ONE(forinfo_T);\n    if (fi == NULL)\n\treturn NULL;\n\n    var_list_end = skip_var_list(arg, TRUE, &fi->fi_varcount,\n\t\t\t\t\t\t     &fi->fi_semicolon, FALSE);\n    if (var_list_end == NULL)\n\treturn fi;\n\n    expr = skipwhite_and_linebreak(var_list_end, evalarg);\n    if (expr[0] != 'i' || expr[1] != 'n'\n\t\t\t\t  || !(expr[2] == NUL || VIM_ISWHITE(expr[2])))\n    {\n\tif (in_vim9script() && *expr == ':' && expr != var_list_end)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), expr);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn fi;\n    }\n\n    if (skip)\n\t++emsg_skip;\n    expr = skipwhite_and_linebreak(expr + 2, evalarg);\n    if (eval0(expr, &tv, eap, evalarg) == OK)\n    {\n\t*errp = FALSE;\n\tif (!skip)\n\t{\n\t    if (tv.v_type == VAR_LIST)\n\t    {\n\t\tl = tv.vval.v_list;\n\t\tif (l == NULL)\n\t\t{\n\t\t    // a null list is like an empty list: do nothing\n\t\t    clear_tv(&tv);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Need a real list here.\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\n\t\t    // No need to increment the refcount, it's already set for\n\t\t    // the list being used in \"tv\".\n\t\t    fi->fi_list = l;\n\t\t    list_add_watch(l, &fi->fi_lw);\n\t\t    fi->fi_lw.lw_item = l->lv_first;\n\t\t}\n\t    }\n\t    else if (tv.v_type == VAR_BLOB)\n\t    {\n\t\tfi->fi_bi = 0;\n\t\tif (tv.vval.v_blob != NULL)\n\t\t{\n\t\t    typval_T btv;\n\n\t\t    // Make a copy, so that the iteration still works when the\n\t\t    // blob is changed.\n\t\t    blob_copy(tv.vval.v_blob, &btv);\n\t\t    fi->fi_blob = btv.vval.v_blob;\n\t\t}\n\t\tclear_tv(&tv);\n\t    }\n\t    else if (tv.v_type == VAR_STRING)\n\t    {\n\t\tfi->fi_byte_idx = 0;\n\t\tfi->fi_string = tv.vval.v_string;\n\t\ttv.vval.v_string = NULL;\n\t\tif (fi->fi_string == NULL)\n\t\t    fi->fi_string = vim_strsave((char_u *)\"\");\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_list_or_blob_required));\n\t\tclear_tv(&tv);\n\t    }\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    fi->fi_break_count = evalarg->eval_break_count;\n\n    return fi;\n}\n\n/*\n * Used when looping over a :for line, skip the \"in expr\" part.\n */\n    void\nskip_for_lines(void *fi_void, evalarg_T *evalarg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\ti;\n\n    for (i = 0; i < fi->fi_break_count; ++i)\n\teval_next_line(evalarg);\n}\n\n/*\n * Use the first item in a \":for\" list.  Advance to the next.\n * Assign the values to the variable (list).  \"arg\" points to the first one.\n * Return TRUE when a valid item was found, FALSE when at end of list or\n * something wrong.\n */\n    int\nnext_for_item(void *fi_void, char_u *arg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\tresult;\n    int\t\tflag = ASSIGN_FOR_LOOP | (in_vim9script()\n\t\t\t ? (ASSIGN_FINAL\n\t\t\t     // first round: error if variable exists\n\t\t\t     | (fi->fi_bi == 0 ? 0 : ASSIGN_DECL)\n\t\t\t     | ASSIGN_NO_MEMBER_TYPE)\n\t\t\t : 0);\n    listitem_T\t*item;\n    int\t\tskip_assign = in_vim9script() && arg[0] == '_'\n\t\t\t\t\t\t      && !eval_isnamec(arg[1]);\n\n    if (fi->fi_blob != NULL)\n    {\n\ttypval_T\ttv;\n\n\tif (fi->fi_bi >= blob_len(fi->fi_blob))\n\t    return FALSE;\n\ttv.v_type = VAR_NUMBER;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_number = blob_get(fi->fi_blob, fi->fi_bi);\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    return TRUE;\n\treturn ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n    }\n\n    if (fi->fi_string != NULL)\n    {\n\ttypval_T\ttv;\n\tint\t\tlen;\n\n\tlen = mb_ptr2len(fi->fi_string + fi->fi_byte_idx);\n\tif (len == 0)\n\t    return FALSE;\n\ttv.v_type = VAR_STRING;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_string = vim_strnsave(fi->fi_string + fi->fi_byte_idx, len);\n\tfi->fi_byte_idx += len;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n\tvim_free(tv.vval.v_string);\n\treturn result;\n    }\n\n    item = fi->fi_lw.lw_item;\n    if (item == NULL)\n\tresult = FALSE;\n    else\n    {\n\tfi->fi_lw.lw_item = item->li_next;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = (ex_let_vars(arg, &item->li_tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t   fi->fi_varcount, flag, NULL) == OK);\n    }\n    return result;\n}\n\n/*\n * Free the structure used to store info used by \":for\".\n */\n    void\nfree_for_info(void *fi_void)\n{\n    forinfo_T    *fi = (forinfo_T *)fi_void;\n\n    if (fi == NULL)\n\treturn;\n    if (fi->fi_list != NULL)\n    {\n\tlist_rem_watch(fi->fi_list, &fi->fi_lw);\n\tlist_unref(fi->fi_list);\n    }\n    else if (fi->fi_blob != NULL)\n\tblob_unref(fi->fi_blob);\n    else\n\tvim_free(fi->fi_string);\n    vim_free(fi);\n}\n\n    void\nset_context_for_expression(\n    expand_T\t*xp,\n    char_u\t*arg,\n    cmdidx_T\tcmdidx)\n{\n    int\t\thas_expr = cmdidx != CMD_let && cmdidx != CMD_var;\n    int\t\tc;\n    char_u\t*p;\n\n    if (cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_const || cmdidx == CMD_final)\n    {\n\txp->xp_context = EXPAND_USER_VARS;\n\tif (vim_strpbrk(arg, (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\") == NULL)\n\t{\n\t    // \":let var1 var2 ...\": find last space.\n\t    for (p = arg + STRLEN(arg); p >= arg; )\n\t    {\n\t\txp->xp_pattern = p;\n\t\tMB_PTR_BACK(arg, p);\n\t\tif (VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    return;\n\t}\n    }\n    else\n\txp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS\n\t\t\t\t\t\t\t  : EXPAND_EXPRESSION;\n    while ((xp->xp_pattern = vim_strpbrk(arg,\n\t\t\t\t  (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL)\n    {\n\tc = *xp->xp_pattern;\n\tif (c == '&')\n\t{\n\t    c = xp->xp_pattern[1];\n\t    if (c == '&')\n\t    {\n\t\t++xp->xp_pattern;\n\t\txp->xp_context = has_expr ? EXPAND_EXPRESSION : EXPAND_NOTHING;\n\t    }\n\t    else if (c != ' ')\n\t    {\n\t\txp->xp_context = EXPAND_SETTINGS;\n\t\tif ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')\n\t\t    xp->xp_pattern += 2;\n\n\t    }\n\t}\n\telse if (c == '$')\n\t{\n\t    // environment variable\n\t    xp->xp_context = EXPAND_ENV_VARS;\n\t}\n\telse if (c == '=')\n\t{\n\t    has_expr = TRUE;\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse if (c == '#'\n\t\t&& xp->xp_context == EXPAND_EXPRESSION)\n\t{\n\t    // Autoload function/variable contains '#'.\n\t    break;\n\t}\n\telse if ((c == '<' || c == '#')\n\t\t&& xp->xp_context == EXPAND_FUNCTIONS\n\t\t&& vim_strchr(xp->xp_pattern, '(') == NULL)\n\t{\n\t    // Function name can start with \"<SNR>\" and contain '#'.\n\t    break;\n\t}\n\telse if (has_expr)\n\t{\n\t    if (c == '\"')\t    // string\n\t    {\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\"')\n\t\t    if (c == '\\\\' && xp->xp_pattern[1] != NUL)\n\t\t\t++xp->xp_pattern;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '\\'')\t    // literal string\n\t    {\n\t\t// Trick: '' is like stopping and starting a literal string.\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\\'')\n\t\t    /* skip */ ;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '|')\n\t    {\n\t\tif (xp->xp_pattern[1] == '|')\n\t\t{\n\t\t    ++xp->xp_pattern;\n\t\t    xp->xp_context = EXPAND_EXPRESSION;\n\t\t}\n\t\telse\n\t\t    xp->xp_context = EXPAND_COMMANDS;\n\t    }\n\t    else\n\t\txp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse\n\t    // Doesn't look like something valid, expand as an expression\n\t    // anyway.\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\targ = xp->xp_pattern;\n\tif (*arg != NUL)\n\t    while ((c = *++arg) != NUL && (c == ' ' || c == '\\t'))\n\t\t/* skip */ ;\n    }\n\n    // \":exe one two\" completes \"two\"\n    if ((cmdidx == CMD_execute\n\t\t|| cmdidx == CMD_echo\n\t\t|| cmdidx == CMD_echon\n\t\t|| cmdidx == CMD_echomsg)\n\t    && xp->xp_context == EXPAND_EXPRESSION)\n    {\n\tfor (;;)\n\t{\n\t    char_u *n = skiptowhite(arg);\n\n\t    if (n == arg || IS_WHITE_OR_NUL(*skipwhite(n)))\n\t\tbreak;\n\t    arg = skipwhite(n);\n\t}\n    }\n\n    xp->xp_pattern = arg;\n}\n\n/*\n * Return TRUE if \"pat\" matches \"text\".\n * Does not use 'cpo' and always uses 'magic'.\n */\n    int\npattern_match(char_u *pat, char_u *text, int ic)\n{\n    int\t\tmatches = FALSE;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n\n    // avoid 'l' flag in 'cpoptions'\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = ic;\n\tmatches = vim_regexec_nl(&regmatch, text, (colnr_T)0);\n\tvim_regfree(regmatch.regprog);\n    }\n    p_cpo = save_cpo;\n    return matches;\n}\n\n/*\n * Handle a name followed by \"(\".  Both for just \"name(arg)\" and for\n * \"expr->name(arg)\".\n * Returns OK or FAIL.\n */\n    static int\neval_func(\n\tchar_u\t    **arg,\t// points to \"(\", will be advanced\n\tevalarg_T   *evalarg,\n\tchar_u\t    *name,\n\tint\t    name_len,\n\ttypval_T    *rettv,\n\tint\t    flags,\n\ttypval_T    *basetv)\t// \"expr\" for \"expr->name(arg)\"\n{\n    int\t\tevaluate = flags & EVAL_EVALUATE;\n    char_u\t*s = name;\n    int\t\tlen = name_len;\n    partial_T\t*partial;\n    int\t\tret = OK;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    if (!evaluate)\n\tcheck_vars(s, len);\n\n    // If \"s\" is the name of a variable of type VAR_FUNC\n    // use its contents.\n    s = deref_func_name(s, &len, &partial,\n\t\t in_vim9script() ? &type : NULL, !evaluate, FALSE, &found_var);\n\n    // Need to make a copy, in case evaluating the arguments makes\n    // the name invalid.\n    s = vim_strsave(s);\n    if (s == NULL || (evaluate && (*s == NUL || (flags & EVAL_CONSTANT))))\n\tret = FAIL;\n    else\n    {\n\tfuncexe_T funcexe;\n\n\t// Invoke the function.\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = evaluate;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_basetv = basetv;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\tret = get_func_tv(s, len, rettv, arg, evalarg, &funcexe);\n    }\n    vim_free(s);\n\n    // If evaluate is FALSE rettv->v_type was not set in\n    // get_func_tv, but it's needed in handle_subscript() to parse\n    // what follows. So set it here.\n    if (rettv->v_type == VAR_UNKNOWN && !evaluate && **arg == '(')\n    {\n\trettv->vval.v_string = NULL;\n\trettv->v_type = VAR_FUNC;\n    }\n\n    // Stop the expression evaluation when immediately\n    // aborting on error, or when an interrupt occurred or\n    // an exception was thrown but not caught.\n    if (evaluate && aborting())\n    {\n\tif (ret == OK)\n\t    clear_tv(rettv);\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * Get the next line source line without advancing.  But do skip over comment\n * lines.\n * Only called for Vim9 script.\n */\n    static char_u *\ngetline_peek_skip_comments(evalarg_T *evalarg)\n{\n    for (;;)\n    {\n\tchar_u *next = getline_peek(evalarg->eval_getline,\n\t\t\t\t\t\t\t evalarg->eval_cookie);\n\tchar_u *p;\n\n\tif (next == NULL)\n\t    break;\n\tp = skipwhite(next);\n\tif (*p != NUL && !vim9_comment_start(p))\n\t    return next;\n\t(void)eval_next_line(evalarg);\n    }\n    return NULL;\n}\n\n/*\n * If inside Vim9 script, \"arg\" points to the end of a line (ignoring a #\n * comment) and there is a next line, return the next line (skipping blanks)\n * and set \"getnext\".\n * Otherwise return the next non-white at or after \"arg\" and set \"getnext\" to\n * FALSE.\n * \"arg\" must point somewhere inside a line, not at the start.\n */\n    char_u *\neval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL)\n\t    && (*p == NUL || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}\n\n/*\n * To be called after eval_next_non_blank() sets \"getnext\" to TRUE.\n * Only called for Vim9 script.\n */\n    char_u *\neval_next_line(evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tvim_free(evalarg->eval_tofree);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}\n\n/*\n * Call eval_next_non_blank() and get the next line if needed.\n */\n    char_u *\nskipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg)\n{\n    int\t    getnext;\n    char_u  *p = skipwhite_and_nl(arg);\n\n    if (evalarg == NULL)\n\treturn skipwhite(arg);\n    eval_next_non_blank(p, evalarg, &getnext);\n    if (getnext)\n\treturn eval_next_line(evalarg);\n    return p;\n}\n\n/*\n * Initialize \"evalarg\" for use.\n */\n    void\ninit_evalarg(evalarg_T *evalarg)\n{\n    CLEAR_POINTER(evalarg);\n    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n}\n\n/*\n * After using \"evalarg\" filled from \"eap\": free the memory.\n */\n    void\nclear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\t// We may need to keep the original command line, e.g. for\n\t\t// \":let\" it has the variable names.  But we may also need the\n\t\t// new one, \"nextcmd\" points into it.  Keep both.\n\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}\n\n/*\n * The \"evaluate\" argument: When FALSE, the argument is only parsed but not\n * executed.  The function may return OK, but the rettv will be of type\n * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.\n */\n\n/*\n * Handle zero level expression.\n * This calls eval1() and handles error message and nextcmd.\n * Put the result in \"rettv\" when returning OK and \"evaluate\" is TRUE.\n * Note: \"rettv.v_lock\" is not set.\n * \"evalarg\" can be NULL, EVALARG_EVALUATE or a pointer.\n * Return OK or FAIL.\n */\n    int\neval0(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    return eval0_retarg(arg, rettv, eap, evalarg, NULL);\n}\n\n/*\n * Like eval0() but when \"retarg\" is not NULL store the pointer to after the\n * expression and don't check what comes after the expression.\n */\n    int\neval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n\n    // In Vim9 script a command block is not split at NL characters for\n    // commands using an expression argument.  Skip over a '#' comment to check\n    // for a following NL.  Require white space before the '#'.\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}\n\n/*\n * Handle top level expression:\n *\texpr2 ? expr1 : expr1\n *\texpr2 ?? expr1\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Note: \"rettv.v_lock\" is not set.\n *\n * Return OK or FAIL.\n */\n    int\neval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u  *p;\n    int\t    getnext;\n\n    CLEAR_POINTER(rettv);\n\n    /*\n     * Get the first variable.\n     */\n    if (eval2(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tint\t\tresult;\n\ttypval_T\tvar2;\n\tevalarg_T\t*evalarg_used = evalarg;\n\tevalarg_T\tlocal_evalarg;\n\tint\t\torig_flags;\n\tint\t\tevaluate;\n\tint\t\tvim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = evalarg_used->eval_flags & EVAL_EVALUATE;\n\n\tif (getnext)\n\t    *arg = eval_next_line(evalarg_used);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t    {\n\t\terror_white_both(p, op_falsy ? 2 : 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n\tresult = FALSE;\n\tif (evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    if (op_falsy)\n\t\tresult = tv2bool(rettv);\n\t    else if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    if (error || !op_falsy || !result)\n\t\tclear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.  Recursive!\n\t */\n\tif (op_falsy)\n\t    ++*arg;\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg - (op_falsy ? 1 : 0), op_falsy ? 2 : 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\tevalarg_used->eval_flags = (op_falsy ? !result : result)\n\t\t\t\t    ? orig_flags : orig_flags & ~EVAL_EVALUATE;\n\tif (eval1(arg, &var2, evalarg_used) == FAIL)\n\t{\n\t    evalarg_used->eval_flags = orig_flags;\n\t    return FAIL;\n\t}\n\tif (!op_falsy || !result)\n\t    *rettv = var2;\n\n\tif (!op_falsy)\n\t{\n\t    /*\n\t     * Check for the \":\".\n\t     */\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (getnext)\n\t\t*arg = eval_next_line(evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 1);\n\t\t    clear_tv(rettv);\n\t\t    evalarg_used->eval_flags = orig_flags;\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the third variable.  Recursive!\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval1(arg, &var2, evalarg_used) == FAIL)\n\t    {\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (evaluate && !result)\n\t\t*rettv = var2;\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle first level expression:\n *\texpr2 || expr2 || expr2\t    logical OR\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first variable.\n     */\n    if (eval3(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the  \"||\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '|' && p[1] == '|')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    evaluate;\n\tint\t    orig_flags;\n\tlong\t    result = FALSE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"||\".\n\t */\n\twhile (p[0] == '|' && p[1] == '|')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && in_vim9script() && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval3(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && !result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) != 0)\n\t\t    result = TRUE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle second level expression:\n *\texpr3 && expr3 && expr3\t    logical AND\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first variable.\n     */\n    if (eval4(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the \"&&\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '&' && p[1] == '&')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    orig_flags;\n\tint\t    evaluate;\n\tlong\t    result = TRUE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) == 0)\n\t\tresult = FALSE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"&&\".\n\t */\n\twhile (p[0] == '&' && p[1] == '&')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    CLEAR_FIELD(var2);\n\t    if (eval4(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) == 0)\n\t\t    result = FALSE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle third level expression:\n *\tvar1 == var2\n *\tvar1 =~ var2\n *\tvar1 != var2\n *\tvar1 !~ var2\n *\tvar1 > var2\n *\tvar1 >= var2\n *\tvar1 < var2\n *\tvar1 <= var2\n *\tvar1 is var2\n *\tvar1 isnot var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n\n    /*\n     * Get the first variable.\n     */\n    if (eval5(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\ttypval_T    var2;\n\tint\t    ic;\n\tint\t    vim9script = in_vim9script();\n\tint\t    evaluate = evalarg == NULL\n\t\t\t\t   ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (vim9script && type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), p);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case\n\telse if (p[len] == '#')\n\t{\n\t    ic = FALSE;\n\t    ++len;\n\t}\n\t// nothing appended: use 'ignorecase' if not in Vim script\n\telse\n\t    ic = vim9script ? FALSE : p_ic;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + len, evalarg);\n\tif (eval5(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (evaluate)\n\t{\n\t    int ret;\n\n\t    if (vim9script && check_compare_types(type, rettv, &var2) == FAIL)\n\t    {\n\t\tret = FAIL;\n\t\tclear_tv(rettv);\n\t    }\n\t    else\n\t\tret = typval_compare(rettv, &var2, type, ic);\n\t    clear_tv(&var2);\n\t    return ret;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Make a copy of blob \"tv1\" and append blob \"tv2\".\n */\n    void\neval_addblob(typval_T *tv1, typval_T *tv2)\n{\n    blob_T  *b1 = tv1->vval.v_blob;\n    blob_T  *b2 = tv2->vval.v_blob;\n    blob_T  *b = blob_alloc();\n    int\t    i;\n\n    if (b != NULL)\n    {\n\tfor (i = 0; i < blob_len(b1); i++)\n\t    ga_append(&b->bv_ga, blob_get(b1, i));\n\tfor (i = 0; i < blob_len(b2); i++)\n\t    ga_append(&b->bv_ga, blob_get(b2, i));\n\n\tclear_tv(tv1);\n\trettv_blob_set(tv1, b);\n    }\n}\n\n/*\n * Make a copy of list \"tv1\" and append list \"tv2\".\n */\n    int\neval_addlist(typval_T *tv1, typval_T *tv2)\n{\n    typval_T var3;\n\n    // concatenate Lists\n    if (list_concat(tv1->vval.v_list, tv2->vval.v_list, &var3) == FAIL)\n    {\n\tclear_tv(tv1);\n\tclear_tv(tv2);\n\treturn FAIL;\n    }\n    clear_tv(tv1);\n    *tv1 = var3;\n    return OK;\n}\n\n/*\n * Handle fourth level expression:\n *\t+\tnumber addition\n *\t-\tnumber subtraction\n *\t.\tstring concatenation (if script version is 1)\n *\t..\tstring concatenation\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first variable.\n     */\n    if (eval6(arg, rettv, evalarg, FALSE) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '+', '-' or '.' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\tchar_u\t    *p;\n\tint\t    op;\n\tint\t    oplen;\n\tint\t    concat;\n\ttypval_T    var2;\n\tint\t    vim9script = in_vim9script();\n\n\t// \".\" is only string concatenation when scriptversion is 1\n\t// \"+=\", \"-=\" and \"..=\" are assignments\n\t// \"++\" and \"--\" on the next line are a separate command.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tconcat = op == '.' && (*(p + 1) == '.' || in_old_script(2));\n\tif ((op != '+' && op != '-' && !concat) || p[1] == '='\n\t\t\t\t\t       || (p[1] == '.' && p[2] == '='))\n\t    break;\n\tif (getnext && (op == '+' || op == '-') && p[0] == p[1])\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\toplen = (concat && p[1] == '.') ? 2 : 1;\n\tif (getnext)\n\t    *arg = eval_next_line(evalarg);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, oplen);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\tif ((op != '+' || (rettv->v_type != VAR_LIST\n\t\t\t\t\t\t && rettv->v_type != VAR_BLOB))\n#ifdef FEAT_FLOAT\n\t\t&& (op == '.' || rettv->v_type != VAR_FLOAT)\n#endif\n\t\t&& evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    // For \"list + ...\", an illegal use of the first operand as\n\t    // a number cannot be determined before evaluating the 2nd\n\t    // operand: if this is also a list, all is ok.\n\t    // For \"something . ...\", \"something - ...\" or \"non-list + ...\",\n\t    // we know that the first operand needs to be a string or number\n\t    // without evaluating the 2nd operand.  So check before to avoid\n\t    // side effects after an error.\n\t    if (op != '.')\n\t\ttv_get_number_chk(rettv, &error);\n\t    if ((op == '.' && tv_get_string_chk(rettv) == NULL) || error)\n\t    {\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[oplen]))\n\t{\n\t    error_white_both(*arg, oplen);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + oplen, evalarg);\n\tif (eval6(arg, &var2, evalarg, !vim9script && op == '.') == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (op == '.')\n\t    {\n\t\tchar_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\t\tchar_u\t*s1 = tv_get_string_buf(rettv, buf1);\n\t\tchar_u\t*s2 = NULL;\n\n\t\tif (vim9script && (var2.v_type == VAR_VOID\n\t\t\t|| var2.v_type == VAR_CHANNEL\n\t\t\t|| var2.v_type == VAR_JOB))\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t   vartype_name(var2.v_type));\n#ifdef FEAT_FLOAT\n\t\telse if (vim9script && var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%g\",\n\t\t\t\t\t\t\t    var2.vval.v_float);\n\t\t    s2 = buf2;\n\t\t}\n#endif\n\t\telse\n\t\t    s2 = tv_get_string_buf_chk(&var2, buf2);\n\t\tif (s2 == NULL)\t\t// type error ?\n\t\t{\n\t\t    clear_tv(rettv);\n\t\t    clear_tv(&var2);\n\t\t    return FAIL;\n\t\t}\n\t\tp = concat_str(s1, s2);\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = p;\n\t    }\n\t    else if (op == '+' && rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t   && var2.v_type == VAR_BLOB)\n\t\teval_addblob(rettv, &var2);\n\t    else if (op == '+' && rettv->v_type == VAR_LIST\n\t\t\t\t\t\t   && var2.v_type == VAR_LIST)\n\t    {\n\t\tif (eval_addlist(rettv, &var2) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tint\t\terror = FALSE;\n\t\tvarnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\tfloat_T\t    f1 = 0, f2 = 0;\n\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    f1 = rettv->vval.v_float;\n\t\t    n1 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n1 = tv_get_number_chk(rettv, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\t// This can only happen for \"list + non-list\" or\n\t\t\t// \"blob + non-blob\".  For \"non-list + ...\" or\n\t\t\t// \"something - ...\", we returned before evaluating the\n\t\t\t// 2nd operand.\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (var2.v_type == VAR_FLOAT)\n\t\t\tf1 = n1;\n#endif\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    f2 = var2.vval.v_float;\n\t\t    n2 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n2 = tv_get_number_chk(&var2, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (rettv->v_type == VAR_FLOAT)\n\t\t\tf2 = n2;\n#endif\n\t\t}\n\t\tclear_tv(rettv);\n\n#ifdef FEAT_FLOAT\n\t\t// If there is a float on either side the result is a float.\n\t\tif (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (op == '+')\n\t\t\tf1 = f1 + f2;\n\t\t    else\n\t\t\tf1 = f1 - f2;\n\t\t    rettv->v_type = VAR_FLOAT;\n\t\t    rettv->vval.v_float = f1;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (op == '+')\n\t\t\tn1 = n1 + n2;\n\t\t    else\n\t\t\tn1 = n1 - n2;\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = n1;\n\t\t}\n\t    }\n\t    clear_tv(&var2);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle fifth level expression:\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval6(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)  // after \".\" operator\n{\n#ifdef FEAT_FLOAT\n    int\t    use_float = FALSE;\n#endif\n\n    /*\n     * Get the first variable.\n     */\n    if (eval7t(arg, rettv, evalarg, want_string) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '*', '/' or '%' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\ttypval_T    var2;\n\tchar_u\t    *p;\n\tint\t    op;\n\tvarnumber_T n1, n2;\n#ifdef FEAT_FLOAT\n\tfloat_T\t    f1, f2;\n#endif\n\tint\t    error;\n\n\t// \"*=\", \"/=\" and \"%=\" are assignments\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tif ((op != '*' && op != '/' && op != '%') || p[1] == '=')\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tif (getnext)\n\t    *arg = eval_next_line(evalarg);\n\telse\n\t{\n\t    if (evaluate && in_vim9script() && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n#ifdef FEAT_FLOAT\n\tf1 = 0;\n\tf2 = 0;\n#endif\n\terror = FALSE;\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tf1 = rettv->vval.v_float;\n\t\tuse_float = TRUE;\n\t\tn1 = 0;\n\t    }\n\t    else\n#endif\n\t\tn1 = tv_get_number_chk(rettv, &error);\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\telse\n\t    n1 = 0;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg, 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (eval7t(arg, &var2, evalarg, FALSE) == FAIL)\n\t    return FAIL;\n\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (var2.v_type == VAR_FLOAT)\n\t    {\n\t\tif (!use_float)\n\t\t{\n\t\t    f1 = n1;\n\t\t    use_float = TRUE;\n\t\t}\n\t\tf2 = var2.vval.v_float;\n\t\tn2 = 0;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tn2 = tv_get_number_chk(&var2, &error);\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n#ifdef FEAT_FLOAT\n\t\tif (use_float)\n\t\t    f2 = n2;\n#endif\n\t    }\n\n\t    /*\n\t     * Compute the result.\n\t     * When either side is a float the result is a float.\n\t     */\n#ifdef FEAT_FLOAT\n\t    if (use_float)\n\t    {\n\t\tif (op == '*')\n\t\t    f1 = f1 * f2;\n\t\telse if (op == '/')\n\t\t{\n# ifdef VMS\n\t\t    // VMS crashes on divide by zero, work around it\n\t\t    if (f2 == 0.0)\n\t\t    {\n\t\t\tif (f1 == 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX - 1L;   // similar to NaN\n\t\t\telse if (f1 < 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX;\n\t\t\telse\n\t\t\t    f1 = __F_FLT_MAX;\n\t\t    }\n\t\t    else\n\t\t\tf1 = f1 / f2;\n# else\n\t\t    // We rely on the floating point library to handle divide\n\t\t    // by zero to result in \"inf\" and not a crash.\n\t\t    f1 = f1 / f2;\n# endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_cannot_use_percent_with_float));\n\t\t    return FAIL;\n\t\t}\n\t\trettv->v_type = VAR_FLOAT;\n\t\trettv->vval.v_float = f1;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tint\t    failed = FALSE;\n\n\t\tif (op == '*')\n\t\t    n1 = n1 * n2;\n\t\telse if (op == '/')\n\t\t    n1 = num_divide(n1, n2, &failed);\n\t\telse\n\t\t    n1 = num_modulus(n1, n2, &failed);\n\t\tif (failed)\n\t\t    return FAIL;\n\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = n1;\n\t    }\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Handle a type cast before a base level expression.\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n * Return OK or FAIL.\n */\n    static int\neval7t(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    type_T\t*want_type = NULL;\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    int\t\tres;\n    int\t\tevaluate = evalarg == NULL ? 0\n\t\t\t\t       : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    // Recognize <type> in Vim9 script only.\n    if (in_vim9script() && **arg == '<' && eval_isnamec1((*arg)[1])\n\t\t\t\t\t     && STRNCMP(*arg, \"<SNR>\", 5) != 0)\n    {\n\t++*arg;\n\tga_init2(&type_list, sizeof(type_T *), 10);\n\twant_type = parse_type(arg, &type_list, TRUE);\n\tif (want_type == NULL && (evaluate || **arg != '>'))\n\t{\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\t++*arg;\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n    }\n\n    res = eval7(arg, rettv, evalarg, want_string);\n\n    if (want_type != NULL && evaluate)\n    {\n\tif (res == OK)\n\t{\n\t    type_T *actual = typval2type(rettv, get_copyID(), &type_list,\n\t\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\n\t    if (!equal_type(want_type, actual, 0))\n\t    {\n\t\tif (want_type == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n\t\t{\n\t\t    int n = tv2bool(rettv);\n\n\t\t    // can use \"0\" and \"1\" for boolean in some places\n\t\t    clear_tv(rettv);\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\n\t\t    where.wt_variable = TRUE;\n\t\t    res = check_type(want_type, actual, TRUE, where);\n\t\t}\n\t    }\n\t}\n\tclear_type_list(&type_list);\n    }\n\n    return res;\n}\n\n    int\neval_leader(char_u **arg, int vim9)\n{\n    char_u\t*s = *arg;\n    char_u\t*p = *arg;\n\n    while (*p == '!' || *p == '-' || *p == '+')\n    {\n\tchar_u *n = skipwhite(p + 1);\n\n\t// ++, --, -+ and +- are not accepted in Vim9 script\n\tif (vim9 && (*p == '-' || *p == '+') && (*n == '-' || *n == '+'))\n\t{\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n\tp = n;\n    }\n    *arg = p;\n    return OK;\n}\n\n/*\n * Handle sixth level expression:\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {arg, arg -> expr}\tLambda\n *  {key: val, key: val}   Dictionary\n *  #{key: val, key: val}  Dictionary with literal keys\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n    return ret;\n}\n\n/*\n * Apply the leading \"!\" and \"-\" before an eval7 expression to \"rettv\".\n * When \"numeric_only\" is TRUE only handle \"+\" and \"-\".\n * Adjusts \"end_leaderp\" until it is at \"start_leader\".\n */\n    static int\neval7_leader(\n\ttypval_T    *rettv,\n\tint\t    numeric_only,\n\tchar_u\t    *start_leader,\n\tchar_u\t    **end_leaderp)\n{\n    char_u\t*end_leader = *end_leaderp;\n    int\t\tret = OK;\n    int\t\terror = FALSE;\n    varnumber_T val = 0;\n    vartype_T\ttype = rettv->v_type;\n#ifdef FEAT_FLOAT\n    float_T\t    f = 0.0;\n\n    if (rettv->v_type == VAR_FLOAT)\n\tf = rettv->vval.v_float;\n    else\n#endif\n    {\n\twhile (VIM_ISWHITE(end_leader[-1]))\n\t    --end_leader;\n\tif (in_vim9script() && end_leader[-1] == '!')\n\t    val = tv2bool(rettv);\n\telse\n\t    val = tv_get_number_chk(rettv, &error);\n    }\n    if (error)\n    {\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n    {\n\twhile (end_leader > start_leader)\n\t{\n\t    --end_leader;\n\t    if (*end_leader == '!')\n\t    {\n\t\tif (numeric_only)\n\t\t{\n\t\t    ++end_leader;\n\t\t    break;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (in_vim9script())\n\t\t    {\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\tval = f == 0.0 ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tf = !f;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    val = !val;\n\t\t    type = VAR_BOOL;\n\t\t}\n\t    }\n\t    else if (*end_leader == '-')\n\t    {\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t    f = -f;\n\t\telse\n#endif\n\t\t{\n\t\t    val = -val;\n\t\t    type = VAR_NUMBER;\n\t\t}\n\t    }\n\t}\n#ifdef FEAT_FLOAT\n\tif (rettv->v_type == VAR_FLOAT)\n\t{\n\t    clear_tv(rettv);\n\t    rettv->vval.v_float = f;\n\t}\n\telse\n#endif\n\t{\n\t    clear_tv(rettv);\n\t    if (in_vim9script())\n\t\trettv->v_type = type;\n\t    else\n\t\trettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = val;\n\t}\n    }\n    *end_leaderp = end_leader;\n    return ret;\n}\n\n/*\n * Call the function referred to in \"rettv\".\n */\n    static int\ncall_func_rettv(\n\tchar_u\t    **arg,\n\tevalarg_T   *evalarg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tdict_T\t    *selfdict,\n\ttypval_T    *basetv)\n{\n    partial_T\t*pt = NULL;\n    funcexe_T\tfuncexe;\n    typval_T\tfunctv;\n    char_u\t*s;\n    int\t\tret;\n\n    // need to copy the funcref so that we can clear rettv\n    if (evaluate)\n    {\n\tfunctv = *rettv;\n\trettv->v_type = VAR_UNKNOWN;\n\n\t// Invoke the function.  Recursive!\n\tif (functv.v_type == VAR_PARTIAL)\n\t{\n\t    pt = functv.vval.v_partial;\n\t    s = partial_name(pt);\n\t}\n\telse\n\t{\n\t    s = functv.vval.v_string;\n\t    if (s == NULL || *s == NUL)\n\t    {\n\t\temsg(_(e_empty_function_name));\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n    }\n    else\n\ts = (char_u *)\"\";\n\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = evaluate;\n    funcexe.fe_partial = pt;\n    funcexe.fe_selfdict = selfdict;\n    funcexe.fe_basetv = basetv;\n    ret = get_func_tv(s, -1, rettv, arg, evalarg, &funcexe);\n\ntheend:\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&functv);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_method(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    char_u\t*name;\n    long\tlen;\n    char_u\t*alias;\n    char_u\t*tofree = NULL;\n    typval_T\tbase = *rettv;\n    int\t\tret = OK;\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    name = *arg;\n    len = get_name_len(arg, &alias, evaluate, TRUE);\n    if (alias != NULL)\n\tname = alias;\n\n    if (len <= 0)\n    {\n\tif (verbose)\n\t    emsg(_(e_missing_name_after_method));\n\tret = FAIL;\n    }\n    else\n    {\n\tchar_u *paren;\n\n\t// If there is no \"(\" immediately following, but there is further on,\n\t// it can be \"import.Func()\", \"dict.Func()\", \"list[nr]\", etc.\n\t// Does not handle anything where \"(\" is part of the expression.\n\t*arg = skipwhite(*arg);\n\n\tif (**arg != '(' && alias == NULL\n\t\t\t\t    && (paren = vim_strchr(*arg, '(')) != NULL)\n\t{\n\t    char_u *deref;\n\n\t    *arg = name;\n\t    *paren = NUL;\n\t    deref = deref_function_name(arg, &tofree, evalarg, verbose);\n\t    if (deref == NULL)\n\t    {\n\t\t*arg = name + len;\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tname = deref;\n\t\tlen = STRLEN(name);\n\t    }\n\t    *paren = '(';\n\t}\n\n\tif (ret == OK)\n\t{\n\t    *arg = skipwhite(*arg);\n\n\t    if (**arg != '(')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_missing_parenthesis_str), name);\n\t\tret = FAIL;\n\t    }\n\t    else if (VIM_ISWHITE((*arg)[-1]))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = eval_func(arg, evalarg, name, len, rettv,\n\t\t\t\t\t  evaluate ? EVAL_EVALUATE : 0, &base);\n\t}\n    }\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\".\n * \"*arg\" points to the '[' or '.'.\n * Returns FAIL or OK. \"*arg\" is advanced to after the ']'.\n */\n    static int\neval_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tempty1 = FALSE, empty2 = FALSE;\n    typval_T\tvar1, var2;\n    int\t\trange = FALSE;\n    char_u\t*key = NULL;\n    int\t\tkeylen = -1;\n    int\t\tvim9 = in_vim9script();\n\n    if (check_can_index(rettv, evaluate, verbose) == FAIL)\n\treturn FAIL;\n\n    init_tv(&var1);\n    init_tv(&var2);\n    if (**arg == '.')\n    {\n\t/*\n\t * dict.name\n\t */\n\tkey = *arg + 1;\n\tfor (keylen = 0; eval_isdictc(key[keylen]); ++keylen)\n\t    ;\n\tif (keylen == 0)\n\t    return FAIL;\n\t*arg = key + keylen;\n    }\n    else\n    {\n\t/*\n\t * something[idx]\n\t *\n\t * Get the (first) variable from inside the [].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (**arg == ':')\n\t    empty1 = TRUE;\n\telse if (eval1(arg, &var1, evalarg) == FAIL)\t// recursive!\n\t    return FAIL;\n\telse if (vim9 && **arg == ':')\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t    clear_tv(&var1);\n\t    return FAIL;\n\t}\n\telse if (evaluate)\n\t{\n\t    int error = FALSE;\n\n#ifdef FEAT_FLOAT\n\t    // allow for indexing with float\n\t    if (vim9 && rettv->v_type == VAR_DICT\n\t\t\t\t\t\t   && var1.v_type == VAR_FLOAT)\n\t    {\n\t\tvar1.vval.v_string = typval_tostring(&var1, TRUE);\n\t\tvar1.v_type = VAR_STRING;\n\t    }\n#endif\n\t    if (vim9 && rettv->v_type == VAR_LIST)\n\t\ttv_get_number_chk(&var1, &error);\n\t    else\n\t\terror = tv_get_string_chk(&var1) == NULL;\n\t    if (error)\n\t    {\n\t\t// not a number or string\n\t\tclear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable from inside the [:].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ':')\n\t{\n\t    range = TRUE;\n\t    ++*arg;\n\t    if (vim9 && !IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\":\", *arg - 1);\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t    if (**arg == ']')\n\t\tempty2 = TRUE;\n\t    else if (eval1(arg, &var2, evalarg) == FAIL)\t// recursive!\n\t    {\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    else if (evaluate && tv_get_string_chk(&var2) == NULL)\n\t    {\n\t\t// not a number or string\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// Check for the ']'.\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ']')\n\t{\n\t    if (verbose)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    clear_tv(&var1);\n\t    if (range)\n\t\tclear_tv(&var2);\n\t    return FAIL;\n\t}\n\t*arg = *arg + 1;\t// skip over the ']'\n    }\n\n    if (evaluate)\n    {\n\tint res = eval_index_inner(rettv, range,\n\t\tempty1 ? NULL : &var1, empty2 ? NULL : &var2, FALSE,\n\t\tkey, keylen, verbose);\n\n\tif (!empty1)\n\t    clear_tv(&var1);\n\tif (range)\n\t    clear_tv(&var2);\n\treturn res;\n    }\n    return OK;\n}\n\n/*\n * Check if \"rettv\" can have an [index] or [sli:ce]\n */\n    int\ncheck_can_index(typval_T *rettv, int evaluate, int verbose)\n{\n    switch (rettv->v_type)\n    {\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_a_funcref));\n\t    return FAIL;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (verbose)\n\t\temsg(_(e_using_float_as_string));\n\t    return FAIL;\n#endif\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_special_variable));\n\t    return FAIL;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    if (evaluate)\n\t    {\n\t\temsg(_(e_cannot_index_special_variable));\n\t\treturn FAIL;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase VAR_STRING:\n\tcase VAR_LIST:\n\tcase VAR_DICT:\n\tcase VAR_BLOB:\n\t    break;\n\tcase VAR_NUMBER:\n\t    if (in_vim9script())\n\t\temsg(_(e_cannot_index_number));\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * slice() function\n */\n    void\nf_slice(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && ((argvars[0].v_type != VAR_STRING\n\t\t    && argvars[0].v_type != VAR_LIST\n\t\t    && argvars[0].v_type != VAR_BLOB\n\t\t    && check_for_list_arg(argvars, 0) == FAIL)\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (check_can_index(argvars, TRUE, FALSE) == OK)\n    {\n\tcopy_tv(argvars, rettv);\n\teval_index_inner(rettv, TRUE, argvars + 1,\n\t\targvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,\n\t\tTRUE, NULL, 0, FALSE);\n    }\n}\n\n/*\n * Apply index or range to \"rettv\".\n * \"var1\" is the first index, NULL for [:expr].\n * \"var2\" is the second index, NULL for [expr] and [expr: ]\n * \"exclusive\" is TRUE for slice(): second index is exclusive, use character\n * index for string.\n * Alternatively, \"key\" is not NULL, then key[keylen] is the dict index.\n */\n    int\neval_index_inner(\n\ttypval_T    *rettv,\n\tint\t    is_range,\n\ttypval_T    *var1,\n\ttypval_T    *var2,\n\tint\t    exclusive,\n\tchar_u\t    *key,\n\tint\t    keylen,\n\tint\t    verbose)\n{\n    varnumber_T\t    n1, n2 = 0;\n    long\t    len;\n\n    n1 = 0;\n    if (var1 != NULL && rettv->v_type != VAR_DICT)\n\tn1 = tv_get_number(var1);\n\n    if (is_range)\n    {\n\tif (rettv->v_type == VAR_DICT)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (var2 != NULL)\n\t    n2 = tv_get_number(var2);\n\telse\n\t    n2 = VARNUM_MAX;\n    }\n\n    switch (rettv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break; // not evaluating, skipping over subscript\n\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\t    {\n\t\tchar_u\t*s = tv_get_string(rettv);\n\n\t\tlen = (long)STRLEN(s);\n\t\tif (in_vim9script() || exclusive)\n\t\t{\n\t\t    if (is_range)\n\t\t\ts = string_slice(s, n1, n2, exclusive);\n\t\t    else\n\t\t\ts = char_from_string(s, n1);\n\t\t}\n\t\telse if (is_range)\n\t\t{\n\t\t    // The resulting variable is a substring.  If the indexes\n\t\t    // are out of range the result is empty.\n\t\t    if (n1 < 0)\n\t\t    {\n\t\t\tn1 = len + n1;\n\t\t\tif (n1 < 0)\n\t\t\t    n1 = 0;\n\t\t    }\n\t\t    if (n2 < 0)\n\t\t\tn2 = len + n2;\n\t\t    else if (n2 >= len)\n\t\t\tn2 = len;\n\t\t    if (n1 >= len || n2 < 0 || n1 > n2)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, n2 - n1 + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // The resulting variable is a string of a single\n\t\t    // character.  If the index is too big or negative the\n\t\t    // result is empty.\n\t\t    if (n1 >= len || n1 < 0)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, 1);\n\t\t}\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = s;\n\t    }\n\t    break;\n\n\tcase VAR_BLOB:\n\t    blob_slice_or_index(rettv->vval.v_blob, is_range, n1, n2,\n\t\t\t\t\t\t\t     exclusive, rettv);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (var1 == NULL)\n\t\tn1 = 0;\n\t    if (var2 == NULL)\n\t\tn2 = VARNUM_MAX;\n\t    if (list_slice_or_index(rettv->vval.v_list,\n\t\t\t  is_range, n1, n2, exclusive, rettv, verbose) == FAIL)\n\t\treturn FAIL;\n\t    break;\n\n\tcase VAR_DICT:\n\t    {\n\t\tdictitem_T\t*item;\n\t\ttypval_T\ttmp;\n\n\t\tif (key == NULL)\n\t\t{\n\t\t    key = tv_get_string_chk(var1);\n\t\t    if (key == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\n\t\titem = dict_find(rettv->vval.v_dict, key, keylen);\n\n\t\tif (item == NULL)\n\t\t{\n\t\t    if (verbose)\n\t\t    {\n\t\t\tif (keylen > 0)\n\t\t\t    key[keylen] = NUL;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    }\n\t\t    return FAIL;\n\t\t}\n\n\t\tcopy_tv(&item->di_tv, &tmp);\n\t\tclear_tv(rettv);\n\t\t*rettv = tmp;\n\t    }\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * Return the function name of partial \"pt\".\n */\n    char_u *\npartial_name(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (pt->pt_name != NULL)\n\t    return pt->pt_name;\n\tif (pt->pt_func != NULL)\n\t    return pt->pt_func->uf_name;\n    }\n    return (char_u *)\"\";\n}\n\n    static void\npartial_free(partial_T *pt)\n{\n    int i;\n\n    for (i = 0; i < pt->pt_argc; ++i)\n\tclear_tv(&pt->pt_argv[i]);\n    vim_free(pt->pt_argv);\n    dict_unref(pt->pt_dict);\n    if (pt->pt_name != NULL)\n    {\n\tfunc_unref(pt->pt_name);\n\tvim_free(pt->pt_name);\n    }\n    else\n\tfunc_ptr_unref(pt->pt_func);\n\n    // \"out_up\" is no longer used, decrement refcount on partial that owns it.\n    partial_unref(pt->pt_outer.out_up_partial);\n\n    // Decrease the reference count for the context of a closure.  If down\n    // to the minimum it may be time to free it.\n    if (pt->pt_funcstack != NULL)\n    {\n\t--pt->pt_funcstack->fs_refcount;\n\tfuncstack_check_refcount(pt->pt_funcstack);\n    }\n\n    vim_free(pt);\n}\n\n/*\n * Unreference a closure: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\npartial_unref(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (--pt->pt_refcount <= 0)\n\t    partial_free(pt);\n\n\t// If the reference count goes down to one, the funcstack may be the\n\t// only reference and can be freed if no other partials reference it.\n\telse if (pt->pt_refcount == 1 && pt->pt_funcstack != NULL)\n\t    funcstack_check_refcount(pt->pt_funcstack);\n    }\n}\n\n/*\n * Return the next (unique) copy ID.\n * Used for serializing nested structures.\n */\n    int\nget_copyID(void)\n{\n    current_copyID += COPYID_INC;\n    return current_copyID;\n}\n\n/*\n * Garbage collection for lists and dictionaries.\n *\n * We use reference counts to be able to free most items right away when they\n * are no longer used.  But for composite items it's possible that it becomes\n * unused while the reference count is > 0: When there is a recursive\n * reference.  Example:\n *\t:let l = [1, 2, 3]\n *\t:let d = {9: l}\n *\t:let l[1] = d\n *\n * Since this is quite unusual we handle this with garbage collection: every\n * once in a while find out which lists and dicts are not referenced from any\n * variable.\n *\n * Here is a good reference text about garbage collection (refers to Python\n * but it applies to all reference-counting mechanisms):\n *\thttp://python.ca/nas/python/gc/\n */\n\n/*\n * Do garbage collection for lists and dicts.\n * When \"testing\" is TRUE this is called from test_garbagecollect_now().\n * Return TRUE if some memory was freed.\n */\n    int\ngarbage_collect(int testing)\n{\n    int\t\tcopyID;\n    int\t\tabort = FALSE;\n    buf_T\t*buf;\n    win_T\t*wp;\n    int\t\tdid_free = FALSE;\n    tabpage_T\t*tp;\n\n    if (!testing)\n    {\n\t// Only do this once.\n\twant_garbage_collect = FALSE;\n\tmay_garbage_collect = FALSE;\n\tgarbage_collect_at_exit = FALSE;\n    }\n\n    // The execution stack can grow big, limit the size.\n    if (exestack.ga_maxlen - exestack.ga_len > 500)\n    {\n\tsize_t\tnew_len;\n\tchar_u\t*pp;\n\tint\tn;\n\n\t// Keep 150% of the current size, with a minimum of the growth size.\n\tn = exestack.ga_len / 2;\n\tif (n < exestack.ga_growsize)\n\t    n = exestack.ga_growsize;\n\n\t// Don't make it bigger though.\n\tif (exestack.ga_len + n < exestack.ga_maxlen)\n\t{\n\t    new_len = exestack.ga_itemsize * (exestack.ga_len + n);\n\t    pp = vim_realloc(exestack.ga_data, new_len);\n\t    if (pp == NULL)\n\t\treturn FAIL;\n\t    exestack.ga_maxlen = exestack.ga_len + n;\n\t    exestack.ga_data = pp;\n\t}\n    }\n\n    // We advance by two because we add one for items referenced through\n    // previous_funccal.\n    copyID = get_copyID();\n\n    /*\n     * 1. Go through all accessible variables and mark all lists and dicts\n     *    with copyID.\n     */\n\n    // Don't free variables in the previous_funccal list unless they are only\n    // referenced through previous_funccal.  This must be first, because if\n    // the item is referenced elsewhere the funccal must not be freed.\n    abort = abort || set_ref_in_previous_funccal(copyID);\n\n    // script-local variables\n    abort = abort || garbage_collect_scriptvars(copyID);\n\n    // buffer-local variables\n    FOR_ALL_BUFFERS(buf)\n\tabort = abort || set_ref_in_item(&buf->b_bufvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n    // window-local variables\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    if (aucmd_win != NULL)\n\tabort = abort || set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    FOR_ALL_TABPAGES(tp)\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#endif\n\n    // tabpage-local variables\n    FOR_ALL_TABPAGES(tp)\n\tabort = abort || set_ref_in_item(&tp->tp_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    // global variables\n    abort = abort || garbage_collect_globvars(copyID);\n\n    // function-local variables\n    abort = abort || set_ref_in_call_stack(copyID);\n\n    // named functions (matters for closures)\n    abort = abort || set_ref_in_functions(copyID);\n\n    // function call arguments, if v:testing is set.\n    abort = abort || set_ref_in_func_args(copyID);\n\n    // funcstacks keep variables for closures\n    abort = abort || set_ref_in_funcstacks(copyID);\n\n    // v: vars\n    abort = abort || garbage_collect_vimvars(copyID);\n\n    // callbacks in buffers\n    abort = abort || set_ref_in_buffers(copyID);\n\n    // 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks\n    abort = abort || set_ref_in_insexpand_funcs(copyID);\n\n    // 'operatorfunc' callback\n    abort = abort || set_ref_in_opfunc(copyID);\n\n    // 'tagfunc' callback\n    abort = abort || set_ref_in_tagfunc(copyID);\n\n    // 'imactivatefunc' and 'imstatusfunc' callbacks\n    abort = abort || set_ref_in_im_funcs(copyID);\n\n#ifdef FEAT_LUA\n    abort = abort || set_ref_in_lua(copyID);\n#endif\n\n#ifdef FEAT_PYTHON\n    abort = abort || set_ref_in_python(copyID);\n#endif\n\n#ifdef FEAT_PYTHON3\n    abort = abort || set_ref_in_python3(copyID);\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n    abort = abort || set_ref_in_channel(copyID);\n    abort = abort || set_ref_in_job(copyID);\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    abort = abort || set_ref_in_nb_channel(copyID);\n#endif\n\n#ifdef FEAT_TIMERS\n    abort = abort || set_ref_in_timer(copyID);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    abort = abort || set_ref_in_quickfix(copyID);\n#endif\n\n#ifdef FEAT_TERMINAL\n    abort = abort || set_ref_in_term(copyID);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    abort = abort || set_ref_in_popups(copyID);\n#endif\n\n    if (!abort)\n    {\n\t/*\n\t * 2. Free lists and dictionaries that are not referenced.\n\t */\n\tdid_free = free_unref_items(copyID);\n\n\t/*\n\t * 3. Check if any funccal can be freed now.\n\t *    This may call us back recursively.\n\t */\n\tfree_unref_funccal(copyID, testing);\n    }\n    else if (p_verbose > 0)\n    {\n\tverb_msg(_(\"Not enough memory to set references, garbage collection aborted!\"));\n    }\n\n    return did_free;\n}\n\n/*\n * Free lists, dictionaries, channels and jobs that are no longer referenced.\n */\n    static int\nfree_unref_items(int copyID)\n{\n    int\t\tdid_free = FALSE;\n\n    // Let all \"free\" functions know that we are here.  This means no\n    // dictionaries, lists, channels or jobs are to be freed, because we will\n    // do that here.\n    in_free_unref_items = TRUE;\n\n    /*\n     * PASS 1: free the contents of the items.  We don't free the items\n     * themselves yet, so that it is possible to decrement refcount counters\n     */\n\n    // Go through the list of dicts and free items without the copyID.\n    did_free |= dict_free_nonref(copyID);\n\n    // Go through the list of lists and free items without the copyID.\n    did_free |= list_free_nonref(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    did_free |= free_unused_jobs_contents(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    did_free |= free_unused_channels_contents(copyID, COPYID_MASK);\n#endif\n\n    /*\n     * PASS 2: free the items themselves.\n     */\n    dict_free_items(copyID);\n    list_free_items(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    free_unused_jobs(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    free_unused_channels(copyID, COPYID_MASK);\n#endif\n\n    in_free_unref_items = FALSE;\n\n    return did_free;\n}\n\n/*\n * Mark all lists and dicts referenced through hashtab \"ht\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)\n{\n    int\t\ttodo;\n    int\t\tabort = FALSE;\n    hashitem_T\t*hi;\n    hashtab_T\t*cur_ht;\n    ht_stack_T\t*ht_stack = NULL;\n    ht_stack_T\t*tempitem;\n\n    cur_ht = ht;\n    for (;;)\n    {\n\tif (!abort)\n\t{\n\t    // Mark each item in the hashtab.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    todo = (int)cur_ht->ht_used;\n\t    for (hi = cur_ht->ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    --todo;\n\t\t    abort = abort || set_ref_in_item(&HI2DI(hi)->di_tv, copyID,\n\t\t\t\t\t\t       &ht_stack, list_stack);\n\t\t}\n\t}\n\n\tif (ht_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_ht = ht_stack->ht;\n\ttempitem = ht_stack;\n\tht_stack = ht_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n#if defined(FEAT_LUA) || defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) \\\n\t\t\t\t\t\t\t|| defined(PROTO)\n/*\n * Mark a dict and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_dict(dict_T *d, int copyID)\n{\n    if (d != NULL && d->dv_copyID != copyID)\n    {\n\td->dv_copyID = copyID;\n\treturn set_ref_in_ht(&d->dv_hashtab, copyID, NULL);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Mark a list and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list(list_T *ll, int copyID)\n{\n    if (ll != NULL && ll->lv_copyID != copyID)\n    {\n\tll->lv_copyID = copyID;\n\treturn set_ref_in_list_items(ll, copyID, NULL);\n    }\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through list \"l\" with \"copyID\".\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack)\n{\n    listitem_T\t *li;\n    int\t\t abort = FALSE;\n    list_T\t *cur_l;\n    list_stack_T *list_stack = NULL;\n    list_stack_T *tempitem;\n\n    cur_l = l;\n    for (;;)\n    {\n\tif (!abort && cur_l->lv_first != &range_list_item)\n\t    // Mark each item in the list.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    for (li = cur_l->lv_first; !abort && li != NULL; li = li->li_next)\n\t\tabort = abort || set_ref_in_item(&li->li_tv, copyID,\n\t\t\t\t\t\t       ht_stack, &list_stack);\n\tif (list_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_l = list_stack->list;\n\ttempitem = list_stack;\n\tlist_stack = list_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the partial in callback 'cb' with \"copyID\".\n */\n    int\nset_ref_in_callback(callback_T *cb, int copyID)\n{\n    typval_T tv;\n\n    if (cb->cb_name == NULL || *cb->cb_name == NUL || cb->cb_partial == NULL)\n\treturn FALSE;\n\n    tv.v_type = VAR_PARTIAL;\n    tv.vval.v_partial = cb->cb_partial;\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n}\n\n/*\n * Mark all lists and dicts referenced through typval \"tv\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_item(\n    typval_T\t    *tv,\n    int\t\t    copyID,\n    ht_stack_T\t    **ht_stack,\n    list_stack_T    **list_stack)\n{\n    int\t\tabort = FALSE;\n\n    if (tv->v_type == VAR_DICT)\n    {\n\tdict_T\t*dd = tv->vval.v_dict;\n\n\tif (dd != NULL && dd->dv_copyID != copyID)\n\t{\n\t    // Didn't see this dict yet.\n\t    dd->dv_copyID = copyID;\n\t    if (ht_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_ht(&dd->dv_hashtab, copyID, list_stack);\n\t    }\n\t    else\n\t    {\n\t\tht_stack_T *newitem = ALLOC_ONE(ht_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->ht = &dd->dv_hashtab;\n\t\t    newitem->prev = *ht_stack;\n\t\t    *ht_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_LIST)\n    {\n\tlist_T\t*ll = tv->vval.v_list;\n\n\tif (ll != NULL && ll->lv_copyID != copyID)\n\t{\n\t    // Didn't see this list yet.\n\t    ll->lv_copyID = copyID;\n\t    if (list_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_list_items(ll, copyID, ht_stack);\n\t    }\n\t    else\n\t    {\n\t\tlist_stack_T *newitem = ALLOC_ONE(list_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->list = ll;\n\t\t    newitem->prev = *list_stack;\n\t\t    *list_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_FUNC)\n    {\n\tabort = set_ref_in_func(tv->vval.v_string, NULL, copyID);\n    }\n    else if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T\t*pt = tv->vval.v_partial;\n\tint\t\ti;\n\n\tif (pt != NULL && pt->pt_copyID != copyID)\n\t{\n\t    // Didn't see this partial yet.\n\t    pt->pt_copyID = copyID;\n\n\t    abort = set_ref_in_func(pt->pt_name, pt->pt_func, copyID);\n\n\t    if (pt->pt_dict != NULL)\n\t    {\n\t\ttypval_T dtv;\n\n\t\tdtv.v_type = VAR_DICT;\n\t\tdtv.vval.v_dict = pt->pt_dict;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tabort = abort || set_ref_in_item(&pt->pt_argv[i], copyID,\n\t\t\t\t\t\t\tht_stack, list_stack);\n\t    // pt_funcstack is handled in set_ref_in_funcstacks()\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv->v_type == VAR_JOB)\n    {\n\tjob_T\t    *job = tv->vval.v_job;\n\ttypval_T    dtv;\n\n\tif (job != NULL && job->jv_copyID != copyID)\n\t{\n\t    job->jv_copyID = copyID;\n\t    if (job->jv_channel != NULL)\n\t    {\n\t\tdtv.v_type = VAR_CHANNEL;\n\t\tdtv.vval.v_channel = job->jv_channel;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (job->jv_exit_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = job->jv_exit_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_CHANNEL)\n    {\n\tchannel_T   *ch =tv->vval.v_channel;\n\tch_part_T   part;\n\ttypval_T    dtv;\n\tjsonq_T\t    *jq;\n\tcbq_T\t    *cq;\n\n\tif (ch != NULL && ch->ch_copyID != copyID)\n\t{\n\t    ch->ch_copyID = copyID;\n\t    for (part = PART_SOCK; part < PART_COUNT; ++part)\n\t    {\n\t\tfor (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;\n\t\t\t\t\t\t\t     jq = jq->jq_next)\n\t\t    set_ref_in_item(jq->jq_value, copyID, ht_stack, list_stack);\n\t\tfor (cq = ch->ch_part[part].ch_cb_head.cq_next; cq != NULL;\n\t\t\t\t\t\t\t     cq = cq->cq_next)\n\t\t    if (cq->cq_callback.cb_partial != NULL)\n\t\t    {\n\t\t\tdtv.v_type = VAR_PARTIAL;\n\t\t\tdtv.vval.v_partial = cq->cq_callback.cb_partial;\n\t\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t    }\n\t\tif (ch->ch_part[part].ch_callback.cb_partial != NULL)\n\t\t{\n\t\t    dtv.v_type = VAR_PARTIAL;\n\t\t    dtv.vval.v_partial =\n\t\t\t\t      ch->ch_part[part].ch_callback.cb_partial;\n\t\t    set_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t}\n\t    }\n\t    if (ch->ch_callback.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_callback.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (ch->ch_close_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_close_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n#endif\n    return abort;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * When both \"echo_style\" and \"composite_val\" are FALSE, put quotes around\n * strings as \"string()\", otherwise does not put quotes around strings, as\n * \":echo\" displays values.\n * When \"restore_copyID\" is FALSE, repeated items in dictionaries and lists\n * are replaced with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string_core(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID,\n    int\t\techo_style,\n    int\t\trestore_copyID,\n    int\t\tcomposite_val)\n{\n    static int\trecurse = 0;\n    char_u\t*r = NULL;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\tif (!did_echo_string_emsg)\n\t{\n\t    // Only give this message once for a recursive call to avoid\n\t    // flooding the user with errors.  And stop iterating over lists\n\t    // and dicts.\n\t    did_echo_string_emsg = TRUE;\n\t    emsg(_(e_variable_nested_too_deep_for_displaying));\n\t}\n\t*tofree = NULL;\n\treturn (char_u *)\"{E724}\";\n    }\n    ++recurse;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_STRING:\n\t    if (echo_style && !composite_val)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t\tif (r == NULL)\n\t\t    r = (char_u *)\"\";\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, FALSE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_FUNC:\n\t    if (echo_style)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, TRUE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_PARTIAL:\n\t    {\n\t\tpartial_T   *pt = tv->vval.v_partial;\n\t\tchar_u\t    *fname = string_quote(pt == NULL ? NULL\n\t\t\t\t\t\t    : partial_name(pt), FALSE);\n\t\tgarray_T    ga;\n\t\tint\t    i;\n\t\tchar_u\t    *tf;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tga_concat(&ga, (char_u *)\"function(\");\n\t\tif (fname != NULL)\n\t\t{\n\t\t    // When using uf_name prepend \"g:\" for a global function.\n\t\t    if (pt != NULL && pt->pt_name == NULL && fname[0] == '\\''\n\t\t\t\t\t\t      && vim_isupper(fname[1]))\n\t\t    {\n\t\t\tga_concat(&ga, (char_u *)\"'g:\");\n\t\t\tga_concat(&ga, fname + 1);\n\t\t    }\n\t\t    else\n\t\t\tga_concat(&ga, fname);\n\t\t    vim_free(fname);\n\t\t}\n\t\tif (pt != NULL && pt->pt_argc > 0)\n\t\t{\n\t\t    ga_concat(&ga, (char_u *)\", [\");\n\t\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t\tga_concat(&ga,\n\t\t\t     tv2string(&pt->pt_argv[i], &tf, numbuf, copyID));\n\t\t\tvim_free(tf);\n\t\t    }\n\t\t    ga_concat(&ga, (char_u *)\"]\");\n\t\t}\n\t\tif (pt != NULL && pt->pt_dict != NULL)\n\t\t{\n\t\t    typval_T dtv;\n\n\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t    dtv.v_type = VAR_DICT;\n\t\t    dtv.vval.v_dict = pt->pt_dict;\n\t\t    ga_concat(&ga, tv2string(&dtv, &tf, numbuf, copyID));\n\t\t    vim_free(tf);\n\t\t}\n\t\t// terminate with ')' and a NUL\n\t\tga_concat_len(&ga, (char_u *)\")\", 2);\n\n\t\t*tofree = ga.ga_data;\n\t\tr = *tofree;\n\t\tbreak;\n\t    }\n\n\tcase VAR_BLOB:\n\t    r = blob2string(tv->vval.v_blob, tofree, numbuf);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t    {\n\t\t// NULL list is equivalent to empty list.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[]\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_list->lv_copyID == copyID\n\t\t    && tv->vval.v_list->lv_len > 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[...]\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_list->lv_copyID;\n\n\t\ttv->vval.v_list->lv_copyID = copyID;\n\t\t*tofree = list2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_list->lv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t    {\n\t\t// NULL dict is equivalent to empty dict.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{}\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_dict->dv_copyID == copyID\n\t\t    && tv->vval.v_dict->dv_hashtab.ht_used != 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{...}\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_dict->dv_copyID;\n\n\t\ttv->vval.v_dict->dv_copyID = copyID;\n\t\t*tofree = dict2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_dict->dv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_NUMBER:\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    *tofree = NULL;\n\t    r = tv_get_string_buf(tv, numbuf);\n\t    break;\n\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    *tofree = NULL;\n\t    r = tv->v_type == VAR_JOB ? job_to_string_buf(tv, numbuf)\n\t\t\t\t\t   : channel_to_string_buf(tv, numbuf);\n\t    if (composite_val)\n\t    {\n\t\t*tofree = string_quote(r, FALSE);\n\t\tr = *tofree;\n\t    }\n#endif\n\t    break;\n\n\tcase VAR_INSTR:\n\t    *tofree = NULL;\n\t    r = (char_u *)\"instructions\";\n\t    break;\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    *tofree = NULL;\n\t    vim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\t    r = numbuf;\n\t    break;\n#endif\n\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    *tofree = NULL;\n\t    r = (char_u *)get_var_special_name(tv->vval.v_number);\n\t    break;\n    }\n\n    if (--recurse == 0)\n\tdid_echo_string_emsg = FALSE;\n    return r;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Does not put quotes around strings, as \":echo\" displays values.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, TRUE, FALSE, FALSE);\n}\n\n/*\n * Convert the specified byte index of line 'lnum' in buffer 'buf' to a\n * character index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n    int\t\tcount;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    if (*str == NUL)\n\treturn 0;\n\n    // count the number of characters\n    t = str;\n    for (count = 0; *t != NUL && t <= str + byteidx; count++)\n\tt += mb_ptr2len(t);\n\n    // In insert mode, when the cursor is at the end of a non-empty line,\n    // byteidx points to the NUL character immediately past the end of the\n    // string. In this case, add one to the character count.\n    if (*t == NUL && byteidx != 0 && t == str + byteidx)\n\tcount++;\n\n    return count - 1;\n}\n\n/*\n * Convert the specified character index of line 'lnum' in buffer 'buf' to a\n * byte index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    // Convert the character offset to a byte offset\n    t = str;\n    while (*t != NUL && --charidx > 0)\n\tt += mb_ptr2len(t);\n\n    return t - str;\n}\n\n/*\n * Translate a String variable into a position.\n * Returns NULL when there is an error.\n */\n    pos_T *\nvar2fpos(\n    typval_T\t*varp,\n    int\t\tdollar_lnum,\t// TRUE when $ is last line\n    int\t\t*fnum,\t\t// set to fnum for '0, 'A, etc.\n    int\t\tcharcol)\t// return character column\n{\n    char_u\t\t*name;\n    static pos_T\tpos;\n    pos_T\t\t*pp;\n\n    // Argument can be [lnum, col, coladd].\n    if (varp->v_type == VAR_LIST)\n    {\n\tlist_T\t\t*l;\n\tint\t\tlen;\n\tint\t\terror = FALSE;\n\tlistitem_T\t*li;\n\n\tl = varp->vval.v_list;\n\tif (l == NULL)\n\t    return NULL;\n\n\t// Get the line number\n\tpos.lnum = list_find_nr(l, 0L, &error);\n\tif (error || pos.lnum <= 0 || pos.lnum > curbuf->b_ml.ml_line_count)\n\t    return NULL;\t// invalid line number\n\tif (charcol)\n\t    len = (long)mb_charlen(ml_get(pos.lnum));\n\telse\n\t    len = (long)STRLEN(ml_get(pos.lnum));\n\n\t// Get the column number\n\t// We accept \"$\" for the column number: last column.\n\tli = list_find(l, 1L);\n\tif (li != NULL && li->li_tv.v_type == VAR_STRING\n\t\t&& li->li_tv.vval.v_string != NULL\n\t\t&& STRCMP(li->li_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    pos.col = len + 1;\n\t}\n\telse\n\t{\n\t    pos.col = list_find_nr(l, 1L, &error);\n\t    if (error)\n\t\treturn NULL;\n\t}\n\n\t// Accept a position up to the NUL after the line.\n\tif (pos.col == 0 || (int)pos.col > len + 1)\n\t    return NULL;\t// invalid column number\n\t--pos.col;\n\n\t// Get the virtual offset.  Defaults to zero.\n\tpos.coladd = list_find_nr(l, 2L, &error);\n\tif (error)\n\t    pos.coladd = 0;\n\n\treturn &pos;\n    }\n\n    if (in_vim9script() && check_for_string_arg(varp, 0) == FAIL)\n\treturn NULL;\n\n    name = tv_get_string_chk(varp);\n    if (name == NULL)\n\treturn NULL;\n    if (name[0] == '.' && (!in_vim9script() || name[1] == NUL))\n    {\n\t// cursor\n\tpos = curwin->w_cursor;\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n    if (name[0] == 'v' && name[1] == NUL)\t// Visual start\n    {\n\tif (VIsual_active)\n\t    pos = VIsual;\n\telse\n\t    pos = curwin->w_cursor;\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n    if (name[0] == '\\'' && (!in_vim9script()\n\t\t\t\t\t|| (name[1] != NUL && name[2] == NUL)))\n    {\n\t// mark\n\tpp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);\n\tif (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0)\n\t    return NULL;\n\tif (charcol)\n\t    pp->col = buf_byteidx_to_charidx(curbuf, pp->lnum, pp->col);\n\treturn pp;\n    }\n\n    pos.coladd = 0;\n\n    if (name[0] == 'w' && dollar_lnum)\n    {\n\tpos.col = 0;\n\tif (name[1] == '0')\t\t// \"w0\": first visible line\n\t{\n\t    update_topline();\n\t    // In silent Ex mode topline is zero, but that's not a valid line\n\t    // number; use one instead.\n\t    pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;\n\t    return &pos;\n\t}\n\telse if (name[1] == '$')\t// \"w$\": last visible line\n\t{\n\t    validate_botline();\n\t    // In silent Ex mode botline is zero, return zero then.\n\t    pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;\n\t    return &pos;\n\t}\n    }\n    else if (name[0] == '$')\t\t// last column or line\n    {\n\tif (dollar_lnum)\n\t{\n\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t    pos.col = 0;\n\t}\n\telse\n\t{\n\t    pos.lnum = curwin->w_cursor.lnum;\n\t    if (charcol)\n\t\tpos.col = (colnr_T)mb_charlen(ml_get_curline());\n\t    else\n\t\tpos.col = (colnr_T)STRLEN(ml_get_curline());\n\t}\n\treturn &pos;\n    }\n    if (in_vim9script())\n\tsemsg(_(e_invalid_value_for_line_number_str), name);\n    return NULL;\n}\n\n/*\n * Convert list in \"arg\" into a position and optional file number.\n * When \"fnump\" is NULL there is no file number, only 3 items.\n * Note that the column is passed on as-is, the caller may want to decrement\n * it to use 1 for the first column.\n * Return FAIL when conversion is not possible, doesn't check the position for\n * validity.\n */\n    int\nlist2fpos(\n    typval_T\t*arg,\n    pos_T\t*posp,\n    int\t\t*fnump,\n    colnr_T\t*curswantp,\n    int\t\tcharcol)\n{\n    list_T\t*l = arg->vval.v_list;\n    long\ti = 0;\n    long\tn;\n\n    // List must be: [fnum, lnum, col, coladd, curswant], where \"fnum\" is only\n    // there when \"fnump\" isn't NULL; \"coladd\" and \"curswant\" are optional.\n    if (arg->v_type != VAR_LIST\n\t    || l == NULL\n\t    || l->lv_len < (fnump == NULL ? 2 : 3)\n\t    || l->lv_len > (fnump == NULL ? 4 : 5))\n\treturn FAIL;\n\n    if (fnump != NULL)\n    {\n\tn = list_find_nr(l, i++, NULL);\t// fnum\n\tif (n < 0)\n\t    return FAIL;\n\tif (n == 0)\n\t    n = curbuf->b_fnum;\t\t// current buffer\n\t*fnump = n;\n    }\n\n    n = list_find_nr(l, i++, NULL);\t// lnum\n    if (n < 0)\n\treturn FAIL;\n    posp->lnum = n;\n\n    n = list_find_nr(l, i++, NULL);\t// col\n    if (n < 0)\n\treturn FAIL;\n    // If character position is specified, then convert to byte position\n    if (charcol)\n    {\n\tbuf_T\t*buf;\n\n\t// Get the text for the specified line in a loaded buffer\n\tbuf = buflist_findnr(fnump == NULL ? curbuf->b_fnum : *fnump);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    return FAIL;\n\n\tn = buf_charidx_to_byteidx(buf, posp->lnum, n) + 1;\n    }\n    posp->col = n;\n\n    n = list_find_nr(l, i, NULL);\t// off\n    if (n < 0)\n\tposp->coladd = 0;\n    else\n\tposp->coladd = n;\n\n    if (curswantp != NULL)\n\t*curswantp = list_find_nr(l, i + 1, NULL);  // curswant\n\n    return OK;\n}\n\n/*\n * Get the length of an environment variable name.\n * Advance \"arg\" to the first character after the name.\n * Return 0 for error.\n */\n    int\nget_env_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    for (p = *arg; vim_isIDc(*p); ++p)\n\t;\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n    return len;\n}\n\n/*\n * Get the length of the name of a function or internal variable.\n * \"arg\" is advanced to after the name.\n * Return 0 if something is wrong.\n */\n    int\nget_id_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    // Find the end of the name.\n    for (p = *arg; eval_isnamec(*p); ++p)\n    {\n\tif (*p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace.\n\t    len = (int)(p - *arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, **arg) == NULL)\n\t\t    || len > 1)\n\t\tbreak;\n\t}\n    }\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n\n    return len;\n}\n\n/*\n * Get the length of the name of a variable or function.\n * Only the name is recognized, does not handle \".key\" or \"[idx]\".\n * \"arg\" is advanced to the first non-white character after the name.\n * Return -1 if curly braces expansion failed.\n * Return 0 if something else is wrong.\n * If the name contains 'magic' {}'s, expand them and return the\n * expanded name in an allocated string via 'alias' - caller must free.\n */\n    int\nget_name_len(\n    char_u\t**arg,\n    char_u\t**alias,\n    int\t\tevaluate,\n    int\t\tverbose)\n{\n    int\t\tlen;\n    char_u\t*p;\n    char_u\t*expr_start;\n    char_u\t*expr_end;\n\n    *alias = NULL;  // default to no alias\n\n    if ((*arg)[0] == K_SPECIAL && (*arg)[1] == KS_EXTRA\n\t\t\t\t\t\t  && (*arg)[2] == (int)KE_SNR)\n    {\n\t// hard coded <SNR>, already translated\n\t*arg += 3;\n\treturn get_id_len(arg) + 3;\n    }\n    len = eval_fname_script(*arg);\n    if (len > 0)\n    {\n\t// literal \"<SID>\", \"s:\" or \"<SNR>\"\n\t*arg += len;\n    }\n\n    /*\n     * Find the end of the name; check for {} construction.\n     */\n    p = find_name_end(*arg, &expr_start, &expr_end,\n\t\t\t\t\t       len > 0 ? 0 : FNE_CHECK_START);\n    if (expr_start != NULL)\n    {\n\tchar_u\t*temp_string;\n\n\tif (!evaluate)\n\t{\n\t    len += (int)(p - *arg);\n\t    *arg = skipwhite(p);\n\t    return len;\n\t}\n\n\t/*\n\t * Include any <SID> etc in the expanded string:\n\t * Thus the -len here.\n\t */\n\ttemp_string = make_expanded_name(*arg - len, expr_start, expr_end, p);\n\tif (temp_string == NULL)\n\t    return -1;\n\t*alias = temp_string;\n\t*arg = skipwhite(p);\n\treturn (int)STRLEN(temp_string);\n    }\n\n    len += get_id_len(arg);\n    // Only give an error when there is something, otherwise it will be\n    // reported at a higher level.\n    if (len == 0 && verbose && **arg != NUL)\n\tsemsg(_(e_invalid_expression_str), *arg);\n\n    return len;\n}\n\n/*\n * Find the end of a variable or function name, taking care of magic braces.\n * If \"expr_start\" is not NULL then \"expr_start\" and \"expr_end\" are set to the\n * start and end of the first magic braces item.\n * \"flags\" can have FNE_INCL_BR and FNE_CHECK_START.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nfind_name_end(\n    char_u\t*arg,\n    char_u\t**expr_start,\n    char_u\t**expr_end,\n    int\t\tflags)\n{\n    int\t\tmb_nest = 0;\n    int\t\tbr_nest = 0;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tvim9script = in_vim9script();\n\n    if (expr_start != NULL)\n    {\n\t*expr_start = NULL;\n\t*expr_end = NULL;\n    }\n\n    // Quick check for valid starting character.\n    if ((flags & FNE_CHECK_START) && !eval_isnamec1(*arg)\n\t\t\t\t\t\t&& (*arg != '{' || vim9script))\n\treturn arg;\n\n    for (p = arg; *p != NUL\n\t\t    && (eval_isnamec(*p)\n\t\t\t|| (*p == '{' && !vim9script)\n\t\t\t|| ((flags & FNE_INCL_BR) && (*p == '['\n\t\t\t\t\t || (*p == '.' && eval_isdictc(p[1]))))\n\t\t\t|| mb_nest != 0\n\t\t\t|| br_nest != 0); MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    // skip over 'string' to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\\''; MB_PTR_ADV(p))\n\t\t;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    // skip over \"str\\\"ing\" to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (br_nest == 0 && mb_nest == 0 && *p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace. But {ns}: is.\n\t    len = (int)(p - arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, *arg) == NULL)\n\t\t    || (len > 1 && p[-1] != '}'))\n\t\tbreak;\n\t}\n\n\tif (mb_nest == 0)\n\t{\n\t    if (*p == '[')\n\t\t++br_nest;\n\t    else if (*p == ']')\n\t\t--br_nest;\n\t}\n\n\tif (br_nest == 0 && !vim9script)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tmb_nest++;\n\t\tif (expr_start != NULL && *expr_start == NULL)\n\t\t    *expr_start = p;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\tmb_nest--;\n\t\tif (expr_start != NULL && mb_nest == 0 && *expr_end == NULL)\n\t\t    *expr_end = p;\n\t    }\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Expands out the 'magic' {}'s in a variable/function name.\n * Note that this can call itself recursively, to deal with\n * constructs like foo{bar}{baz}{bam}\n * The four pointer arguments point to \"foo{expre}ss{ion}bar\"\n *\t\t\t\"in_start\"      ^\n *\t\t\t\"expr_start\"\t   ^\n *\t\t\t\"expr_end\"\t\t ^\n *\t\t\t\"in_end\"\t\t\t    ^\n *\n * Returns a new allocated string, which the caller must free.\n * Returns NULL for failure.\n */\n    static char_u *\nmake_expanded_name(\n    char_u\t*in_start,\n    char_u\t*expr_start,\n    char_u\t*expr_end,\n    char_u\t*in_end)\n{\n    char_u\tc1;\n    char_u\t*retval = NULL;\n    char_u\t*temp_result;\n\n    if (expr_end == NULL || in_end == NULL)\n\treturn NULL;\n    *expr_start\t= NUL;\n    *expr_end = NUL;\n    c1 = *in_end;\n    *in_end = NUL;\n\n    temp_result = eval_to_string(expr_start + 1, FALSE);\n    if (temp_result != NULL)\n    {\n\tretval = alloc(STRLEN(temp_result) + (expr_start - in_start)\n\t\t\t\t\t\t   + (in_end - expr_end) + 1);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, in_start);\n\t    STRCAT(retval, temp_result);\n\t    STRCAT(retval, expr_end + 1);\n\t}\n    }\n    vim_free(temp_result);\n\n    *in_end = c1;\t\t// put char back for error messages\n    *expr_start = '{';\n    *expr_end = '}';\n\n    if (retval != NULL)\n    {\n\ttemp_result = find_name_end(retval, &expr_start, &expr_end, 0);\n\tif (expr_start != NULL)\n\t{\n\t    // Further expansion!\n\t    temp_result = make_expanded_name(retval, expr_start,\n\t\t\t\t\t\t       expr_end, temp_result);\n\t    vim_free(retval);\n\t    retval = temp_result;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if character \"c\" can be used in a variable or function name.\n * Does not include '{' or '}' for magic braces.\n */\n    int\neval_isnamec(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character in a\n * variable or function name (excluding '{' and '}').\n */\n    int\neval_isnamec1(int c)\n{\n    return ASCII_ISALPHA(c) || c == '_';\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character of a\n * dictionary key.\n */\n    int\neval_isdictc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * Handle:\n * - expr[expr], expr[expr:expr] subscript\n * - \".name\" lookup\n * - function call with Funcref variable: func(expr)\n * - method call: var->method()\n *\n * Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()\n * \"name_start\" points to a variable before the subscript or is NULL.\n */\n    int\nhandle_subscript(\n    char_u\t**arg,\n    char_u\t*name_start,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tret = OK;\n    dict_T\t*selfdict = NULL;\n    int\t\tcheck_white = TRUE;\n    int\t\tgetnext;\n    char_u\t*p;\n\n    while (ret == OK)\n    {\n\t// When at the end of the line and \".name\" or \"->{\" or \"->X\" follows in\n\t// the next line then consume the line break.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (getnext\n\t    && ((rettv->v_type == VAR_DICT && *p == '.' && eval_isdictc(p[1]))\n\t\t|| (p[0] == '-' && p[1] == '>' && (p[2] == '{'\n\t\t\t|| ASCII_ISALPHA(in_vim9script() ? *skipwhite(p + 2)\n\t\t\t\t\t\t\t\t    : p[2])))))\n\t{\n\t    *arg = eval_next_line(evalarg);\n\t    p = *arg;\n\t    check_white = FALSE;\n\t}\n\n\tif (rettv->v_type == VAR_ANY)\n\t{\n\t    char_u\t*exp_name;\n\t    int\t\tcc;\n\t    int\t\tidx;\n\t    ufunc_T\t*ufunc;\n\t    type_T\t*type;\n\n\t    // Found script from \"import {name} as name\", script item name must\n\t    // follow.  \"rettv->vval.v_number\" has the script ID.\n\t    if (**arg != '.')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_expected_dot_after_name_str),\n\t\t\t\t\tname_start != NULL ? name_start: *arg);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    ++*arg;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // isolate the name\n\t    exp_name = *arg;\n\t    while (eval_isnamec(**arg))\n\t\t++*arg;\n\t    cc = **arg;\n\t    **arg = NUL;\n\n\t    idx = find_exported(rettv->vval.v_number, exp_name, &ufunc, &type,\n\t\t\t\t\t\t  evalarg->eval_cctx, verbose);\n\t    **arg = cc;\n\n\t    if (idx < 0 && ufunc == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (idx >= 0)\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(rettv->vval.v_number);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t\tcopy_tv(sv->sv_tv, rettv);\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_FUNC;\n\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t    }\n\t    continue;\n\t}\n\n\tif ((**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC\n\t\t\t    || rettv->v_type == VAR_PARTIAL))\n\t\t    && (!check_white || !VIM_ISWHITE(*(*arg - 1))))\n\t{\n\t    ret = call_func_rettv(arg, evalarg, rettv, evaluate,\n\t\t\t\t\t\t\t       selfdict, NULL);\n\n\t    // Stop the expression evaluation when immediately aborting on\n\t    // error, or when an interrupt occurred or an exception was thrown\n\t    // but not caught.\n\t    if (aborting())\n\t    {\n\t\tif (ret == OK)\n\t\t    clear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t    dict_unref(selfdict);\n\t    selfdict = NULL;\n\t}\n\telse if (p[0] == '-' && p[1] == '>')\n\t{\n\t    if (in_vim9script())\n\t\t*arg = skipwhite(p + 2);\n\t    else\n\t\t*arg = p + 2;\n\t    if (ret == OK)\n\t    {\n\t\tif (VIM_ISWHITE(**arg))\n\t\t{\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    ret = FAIL;\n\t\t}\n\t\telse if ((**arg == '{' && !in_vim9script()) || **arg == '(')\n\t\t    // expr->{lambda}() or expr->(lambda)()\n\t\t    ret = eval_lambda(arg, rettv, evalarg, verbose);\n\t\telse\n\t\t    // expr->name()\n\t\t    ret = eval_method(arg, rettv, evalarg, verbose);\n\t    }\n\t}\n\t// \".\" is \".name\" lookup when we found a dict or when evaluating and\n\t// scriptversion is at least 2, where string concatenation is \"..\".\n\telse if (**arg == '['\n\t\t|| (**arg == '.' && (rettv->v_type == VAR_DICT\n\t\t\t|| (!evaluate\n\t\t\t    && (*arg)[1] != '.'\n\t\t\t    && !in_old_script(2)))))\n\t{\n\t    dict_unref(selfdict);\n\t    if (rettv->v_type == VAR_DICT)\n\t    {\n\t\tselfdict = rettv->vval.v_dict;\n\t\tif (selfdict != NULL)\n\t\t    ++selfdict->dv_refcount;\n\t    }\n\t    else\n\t\tselfdict = NULL;\n\t    if (eval_index(arg, rettv, evalarg, verbose) == FAIL)\n\t    {\n\t\tclear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // Don't do this when \"Func\" is already a partial that was bound\n    // explicitly (pt_auto is FALSE).\n    if (selfdict != NULL\n\t    && (rettv->v_type == VAR_FUNC\n\t\t|| (rettv->v_type == VAR_PARTIAL\n\t\t    && (rettv->vval.v_partial->pt_auto\n\t\t\t|| rettv->vval.v_partial->pt_dict == NULL))))\n\tselfdict = make_partial(selfdict, rettv);\n\n    dict_unref(selfdict);\n    return ret;\n}\n\n/*\n * Make a copy of an item.\n * Lists and Dictionaries are also copied.  A deep copy if \"deep\" is set.\n * For deepcopy() \"copyID\" is zero for a full copy or the ID for when a\n * reference to an already copied list/dict can be used.\n * Returns FAIL or OK.\n */\n    int\nitem_copy(\n    typval_T\t*from,\n    typval_T\t*to,\n    int\t\tdeep,\n    int\t\tcopyID)\n{\n    static int\trecurse = 0;\n    int\t\tret = OK;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_making_copy));\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_FLOAT:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    copy_tv(from, to);\n\t    break;\n\tcase VAR_LIST:\n\t    to->v_type = VAR_LIST;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else if (copyID != 0 && from->vval.v_list->lv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_list = from->vval.v_list->lv_copylist;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_list = list_copy(from->vval.v_list, deep, copyID);\n\t    if (to->vval.v_list == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_BLOB:\n\t    ret = blob_copy(from->vval.v_blob, to);\n\t    break;\n\tcase VAR_DICT:\n\t    to->v_type = VAR_DICT;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_dict = from->vval.v_dict->dv_copydict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_dict = dict_copy(from->vval.v_dict, deep, copyID);\n\t    if (to->vval.v_dict == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    internal_error_no_abort(\"item_copy(UNKNOWN)\");\n\t    ret = FAIL;\n    }\n    --recurse;\n    return ret;\n}\n\n    void\necho_one(typval_T *rettv, int with_space, int *atstart, int *needclr)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*p = echo_string(rettv, &tofree, numbuf, get_copyID());\n\n    if (*atstart)\n    {\n\t*atstart = FALSE;\n\t// Call msg_start() after eval1(), evaluating the expression\n\t// may cause a message to appear.\n\tif (with_space)\n\t{\n\t    // Mark the saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back\n\t    // at the more prompt.\n\t    msg_sb_eol();\n\t    msg_start();\n\t}\n    }\n    else if (with_space)\n\tmsg_puts_attr(\" \", echo_attr);\n\n    if (p != NULL)\n\tfor ( ; *p != NUL && !got_int; ++p)\n\t{\n\t    if (*p == '\\n' || *p == '\\r' || *p == TAB)\n\t    {\n\t\tif (*p != TAB && *needclr)\n\t\t{\n\t\t    // remove any text still there from the command\n\t\t    msg_clr_eos();\n\t\t    *needclr = FALSE;\n\t\t}\n\t\tmsg_putchar_attr(*p, echo_attr);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int i = (*mb_ptr2len)(p);\n\n\t\t    (void)msg_outtrans_len_attr(p, i, echo_attr);\n\t\t    p += i - 1;\n\t\t}\n\t\telse\n\t\t    (void)msg_outtrans_len_attr(p, 1, echo_attr);\n\t    }\n\t}\n    vim_free(tofree);\n}\n\n/*\n * \":echo expr1 ...\"\tprint each argument separated with a space, add a\n *\t\t\tnewline at the end.\n * \":echon expr1 ...\"\tprint each argument plain.\n */\n    void\nex_echo(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    char_u\t*arg_start;\n    int\t\tneedclr = TRUE;\n    int\t\tatstart = TRUE;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while ((!ends_excmd2(eap->cmd, arg) || *arg == '\"') && !got_int)\n    {\n\t// If eval1() causes an error message the text from the command may\n\t// still need to be cleared. E.g., \"echo 22,44\".\n\tneed_clr_eos = needclr;\n\n\targ_start = arg;\n\tif (eval1(&arg, &rettv, &evalarg) == FAIL)\n\t{\n\t    /*\n\t     * Report the invalid expression unless the expression evaluation\n\t     * has been cancelled due to an aborting error, an interrupt, or an\n\t     * exception.\n\t     */\n\t    if (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t\tsemsg(_(e_invalid_expression_str), arg_start);\n\t    need_clr_eos = FALSE;\n\t    break;\n\t}\n\tneed_clr_eos = FALSE;\n\n\tif (!eap->skip)\n\t{\n\t    if (rettv.v_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), arg_start);\n\t\tbreak;\n\t    }\n\t    echo_one(&rettv, eap->cmdidx == CMD_echo, &atstart, &needclr);\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n    set_nextcmd(eap, arg);\n    clear_evalarg(&evalarg, eap);\n\n    if (eap->skip)\n\t--emsg_skip;\n    else\n    {\n\t// remove text that may still be there from the command\n\tif (needclr)\n\t    msg_clr_eos();\n\tif (eap->cmdidx == CMD_echo)\n\t    msg_end();\n    }\n}\n\n/*\n * \":echohl {name}\".\n */\n    void\nex_echohl(exarg_T *eap)\n{\n    echo_attr = syn_name2attr(eap->arg);\n}\n\n/*\n * Returns the :echo attribute\n */\n    int\nget_echo_attr(void)\n{\n    return echo_attr;\n}\n\n/*\n * \":execute expr1 ...\"\texecute the result of an expression.\n * \":echomsg expr1 ...\"\tPrint a message\n * \":echoerr expr1 ...\"\tPrint an error\n * \":echoconsole expr1 ...\" Print a message on stdout\n * Each gets spaces around each argument and a newline at the end for\n * echo commands\n */\n    void\nex_execute(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\tret = OK;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\tlen;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    ga_init2(&ga, 1, 80);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while (!ends_excmd2(eap->cmd, arg) || *arg == '\"')\n    {\n\tret = eval1_emsg(&arg, &rettv, eap);\n\tif (ret == FAIL)\n\t    break;\n\n\tif (!eap->skip)\n\t{\n\t    char_u   buf[NUMBUFLEN];\n\n\t    if (eap->cmdidx == CMD_execute)\n\t    {\n\t\tif (rettv.v_type == VAR_CHANNEL || rettv.v_type == VAR_JOB)\n\t\t{\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(rettv.v_type));\n\t\t    p = NULL;\n\t\t}\n\t\telse\n\t\t    p = tv_get_string_buf(&rettv, buf);\n\t    }\n\t    else\n\t\tp = tv_stringify(&rettv, buf);\n\t    if (p == NULL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    len = (int)STRLEN(p);\n\t    if (ga_grow(&ga, len + 2) == FAIL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (ga.ga_len)\n\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t    ga.ga_len += len;\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n\n    if (ret != FAIL && ga.ga_data != NULL)\n    {\n\t// use the first line of continuation lines for messages\n\tSOURCING_LNUM = start_lnum;\n\n\tif (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr)\n\t{\n\t    // Mark the already saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back at the\n\t    // more prompt.\n\t    msg_sb_eol();\n\t}\n\n\tif (eap->cmdidx == CMD_echomsg)\n\t{\n\t    msg_attr(ga.ga_data, echo_attr);\n\t    out_flush();\n\t}\n\telse if (eap->cmdidx == CMD_echoconsole)\n\t{\n\t    ui_write(ga.ga_data, (int)STRLEN(ga.ga_data), TRUE);\n\t    ui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t}\n\telse if (eap->cmdidx == CMD_echoerr)\n\t{\n\t    int\t\tsave_did_emsg = did_emsg;\n\n\t    // We don't want to abort following commands, restore did_emsg.\n\t    emsg(ga.ga_data);\n\t    if (!force_abort)\n\t\tdid_emsg = save_did_emsg;\n\t}\n\telse if (eap->cmdidx == CMD_execute)\n\t    do_cmdline((char_u *)ga.ga_data,\n\t\t       eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);\n    }\n\n    ga_clear(&ga);\n\n    if (eap->skip)\n\t--emsg_skip;\n\n    set_nextcmd(eap, arg);\n}\n\n/*\n * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\".\n * \"arg\" points to the \"&\" or '+' when called, to \"option\" when returning.\n * Returns NULL when no option name found.  Otherwise pointer to the char\n * after the option name.\n */\n    char_u *\nfind_option_end(char_u **arg, int *scope)\n{\n    char_u\t*p = *arg;\n\n    ++p;\n    if (*p == 'g' && p[1] == ':')\n    {\n\t*scope = OPT_GLOBAL;\n\tp += 2;\n    }\n    else if (*p == 'l' && p[1] == ':')\n    {\n\t*scope = OPT_LOCAL;\n\tp += 2;\n    }\n    else\n\t*scope = 0;\n\n    if (!ASCII_ISALPHA(*p))\n\treturn NULL;\n    *arg = p;\n\n    if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL)\n\tp += 4;\t    // termcap option\n    else\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n    return p;\n}\n\n/*\n * Display script name where an item was last set.\n * Should only be invoked when 'verbose' is non-zero.\n */\n    void\nlast_set_msg(sctx_T script_ctx)\n{\n    char_u *p;\n\n    if (script_ctx.sc_sid != 0)\n    {\n\tp = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));\n\tif (p != NULL)\n\t{\n\t    verbose_enter();\n\t    msg_puts(_(\"\\n\\tLast set from \"));\n\t    msg_puts((char *)p);\n\t    if (script_ctx.sc_lnum > 0)\n\t    {\n\t\tmsg_puts(_(line_msg));\n\t\tmsg_outnum((long)script_ctx.sc_lnum);\n\t    }\n\t    verbose_leave();\n\t    vim_free(p);\n\t}\n    }\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Perform a substitution on \"str\" with pattern \"pat\" and substitute \"sub\".\n * When \"sub\" is NULL \"expr\" is used, must be a VAR_FUNC or VAR_PARTIAL.\n * \"flags\" can be \"g\" to do a global substitute.\n * Returns an allocated string, NULL for error.\n */\n    char_u *\ndo_string_sub(\n    char_u\t*str,\n    char_u\t*pat,\n    char_u\t*sub,\n    typval_T\t*expr,\n    char_u\t*flags)\n{\n    int\t\tsublen;\n    regmatch_T\tregmatch;\n    int\t\ti;\n    int\t\tdo_all;\n    char_u\t*tail;\n    char_u\t*end;\n    garray_T\tga;\n    char_u\t*ret;\n    char_u\t*save_cpo;\n    char_u\t*zero_width = NULL;\n\n    // Make 'cpoptions' empty, so that the 'l' flag doesn't work here\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n\n    ga_init2(&ga, 1, 200);\n\n    do_all = (flags[0] == 'g');\n\n    regmatch.rm_ic = p_ic;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\ttail = str;\n\tend = str + STRLEN(str);\n\twhile (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))\n\t{\n\t    // Skip empty match except for first match.\n\t    if (regmatch.startp[0] == regmatch.endp[0])\n\t    {\n\t\tif (zero_width == regmatch.startp[0])\n\t\t{\n\t\t    // avoid getting stuck on a match with an empty string\n\t\t    i = mb_ptr2len(tail);\n\t\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,\n\t\t\t\t\t\t\t\t   (size_t)i);\n\t\t    ga.ga_len += i;\n\t\t    tail += i;\n\t\t    continue;\n\t\t}\n\t\tzero_width = regmatch.startp[0];\n\t    }\n\n\t    /*\n\t     * Get some space for a temporary buffer to do the substitution\n\t     * into.  It will contain:\n\t     * - The text up to where the match is.\n\t     * - The substituted text.\n\t     * - The text after the match.\n\t     */\n\t    sublen = vim_regsub(&regmatch, sub, expr, tail, FALSE, TRUE, FALSE);\n\t    if (ga_grow(&ga, (int)((end - tail) + sublen -\n\t\t\t    (regmatch.endp[0] - regmatch.startp[0]))) == FAIL)\n\t    {\n\t\tga_clear(&ga);\n\t\tbreak;\n\t    }\n\n\t    // copy the text up to where the match is\n\t    i = (int)(regmatch.startp[0] - tail);\n\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n\t    // add the substituted text\n\t    (void)vim_regsub(&regmatch, sub, expr, (char_u *)ga.ga_data\n\t\t\t\t\t  + ga.ga_len + i, TRUE, TRUE, FALSE);\n\t    ga.ga_len += i + sublen - 1;\n\t    tail = regmatch.endp[0];\n\t    if (*tail == NUL)\n\t\tbreak;\n\t    if (!do_all)\n\t\tbreak;\n\t}\n\n\tif (ga.ga_data != NULL)\n\t    STRCPY((char *)ga.ga_data + ga.ga_len, tail);\n\n\tvim_regfree(regmatch.regprog);\n    }\n\n    ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);\n    ga_clear(&ga);\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, evaluating {sub} expression or {expr} changed the value.\n\t// If it's still empty it was changed and restored, need to restore in\n\t// the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tfree_string_option(save_cpo);\n    }\n\n    return ret;\n}\n", "\" Tests for various eval things.\n\nsource view_util.vim\n\nfunction s:foo() abort\n  try\n    return [] == 0\n  catch\n    return 1\n  endtry\nendfunction\n\nfunc Test_catch_return_with_error()\n  call assert_equal(1, s:foo())\nendfunc\n\nfunc Test_nocatch_restore_silent_emsg()\n  silent! try\n    throw 1\n  catch\n  endtry\n  echoerr 'wrong again'\n  call assert_equal('wrong again', ScreenLine(&lines))\nendfunc\n\nfunc Test_mkdir_p()\n  call mkdir('Xmkdir/nested', 'p')\n  call assert_true(isdirectory('Xmkdir/nested'))\n  try\n    \" Trying to make existing directories doesn't error\n    call mkdir('Xmkdir', 'p')\n    call mkdir('Xmkdir/nested', 'p')\n  catch /E739:/\n    call assert_report('mkdir(..., \"p\") failed for an existing directory')\n  endtry\n  \" 'p' doesn't suppress real errors\n  call writefile([], 'Xfile')\n  call assert_fails('call mkdir(\"Xfile\", \"p\")', 'E739:')\n  call delete('Xfile')\n  call delete('Xmkdir', 'rf')\n  call assert_equal(0, mkdir(test_null_string()))\n  call assert_fails('call mkdir([])', 'E730:')\n  call assert_fails('call mkdir(\"abc\", [], [])', 'E745:')\nendfunc\n\nfunc Test_line_continuation()\n  let array = [5,\n\t\"\\ ignore this\n\t\\ 6,\n\t\"\\ more to ignore\n\t\"\\ more moreto ignore\n\t\\ ]\n\t\"\\ and some more\n  call assert_equal([5, 6], array)\nendfunc\n\nfunc Test_E963()\n  \" These commands used to cause an internal error prior to vim 8.1.0563\n  let v_e = v:errors\n  let v_o = v:oldfiles\n  call assert_fails(\"let v:errors=''\", 'E963:')\n  call assert_equal(v_e, v:errors)\n  call assert_fails(\"let v:oldfiles=''\", 'E963:')\n  call assert_equal(v_o, v:oldfiles)\nendfunc\n\nfunc Test_for_invalid()\n  call assert_fails(\"for x in 99\", 'E1098:')\n  call assert_fails(\"for x in function('winnr')\", 'E1098:')\n  call assert_fails(\"for x in {'a': 9}\", 'E1098:')\n\n  if 0\n    /1/5/2/s/\\n\n  endif\n  redraw\nendfunc\n\nfunc Test_readfile_binary()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  setlocal ff=dos\n  silent write XReadfile_bin\n  let lines = 'XReadfile_bin'->readfile()\n  call assert_equal(['one', 'two', 'three'], lines)\n  let lines = readfile('XReadfile_bin', '', 2)\n  call assert_equal(['one', 'two'], lines)\n  let lines = readfile('XReadfile_bin', 'b')\n  call assert_equal([\"one\\r\", \"two\\r\", \"three\\r\", \"\"], lines)\n  let lines = readfile('XReadfile_bin', 'b', 2)\n  call assert_equal([\"one\\r\", \"two\\r\"], lines)\n\n  bwipe!\n  call delete('XReadfile_bin')\nendfunc\n\nfunc Test_readfile_binary_empty()\n  call writefile([], 'Xempty-file')\n  \" This used to compare uninitialized memory in Vim <= 8.2.4065\n  call assert_equal([''], readfile('Xempty-file', 'b'))\n  call delete('Xempty-file')\nendfunc\n\nfunc Test_readfile_bom()\n  call writefile([\"\\ufeffFOO\", \"FOO\\ufeffBAR\"], 'XReadfile_bom')\n  call assert_equal(['FOO', 'FOOBAR'], readfile('XReadfile_bom'))\n  call delete('XReadfile_bom')\nendfunc\n\nfunc Test_readfile_max()\n  call writefile(range(1, 4), 'XReadfile_max')\n  call assert_equal(['1', '2'], readfile('XReadfile_max', '', 2))\n  call assert_equal(['3', '4'], readfile('XReadfile_max', '', -2))\n  call delete('XReadfile_max')\nendfunc\n\nfunc Test_let_errmsg()\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\nendfunc\n\nfunc Test_string_concatenation()\n  call assert_equal('ab', 'a'.'b')\n  call assert_equal('ab', 'a' .'b')\n  call assert_equal('ab', 'a'. 'b')\n  call assert_equal('ab', 'a' . 'b')\n\n  call assert_equal('ab', 'a'..'b')\n  call assert_equal('ab', 'a' ..'b')\n  call assert_equal('ab', 'a'.. 'b')\n  call assert_equal('ab', 'a' .. 'b')\n\n  let a = 'a'\n  let b = 'b'\n  let a .= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a.=b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a ..= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a..=b\n  call assert_equal('ab', a)\n\n  if has('float')\n    let a = 'A'\n    let b = 1.234\n    call assert_equal('A1.234', a .. b)\n  endif\nendfunc\n\n\" Test fix for issue #4507\nfunc Test_skip_after_throw()\n  try\n    throw 'something'\n    let x = wincol() || &ts\n  catch /something/\n  endtry\nendfunc\n\nscriptversion 2\nfunc Test_string_concat_scriptversion2()\n  call assert_true(has('vimscript-2'))\n  let a = 'a'\n  let b = 'b'\n\n  call assert_fails('echo a . b', 'E15:')\n  call assert_fails('let a .= b', 'E985:')\n  call assert_fails('let vers = 1.2.3', 'E488:')\n\n  if has('float')\n    let f = .5\n    call assert_equal(0.5, f)\n  endif\nendfunc\n\nscriptversion 1\nfunc Test_string_concat_scriptversion1()\n  call assert_true(has('vimscript-1'))\n  let a = 'a'\n  let b = 'b'\n\n  echo a . b\n  let a .= b\n  let vers = 1.2.3\n  call assert_equal('123', vers)\n\n  if has('float')\n    call assert_fails('let f = .5', 'E15:')\n  endif\nendfunc\n\nscriptversion 3\nfunc Test_vvar_scriptversion3()\n  call assert_true(has('vimscript-3'))\n  call assert_fails('echo version', 'E121:')\n  call assert_false(exists('version'))\n  let version = 1\n  call assert_equal(1, version)\nendfunc\n\nscriptversion 2\nfunc Test_vvar_scriptversion2()\n  call assert_true(exists('version'))\n  echo version\n  call assert_fails('let version = 1', 'E46:')\n  call assert_equal(v:version, version)\n\n  call assert_equal(v:version, v:versionlong / 10000)\n  call assert_true(v:versionlong > 8011525)\nendfunc\n\nfunc Test_dict_access_scriptversion2()\n  let l:x = {'foo': 1}\n\n  call assert_false(0 && l:x.foo)\n  call assert_true(1 && l:x.foo)\nendfunc\n\nscriptversion 4\nfunc Test_vvar_scriptversion4()\n  call assert_true(has('vimscript-4'))\n  call assert_equal(17, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\n  call assert_equal(64, 0b1'00'00'00)\n  call assert_equal(1048576, 0x10'00'00)\n  call assert_equal(32768, 0o10'00'00)\n  call assert_equal(1000000, 1'000'000)\n  call assert_equal(\"1234\", execute(\"echo 1'234\")->trim())\n  call assert_equal('1  234', execute(\"echo 1''234\")->trim())\n  call assert_fails(\"echo 1'''234\", 'E115:')\nendfunc\n\nscriptversion 1\nfunc Test_vvar_scriptversion1()\n  call assert_equal(15, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\nendfunc\n\nfunc Test_scriptversion_fail()\n  call writefile(['scriptversion 9'], 'Xversionscript')\n  call assert_fails('source Xversionscript', 'E999:')\n  call delete('Xversionscript')\nendfunc\n\nfunc Test_execute_cmd_with_null()\n  call assert_fails('execute test_null_list()', 'E730:')\n  call assert_fails('execute test_null_dict()', 'E731:')\n  call assert_fails('execute test_null_blob()', 'E976:')\n  execute test_null_string()\n  call assert_fails('execute test_null_partial()', 'E729:')\n  call assert_fails('execute test_unknown()', 'E908:')\n  if has('job')\n    call assert_fails('execute test_null_job()', 'E908:')\n    call assert_fails('execute test_null_channel()', 'E908:')\n  endif\nendfunc\n\nfunc Test_number_max_min_size()\n  \" This will fail on systems without 64 bit number support or when not\n  \" configured correctly.\n  call assert_equal(64, v:numbersize)\n\n  call assert_true(v:numbermin < -9999999)\n  call assert_true(v:numbermax > 9999999)\nendfunc\n\nfunc Assert_reg(name, type, value, valuestr, expr, exprstr)\n  call assert_equal(a:type, getregtype(a:name))\n  call assert_equal(a:value, getreg(a:name))\n  call assert_equal(a:valuestr, string(getreg(a:name, 0, 1)))\n  call assert_equal(a:expr, getreg(a:name, 1))\n  call assert_equal(a:exprstr, string(getreg(a:name, 1, 1)))\nendfunc\n\nfunc Test_let_register()\n  let @\" = 'abc'\n  call Assert_reg('\"', 'v', \"abc\", \"['abc']\", \"abc\", \"['abc']\")\n  let @\" = \"abc\\n\"\n  call Assert_reg('\"', 'V', \"abc\\n\", \"['abc']\", \"abc\\n\", \"['abc']\")\n  let @\" = \"abc\\<C-m>\"\n  call Assert_reg('\"', 'V', \"abc\\r\\n\", \"['abc\\r']\", \"abc\\r\\n\", \"['abc\\r']\")\n  let @= = '\"abc\"'\n  call Assert_reg('=', 'v', \"abc\", \"['abc']\", '\"abc\"', \"['\\\"abc\\\"']\")\nendfunc\n\nfunc Assert_regput(name, result)\n  new\n  execute \"silent normal! o==\\n==\\e\\\"\" . a:name . \"P\"\n  call assert_equal(a:result, getline(2, line('$')))\n  bwipe!\nendfunc\n\nfunc Test_setreg_basic()\n  call setreg('a', 'abcA', 'c')\n  call Assert_reg('a', 'v', \"abcA\", \"['abcA']\", \"abcA\", \"['abcA']\")\n  call Assert_regput('a', ['==', '=abcA='])\n\n  call setreg('A', 'abcAc', 'c')\n  call Assert_reg('A', 'v', \"abcAabcAc\", \"['abcAabcAc']\", \"abcAabcAc\", \"['abcAabcAc']\")\n  call Assert_regput('a', ['==', '=abcAabcAc='])\n\n  call setreg('A', 'abcAl', 'l')\n  call Assert_reg('A', 'V', \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\", \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\")\n  call Assert_regput('a', ['==', 'abcAabcAcabcAl', '=='])\n\n  call setreg('A', 'abcAc2','c')\n  call Assert_reg('A', 'v', \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\", \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\")\n  call Assert_regput('a', ['==', '=abcAabcAcabcAl', 'abcAc2='])\n\n  call setreg('b', 'abcB', 'v')\n  call Assert_reg('b', 'v', \"abcB\", \"['abcB']\", \"abcB\", \"['abcB']\")\n  call Assert_regput('b', ['==', '=abcB='])\n\n  call setreg('b', 'abcBc', 'ca')\n  call Assert_reg('b', 'v', \"abcBabcBc\", \"['abcBabcBc']\", \"abcBabcBc\", \"['abcBabcBc']\")\n  call Assert_regput('b', ['==', '=abcBabcBc='])\n\n  call setreg('b', 'abcBb', 'ba')\n  call Assert_reg('b', \"\\<C-V>5\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb='])\n\n  call setreg('b', 'abcBc2','ca')\n  call Assert_reg('b', \"v\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb', 'abcBc2='])\n\n  call setreg('b', 'abcBb2','b50a')\n  call Assert_reg('b', \"\\<C-V>50\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb                                    =', ' abcBc2abcBb2'])\n\n  call setreg('c', 'abcC', 'l')\n  call Assert_reg('c', 'V', \"abcC\\n\", \"['abcC']\", \"abcC\\n\", \"['abcC']\")\n  call Assert_regput('c', ['==', 'abcC', '=='])\n\n  call setreg('C', 'abcCl', 'l')\n  call Assert_reg('C', 'V', \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\", \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\")\n  call Assert_regput('c', ['==', 'abcC', 'abcCl', '=='])\n\n  call setreg('C', 'abcCc', 'c')\n  call Assert_reg('C', 'v', \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\", \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\")\n  call Assert_regput('c', ['==', '=abcC', 'abcCl', 'abcCc='])\n\n  call setreg('d', 'abcD', 'V')\n  call Assert_reg('d', 'V', \"abcD\\n\", \"['abcD']\", \"abcD\\n\", \"['abcD']\")\n  call Assert_regput('d', ['==', 'abcD', '=='])\n\n  call setreg('D', 'abcDb', 'b')\n  call Assert_reg('d', \"\\<C-V>5\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\")\n  call Assert_regput('d', ['==', '=abcD =', ' abcDb'])\n\n  call setreg('e', 'abcE', 'b')\n  call Assert_reg('e', \"\\<C-V>4\", \"abcE\", \"['abcE']\", \"abcE\", \"['abcE']\")\n  call Assert_regput('e', ['==', '=abcE='])\n\n  call setreg('E', 'abcEb', 'b')\n  call Assert_reg('E', \"\\<C-V>5\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\")\n  call Assert_regput('e', ['==', '=abcE =', ' abcEb'])\n\n  call setreg('E', 'abcEl', 'l')\n  call Assert_reg('E', \"V\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\")\n  call Assert_regput('e', ['==', 'abcE', 'abcEb', 'abcEl', '=='])\n\n  call setreg('f', 'abcF', \"\\<C-v>\")\n  call Assert_reg('f', \"\\<C-V>4\", \"abcF\", \"['abcF']\", \"abcF\", \"['abcF']\")\n  call Assert_regput('f', ['==', '=abcF='])\n\n  call setreg('F', 'abcFc', 'c')\n  call Assert_reg('F', \"v\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\")\n  call Assert_regput('f', ['==', '=abcF', 'abcFc='])\n\n  call setreg('g', 'abcG', 'b10')\n  call Assert_reg('g', \"\\<C-V>10\", \"abcG\", \"['abcG']\", \"abcG\", \"['abcG']\")\n  call Assert_regput('g', ['==', '=abcG      ='])\n\n  call setreg('h', 'abcH', \"\\<C-v>10\")\n  call Assert_reg('h', \"\\<C-V>10\", \"abcH\", \"['abcH']\", \"abcH\", \"['abcH']\")\n  call Assert_regput('h', ['==', '=abcH      ='])\n\n  call setreg('I', 'abcI')\n  call Assert_reg('I', \"v\", \"abcI\", \"['abcI']\", \"abcI\", \"['abcI']\")\n  call Assert_regput('I', ['==', '=abcI='])\n\n  \" Appending NL with setreg()\n  call setreg('a', 'abcA2', 'c')\n  call setreg('b', 'abcB2', 'v')\n  call setreg('c', 'abcC2', 'l')\n  call setreg('d', 'abcD2', 'V')\n  call setreg('e', 'abcE2', 'b')\n  call setreg('f', 'abcF2', \"\\<C-v>\")\n  call setreg('g', 'abcG2', 'b10')\n  call setreg('h', 'abcH2', \"\\<C-v>10\")\n  call setreg('I', 'abcI2')\n\n  call setreg('A', \"\\n\")\n  call Assert_reg('A', 'V', \"abcA2\\n\", \"['abcA2']\", \"abcA2\\n\", \"['abcA2']\")\n  call Assert_regput('A', ['==', 'abcA2', '=='])\n\n  call setreg('B', \"\\n\", 'c')\n  call Assert_reg('B', 'v', \"abcB2\\n\", \"['abcB2', '']\", \"abcB2\\n\", \"['abcB2', '']\")\n  call Assert_regput('B', ['==', '=abcB2', '='])\n\n  call setreg('C', \"\\n\")\n  call Assert_reg('C', 'V', \"abcC2\\n\\n\", \"['abcC2', '']\", \"abcC2\\n\\n\", \"['abcC2', '']\")\n  call Assert_regput('C', ['==', 'abcC2', '', '=='])\n\n  call setreg('D', \"\\n\", 'l')\n  call Assert_reg('D', 'V', \"abcD2\\n\\n\", \"['abcD2', '']\", \"abcD2\\n\\n\", \"['abcD2', '']\")\n  call Assert_regput('D', ['==', 'abcD2', '', '=='])\n\n  call setreg('E', \"\\n\")\n  call Assert_reg('E', 'V', \"abcE2\\n\\n\", \"['abcE2', '']\", \"abcE2\\n\\n\", \"['abcE2', '']\")\n  call Assert_regput('E', ['==', 'abcE2', '', '=='])\n\n  call setreg('F', \"\\n\", 'b')\n  call Assert_reg('F', \"\\<C-V>0\", \"abcF2\\n\", \"['abcF2', '']\", \"abcF2\\n\", \"['abcF2', '']\")\n  call Assert_regput('F', ['==', '=abcF2=', ' '])\n\n  \" Setting lists with setreg()\n  call setreg('a', ['abcA3'], 'c')\n  call Assert_reg('a', 'v', \"abcA3\", \"['abcA3']\", \"abcA3\", \"['abcA3']\")\n  call Assert_regput('a', ['==', '=abcA3='])\n\n  call setreg('b', ['abcB3'], 'l')\n  call Assert_reg('b', 'V', \"abcB3\\n\", \"['abcB3']\", \"abcB3\\n\", \"['abcB3']\")\n  call Assert_regput('b', ['==', 'abcB3', '=='])\n\n  call setreg('c', ['abcC3'], 'b')\n  call Assert_reg('c', \"\\<C-V>5\", \"abcC3\", \"['abcC3']\", \"abcC3\", \"['abcC3']\")\n  call Assert_regput('c', ['==', '=abcC3='])\n\n  call setreg('d', ['abcD3'])\n  call Assert_reg('d', 'V', \"abcD3\\n\", \"['abcD3']\", \"abcD3\\n\", \"['abcD3']\")\n  call Assert_regput('d', ['==', 'abcD3', '=='])\n\n  call setreg('e', [1, 2, 'abc', 3])\n  call Assert_reg('e', 'V', \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\", \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\")\n  call Assert_regput('e', ['==', '1', '2', 'abc', '3', '=='])\n\n  call setreg('f', [1, 2, 3])\n  call Assert_reg('f', 'V', \"1\\n2\\n3\\n\", \"['1', '2', '3']\", \"1\\n2\\n3\\n\", \"['1', '2', '3']\")\n  call Assert_regput('f', ['==', '1', '2', '3', '=='])\n\n  \" Appending lists with setreg()\n  call setreg('A', ['abcA3c'], 'c')\n  call Assert_reg('A', 'v', \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\", \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\")\n  call Assert_regput('A', ['==', '=abcA3', 'abcA3c='])\n\n  call setreg('b', ['abcB3l'], 'la')\n  call Assert_reg('b', 'V', \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\", \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\")\n  call Assert_regput('b', ['==', 'abcB3', 'abcB3l', '=='])\n\n  call setreg('C', ['abcC3b'], 'lb')\n  call Assert_reg('C', \"\\<C-V>6\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\")\n  call Assert_regput('C', ['==', '=abcC3 =', ' abcC3b'])\n\n  call setreg('D', ['abcD32'])\n  call Assert_reg('D', 'V', \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\", \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\")\n  call Assert_regput('D', ['==', 'abcD3', 'abcD32', '=='])\n\n  call setreg('A', ['abcA32'])\n  call Assert_reg('A', 'V', \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\", \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', '=='])\n\n  call setreg('B', ['abcB3c'], 'c')\n  call Assert_reg('B', 'v', \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\", \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c='])\n\n  call setreg('C', ['abcC3l'], 'l')\n  call Assert_reg('C', 'V', \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\", \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\")\n  call Assert_regput('C', ['==', 'abcC3', 'abcC3b', 'abcC3l', '=='])\n\n  call setreg('D', ['abcD3b'], 'b')\n  call Assert_reg('D', \"\\<C-V>6\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\")\n  call Assert_regput('D', ['==', '=abcD3 =', ' abcD32', ' abcD3b'])\n\n  \" Appending lists with NL with setreg()\n  call setreg('A', [\"\\n\", 'abcA3l2'], 'l')\n  call Assert_reg('A', \"V\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', \"\\n\", 'abcA3l2', '=='])\n\n  call setreg('B', [\"\\n\", 'abcB3c2'], 'c')\n  call Assert_reg('B', \"v\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c', \"\\n\", 'abcB3c2='])\n\n  call setreg('C', [\"\\n\", 'abcC3b2'], 'b')\n  call Assert_reg('C', \"\u00167\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\")\n  call Assert_regput('C', ['==', '=abcC3  =', ' abcC3b', ' abcC3l', \" \\n\", ' abcC3b2'])\n\n  call setreg('D', [\"\\n\", 'abcD3b50'],'b50')\n  call Assert_reg('D', \"\u001650\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\")\n  call Assert_regput('D', ['==', '=abcD3                                             =', ' abcD32', ' abcD3b', \" \\n\", ' abcD3b50'])\n\n  \" Setting lists with NLs with setreg()\n  call setreg('a', ['abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\"])\n  call Assert_reg('a', \"V\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\")\n  call Assert_regput('a', ['==', 'abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\", '=='])\n\n  call setreg('b', ['abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2\"], 'c')\n  call Assert_reg('b', \"v\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\")\n  call Assert_regput('b', ['==', '=abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2=\"])\n\n  call setreg('c', ['abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\"], 'l')\n  call Assert_reg('c', \"V\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\")\n  call Assert_regput('c', ['==', 'abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\", '=='])\n\n  call setreg('d', ['abcD4b-0', \"\\n\", \"abcD4b-2\\n\", \"\\nabcD4b-3\", \"abcD4b-4\\nabcD4b-4-2\"], 'b')\n  call Assert_reg('d', \"\u001619\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\")\n  call Assert_regput('d', ['==', '=abcD4b-0           =', \" \\n\", \" abcD4b-2\\n\", \" \\nabcD4b-3\", \" abcD4b-4\\nabcD4b-4-2\"])\n\n  call setreg('e', ['abcE4b10-0', \"\\n\", \"abcE4b10-2\\n\", \"\\nabcE4b10-3\", \"abcE4b10-4\\nabcE4b10-4-2\"], 'b10')\n  call Assert_reg('e', \"\u001610\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\")\n  call Assert_regput('e', ['==', '=abcE4b10-0=', \" \\n\", \" abcE4b10-2\\n\", \" \\nabcE4b10-3\", \" abcE4b10-4\\nabcE4b10-4-2\"])\n\n  \" Search and expressions\n  call setreg('/', ['abc/'])\n  call Assert_reg('/', 'v', \"abc/\", \"['abc/']\", \"abc/\", \"['abc/']\")\n  call Assert_regput('/', ['==', '=abc/='])\n\n  call setreg('/', [\"abc/\\n\"])\n  call Assert_reg('/', 'v', \"abc/\\n\", \"['abc/\\n']\", \"abc/\\n\", \"['abc/\\n']\")\n  call Assert_regput('/', ['==', \"=abc/\\n=\"])\n\n  call setreg('=', ['\"abc/\"'])\n  call Assert_reg('=', 'v', \"abc/\", \"['abc/']\", '\"abc/\"', \"['\\\"abc/\\\"']\")\n\n  call setreg('=', [\"\\\"abc/\\n\\\"\"])\n  call Assert_reg('=', 'v', \"abc/\\n\", \"['abc/\\n']\", \"\\\"abc/\\n\\\"\", \"['\\\"abc/\\n\\\"']\")\n\n  \" System clipboard\n  if has('clipboard')\n    new | only!\n    call setline(1, ['clipboard contents', 'something else'])\n    \" Save and restore system clipboard.\n    \" If no connection to X-Server is possible, test should succeed.\n    let _clipreg = ['*', getreg('*'), getregtype('*')]\n    let _clipopt = &cb\n    let &cb='unnamed'\n    1y\n    call Assert_reg('*', 'V', \"clipboard contents\\n\", \"['clipboard contents']\", \"clipboard contents\\n\", \"['clipboard contents']\")\n    tabdo :windo :echo \"hi\"\n    2y\n    call Assert_reg('*', 'V', \"something else\\n\", \"['something else']\", \"something else\\n\", \"['something else']\")\n    let &cb=_clipopt\n    call call('setreg', _clipreg)\n    enew!\n  endif\n\n  \" Error cases\n  call assert_fails('call setreg()', 'E119:')\n  call assert_fails('call setreg(1)', 'E119:')\n  call assert_fails('call setreg(1, 2, 3, 4)', 'E118:')\n  call assert_fails('call setreg([], 2)', 'E730:')\n  call assert_fails('call setreg(1, 2, [])', 'E730:')\n  call assert_fails('call setreg(\"/\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(\"=\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(1, [\"\", \"\", [], \"\"])', 'E730:')\nendfunc\n\nfunc Test_curly_assignment()\n  let s:svar = 'svar'\n  let g:gvar = 'gvar'\n  let lname = 'gvar'\n  let gname = 'gvar'\n  let {'s:'.lname} = {'g:'.gname}\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:'.lname } = { 'g:'.gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' . lname } = { 'g:' . gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' .. lname } = { 'g:' .. gname }\n  call assert_equal('gvar', s:gvar)\n\n  unlet s:svar\n  unlet s:gvar\n  unlet g:gvar\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\n#ifdef FEAT_CMDWIN\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\n#endif\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\nEXTERN char e_src_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= N_(\"E38: Null argument\"));\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= N_(\"E43: Damaged match string\"));\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= N_(\"E44: Corrupted regexp program\"));\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\nEXTERN char e_nr_more_file_to_edit[]\n\tINIT(= N_(\"E173: %d more file to edit\"));\nEXTERN char e_nr_more_files_to_edit[]\n\tINIT(= N_(\"E173: %d more files to edit\"));\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\n#ifdef FEAT_CMDWIN\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\n#endif\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= N_(\"E222: Add to internal buffer that was already read from\"));\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= N_(\"E228: makemap: Illegal mode\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= N_(\"E232: Cannot create BalloonEval with both message and callback\"));\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: no registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: no matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= N_(\"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\"));\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= N_(\"E292: Invalid count for del_bytes(): %ld\"));\nEXTERN char e_block_was_not_locked[]\n\tINIT(= N_(\"E293: block was not locked\"));\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= N_(\"E298: Didn't get block nr 0?\"));\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= N_(\"E298: Didn't get block nr 1?\"));\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= N_(\"E298: Didn't get block nr 2?\"));\n// E299 unused\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= N_(\"E304: ml_upd_block0(): Didn't get block 0??\"));\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= N_(\"E315: ml_get: invalid lnum: %ld\"));\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= N_(\"E316: ml_get: cannot find line %ld in buffer %d %s\"));\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= N_(\"E317: pointer block id wrong\"));\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= N_(\"E317: pointer block id wrong 2\"));\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= N_(\"E317: pointer block id wrong 3\"));\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= N_(\"E317: pointer block id wrong 4\"));\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= N_(\"E318: Updated too many blocks?\"));\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= N_(\"E320: Cannot find line %ld\"));\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= N_(\"E322: line number out of range: %ld past the end\"));\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= N_(\"E323: line count wrong in block %ld\"));\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\n// E340 unused\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= N_(\"E341: Internal error: lalloc(0, )\"));\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\n#ifdef FEAT_PATH_EXTRA\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\n#endif\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\n#endif\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= N_(\"E356: get_varp ERROR\"));\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\n#endif\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_canot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= N_(\"E438: u_undo: line numbers wrong\"));\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= N_(\"E439: undo list corrupt\"));\nEXTERN char e_undo_line_missing[]\n\tINIT(= N_(\"E440: undo line missing\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#endif\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= N_(\"E473: Internal error in regexp\"));\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: no call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: json decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: no autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_name_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: no autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: no autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: no :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_canot_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: netbeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\n// E538 unused\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: at bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: at top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: no cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= N_(\"E570: fatal error in cs_manage_matches\"));\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_here[]\n\tINIT(= N_(\"E578: Not allowed to change text here\"));\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_vim_selfile_cant_return_to_current_directory[]\n\tINIT(= N_(\"E614: vim_SelFile: can't return to current directory\"));\nEXTERN char e_vim_selfile_cant_get_current_directory[]\n\tINIT(= N_(\"E615: vim_SelFile: can't get current directory\"));\nEXTERN char e_vim_selfile_cant_get_font_str[]\n\tINIT(= N_(\"E616: vim_SelFile: can't get font %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: file \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: file \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= \"E627: missing colon: %s\");\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= \"E628: missing ! or / in: %s\");\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= \"E632: invalid buffer identifier in getLength\");\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= \"E633: invalid buffer identifier in getText\");\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= \"E634: invalid buffer identifier in remove\");\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= \"E635: invalid buffer identifier in insert\");\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= \"E636: invalid buffer identifier in create\");\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= \"E637: invalid buffer identifier in startDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= \"E638: invalid buffer identifier in stopDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= \"E639: invalid buffer identifier in setTitle\");\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= \"E640: invalid buffer identifier in initDone\");\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= \"E641: invalid buffer identifier in setBufferNumber\");\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= \"E642: File %s not found in setBufferNumber\");\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= \"E643: invalid buffer identifier in setFullName\");\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= \"E644: invalid buffer identifier in editFile\");\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= \"E645: invalid buffer identifier in setVisible\");\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= \"E646: invalid buffer identifier in setModified\");\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= \"E647: invalid buffer identifier in setDot\");\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= \"E648: invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= \"E649: invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= \"E650: invalid buffer identifier in defineAnnoType\");\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= \"E651: invalid buffer identifier in addAnno\");\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= \"E652: Invalid buffer identifier in getAnno\");\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_acwrite_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for acwrite buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: list index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_can_only_index_list_dictionary_or_blob[]\n\tINIT(= N_(\"E689: Can only index a List, Dictionary or Blob\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\n// E693 unused\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\n// E706 unused\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dicitonary[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n# ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n\t// E796\n# ifdef MSWIN\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: using Float as a String\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\n#endif\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= N_(\"E831: bf_key_init() called with empty password\"));\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: netbeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: no line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= N_(\"E877: (NFA regexp) Invalid character class: %d\"));\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: not an open channel\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\nEXTERN char e_expected_dict[]\n\tINIT(= N_(\"E922: expected a dict\"));\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= N_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: no line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: setting %s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= N_(\"E967: text property info corrupted\"));\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_type_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\n# ifdef FEAT_FLOAT\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\n# endif\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type[]\n\tINIT(= N_(\"E1008: Missing <type>\"));\nEXTERN char e_missing_gt_after_type[]\n\tINIT(= N_(\"E1009: Missing > after type\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item %s\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\n// E1045 not used\n// E1046 not used\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\n#ifdef FEAT_EVAL\n// E1065 unused\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n#ifndef FEAT_FLOAT\nEXTERN char e_this_vim_is_not_compiled_with_float_support[]\n\tINIT(= N_(\"E1076: This Vim is not compiled with float support\"));\n#endif\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n// E1078 unused\n// E1079 unused\n// E1080 unused\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\n// E1082 unused\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\nEXTERN char e_function_reference_invalid[]\n\tINIT(= N_(\"E1086: Function reference invalid\"));\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\n// E1088 unused\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\n// E1092 unused\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_return[]\n\tINIT(= N_(\"E1095: Unreachable code after :return\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\nEXTERN char e_one_argument_too_many[]\n\tINIT(= N_(\"E1106: One argument too many\"));\nEXTERN char e_nr_arguments_too_many[]\n\tINIT(= N_(\"E1106: %d arguments too many\"));\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\nEXTERN char e_item_not_found_str[]\n\tINIT(= N_(\"E1108: Item not found: %s\"));\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x100_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x100 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_list[]\n\tINIT(= N_(\"E1118: Cannot change list\"));\nEXTERN char e_cannot_change_list_item[]\n\tINIT(= N_(\"E1119: Cannot change list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\nEXTERN char e_cmd_maping_must_not_include_str_key[]\n\tINIT(= N_(\"E1137: <Cmd> mapping must not include %s key\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\n// E1142 unused\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\nEXTERN char e_expression_too_recursive_str[]\n\tINIT(= N_(\"E1169: Expression too recursive: %s\"));\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_blob_required[]\n\tINIT(= N_(\"E1182: Blob required\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1185: Cannot nest :redir\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL) && defined(FEAT_CMDWIN)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\nEXTERN char e_one_argument_too_few[]\n\tINIT(= N_(\"E1190: One argument too few\"));\nEXTERN char e_nr_arguments_too_few[]\n\tINIT(= N_(\"E1190: %d arguments too few\"));\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_can_only_be_used_on_dictionary_str[]\n\tINIT(= N_(\"E1203: Dot can only be used on a dictionary: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS) && defined(FEAT_EVAL)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_reference_is_not_set[]\n\tINIT(= N_(\"E1235: Function reference is not set\"));\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\nEXTERN char e_string_expected_for_argument_nr[]\n\tINIT(= N_(\"E1253: String expected for argument %d\"));\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_using_autoload_name_in_non_autoload_script_str[]\n\tINIT(= N_(\"E1263: Using autoload name in a non-autoload script: %s\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * eval.c: Expression evaluation.\n */\n#define USING_FLOAT_STUFF\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n#ifdef VMS\n# include <float.h>\n#endif\n\n#define NAMESPACE_CHAR\t(char_u *)\"abglstvw\"\n\n/*\n * When recursively copying lists and dicts we need to remember which ones we\n * have done to avoid endless recursiveness.  This unique ID is used for that.\n * The last bit is used for previous_funccal, ignored when comparing.\n */\nstatic int current_copyID = 0;\n\n/*\n * Info used by a \":for\" loop.\n */\ntypedef struct\n{\n    int\t\tfi_semicolon;\t// TRUE if ending in '; var]'\n    int\t\tfi_varcount;\t// nr of variables in the list\n    int\t\tfi_break_count;\t// nr of line breaks encountered\n    listwatch_T\tfi_lw;\t\t// keep an eye on the item used.\n    list_T\t*fi_list;\t// list being used\n    int\t\tfi_bi;\t\t// index of blob\n    blob_T\t*fi_blob;\t// blob being used\n    char_u\t*fi_string;\t// copy of string being used\n    int\t\tfi_byte_idx;\t// byte index in fi_string\n} forinfo_T;\n\nstatic int eval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval7t(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval7(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval7_leader(typval_T *rettv, int numeric_only, char_u *start_leader, char_u **end_leaderp);\n\nstatic int free_unref_items(int copyID);\nstatic char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);\n\n/*\n * Return \"n1\" divided by \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_divide(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    varnumber_T\tresult;\n\n    if (n2 == 0)\n    {\n\tif (in_vim9script())\n\t{\n\t    emsg(_(e_divide_by_zero));\n\t    if (failed != NULL)\n\t\t*failed = TRUE;\n\t}\n\tif (n1 == 0)\n\t    result = VARNUM_MIN; // similar to NaN\n\telse if (n1 < 0)\n\t    result = -VARNUM_MAX;\n\telse\n\t    result = VARNUM_MAX;\n    }\n    else\n\tresult = n1 / n2;\n\n    return result;\n}\n\n/*\n * Return \"n1\" modulus \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_modulus(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    if (n2 == 0 && in_vim9script())\n    {\n\temsg(_(e_divide_by_zero));\n\tif (failed != NULL)\n\t    *failed = TRUE;\n    }\n    return (n2 == 0) ? 0 : (n1 % n2);\n}\n\n/*\n * Initialize the global and v: variables.\n */\n    void\neval_init(void)\n{\n    evalvars_init();\n    func_init();\n\n#ifdef EBCDIC\n    /*\n     * Sort the function table, to enable binary search.\n     */\n    sortFunctions();\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\neval_clear(void)\n{\n    evalvars_clear();\n    free_scriptnames();  // must come after evalvars_clear().\n    free_locales();\n\n    // autoloaded script names\n    free_autoload_scriptnames();\n\n    // unreferenced lists and dicts\n    (void)garbage_collect(FALSE);\n\n    // functions not garbage collected\n    free_all_functions();\n}\n#endif\n\n    void\nfill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (getline_equal(eap->getline, eap->cookie, getsourceline))\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}\n\n/*\n * Top level evaluation function, returning a boolean.\n * Sets \"error\" to TRUE if there was an error.\n * Return TRUE or FALSE.\n */\n    int\neval_to_bool(\n    char_u\t*arg,\n    int\t\t*error,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    varnumber_T\tretval = FALSE;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL)\n\t*error = TRUE;\n    else\n    {\n\t*error = FALSE;\n\tif (!skip)\n\t{\n\t    if (in_vim9script())\n\t\tretval = tv_get_bool_chk(&tv, error);\n\t    else\n\t\tretval = (tv_get_number_chk(&tv, error) != 0);\n\t    clear_tv(&tv);\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return (int)retval;\n}\n\n/*\n * Call eval1() and give an error message if not done at a lower level.\n */\n    static int\neval1_emsg(char_u **arg, typval_T *rettv, exarg_T *eap)\n{\n    char_u\t*start = *arg;\n    int\t\tret;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    ret = eval1(arg, rettv, &evalarg);\n    if (ret == FAIL)\n    {\n\t// Report the invalid expression unless the expression evaluation has\n\t// been cancelled due to an aborting error, an interrupt, or an\n\t// exception, or we already gave a more specific error.\n\t// Also check called_emsg for when using assert_fails().\n\tif (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t    semsg(_(e_invalid_expression_str), start);\n    }\n    clear_evalarg(&evalarg, eap);\n    return ret;\n}\n\n/*\n * Return whether a typval is a valid expression to pass to eval_expr_typval()\n * or eval_expr_to_bool().  An empty string returns FALSE;\n */\n    int\neval_expr_valid_arg(typval_T *tv)\n{\n    return tv->v_type != VAR_UNKNOWN\n\t    && (tv->v_type != VAR_STRING\n\t\t  || (tv->vval.v_string != NULL && *tv->vval.v_string != NUL));\n}\n\n/*\n * Evaluate an expression, which can be a function, partial or string.\n * Pass arguments \"argv[argc]\".\n * Return the result in \"rettv\" and OK or FAIL.\n */\n    int\neval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n{\n    char_u\t*s;\n    char_u\tbuf[NUMBUFLEN];\n    funcexe_T\tfuncexe;\n\n    if (expr->v_type == VAR_FUNC)\n    {\n\ts = expr->vval.v_string;\n\tif (s == NULL || *s == NUL)\n\t    return FAIL;\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_evaluate = TRUE;\n\tif (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t    return FAIL;\n    }\n    else if (expr->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *partial = expr->vval.v_partial;\n\n\tif (partial == NULL)\n\t    return FAIL;\n\n\tif (partial->pt_func != NULL\n\t\t\t  && partial->pt_func->uf_def_status != UF_NOT_COMPILED)\n\t{\n\t    if (call_def_function(partial->pt_func, argc, argv,\n\t\t\t\t\t\t       partial, rettv) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    s = partial_name(partial);\n\t    if (s == NULL || *s == NUL)\n\t\treturn FAIL;\n\t    CLEAR_FIELD(funcexe);\n\t    funcexe.fe_evaluate = TRUE;\n\t    funcexe.fe_partial = partial;\n\t    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (expr->v_type == VAR_INSTR)\n    {\n\treturn exe_typval_instr(expr, rettv);\n    }\n    else\n    {\n\ts = tv_get_string_buf_chk(expr, buf);\n\tif (s == NULL)\n\t    return FAIL;\n\ts = skipwhite(s);\n\tif (eval1_emsg(&s, rettv, NULL) == FAIL)\n\t    return FAIL;\n\tif (*skipwhite(s) != NUL)  // check for trailing chars after expr\n\t{\n\t    clear_tv(rettv);\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Like eval_to_bool() but using a typval_T instead of a string.\n * Works for string, funcref and partial.\n */\n    int\neval_expr_to_bool(typval_T *expr, int *error)\n{\n    typval_T\trettv;\n    int\t\tres;\n\n    if (eval_expr_typval(expr, NULL, 0, &rettv) == FAIL)\n    {\n\t*error = TRUE;\n\treturn FALSE;\n    }\n    res = (tv_get_bool_chk(&rettv, error) != 0);\n    clear_tv(&rettv);\n    return res;\n}\n\n/*\n * Top level evaluation function, returning a string.  If \"skip\" is TRUE,\n * only parsing to \"nextcmd\" is done, without reporting errors.  Return\n * pointer to allocated memory, or NULL for failure or when \"skip\" is TRUE.\n */\n    char_u *\neval_to_string_skip(\n    char_u\t*arg,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL || skip)\n\tretval = NULL;\n    else\n    {\n\tretval = vim_strsave(tv_get_string(&tv));\n\tclear_tv(&tv);\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return retval;\n}\n\n/*\n * Skip over an expression at \"*pp\".\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr(char_u **pp, evalarg_T *evalarg)\n{\n    typval_T\trettv;\n\n    *pp = skipwhite(*pp);\n    return eval1(pp, &rettv, evalarg);\n}\n\n/*\n * Skip over an expression at \"*arg\".\n * If in Vim9 script and line breaks are encountered, the lines are\n * concatenated.  \"evalarg->eval_tofree\" will be set accordingly.\n * \"arg\" is advanced to just after the expression.\n * \"start\" is set to the start of the expression, \"end\" to just after the end.\n * Also when the expression is copied to allocated memory.\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\t// leave room for \"start\"\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n    // Don't evaluate the expression.\n    if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t    // just the one line, no need to concatenate\n\t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t    // Line breaks encountered, concatenate all the lines.\n\t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t    // free the lines only when using getsourceline()\n\t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t// Do not free the first line, the caller can still use it.\n\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t// Do not free the last line, \"arg\" points into it, free it\n\t\t// later.\n\t\tvim_free(evalarg->eval_tofree);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t// free lines that were explicitly marked for freeing\n\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t    // Compute \"end\" relative to the end.\n\t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Convert \"tv\" to a string.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Returns an allocated string (NULL when out of memory).\n */\n    char_u *\ntypval2string(typval_T *tv, int convert)\n{\n    garray_T\tga;\n    char_u\t*retval;\n#ifdef FEAT_FLOAT\n    char_u\tnumbuf[NUMBUFLEN];\n#endif\n\n    if (convert && tv->v_type == VAR_LIST)\n    {\n\tga_init2(&ga, sizeof(char), 80);\n\tif (tv->vval.v_list != NULL)\n\t{\n\t    list_join(&ga, tv->vval.v_list, (char_u *)\"\\n\", TRUE, FALSE, 0);\n\t    if (tv->vval.v_list->lv_len > 0)\n\t\tga_append(&ga, NL);\n\t}\n\tga_append(&ga, NUL);\n\tretval = (char_u *)ga.ga_data;\n    }\n#ifdef FEAT_FLOAT\n    else if (convert && tv->v_type == VAR_FLOAT)\n    {\n\tvim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\tretval = vim_strsave(numbuf);\n    }\n#endif\n    else\n\tretval = vim_strsave(tv_get_string(tv));\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a string.  Does not handle line\n * breaks.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Return pointer to allocated memory, or NULL for failure.\n */\n    char_u *\neval_to_string_eap(\n    char_u\t*arg,\n    int\t\tconvert,\n    exarg_T\t*eap)\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n    if (eval0(arg, &tv, NULL, &evalarg) == FAIL)\n\tretval = NULL;\n    else\n    {\n\tretval = typval2string(&tv, convert);\n\tclear_tv(&tv);\n    }\n    clear_evalarg(&evalarg, NULL);\n\n    return retval;\n}\n\n    char_u *\neval_to_string(\n    char_u\t*arg,\n    int\t\tconvert)\n{\n    return eval_to_string_eap(arg, convert, NULL);\n}\n\n/*\n * Call eval_to_string() without using current local variables and using\n * textwinlock.  When \"use_sandbox\" is TRUE use the sandbox.\n * Use legacy Vim script syntax.\n */\n    char_u *\neval_to_string_safe(\n    char_u\t*arg,\n    int\t\tuse_sandbox,\n    int\t\tkeep_script_version)\n{\n    char_u\t*retval;\n    funccal_entry_T funccal_entry;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n    int\t\tsave_garbage = may_garbage_collect;\n\n    if (!keep_script_version)\n\tcurrent_sctx.sc_version = 1;\n    save_funccal(&funccal_entry);\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n    may_garbage_collect = FALSE;\n    retval = eval_to_string(arg, FALSE);\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n    may_garbage_collect = save_garbage;\n    restore_funccal();\n    current_sctx.sc_version = save_sc_version;\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a number.\n * Evaluates \"expr\" silently.\n * Returns -1 for an error.\n */\n    varnumber_T\neval_to_number(char_u *expr)\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n    char_u\t*p = skipwhite(expr);\n\n    ++emsg_off;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == FAIL)\n\tretval = -1;\n    else\n    {\n\tretval = tv_get_number_chk(&rettv, NULL);\n\tclear_tv(&rettv);\n    }\n    --emsg_off;\n\n    return retval;\n}\n\n/*\n * Top level evaluation function.\n * Returns an allocated typval_T with the result.\n * Returns NULL when there is an error.\n */\n    typval_T *\neval_expr(char_u *arg, exarg_T *eap)\n{\n    typval_T\t*tv;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    tv = ALLOC_ONE(typval_T);\n    if (tv != NULL && eval0(arg, tv, eap, &evalarg) == FAIL)\n\tVIM_CLEAR(tv);\n\n    clear_evalarg(&evalarg, eap);\n    return tv;\n}\n\n/*\n * \"*arg\" points to what can be a function name in the form of \"import.Name\" or\n * \"Funcref\".  Return the name of the function.  Set \"tofree\" to something that\n * was allocated.\n * If \"verbose\" is FALSE no errors are given.\n * Return NULL for any failure.\n */\n    static char_u *\nderef_function_name(\n\t    char_u **arg,\n\t    char_u **tofree,\n\t    evalarg_T *evalarg,\n\t    int verbose)\n{\n    typval_T\tref;\n    char_u\t*name = *arg;\n\n    ref.v_type = VAR_UNKNOWN;\n    if (eval7(arg, &ref, evalarg, FALSE) == FAIL)\n\treturn NULL;\n    if (*skipwhite(*arg) != NUL)\n    {\n\tif (verbose)\n\t    semsg(_(e_trailing_characters_str), *arg);\n\tname = NULL;\n    }\n    else if (ref.v_type == VAR_FUNC && ref.vval.v_string != NULL)\n    {\n\tname = ref.vval.v_string;\n\tref.vval.v_string = NULL;\n\t*tofree = name;\n    }\n    else if (ref.v_type == VAR_PARTIAL && ref.vval.v_partial != NULL)\n    {\n\tif (ref.vval.v_partial->pt_argc > 0\n\t\t|| ref.vval.v_partial->pt_dict != NULL)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_use_partial_here));\n\t    name = NULL;\n\t}\n\telse\n\t{\n\t    name = vim_strsave(partial_name(ref.vval.v_partial));\n\t    *tofree = name;\n\t}\n    }\n    else\n    {\n\tif (verbose)\n\t    semsg(_(e_not_callable_type_str), name);\n\tname = NULL;\n    }\n    clear_tv(&ref);\n    return name;\n}\n\n/*\n * Call some Vim script function and return the result in \"*rettv\".\n * Uses argv[0] to argv[argc - 1] for the function arguments.  argv[argc]\n * should have type VAR_UNKNOWN.\n * Returns OK or FAIL.\n */\n    int\ncall_vim_function(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv,\n    typval_T\t*rettv)\n{\n    int\t\tret;\n    funcexe_T\tfuncexe;\n    char_u\t*arg;\n    char_u\t*name;\n    char_u\t*tofree = NULL;\n\n    rettv->v_type = VAR_UNKNOWN;\t\t// clear_tv() uses this\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = TRUE;\n\n    // The name might be \"import.Func\" or \"Funcref\".\n    arg = func;\n    ++emsg_off;\n    name = deref_function_name(&arg, &tofree, &EVALARG_EVALUATE, FALSE);\n    --emsg_off;\n    if (name == NULL)\n\tname = func;\n\n    ret = call_func(name, -1, rettv, argc, argv, &funcexe);\n\n    if (ret == FAIL)\n\tclear_tv(rettv);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a string.\n * Uses \"argv[0]\" to \"argv[argc - 1]\" for the function arguments. \"argv[argc]\"\n * should have type VAR_UNKNOWN.\n * Returns NULL when calling the function fails.\n */\n    void *\ncall_func_retstr(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n    char_u\t*retval;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    retval = vim_strsave(tv_get_string(&rettv));\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a List.\n * Uses \"argv\" and \"argc\" as call_func_retstr().\n * Returns NULL when there is something wrong.\n */\n    void *\ncall_func_retlist(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    if (rettv.v_type != VAR_LIST)\n    {\n\tclear_tv(&rettv);\n\treturn NULL;\n    }\n\n    return rettv.vval.v_list;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Evaluate \"arg\", which is 'foldexpr'.\n * Note: caller must set \"curwin\" to match \"arg\".\n * Returns the foldlevel, and any character preceding it in \"*cp\".  Doesn't\n * give error messages.\n */\n    int\neval_foldexpr(win_T *wp, int *cp)\n{\n    char_u\t*arg;\n    typval_T\ttv;\n    varnumber_T\tretval;\n    char_u\t*s;\n    sctx_T\tsaved_sctx = current_sctx;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"foldexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    arg = wp->w_p_fde;\n    current_sctx = wp->w_p_script_ctx[WV_FDE];\n\n    ++emsg_off;\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n    *cp = NUL;\n    if (eval0(arg, &tv, NULL, &EVALARG_EVALUATE) == FAIL)\n\tretval = 0;\n    else\n    {\n\t// If the result is a number, just return the number.\n\tif (tv.v_type == VAR_NUMBER)\n\t    retval = tv.vval.v_number;\n\telse if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL)\n\t    retval = 0;\n\telse\n\t{\n\t    // If the result is a string, check if there is a non-digit before\n\t    // the number.\n\t    s = tv.vval.v_string;\n\t    if (!VIM_ISDIGIT(*s) && *s != '-')\n\t\t*cp = *s++;\n\t    retval = atol((char *)s);\n\t}\n\tclear_tv(&tv);\n    }\n    --emsg_off;\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n    clear_evalarg(&EVALARG_EVALUATE, NULL);\n    current_sctx = saved_sctx;\n\n    return (int)retval;\n}\n#endif\n\n/*\n * Get an lval: variable, Dict item or List item that can be assigned a value\n * to: \"name\", \"na{me}\", \"name[expr]\", \"name[expr:expr]\", \"name[expr][expr]\",\n * \"name.key\", \"name.key[expr]\" etc.\n * Indexing only works if \"name\" is an existing List or Dictionary.\n * \"name\" points to the start of the name.\n * If \"rettv\" is not NULL it points to the value to be assigned.\n * \"unlet\" is TRUE for \":unlet\": slightly different behavior when something is\n * wrong; must end in space or cmd separator.\n *\n * flags:\n *  GLV_QUIET:       do not give error messages\n *  GLV_READ_ONLY:   will not change the variable\n *  GLV_NO_AUTOLOAD: do not use script autoloading\n *\n * Returns a pointer to just after the name, including indexes.\n * When an evaluation error occurs \"lp->ll_name\" is NULL;\n * Returns NULL for a parsing error.  Still need to free items in \"lp\"!\n */\n    char_u *\nget_lval(\n    char_u\t*name,\n    typval_T\t*rettv,\n    lval_T\t*lp,\n    int\t\tunlet,\n    int\t\tskip,\n    int\t\tflags,\t    // GLV_ values\n    int\t\tfne_flags)  // flags for find_name_end()\n{\n    char_u\t*p;\n    char_u\t*expr_start, *expr_end;\n    int\t\tcc;\n    dictitem_T\t*v;\n    typval_T\tvar1;\n    typval_T\tvar2;\n    int\t\tempty1 = FALSE;\n    char_u\t*key = NULL;\n    int\t\tlen;\n    hashtab_T\t*ht = NULL;\n    int\t\tquiet = flags & GLV_QUIET;\n    int\t\twriting;\n\n    // Clear everything in \"lp\".\n    CLEAR_POINTER(lp);\n\n    if (skip || (flags & GLV_COMPILING))\n    {\n\t// When skipping or compiling just find the end of the name.\n\tlp->ll_name = name;\n\tlp->ll_name_end = find_name_end(name, NULL, NULL,\n\t\t\t\t\t\t      FNE_INCL_BR | fne_flags);\n\treturn lp->ll_name_end;\n    }\n\n    // Find the end of the name.\n    p = find_name_end(name, &expr_start, &expr_end, fne_flags);\n    lp->ll_name_end = p;\n    if (expr_start != NULL)\n    {\n\t// Don't expand the name when we already know there is an error.\n\tif (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)\n\t\t\t\t\t\t    && *p != '[' && *p != '.')\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\n\tlp->ll_exp_name = make_expanded_name(name, expr_start, expr_end, p);\n\tif (lp->ll_exp_name == NULL)\n\t{\n\t    // Report an invalid expression in braces, unless the\n\t    // expression evaluation has been cancelled due to an\n\t    // aborting error, an interrupt, or an exception.\n\t    if (!aborting() && !quiet)\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_invalid_argument_str), name);\n\t\treturn NULL;\n\t    }\n\t}\n\tlp->ll_name = lp->ll_exp_name;\n    }\n    else\n    {\n\tlp->ll_name = name;\n\n\tif (in_vim9script())\n\t{\n\t    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n\t    if (p == name + 2 && p[-1] == ':')\n\t    {\n\t\t--p;\n\t\tlp->ll_name_end = p;\n\t    }\n\t    if (*p == ':')\n\t    {\n\t\tgarray_T    tmp_type_list;\n\t\tgarray_T    *type_list;\n\t\tchar_u\t    *tp = skipwhite(p + 1);\n\n\t\tif (tp == p + 1 && !quiet)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \":\", p);\n\t\t    return NULL;\n\t\t}\n\n\t\tif (SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t\t    type_list = &SCRIPT_ITEM(current_sctx.sc_sid)->sn_type_list;\n\t\telse\n\t\t{\n\t\t    type_list = &tmp_type_list;\n\t\t    ga_init2(type_list, sizeof(type_T), 10);\n\t\t}\n\n\t\t// parse the type after the name\n\t\tlp->ll_type = parse_type(&tp, type_list, !quiet);\n\t\tif (lp->ll_type == NULL && !quiet)\n\t\t    return NULL;\n\t\tlp->ll_name_end = tp;\n\n\t\t// drop the type when not in a script\n\t\tif (type_list == &tmp_type_list)\n\t\t{\n\t\t    lp->ll_type = NULL;\n\t\t    clear_type_list(type_list);\n\t\t}\n\t    }\n\t}\n    }\n    if (lp->ll_name == NULL)\n\treturn p;\n\n    if (*p == '.' && in_vim9script())\n    {\n\timported_T *import = find_imported(lp->ll_name, p - lp->ll_name,\n\t\t\t\t\t\t\t\t   TRUE, NULL);\n\n\tif (import != NULL)\n\t{\n\t    ufunc_T *ufunc;\n\t    type_T *type;\n\n\t    lp->ll_sid = import->imp_sid;\n\t    lp->ll_name = skipwhite(p + 1);\n\t    p = find_name_end(lp->ll_name, NULL, NULL, fne_flags);\n\t    lp->ll_name_end = p;\n\n\t    // check the item is exported\n\t    cc = *p;\n\t    *p = NUL;\n\t    if (find_exported(import->imp_sid, lp->ll_name, &ufunc, &type,\n\t\t\t\t\t\t\t     NULL, TRUE) == -1)\n\t    {\n\t\t*p = cc;\n\t\treturn NULL;\n\t    }\n\t    *p = cc;\n\t}\n    }\n\n    // Without [idx] or .key we are done.\n    if ((*p != '[' && *p != '.'))\n\treturn p;\n\n    if (in_vim9script() && lval_root != NULL)\n    {\n\t// using local variable\n\tlp->ll_tv = lval_root;\n\tv = NULL;\n    }\n    else\n    {\n\tcc = *p;\n\t*p = NUL;\n\t// When we would write to the variable pass &ht and prevent autoload.\n\twriting = !(flags & GLV_READ_ONLY);\n\tv = find_var(lp->ll_name, writing ? &ht : NULL,\n\t\t\t\t\t (flags & GLV_NO_AUTOLOAD) || writing);\n\tif (v == NULL && !quiet)\n\t    semsg(_(e_undefined_variable_str), lp->ll_name);\n\t*p = cc;\n\tif (v == NULL)\n\t    return NULL;\n\tlp->ll_tv = &v->di_tv;\n    }\n\n    if (in_vim9script() && (flags & GLV_NO_DECL) == 0)\n    {\n\tif (!quiet)\n\t    semsg(_(e_variable_already_declared), lp->ll_name);\n\treturn NULL;\n    }\n\n    /*\n     * Loop until no more [idx] or .key is following.\n     */\n    var1.v_type = VAR_UNKNOWN;\n    var2.v_type = VAR_UNKNOWN;\n    while (*p == '[' || (*p == '.' && p[1] != '=' && p[1] != '.'))\n    {\n\tif (*p == '.' && lp->ll_tv->v_type != VAR_DICT)\n\t{\n\t    if (!quiet)\n\t\tsemsg(_(e_dot_can_only_be_used_on_dictionary_str), name);\n\t    return NULL;\n\t}\n\tif (lp->ll_tv->v_type != VAR_LIST\n\t\t&& lp->ll_tv->v_type != VAR_DICT\n\t\t&& lp->ll_tv->v_type != VAR_BLOB)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_can_only_index_list_dictionary_or_blob));\n\t    return NULL;\n\t}\n\n\t// a NULL list/blob works like an empty list/blob, allocate one now.\n\tif (lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list == NULL)\n\t    rettv_list_alloc(lp->ll_tv);\n\telse if (lp->ll_tv->v_type == VAR_BLOB\n\t\t\t\t\t     && lp->ll_tv->vval.v_blob == NULL)\n\t    rettv_blob_alloc(lp->ll_tv);\n\n\tif (lp->ll_range)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_slice_must_come_last));\n\t    return NULL;\n\t}\n\n\tif (in_vim9script() && lp->ll_valtype == NULL\n\t\t&& v != NULL\n\t\t&& lp->ll_tv == &v->di_tv\n\t\t&& ht != NULL && ht == get_script_local_ht())\n\t{\n\t    svar_T  *sv = find_typval_in_script(lp->ll_tv, 0);\n\n\t    // Vim9 script local variable: get the type\n\t    if (sv != NULL)\n\t\tlp->ll_valtype = sv->sv_type;\n\t}\n\n\tlen = -1;\n\tif (*p == '.')\n\t{\n\t    key = p + 1;\n\t    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)\n\t\t;\n\t    if (len == 0)\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_cannot_use_empty_key_for_dictionary));\n\t\treturn NULL;\n\t    }\n\t    p = key + len;\n\t}\n\telse\n\t{\n\t    // Get the index [expr] or the first index [expr: ].\n\t    p = skipwhite(p + 1);\n\t    if (*p == ':')\n\t\tempty1 = TRUE;\n\t    else\n\t    {\n\t\tempty1 = FALSE;\n\t\tif (eval1(&p, &var1, &EVALARG_EVALUATE) == FAIL)  // recursive!\n\t\t    return NULL;\n\t\tif (tv_get_string_chk(&var1) == NULL)\n\t\t{\n\t\t    // not a number or string\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\n\t    // Optionally get the second index [ :expr].\n\t    if (*p == ':')\n\t    {\n\t\tif (lp->ll_tv->v_type == VAR_DICT)\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_cannot_slice_dictionary));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (rettv != NULL\n\t\t\t&& !(rettv->v_type == VAR_LIST\n\t\t\t\t\t\t && rettv->vval.v_list != NULL)\n\t\t\t&& !(rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t&& rettv->vval.v_blob != NULL))\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_slice_requires_list_or_blob_value));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p + 1);\n\t\tif (*p == ']')\n\t\t    lp->ll_empty2 = TRUE;\n\t\telse\n\t\t{\n\t\t    lp->ll_empty2 = FALSE;\n\t\t    // recursive!\n\t\t    if (eval1(&p, &var2, &EVALARG_EVALUATE) == FAIL)\n\t\t    {\n\t\t\tclear_tv(&var1);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (tv_get_string_chk(&var2) == NULL)\n\t\t    {\n\t\t\t// not a number or string\n\t\t\tclear_tv(&var1);\n\t\t\tclear_tv(&var2);\n\t\t\treturn NULL;\n\t\t    }\n\t\t}\n\t\tlp->ll_range = TRUE;\n\t    }\n\t    else\n\t\tlp->ll_range = FALSE;\n\n\t    if (*p != ']')\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_missing_closing_square_brace));\n\t\tclear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    // Skip to past ']'.\n\t    ++p;\n\t}\n\n\tif (lp->ll_tv->v_type == VAR_DICT)\n\t{\n\t    if (len == -1)\n\t    {\n\t\t// \"[key]\": get key from \"var1\"\n\t\tkey = tv_get_string_chk(&var1);\t// is number or string\n\t\tif (key == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t    lp->ll_list = NULL;\n\n\t    // a NULL dict is equivalent with an empty dict\n\t    if (lp->ll_tv->vval.v_dict == NULL)\n\t    {\n\t\tlp->ll_tv->vval.v_dict = dict_alloc();\n\t\tif (lp->ll_tv->vval.v_dict == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\t++lp->ll_tv->vval.v_dict->dv_refcount;\n\t    }\n\t    lp->ll_dict = lp->ll_tv->vval.v_dict;\n\n\t    lp->ll_di = dict_find(lp->ll_dict, key, len);\n\n\t    // When assigning to a scope dictionary check that a function and\n\t    // variable name is valid (only variable name unless it is l: or\n\t    // g: dictionary). Disallow overwriting a builtin function.\n\t    if (rettv != NULL && lp->ll_dict->dv_scope != 0)\n\t    {\n\t\tint prevval;\n\t\tint wrong;\n\n\t\tif (len != -1)\n\t\t{\n\t\t    prevval = key[len];\n\t\t    key[len] = NUL;\n\t\t}\n\t\telse\n\t\t    prevval = 0; // avoid compiler warning\n\t\twrong = (lp->ll_dict->dv_scope == VAR_DEF_SCOPE\n\t\t\t       && rettv->v_type == VAR_FUNC\n\t\t\t       && var_wrong_func_name(key, lp->ll_di == NULL))\n\t\t\t|| !valid_varname(key, -1, TRUE);\n\t\tif (len != -1)\n\t\t    key[len] = prevval;\n\t\tif (wrong)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    if (lp->ll_di == NULL)\n\t    {\n\t\t// Can't add \"v:\" or \"a:\" variable.\n\t\tif (lp->ll_dict == get_vimvar_dict()\n\t\t\t || &lp->ll_dict->dv_hashtab == get_funccal_args_ht())\n\t\t{\n\t\t    semsg(_(e_illegal_variable_name_str), name);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\n\t\t// Key does not exist in dict: may need to add it.\n\t\tif (*p == '[' || *p == '.' || unlet)\n\t\t{\n\t\t    if (!quiet)\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (len == -1)\n\t\t    lp->ll_newkey = vim_strsave(key);\n\t\telse\n\t\t    lp->ll_newkey = vim_strnsave(key, len);\n\t\tclear_tv(&var1);\n\t\tif (lp->ll_newkey == NULL)\n\t\t    p = NULL;\n\t\tbreak;\n\t    }\n\t    // existing variable, need to check if it can be changed\n\t    else if ((flags & GLV_READ_ONLY) == 0\n\t\t\t&& (var_check_ro(lp->ll_di->di_flags, name, FALSE)\n\t\t\t  || var_check_lock(lp->ll_di->di_flags, name, FALSE)))\n\t    {\n\t\tclear_tv(&var1);\n\t\treturn NULL;\n\t    }\n\n\t    clear_tv(&var1);\n\t    lp->ll_tv = &lp->ll_di->di_tv;\n\t}\n\telse if (lp->ll_tv->v_type == VAR_BLOB)\n\t{\n\t    long bloblen = blob_len(lp->ll_tv->vval.v_blob);\n\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    if (check_blob_index(bloblen, lp->ll_n1, quiet) == FAIL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\tclear_tv(&var2);\n\t\tif (check_blob_range(bloblen, lp->ll_n1, lp->ll_n2, quiet)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return NULL;\n\t    }\n\t    lp->ll_blob = lp->ll_tv->vval.v_blob;\n\t    lp->ll_tv = NULL;\n\t    break;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    lp->ll_dict = NULL;\n\t    lp->ll_list = lp->ll_tv->vval.v_list;\n\t    lp->ll_li = check_range_index_one(lp->ll_list, &lp->ll_n1, quiet);\n\t    if (lp->ll_li == NULL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    /*\n\t     * May need to find the item or absolute index for the second\n\t     * index of a range.\n\t     * When no index given: \"lp->ll_empty2\" is TRUE.\n\t     * Otherwise \"lp->ll_n2\" is set to the second index.\n\t     */\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\t\t\t\t\t    // is number or string\n\t\tclear_tv(&var2);\n\t\tif (check_range_index_two(lp->ll_list,\n\t\t\t\t\t    &lp->ll_n1, lp->ll_li,\n\t\t\t\t\t    &lp->ll_n2, quiet) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    lp->ll_tv = &lp->ll_li->li_tv;\n\t}\n    }\n\n    clear_tv(&var1);\n    lp->ll_name_end = p;\n    return p;\n}\n\n/*\n * Clear lval \"lp\" that was filled by get_lval().\n */\n    void\nclear_lval(lval_T *lp)\n{\n    vim_free(lp->ll_exp_name);\n    vim_free(lp->ll_newkey);\n}\n\n/*\n * Set a variable that was parsed by get_lval() to \"rettv\".\n * \"endp\" points to just after the parsed name.\n * \"op\" is NULL, \"+\" for \"+=\", \"-\" for \"-=\", \"*\" for \"*=\", \"/\" for \"/=\",\n * \"%\" for \"%=\", \".\" for \".=\" or \"=\" for \"=\".\n */\n    void\nset_var_lval(\n    lval_T\t*lp,\n    char_u\t*endp,\n    typval_T\t*rettv,\n    int\t\tcopy,\n    int\t\tflags,\t    // ASSIGN_CONST, ASSIGN_NO_DECL\n    char_u\t*op,\n    int\t\tvar_idx)    // index for \"let [a, b] = list\"\n{\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *endp;\n\t*endp = NUL;\n\tif (in_vim9script() && check_reserved_name(lp->ll_name) == FAIL)\n\t    return;\n\n\tif (lp->ll_blob != NULL)\n\t{\n\t    int\t    error = FALSE, val;\n\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\treturn;\n\t    }\n\t    if (value_check_lock(lp->ll_blob->bv_lock, lp->ll_name, FALSE))\n\t\treturn;\n\n\t    if (lp->ll_range && rettv->v_type == VAR_BLOB)\n\t    {\n\t\tif (lp->ll_empty2)\n\t\t    lp->ll_n2 = blob_len(lp->ll_blob) - 1;\n\n\t\tif (blob_set_range(lp->ll_blob, lp->ll_n1, lp->ll_n2,\n\t\t\t\t\t\t\t\trettv) == FAIL)\n\t\t    return;\n\t    }\n\t    else\n\t    {\n\t\tval = (int)tv_get_number_chk(rettv, &error);\n\t\tif (!error)\n\t\t    blob_set_append(lp->ll_blob, lp->ll_n1, val);\n\t    }\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    typval_T tv;\n\n\t    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t    {\n\t\temsg(_(e_cannot_modify_existing_variable));\n\t\t*endp = cc;\n\t\treturn;\n\t    }\n\n\t    // handle +=, -=, *=, /=, %= and .=\n\t    di = NULL;\n\t    if (eval_variable(lp->ll_name, (int)STRLEN(lp->ll_name),\n\t\t\t\t lp->ll_sid, &tv, &di, EVAL_VAR_VERBOSE) == OK)\n\t    {\n\t\tif ((di == NULL\n\t\t\t || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)\n\t\t\t   && !tv_check_lock(&di->di_tv, lp->ll_name, FALSE)))\n\t\t\t&& tv_op(&tv, rettv, op) == OK)\n\t\t    set_var_const(lp->ll_name, lp->ll_sid, NULL, &tv, FALSE,\n\t\t\t\t\t\t\t    ASSIGN_NO_DECL, 0);\n\t\tclear_tv(&tv);\n\t    }\n\t}\n\telse\n\t{\n\t    if (lp->ll_type != NULL && check_typval_arg_type(lp->ll_type, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t\treturn;\n\t    set_var_const(lp->ll_name, lp->ll_sid, lp->ll_type, rettv, copy,\n\t\t\t\t\t\t\t       flags, var_idx);\n\t}\n\t*endp = cc;\n    }\n    else if (value_check_lock(lp->ll_newkey == NULL\n\t\t? lp->ll_tv->v_lock\n\t\t: lp->ll_tv->vval.v_dict->dv_lock, lp->ll_name, FALSE))\n\t;\n    else if (lp->ll_range)\n    {\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_range));\n\t    return;\n\t}\n\n\t(void)list_assign_range(lp->ll_list, rettv->vval.v_list,\n\t\t\t lp->ll_n1, lp->ll_n2, lp->ll_empty2, op, lp->ll_name);\n    }\n    else\n    {\n\t/*\n\t * Assign to a List or Dictionary item.\n\t */\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_list_or_dict));\n\t    return;\n\t}\n\n\tif (lp->ll_valtype != NULL\n\t\t    && check_typval_arg_type(lp->ll_valtype, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t    return;\n\n\tif (lp->ll_newkey != NULL)\n\t{\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_key_not_present_in_dictionary), lp->ll_newkey);\n\t\treturn;\n\t    }\n\t    if (dict_wrong_func_name(lp->ll_tv->vval.v_dict, rettv,\n\t\t\t\t\t\t\t\tlp->ll_newkey))\n\t\treturn;\n\n\t    // Need to add an item to the Dictionary.\n\t    di = dictitem_alloc(lp->ll_newkey);\n\t    if (di == NULL)\n\t\treturn;\n\t    if (dict_add(lp->ll_tv->vval.v_dict, di) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\treturn;\n\t    }\n\t    lp->ll_tv = &di->di_tv;\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    tv_op(lp->ll_tv, rettv, op);\n\t    return;\n\t}\n\telse\n\t    clear_tv(lp->ll_tv);\n\n\t/*\n\t * Assign the value to the variable or list item.\n\t */\n\tif (copy)\n\t    copy_tv(rettv, lp->ll_tv);\n\telse\n\t{\n\t    *lp->ll_tv = *rettv;\n\t    lp->ll_tv->v_lock = 0;\n\t    init_tv(rettv);\n\t}\n    }\n}\n\n/*\n * Handle \"tv1 += tv2\", \"tv1 -= tv2\", \"tv1 *= tv2\", \"tv1 /= tv2\", \"tv1 %= tv2\"\n * and \"tv1 .= tv2\"\n * Returns OK or FAIL.\n */\n    int\ntv_op(typval_T *tv1, typval_T *tv2, char_u *op)\n{\n    varnumber_T\tn;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*s;\n    int\t\tfailed = FALSE;\n\n    // Can't do anything with a Funcref or Dict on the right.\n    // v:true and friends only work with \"..=\".\n    if (tv2->v_type != VAR_FUNC && tv2->v_type != VAR_DICT\n\t\t    && ((tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)\n\t\t\t\t\t\t\t\t|| *op == '.'))\n    {\n\tswitch (tv1->v_type)\n\t{\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t    case VAR_DICT:\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\n\t    case VAR_BLOB:\n\t\tif (*op != '+' || tv2->v_type != VAR_BLOB)\n\t\t    break;\n\t\t// BLOB += BLOB\n\t\tif (tv1->vval.v_blob != NULL && tv2->vval.v_blob != NULL)\n\t\t{\n\t\t    blob_T  *b1 = tv1->vval.v_blob;\n\t\t    blob_T  *b2 = tv2->vval.v_blob;\n\t\t    int\ti, len = blob_len(b2);\n\t\t    for (i = 0; i < len; i++)\n\t\t\tga_append(&b1->bv_ga, blob_get(b2, i));\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_LIST:\n\t\tif (*op != '+' || tv2->v_type != VAR_LIST)\n\t\t    break;\n\t\t// List += List\n\t\tif (tv2->vval.v_list != NULL)\n\t\t{\n\t\t    if (tv1->vval.v_list == NULL)\n\t\t    {\n\t\t\ttv1->vval.v_list = tv2->vval.v_list;\n\t\t\t++tv1->vval.v_list->lv_refcount;\n\t\t    }\n\t\t    else\n\t\t\tlist_extend(tv1->vval.v_list, tv2->vval.v_list, NULL);\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_NUMBER:\n\t    case VAR_STRING:\n\t\tif (tv2->v_type == VAR_LIST)\n\t\t    break;\n\t\tif (vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t\t{\n\t\t    // nr += nr , nr -= nr , nr *=nr , nr /= nr , nr %= nr\n\t\t    n = tv_get_number(tv1);\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tfloat_T f = n;\n\n\t\t\tif (*op == '%')\n\t\t\t    break;\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': f += tv2->vval.v_float; break;\n\t\t\t    case '-': f -= tv2->vval.v_float; break;\n\t\t\t    case '*': f *= tv2->vval.v_float; break;\n\t\t\t    case '/': f /= tv2->vval.v_float; break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': n += tv_get_number(tv2); break;\n\t\t\t    case '-': n -= tv_get_number(tv2); break;\n\t\t\t    case '*': n *= tv_get_number(tv2); break;\n\t\t\t    case '/': n = num_divide(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t    case '%': n = num_modulus(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tbreak;\n\n\t\t    // str .= str\n\t\t    s = tv_get_string(tv1);\n\t\t    s = concat_str(s, tv_get_string_buf(tv2, numbuf));\n\t\t    clear_tv(tv1);\n\t\t    tv1->v_type = VAR_STRING;\n\t\t    tv1->vval.v_string = s;\n\t\t}\n\t\treturn failed ? FAIL : OK;\n\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    float_T f;\n\n\t\t    if (*op == '%' || *op == '.'\n\t\t\t\t   || (tv2->v_type != VAR_FLOAT\n\t\t\t\t    && tv2->v_type != VAR_NUMBER\n\t\t\t\t    && tv2->v_type != VAR_STRING))\n\t\t\tbreak;\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tf = tv2->vval.v_float;\n\t\t    else\n\t\t\tf = tv_get_number(tv2);\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': tv1->vval.v_float += f; break;\n\t\t\tcase '-': tv1->vval.v_float -= f; break;\n\t\t\tcase '*': tv1->vval.v_float *= f; break;\n\t\t\tcase '/': tv1->vval.v_float /= f; break;\n\t\t    }\n\t\t}\n#endif\n\t\treturn OK;\n\t}\n    }\n\n    semsg(_(e_wrong_variable_type_for_str_equal), op);\n    return FAIL;\n}\n\n/*\n * Evaluate the expression used in a \":for var in expr\" command.\n * \"arg\" points to \"var\".\n * Set \"*errp\" to TRUE for an error, FALSE otherwise;\n * Return a pointer that holds the info.  Null when there is an error.\n */\n    void *\neval_for_line(\n    char_u\t*arg,\n    int\t\t*errp,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    forinfo_T\t*fi;\n    char_u\t*var_list_end;\n    char_u\t*expr;\n    typval_T\ttv;\n    list_T\t*l;\n    int\t\tskip = !(evalarg->eval_flags & EVAL_EVALUATE);\n\n    *errp = TRUE;\t// default: there is an error\n\n    fi = ALLOC_CLEAR_ONE(forinfo_T);\n    if (fi == NULL)\n\treturn NULL;\n\n    var_list_end = skip_var_list(arg, TRUE, &fi->fi_varcount,\n\t\t\t\t\t\t     &fi->fi_semicolon, FALSE);\n    if (var_list_end == NULL)\n\treturn fi;\n\n    expr = skipwhite_and_linebreak(var_list_end, evalarg);\n    if (expr[0] != 'i' || expr[1] != 'n'\n\t\t\t\t  || !(expr[2] == NUL || VIM_ISWHITE(expr[2])))\n    {\n\tif (in_vim9script() && *expr == ':' && expr != var_list_end)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), expr);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn fi;\n    }\n\n    if (skip)\n\t++emsg_skip;\n    expr = skipwhite_and_linebreak(expr + 2, evalarg);\n    if (eval0(expr, &tv, eap, evalarg) == OK)\n    {\n\t*errp = FALSE;\n\tif (!skip)\n\t{\n\t    if (tv.v_type == VAR_LIST)\n\t    {\n\t\tl = tv.vval.v_list;\n\t\tif (l == NULL)\n\t\t{\n\t\t    // a null list is like an empty list: do nothing\n\t\t    clear_tv(&tv);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Need a real list here.\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\n\t\t    // No need to increment the refcount, it's already set for\n\t\t    // the list being used in \"tv\".\n\t\t    fi->fi_list = l;\n\t\t    list_add_watch(l, &fi->fi_lw);\n\t\t    fi->fi_lw.lw_item = l->lv_first;\n\t\t}\n\t    }\n\t    else if (tv.v_type == VAR_BLOB)\n\t    {\n\t\tfi->fi_bi = 0;\n\t\tif (tv.vval.v_blob != NULL)\n\t\t{\n\t\t    typval_T btv;\n\n\t\t    // Make a copy, so that the iteration still works when the\n\t\t    // blob is changed.\n\t\t    blob_copy(tv.vval.v_blob, &btv);\n\t\t    fi->fi_blob = btv.vval.v_blob;\n\t\t}\n\t\tclear_tv(&tv);\n\t    }\n\t    else if (tv.v_type == VAR_STRING)\n\t    {\n\t\tfi->fi_byte_idx = 0;\n\t\tfi->fi_string = tv.vval.v_string;\n\t\ttv.vval.v_string = NULL;\n\t\tif (fi->fi_string == NULL)\n\t\t    fi->fi_string = vim_strsave((char_u *)\"\");\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_list_or_blob_required));\n\t\tclear_tv(&tv);\n\t    }\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    fi->fi_break_count = evalarg->eval_break_count;\n\n    return fi;\n}\n\n/*\n * Used when looping over a :for line, skip the \"in expr\" part.\n */\n    void\nskip_for_lines(void *fi_void, evalarg_T *evalarg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\ti;\n\n    for (i = 0; i < fi->fi_break_count; ++i)\n\teval_next_line(evalarg);\n}\n\n/*\n * Use the first item in a \":for\" list.  Advance to the next.\n * Assign the values to the variable (list).  \"arg\" points to the first one.\n * Return TRUE when a valid item was found, FALSE when at end of list or\n * something wrong.\n */\n    int\nnext_for_item(void *fi_void, char_u *arg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\tresult;\n    int\t\tflag = ASSIGN_FOR_LOOP | (in_vim9script()\n\t\t\t ? (ASSIGN_FINAL\n\t\t\t     // first round: error if variable exists\n\t\t\t     | (fi->fi_bi == 0 ? 0 : ASSIGN_DECL)\n\t\t\t     | ASSIGN_NO_MEMBER_TYPE)\n\t\t\t : 0);\n    listitem_T\t*item;\n    int\t\tskip_assign = in_vim9script() && arg[0] == '_'\n\t\t\t\t\t\t      && !eval_isnamec(arg[1]);\n\n    if (fi->fi_blob != NULL)\n    {\n\ttypval_T\ttv;\n\n\tif (fi->fi_bi >= blob_len(fi->fi_blob))\n\t    return FALSE;\n\ttv.v_type = VAR_NUMBER;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_number = blob_get(fi->fi_blob, fi->fi_bi);\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    return TRUE;\n\treturn ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n    }\n\n    if (fi->fi_string != NULL)\n    {\n\ttypval_T\ttv;\n\tint\t\tlen;\n\n\tlen = mb_ptr2len(fi->fi_string + fi->fi_byte_idx);\n\tif (len == 0)\n\t    return FALSE;\n\ttv.v_type = VAR_STRING;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_string = vim_strnsave(fi->fi_string + fi->fi_byte_idx, len);\n\tfi->fi_byte_idx += len;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n\tvim_free(tv.vval.v_string);\n\treturn result;\n    }\n\n    item = fi->fi_lw.lw_item;\n    if (item == NULL)\n\tresult = FALSE;\n    else\n    {\n\tfi->fi_lw.lw_item = item->li_next;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = (ex_let_vars(arg, &item->li_tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t   fi->fi_varcount, flag, NULL) == OK);\n    }\n    return result;\n}\n\n/*\n * Free the structure used to store info used by \":for\".\n */\n    void\nfree_for_info(void *fi_void)\n{\n    forinfo_T    *fi = (forinfo_T *)fi_void;\n\n    if (fi == NULL)\n\treturn;\n    if (fi->fi_list != NULL)\n    {\n\tlist_rem_watch(fi->fi_list, &fi->fi_lw);\n\tlist_unref(fi->fi_list);\n    }\n    else if (fi->fi_blob != NULL)\n\tblob_unref(fi->fi_blob);\n    else\n\tvim_free(fi->fi_string);\n    vim_free(fi);\n}\n\n    void\nset_context_for_expression(\n    expand_T\t*xp,\n    char_u\t*arg,\n    cmdidx_T\tcmdidx)\n{\n    int\t\thas_expr = cmdidx != CMD_let && cmdidx != CMD_var;\n    int\t\tc;\n    char_u\t*p;\n\n    if (cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_const || cmdidx == CMD_final)\n    {\n\txp->xp_context = EXPAND_USER_VARS;\n\tif (vim_strpbrk(arg, (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\") == NULL)\n\t{\n\t    // \":let var1 var2 ...\": find last space.\n\t    for (p = arg + STRLEN(arg); p >= arg; )\n\t    {\n\t\txp->xp_pattern = p;\n\t\tMB_PTR_BACK(arg, p);\n\t\tif (VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    return;\n\t}\n    }\n    else\n\txp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS\n\t\t\t\t\t\t\t  : EXPAND_EXPRESSION;\n    while ((xp->xp_pattern = vim_strpbrk(arg,\n\t\t\t\t  (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL)\n    {\n\tc = *xp->xp_pattern;\n\tif (c == '&')\n\t{\n\t    c = xp->xp_pattern[1];\n\t    if (c == '&')\n\t    {\n\t\t++xp->xp_pattern;\n\t\txp->xp_context = has_expr ? EXPAND_EXPRESSION : EXPAND_NOTHING;\n\t    }\n\t    else if (c != ' ')\n\t    {\n\t\txp->xp_context = EXPAND_SETTINGS;\n\t\tif ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')\n\t\t    xp->xp_pattern += 2;\n\n\t    }\n\t}\n\telse if (c == '$')\n\t{\n\t    // environment variable\n\t    xp->xp_context = EXPAND_ENV_VARS;\n\t}\n\telse if (c == '=')\n\t{\n\t    has_expr = TRUE;\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse if (c == '#'\n\t\t&& xp->xp_context == EXPAND_EXPRESSION)\n\t{\n\t    // Autoload function/variable contains '#'.\n\t    break;\n\t}\n\telse if ((c == '<' || c == '#')\n\t\t&& xp->xp_context == EXPAND_FUNCTIONS\n\t\t&& vim_strchr(xp->xp_pattern, '(') == NULL)\n\t{\n\t    // Function name can start with \"<SNR>\" and contain '#'.\n\t    break;\n\t}\n\telse if (has_expr)\n\t{\n\t    if (c == '\"')\t    // string\n\t    {\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\"')\n\t\t    if (c == '\\\\' && xp->xp_pattern[1] != NUL)\n\t\t\t++xp->xp_pattern;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '\\'')\t    // literal string\n\t    {\n\t\t// Trick: '' is like stopping and starting a literal string.\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\\'')\n\t\t    /* skip */ ;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '|')\n\t    {\n\t\tif (xp->xp_pattern[1] == '|')\n\t\t{\n\t\t    ++xp->xp_pattern;\n\t\t    xp->xp_context = EXPAND_EXPRESSION;\n\t\t}\n\t\telse\n\t\t    xp->xp_context = EXPAND_COMMANDS;\n\t    }\n\t    else\n\t\txp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse\n\t    // Doesn't look like something valid, expand as an expression\n\t    // anyway.\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\targ = xp->xp_pattern;\n\tif (*arg != NUL)\n\t    while ((c = *++arg) != NUL && (c == ' ' || c == '\\t'))\n\t\t/* skip */ ;\n    }\n\n    // \":exe one two\" completes \"two\"\n    if ((cmdidx == CMD_execute\n\t\t|| cmdidx == CMD_echo\n\t\t|| cmdidx == CMD_echon\n\t\t|| cmdidx == CMD_echomsg)\n\t    && xp->xp_context == EXPAND_EXPRESSION)\n    {\n\tfor (;;)\n\t{\n\t    char_u *n = skiptowhite(arg);\n\n\t    if (n == arg || IS_WHITE_OR_NUL(*skipwhite(n)))\n\t\tbreak;\n\t    arg = skipwhite(n);\n\t}\n    }\n\n    xp->xp_pattern = arg;\n}\n\n/*\n * Return TRUE if \"pat\" matches \"text\".\n * Does not use 'cpo' and always uses 'magic'.\n */\n    int\npattern_match(char_u *pat, char_u *text, int ic)\n{\n    int\t\tmatches = FALSE;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n\n    // avoid 'l' flag in 'cpoptions'\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = ic;\n\tmatches = vim_regexec_nl(&regmatch, text, (colnr_T)0);\n\tvim_regfree(regmatch.regprog);\n    }\n    p_cpo = save_cpo;\n    return matches;\n}\n\n/*\n * Handle a name followed by \"(\".  Both for just \"name(arg)\" and for\n * \"expr->name(arg)\".\n * Returns OK or FAIL.\n */\n    static int\neval_func(\n\tchar_u\t    **arg,\t// points to \"(\", will be advanced\n\tevalarg_T   *evalarg,\n\tchar_u\t    *name,\n\tint\t    name_len,\n\ttypval_T    *rettv,\n\tint\t    flags,\n\ttypval_T    *basetv)\t// \"expr\" for \"expr->name(arg)\"\n{\n    int\t\tevaluate = flags & EVAL_EVALUATE;\n    char_u\t*s = name;\n    int\t\tlen = name_len;\n    partial_T\t*partial;\n    int\t\tret = OK;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    if (!evaluate)\n\tcheck_vars(s, len);\n\n    // If \"s\" is the name of a variable of type VAR_FUNC\n    // use its contents.\n    s = deref_func_name(s, &len, &partial,\n\t\t in_vim9script() ? &type : NULL, !evaluate, FALSE, &found_var);\n\n    // Need to make a copy, in case evaluating the arguments makes\n    // the name invalid.\n    s = vim_strsave(s);\n    if (s == NULL || (evaluate && (*s == NUL || (flags & EVAL_CONSTANT))))\n\tret = FAIL;\n    else\n    {\n\tfuncexe_T funcexe;\n\n\t// Invoke the function.\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = evaluate;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_basetv = basetv;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\tret = get_func_tv(s, len, rettv, arg, evalarg, &funcexe);\n    }\n    vim_free(s);\n\n    // If evaluate is FALSE rettv->v_type was not set in\n    // get_func_tv, but it's needed in handle_subscript() to parse\n    // what follows. So set it here.\n    if (rettv->v_type == VAR_UNKNOWN && !evaluate && **arg == '(')\n    {\n\trettv->vval.v_string = NULL;\n\trettv->v_type = VAR_FUNC;\n    }\n\n    // Stop the expression evaluation when immediately\n    // aborting on error, or when an interrupt occurred or\n    // an exception was thrown but not caught.\n    if (evaluate && aborting())\n    {\n\tif (ret == OK)\n\t    clear_tv(rettv);\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * Get the next line source line without advancing.  But do skip over comment\n * lines.\n * Only called for Vim9 script.\n */\n    static char_u *\ngetline_peek_skip_comments(evalarg_T *evalarg)\n{\n    for (;;)\n    {\n\tchar_u *next = getline_peek(evalarg->eval_getline,\n\t\t\t\t\t\t\t evalarg->eval_cookie);\n\tchar_u *p;\n\n\tif (next == NULL)\n\t    break;\n\tp = skipwhite(next);\n\tif (*p != NUL && !vim9_comment_start(p))\n\t    return next;\n\t(void)eval_next_line(evalarg);\n    }\n    return NULL;\n}\n\n/*\n * If inside Vim9 script, \"arg\" points to the end of a line (ignoring a #\n * comment) and there is a next line, return the next line (skipping blanks)\n * and set \"getnext\".\n * Otherwise return the next non-white at or after \"arg\" and set \"getnext\" to\n * FALSE.\n * \"arg\" must point somewhere inside a line, not at the start.\n */\n    char_u *\neval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL)\n\t    && (*p == NUL || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}\n\n/*\n * To be called after eval_next_non_blank() sets \"getnext\" to TRUE.\n * Only called for Vim9 script.\n */\n    char_u *\neval_next_line(evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tvim_free(evalarg->eval_tofree);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}\n\n/*\n * Call eval_next_non_blank() and get the next line if needed.\n */\n    char_u *\nskipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg)\n{\n    int\t    getnext;\n    char_u  *p = skipwhite_and_nl(arg);\n\n    if (evalarg == NULL)\n\treturn skipwhite(arg);\n    eval_next_non_blank(p, evalarg, &getnext);\n    if (getnext)\n\treturn eval_next_line(evalarg);\n    return p;\n}\n\n/*\n * Initialize \"evalarg\" for use.\n */\n    void\ninit_evalarg(evalarg_T *evalarg)\n{\n    CLEAR_POINTER(evalarg);\n    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n}\n\n/*\n * After using \"evalarg\" filled from \"eap\": free the memory.\n */\n    void\nclear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\t// We may need to keep the original command line, e.g. for\n\t\t// \":let\" it has the variable names.  But we may also need the\n\t\t// new one, \"nextcmd\" points into it.  Keep both.\n\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}\n\n/*\n * The \"evaluate\" argument: When FALSE, the argument is only parsed but not\n * executed.  The function may return OK, but the rettv will be of type\n * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.\n */\n\n/*\n * Handle zero level expression.\n * This calls eval1() and handles error message and nextcmd.\n * Put the result in \"rettv\" when returning OK and \"evaluate\" is TRUE.\n * Note: \"rettv.v_lock\" is not set.\n * \"evalarg\" can be NULL, EVALARG_EVALUATE or a pointer.\n * Return OK or FAIL.\n */\n    int\neval0(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    return eval0_retarg(arg, rettv, eap, evalarg, NULL);\n}\n\n/*\n * Like eval0() but when \"retarg\" is not NULL store the pointer to after the\n * expression and don't check what comes after the expression.\n */\n    int\neval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n\n    // In Vim9 script a command block is not split at NL characters for\n    // commands using an expression argument.  Skip over a '#' comment to check\n    // for a following NL.  Require white space before the '#'.\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}\n\n/*\n * Handle top level expression:\n *\texpr2 ? expr1 : expr1\n *\texpr2 ?? expr1\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Note: \"rettv.v_lock\" is not set.\n *\n * Return OK or FAIL.\n */\n    int\neval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u  *p;\n    int\t    getnext;\n\n    CLEAR_POINTER(rettv);\n\n    /*\n     * Get the first variable.\n     */\n    if (eval2(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tint\t\tresult;\n\ttypval_T\tvar2;\n\tevalarg_T\t*evalarg_used = evalarg;\n\tevalarg_T\tlocal_evalarg;\n\tint\t\torig_flags;\n\tint\t\tevaluate;\n\tint\t\tvim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = evalarg_used->eval_flags & EVAL_EVALUATE;\n\n\tif (getnext)\n\t    *arg = eval_next_line(evalarg_used);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t    {\n\t\terror_white_both(p, op_falsy ? 2 : 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n\tresult = FALSE;\n\tif (evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    if (op_falsy)\n\t\tresult = tv2bool(rettv);\n\t    else if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    if (error || !op_falsy || !result)\n\t\tclear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.  Recursive!\n\t */\n\tif (op_falsy)\n\t    ++*arg;\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg - (op_falsy ? 1 : 0), op_falsy ? 2 : 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\tevalarg_used->eval_flags = (op_falsy ? !result : result)\n\t\t\t\t    ? orig_flags : orig_flags & ~EVAL_EVALUATE;\n\tif (eval1(arg, &var2, evalarg_used) == FAIL)\n\t{\n\t    evalarg_used->eval_flags = orig_flags;\n\t    return FAIL;\n\t}\n\tif (!op_falsy || !result)\n\t    *rettv = var2;\n\n\tif (!op_falsy)\n\t{\n\t    /*\n\t     * Check for the \":\".\n\t     */\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (getnext)\n\t\t*arg = eval_next_line(evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 1);\n\t\t    clear_tv(rettv);\n\t\t    evalarg_used->eval_flags = orig_flags;\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the third variable.  Recursive!\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval1(arg, &var2, evalarg_used) == FAIL)\n\t    {\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (evaluate && !result)\n\t\t*rettv = var2;\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle first level expression:\n *\texpr2 || expr2 || expr2\t    logical OR\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first variable.\n     */\n    if (eval3(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the  \"||\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '|' && p[1] == '|')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    evaluate;\n\tint\t    orig_flags;\n\tlong\t    result = FALSE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"||\".\n\t */\n\twhile (p[0] == '|' && p[1] == '|')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && in_vim9script() && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval3(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && !result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) != 0)\n\t\t    result = TRUE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle second level expression:\n *\texpr3 && expr3 && expr3\t    logical AND\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first variable.\n     */\n    if (eval4(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the \"&&\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '&' && p[1] == '&')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    orig_flags;\n\tint\t    evaluate;\n\tlong\t    result = TRUE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) == 0)\n\t\tresult = FALSE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"&&\".\n\t */\n\twhile (p[0] == '&' && p[1] == '&')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    CLEAR_FIELD(var2);\n\t    if (eval4(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) == 0)\n\t\t    result = FALSE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle third level expression:\n *\tvar1 == var2\n *\tvar1 =~ var2\n *\tvar1 != var2\n *\tvar1 !~ var2\n *\tvar1 > var2\n *\tvar1 >= var2\n *\tvar1 < var2\n *\tvar1 <= var2\n *\tvar1 is var2\n *\tvar1 isnot var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n\n    /*\n     * Get the first variable.\n     */\n    if (eval5(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\ttypval_T    var2;\n\tint\t    ic;\n\tint\t    vim9script = in_vim9script();\n\tint\t    evaluate = evalarg == NULL\n\t\t\t\t   ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (vim9script && type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), p);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case\n\telse if (p[len] == '#')\n\t{\n\t    ic = FALSE;\n\t    ++len;\n\t}\n\t// nothing appended: use 'ignorecase' if not in Vim script\n\telse\n\t    ic = vim9script ? FALSE : p_ic;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + len, evalarg);\n\tif (eval5(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (evaluate)\n\t{\n\t    int ret;\n\n\t    if (vim9script && check_compare_types(type, rettv, &var2) == FAIL)\n\t    {\n\t\tret = FAIL;\n\t\tclear_tv(rettv);\n\t    }\n\t    else\n\t\tret = typval_compare(rettv, &var2, type, ic);\n\t    clear_tv(&var2);\n\t    return ret;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Make a copy of blob \"tv1\" and append blob \"tv2\".\n */\n    void\neval_addblob(typval_T *tv1, typval_T *tv2)\n{\n    blob_T  *b1 = tv1->vval.v_blob;\n    blob_T  *b2 = tv2->vval.v_blob;\n    blob_T  *b = blob_alloc();\n    int\t    i;\n\n    if (b != NULL)\n    {\n\tfor (i = 0; i < blob_len(b1); i++)\n\t    ga_append(&b->bv_ga, blob_get(b1, i));\n\tfor (i = 0; i < blob_len(b2); i++)\n\t    ga_append(&b->bv_ga, blob_get(b2, i));\n\n\tclear_tv(tv1);\n\trettv_blob_set(tv1, b);\n    }\n}\n\n/*\n * Make a copy of list \"tv1\" and append list \"tv2\".\n */\n    int\neval_addlist(typval_T *tv1, typval_T *tv2)\n{\n    typval_T var3;\n\n    // concatenate Lists\n    if (list_concat(tv1->vval.v_list, tv2->vval.v_list, &var3) == FAIL)\n    {\n\tclear_tv(tv1);\n\tclear_tv(tv2);\n\treturn FAIL;\n    }\n    clear_tv(tv1);\n    *tv1 = var3;\n    return OK;\n}\n\n/*\n * Handle fourth level expression:\n *\t+\tnumber addition\n *\t-\tnumber subtraction\n *\t.\tstring concatenation (if script version is 1)\n *\t..\tstring concatenation\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first variable.\n     */\n    if (eval6(arg, rettv, evalarg, FALSE) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '+', '-' or '.' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\tchar_u\t    *p;\n\tint\t    op;\n\tint\t    oplen;\n\tint\t    concat;\n\ttypval_T    var2;\n\tint\t    vim9script = in_vim9script();\n\n\t// \".\" is only string concatenation when scriptversion is 1\n\t// \"+=\", \"-=\" and \"..=\" are assignments\n\t// \"++\" and \"--\" on the next line are a separate command.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tconcat = op == '.' && (*(p + 1) == '.' || in_old_script(2));\n\tif ((op != '+' && op != '-' && !concat) || p[1] == '='\n\t\t\t\t\t       || (p[1] == '.' && p[2] == '='))\n\t    break;\n\tif (getnext && (op == '+' || op == '-') && p[0] == p[1])\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\toplen = (concat && p[1] == '.') ? 2 : 1;\n\tif (getnext)\n\t    *arg = eval_next_line(evalarg);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, oplen);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\tif ((op != '+' || (rettv->v_type != VAR_LIST\n\t\t\t\t\t\t && rettv->v_type != VAR_BLOB))\n#ifdef FEAT_FLOAT\n\t\t&& (op == '.' || rettv->v_type != VAR_FLOAT)\n#endif\n\t\t&& evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    // For \"list + ...\", an illegal use of the first operand as\n\t    // a number cannot be determined before evaluating the 2nd\n\t    // operand: if this is also a list, all is ok.\n\t    // For \"something . ...\", \"something - ...\" or \"non-list + ...\",\n\t    // we know that the first operand needs to be a string or number\n\t    // without evaluating the 2nd operand.  So check before to avoid\n\t    // side effects after an error.\n\t    if (op != '.')\n\t\ttv_get_number_chk(rettv, &error);\n\t    if ((op == '.' && tv_get_string_chk(rettv) == NULL) || error)\n\t    {\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[oplen]))\n\t{\n\t    error_white_both(*arg, oplen);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + oplen, evalarg);\n\tif (eval6(arg, &var2, evalarg, !vim9script && op == '.') == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (op == '.')\n\t    {\n\t\tchar_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\t\tchar_u\t*s1 = tv_get_string_buf(rettv, buf1);\n\t\tchar_u\t*s2 = NULL;\n\n\t\tif (vim9script && (var2.v_type == VAR_VOID\n\t\t\t|| var2.v_type == VAR_CHANNEL\n\t\t\t|| var2.v_type == VAR_JOB))\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t   vartype_name(var2.v_type));\n#ifdef FEAT_FLOAT\n\t\telse if (vim9script && var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%g\",\n\t\t\t\t\t\t\t    var2.vval.v_float);\n\t\t    s2 = buf2;\n\t\t}\n#endif\n\t\telse\n\t\t    s2 = tv_get_string_buf_chk(&var2, buf2);\n\t\tif (s2 == NULL)\t\t// type error ?\n\t\t{\n\t\t    clear_tv(rettv);\n\t\t    clear_tv(&var2);\n\t\t    return FAIL;\n\t\t}\n\t\tp = concat_str(s1, s2);\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = p;\n\t    }\n\t    else if (op == '+' && rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t   && var2.v_type == VAR_BLOB)\n\t\teval_addblob(rettv, &var2);\n\t    else if (op == '+' && rettv->v_type == VAR_LIST\n\t\t\t\t\t\t   && var2.v_type == VAR_LIST)\n\t    {\n\t\tif (eval_addlist(rettv, &var2) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tint\t\terror = FALSE;\n\t\tvarnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\tfloat_T\t    f1 = 0, f2 = 0;\n\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    f1 = rettv->vval.v_float;\n\t\t    n1 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n1 = tv_get_number_chk(rettv, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\t// This can only happen for \"list + non-list\" or\n\t\t\t// \"blob + non-blob\".  For \"non-list + ...\" or\n\t\t\t// \"something - ...\", we returned before evaluating the\n\t\t\t// 2nd operand.\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (var2.v_type == VAR_FLOAT)\n\t\t\tf1 = n1;\n#endif\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    f2 = var2.vval.v_float;\n\t\t    n2 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n2 = tv_get_number_chk(&var2, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (rettv->v_type == VAR_FLOAT)\n\t\t\tf2 = n2;\n#endif\n\t\t}\n\t\tclear_tv(rettv);\n\n#ifdef FEAT_FLOAT\n\t\t// If there is a float on either side the result is a float.\n\t\tif (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (op == '+')\n\t\t\tf1 = f1 + f2;\n\t\t    else\n\t\t\tf1 = f1 - f2;\n\t\t    rettv->v_type = VAR_FLOAT;\n\t\t    rettv->vval.v_float = f1;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (op == '+')\n\t\t\tn1 = n1 + n2;\n\t\t    else\n\t\t\tn1 = n1 - n2;\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = n1;\n\t\t}\n\t    }\n\t    clear_tv(&var2);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle fifth level expression:\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval6(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)  // after \".\" operator\n{\n#ifdef FEAT_FLOAT\n    int\t    use_float = FALSE;\n#endif\n\n    /*\n     * Get the first variable.\n     */\n    if (eval7t(arg, rettv, evalarg, want_string) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '*', '/' or '%' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\ttypval_T    var2;\n\tchar_u\t    *p;\n\tint\t    op;\n\tvarnumber_T n1, n2;\n#ifdef FEAT_FLOAT\n\tfloat_T\t    f1, f2;\n#endif\n\tint\t    error;\n\n\t// \"*=\", \"/=\" and \"%=\" are assignments\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tif ((op != '*' && op != '/' && op != '%') || p[1] == '=')\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tif (getnext)\n\t    *arg = eval_next_line(evalarg);\n\telse\n\t{\n\t    if (evaluate && in_vim9script() && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n#ifdef FEAT_FLOAT\n\tf1 = 0;\n\tf2 = 0;\n#endif\n\terror = FALSE;\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tf1 = rettv->vval.v_float;\n\t\tuse_float = TRUE;\n\t\tn1 = 0;\n\t    }\n\t    else\n#endif\n\t\tn1 = tv_get_number_chk(rettv, &error);\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\telse\n\t    n1 = 0;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg, 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (eval7t(arg, &var2, evalarg, FALSE) == FAIL)\n\t    return FAIL;\n\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (var2.v_type == VAR_FLOAT)\n\t    {\n\t\tif (!use_float)\n\t\t{\n\t\t    f1 = n1;\n\t\t    use_float = TRUE;\n\t\t}\n\t\tf2 = var2.vval.v_float;\n\t\tn2 = 0;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tn2 = tv_get_number_chk(&var2, &error);\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n#ifdef FEAT_FLOAT\n\t\tif (use_float)\n\t\t    f2 = n2;\n#endif\n\t    }\n\n\t    /*\n\t     * Compute the result.\n\t     * When either side is a float the result is a float.\n\t     */\n#ifdef FEAT_FLOAT\n\t    if (use_float)\n\t    {\n\t\tif (op == '*')\n\t\t    f1 = f1 * f2;\n\t\telse if (op == '/')\n\t\t{\n# ifdef VMS\n\t\t    // VMS crashes on divide by zero, work around it\n\t\t    if (f2 == 0.0)\n\t\t    {\n\t\t\tif (f1 == 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX - 1L;   // similar to NaN\n\t\t\telse if (f1 < 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX;\n\t\t\telse\n\t\t\t    f1 = __F_FLT_MAX;\n\t\t    }\n\t\t    else\n\t\t\tf1 = f1 / f2;\n# else\n\t\t    // We rely on the floating point library to handle divide\n\t\t    // by zero to result in \"inf\" and not a crash.\n\t\t    f1 = f1 / f2;\n# endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_cannot_use_percent_with_float));\n\t\t    return FAIL;\n\t\t}\n\t\trettv->v_type = VAR_FLOAT;\n\t\trettv->vval.v_float = f1;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tint\t    failed = FALSE;\n\n\t\tif (op == '*')\n\t\t    n1 = n1 * n2;\n\t\telse if (op == '/')\n\t\t    n1 = num_divide(n1, n2, &failed);\n\t\telse\n\t\t    n1 = num_modulus(n1, n2, &failed);\n\t\tif (failed)\n\t\t    return FAIL;\n\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = n1;\n\t    }\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Handle a type cast before a base level expression.\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n * Return OK or FAIL.\n */\n    static int\neval7t(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    type_T\t*want_type = NULL;\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    int\t\tres;\n    int\t\tevaluate = evalarg == NULL ? 0\n\t\t\t\t       : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    // Recognize <type> in Vim9 script only.\n    if (in_vim9script() && **arg == '<' && eval_isnamec1((*arg)[1])\n\t\t\t\t\t     && STRNCMP(*arg, \"<SNR>\", 5) != 0)\n    {\n\t++*arg;\n\tga_init2(&type_list, sizeof(type_T *), 10);\n\twant_type = parse_type(arg, &type_list, TRUE);\n\tif (want_type == NULL && (evaluate || **arg != '>'))\n\t{\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\t++*arg;\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n    }\n\n    res = eval7(arg, rettv, evalarg, want_string);\n\n    if (want_type != NULL && evaluate)\n    {\n\tif (res == OK)\n\t{\n\t    type_T *actual = typval2type(rettv, get_copyID(), &type_list,\n\t\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\n\t    if (!equal_type(want_type, actual, 0))\n\t    {\n\t\tif (want_type == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n\t\t{\n\t\t    int n = tv2bool(rettv);\n\n\t\t    // can use \"0\" and \"1\" for boolean in some places\n\t\t    clear_tv(rettv);\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\n\t\t    where.wt_variable = TRUE;\n\t\t    res = check_type(want_type, actual, TRUE, where);\n\t\t}\n\t    }\n\t}\n\tclear_type_list(&type_list);\n    }\n\n    return res;\n}\n\n    int\neval_leader(char_u **arg, int vim9)\n{\n    char_u\t*s = *arg;\n    char_u\t*p = *arg;\n\n    while (*p == '!' || *p == '-' || *p == '+')\n    {\n\tchar_u *n = skipwhite(p + 1);\n\n\t// ++, --, -+ and +- are not accepted in Vim9 script\n\tif (vim9 && (*p == '-' || *p == '+') && (*n == '-' || *n == '+'))\n\t{\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n\tp = n;\n    }\n    *arg = p;\n    return OK;\n}\n\n/*\n * Handle sixth level expression:\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {arg, arg -> expr}\tLambda\n *  {key: val, key: val}   Dictionary\n *  #{key: val, key: val}  Dictionary with literal keys\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static\tint recurse = 0;\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.\n    if (recurse == 1000)\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}\n\n/*\n * Apply the leading \"!\" and \"-\" before an eval7 expression to \"rettv\".\n * When \"numeric_only\" is TRUE only handle \"+\" and \"-\".\n * Adjusts \"end_leaderp\" until it is at \"start_leader\".\n */\n    static int\neval7_leader(\n\ttypval_T    *rettv,\n\tint\t    numeric_only,\n\tchar_u\t    *start_leader,\n\tchar_u\t    **end_leaderp)\n{\n    char_u\t*end_leader = *end_leaderp;\n    int\t\tret = OK;\n    int\t\terror = FALSE;\n    varnumber_T val = 0;\n    vartype_T\ttype = rettv->v_type;\n#ifdef FEAT_FLOAT\n    float_T\t    f = 0.0;\n\n    if (rettv->v_type == VAR_FLOAT)\n\tf = rettv->vval.v_float;\n    else\n#endif\n    {\n\twhile (VIM_ISWHITE(end_leader[-1]))\n\t    --end_leader;\n\tif (in_vim9script() && end_leader[-1] == '!')\n\t    val = tv2bool(rettv);\n\telse\n\t    val = tv_get_number_chk(rettv, &error);\n    }\n    if (error)\n    {\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n    {\n\twhile (end_leader > start_leader)\n\t{\n\t    --end_leader;\n\t    if (*end_leader == '!')\n\t    {\n\t\tif (numeric_only)\n\t\t{\n\t\t    ++end_leader;\n\t\t    break;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (in_vim9script())\n\t\t    {\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\tval = f == 0.0 ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tf = !f;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    val = !val;\n\t\t    type = VAR_BOOL;\n\t\t}\n\t    }\n\t    else if (*end_leader == '-')\n\t    {\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t    f = -f;\n\t\telse\n#endif\n\t\t{\n\t\t    val = -val;\n\t\t    type = VAR_NUMBER;\n\t\t}\n\t    }\n\t}\n#ifdef FEAT_FLOAT\n\tif (rettv->v_type == VAR_FLOAT)\n\t{\n\t    clear_tv(rettv);\n\t    rettv->vval.v_float = f;\n\t}\n\telse\n#endif\n\t{\n\t    clear_tv(rettv);\n\t    if (in_vim9script())\n\t\trettv->v_type = type;\n\t    else\n\t\trettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = val;\n\t}\n    }\n    *end_leaderp = end_leader;\n    return ret;\n}\n\n/*\n * Call the function referred to in \"rettv\".\n */\n    static int\ncall_func_rettv(\n\tchar_u\t    **arg,\n\tevalarg_T   *evalarg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tdict_T\t    *selfdict,\n\ttypval_T    *basetv)\n{\n    partial_T\t*pt = NULL;\n    funcexe_T\tfuncexe;\n    typval_T\tfunctv;\n    char_u\t*s;\n    int\t\tret;\n\n    // need to copy the funcref so that we can clear rettv\n    if (evaluate)\n    {\n\tfunctv = *rettv;\n\trettv->v_type = VAR_UNKNOWN;\n\n\t// Invoke the function.  Recursive!\n\tif (functv.v_type == VAR_PARTIAL)\n\t{\n\t    pt = functv.vval.v_partial;\n\t    s = partial_name(pt);\n\t}\n\telse\n\t{\n\t    s = functv.vval.v_string;\n\t    if (s == NULL || *s == NUL)\n\t    {\n\t\temsg(_(e_empty_function_name));\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n    }\n    else\n\ts = (char_u *)\"\";\n\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = evaluate;\n    funcexe.fe_partial = pt;\n    funcexe.fe_selfdict = selfdict;\n    funcexe.fe_basetv = basetv;\n    ret = get_func_tv(s, -1, rettv, arg, evalarg, &funcexe);\n\ntheend:\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&functv);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_method(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    char_u\t*name;\n    long\tlen;\n    char_u\t*alias;\n    char_u\t*tofree = NULL;\n    typval_T\tbase = *rettv;\n    int\t\tret = OK;\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    name = *arg;\n    len = get_name_len(arg, &alias, evaluate, TRUE);\n    if (alias != NULL)\n\tname = alias;\n\n    if (len <= 0)\n    {\n\tif (verbose)\n\t    emsg(_(e_missing_name_after_method));\n\tret = FAIL;\n    }\n    else\n    {\n\tchar_u *paren;\n\n\t// If there is no \"(\" immediately following, but there is further on,\n\t// it can be \"import.Func()\", \"dict.Func()\", \"list[nr]\", etc.\n\t// Does not handle anything where \"(\" is part of the expression.\n\t*arg = skipwhite(*arg);\n\n\tif (**arg != '(' && alias == NULL\n\t\t\t\t    && (paren = vim_strchr(*arg, '(')) != NULL)\n\t{\n\t    char_u *deref;\n\n\t    *arg = name;\n\t    *paren = NUL;\n\t    deref = deref_function_name(arg, &tofree, evalarg, verbose);\n\t    if (deref == NULL)\n\t    {\n\t\t*arg = name + len;\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tname = deref;\n\t\tlen = STRLEN(name);\n\t    }\n\t    *paren = '(';\n\t}\n\n\tif (ret == OK)\n\t{\n\t    *arg = skipwhite(*arg);\n\n\t    if (**arg != '(')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_missing_parenthesis_str), name);\n\t\tret = FAIL;\n\t    }\n\t    else if (VIM_ISWHITE((*arg)[-1]))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = eval_func(arg, evalarg, name, len, rettv,\n\t\t\t\t\t  evaluate ? EVAL_EVALUATE : 0, &base);\n\t}\n    }\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\".\n * \"*arg\" points to the '[' or '.'.\n * Returns FAIL or OK. \"*arg\" is advanced to after the ']'.\n */\n    static int\neval_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tempty1 = FALSE, empty2 = FALSE;\n    typval_T\tvar1, var2;\n    int\t\trange = FALSE;\n    char_u\t*key = NULL;\n    int\t\tkeylen = -1;\n    int\t\tvim9 = in_vim9script();\n\n    if (check_can_index(rettv, evaluate, verbose) == FAIL)\n\treturn FAIL;\n\n    init_tv(&var1);\n    init_tv(&var2);\n    if (**arg == '.')\n    {\n\t/*\n\t * dict.name\n\t */\n\tkey = *arg + 1;\n\tfor (keylen = 0; eval_isdictc(key[keylen]); ++keylen)\n\t    ;\n\tif (keylen == 0)\n\t    return FAIL;\n\t*arg = key + keylen;\n    }\n    else\n    {\n\t/*\n\t * something[idx]\n\t *\n\t * Get the (first) variable from inside the [].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (**arg == ':')\n\t    empty1 = TRUE;\n\telse if (eval1(arg, &var1, evalarg) == FAIL)\t// recursive!\n\t    return FAIL;\n\telse if (vim9 && **arg == ':')\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t    clear_tv(&var1);\n\t    return FAIL;\n\t}\n\telse if (evaluate)\n\t{\n\t    int error = FALSE;\n\n#ifdef FEAT_FLOAT\n\t    // allow for indexing with float\n\t    if (vim9 && rettv->v_type == VAR_DICT\n\t\t\t\t\t\t   && var1.v_type == VAR_FLOAT)\n\t    {\n\t\tvar1.vval.v_string = typval_tostring(&var1, TRUE);\n\t\tvar1.v_type = VAR_STRING;\n\t    }\n#endif\n\t    if (vim9 && rettv->v_type == VAR_LIST)\n\t\ttv_get_number_chk(&var1, &error);\n\t    else\n\t\terror = tv_get_string_chk(&var1) == NULL;\n\t    if (error)\n\t    {\n\t\t// not a number or string\n\t\tclear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable from inside the [:].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ':')\n\t{\n\t    range = TRUE;\n\t    ++*arg;\n\t    if (vim9 && !IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\":\", *arg - 1);\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t    if (**arg == ']')\n\t\tempty2 = TRUE;\n\t    else if (eval1(arg, &var2, evalarg) == FAIL)\t// recursive!\n\t    {\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    else if (evaluate && tv_get_string_chk(&var2) == NULL)\n\t    {\n\t\t// not a number or string\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// Check for the ']'.\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ']')\n\t{\n\t    if (verbose)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    clear_tv(&var1);\n\t    if (range)\n\t\tclear_tv(&var2);\n\t    return FAIL;\n\t}\n\t*arg = *arg + 1;\t// skip over the ']'\n    }\n\n    if (evaluate)\n    {\n\tint res = eval_index_inner(rettv, range,\n\t\tempty1 ? NULL : &var1, empty2 ? NULL : &var2, FALSE,\n\t\tkey, keylen, verbose);\n\n\tif (!empty1)\n\t    clear_tv(&var1);\n\tif (range)\n\t    clear_tv(&var2);\n\treturn res;\n    }\n    return OK;\n}\n\n/*\n * Check if \"rettv\" can have an [index] or [sli:ce]\n */\n    int\ncheck_can_index(typval_T *rettv, int evaluate, int verbose)\n{\n    switch (rettv->v_type)\n    {\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_a_funcref));\n\t    return FAIL;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (verbose)\n\t\temsg(_(e_using_float_as_string));\n\t    return FAIL;\n#endif\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_special_variable));\n\t    return FAIL;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    if (evaluate)\n\t    {\n\t\temsg(_(e_cannot_index_special_variable));\n\t\treturn FAIL;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase VAR_STRING:\n\tcase VAR_LIST:\n\tcase VAR_DICT:\n\tcase VAR_BLOB:\n\t    break;\n\tcase VAR_NUMBER:\n\t    if (in_vim9script())\n\t\temsg(_(e_cannot_index_number));\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * slice() function\n */\n    void\nf_slice(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && ((argvars[0].v_type != VAR_STRING\n\t\t    && argvars[0].v_type != VAR_LIST\n\t\t    && argvars[0].v_type != VAR_BLOB\n\t\t    && check_for_list_arg(argvars, 0) == FAIL)\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (check_can_index(argvars, TRUE, FALSE) == OK)\n    {\n\tcopy_tv(argvars, rettv);\n\teval_index_inner(rettv, TRUE, argvars + 1,\n\t\targvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,\n\t\tTRUE, NULL, 0, FALSE);\n    }\n}\n\n/*\n * Apply index or range to \"rettv\".\n * \"var1\" is the first index, NULL for [:expr].\n * \"var2\" is the second index, NULL for [expr] and [expr: ]\n * \"exclusive\" is TRUE for slice(): second index is exclusive, use character\n * index for string.\n * Alternatively, \"key\" is not NULL, then key[keylen] is the dict index.\n */\n    int\neval_index_inner(\n\ttypval_T    *rettv,\n\tint\t    is_range,\n\ttypval_T    *var1,\n\ttypval_T    *var2,\n\tint\t    exclusive,\n\tchar_u\t    *key,\n\tint\t    keylen,\n\tint\t    verbose)\n{\n    varnumber_T\t    n1, n2 = 0;\n    long\t    len;\n\n    n1 = 0;\n    if (var1 != NULL && rettv->v_type != VAR_DICT)\n\tn1 = tv_get_number(var1);\n\n    if (is_range)\n    {\n\tif (rettv->v_type == VAR_DICT)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (var2 != NULL)\n\t    n2 = tv_get_number(var2);\n\telse\n\t    n2 = VARNUM_MAX;\n    }\n\n    switch (rettv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break; // not evaluating, skipping over subscript\n\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\t    {\n\t\tchar_u\t*s = tv_get_string(rettv);\n\n\t\tlen = (long)STRLEN(s);\n\t\tif (in_vim9script() || exclusive)\n\t\t{\n\t\t    if (is_range)\n\t\t\ts = string_slice(s, n1, n2, exclusive);\n\t\t    else\n\t\t\ts = char_from_string(s, n1);\n\t\t}\n\t\telse if (is_range)\n\t\t{\n\t\t    // The resulting variable is a substring.  If the indexes\n\t\t    // are out of range the result is empty.\n\t\t    if (n1 < 0)\n\t\t    {\n\t\t\tn1 = len + n1;\n\t\t\tif (n1 < 0)\n\t\t\t    n1 = 0;\n\t\t    }\n\t\t    if (n2 < 0)\n\t\t\tn2 = len + n2;\n\t\t    else if (n2 >= len)\n\t\t\tn2 = len;\n\t\t    if (n1 >= len || n2 < 0 || n1 > n2)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, n2 - n1 + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // The resulting variable is a string of a single\n\t\t    // character.  If the index is too big or negative the\n\t\t    // result is empty.\n\t\t    if (n1 >= len || n1 < 0)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, 1);\n\t\t}\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = s;\n\t    }\n\t    break;\n\n\tcase VAR_BLOB:\n\t    blob_slice_or_index(rettv->vval.v_blob, is_range, n1, n2,\n\t\t\t\t\t\t\t     exclusive, rettv);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (var1 == NULL)\n\t\tn1 = 0;\n\t    if (var2 == NULL)\n\t\tn2 = VARNUM_MAX;\n\t    if (list_slice_or_index(rettv->vval.v_list,\n\t\t\t  is_range, n1, n2, exclusive, rettv, verbose) == FAIL)\n\t\treturn FAIL;\n\t    break;\n\n\tcase VAR_DICT:\n\t    {\n\t\tdictitem_T\t*item;\n\t\ttypval_T\ttmp;\n\n\t\tif (key == NULL)\n\t\t{\n\t\t    key = tv_get_string_chk(var1);\n\t\t    if (key == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\n\t\titem = dict_find(rettv->vval.v_dict, key, keylen);\n\n\t\tif (item == NULL)\n\t\t{\n\t\t    if (verbose)\n\t\t    {\n\t\t\tif (keylen > 0)\n\t\t\t    key[keylen] = NUL;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    }\n\t\t    return FAIL;\n\t\t}\n\n\t\tcopy_tv(&item->di_tv, &tmp);\n\t\tclear_tv(rettv);\n\t\t*rettv = tmp;\n\t    }\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * Return the function name of partial \"pt\".\n */\n    char_u *\npartial_name(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (pt->pt_name != NULL)\n\t    return pt->pt_name;\n\tif (pt->pt_func != NULL)\n\t    return pt->pt_func->uf_name;\n    }\n    return (char_u *)\"\";\n}\n\n    static void\npartial_free(partial_T *pt)\n{\n    int i;\n\n    for (i = 0; i < pt->pt_argc; ++i)\n\tclear_tv(&pt->pt_argv[i]);\n    vim_free(pt->pt_argv);\n    dict_unref(pt->pt_dict);\n    if (pt->pt_name != NULL)\n    {\n\tfunc_unref(pt->pt_name);\n\tvim_free(pt->pt_name);\n    }\n    else\n\tfunc_ptr_unref(pt->pt_func);\n\n    // \"out_up\" is no longer used, decrement refcount on partial that owns it.\n    partial_unref(pt->pt_outer.out_up_partial);\n\n    // Decrease the reference count for the context of a closure.  If down\n    // to the minimum it may be time to free it.\n    if (pt->pt_funcstack != NULL)\n    {\n\t--pt->pt_funcstack->fs_refcount;\n\tfuncstack_check_refcount(pt->pt_funcstack);\n    }\n\n    vim_free(pt);\n}\n\n/*\n * Unreference a closure: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\npartial_unref(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (--pt->pt_refcount <= 0)\n\t    partial_free(pt);\n\n\t// If the reference count goes down to one, the funcstack may be the\n\t// only reference and can be freed if no other partials reference it.\n\telse if (pt->pt_refcount == 1 && pt->pt_funcstack != NULL)\n\t    funcstack_check_refcount(pt->pt_funcstack);\n    }\n}\n\n/*\n * Return the next (unique) copy ID.\n * Used for serializing nested structures.\n */\n    int\nget_copyID(void)\n{\n    current_copyID += COPYID_INC;\n    return current_copyID;\n}\n\n/*\n * Garbage collection for lists and dictionaries.\n *\n * We use reference counts to be able to free most items right away when they\n * are no longer used.  But for composite items it's possible that it becomes\n * unused while the reference count is > 0: When there is a recursive\n * reference.  Example:\n *\t:let l = [1, 2, 3]\n *\t:let d = {9: l}\n *\t:let l[1] = d\n *\n * Since this is quite unusual we handle this with garbage collection: every\n * once in a while find out which lists and dicts are not referenced from any\n * variable.\n *\n * Here is a good reference text about garbage collection (refers to Python\n * but it applies to all reference-counting mechanisms):\n *\thttp://python.ca/nas/python/gc/\n */\n\n/*\n * Do garbage collection for lists and dicts.\n * When \"testing\" is TRUE this is called from test_garbagecollect_now().\n * Return TRUE if some memory was freed.\n */\n    int\ngarbage_collect(int testing)\n{\n    int\t\tcopyID;\n    int\t\tabort = FALSE;\n    buf_T\t*buf;\n    win_T\t*wp;\n    int\t\tdid_free = FALSE;\n    tabpage_T\t*tp;\n\n    if (!testing)\n    {\n\t// Only do this once.\n\twant_garbage_collect = FALSE;\n\tmay_garbage_collect = FALSE;\n\tgarbage_collect_at_exit = FALSE;\n    }\n\n    // The execution stack can grow big, limit the size.\n    if (exestack.ga_maxlen - exestack.ga_len > 500)\n    {\n\tsize_t\tnew_len;\n\tchar_u\t*pp;\n\tint\tn;\n\n\t// Keep 150% of the current size, with a minimum of the growth size.\n\tn = exestack.ga_len / 2;\n\tif (n < exestack.ga_growsize)\n\t    n = exestack.ga_growsize;\n\n\t// Don't make it bigger though.\n\tif (exestack.ga_len + n < exestack.ga_maxlen)\n\t{\n\t    new_len = exestack.ga_itemsize * (exestack.ga_len + n);\n\t    pp = vim_realloc(exestack.ga_data, new_len);\n\t    if (pp == NULL)\n\t\treturn FAIL;\n\t    exestack.ga_maxlen = exestack.ga_len + n;\n\t    exestack.ga_data = pp;\n\t}\n    }\n\n    // We advance by two because we add one for items referenced through\n    // previous_funccal.\n    copyID = get_copyID();\n\n    /*\n     * 1. Go through all accessible variables and mark all lists and dicts\n     *    with copyID.\n     */\n\n    // Don't free variables in the previous_funccal list unless they are only\n    // referenced through previous_funccal.  This must be first, because if\n    // the item is referenced elsewhere the funccal must not be freed.\n    abort = abort || set_ref_in_previous_funccal(copyID);\n\n    // script-local variables\n    abort = abort || garbage_collect_scriptvars(copyID);\n\n    // buffer-local variables\n    FOR_ALL_BUFFERS(buf)\n\tabort = abort || set_ref_in_item(&buf->b_bufvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n    // window-local variables\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    if (aucmd_win != NULL)\n\tabort = abort || set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    FOR_ALL_TABPAGES(tp)\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#endif\n\n    // tabpage-local variables\n    FOR_ALL_TABPAGES(tp)\n\tabort = abort || set_ref_in_item(&tp->tp_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    // global variables\n    abort = abort || garbage_collect_globvars(copyID);\n\n    // function-local variables\n    abort = abort || set_ref_in_call_stack(copyID);\n\n    // named functions (matters for closures)\n    abort = abort || set_ref_in_functions(copyID);\n\n    // function call arguments, if v:testing is set.\n    abort = abort || set_ref_in_func_args(copyID);\n\n    // funcstacks keep variables for closures\n    abort = abort || set_ref_in_funcstacks(copyID);\n\n    // v: vars\n    abort = abort || garbage_collect_vimvars(copyID);\n\n    // callbacks in buffers\n    abort = abort || set_ref_in_buffers(copyID);\n\n    // 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks\n    abort = abort || set_ref_in_insexpand_funcs(copyID);\n\n    // 'operatorfunc' callback\n    abort = abort || set_ref_in_opfunc(copyID);\n\n    // 'tagfunc' callback\n    abort = abort || set_ref_in_tagfunc(copyID);\n\n    // 'imactivatefunc' and 'imstatusfunc' callbacks\n    abort = abort || set_ref_in_im_funcs(copyID);\n\n#ifdef FEAT_LUA\n    abort = abort || set_ref_in_lua(copyID);\n#endif\n\n#ifdef FEAT_PYTHON\n    abort = abort || set_ref_in_python(copyID);\n#endif\n\n#ifdef FEAT_PYTHON3\n    abort = abort || set_ref_in_python3(copyID);\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n    abort = abort || set_ref_in_channel(copyID);\n    abort = abort || set_ref_in_job(copyID);\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    abort = abort || set_ref_in_nb_channel(copyID);\n#endif\n\n#ifdef FEAT_TIMERS\n    abort = abort || set_ref_in_timer(copyID);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    abort = abort || set_ref_in_quickfix(copyID);\n#endif\n\n#ifdef FEAT_TERMINAL\n    abort = abort || set_ref_in_term(copyID);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    abort = abort || set_ref_in_popups(copyID);\n#endif\n\n    if (!abort)\n    {\n\t/*\n\t * 2. Free lists and dictionaries that are not referenced.\n\t */\n\tdid_free = free_unref_items(copyID);\n\n\t/*\n\t * 3. Check if any funccal can be freed now.\n\t *    This may call us back recursively.\n\t */\n\tfree_unref_funccal(copyID, testing);\n    }\n    else if (p_verbose > 0)\n    {\n\tverb_msg(_(\"Not enough memory to set references, garbage collection aborted!\"));\n    }\n\n    return did_free;\n}\n\n/*\n * Free lists, dictionaries, channels and jobs that are no longer referenced.\n */\n    static int\nfree_unref_items(int copyID)\n{\n    int\t\tdid_free = FALSE;\n\n    // Let all \"free\" functions know that we are here.  This means no\n    // dictionaries, lists, channels or jobs are to be freed, because we will\n    // do that here.\n    in_free_unref_items = TRUE;\n\n    /*\n     * PASS 1: free the contents of the items.  We don't free the items\n     * themselves yet, so that it is possible to decrement refcount counters\n     */\n\n    // Go through the list of dicts and free items without the copyID.\n    did_free |= dict_free_nonref(copyID);\n\n    // Go through the list of lists and free items without the copyID.\n    did_free |= list_free_nonref(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    did_free |= free_unused_jobs_contents(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    did_free |= free_unused_channels_contents(copyID, COPYID_MASK);\n#endif\n\n    /*\n     * PASS 2: free the items themselves.\n     */\n    dict_free_items(copyID);\n    list_free_items(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    free_unused_jobs(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    free_unused_channels(copyID, COPYID_MASK);\n#endif\n\n    in_free_unref_items = FALSE;\n\n    return did_free;\n}\n\n/*\n * Mark all lists and dicts referenced through hashtab \"ht\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)\n{\n    int\t\ttodo;\n    int\t\tabort = FALSE;\n    hashitem_T\t*hi;\n    hashtab_T\t*cur_ht;\n    ht_stack_T\t*ht_stack = NULL;\n    ht_stack_T\t*tempitem;\n\n    cur_ht = ht;\n    for (;;)\n    {\n\tif (!abort)\n\t{\n\t    // Mark each item in the hashtab.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    todo = (int)cur_ht->ht_used;\n\t    for (hi = cur_ht->ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    --todo;\n\t\t    abort = abort || set_ref_in_item(&HI2DI(hi)->di_tv, copyID,\n\t\t\t\t\t\t       &ht_stack, list_stack);\n\t\t}\n\t}\n\n\tif (ht_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_ht = ht_stack->ht;\n\ttempitem = ht_stack;\n\tht_stack = ht_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n#if defined(FEAT_LUA) || defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) \\\n\t\t\t\t\t\t\t|| defined(PROTO)\n/*\n * Mark a dict and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_dict(dict_T *d, int copyID)\n{\n    if (d != NULL && d->dv_copyID != copyID)\n    {\n\td->dv_copyID = copyID;\n\treturn set_ref_in_ht(&d->dv_hashtab, copyID, NULL);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Mark a list and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list(list_T *ll, int copyID)\n{\n    if (ll != NULL && ll->lv_copyID != copyID)\n    {\n\tll->lv_copyID = copyID;\n\treturn set_ref_in_list_items(ll, copyID, NULL);\n    }\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through list \"l\" with \"copyID\".\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack)\n{\n    listitem_T\t *li;\n    int\t\t abort = FALSE;\n    list_T\t *cur_l;\n    list_stack_T *list_stack = NULL;\n    list_stack_T *tempitem;\n\n    cur_l = l;\n    for (;;)\n    {\n\tif (!abort && cur_l->lv_first != &range_list_item)\n\t    // Mark each item in the list.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    for (li = cur_l->lv_first; !abort && li != NULL; li = li->li_next)\n\t\tabort = abort || set_ref_in_item(&li->li_tv, copyID,\n\t\t\t\t\t\t       ht_stack, &list_stack);\n\tif (list_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_l = list_stack->list;\n\ttempitem = list_stack;\n\tlist_stack = list_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the partial in callback 'cb' with \"copyID\".\n */\n    int\nset_ref_in_callback(callback_T *cb, int copyID)\n{\n    typval_T tv;\n\n    if (cb->cb_name == NULL || *cb->cb_name == NUL || cb->cb_partial == NULL)\n\treturn FALSE;\n\n    tv.v_type = VAR_PARTIAL;\n    tv.vval.v_partial = cb->cb_partial;\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n}\n\n/*\n * Mark all lists and dicts referenced through typval \"tv\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_item(\n    typval_T\t    *tv,\n    int\t\t    copyID,\n    ht_stack_T\t    **ht_stack,\n    list_stack_T    **list_stack)\n{\n    int\t\tabort = FALSE;\n\n    if (tv->v_type == VAR_DICT)\n    {\n\tdict_T\t*dd = tv->vval.v_dict;\n\n\tif (dd != NULL && dd->dv_copyID != copyID)\n\t{\n\t    // Didn't see this dict yet.\n\t    dd->dv_copyID = copyID;\n\t    if (ht_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_ht(&dd->dv_hashtab, copyID, list_stack);\n\t    }\n\t    else\n\t    {\n\t\tht_stack_T *newitem = ALLOC_ONE(ht_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->ht = &dd->dv_hashtab;\n\t\t    newitem->prev = *ht_stack;\n\t\t    *ht_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_LIST)\n    {\n\tlist_T\t*ll = tv->vval.v_list;\n\n\tif (ll != NULL && ll->lv_copyID != copyID)\n\t{\n\t    // Didn't see this list yet.\n\t    ll->lv_copyID = copyID;\n\t    if (list_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_list_items(ll, copyID, ht_stack);\n\t    }\n\t    else\n\t    {\n\t\tlist_stack_T *newitem = ALLOC_ONE(list_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->list = ll;\n\t\t    newitem->prev = *list_stack;\n\t\t    *list_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_FUNC)\n    {\n\tabort = set_ref_in_func(tv->vval.v_string, NULL, copyID);\n    }\n    else if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T\t*pt = tv->vval.v_partial;\n\tint\t\ti;\n\n\tif (pt != NULL && pt->pt_copyID != copyID)\n\t{\n\t    // Didn't see this partial yet.\n\t    pt->pt_copyID = copyID;\n\n\t    abort = set_ref_in_func(pt->pt_name, pt->pt_func, copyID);\n\n\t    if (pt->pt_dict != NULL)\n\t    {\n\t\ttypval_T dtv;\n\n\t\tdtv.v_type = VAR_DICT;\n\t\tdtv.vval.v_dict = pt->pt_dict;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tabort = abort || set_ref_in_item(&pt->pt_argv[i], copyID,\n\t\t\t\t\t\t\tht_stack, list_stack);\n\t    // pt_funcstack is handled in set_ref_in_funcstacks()\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv->v_type == VAR_JOB)\n    {\n\tjob_T\t    *job = tv->vval.v_job;\n\ttypval_T    dtv;\n\n\tif (job != NULL && job->jv_copyID != copyID)\n\t{\n\t    job->jv_copyID = copyID;\n\t    if (job->jv_channel != NULL)\n\t    {\n\t\tdtv.v_type = VAR_CHANNEL;\n\t\tdtv.vval.v_channel = job->jv_channel;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (job->jv_exit_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = job->jv_exit_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_CHANNEL)\n    {\n\tchannel_T   *ch =tv->vval.v_channel;\n\tch_part_T   part;\n\ttypval_T    dtv;\n\tjsonq_T\t    *jq;\n\tcbq_T\t    *cq;\n\n\tif (ch != NULL && ch->ch_copyID != copyID)\n\t{\n\t    ch->ch_copyID = copyID;\n\t    for (part = PART_SOCK; part < PART_COUNT; ++part)\n\t    {\n\t\tfor (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;\n\t\t\t\t\t\t\t     jq = jq->jq_next)\n\t\t    set_ref_in_item(jq->jq_value, copyID, ht_stack, list_stack);\n\t\tfor (cq = ch->ch_part[part].ch_cb_head.cq_next; cq != NULL;\n\t\t\t\t\t\t\t     cq = cq->cq_next)\n\t\t    if (cq->cq_callback.cb_partial != NULL)\n\t\t    {\n\t\t\tdtv.v_type = VAR_PARTIAL;\n\t\t\tdtv.vval.v_partial = cq->cq_callback.cb_partial;\n\t\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t    }\n\t\tif (ch->ch_part[part].ch_callback.cb_partial != NULL)\n\t\t{\n\t\t    dtv.v_type = VAR_PARTIAL;\n\t\t    dtv.vval.v_partial =\n\t\t\t\t      ch->ch_part[part].ch_callback.cb_partial;\n\t\t    set_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t}\n\t    }\n\t    if (ch->ch_callback.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_callback.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (ch->ch_close_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_close_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n#endif\n    return abort;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * When both \"echo_style\" and \"composite_val\" are FALSE, put quotes around\n * strings as \"string()\", otherwise does not put quotes around strings, as\n * \":echo\" displays values.\n * When \"restore_copyID\" is FALSE, repeated items in dictionaries and lists\n * are replaced with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string_core(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID,\n    int\t\techo_style,\n    int\t\trestore_copyID,\n    int\t\tcomposite_val)\n{\n    static int\trecurse = 0;\n    char_u\t*r = NULL;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\tif (!did_echo_string_emsg)\n\t{\n\t    // Only give this message once for a recursive call to avoid\n\t    // flooding the user with errors.  And stop iterating over lists\n\t    // and dicts.\n\t    did_echo_string_emsg = TRUE;\n\t    emsg(_(e_variable_nested_too_deep_for_displaying));\n\t}\n\t*tofree = NULL;\n\treturn (char_u *)\"{E724}\";\n    }\n    ++recurse;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_STRING:\n\t    if (echo_style && !composite_val)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t\tif (r == NULL)\n\t\t    r = (char_u *)\"\";\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, FALSE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_FUNC:\n\t    if (echo_style)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, TRUE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_PARTIAL:\n\t    {\n\t\tpartial_T   *pt = tv->vval.v_partial;\n\t\tchar_u\t    *fname = string_quote(pt == NULL ? NULL\n\t\t\t\t\t\t    : partial_name(pt), FALSE);\n\t\tgarray_T    ga;\n\t\tint\t    i;\n\t\tchar_u\t    *tf;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tga_concat(&ga, (char_u *)\"function(\");\n\t\tif (fname != NULL)\n\t\t{\n\t\t    // When using uf_name prepend \"g:\" for a global function.\n\t\t    if (pt != NULL && pt->pt_name == NULL && fname[0] == '\\''\n\t\t\t\t\t\t      && vim_isupper(fname[1]))\n\t\t    {\n\t\t\tga_concat(&ga, (char_u *)\"'g:\");\n\t\t\tga_concat(&ga, fname + 1);\n\t\t    }\n\t\t    else\n\t\t\tga_concat(&ga, fname);\n\t\t    vim_free(fname);\n\t\t}\n\t\tif (pt != NULL && pt->pt_argc > 0)\n\t\t{\n\t\t    ga_concat(&ga, (char_u *)\", [\");\n\t\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t\tga_concat(&ga,\n\t\t\t     tv2string(&pt->pt_argv[i], &tf, numbuf, copyID));\n\t\t\tvim_free(tf);\n\t\t    }\n\t\t    ga_concat(&ga, (char_u *)\"]\");\n\t\t}\n\t\tif (pt != NULL && pt->pt_dict != NULL)\n\t\t{\n\t\t    typval_T dtv;\n\n\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t    dtv.v_type = VAR_DICT;\n\t\t    dtv.vval.v_dict = pt->pt_dict;\n\t\t    ga_concat(&ga, tv2string(&dtv, &tf, numbuf, copyID));\n\t\t    vim_free(tf);\n\t\t}\n\t\t// terminate with ')' and a NUL\n\t\tga_concat_len(&ga, (char_u *)\")\", 2);\n\n\t\t*tofree = ga.ga_data;\n\t\tr = *tofree;\n\t\tbreak;\n\t    }\n\n\tcase VAR_BLOB:\n\t    r = blob2string(tv->vval.v_blob, tofree, numbuf);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t    {\n\t\t// NULL list is equivalent to empty list.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[]\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_list->lv_copyID == copyID\n\t\t    && tv->vval.v_list->lv_len > 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[...]\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_list->lv_copyID;\n\n\t\ttv->vval.v_list->lv_copyID = copyID;\n\t\t*tofree = list2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_list->lv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t    {\n\t\t// NULL dict is equivalent to empty dict.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{}\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_dict->dv_copyID == copyID\n\t\t    && tv->vval.v_dict->dv_hashtab.ht_used != 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{...}\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_dict->dv_copyID;\n\n\t\ttv->vval.v_dict->dv_copyID = copyID;\n\t\t*tofree = dict2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_dict->dv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_NUMBER:\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    *tofree = NULL;\n\t    r = tv_get_string_buf(tv, numbuf);\n\t    break;\n\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    *tofree = NULL;\n\t    r = tv->v_type == VAR_JOB ? job_to_string_buf(tv, numbuf)\n\t\t\t\t\t   : channel_to_string_buf(tv, numbuf);\n\t    if (composite_val)\n\t    {\n\t\t*tofree = string_quote(r, FALSE);\n\t\tr = *tofree;\n\t    }\n#endif\n\t    break;\n\n\tcase VAR_INSTR:\n\t    *tofree = NULL;\n\t    r = (char_u *)\"instructions\";\n\t    break;\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    *tofree = NULL;\n\t    vim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\t    r = numbuf;\n\t    break;\n#endif\n\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    *tofree = NULL;\n\t    r = (char_u *)get_var_special_name(tv->vval.v_number);\n\t    break;\n    }\n\n    if (--recurse == 0)\n\tdid_echo_string_emsg = FALSE;\n    return r;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Does not put quotes around strings, as \":echo\" displays values.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, TRUE, FALSE, FALSE);\n}\n\n/*\n * Convert the specified byte index of line 'lnum' in buffer 'buf' to a\n * character index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n    int\t\tcount;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    if (*str == NUL)\n\treturn 0;\n\n    // count the number of characters\n    t = str;\n    for (count = 0; *t != NUL && t <= str + byteidx; count++)\n\tt += mb_ptr2len(t);\n\n    // In insert mode, when the cursor is at the end of a non-empty line,\n    // byteidx points to the NUL character immediately past the end of the\n    // string. In this case, add one to the character count.\n    if (*t == NUL && byteidx != 0 && t == str + byteidx)\n\tcount++;\n\n    return count - 1;\n}\n\n/*\n * Convert the specified character index of line 'lnum' in buffer 'buf' to a\n * byte index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    // Convert the character offset to a byte offset\n    t = str;\n    while (*t != NUL && --charidx > 0)\n\tt += mb_ptr2len(t);\n\n    return t - str;\n}\n\n/*\n * Translate a String variable into a position.\n * Returns NULL when there is an error.\n */\n    pos_T *\nvar2fpos(\n    typval_T\t*varp,\n    int\t\tdollar_lnum,\t// TRUE when $ is last line\n    int\t\t*fnum,\t\t// set to fnum for '0, 'A, etc.\n    int\t\tcharcol)\t// return character column\n{\n    char_u\t\t*name;\n    static pos_T\tpos;\n    pos_T\t\t*pp;\n\n    // Argument can be [lnum, col, coladd].\n    if (varp->v_type == VAR_LIST)\n    {\n\tlist_T\t\t*l;\n\tint\t\tlen;\n\tint\t\terror = FALSE;\n\tlistitem_T\t*li;\n\n\tl = varp->vval.v_list;\n\tif (l == NULL)\n\t    return NULL;\n\n\t// Get the line number\n\tpos.lnum = list_find_nr(l, 0L, &error);\n\tif (error || pos.lnum <= 0 || pos.lnum > curbuf->b_ml.ml_line_count)\n\t    return NULL;\t// invalid line number\n\tif (charcol)\n\t    len = (long)mb_charlen(ml_get(pos.lnum));\n\telse\n\t    len = (long)STRLEN(ml_get(pos.lnum));\n\n\t// Get the column number\n\t// We accept \"$\" for the column number: last column.\n\tli = list_find(l, 1L);\n\tif (li != NULL && li->li_tv.v_type == VAR_STRING\n\t\t&& li->li_tv.vval.v_string != NULL\n\t\t&& STRCMP(li->li_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    pos.col = len + 1;\n\t}\n\telse\n\t{\n\t    pos.col = list_find_nr(l, 1L, &error);\n\t    if (error)\n\t\treturn NULL;\n\t}\n\n\t// Accept a position up to the NUL after the line.\n\tif (pos.col == 0 || (int)pos.col > len + 1)\n\t    return NULL;\t// invalid column number\n\t--pos.col;\n\n\t// Get the virtual offset.  Defaults to zero.\n\tpos.coladd = list_find_nr(l, 2L, &error);\n\tif (error)\n\t    pos.coladd = 0;\n\n\treturn &pos;\n    }\n\n    if (in_vim9script() && check_for_string_arg(varp, 0) == FAIL)\n\treturn NULL;\n\n    name = tv_get_string_chk(varp);\n    if (name == NULL)\n\treturn NULL;\n    if (name[0] == '.' && (!in_vim9script() || name[1] == NUL))\n    {\n\t// cursor\n\tpos = curwin->w_cursor;\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n    if (name[0] == 'v' && name[1] == NUL)\t// Visual start\n    {\n\tif (VIsual_active)\n\t    pos = VIsual;\n\telse\n\t    pos = curwin->w_cursor;\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n    if (name[0] == '\\'' && (!in_vim9script()\n\t\t\t\t\t|| (name[1] != NUL && name[2] == NUL)))\n    {\n\t// mark\n\tpp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);\n\tif (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0)\n\t    return NULL;\n\tif (charcol)\n\t    pp->col = buf_byteidx_to_charidx(curbuf, pp->lnum, pp->col);\n\treturn pp;\n    }\n\n    pos.coladd = 0;\n\n    if (name[0] == 'w' && dollar_lnum)\n    {\n\tpos.col = 0;\n\tif (name[1] == '0')\t\t// \"w0\": first visible line\n\t{\n\t    update_topline();\n\t    // In silent Ex mode topline is zero, but that's not a valid line\n\t    // number; use one instead.\n\t    pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;\n\t    return &pos;\n\t}\n\telse if (name[1] == '$')\t// \"w$\": last visible line\n\t{\n\t    validate_botline();\n\t    // In silent Ex mode botline is zero, return zero then.\n\t    pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;\n\t    return &pos;\n\t}\n    }\n    else if (name[0] == '$')\t\t// last column or line\n    {\n\tif (dollar_lnum)\n\t{\n\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t    pos.col = 0;\n\t}\n\telse\n\t{\n\t    pos.lnum = curwin->w_cursor.lnum;\n\t    if (charcol)\n\t\tpos.col = (colnr_T)mb_charlen(ml_get_curline());\n\t    else\n\t\tpos.col = (colnr_T)STRLEN(ml_get_curline());\n\t}\n\treturn &pos;\n    }\n    if (in_vim9script())\n\tsemsg(_(e_invalid_value_for_line_number_str), name);\n    return NULL;\n}\n\n/*\n * Convert list in \"arg\" into a position and optional file number.\n * When \"fnump\" is NULL there is no file number, only 3 items.\n * Note that the column is passed on as-is, the caller may want to decrement\n * it to use 1 for the first column.\n * Return FAIL when conversion is not possible, doesn't check the position for\n * validity.\n */\n    int\nlist2fpos(\n    typval_T\t*arg,\n    pos_T\t*posp,\n    int\t\t*fnump,\n    colnr_T\t*curswantp,\n    int\t\tcharcol)\n{\n    list_T\t*l = arg->vval.v_list;\n    long\ti = 0;\n    long\tn;\n\n    // List must be: [fnum, lnum, col, coladd, curswant], where \"fnum\" is only\n    // there when \"fnump\" isn't NULL; \"coladd\" and \"curswant\" are optional.\n    if (arg->v_type != VAR_LIST\n\t    || l == NULL\n\t    || l->lv_len < (fnump == NULL ? 2 : 3)\n\t    || l->lv_len > (fnump == NULL ? 4 : 5))\n\treturn FAIL;\n\n    if (fnump != NULL)\n    {\n\tn = list_find_nr(l, i++, NULL);\t// fnum\n\tif (n < 0)\n\t    return FAIL;\n\tif (n == 0)\n\t    n = curbuf->b_fnum;\t\t// current buffer\n\t*fnump = n;\n    }\n\n    n = list_find_nr(l, i++, NULL);\t// lnum\n    if (n < 0)\n\treturn FAIL;\n    posp->lnum = n;\n\n    n = list_find_nr(l, i++, NULL);\t// col\n    if (n < 0)\n\treturn FAIL;\n    // If character position is specified, then convert to byte position\n    if (charcol)\n    {\n\tbuf_T\t*buf;\n\n\t// Get the text for the specified line in a loaded buffer\n\tbuf = buflist_findnr(fnump == NULL ? curbuf->b_fnum : *fnump);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    return FAIL;\n\n\tn = buf_charidx_to_byteidx(buf, posp->lnum, n) + 1;\n    }\n    posp->col = n;\n\n    n = list_find_nr(l, i, NULL);\t// off\n    if (n < 0)\n\tposp->coladd = 0;\n    else\n\tposp->coladd = n;\n\n    if (curswantp != NULL)\n\t*curswantp = list_find_nr(l, i + 1, NULL);  // curswant\n\n    return OK;\n}\n\n/*\n * Get the length of an environment variable name.\n * Advance \"arg\" to the first character after the name.\n * Return 0 for error.\n */\n    int\nget_env_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    for (p = *arg; vim_isIDc(*p); ++p)\n\t;\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n    return len;\n}\n\n/*\n * Get the length of the name of a function or internal variable.\n * \"arg\" is advanced to after the name.\n * Return 0 if something is wrong.\n */\n    int\nget_id_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    // Find the end of the name.\n    for (p = *arg; eval_isnamec(*p); ++p)\n    {\n\tif (*p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace.\n\t    len = (int)(p - *arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, **arg) == NULL)\n\t\t    || len > 1)\n\t\tbreak;\n\t}\n    }\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n\n    return len;\n}\n\n/*\n * Get the length of the name of a variable or function.\n * Only the name is recognized, does not handle \".key\" or \"[idx]\".\n * \"arg\" is advanced to the first non-white character after the name.\n * Return -1 if curly braces expansion failed.\n * Return 0 if something else is wrong.\n * If the name contains 'magic' {}'s, expand them and return the\n * expanded name in an allocated string via 'alias' - caller must free.\n */\n    int\nget_name_len(\n    char_u\t**arg,\n    char_u\t**alias,\n    int\t\tevaluate,\n    int\t\tverbose)\n{\n    int\t\tlen;\n    char_u\t*p;\n    char_u\t*expr_start;\n    char_u\t*expr_end;\n\n    *alias = NULL;  // default to no alias\n\n    if ((*arg)[0] == K_SPECIAL && (*arg)[1] == KS_EXTRA\n\t\t\t\t\t\t  && (*arg)[2] == (int)KE_SNR)\n    {\n\t// hard coded <SNR>, already translated\n\t*arg += 3;\n\treturn get_id_len(arg) + 3;\n    }\n    len = eval_fname_script(*arg);\n    if (len > 0)\n    {\n\t// literal \"<SID>\", \"s:\" or \"<SNR>\"\n\t*arg += len;\n    }\n\n    /*\n     * Find the end of the name; check for {} construction.\n     */\n    p = find_name_end(*arg, &expr_start, &expr_end,\n\t\t\t\t\t       len > 0 ? 0 : FNE_CHECK_START);\n    if (expr_start != NULL)\n    {\n\tchar_u\t*temp_string;\n\n\tif (!evaluate)\n\t{\n\t    len += (int)(p - *arg);\n\t    *arg = skipwhite(p);\n\t    return len;\n\t}\n\n\t/*\n\t * Include any <SID> etc in the expanded string:\n\t * Thus the -len here.\n\t */\n\ttemp_string = make_expanded_name(*arg - len, expr_start, expr_end, p);\n\tif (temp_string == NULL)\n\t    return -1;\n\t*alias = temp_string;\n\t*arg = skipwhite(p);\n\treturn (int)STRLEN(temp_string);\n    }\n\n    len += get_id_len(arg);\n    // Only give an error when there is something, otherwise it will be\n    // reported at a higher level.\n    if (len == 0 && verbose && **arg != NUL)\n\tsemsg(_(e_invalid_expression_str), *arg);\n\n    return len;\n}\n\n/*\n * Find the end of a variable or function name, taking care of magic braces.\n * If \"expr_start\" is not NULL then \"expr_start\" and \"expr_end\" are set to the\n * start and end of the first magic braces item.\n * \"flags\" can have FNE_INCL_BR and FNE_CHECK_START.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nfind_name_end(\n    char_u\t*arg,\n    char_u\t**expr_start,\n    char_u\t**expr_end,\n    int\t\tflags)\n{\n    int\t\tmb_nest = 0;\n    int\t\tbr_nest = 0;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tvim9script = in_vim9script();\n\n    if (expr_start != NULL)\n    {\n\t*expr_start = NULL;\n\t*expr_end = NULL;\n    }\n\n    // Quick check for valid starting character.\n    if ((flags & FNE_CHECK_START) && !eval_isnamec1(*arg)\n\t\t\t\t\t\t&& (*arg != '{' || vim9script))\n\treturn arg;\n\n    for (p = arg; *p != NUL\n\t\t    && (eval_isnamec(*p)\n\t\t\t|| (*p == '{' && !vim9script)\n\t\t\t|| ((flags & FNE_INCL_BR) && (*p == '['\n\t\t\t\t\t || (*p == '.' && eval_isdictc(p[1]))))\n\t\t\t|| mb_nest != 0\n\t\t\t|| br_nest != 0); MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    // skip over 'string' to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\\''; MB_PTR_ADV(p))\n\t\t;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    // skip over \"str\\\"ing\" to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (br_nest == 0 && mb_nest == 0 && *p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace. But {ns}: is.\n\t    len = (int)(p - arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, *arg) == NULL)\n\t\t    || (len > 1 && p[-1] != '}'))\n\t\tbreak;\n\t}\n\n\tif (mb_nest == 0)\n\t{\n\t    if (*p == '[')\n\t\t++br_nest;\n\t    else if (*p == ']')\n\t\t--br_nest;\n\t}\n\n\tif (br_nest == 0 && !vim9script)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tmb_nest++;\n\t\tif (expr_start != NULL && *expr_start == NULL)\n\t\t    *expr_start = p;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\tmb_nest--;\n\t\tif (expr_start != NULL && mb_nest == 0 && *expr_end == NULL)\n\t\t    *expr_end = p;\n\t    }\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Expands out the 'magic' {}'s in a variable/function name.\n * Note that this can call itself recursively, to deal with\n * constructs like foo{bar}{baz}{bam}\n * The four pointer arguments point to \"foo{expre}ss{ion}bar\"\n *\t\t\t\"in_start\"      ^\n *\t\t\t\"expr_start\"\t   ^\n *\t\t\t\"expr_end\"\t\t ^\n *\t\t\t\"in_end\"\t\t\t    ^\n *\n * Returns a new allocated string, which the caller must free.\n * Returns NULL for failure.\n */\n    static char_u *\nmake_expanded_name(\n    char_u\t*in_start,\n    char_u\t*expr_start,\n    char_u\t*expr_end,\n    char_u\t*in_end)\n{\n    char_u\tc1;\n    char_u\t*retval = NULL;\n    char_u\t*temp_result;\n\n    if (expr_end == NULL || in_end == NULL)\n\treturn NULL;\n    *expr_start\t= NUL;\n    *expr_end = NUL;\n    c1 = *in_end;\n    *in_end = NUL;\n\n    temp_result = eval_to_string(expr_start + 1, FALSE);\n    if (temp_result != NULL)\n    {\n\tretval = alloc(STRLEN(temp_result) + (expr_start - in_start)\n\t\t\t\t\t\t   + (in_end - expr_end) + 1);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, in_start);\n\t    STRCAT(retval, temp_result);\n\t    STRCAT(retval, expr_end + 1);\n\t}\n    }\n    vim_free(temp_result);\n\n    *in_end = c1;\t\t// put char back for error messages\n    *expr_start = '{';\n    *expr_end = '}';\n\n    if (retval != NULL)\n    {\n\ttemp_result = find_name_end(retval, &expr_start, &expr_end, 0);\n\tif (expr_start != NULL)\n\t{\n\t    // Further expansion!\n\t    temp_result = make_expanded_name(retval, expr_start,\n\t\t\t\t\t\t       expr_end, temp_result);\n\t    vim_free(retval);\n\t    retval = temp_result;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if character \"c\" can be used in a variable or function name.\n * Does not include '{' or '}' for magic braces.\n */\n    int\neval_isnamec(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character in a\n * variable or function name (excluding '{' and '}').\n */\n    int\neval_isnamec1(int c)\n{\n    return ASCII_ISALPHA(c) || c == '_';\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character of a\n * dictionary key.\n */\n    int\neval_isdictc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * Handle:\n * - expr[expr], expr[expr:expr] subscript\n * - \".name\" lookup\n * - function call with Funcref variable: func(expr)\n * - method call: var->method()\n *\n * Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()\n * \"name_start\" points to a variable before the subscript or is NULL.\n */\n    int\nhandle_subscript(\n    char_u\t**arg,\n    char_u\t*name_start,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tret = OK;\n    dict_T\t*selfdict = NULL;\n    int\t\tcheck_white = TRUE;\n    int\t\tgetnext;\n    char_u\t*p;\n\n    while (ret == OK)\n    {\n\t// When at the end of the line and \".name\" or \"->{\" or \"->X\" follows in\n\t// the next line then consume the line break.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (getnext\n\t    && ((rettv->v_type == VAR_DICT && *p == '.' && eval_isdictc(p[1]))\n\t\t|| (p[0] == '-' && p[1] == '>' && (p[2] == '{'\n\t\t\t|| ASCII_ISALPHA(in_vim9script() ? *skipwhite(p + 2)\n\t\t\t\t\t\t\t\t    : p[2])))))\n\t{\n\t    *arg = eval_next_line(evalarg);\n\t    p = *arg;\n\t    check_white = FALSE;\n\t}\n\n\tif (rettv->v_type == VAR_ANY)\n\t{\n\t    char_u\t*exp_name;\n\t    int\t\tcc;\n\t    int\t\tidx;\n\t    ufunc_T\t*ufunc;\n\t    type_T\t*type;\n\n\t    // Found script from \"import {name} as name\", script item name must\n\t    // follow.  \"rettv->vval.v_number\" has the script ID.\n\t    if (**arg != '.')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_expected_dot_after_name_str),\n\t\t\t\t\tname_start != NULL ? name_start: *arg);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    ++*arg;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // isolate the name\n\t    exp_name = *arg;\n\t    while (eval_isnamec(**arg))\n\t\t++*arg;\n\t    cc = **arg;\n\t    **arg = NUL;\n\n\t    idx = find_exported(rettv->vval.v_number, exp_name, &ufunc, &type,\n\t\t\t\t\t\t  evalarg->eval_cctx, verbose);\n\t    **arg = cc;\n\n\t    if (idx < 0 && ufunc == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (idx >= 0)\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(rettv->vval.v_number);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t\tcopy_tv(sv->sv_tv, rettv);\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_FUNC;\n\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t    }\n\t    continue;\n\t}\n\n\tif ((**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC\n\t\t\t    || rettv->v_type == VAR_PARTIAL))\n\t\t    && (!check_white || !VIM_ISWHITE(*(*arg - 1))))\n\t{\n\t    ret = call_func_rettv(arg, evalarg, rettv, evaluate,\n\t\t\t\t\t\t\t       selfdict, NULL);\n\n\t    // Stop the expression evaluation when immediately aborting on\n\t    // error, or when an interrupt occurred or an exception was thrown\n\t    // but not caught.\n\t    if (aborting())\n\t    {\n\t\tif (ret == OK)\n\t\t    clear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t    dict_unref(selfdict);\n\t    selfdict = NULL;\n\t}\n\telse if (p[0] == '-' && p[1] == '>')\n\t{\n\t    if (in_vim9script())\n\t\t*arg = skipwhite(p + 2);\n\t    else\n\t\t*arg = p + 2;\n\t    if (ret == OK)\n\t    {\n\t\tif (VIM_ISWHITE(**arg))\n\t\t{\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    ret = FAIL;\n\t\t}\n\t\telse if ((**arg == '{' && !in_vim9script()) || **arg == '(')\n\t\t    // expr->{lambda}() or expr->(lambda)()\n\t\t    ret = eval_lambda(arg, rettv, evalarg, verbose);\n\t\telse\n\t\t    // expr->name()\n\t\t    ret = eval_method(arg, rettv, evalarg, verbose);\n\t    }\n\t}\n\t// \".\" is \".name\" lookup when we found a dict or when evaluating and\n\t// scriptversion is at least 2, where string concatenation is \"..\".\n\telse if (**arg == '['\n\t\t|| (**arg == '.' && (rettv->v_type == VAR_DICT\n\t\t\t|| (!evaluate\n\t\t\t    && (*arg)[1] != '.'\n\t\t\t    && !in_old_script(2)))))\n\t{\n\t    dict_unref(selfdict);\n\t    if (rettv->v_type == VAR_DICT)\n\t    {\n\t\tselfdict = rettv->vval.v_dict;\n\t\tif (selfdict != NULL)\n\t\t    ++selfdict->dv_refcount;\n\t    }\n\t    else\n\t\tselfdict = NULL;\n\t    if (eval_index(arg, rettv, evalarg, verbose) == FAIL)\n\t    {\n\t\tclear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // Don't do this when \"Func\" is already a partial that was bound\n    // explicitly (pt_auto is FALSE).\n    if (selfdict != NULL\n\t    && (rettv->v_type == VAR_FUNC\n\t\t|| (rettv->v_type == VAR_PARTIAL\n\t\t    && (rettv->vval.v_partial->pt_auto\n\t\t\t|| rettv->vval.v_partial->pt_dict == NULL))))\n\tselfdict = make_partial(selfdict, rettv);\n\n    dict_unref(selfdict);\n    return ret;\n}\n\n/*\n * Make a copy of an item.\n * Lists and Dictionaries are also copied.  A deep copy if \"deep\" is set.\n * For deepcopy() \"copyID\" is zero for a full copy or the ID for when a\n * reference to an already copied list/dict can be used.\n * Returns FAIL or OK.\n */\n    int\nitem_copy(\n    typval_T\t*from,\n    typval_T\t*to,\n    int\t\tdeep,\n    int\t\tcopyID)\n{\n    static int\trecurse = 0;\n    int\t\tret = OK;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_making_copy));\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_FLOAT:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    copy_tv(from, to);\n\t    break;\n\tcase VAR_LIST:\n\t    to->v_type = VAR_LIST;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else if (copyID != 0 && from->vval.v_list->lv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_list = from->vval.v_list->lv_copylist;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_list = list_copy(from->vval.v_list, deep, copyID);\n\t    if (to->vval.v_list == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_BLOB:\n\t    ret = blob_copy(from->vval.v_blob, to);\n\t    break;\n\tcase VAR_DICT:\n\t    to->v_type = VAR_DICT;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_dict = from->vval.v_dict->dv_copydict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_dict = dict_copy(from->vval.v_dict, deep, copyID);\n\t    if (to->vval.v_dict == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    internal_error_no_abort(\"item_copy(UNKNOWN)\");\n\t    ret = FAIL;\n    }\n    --recurse;\n    return ret;\n}\n\n    void\necho_one(typval_T *rettv, int with_space, int *atstart, int *needclr)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*p = echo_string(rettv, &tofree, numbuf, get_copyID());\n\n    if (*atstart)\n    {\n\t*atstart = FALSE;\n\t// Call msg_start() after eval1(), evaluating the expression\n\t// may cause a message to appear.\n\tif (with_space)\n\t{\n\t    // Mark the saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back\n\t    // at the more prompt.\n\t    msg_sb_eol();\n\t    msg_start();\n\t}\n    }\n    else if (with_space)\n\tmsg_puts_attr(\" \", echo_attr);\n\n    if (p != NULL)\n\tfor ( ; *p != NUL && !got_int; ++p)\n\t{\n\t    if (*p == '\\n' || *p == '\\r' || *p == TAB)\n\t    {\n\t\tif (*p != TAB && *needclr)\n\t\t{\n\t\t    // remove any text still there from the command\n\t\t    msg_clr_eos();\n\t\t    *needclr = FALSE;\n\t\t}\n\t\tmsg_putchar_attr(*p, echo_attr);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int i = (*mb_ptr2len)(p);\n\n\t\t    (void)msg_outtrans_len_attr(p, i, echo_attr);\n\t\t    p += i - 1;\n\t\t}\n\t\telse\n\t\t    (void)msg_outtrans_len_attr(p, 1, echo_attr);\n\t    }\n\t}\n    vim_free(tofree);\n}\n\n/*\n * \":echo expr1 ...\"\tprint each argument separated with a space, add a\n *\t\t\tnewline at the end.\n * \":echon expr1 ...\"\tprint each argument plain.\n */\n    void\nex_echo(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    char_u\t*arg_start;\n    int\t\tneedclr = TRUE;\n    int\t\tatstart = TRUE;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while ((!ends_excmd2(eap->cmd, arg) || *arg == '\"') && !got_int)\n    {\n\t// If eval1() causes an error message the text from the command may\n\t// still need to be cleared. E.g., \"echo 22,44\".\n\tneed_clr_eos = needclr;\n\n\targ_start = arg;\n\tif (eval1(&arg, &rettv, &evalarg) == FAIL)\n\t{\n\t    /*\n\t     * Report the invalid expression unless the expression evaluation\n\t     * has been cancelled due to an aborting error, an interrupt, or an\n\t     * exception.\n\t     */\n\t    if (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t\tsemsg(_(e_invalid_expression_str), arg_start);\n\t    need_clr_eos = FALSE;\n\t    break;\n\t}\n\tneed_clr_eos = FALSE;\n\n\tif (!eap->skip)\n\t{\n\t    if (rettv.v_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), arg_start);\n\t\tbreak;\n\t    }\n\t    echo_one(&rettv, eap->cmdidx == CMD_echo, &atstart, &needclr);\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n    set_nextcmd(eap, arg);\n    clear_evalarg(&evalarg, eap);\n\n    if (eap->skip)\n\t--emsg_skip;\n    else\n    {\n\t// remove text that may still be there from the command\n\tif (needclr)\n\t    msg_clr_eos();\n\tif (eap->cmdidx == CMD_echo)\n\t    msg_end();\n    }\n}\n\n/*\n * \":echohl {name}\".\n */\n    void\nex_echohl(exarg_T *eap)\n{\n    echo_attr = syn_name2attr(eap->arg);\n}\n\n/*\n * Returns the :echo attribute\n */\n    int\nget_echo_attr(void)\n{\n    return echo_attr;\n}\n\n/*\n * \":execute expr1 ...\"\texecute the result of an expression.\n * \":echomsg expr1 ...\"\tPrint a message\n * \":echoerr expr1 ...\"\tPrint an error\n * \":echoconsole expr1 ...\" Print a message on stdout\n * Each gets spaces around each argument and a newline at the end for\n * echo commands\n */\n    void\nex_execute(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\tret = OK;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\tlen;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    ga_init2(&ga, 1, 80);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while (!ends_excmd2(eap->cmd, arg) || *arg == '\"')\n    {\n\tret = eval1_emsg(&arg, &rettv, eap);\n\tif (ret == FAIL)\n\t    break;\n\n\tif (!eap->skip)\n\t{\n\t    char_u   buf[NUMBUFLEN];\n\n\t    if (eap->cmdidx == CMD_execute)\n\t    {\n\t\tif (rettv.v_type == VAR_CHANNEL || rettv.v_type == VAR_JOB)\n\t\t{\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(rettv.v_type));\n\t\t    p = NULL;\n\t\t}\n\t\telse\n\t\t    p = tv_get_string_buf(&rettv, buf);\n\t    }\n\t    else\n\t\tp = tv_stringify(&rettv, buf);\n\t    if (p == NULL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    len = (int)STRLEN(p);\n\t    if (ga_grow(&ga, len + 2) == FAIL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (ga.ga_len)\n\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t    ga.ga_len += len;\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n\n    if (ret != FAIL && ga.ga_data != NULL)\n    {\n\t// use the first line of continuation lines for messages\n\tSOURCING_LNUM = start_lnum;\n\n\tif (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr)\n\t{\n\t    // Mark the already saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back at the\n\t    // more prompt.\n\t    msg_sb_eol();\n\t}\n\n\tif (eap->cmdidx == CMD_echomsg)\n\t{\n\t    msg_attr(ga.ga_data, echo_attr);\n\t    out_flush();\n\t}\n\telse if (eap->cmdidx == CMD_echoconsole)\n\t{\n\t    ui_write(ga.ga_data, (int)STRLEN(ga.ga_data), TRUE);\n\t    ui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t}\n\telse if (eap->cmdidx == CMD_echoerr)\n\t{\n\t    int\t\tsave_did_emsg = did_emsg;\n\n\t    // We don't want to abort following commands, restore did_emsg.\n\t    emsg(ga.ga_data);\n\t    if (!force_abort)\n\t\tdid_emsg = save_did_emsg;\n\t}\n\telse if (eap->cmdidx == CMD_execute)\n\t    do_cmdline((char_u *)ga.ga_data,\n\t\t       eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);\n    }\n\n    ga_clear(&ga);\n\n    if (eap->skip)\n\t--emsg_skip;\n\n    set_nextcmd(eap, arg);\n}\n\n/*\n * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\".\n * \"arg\" points to the \"&\" or '+' when called, to \"option\" when returning.\n * Returns NULL when no option name found.  Otherwise pointer to the char\n * after the option name.\n */\n    char_u *\nfind_option_end(char_u **arg, int *scope)\n{\n    char_u\t*p = *arg;\n\n    ++p;\n    if (*p == 'g' && p[1] == ':')\n    {\n\t*scope = OPT_GLOBAL;\n\tp += 2;\n    }\n    else if (*p == 'l' && p[1] == ':')\n    {\n\t*scope = OPT_LOCAL;\n\tp += 2;\n    }\n    else\n\t*scope = 0;\n\n    if (!ASCII_ISALPHA(*p))\n\treturn NULL;\n    *arg = p;\n\n    if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL)\n\tp += 4;\t    // termcap option\n    else\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n    return p;\n}\n\n/*\n * Display script name where an item was last set.\n * Should only be invoked when 'verbose' is non-zero.\n */\n    void\nlast_set_msg(sctx_T script_ctx)\n{\n    char_u *p;\n\n    if (script_ctx.sc_sid != 0)\n    {\n\tp = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));\n\tif (p != NULL)\n\t{\n\t    verbose_enter();\n\t    msg_puts(_(\"\\n\\tLast set from \"));\n\t    msg_puts((char *)p);\n\t    if (script_ctx.sc_lnum > 0)\n\t    {\n\t\tmsg_puts(_(line_msg));\n\t\tmsg_outnum((long)script_ctx.sc_lnum);\n\t    }\n\t    verbose_leave();\n\t    vim_free(p);\n\t}\n    }\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Perform a substitution on \"str\" with pattern \"pat\" and substitute \"sub\".\n * When \"sub\" is NULL \"expr\" is used, must be a VAR_FUNC or VAR_PARTIAL.\n * \"flags\" can be \"g\" to do a global substitute.\n * Returns an allocated string, NULL for error.\n */\n    char_u *\ndo_string_sub(\n    char_u\t*str,\n    char_u\t*pat,\n    char_u\t*sub,\n    typval_T\t*expr,\n    char_u\t*flags)\n{\n    int\t\tsublen;\n    regmatch_T\tregmatch;\n    int\t\ti;\n    int\t\tdo_all;\n    char_u\t*tail;\n    char_u\t*end;\n    garray_T\tga;\n    char_u\t*ret;\n    char_u\t*save_cpo;\n    char_u\t*zero_width = NULL;\n\n    // Make 'cpoptions' empty, so that the 'l' flag doesn't work here\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n\n    ga_init2(&ga, 1, 200);\n\n    do_all = (flags[0] == 'g');\n\n    regmatch.rm_ic = p_ic;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\ttail = str;\n\tend = str + STRLEN(str);\n\twhile (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))\n\t{\n\t    // Skip empty match except for first match.\n\t    if (regmatch.startp[0] == regmatch.endp[0])\n\t    {\n\t\tif (zero_width == regmatch.startp[0])\n\t\t{\n\t\t    // avoid getting stuck on a match with an empty string\n\t\t    i = mb_ptr2len(tail);\n\t\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,\n\t\t\t\t\t\t\t\t   (size_t)i);\n\t\t    ga.ga_len += i;\n\t\t    tail += i;\n\t\t    continue;\n\t\t}\n\t\tzero_width = regmatch.startp[0];\n\t    }\n\n\t    /*\n\t     * Get some space for a temporary buffer to do the substitution\n\t     * into.  It will contain:\n\t     * - The text up to where the match is.\n\t     * - The substituted text.\n\t     * - The text after the match.\n\t     */\n\t    sublen = vim_regsub(&regmatch, sub, expr, tail, FALSE, TRUE, FALSE);\n\t    if (ga_grow(&ga, (int)((end - tail) + sublen -\n\t\t\t    (regmatch.endp[0] - regmatch.startp[0]))) == FAIL)\n\t    {\n\t\tga_clear(&ga);\n\t\tbreak;\n\t    }\n\n\t    // copy the text up to where the match is\n\t    i = (int)(regmatch.startp[0] - tail);\n\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n\t    // add the substituted text\n\t    (void)vim_regsub(&regmatch, sub, expr, (char_u *)ga.ga_data\n\t\t\t\t\t  + ga.ga_len + i, TRUE, TRUE, FALSE);\n\t    ga.ga_len += i + sublen - 1;\n\t    tail = regmatch.endp[0];\n\t    if (*tail == NUL)\n\t\tbreak;\n\t    if (!do_all)\n\t\tbreak;\n\t}\n\n\tif (ga.ga_data != NULL)\n\t    STRCPY((char *)ga.ga_data + ga.ga_len, tail);\n\n\tvim_regfree(regmatch.regprog);\n    }\n\n    ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);\n    ga_clear(&ga);\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, evaluating {sub} expression or {expr} changed the value.\n\t// If it's still empty it was changed and restored, need to restore in\n\t// the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tfree_string_option(save_cpo);\n    }\n\n    return ret;\n}\n", "\" Tests for various eval things.\n\nsource view_util.vim\n\nfunction s:foo() abort\n  try\n    return [] == 0\n  catch\n    return 1\n  endtry\nendfunction\n\nfunc Test_catch_return_with_error()\n  call assert_equal(1, s:foo())\nendfunc\n\nfunc Test_nocatch_restore_silent_emsg()\n  silent! try\n    throw 1\n  catch\n  endtry\n  echoerr 'wrong again'\n  call assert_equal('wrong again', ScreenLine(&lines))\nendfunc\n\nfunc Test_mkdir_p()\n  call mkdir('Xmkdir/nested', 'p')\n  call assert_true(isdirectory('Xmkdir/nested'))\n  try\n    \" Trying to make existing directories doesn't error\n    call mkdir('Xmkdir', 'p')\n    call mkdir('Xmkdir/nested', 'p')\n  catch /E739:/\n    call assert_report('mkdir(..., \"p\") failed for an existing directory')\n  endtry\n  \" 'p' doesn't suppress real errors\n  call writefile([], 'Xfile')\n  call assert_fails('call mkdir(\"Xfile\", \"p\")', 'E739:')\n  call delete('Xfile')\n  call delete('Xmkdir', 'rf')\n  call assert_equal(0, mkdir(test_null_string()))\n  call assert_fails('call mkdir([])', 'E730:')\n  call assert_fails('call mkdir(\"abc\", [], [])', 'E745:')\nendfunc\n\nfunc Test_line_continuation()\n  let array = [5,\n\t\"\\ ignore this\n\t\\ 6,\n\t\"\\ more to ignore\n\t\"\\ more moreto ignore\n\t\\ ]\n\t\"\\ and some more\n  call assert_equal([5, 6], array)\nendfunc\n\nfunc Test_E963()\n  \" These commands used to cause an internal error prior to vim 8.1.0563\n  let v_e = v:errors\n  let v_o = v:oldfiles\n  call assert_fails(\"let v:errors=''\", 'E963:')\n  call assert_equal(v_e, v:errors)\n  call assert_fails(\"let v:oldfiles=''\", 'E963:')\n  call assert_equal(v_o, v:oldfiles)\nendfunc\n\nfunc Test_for_invalid()\n  call assert_fails(\"for x in 99\", 'E1098:')\n  call assert_fails(\"for x in function('winnr')\", 'E1098:')\n  call assert_fails(\"for x in {'a': 9}\", 'E1098:')\n\n  if 0\n    /1/5/2/s/\\n\n  endif\n  redraw\nendfunc\n\nfunc Test_readfile_binary()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  setlocal ff=dos\n  silent write XReadfile_bin\n  let lines = 'XReadfile_bin'->readfile()\n  call assert_equal(['one', 'two', 'three'], lines)\n  let lines = readfile('XReadfile_bin', '', 2)\n  call assert_equal(['one', 'two'], lines)\n  let lines = readfile('XReadfile_bin', 'b')\n  call assert_equal([\"one\\r\", \"two\\r\", \"three\\r\", \"\"], lines)\n  let lines = readfile('XReadfile_bin', 'b', 2)\n  call assert_equal([\"one\\r\", \"two\\r\"], lines)\n\n  bwipe!\n  call delete('XReadfile_bin')\nendfunc\n\nfunc Test_readfile_binary_empty()\n  call writefile([], 'Xempty-file')\n  \" This used to compare uninitialized memory in Vim <= 8.2.4065\n  call assert_equal([''], readfile('Xempty-file', 'b'))\n  call delete('Xempty-file')\nendfunc\n\nfunc Test_readfile_bom()\n  call writefile([\"\\ufeffFOO\", \"FOO\\ufeffBAR\"], 'XReadfile_bom')\n  call assert_equal(['FOO', 'FOOBAR'], readfile('XReadfile_bom'))\n  call delete('XReadfile_bom')\nendfunc\n\nfunc Test_readfile_max()\n  call writefile(range(1, 4), 'XReadfile_max')\n  call assert_equal(['1', '2'], readfile('XReadfile_max', '', 2))\n  call assert_equal(['3', '4'], readfile('XReadfile_max', '', -2))\n  call delete('XReadfile_max')\nendfunc\n\nfunc Test_let_errmsg()\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\nendfunc\n\nfunc Test_string_concatenation()\n  call assert_equal('ab', 'a'.'b')\n  call assert_equal('ab', 'a' .'b')\n  call assert_equal('ab', 'a'. 'b')\n  call assert_equal('ab', 'a' . 'b')\n\n  call assert_equal('ab', 'a'..'b')\n  call assert_equal('ab', 'a' ..'b')\n  call assert_equal('ab', 'a'.. 'b')\n  call assert_equal('ab', 'a' .. 'b')\n\n  let a = 'a'\n  let b = 'b'\n  let a .= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a.=b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a ..= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a..=b\n  call assert_equal('ab', a)\n\n  if has('float')\n    let a = 'A'\n    let b = 1.234\n    call assert_equal('A1.234', a .. b)\n  endif\nendfunc\n\n\" Test fix for issue #4507\nfunc Test_skip_after_throw()\n  try\n    throw 'something'\n    let x = wincol() || &ts\n  catch /something/\n  endtry\nendfunc\n\nscriptversion 2\nfunc Test_string_concat_scriptversion2()\n  call assert_true(has('vimscript-2'))\n  let a = 'a'\n  let b = 'b'\n\n  call assert_fails('echo a . b', 'E15:')\n  call assert_fails('let a .= b', 'E985:')\n  call assert_fails('let vers = 1.2.3', 'E488:')\n\n  if has('float')\n    let f = .5\n    call assert_equal(0.5, f)\n  endif\nendfunc\n\nscriptversion 1\nfunc Test_string_concat_scriptversion1()\n  call assert_true(has('vimscript-1'))\n  let a = 'a'\n  let b = 'b'\n\n  echo a . b\n  let a .= b\n  let vers = 1.2.3\n  call assert_equal('123', vers)\n\n  if has('float')\n    call assert_fails('let f = .5', 'E15:')\n  endif\nendfunc\n\nscriptversion 3\nfunc Test_vvar_scriptversion3()\n  call assert_true(has('vimscript-3'))\n  call assert_fails('echo version', 'E121:')\n  call assert_false(exists('version'))\n  let version = 1\n  call assert_equal(1, version)\nendfunc\n\nscriptversion 2\nfunc Test_vvar_scriptversion2()\n  call assert_true(exists('version'))\n  echo version\n  call assert_fails('let version = 1', 'E46:')\n  call assert_equal(v:version, version)\n\n  call assert_equal(v:version, v:versionlong / 10000)\n  call assert_true(v:versionlong > 8011525)\nendfunc\n\nfunc Test_dict_access_scriptversion2()\n  let l:x = {'foo': 1}\n\n  call assert_false(0 && l:x.foo)\n  call assert_true(1 && l:x.foo)\nendfunc\n\nscriptversion 4\nfunc Test_vvar_scriptversion4()\n  call assert_true(has('vimscript-4'))\n  call assert_equal(17, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\n  call assert_equal(64, 0b1'00'00'00)\n  call assert_equal(1048576, 0x10'00'00)\n  call assert_equal(32768, 0o10'00'00)\n  call assert_equal(1000000, 1'000'000)\n  call assert_equal(\"1234\", execute(\"echo 1'234\")->trim())\n  call assert_equal('1  234', execute(\"echo 1''234\")->trim())\n  call assert_fails(\"echo 1'''234\", 'E115:')\nendfunc\n\nscriptversion 1\nfunc Test_vvar_scriptversion1()\n  call assert_equal(15, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\nendfunc\n\nfunc Test_scriptversion_fail()\n  call writefile(['scriptversion 9'], 'Xversionscript')\n  call assert_fails('source Xversionscript', 'E999:')\n  call delete('Xversionscript')\nendfunc\n\nfunc Test_execute_cmd_with_null()\n  call assert_fails('execute test_null_list()', 'E730:')\n  call assert_fails('execute test_null_dict()', 'E731:')\n  call assert_fails('execute test_null_blob()', 'E976:')\n  execute test_null_string()\n  call assert_fails('execute test_null_partial()', 'E729:')\n  call assert_fails('execute test_unknown()', 'E908:')\n  if has('job')\n    call assert_fails('execute test_null_job()', 'E908:')\n    call assert_fails('execute test_null_channel()', 'E908:')\n  endif\nendfunc\n\nfunc Test_number_max_min_size()\n  \" This will fail on systems without 64 bit number support or when not\n  \" configured correctly.\n  call assert_equal(64, v:numbersize)\n\n  call assert_true(v:numbermin < -9999999)\n  call assert_true(v:numbermax > 9999999)\nendfunc\n\nfunc Assert_reg(name, type, value, valuestr, expr, exprstr)\n  call assert_equal(a:type, getregtype(a:name))\n  call assert_equal(a:value, getreg(a:name))\n  call assert_equal(a:valuestr, string(getreg(a:name, 0, 1)))\n  call assert_equal(a:expr, getreg(a:name, 1))\n  call assert_equal(a:exprstr, string(getreg(a:name, 1, 1)))\nendfunc\n\nfunc Test_let_register()\n  let @\" = 'abc'\n  call Assert_reg('\"', 'v', \"abc\", \"['abc']\", \"abc\", \"['abc']\")\n  let @\" = \"abc\\n\"\n  call Assert_reg('\"', 'V', \"abc\\n\", \"['abc']\", \"abc\\n\", \"['abc']\")\n  let @\" = \"abc\\<C-m>\"\n  call Assert_reg('\"', 'V', \"abc\\r\\n\", \"['abc\\r']\", \"abc\\r\\n\", \"['abc\\r']\")\n  let @= = '\"abc\"'\n  call Assert_reg('=', 'v', \"abc\", \"['abc']\", '\"abc\"', \"['\\\"abc\\\"']\")\nendfunc\n\nfunc Assert_regput(name, result)\n  new\n  execute \"silent normal! o==\\n==\\e\\\"\" . a:name . \"P\"\n  call assert_equal(a:result, getline(2, line('$')))\n  bwipe!\nendfunc\n\nfunc Test_setreg_basic()\n  call setreg('a', 'abcA', 'c')\n  call Assert_reg('a', 'v', \"abcA\", \"['abcA']\", \"abcA\", \"['abcA']\")\n  call Assert_regput('a', ['==', '=abcA='])\n\n  call setreg('A', 'abcAc', 'c')\n  call Assert_reg('A', 'v', \"abcAabcAc\", \"['abcAabcAc']\", \"abcAabcAc\", \"['abcAabcAc']\")\n  call Assert_regput('a', ['==', '=abcAabcAc='])\n\n  call setreg('A', 'abcAl', 'l')\n  call Assert_reg('A', 'V', \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\", \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\")\n  call Assert_regput('a', ['==', 'abcAabcAcabcAl', '=='])\n\n  call setreg('A', 'abcAc2','c')\n  call Assert_reg('A', 'v', \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\", \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\")\n  call Assert_regput('a', ['==', '=abcAabcAcabcAl', 'abcAc2='])\n\n  call setreg('b', 'abcB', 'v')\n  call Assert_reg('b', 'v', \"abcB\", \"['abcB']\", \"abcB\", \"['abcB']\")\n  call Assert_regput('b', ['==', '=abcB='])\n\n  call setreg('b', 'abcBc', 'ca')\n  call Assert_reg('b', 'v', \"abcBabcBc\", \"['abcBabcBc']\", \"abcBabcBc\", \"['abcBabcBc']\")\n  call Assert_regput('b', ['==', '=abcBabcBc='])\n\n  call setreg('b', 'abcBb', 'ba')\n  call Assert_reg('b', \"\\<C-V>5\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb='])\n\n  call setreg('b', 'abcBc2','ca')\n  call Assert_reg('b', \"v\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb', 'abcBc2='])\n\n  call setreg('b', 'abcBb2','b50a')\n  call Assert_reg('b', \"\\<C-V>50\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb                                    =', ' abcBc2abcBb2'])\n\n  call setreg('c', 'abcC', 'l')\n  call Assert_reg('c', 'V', \"abcC\\n\", \"['abcC']\", \"abcC\\n\", \"['abcC']\")\n  call Assert_regput('c', ['==', 'abcC', '=='])\n\n  call setreg('C', 'abcCl', 'l')\n  call Assert_reg('C', 'V', \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\", \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\")\n  call Assert_regput('c', ['==', 'abcC', 'abcCl', '=='])\n\n  call setreg('C', 'abcCc', 'c')\n  call Assert_reg('C', 'v', \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\", \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\")\n  call Assert_regput('c', ['==', '=abcC', 'abcCl', 'abcCc='])\n\n  call setreg('d', 'abcD', 'V')\n  call Assert_reg('d', 'V', \"abcD\\n\", \"['abcD']\", \"abcD\\n\", \"['abcD']\")\n  call Assert_regput('d', ['==', 'abcD', '=='])\n\n  call setreg('D', 'abcDb', 'b')\n  call Assert_reg('d', \"\\<C-V>5\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\")\n  call Assert_regput('d', ['==', '=abcD =', ' abcDb'])\n\n  call setreg('e', 'abcE', 'b')\n  call Assert_reg('e', \"\\<C-V>4\", \"abcE\", \"['abcE']\", \"abcE\", \"['abcE']\")\n  call Assert_regput('e', ['==', '=abcE='])\n\n  call setreg('E', 'abcEb', 'b')\n  call Assert_reg('E', \"\\<C-V>5\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\")\n  call Assert_regput('e', ['==', '=abcE =', ' abcEb'])\n\n  call setreg('E', 'abcEl', 'l')\n  call Assert_reg('E', \"V\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\")\n  call Assert_regput('e', ['==', 'abcE', 'abcEb', 'abcEl', '=='])\n\n  call setreg('f', 'abcF', \"\\<C-v>\")\n  call Assert_reg('f', \"\\<C-V>4\", \"abcF\", \"['abcF']\", \"abcF\", \"['abcF']\")\n  call Assert_regput('f', ['==', '=abcF='])\n\n  call setreg('F', 'abcFc', 'c')\n  call Assert_reg('F', \"v\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\")\n  call Assert_regput('f', ['==', '=abcF', 'abcFc='])\n\n  call setreg('g', 'abcG', 'b10')\n  call Assert_reg('g', \"\\<C-V>10\", \"abcG\", \"['abcG']\", \"abcG\", \"['abcG']\")\n  call Assert_regput('g', ['==', '=abcG      ='])\n\n  call setreg('h', 'abcH', \"\\<C-v>10\")\n  call Assert_reg('h', \"\\<C-V>10\", \"abcH\", \"['abcH']\", \"abcH\", \"['abcH']\")\n  call Assert_regput('h', ['==', '=abcH      ='])\n\n  call setreg('I', 'abcI')\n  call Assert_reg('I', \"v\", \"abcI\", \"['abcI']\", \"abcI\", \"['abcI']\")\n  call Assert_regput('I', ['==', '=abcI='])\n\n  \" Appending NL with setreg()\n  call setreg('a', 'abcA2', 'c')\n  call setreg('b', 'abcB2', 'v')\n  call setreg('c', 'abcC2', 'l')\n  call setreg('d', 'abcD2', 'V')\n  call setreg('e', 'abcE2', 'b')\n  call setreg('f', 'abcF2', \"\\<C-v>\")\n  call setreg('g', 'abcG2', 'b10')\n  call setreg('h', 'abcH2', \"\\<C-v>10\")\n  call setreg('I', 'abcI2')\n\n  call setreg('A', \"\\n\")\n  call Assert_reg('A', 'V', \"abcA2\\n\", \"['abcA2']\", \"abcA2\\n\", \"['abcA2']\")\n  call Assert_regput('A', ['==', 'abcA2', '=='])\n\n  call setreg('B', \"\\n\", 'c')\n  call Assert_reg('B', 'v', \"abcB2\\n\", \"['abcB2', '']\", \"abcB2\\n\", \"['abcB2', '']\")\n  call Assert_regput('B', ['==', '=abcB2', '='])\n\n  call setreg('C', \"\\n\")\n  call Assert_reg('C', 'V', \"abcC2\\n\\n\", \"['abcC2', '']\", \"abcC2\\n\\n\", \"['abcC2', '']\")\n  call Assert_regput('C', ['==', 'abcC2', '', '=='])\n\n  call setreg('D', \"\\n\", 'l')\n  call Assert_reg('D', 'V', \"abcD2\\n\\n\", \"['abcD2', '']\", \"abcD2\\n\\n\", \"['abcD2', '']\")\n  call Assert_regput('D', ['==', 'abcD2', '', '=='])\n\n  call setreg('E', \"\\n\")\n  call Assert_reg('E', 'V', \"abcE2\\n\\n\", \"['abcE2', '']\", \"abcE2\\n\\n\", \"['abcE2', '']\")\n  call Assert_regput('E', ['==', 'abcE2', '', '=='])\n\n  call setreg('F', \"\\n\", 'b')\n  call Assert_reg('F', \"\\<C-V>0\", \"abcF2\\n\", \"['abcF2', '']\", \"abcF2\\n\", \"['abcF2', '']\")\n  call Assert_regput('F', ['==', '=abcF2=', ' '])\n\n  \" Setting lists with setreg()\n  call setreg('a', ['abcA3'], 'c')\n  call Assert_reg('a', 'v', \"abcA3\", \"['abcA3']\", \"abcA3\", \"['abcA3']\")\n  call Assert_regput('a', ['==', '=abcA3='])\n\n  call setreg('b', ['abcB3'], 'l')\n  call Assert_reg('b', 'V', \"abcB3\\n\", \"['abcB3']\", \"abcB3\\n\", \"['abcB3']\")\n  call Assert_regput('b', ['==', 'abcB3', '=='])\n\n  call setreg('c', ['abcC3'], 'b')\n  call Assert_reg('c', \"\\<C-V>5\", \"abcC3\", \"['abcC3']\", \"abcC3\", \"['abcC3']\")\n  call Assert_regput('c', ['==', '=abcC3='])\n\n  call setreg('d', ['abcD3'])\n  call Assert_reg('d', 'V', \"abcD3\\n\", \"['abcD3']\", \"abcD3\\n\", \"['abcD3']\")\n  call Assert_regput('d', ['==', 'abcD3', '=='])\n\n  call setreg('e', [1, 2, 'abc', 3])\n  call Assert_reg('e', 'V', \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\", \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\")\n  call Assert_regput('e', ['==', '1', '2', 'abc', '3', '=='])\n\n  call setreg('f', [1, 2, 3])\n  call Assert_reg('f', 'V', \"1\\n2\\n3\\n\", \"['1', '2', '3']\", \"1\\n2\\n3\\n\", \"['1', '2', '3']\")\n  call Assert_regput('f', ['==', '1', '2', '3', '=='])\n\n  \" Appending lists with setreg()\n  call setreg('A', ['abcA3c'], 'c')\n  call Assert_reg('A', 'v', \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\", \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\")\n  call Assert_regput('A', ['==', '=abcA3', 'abcA3c='])\n\n  call setreg('b', ['abcB3l'], 'la')\n  call Assert_reg('b', 'V', \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\", \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\")\n  call Assert_regput('b', ['==', 'abcB3', 'abcB3l', '=='])\n\n  call setreg('C', ['abcC3b'], 'lb')\n  call Assert_reg('C', \"\\<C-V>6\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\")\n  call Assert_regput('C', ['==', '=abcC3 =', ' abcC3b'])\n\n  call setreg('D', ['abcD32'])\n  call Assert_reg('D', 'V', \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\", \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\")\n  call Assert_regput('D', ['==', 'abcD3', 'abcD32', '=='])\n\n  call setreg('A', ['abcA32'])\n  call Assert_reg('A', 'V', \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\", \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', '=='])\n\n  call setreg('B', ['abcB3c'], 'c')\n  call Assert_reg('B', 'v', \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\", \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c='])\n\n  call setreg('C', ['abcC3l'], 'l')\n  call Assert_reg('C', 'V', \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\", \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\")\n  call Assert_regput('C', ['==', 'abcC3', 'abcC3b', 'abcC3l', '=='])\n\n  call setreg('D', ['abcD3b'], 'b')\n  call Assert_reg('D', \"\\<C-V>6\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\")\n  call Assert_regput('D', ['==', '=abcD3 =', ' abcD32', ' abcD3b'])\n\n  \" Appending lists with NL with setreg()\n  call setreg('A', [\"\\n\", 'abcA3l2'], 'l')\n  call Assert_reg('A', \"V\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', \"\\n\", 'abcA3l2', '=='])\n\n  call setreg('B', [\"\\n\", 'abcB3c2'], 'c')\n  call Assert_reg('B', \"v\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c', \"\\n\", 'abcB3c2='])\n\n  call setreg('C', [\"\\n\", 'abcC3b2'], 'b')\n  call Assert_reg('C', \"\u00167\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\")\n  call Assert_regput('C', ['==', '=abcC3  =', ' abcC3b', ' abcC3l', \" \\n\", ' abcC3b2'])\n\n  call setreg('D', [\"\\n\", 'abcD3b50'],'b50')\n  call Assert_reg('D', \"\u001650\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\")\n  call Assert_regput('D', ['==', '=abcD3                                             =', ' abcD32', ' abcD3b', \" \\n\", ' abcD3b50'])\n\n  \" Setting lists with NLs with setreg()\n  call setreg('a', ['abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\"])\n  call Assert_reg('a', \"V\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\")\n  call Assert_regput('a', ['==', 'abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\", '=='])\n\n  call setreg('b', ['abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2\"], 'c')\n  call Assert_reg('b', \"v\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\")\n  call Assert_regput('b', ['==', '=abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2=\"])\n\n  call setreg('c', ['abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\"], 'l')\n  call Assert_reg('c', \"V\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\")\n  call Assert_regput('c', ['==', 'abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\", '=='])\n\n  call setreg('d', ['abcD4b-0', \"\\n\", \"abcD4b-2\\n\", \"\\nabcD4b-3\", \"abcD4b-4\\nabcD4b-4-2\"], 'b')\n  call Assert_reg('d', \"\u001619\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\")\n  call Assert_regput('d', ['==', '=abcD4b-0           =', \" \\n\", \" abcD4b-2\\n\", \" \\nabcD4b-3\", \" abcD4b-4\\nabcD4b-4-2\"])\n\n  call setreg('e', ['abcE4b10-0', \"\\n\", \"abcE4b10-2\\n\", \"\\nabcE4b10-3\", \"abcE4b10-4\\nabcE4b10-4-2\"], 'b10')\n  call Assert_reg('e', \"\u001610\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\")\n  call Assert_regput('e', ['==', '=abcE4b10-0=', \" \\n\", \" abcE4b10-2\\n\", \" \\nabcE4b10-3\", \" abcE4b10-4\\nabcE4b10-4-2\"])\n\n  \" Search and expressions\n  call setreg('/', ['abc/'])\n  call Assert_reg('/', 'v', \"abc/\", \"['abc/']\", \"abc/\", \"['abc/']\")\n  call Assert_regput('/', ['==', '=abc/='])\n\n  call setreg('/', [\"abc/\\n\"])\n  call Assert_reg('/', 'v', \"abc/\\n\", \"['abc/\\n']\", \"abc/\\n\", \"['abc/\\n']\")\n  call Assert_regput('/', ['==', \"=abc/\\n=\"])\n\n  call setreg('=', ['\"abc/\"'])\n  call Assert_reg('=', 'v', \"abc/\", \"['abc/']\", '\"abc/\"', \"['\\\"abc/\\\"']\")\n\n  call setreg('=', [\"\\\"abc/\\n\\\"\"])\n  call Assert_reg('=', 'v', \"abc/\\n\", \"['abc/\\n']\", \"\\\"abc/\\n\\\"\", \"['\\\"abc/\\n\\\"']\")\n\n  \" System clipboard\n  if has('clipboard')\n    new | only!\n    call setline(1, ['clipboard contents', 'something else'])\n    \" Save and restore system clipboard.\n    \" If no connection to X-Server is possible, test should succeed.\n    let _clipreg = ['*', getreg('*'), getregtype('*')]\n    let _clipopt = &cb\n    let &cb='unnamed'\n    1y\n    call Assert_reg('*', 'V', \"clipboard contents\\n\", \"['clipboard contents']\", \"clipboard contents\\n\", \"['clipboard contents']\")\n    tabdo :windo :echo \"hi\"\n    2y\n    call Assert_reg('*', 'V', \"something else\\n\", \"['something else']\", \"something else\\n\", \"['something else']\")\n    let &cb=_clipopt\n    call call('setreg', _clipreg)\n    enew!\n  endif\n\n  \" Error cases\n  call assert_fails('call setreg()', 'E119:')\n  call assert_fails('call setreg(1)', 'E119:')\n  call assert_fails('call setreg(1, 2, 3, 4)', 'E118:')\n  call assert_fails('call setreg([], 2)', 'E730:')\n  call assert_fails('call setreg(1, 2, [])', 'E730:')\n  call assert_fails('call setreg(\"/\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(\"=\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(1, [\"\", \"\", [], \"\"])', 'E730:')\nendfunc\n\nfunc Test_curly_assignment()\n  let s:svar = 'svar'\n  let g:gvar = 'gvar'\n  let lname = 'gvar'\n  let gname = 'gvar'\n  let {'s:'.lname} = {'g:'.gname}\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:'.lname } = { 'g:'.gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' . lname } = { 'g:' . gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' .. lname } = { 'g:' .. gname }\n  call assert_equal('gvar', s:gvar)\n\n  unlet s:svar\n  unlet s:gvar\n  unlet g:gvar\nendfunc\n\nfunc Test_deep_recursion()\n  \" this was running out of stack\n  call assert_fails(\"exe 'if ' .. repeat('(', 1002)\", 'E1169: Expression too recursive: ((')\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/errors.h", "src/eval.c", "src/testdir/test_eval_stuff.vim", "src/version.c"], "buggy_code_start_loc": [2720, 3528, 592, 752], "buggy_code_end_loc": [2970, 3783, 592, 752], "fixing_code_start_loc": [2721, 3529, 593, 753], "fixing_code_end_loc": [2975, 3796, 598, 755], "type": "CWE-119", "message": "Access of Memory Location Before Start of Buffer in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-0351", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-25T18:15:08.100", "lastModified": "2022-11-09T19:20:23.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Access of Memory Location Before Start of Buffer in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Acceso a la ubicaci\u00f3n de la memoria antes del inicio del b\u00fafer en el repositorio GitHub vim/vim anterior a 8.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-786"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2", "matchCriteriaId": "8E36296E-EE72-4469-A40D-73AF3C7C1825"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.6", "matchCriteriaId": "0B4BB820-002E-4847-B630-F826B18100A5"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/43", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8b36db58-b65c-4298-be7f-40b9e37fd161", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213444", "source": "security@huntr.dev", "tags": ["Vendor Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d"}}