{"buggy_code": ["<?php\n\n/**\n * QtranslateSlug class\n *\n * @since 1.0\n */\nclass QtranslateSlug {\n    \n    \n    /**\n     * array with old data system\n     *\n     * @var bool\n     *\n     * @since 1.0\n     */\n    private $old_data = null;\n    \n    \n    \n    /**\n     * stores permalink_structure option, for save queries to db\n     *\n     * @var string\n     *\n     * @since 1.0\n     */\n    private $permalink_structure;\n    \n    \n    \n    /**\n     * Stores options slugs from database\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    protected $options;\n    \n    \n    \n    /**\n     * Variable used to override the language\n     *\n     * @var string\n     *\n     * @since 1.0\n     */\n    private $lang = false;\n\t\n\t/**\n\t * variable for current language\n\t */\n    private $current_lang = false;\n    \n    /**\n\t * variable for default language\n\t */\n    private $default_language = false;\n    \n\t/**\n     * Array of enabled languages\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    private $enabled_languages = array();\n\t/**\n     * Array of enabled languages\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    private $url_path_mode = \"\";\n\t\n    \n    \n    /**\n     * slug in meta_key name in meta tables\n     *\n     * @var string\n     *\n     * @since 1.0\n     */\n    private $meta_key = \"_qts_slug_%s\";\n    \n    \n    \n    /**\n     * Array of translated versions of the current url\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    private $current_url = array();\n    \n    \n    /**\n     * Variable that contains the prefix for base plugin function names (qtranslate/qtranslate-x)\n     *\n     * @var string\n     *\n     * @since ?\n     */\n    private $plugin_prefix = \"\";\n\t\n\t\n    /**\n     * return the current / temp language\n     *\n     * @since 1.0\n     */\n    private function get_lang() {\n        global $q_config;\n        \n        return ($this->lang) ? $this->lang : $q_config['language'];\n    }\n    /**\n     * return the current / temp language\n\t * we store and use it all the way!\n     *\n     * @since 1.1.9\n     */\n    private function get_currentlang() {\n        return $this->current_lang;\n    }\n    /**\n     * return the enabled languages\n\t * we store and use it all the way!\n     *\n     * @since 1.1.9\n     */\n    private function get_enabled_languages() {\n        return $this->enabled_languages;\n    }\n    /**\n     * return the enabled languages\n\t * we store and use it all the way!\n     *\n     * @since 1.1.9\n     */\n    private function get_url_path_mode() {\n        return $this->url_path_mode;\n    }\n    \n    \n    /**\n     * getter: options\n     *\n     * @since 1.0\n     */\n    public function get_options() {\n        $this->set_options();\n        return $this->options;\n    }\n\n    /**\n     * Returns the correct prefix for the function names of the different supported translation plugins.\n     * Will return 'qtranxf_' if qtranslate-x is used, 'qtrans_' otherwise.\n     *\n     * @return string the function name prefix for translation functions from other plugins\n     * @since 1.1.9\n     */\n\n    private function get_plugin_prefix(){\n        \n        return $this->plugin_prefix;\n    }\n    \n    \n    /**\n     * setter: options | permalink_structure\n     *\n     * @since 1.0\n     */\n    public function set_options() {\n\n        if (empty($this->options)) {\n            $this->options = get_option(QTS_OPTIONS_NAME);\n        }\n\n        if (!$this->options) {\n            add_option(QTS_OPTIONS_NAME, array());\n        }\n        \n        if (is_null($this->permalink_structure)) {\n            $this->permalink_structure = get_option('permalink_structure');\n        }\n    }\n    \n    /**\n\t * Sets the prefix for the active fork. See get_plugin_prefix\n\t * @since 1.1.9\n\t *\n\t */\n    private function set_plugin_prefix(){\n        if ('' === $this->plugin_prefix){\n            if (is_plugin_active('qtranslate-x/qtranslate.php')){\n                $this->plugin_prefix = 'qtranxf_';\n            } else {\n                $this->plugin_prefix = 'qtrans_';\n            }\n        }\n    }\n\n    /**\n     * Sets the url path mode based on the qtranslate or fork settings.\n     *\n     */\n\n    private function set_url_path_mode(){\n        if ('' === $this->url_path_mode){\n            if (is_plugin_active('qtranslate-x/qtranslate.php')){\n                $this->url_path_mode = QTX_URL_PATH;\n            } else {\n                $this->url_path_mode = QT_URL_PATH;\n            }\n        }\n    }\n    \n    /**\n     * setter: options | permalink_structure\n     *\n     * @since 1.0\n     */\n    public function save_options($new_options = false) {\n        if (!$new_options || empty($new_options)) {\n            return;\n        }\n        \n        if (count($this->options) != count($new_options)) {\n            return;\n        }\n        \n        update_option(QTS_OPTIONS_NAME, $new_options);\n        $this->options = $new_options;\n    }\n    \n    \n    \n    /**\n     * getter: meta key\n     *\n     * @since 1.0\n     */\n    public function get_meta_key( $force_lang = false ) {\n        global $q_config;\n        \n        $lang = $this->get_lang();\n        \n        if ($force_lang) {\n            $lang = $force_lang;\n        }\n       \n        return sprintf($this->meta_key, $lang); // returns: _qts_slug_en\n    }\n    \n    \n    \n    /**\n     * check dependences for activation\n     *\n     * @since 1.0\n     */\n    static function block_activate() {\n        global $wp_version;\n        \n        include_once( ABSPATH . 'wp-admin/includes/plugin.php' ); \n        \n        return (\n            version_compare($wp_version, \"3.3\", \"<\" ) ||\n                ( !is_plugin_active('qtranslate/qtranslate.php') && \n                !is_plugin_active('mqtranslate/mqtranslate.php') && \n                !is_plugin_active('qtranslate-x/qtranslate.php'))\n        );\n    }\n    \n    \n\t\n    \n    /**\n     * check if exists qtranslate and do the installation, support multisite\n     *\n     * @since 1.0\n     */\n    public function install() {\n        global $wpdb;\n        \n        if ( self::block_activate() ) {\n            return;\n        }\n        \n        if ( function_exists('is_multisite') && is_multisite() ) {\n\n            if (isset($_GET['networkwide']) && ($_GET['networkwide'] == 1)) {\n                \n                $old_blog = $wpdb->blogid;\n                $blogids = $wpdb->get_col($wpdb->prepare(\"SELECT blog_id FROM $wpdb->blogs\"));\n                foreach ($blogids as $blog_id) {\n                    switch_to_blog($blog_id);\n                    $this->activate();\n                }\n                switch_to_blog($old_blog);\n                return;\n            }\n        }\n        \n        $this->activate();\n    }\n    \n    \n    \n    /**\n     * activates and do the installation\n     *\n     * @since 1.0\n     */\n    private function activate() {\n        global $wp_rewrite;\n\n        $this->set_options();\n        \n        $qts_version = get_option('qts_version');\n        \n        // checks version and do the installation\n        if ( !$qts_version || $qts_version != QTS_VERSION ) {\n            \n            // install termmeta table using functions from Simple-Term-Meta \n            // ( http://wordpress.org/extend/plugins/simple-term-meta/ )\n            install_term_meta_table();\n            \n            // update installed option  \n            update_option('qts_version', QTS_VERSION);\n        }\n    \n        // regenerate rewrite rules in db\n        add_action( 'generate_rewrite_rules', array(&$this, 'modify_rewrite_rules') );\n        flush_rewrite_rules();\n    }\n  \n    \n\n    /**\n    * register front end styles and enqueue\n    *\n    * @since 1.1.7\n    */\n    public function register_plugin_styles() {\n\t\twp_register_style( 'qts_front_styles', plugins_url( '/assets/css/qts-default.css', dirname(__FILE__ ) ) );\n        wp_enqueue_style( 'qts_front_styles' );\n    }\n    /**\n    * register minified front end styles and enqueue\n    * 43LC: easier duplicating the function :|\n    * @since 1.1.8\n    */\n    public function register_plugin_styles_min() {\n\t\twp_register_style( 'qts_front_styles', plugins_url( '/assets/css/qts-default.min.css', dirname(__FILE__ ) ) );\n        wp_enqueue_style( 'qts_front_styles' );\n    }\n\n\n\n    /**\n    * print front end styles\n    *\n    * @since 1.1.7\n    */\n    public function print_plugin_styles() {\n\n        $css_path = dirname(__FILE__).'/assets/css/qts-default.css';\n\n        if (!file_exists($css_path) || !is_readable($css_path)) {\n            return;\n        }\n\n        $default_css_file = file_get_contents($css_path, FILE_USE_INCLUDE_PATH);\n\n        $css = \"<style media=\\\"screen\\\">\\n\";\n        $css .= \"$default_css_file\\n\";\n        $css .=\"</style>\\n\";\n        echo $css;\n    }\n  \n    \n\n    /**\n     * actions when deactivating the plugin\n     *\n     * @since 1.0\n     */\n    public function deactivate() {\n        global $wp_rewrite;\n        \n        // regenerate rewrite rules in db\n        remove_action( 'generate_rewrite_rules', array(&$this, 'modify_rewrite_rules') );\n        $wp_rewrite->flush_rules();\n    }\n    \n\n\n    /**\n     * admin notice: update your old data \n     *\n     * @since 1.0\n     */\n    function notice_update(){\n        global $current_screen;\n        \n        if ($current_screen->id != 'settings_page_qtranslate-slug-settings') {\n        \n            echo \"<div class=\\\"updated\\\">\" . PHP_EOL;\n            echo \"<p><strong>Qtranslate Slug:</strong></p>\" . PHP_EOL;\n            printf(\"<p>%s <a href=\\\"%s\\\" class=\\\"button\\\">%s</a></p>\", __('Please update your old data to the new system.', 'qts'), add_query_arg(array('page' => 'qtranslate-slug-settings'), 'options-general.php'), __('upgrade now', 'qts')) . PHP_EOL;\n            echo \"</div>\" . PHP_EOL;\n        }\n    }\n    \n    \n    \n    /**\n     * admin notice: update your old data \n     *\n     * @since 1.0\n     */\n    function notice_dependences(){\n        global $current_screen;\n        $ornewer=__('or newer','qts');\n        $info_url=admin_url('plugin-install.php?tab=plugin-information');\n        echo '<div class=\"error\">' . PHP_EOL;\n        echo '<p><strong>Qtranslate Slug:</strong></p>' . PHP_EOL;\n        echo '<p>';\n        printf(__('This plugin requires at least %s and either %s, or %s, or %s', 'qts'),'<strong>WordPress 3.3</strong>','<a href=\"'.$info_url.'&plugin=qtranslate-x&TB_iframe=true\" class=\"thickbox\" aria-label=\"'.__('More information about', 'qts').' '.'qTranslate-X\" data-title=\"qTranslate-X\"><strong>qTranslate-X</strong></a> (2.9 '.$ornewer.')','<a href=\"'.$info_url.'&plugin=mqtranslate&TB_iframe=true\" class=\"thickbox\" aria-label=\"'.__('More information about', 'qts').' '.'mqTranslate\" data-title=\"mqTranslate\"><strong>mqTranslate</strong></a> (2.6.2.4 '.$ornewer.')','<a href=\"'.$info_url.'&plugin=qtranslate&TB_iframe=true\" class=\"thickbox\" aria-label=\"'.__('More information about', 'qts').' '.'qTranslate\" data-title=\"qTranslate\"><strong>qTranslate</strong></a> (2.5.8 '.$ornewer.')');\n        echo '</p>' . PHP_EOL;\n        echo '</div>' . PHP_EOL; \n    }\n    \n    \n    \n    /**\n     * checks if old table 'qtranslate_slug' exists and is not empty\n     * \n     * @return object | false\n     *\n     * @since 1.0\n     */\n    public function check_old_data() {\n        global $wpdb;\n        \n        if ($this->old_data === false) {\n            return false;\n        }\n                    \n        $table_name = $wpdb->get_var(\"SHOW TABLES LIKE '{$wpdb->prefix}qtranslate_slug'\");\n            \n        if (!empty($table_name)) {\n            $this->old_data = $wpdb->get_results(\"SELECT * FROM {$wpdb->prefix}qtranslate_slug\");\n        }\n        \n        if ( empty($table_name) || empty($this->old_data) ) {\n            $this->old_data = false;\n        }\n        \n        return $this->old_data;\n    }\n    \n    \n    \n    /**\n     * actions when deactivating the plugin\n     *\n     * @since 1.0\n     */\n    private function check_old_versions() {\n        \n        if ( $this->check_old_data() ) {\n            add_action('admin_notices', array(&$this, 'notice_update'));\n        }\n    }\n    \n    \n    \n    /**\n     * Initialise the Class with all hooks\n     *\n     * @since 1.0\n     */\n    function init() {\n      \n\t\tload_plugin_textdomain( 'qts', false, basename( plugin_dir_path( dirname( __FILE__ ) ) ) . '/languages' );\n        \n        // checking plugin activate\n        if ( self::block_activate() ) {\n            if (is_admin()) {\n                add_action('admin_notices', array(&$this, 'notice_dependences'));\n            }\n            return;\n        }\n    \n        // caching qts options\n        $this->set_options();\n        \n\t\tglobal $q_config;\n\t\t\n\t\t// until we get  a proper function, this will make it for it.\n\t\t$this->current_lang = $q_config['language'];\n\t    $this->enabled_languages = $q_config['enabled_languages'];\n        $this->default_language  = $q_config['default_language'];\n\t\t$this->set_plugin_prefix();\n\t\t$this->set_url_path_mode();\n\t\t\n        if ( is_admin() ) {\n            \n            $this->check_old_versions();\n       \n            \n            // add filters\n            add_filter( 'qts_validate_post_slug', array(&$this, 'validate_post_slug'), 0, 3 );\n            add_filter( 'qts_validate_post_slug', array(&$this, 'unique_post_slug'), 1, 3 );\n            add_filter( 'qts_validate_term_slug', array(&$this, 'validate_term_slug'), 0, 3 );\n            add_filter( 'qts_validate_term_slug', array(&$this, 'unique_term_slug'), 1, 3 );\n            add_filter( 'wp_get_object_terms', array(&$this, 'get_object_terms'), 0, 4 );\n            add_filter( 'get_terms', array(&$this, 'get_terms'), 0, 3 );\n            \n            // admin actions\n            add_action( 'admin_menu', array(&$this, 'add_slug_meta_box') );\n            add_action( 'save_post', array(&$this, 'save_postdata'), 605, 2 );\n            add_action( 'delete_term', array(&$this, 'delete_term'), 0, 3);\n            add_action( 'created_term', array(&$this, 'save_term'), 605, 3);\n            add_action( 'edited_term', array(&$this, 'save_term'), 605, 3 );\n            add_action( 'admin_head', array(&$this, 'hide_slug_box'), 900 );\n            \n            add_action( 'init', array(&$this, 'taxonomies_hooks'), 805 );\n            \n            add_action( 'wp_dashboard_setup', array(&$this, 'remove_dashboard_widgets') );\n            add_action( 'admin_head', array(&$this, 'hide_quick_edit'), 600 );\n            if(!defined('QTRANSLATE_FILE'))\n              add_action( 'admin_init', array(&$this, 'fix_nav_menu') );\n            \n        } else {\n            \n            add_filter( 'request', array(&$this, 'filter_request') );\n\n            // adds external style file\n            $qts_options = $this->get_options();\n            if ( !isset($qts_options[QTS_PREFIX.'styles']) || $qts_options[QTS_PREFIX.'styles'] == \"file\" ) {\n                add_action( 'wp_enqueue_scripts', array( &$this, 'register_plugin_styles' ) );\n            } elseif ($qts_options[QTS_PREFIX.'styles'] == \"minified\" ) {\n                add_action( 'wp_enqueue_scripts', array( &$this, 'register_plugin_styles_min' ) );\n            } elseif ($qts_options[QTS_PREFIX.'styles'] == \"inline\" ) {\n                add_action( 'wp_print_styles', array( &$this, 'print_plugin_styles' ), 20 );\n            }\n        }\n        \n        add_filter( 'query_vars', array(&$this, 'query_vars'));\n        add_action( 'generate_rewrite_rules', array(&$this, 'modify_rewrite_rules') );\n        \n        // remove from qtranslate the discouraged meta http-equiv, inline styles\n        // (including flag URLs) and wrong hreflang links   \n        \n        remove_action('wp_head', $this->get_plugin_prefix() . 'header');\n        if( \"qtranxf_\" === $this->get_plugin_prefix() ) {\n            remove_action('wp_head', $this->get_plugin_prefix() . 'head');\n        }\n        \n        // add proper hreflang links\n        add_action('wp_head',array(&$this, 'qtranslate_slug_header_extended'));\n        \n        // remove some Qtranslate filters\n        remove_filter( 'page_link',     $this->get_plugin_prefix() . 'convertURL' );\n        remove_filter( 'post_link',     $this->get_plugin_prefix() . 'convertURL' );\n        remove_filter( 'category_link', $this->get_plugin_prefix() . 'convertURL' );\n        remove_filter( 'tag_link',      $this->get_plugin_prefix() . 'convertURL' );\n        \n        add_filter( 'qts_permastruct' , array(&$this, 'get_extra_permastruct'), 0, 2);\n        add_filter( 'qts_url_args',     array(&$this, 'parse_url_args'), 0, 1);\n        add_filter( 'home_url',         array(&$this, 'home_url'), 10, 4);  \n        add_filter( 'post_type_link',   array(&$this, 'post_type_link'), 600, 4 );\n        add_filter( 'post_link',        array(&$this, 'post_link'), 0, 3 );\n        add_filter( '_get_page_link',   array(&$this, '_get_page_link'), 0, 2 );\n        add_filter( 'term_link',        array(&$this, 'term_link'), 600, 3 );\n        \n        add_filter( 'single_term_title', $this->get_plugin_prefix() . 'useTermLib', 805 );\n        add_filter( 'get_blogs_of_user', array(&$this, 'blog_names'), 1  );\n        add_action( 'widgets_init', array(&$this, 'widget_init'), 100 );\n        // Add specific CSS class to body class based on current lang\n        add_filter('body_class', array($this, 'qts_body_class'), 600, 1 );\n        \n        add_filter( 'nav_menu_attr_title', array($this, 'qts_filter_attr_title'), 0, 3 );\n\n\n    }\n      \n     /**\n     * Filters menu link attribute\n     *  \n     * @since 1.1.9\n     */ \n    function qts_filter_attr_title( $attr_title ) {\n        return $this->qts_quickuse($attr_title);\n    }\n\n\n    /**\n     * Adds proper links to the content with available translations.\n     * Fixes issue #25\n     *  \n     * @global $qtranslate_slug used to convert the url\n     * @global $q_config available languages\n     *\n     * @since 1.1.8\n     */ \n    public function qtranslate_slug_header_extended(){\n    \tif(is_404()) return;\n        \n        //taken from qtx \n        echo '<link hreflang=\"x-default\" href=\"'.$this->get_current_url($this->default_language) .'\" rel=\"alternate\" />'.PHP_EOL;\n        foreach($this->get_enabled_languages() as $language) {\n\n            if($language != $this->get_currentlang() )\n                echo '<link hreflang=\"'.$language.'\" href=\"'.$this->get_current_url($language).'\" rel=\"alternate\" />'.\"\\n\";\n        }\n    }\n    \n\n    /**\n     * Add a class based on the current language\n     * @param array $classes list of classes\n     */\n    public function qts_body_class( $classes ) {\n        // add 'class-name' to the $classes array\n        $classes[] = call_user_func($this->get_plugin_prefix() . 'getLanguage');\n        \n        // return the $classes array\n        return $classes;\n    }\n\n\t\t/**\n     * Finds the translated slug of the given post \n     * based on: https://wordpress.org/support/topic/permalink-for-other-languages \n     * @param int $id the post id\n     * @param string $lang which language to look for\n\t\t * @return string the slug or empty if not found\n     * @author vbkun\n     * @since 1.1.13\n     */ \n\t\tpublic function get_slug($id, $lang){\n\t\t\t$slugArray = get_post_meta( $id, '_qts_slug_'.$lang );\n\t\t\treturn !empty($slugArray) ? $slugArray[0] : \"\";\n\t\t}\n\n\t// TODO: properly test this\n\t/**\n\t * Get text in $lang, or in the current lang\n\t *\n\t * @package Qtranslate Slug\n\t * @since 1.1.9\n\t * @param string $text the whole text\n\t * @param string $lang (optional) get the text in this language, or if empty, the current\n\t * @return array the text in the required language\n\t */\n\tpublic function qts_quickuse( $text,$lang='' ){\n\t    global $q_config;\n\t    $lang = '' == $lang ? $q_config['language'] : $lang;\n\t    $parsed_text = call_user_func($this->get_plugin_prefix() . 'getSortedLanguages',$text);\n\t    if( !empty($parsed_text[$lang])){\n\t      return $parsed_text[$lang];  \n\t    }  \n\t}\n\t\n\n    /**\n     * Adds news rules to translate the URL bases, \n     * this function must be called on flush_rewrite or 'flush_rewrite_rules' \n     * \n     * @param object $wp_rewrite\n     *\n     * @since 1.0\n     */ \n    public function modify_rewrite_rules() {\n        // do we need this global?\t\n        //global $wp_rewrite;\n        \n        // post types rules\n        $post_types = get_post_types( array('_builtin' => false ), 'objects');\n        foreach ( $post_types as $post_type ) {\n            $this->generate_extra_rules( $post_type->name );\n        }\n        \n        // taxonomies rules\n        $taxonomies = $this->get_public_taxonomies();\n        foreach ( $taxonomies as $taxonomy ) {\n            $this->generate_extra_rules( $taxonomy->name );\n        }\n    }\n    \n    \n    \n    /**\n     * Helper: news rules to translate the URL bases\n     * \n     * @param string $name name of extra permastruct\n     * @param string $type 'post_type' or 'taxonomy'\n     *\n     * @since 1.0\n     */\n    private function generate_extra_rules( $name = false ) {\n        global $wp_rewrite;\n        \n        foreach ($this->get_enabled_languages() as $lang):\n            \n            if ( $base = $this->get_base_slug( $name, $lang) ):\n                \n                $struct = $wp_rewrite->extra_permastructs[$name];\n                \n                if ( is_array( $struct ) ) {\n                    if ( count( $struct ) == 2 )\n                        $rules = $wp_rewrite->generate_rewrite_rules( \"/$base/%$name%\", $struct[1] );\n                    else\n                        $rules = $wp_rewrite->generate_rewrite_rules( \"/$base/%$name%\", $struct['ep_mask'], $struct['paged'], $struct['feed'], $struct['forcomments'], $struct['walk_dirs'], $struct['endpoints'] );\n                } else {\n                    $rules = $wp_rewrite->generate_rewrite_rules( \"/$base/%$name%\" );\n                }\n                \n                $wp_rewrite->rules = array_merge($rules, $wp_rewrite->rules);\n            \n            endif;\n            \n        endforeach;\n    }\n    \n    \n    \n    /**\n     * Helper that gets a base slug stored in options\n     * \n     * @param string $name of extra permastruct\n     * @return string base slug for 'post_type' and 'language' or false\n     *\n     * @since 1.0\n     */\n    public function get_base_slug($name = false, $lang = false) {\n        \n        if ( !$name || !$lang ) {\n            return false;\n        }\n        \n        if ( taxonomy_exists($name) ) {\n            $type = 'taxonomy';\n        } else if ( post_type_exists($name) ) {\n            $type = 'post_type';\n        } else {\n            return false;\n        }\n        \n        $qts_options = $this->get_options();\n        \n        $option_name = QTS_PREFIX . $type . '_' . $name;\n        \n        if ( !isset($qts_options[$option_name]) || empty($qts_options[$option_name]) ) {\n            return false;\n        }\n        \n        if (isset($qts_options[$option_name][$lang])) {\n            return $qts_options[$option_name][$lang];\n        }\n        \n        return false;\n    }\n    \n    \n    \n    /**\n     * Helper: returns public built-in and not built-in taxonomies\n     * \n     * @return array of public taxonomies objects\n     *\n     * @since 1.0\n     */\n    private function get_public_taxonomies() {\n        \n        $builtin = get_taxonomies( array( 'public' => true, 'show_ui' => true, '_builtin' => true ), 'object'); \n        $taxonomies = get_taxonomies( array( 'public' => true, 'show_ui' => true, '_builtin' => false ), 'object' ); \n        \n        return array_merge( $builtin, $taxonomies );\n    }\n    \n    \n    \n    /**\n     * parse and adds $_GET args passed to an url\n     * \n     * @param string $url parameters\n     * @param string $lang processed\n     * @return string converted url\n     *\n     * @since 1.0\n     */\n    public function parse_url_args( $url ) {\n        global $q_config;\n\n        if (is_admin()) {\n            return $url;\n        }\n        \n        $url = preg_replace('/&amp;/', '&', $url);\n        \n        // if no permalink structure ads ?lang=en\n        $base_query = parse_url($q_config['url_info']['original_url']);\n        $base_args = isset($base_query['query']) ? wp_parse_args($base_query['query']) : array();\n        \n        if ( empty($this->permalink_structure) || $q_config['url_mode'] == 1 ) {\n            $base_args['lang'] = $this->get_lang();\n\n        }\n\n        // rebuild query with all args\n        $url = add_query_arg($base_args, $url);\n\n        $url = str_replace('/?', '?', $url); // TODO: hack: improve this code\n        $url = str_replace('?', '/?', $url); // TODO: hack: improve this code\n        \n        return $url;\n    }\n    \n    \n    \n    /**\n     * Fix get_page_by_path when querying vars\n     * \n     * @param $query_vars objec query vars founded\n     * @return object $query_vars processed\n     *\n     * @since 1.0\n     */\n    public function query_vars( $query_vars ) {\n        global $wp, $wp_rewrite;\n\n        $wp->query_vars = array();\n        $post_type_query_vars = array();\n\n        // Fetch the rewrite rules.\n        $rewrite = $wp_rewrite->wp_rewrite_rules();\n\n        if ( ! empty($rewrite) ) {\n            // If we match a rewrite rule, this will be cleared.\n            $error = '404';\n            $wp->did_permalink = true;\n\n            if ( isset($_SERVER['PATH_INFO']) ) {\n                $pathinfo = $_SERVER['PATH_INFO'];\n            } else {\n                $pathinfo = '';\n            }\n            $pathinfo_array = explode('?', $pathinfo);\n            $pathinfo = str_replace(\"%\", \"%25\", $pathinfo_array[0]);\n            $req_uri = $_SERVER['REQUEST_URI'];\n            $req_uri_array = explode('?', $req_uri);\n            $req_uri = $req_uri_array[0];\n            $self = $_SERVER['PHP_SELF'];\n            $home_path = parse_url(home_url());\n            \n            if ( isset($home_path['path']) ) {\n                $home_path = $home_path['path'];\n            } else {\n                $home_path = '';\n            }\n            $home_path = trim($home_path, '/');\n\n            // Trim path info from the end and the leading home path from the\n            // front. For path info requests, this leaves us with the requesting\n            // filename, if any. For 404 requests, this leaves us with the\n            // requested permalink.\n            $req_uri = str_replace($pathinfo, '', $req_uri);\n            $req_uri = trim($req_uri, '/');\n            $req_uri = preg_replace(\"|^$home_path|\", '', $req_uri);\n            $req_uri = trim($req_uri, '/');\n            if ($GLOBALS['q_config']['url_mode'] == $this->get_url_path_mode()) {\n                $req_uri = preg_replace(\"/^{$GLOBALS['q_config']['language']}(\\/|$)/\", '', $req_uri);\n            }\n            $pathinfo = trim($pathinfo, '/');\n            $pathinfo = preg_replace(\"|^$home_path|\", '', $pathinfo);\n            $pathinfo = trim($pathinfo, '/');\n            $self = trim($self, '/');\n            $self = preg_replace(\"|^$home_path|\", '', $self);\n            $self = trim($self, '/');\n\n            // The requested permalink is in $pathinfo for path info requests and\n            //  $req_uri for other requests.\n            if ( ! empty($pathinfo) && !preg_match('|^.*' . $wp_rewrite->index . '$|', $pathinfo) ) {\n                $request = $pathinfo;\n            } else {\n                // If the request uri is the index, blank it out so that \n                // we don't try to match it against a rule.\n                if ( $req_uri == $wp_rewrite->index )\n                    $req_uri = '';\n                $request = $req_uri;\n            }\n            \n            $wp->request = $request;\n\n            // Look for matches.\n            $request_match = $request;\n            if ( empty( $request_match ) ) {\n                // An empty request could only match against ^$ regex\n                if ( isset( $rewrite['$'] ) ) {\n                    $wp->matched_rule = '$';\n                    $query = $rewrite['$'];\n                    $matches = array('');\n                }\n            } else if ( $req_uri != 'wp-app.php' ) {\n                foreach ( (array) $rewrite as $match => $query ) {\n                    // If the requesting file is the anchor of the match, prepend it to the path info.\n                    if ( ! empty($req_uri) && strpos($match, $req_uri) === 0 && $req_uri != $request ) {\n                        $request_match = $req_uri . '/' . $request;\n                    }\n\n                    if ( preg_match(\"#^$match#\", $request_match, $matches) || preg_match(\"#^$match#\", urldecode($request_match), $matches) ) {\n\n                        if ( $wp_rewrite->use_verbose_page_rules && preg_match( '/pagename=\\$matches\\[([0-9]+)\\]/', $query, $varmatch ) ) {\n                            // this is a verbose page match, lets check to be sure about it\n                            if ( ! $page_foundid = $this->get_page_by_path( $matches[ $varmatch[1] ] ) ) {\n                                continue;\n                            } else {\n                                wp_cache_set('qts_page_request', $page_foundid); // caching query :)\n                            }       \n                        }\n\n                        // Got a match.\n                        $wp->matched_rule = $match;\n                        break;\n                    }\n                }\n            }\n\n            if ( isset( $wp->matched_rule ) ) {\n                // Trim the query of everything up to the '?'.\n                $query = preg_replace(\"!^.+\\?!\", '', $query);\n\n                // Substitute the substring matches into the query.\n                $query = addslashes(WP_MatchesMapRegex::apply($query, $matches));\n\n                $wp->matched_query = $query;\n\n                // Parse the query.\n                parse_str($query, $perma_query_vars);\n\n                // If we're processing a 404 request, clear the error var\n                // since we found something.\n                unset( $_GET['error'] );\n                unset( $error );\n            }\n\n            // If req_uri is empty or if it is a request for ourself, unset error.\n            if ( empty($request) || $req_uri == $self || strpos($_SERVER['PHP_SELF'], 'wp-admin/') !== false ) {\n                unset( $_GET['error'] );\n                unset( $error );\n\n                if ( isset($perma_query_vars) && strpos($_SERVER['PHP_SELF'], 'wp-admin/') !== false ) {\n                    unset( $perma_query_vars );\n                }\n\n                $wp->did_permalink = false;\n            }\n        }\n\n        return count(array_diff($query_vars, $wp->public_query_vars)) > 0 ? $query_vars : $wp->public_query_vars;\n    }\n    \n    \n    \n    /**\n     * Function called when query parameters are processed by Wordpress.\n     * \n     * @param $query query parameters\n     * @return array() $query processed\n     *\n     * @since 1.0\n     */\n    function filter_request( $query ) {\n        global $wp_query, $wp;\n        if ((isset($wp->matched_query) || empty($query))  && ! isset($query['s']) ) {\n            $query = wp_parse_args($wp->matched_query);\n        }\n        \n        foreach (get_post_types() as $post_type) {\n            if ( array_key_exists($post_type, $query) && !in_array($post_type, array('post', 'page')) ) {\n                $query['post_type'] = $post_type;\n            }\n        }\n        \n        $page_foundit = false;\n        \n        // -> page\n        if ( isset($query['pagename']) || isset($query['page_id']) ):\n            \n            $page = wp_cache_get('qts_page_request');\n            if (!$page) \n                $page = isset($query['page_id']) ? get_post($query['page_id']) : $this->get_page_by_path($query['pagename']);\n            \n            if (!$page) return $query;\n            $id = $page->ID;\n            $cache_array = array($page);\n            update_post_caches($cache_array, 'page'); // caching query :)\n            wp_cache_delete('qts_page_request');\n            $query['pagename'] = get_page_uri($page);\n            $function = 'get_page_link';\n        \n        // -> custom post type\n        elseif ( isset($query['post_type']) ):\n            \n            $page_slug = ( isset($query['name']) && !empty($query['name']) ) ? $query['name'] : $query[$query['post_type']];\n            $page = $this->get_page_by_path($page_slug, OBJECT, $query['post_type']);\n            if (!$page) return $query;\n            $id = $page->ID;\n            $cache_array = array($page);\n            update_post_caches($cache_array, $query['post_type']); // caching query :)\n            $query['name'] = $query[$query['post_type']] = get_page_uri($page); \n            $function = 'get_post_permalink';\n        \n        // -> post\n        elseif ( isset($query['name']) || isset($query['p']) ):\n            \n            $post = isset($query['p']) ? get_post($query['p']) : $this->get_page_by_path($query['name'], OBJECT, 'post');\n            if (!$post) {\n                return $query;\n            }\n            $query['name'] = $post->post_name;\n            $id = $post->ID;\n            $cache_array = array($post);\n            update_post_caches($cache_array);\n            $function = 'get_permalink';\n            \n        // -> category\n        elseif ( ( isset($query['category_name']) || isset($query['cat'])) ):\n            if ( isset($query['category_name']) ) {\n                $term_slug = $this->get_last_slash( $query['category_name'] );\n            }\n            $term = isset($query['cat']) ? get_term($query['cat'], 'category') : $this->get_term_by('slug', $term_slug, 'category');\n            if (!$term) {\n                return $query;\n            }\n            $cache_array = array($term);\n            update_term_cache($cache_array, 'category'); // caching query :)\n            $id = $term->term_id;\n            $query['category_name'] = $term->slug; // uri\n            $function = 'get_category_link';\n        \n        // -> tag\n        elseif ( isset($query['tag']) ):\n            \n            $term = $this->get_term_by('slug', $query['tag'], 'post_tag');\n            if (!$term) {\n                return $query;\n            }\n            $cache_array = array($term);\n            update_term_cache($cache_array, 'post_tag'); // caching query :)\n            $id = $term->term_id;\n            $query['tag'] = $term->slug;\n            $function = 'get_tag_link';\n        \n        endif;\n\n        \n        // -> taxonomy\n        $taxonomies = get_taxonomies( array( 'public' => true, '_builtin' => false )  );\n        foreach ($taxonomies as $term_name):\n        if ( isset($query[$term_name]) ) {\n            \n            $term_slug = $this->get_last_slash( $query[$term_name] );\n            $term = $this->get_term_by('slug', $term_slug, $term_name);\n            if (!$term) {\n                return $query;\n            }\n            $cache_array = array($term);\n            update_term_cache($cache_array, $term_name); // caching query :)\n            $id = $term;\n            $query[$term_name] = $term->slug;\n            $function = 'get_term_link';\n            \n        }\n        endforeach;\n\n        // -> home url\n        if ( empty($query) ) {\n            \n            $function = 'home_url';\n            $id = '';\n            \n        }\n        \n        // -> search\n        if (isset($query['s'])) {\n\n          $id = $query['s'];\n          $function=\"get_search_link\";\n      \n        }\n        \n        if ( isset($function) ) {\n                    \n            // parse all languages links\n            foreach( $this->get_enabled_languages() as $lang ) {\n                \n                $this->lang = $lang;\n                $this->current_url[$lang] = apply_filters('qts_url_args', call_user_func($function, $id));\n            }\n\n            $this->lang = false;\n        }\n        \n        return $query;\n    }\n    \n    \n    \n    /**\n     * Parse a hierarquical name and extract the last one\n     *\n     * @param string $lang Page path\n     * @return string\n     *\n     * @since 1.0\n     */\n    public function get_current_url( $lang = false ) {\n        \n        if (!$lang) {\n            $lang = $this->get_lang();\n        }\n        \n        if (isset($this->current_url[$lang]) && !empty($this->current_url[$lang])) {\n            return $this->current_url[$lang];\n        }\n        \n        return '';\n    }\n    \n    \n    \n    /**\n     * Parse a hierarquical name and extract the last one \n     *\n     * @param string $slug Page path\n     * @return string\n     *\n     * @since 1.0\n     */\n    private function get_last_slash($slug) {\n        \n        $slug = rawurlencode( urldecode( $slug ) );\n        $slug = str_replace('%2F', '/', $slug);\n        $slug = str_replace('%20', ' ', $slug);\n        $exploded_slug = explode('/', $slug);\n\n        return array_pop( $exploded_slug );\n    }\n    \n    \n    \n    /**\n     * Retrieves a page id given its path.\n     *\n     * @param string $page_path Page path\n     * @param string $output Optional. Output type. OBJECT, ARRAY_N, or ARRAY_A. Default OBJECT.\n     * @param string $post_type Optional. Post type. Default page.\n     * @return mixed Null when complete.\n     *\n     * @since 1.0\n     */\n    private function get_page_id_by_path($page_path, $output = OBJECT, $post_type = 'page') {\n        global $wpdb;\n\n        $page_path = rawurlencode(urldecode($page_path));\n        $page_path = str_replace('%2F', '/', $page_path);\n        $page_path = str_replace('%20', ' ', $page_path);\n        $parts = explode( '/', trim( $page_path, '/' ) );\n        $parts = array_map( 'esc_sql', $parts );\n        $parts = array_map( 'sanitize_title_for_query', $parts );\n        $in_string = \"'\". implode( \"','\", $parts ) . \"'\";\n        $meta_key = $this->get_meta_key();\n        $post_type_sql = $post_type;\n        $wpdb->escape_by_ref( $post_type_sql );\n        \n        $pages = $wpdb->get_results( \"SELECT $wpdb->posts.ID, $wpdb->posts.post_parent, $wpdb->postmeta.meta_value FROM $wpdb->posts,$wpdb->postmeta WHERE $wpdb->posts.ID = $wpdb->postmeta.post_id AND $wpdb->postmeta.meta_key = '$meta_key' AND $wpdb->postmeta.meta_value IN ($in_string) AND ($wpdb->posts.post_type = '$post_type_sql' OR $wpdb->posts.post_type = 'attachment')\", OBJECT_K );\n\n        $revparts = array_reverse( $parts );\n\n        $foundid = 0;\n        foreach ( (array) $pages as $page ) {\n            if ( $page->meta_value == $revparts[0] ) {\n                $count = 0;\n                $p = $page;\n                while ( $p->post_parent != 0 && isset( $pages[ $p->post_parent ] ) ) {\n                    $count++;\n                    $parent = $pages[ $p->post_parent ];\n                    if ( ! isset( $revparts[ $count ] ) || $parent->meta_value != $revparts[ $count ] ) {\n                        break;\n                    }\n                    $p = $parent;\n                }\n\n                if ( $p->post_parent == 0 && $count+1 == count( $revparts ) && $p->meta_value == $revparts[ $count ] ) {\n                    $foundid = $page->ID;\n                    break;\n                }\n            }\n        }\n        \n        if ( $foundid ) {\n            return $foundid;\n            \n        } else {\n            \n            $last_part = array_pop($parts);\n            $page_id = $wpdb->get_var( \"SELECT ID FROM $wpdb->posts WHERE post_name = '$last_part' AND (post_type = '$post_type_sql' OR post_type = 'attachment')\" );\n            \n            if ( $page_id ) {\n                return $page_id;\n            }\n        }\n\n        return null;\n    }\n    \n    \n    \n    \n    /**\n     * Retrieves a page given its path.\n     *\n     * @param string $page_path Page path\n     * @param string $output Optional. Output type. OBJECT, ARRAY_N, or ARRAY_A. Default OBJECT.\n     * @param string $post_type Optional. Post type. Default page.\n     * @return mixed Null when complete.\n     *\n     * @since 1.0\n     */\n    private function get_page_by_path($page_path, $output = OBJECT, $post_type = 'page') {\n        \n        $foundid = $this->get_page_id_by_path($page_path, $output, $post_type);\n        if ( $foundid ) {\n            return get_post( $foundid, $output );\n        }\n        \n        return null;\n    }\n    \n    \n    \n    /**\n     * Ignores if the mod_rewrite func is the caller\n     *\n     * @return boolean\n     *\n     * @since 1.0\n     */\n    private function ignore_rewrite_caller() {\n        \n        $backtrace = debug_backtrace();\n        \n        $ignore_functions = array('mod_rewrite_rules', 'save_mod_rewrite_rules', 'flush_rules', 'rewrite_rules', 'wp_rewrite_rules', 'query_vars');\n        \n        if ( isset($backtrace['function']) ) {\n            if (in_array($backtrace['function'], $ignore_functions)) {\n                return true;\n            }\n        } else {\n            foreach ($backtrace as $trace) {\n                if ( isset($trace['function']) && in_array($trace['function'], $ignore_functions) ) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    \n    /**\n     * Retrieve the home url for a given site.\n     *\n     * @param  int $blog_id   (optional) Blog ID. Defaults to current blog.\n     * @param  string $path   (optional) Path relative to the home url.\n     * @param  string $scheme (optional) Scheme to give the home url context. Currently 'http', 'https'.\n     * @return string Home url link with optional path appended.\n     *\n     * @since 1.0\n     */\n    public function home_url($url, $path, $scheme, $blog_id) {\n        if ( !in_array( $scheme, array( 'http', 'https' ) ) ) {\n            $scheme = is_ssl() && !is_admin() ? 'https' : 'http';\n        }\n\n        if ( empty( $blog_id ) || !is_multisite() ) {\n            $url = get_option( 'home' );\n        } else {\n            $url = get_blog_option( $blog_id, 'home' );\n        }\n\n        if ( 'http' != $scheme ) {\n            $url = str_replace( 'http://', \"$scheme://\", $url );\n        }\n\n        $ignore_caller = $this->ignore_rewrite_caller();\n\n        if ( !empty( $path ) && is_string( $path ) && strpos( $path, '..' ) === false ) {\n            $url .= '/' . ltrim( $path, '/' );\n        }\n\n        if ( !$ignore_caller ) {\n            $url = call_user_func($this->get_plugin_prefix() . 'convertURL', $url, $this->get_lang(), true);\n        }\n\n        return $url;\n    }\n    \n    \n    \n    /**\n     * Filter that changes the permastruct depending\n     * \n     * @param string $permastruct default permastruct given b wp_rewrite\n     * @param string $name the name of the extra permastruct\n     * @return string processed permastruct\n     *\n     * @since 1.0\n     */\n    public function get_extra_permastruct( $permastruct = false, $name = false ) {\n        \n        if ( !$name || !$permastruct ) {\n            return '';\n        }\n        \n        if ( $base = $this->get_base_slug($name, $this->get_lang()) ) {\n            return \"/$base/%$name%\";\n        }\n        \n        return $permastruct;\n    }\n        \n    \n    \n    /**\n     * Filter that translates the slug parts in a page link\n     * \n     * @param $link the link for the page generated by Wordpress\n     * @param $id the id of the page\n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function post_type_link( $link, $post, $leavename, $sample ) {\n        global $wp_rewrite;\n\n        if ( is_wp_error( $post ) ) {\n            return $post;\n        }\n\n        $post_link = apply_filters( 'qts_permastruct', $wp_rewrite->get_extra_permastruct($post->post_type), $post->post_type);\n        \n        $slug = get_post_meta( $post->ID, $this->get_meta_key(), true );\n        if (!$slug) {\n            $slug =  $post->post_name;\n        }\n\n        $draft_or_pending = isset($post->post_status) && in_array( $post->post_status, array( 'draft', 'pending', 'auto-draft' ) );\n\n        $post_type = get_post_type_object($post->post_type);\n\n        if ( !empty($post_link) && ( !$draft_or_pending || $sample ) ) {\n            if ( ! $leavename ) {\n                if ( $post_type->hierarchical )\n                    $slug = $this->get_page_uri($post->ID);\n                $post_link = str_replace(\"%$post->post_type%\", $slug, $post_link);\n            }\n            \n            $post_link = home_url( user_trailingslashit($post_link) );\n            \n        } else {\n            \n            if ( $post_type->query_var && ( isset($post->post_status) && !$draft_or_pending ) ) {\n                $post_link = add_query_arg($post_type->query_var, $slug, '');\n            } else {\n                $post_link = add_query_arg(array('post_type' => $post->post_type, 'p' => $post->ID), '');\n            }\n            \n            $post_link = home_url($post_link);\n        }\n\n        return $post_link;\n    }\n    \n    \n    \n    /**\n     * Filter that translates the slug in a post link\n     * \n     * @param $link the link generated by wordpress\n     * @param $post the post data\n     * @param $leavename parameter used by get_permalink. Whether to keep post name or page name. \n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function post_link( $link, $post, $leavename ) {\n        global $q_config;\n        \n        $rewritecode = array(\n            '%year%',\n            '%monthnum%',\n            '%day%',\n            '%hour%',\n            '%minute%',\n            '%second%',\n            $leavename? '' : '%postname%',\n            '%post_id%',\n            '%category%',\n            '%author%',\n            $leavename? '' : '%pagename%',\n        );\n\n        if ( empty($post->ID) ) {\n            return false;\n        }\n\n        $permalink = $this->permalink_structure;\n\n        if ( '' != $permalink && !in_array($post->post_status, array('draft', 'pending', 'auto-draft')) ) {\n            $unixtime = strtotime($post->post_date);\n            \n            $category = '';\n            if ( strpos($permalink, '%category%') !== false ) {\n                $cats = get_the_category($post->ID);\n                if ( $cats ) {\n                    usort($cats, '_usort_terms_by_ID'); // order by ID\n                    \n                    $category = get_term_meta($cats[0]->term_id, $this->get_meta_key(), true );\n                    if (!$category) $category = $cats[0]->slug;\n                    \n                    if ( $parent = $cats[0]->parent )\n                        $category = $this->get_category_parents($parent, false, '/', true) . $category;\n                }\n                // show default category in permalinks, without\n                // having to assign it explicitly\n                if ( empty($category) ) {\n                    $default_category = get_category( get_option( 'default_category' ) );\n                    \n                    $default_category_slug = get_term_meta($default_category->term_id, $this->get_meta_key(), true );\n                    if (!$default_category_slug) $default_category_slug = $default_category->slug;\n                    \n                    $category = is_wp_error( $default_category ) ? '' : $default_category_slug;\n                }\n            }\n\n            $author = '';\n            if ( strpos($permalink, '%author%') !== false ) {\n                $authordata = get_userdata($post->post_author);\n                $author = $authordata->user_nicename;\n            }\n\n            $date = explode(\" \",date('Y m d H i s', $unixtime));\n            \n            $post_slug = get_post_meta($post->ID, $this->get_meta_key(), true );\n            if (!$post_slug) {\n                $post_slug = $post->post_name;\n            }\n            \n            $rewritereplace =\n            array(\n                $date[0],\n                $date[1],\n                $date[2],\n                $date[3],\n                $date[4],\n                $date[5],\n                $post_slug,\n                $post->ID,\n                $category,\n                $author,\n                $post_slug,\n            );\n            $permalink = home_url( str_replace($rewritecode, $rewritereplace, $permalink));\n            if ($q_config['url_mode'] != 1) {\n                $permalink = user_trailingslashit($permalink, 'single');\n            }\n        } else { // if they're not using the fancy permalink option\n            $permalink = home_url('?p=' . $post->ID);\n        }\n        \n        return $permalink;\n    }\n    \n    \n    \n    /**\n     * Retrieve category parents with separator.\n     *\n     * @param int $id Category ID.\n     * @param bool $link Optional, default is false. Whether to format with link.\n     * @param string $separator Optional, default is '/'. How to separate categories.\n     * @param bool $nicename Optional, default is false. Whether to use nice name for display.\n     * @param array $visited Optional. Already linked to categories to prevent duplicates.\n     * @return string\n     *\n     * @since 1.0\n     */\n    private function get_category_parents( $id, $link = false, $separator = '/', $nicename = false, $visited = array() ) {\n        \n        $chain = '';\n        if(phpversion() >= 5.4) {\n            $parent = get_category( $id );\n        } else {\n            $parent = &get_category( $id );\n        }\n\n        if ( is_wp_error( $parent ) ) {\n            return $parent;\n        }\n\n        if ( $nicename ) {\n\n            $name = get_term_meta($parent->term_id, $this->get_meta_key(), true );\n            if (!$name) {\n                $name = $parent->slug;\n            }\n        } else {\n            $name = $parent->name;\n        }\n\n        if ( $parent->parent && ( $parent->parent != $parent->term_id ) && !in_array( $parent->parent, $visited ) ) {\n            $visited[] = $parent->parent;\n            $chain .= $this->get_category_parents( $parent->parent, $link, $separator, $nicename, $visited );\n        }\n        \n        if ( $link ) {\n            $chain .= '<a href=\"' . get_category_link( $parent->term_id ) . '\" title=\"' . esc_attr( sprintf( __( \"View all posts in %s\", \"qts\" ), $parent->name ) ) . '\">'.$name.'</a>' . $separator;\n        } else {\n            $chain .= $name.$separator;\n        }\n        \n        return $chain;\n    }\n    \n\n    \n    \n    \n    /**\n     * Filter that translates the slug parts in a page link\n     * \n     * @param $link the link for the page generated by Wordpress\n     * @param $id the id of the page\n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function _get_page_link( $link, $id ) {\n        global $post, $wp_rewrite, $q_config;\n\n        $current_post = $post;\n\n        if ( !$id ) {\n            $id = (int) $post->ID;\n        } else {\n            if(phpversion() >= 5.4) {\n                $current_post = get_post($id);\n            } else {\n                $current_post = &get_post($id);\n            }\n        }\n\n        $draft_or_pending = in_array( $current_post->post_status, array( 'draft', 'pending', 'auto-draft' ) );\n\n        $link = $wp_rewrite->get_page_permastruct();\n\n        if ( !empty($link) && ( isset($current_post->post_status) && !$draft_or_pending ) ) {\n            \n            $link = str_replace('%pagename%', $this->get_page_uri($id), $link);\n            \n            $link = trim($link, '/'); // hack\n            $link = home_url(\"/$link/\"); // hack\n            \n            if ($q_config['url_mode'] != 1)\n                $link = user_trailingslashit($link, 'page');\n            \n        } else {\n            \n            $link = home_url(\"?page_id=$id\");\n        }\n\n        return $link;\n    }\n    \n    \n    \n    /**\n     * Builds URI for a page.\n     *\n     * Sub pages will be in the \"directory\" under the parent page post name.\n     *\n     * @param mixed $page Page object or page ID.\n     * @return string Page URI.\n     *\n     * @since 1.0\n     */\n    private function get_page_uri($page) {\n        \n        if ( ! is_object($page) ) {\n            $page = get_post($page);\n        }\n        \n        $uri = get_post_meta( $page->ID, $this->get_meta_key(), true );\n        if (!$uri) {\n            $uri =  $page->post_name;\n        }\n\n        // A page cannot be it's own parent.\n        if ( $page->post_parent == $page->ID ) {\n            return $uri;\n        }\n\n        while ($page->post_parent != 0) {\n            $page = get_post($page->post_parent);\n            \n            $page_name = get_post_meta( $page->ID, $this->get_meta_key(), true );\n            if (!$page_name) {\n                $page_name = $page->post_name;\n            }\n            \n            $uri = $page_name . \"/\" . $uri;\n        }\n\n        return $uri;\n    }\n    \n    \n    \n    /**\n     * Filter that translates the slug parts in a term link\n     * \n     * @param $link the link for the page generated by Wordpress\n     * @param $term object\n     * @param $taxonomy object\n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function term_link( $link, $term, $taxonomy ) {\n        global $wp_rewrite;\n        \n        // parse normal term names for ?tag=tagname\n        if (empty($this->permalink_structure)) return $link;\n\n        if ( !is_object($term) ) {\n            if ( is_int($term) ) {\n                $term = &get_term($term, $taxonomy);\n            } else {\n                $term = $this->get_term_by('slug', $term, $taxonomy);\n            }\n        }\n\n        if ( !is_object($term) ) {\n            $term = new WP_Error('invalid_term', __('Empty Term', 'qts'));\n        }\n\n        if ( is_wp_error( $term ) ) {\n            return $term;\n        }\n\n        $taxonomy = $term->taxonomy;\n\n        $termlink = apply_filters( 'qts_permastruct', $wp_rewrite->get_extra_permastruct($taxonomy), $taxonomy);\n        \n        $slug = get_term_meta( $term->term_id, $this->get_meta_key(), true );\n        if (!$slug) {\n            $slug = $term->slug;\n        }\n        \n        $t = get_taxonomy($taxonomy);\n\n        if ( empty($termlink) ) {\n            if ( 'category' == $taxonomy )\n                $termlink = '?cat=' . $term->term_id;\n            elseif ( $t->query_var )\n                $termlink = \"?$t->query_var=$slug\";\n            else\n                $termlink = \"?taxonomy=$taxonomy&term=$slug\";\n            $termlink = home_url($termlink);\n        } else {\n            if ( $t->rewrite['hierarchical'] ) {\n                $hierarchical_slugs = array();\n                $ancestors = get_ancestors($term->term_id, $taxonomy);\n                foreach ( (array)$ancestors as $ancestor ) {\n                    $ancestor_term = get_term($ancestor, $taxonomy);\n                    \n                    $ancestor_slug = get_term_meta( $ancestor_term->term_id, $this->get_meta_key(), true );\n                    if (!$ancestor_slug) $ancestor_slug = $ancestor_term->slug;\n                    \n                    $hierarchical_slugs[] = $ancestor_slug;\n                }\n                $hierarchical_slugs = array_reverse($hierarchical_slugs);\n                $hierarchical_slugs[] = $slug;\n                $termlink = str_replace(\"%$taxonomy%\", implode('/', $hierarchical_slugs), $termlink);\n            } else {\n                $termlink = str_replace(\"%$taxonomy%\", $slug, $termlink);\n            }\n            $termlink = home_url( user_trailingslashit($termlink, 'category') );\n        }\n        return $termlink;\n    }\n    \n    \n    \n    /**\n     * Get all Term data from database by Term field and data.\n     *\n     * @param (string) $field Either 'slug', 'name', or 'id'\n     * @param (string|int) $value Search for this term value\n     * @param (string) $taxonomy Taxonomy Name\n     * @param (string) $output Constant OBJECT, ARRAY_A, or ARRAY_N\n     * @param (string) $filter Optional, default is raw or no WordPress defined filter will applied.\n     * @return (mixed) Term Row from database. Will return false if $taxonomy does not exist or $term was not found.\n     *\n     * @since 1.0\n     */\n    private function get_term_by($field, $value, $taxonomy, $output = OBJECT, $filter = 'raw') {\n        global $wpdb;\n        \n        $original_field = $field;\n\n        if ( ! taxonomy_exists($taxonomy) ) {\n            return false;\n        }\n\n        if ( 'slug' == $field ) {\n            $field = 'm.meta_key = \\''.$this->get_meta_key().'\\' AND m.meta_value';\n            $value = sanitize_title($value);\n            if ( empty($value) )\n                return false;\n        } else if ( 'name' == $field ) {\n            // Assume already escaped\n            $value = stripslashes($value);\n            $field = 't.name';\n        } else {\n            $term = get_term( (int) $value, $taxonomy, $output, $filter);\n            if ( is_wp_error( $term ) )\n                $term = false;\n            return $term;\n        }\n        \n        $term = $wpdb->get_row( $wpdb->prepare( \"SELECT t.*, tt.* FROM $wpdb->terms AS t, $wpdb->term_taxonomy AS tt, $wpdb->termmeta AS m WHERE t.term_id = tt.term_id AND tt.term_id = m.term_id AND tt.taxonomy = %s AND $field = %s LIMIT 1\", $taxonomy, $value) );\n\n        if ( !$term && 'slug' == $original_field ) {\n            $field = 't.slug';\n            $term = $wpdb->get_row( $wpdb->prepare( \"SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND $field = %s LIMIT 1\", $taxonomy, $value) );\n        }\n        \n        if ( !$term ) {\n            return false;\n        }\n\n        wp_cache_add($term->term_id, $term, $taxonomy);\n\n        $term = apply_filters('get_term', $term, $taxonomy);\n        $term = apply_filters(\"get_$taxonomy\", $term, $taxonomy);\n        $term = sanitize_term($term, $taxonomy, $filter);\n\n        if ( $output == OBJECT ) {\n            return $term;\n        } elseif ( $output == ARRAY_A ) {\n            return get_object_vars($term);\n        } elseif ( $output == ARRAY_N ) {\n            return array_values(get_object_vars($term));\n        } else {\n            return $term;\n        }\n    }\n\n\n\n    /**\n     * Fix for:\n     * - Taxonomy names in Taxonomy Manage page\n     * - 'Popular Tags' in Taxonomy (Tags) Manage page\n     * - Category filter dropdown menu in Post Manage page\n     * - Category list in Post Edit page\n     * - 'Most Used' tags list in Post Edit page (but have issues when saving)\n     * \n     * @param (array) $terms\n     * @param (string|array) $taxonomy\n     * @since 1.2\n     */\n    function get_terms($terms, $taxonomy) {\n        \n        global $pagenow;\n        \n        \n        if ( $pagenow != 'admin-ajax.php' ) {\n            \n            $meta = get_option('qtranslate_term_name');\n            $lang = call_user_func($this->get_plugin_prefix() . 'getLanguage');\n                    \n            \n            if ( !empty( $terms ) ) {\n                foreach ($terms as $term_index => $term) {\n                    // after saving, dont do anything\n                    if( ( isset($_POST['action'] ) && $_POST['action']  == \"editedtag\") ||\n                     !is_object( $term ) ) {\n                        return $terms;\n                    }\n                    $termname = $term->name;\n\t\t\t\t\tif( isset( $meta[$termname][$lang] ) ) {\n                        $term->name = $meta[$termname][$lang];\n                    }\n                };\n            };\n        }\n        return $terms;\n    }\n\n\n\n    /**\n     * Fix for:\n     * - Taxonomy & custom taxonomy names in Post Manage page\n     * - List of tags already added to the post in Post \n     * - Edit page (but have issues when saving)\n     *\n     * @param (array) $terms\n     * @param (int|array) $obj_id\n     * @param (string|array) $taxonomy\n     * @param (array) $taxonomy\n     * @since 1.2\n     */ \n    function get_object_terms($terms, $obj_id, $taxonomy, $args) {\n        \n        global $pagenow;\n        \n        // Although in post edit page the tags are translated,\n        // but when saving/updating the post Wordpress considers\n        // the translated tags as new tags. Due to this\n        // issue I limit this 'hack' to the post manage\n        // page only.\n        if ( $pagenow == 'edit.php' ) {\n            \n            // $taxonomy output seems to be wrapped\n            // in single quotes, thus remove them to\n            // make the output valid\n            $tax = str_replace(\"'\", \"\", $taxonomy);\n            \n            $meta = get_option('qtranslate_term_name');\n            $lang = call_user_func($this->get_plugin_prefix() . 'getLanguage');\n            \n            if ( !empty( $terms ) ) {\n                foreach ($terms as $term) {\n                    if( isset( $meta[$term->name][$lang] ) ) {\n                        $term->name = $meta[$term->name][$lang];\n                    }\n                };\n            };\n        \n        }\n        return $terms;\n    }\n\n\n\n    /**\n     * hide quickedit slug\n     * \n     * @since 1.0\n     */\n    public function hide_quick_edit() {\n        echo \"<!-- QTS remove quick edit box -->\" . PHP_EOL;\n        echo \"<style type=\\\"text/css\\\" media=\\\"screen\\\">\" . PHP_EOL;\n        echo \"  .inline-edit-row fieldset.inline-edit-col-left .inline-edit-col *:first-child + label + label  { display: none !important }\" . PHP_EOL;\n        echo \"</style>\" . PHP_EOL;\n    }\n    \n    \n    \n    /**\n     * Hide auttomatically the wordpress slug blog in edit posts page\n     *\n     * @since 1.0\n     */\n    public function hide_slug_box() {\n        global $pagenow;\n        \n        switch ( $pagenow ):\n            case 'edit-tags.php':\n            \n                echo \"<!-- QTS remove slug box -->\" . PHP_EOL;\n                echo \"<script type=\\\"text/javascript\\\" charset=\\\"utf-8\\\">\" . PHP_EOL;\n                echo \"  jQuery(document).ready(function($){\" . PHP_EOL;\n                echo \"      $(\\\"#tag-slug\\\").parent().hide();\" . PHP_EOL;\n                echo \"      $(\\\".form-field td #slug\\\").parent().parent().hide();\" . PHP_EOL;\n                echo \"  });\" . PHP_EOL;\n                echo \"</script>\" . PHP_EOL;\n                break;\n            \n            case 'post.php':\n            \n                echo \"<!-- QTS remove slug box -->\" . PHP_EOL;\n                echo \"<style type=\\\"text/css\\\" media=\\\"screen\\\">\" . PHP_EOL;\n                echo \"  #edit-slug-box { display: none !important}\" . PHP_EOL;\n                echo \"</style>\" . PHP_EOL;\n                break;\n        endswitch;\n    }\n    \n    \n        \n    /**\n     * Creates a metabox for every post, page and post type avaiable\n     *\n     * @since 1.0\n     */\n    public function add_slug_meta_box() {\n        \n        if ( function_exists( 'add_meta_box' ) ) {\n            \n            add_meta_box( 'qts_sectionid', __('Slug', 'qts'), array(&$this, 'draw_meta_box'), 'post', 'side', 'high');\n            add_meta_box( 'qts_sectionid', __('Slug', 'qts'), array(&$this, 'draw_meta_box'), 'page', 'side', 'high' );\n            \n            foreach ( get_post_types( array('_builtin' => false ) ) as $ptype )\n                add_meta_box( 'qts_sectionid', __('Slug', 'qts'), array(&$this, 'draw_meta_box'), $ptype, 'side', 'high' );\n        }\n    }\n    \n    \n    \n    /**\n     * Shows the fields where insert the translated slugs in the post and page edit form.\n     *\n     * @param $post (object) current post object\n     *\n     * @since 1.0\n     */\n    public function draw_meta_box( $post ) {\n        global $q_config;\n      \n        // Use nonce for verification\n        echo \"<table style=\\\"width:100%\\\">\" . PHP_EOL;\n        echo \"<input type=\\\"hidden\\\" name=\\\"qts_nonce\\\" id=\\\"qts_nonce\\\" value=\\\"\" . wp_create_nonce( 'qts_nonce' ) . \"\\\" />\" . PHP_EOL;\n  \n        foreach ($q_config['enabled_languages'] as $lang):\n            \n            $slug = get_post_meta( $post->ID, $this->get_meta_key($lang), true);\n            \n            $value = ( $slug ) ? htmlspecialchars( $slug , ENT_QUOTES ) : '';\n            \n            echo \"<tr>\" . PHP_EOL;\n            echo \"<th style=\\\"text-align:left; width:10%; color:#555 \\\"><label for=\\\"qts_{$lang}_slug\\\">\".__($q_config['language_name'][$lang], 'qtranslate').\"</label></th>\" . PHP_EOL;\n            echo \"<td><input type=\\\"text\\\" id=\\\"qts_{$lang}_slug\\\" name=\\\"qts_{$lang}_slug\\\" value=\\\"$value\\\" style=\\\"width:90%; margin-left:10%; color:#777\\\" /></td>\" . PHP_EOL;\n            echo \"</tr>\" . PHP_EOL;\n            \n        endforeach;\n        \n        echo '</table>' . PHP_EOL;\n    }\n    \n    \n    \n    /**\n     * Sanitize title as slug, if empty slug\n     * \n     * @param $post (object) the post object\n     * @param $slug (string) the slug name\n     * @param $lang (string) the language\n     * @return the slug validated\n     *\n     * @since 1.0\n     */\n    public function validate_post_slug( $slug, $post, $lang ) { \n            \n        $post_title = trim(call_user_func($this->get_plugin_prefix() . 'use',$lang, $_POST['post_title']));\n        $post_name = get_post_meta($post->ID, $this->get_meta_key($lang), true);\n        if (!$post_name) {\n            $post_name = $post->post_name;\n        }\n        \n        $name = ( $post_title == '' || strlen($post_title) == 0 ) ? $post_name : $post_title;\n        \n        $slug = trim($slug);\n            \n        $slug = (empty($slug)) ? sanitize_title($name) : sanitize_title($slug);\n        \n        \n        \n        return htmlspecialchars( $slug , ENT_QUOTES );\n    }\n    \n    \n    \n    /**\n     * Validates post slug against repetitions per language\n     * \n     * @param $post (object) the post object\n     * @param $slug (string) the slug name\n     * @param $lang (string) the language\n     * @return the slug validated\n     *\n     * @since 1.0\n     */\n    public function unique_post_slug( $slug, $post, $lang ) {\n        \n        $original_status = $post->post_status;\n        \n        if ( in_array($post->post_status, array('draft', 'pending')) ) {\n            $post->post_status = 'publish';\n        }\n        \n        $slug = $this->wp_unique_post_slug( $slug, $post->ID, $post->post_status, $post->post_type, $post->post_parent, $lang );\n        \n        $post->post_status = $original_status;\n        \n        return $slug;\n    }\n    \n    \n    \n    /**\n     * Computes a unique slug for the post and language, when given the desired slug and some post details.\n     *\n     * @param string $slug the desired slug (post_name)\n     * @param integer $post_ID\n     * @param string $post_status no uniqueness checks are made if the post is still draft or pending\n     * @param string $post_type\n     * @param integer $post_parent\n     * @return string unique slug for the post, based on language meta_value (with a -1, -2, etc. suffix)\n     *\n     * @since 1.0\n     */\n    public function wp_unique_post_slug( $slug, $post_ID, $post_status, $post_type, $post_parent, $lang ) {\n        if ( in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) ) {\n            return $slug;\n        }\n\n        global $wpdb, $wp_rewrite;\n\n        $feeds = $wp_rewrite->feeds;\n        if ( ! is_array( $feeds ) ) {\n            $feeds = array();\n        }\n        \n        $meta_key = $this->get_meta_key($lang);\n        if ( 'attachment' == $post_type ) {\n            // Attachment slugs must be unique across all types.\n            $check_sql = \"SELECT post_name FROM $wpdb->posts WHERE post_name = %s AND ID != %d LIMIT 1\";\n            $post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $slug, $post_ID ) );\n\n            if ( $post_name_check || in_array( $slug, $feeds ) || apply_filters( 'wp_unique_post_slug_is_bad_attachment_slug', false, $slug ) ) {\n                $suffix = 2;\n                do {\n                    $alt_post_name = substr ($slug, 0, 200 - ( strlen( $suffix ) + 1 ) ) . \"-$suffix\";\n                    $post_name_check = $wpdb->get_var( $wpdb->prepare($check_sql, $alt_post_name, $post_ID ) );\n                    $suffix++;\n                } while ( $post_name_check );\n                $slug = $alt_post_name;\n            }\n        } else {\n            // Post slugs must be unique across all posts.\n            $check_sql = \"SELECT $wpdb->postmeta.meta_value FROM $wpdb->posts,$wpdb->postmeta WHERE $wpdb->posts.ID = $wpdb->postmeta.post_id AND $wpdb->postmeta.meta_key = '%s' AND $wpdb->postmeta.meta_value = '%s' AND $wpdb->posts.post_type = %s AND ID != %d LIMIT 1\";\n            $post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $meta_key, $slug, $post_type, $post_ID ) );\n\n            if ( $post_name_check || in_array( $slug, $feeds ) || apply_filters( 'wp_unique_post_slug_is_bad_flat_slug', false, $slug, $post_type ) ) {\n                $suffix = 2;\n                do {\n                    $alt_post_name = substr( $slug, 0, 200 - ( strlen( $suffix ) + 1 ) ) . \"-$suffix\";\n                    $post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $meta_key, $alt_post_name, $post_type, $post_ID ) );\n                    $suffix++;\n                } while ( $post_name_check );\n                $slug = $alt_post_name;\n            }\n        }\n\n        return $slug;\n    }\n    \n    \n    \n    \n    /**\n     * Saves the translated slug when the page is saved\n     * \n     * @param $post_id the post id\n     * @param $post the post object\n     *\n     * @since 1.0\n     */\n    public function save_postdata( $post_id, $post ) {\n        \n        $post_type_object = get_post_type_object( $post->post_type);\n        \n        \n        if ((defined('DOING_AUTOSAVE') && DOING_AUTOSAVE)                       // check autosave\n        || (!isset($_POST['post_ID']) || $post_id != $_POST['post_ID']) // check revision\n        || (!wp_verify_nonce( $_POST['qts_nonce'], 'qts_nonce'))                // verify nonce\n        || (!current_user_can($post_type_object->cap->edit_post, $post_id))) {  // check permission\n            return $post_id;\n        }\n        foreach ($this->get_enabled_languages() as $lang) {\n            \n            $meta_name = $this->get_meta_key($lang);\n            $meta_value = apply_filters( 'qts_validate_post_slug', $_POST[\"qts_{$lang}_slug\"], $post, $lang);\n            delete_post_meta($post_id, $meta_name);\n            update_post_meta($post_id, $meta_name, $meta_value);\n            \n        }\n    }\n    \n    \n    \n    /**\n     * Display multiple input fields, one per language\n     * \n     * @param $term the term object\n     *\n     * @since 1.0\n     */\n    public function show_term_fields( $term ) {\n        global $q_config;\n        \n        // prints the fields in edit page\n        if (isset($_GET['action']) && $_GET['action'] == 'edit' ):\n  \n            echo \"<table class=\\\"form-table\\\">\" . PHP_EOL;\n            echo \"<input type=\\\"hidden\\\" name=\\\"qts_nonce\\\" id=\\\"qts_nonce\\\" value=\\\"\" .  wp_create_nonce( 'qts_nonce' ) . \"\\\" />\" . PHP_EOL;\n  \n            foreach( $q_config['enabled_languages'] as $lang ) {\n            \n                $slug = (is_object($term)) ? get_term_meta( $term->term_id, $this->get_meta_key($lang), true ) : '';\n            \n                $value = ( $slug ) ? htmlspecialchars( $slug , ENT_QUOTES ) : '';\n            \n                echo \"<tr class=\\\"form-field form-required\\\">\" . PHP_EOL;\n                echo \"<th scope=\\\"row\\\" valig=\\\"top\\\"><label for=\\\"qts_{$lang}_slug\\\">\".sprintf( __('Slug (%s)', 'qts'), $q_config['language_name'][$lang] ).\"</label></th>\" . PHP_EOL;\n                echo \"<td><input type=\\\"text\\\" name=\\\"qts_{$lang}_slug\\\" value=\\\"$value\\\" /></td></tr>\" . PHP_EOL;\n            \n            }\n        \n            echo '</table>';\n        \n        // prints the fields in new page\n        else:\n            echo \"<input type=\\\"hidden\\\" name=\\\"qts_nonce\\\" id=\\\"qts_nonce\\\" value=\\\"\" .  wp_create_nonce( 'qts_nonce' ) . \"\\\" />\" . PHP_EOL;\n  \n            foreach( $q_config['enabled_languages'] as $lang ) {\n                \n                echo \"<div class=\\\"form-field\\\">\" . PHP_EOL;\n            \n                $slug = (is_object($term)) ? get_term_meta( $term->term_id, $this->get_meta_key($lang), true ) : '';\n            \n                $value = ( $slug ) ? htmlspecialchars( $slug , ENT_QUOTES ) : '';\n            \n                echo \"<label for=\\\"qts_{$lang}_slug\\\">\".sprintf( __('Slug (%s)', 'qts'), $q_config['language_name'][$lang] ).\"</label>\" . PHP_EOL;\n                echo \"<input type=\\\"text\\\" name=\\\"qts_{$lang}_slug\\\" value=\\\"$value\\\" aria-required=\\\"true\\\">\" . PHP_EOL;\n                \n                echo '</div>';\n            \n            }\n\n        endif;\n    }\n    \n    \n    \n    /**\n     * Sanitize title as slug, if empty slug\n     * \n     * @param $term (object) the term object\n     * @param $slug (string) the slug name\n     * @param $lang (string) the language\n     * @return the slug validated\n     *\n     * @since 1.0\n     */\n    public function validate_term_slug( $slug, $term, $lang ) {\n\n        global $q_config;\n        \n        $lang_name = $q_config['term_name'][$term->name][$lang];\n        \n        $ajax_name = 'new' . $term->taxonomy;\n        \n        $post_name = isset($_POST['name']) ? $_POST['name'] : '';\n        \n        $term_name = isset($_POST[$ajax_name]) ? trim($_POST[$ajax_name]) : $post_name;\n    \n        if (empty($term_name)) {\n            return $slug;\n        }\n        \n        $name = ( $lang_name == '' || strlen($lang_name) == 0 ) ? $term_name : $lang_name;\n        \n        $slug = trim($slug);\n            \n        $slug = (empty($slug)) ? sanitize_title($name) : sanitize_title($slug);\n        \n        return htmlspecialchars( $slug , ENT_QUOTES );\n    }\n    \n    \n    \n    /**\n     * Will make slug unique per language, if it isn't already.\n     *\n     * @param string $slug The string that will be tried for a unique slug\n     * @param object $term The term object that the $slug will belong too\n     * @param object $lang The language reference \n     * @return string Will return a true unique slug.\n     *\n     * @since 1.0\n     */\n    public function unique_term_slug($slug, $term, $lang) {\n      \n        global $wpdb;\n\t\t\n        $meta_key_name = $this->get_meta_key($lang);\n        $query = $wpdb->prepare(\"SELECT term_id FROM $wpdb->termmeta WHERE meta_key = '%s' AND meta_value = '%s' AND term_id != %d \", $meta_key_name, $slug, $term->term_id);\n        $exists_slug = $wpdb->get_results($query);\n\n        if ( empty($exists_slug) ) {\n            return $slug;\n        }\n        \n        // If we didn't get a unique slug, try appending a number to make it unique.\n        $query = $wpdb->prepare(\"SELECT meta_value FROM $wpdb->termmeta WHERE meta_key = '%s' AND meta_value = '%s' AND term_id != %d\", $meta_key_name, $slug, $term->term_id);\n\n        if ( $wpdb->get_var( $query ) ) {\n          $num = 2;\n          do {\n            $alt_slug = $slug . \"-$num\";\n            $num++;\n            $slug_check = $wpdb->get_var(\n              $wpdb->prepare(\n               \"SELECT meta_value FROM $wpdb->termmeta WHERE meta_key = '%s' AND meta_value = '%s'\",\n               $meta_key_name,\n               $alt_slug) );\n          } while ( $slug_check );\n          $slug = $alt_slug;\n        }\n\n        return $slug;\n    }\n    \n    \n    \n    /**\n     * Display multiple input fields, one per language\n     * \n     * @param $term_id the term id\n     * @param $tt_id the term taxonomy id\n     * @param $taxonomy the term object\n     *\n     * @since 1.0\n     */\n    public function save_term( $term_id, $tt_id, $taxonomy ) {\n        \n        $cur_screen = get_current_screen();\n        if ( (defined('DOING_AUTOSAVE') && DOING_AUTOSAVE )  // check autosave\n        || ( !current_user_can('edit_posts') ) // check permission\n        || ( isset($cur_screen) && $cur_screen->id === \"nav-menus\") \n        ) {                  \n            return $term_id;\n        }\n        \n        $term = get_term( $term_id, $taxonomy);\n        foreach( $this->get_enabled_languages() as $lang ) {\n            $meta_name = $this->get_meta_key($lang);\n      \n            //43LC: when at the post edit screen and creating a new tag\n            // the $slug comes from $_POST with the value of the post slug,\n            // not with the term slug. \n            if ($_POST['action'] == \"editpost\")  {\n                // so we use the slug wp gave it\n                $term_slug = $term->slug;\n            } else {\n                // otherwise, its the edit term screen\n                $term_slug =  $_POST[\"qts_{$lang}_slug\"];\n            }\n            \n            $meta_value = apply_filters( 'qts_validate_term_slug', $term_slug, $term, $lang);\n                \n            delete_term_meta($term_id, $meta_name);\n            update_term_meta($term_id, $meta_name, $meta_value);\n       }\n    }\n    \n    \n    \n    /**\n     * deletes termmeta rows associated with the term\n     * \n     * @since 1.0\n     */ \n    public function delete_term($term_id, $tt_id, $taxonomy) {\n        global $wpdb;\n        \n        $wpdb->query( $wpdb->prepare( \"DELETE FROM $wpdb->termmeta WHERE term_id = %d\", $term_id ) );\n    }\n    \n    \n    \n    /**\n\t * creates and prints the forms and hides the default fields \n\t * @param object $term the term object \n\t * @since 1.1.12\n\t * \n\t * TODO: merge with our own form.\n\t * TODO: move code into js file\n\t *\n\t */\n\tpublic function qts_modify_term_form($term) {\n\t\techo \"<script type=\\\"text/javascript\\\">\\n// <![CDATA[\\r\\n\";\n\t\tif(is_object($term)&&isset($term->name)) {\n\t\t\t$termname = $term->name;\n\t\t} else {\n\t\t\t$termname = \"\";\n\t\t}\n\t    if(isset($_GET['action']) && $_GET['action']=='edit') {\n\t\t   foreach($this->get_enabled_languages() as $language) {\n\t\t\t   echo $this->qts_insert_term_input('name', __('Name','qts'), $termname, $language,\"edit\");\n\t        }\n\t    } else {\n\t\t   foreach($this->get_enabled_languages() as $language) {\n\t           echo $this->qts_insert_term_input('tag-name', __('Name','qts'), $termname, $language,\"new\");   \n\t        }\n\t    }\n\t\t// hide real category text\n\t\techo \"if (ins != null) ins.style.display='none';\\n\";\n\t\techo \"// ]]>\\n</script>\\n\";\n\t}\n\n\t/**\n\t * Helper for qts_modify_term_form_for\n\t * @param string $id the term id\n\t * @param object #term the term\n\t * @param string $language the term name\n\t * @param string $action the term name\n\t * @return string $html the new input fields\n\t * @since 1.1.12\n\t * TODO: use DocumentFragment\n\t */\n\tprivate function qts_insert_term_input($id,$name, $language,$action){\n\t\tglobal $q_config;\n\t\t$html = \"\";\n\t\tif( $action === \"new\") {\n\t\t    $html =\"\n\t        var il = document.getElementsByTagName('input'),\n\t        \t d = document.createElement('div'),\n                 l = document.createTextNode('\".$name.\" (\".$q_config['language_name'][$language].\")'),\n\t            ll = document.createElement('label'),\n\t             i = document.createElement('input'),\n\t           ins = null;\n\t        for(var j = 0; j < il.length; j++) {\n\t            if(il[j].id=='\".$id.\"') {\n\t                ins = il[j];\n\t                break;\n\t            }\n\t        }\n\t        i.type = 'text';\n\t        i.id = i.name = ll.htmlFor ='qtrans_term_\".$language.\"';\n\t    \";\n\t\t} elseif ( $action === \"edit\") {\n\t\t    $html =\"\n\t        var tr = document.createElement('tr'),\n\t            th = document.createElement('th'),\n\t            ll = document.createElement('label'),\n\t             l = document.createTextNode('\".$name.\" (\".$q_config['language_name'][$language].\")'),\n\t            td = document.createElement('td'),\n\t             i = document.createElement('input'),\n\t           ins = document.getElementById('\".$id.\"');\n\t        i.type = 'text';\n\t        i.id = i.name = ll.htmlFor ='qtrans_term_\".$language.\"';\n\t    \";\n\t    }\n\t\tif(isset($q_config['term_name'][$termname][$language])) {\n  \t\t $html .=\"\n\t\t     i.value = '\".addslashes(htmlspecialchars_decode($q_config['term_name'][$termname][$language], ENT_QUOTES)).\"';\";\n\t\t     //43LC: applied ENT_QUOTES to both edit and new forms. \n\t\t} else {\n\t\t  $html .=\"\n\t\t\t  if (ins != null)\n\t\t\t\t  i.value = ins.value;\n\t\t\t  \";\n\t\t}\n\t\t\n\t\tif($language == $this->default_language) {\n\t\t\t$html .=\"\n\t\t\t\ti.onchange = function() { \n\t\t\t\t\tvar il = document.getElementsByTagName('input'),\n\t\t\t\t\t   ins = null;\n\t\t\t\t\tfor(var j = 0; j < il.length; j++) {\n\t\t\t\t\t\tif(il[j].id=='\".$id.\"') {\n\t\t\t\t\t\t\tins = il[j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ins != null)\n\t\t\t\t\t\tins.value = document.getElementById('qtrans_term_\".$language.\"').value;\n\t\t\t\t};\n\t\t\t\t\";\n\t\t}\n\t\tif( $action === \"new\") {\n\t        $html .=\"\n\t        if (ins != null)\n\t            ins = ins.parentNode;\n\t        d.className = 'form-field form-required';\n\t        ll.appendChild(l);\n\t        d.appendChild(ll);\n\t        d.appendChild(i);\n\t        if (ins != null)\n\t            ins.parentNode.insertBefore(d,ins);\n\t        \";\n\t    } elseif ( $action === \"edit\") {\n\t        $html .=\"\n\t        ins = ins.parentNode.parentNode;\n\t        tr.className = 'form-field form-required';\n\t        th.scope = 'row';\n\t        th.vAlign = 'top';\n\t        ll.appendChild(l);\n\t        th.appendChild(ll);\n\t        tr.appendChild(th);\n\t        td.appendChild(i);\n\t        tr.appendChild(td);\n\t        ins.parentNode.insertBefore(tr,ins);\n\t        \";\n\t    }\n\t\treturn $html;\t\n\t}\n    /**\n     * adds support for qtranslate in taxonomies\n     *\n     * @since 1.0\n     */\n    public function taxonomies_hooks() {\n    \n        $taxonomies = $this->get_public_taxonomies();\n\n        if ($taxonomies) {\n            foreach ($taxonomies  as $taxonomy ) {\n                add_action( $taxonomy->name.'_add_form', array(&$this, 'qts_modify_term_form'));\n                add_action( $taxonomy->name.'_edit_form', array(&$this, 'qts_modify_term_form'));\n                add_action( $taxonomy->name.'_add_form',  array(&$this, 'show_term_fields'));\n                add_action( $taxonomy->name.'_edit_form_fields', array(&$this, 'show_term_fields') );\n                add_filter('manage_edit-'.$taxonomy->name.'_columns', array(&$this, 'taxonomy_columns'));\n                add_filter('manage_'.$taxonomy->name.'_custom_column', array(&$this, 'taxonomy_custom_column'), 0, 3);\n            }\n        }\n    }\n    \n    \n    \n    /*\n     * Bug fix for slug column in taxonomies\n     * \n     * @since 1.0\n     */\n    public function taxonomy_columns($columns) {\n        unset($columns['slug']);\n        unset($columns['posts']);\n        \n        $columns['qts-slug'] = __('Slug', 'qts');\n        $columns['posts'] = __('Posts', 'qts');\n        \n        return $columns;\n    }\n    \n    \n    \n    /*\n     * Bug fix for slug column in taxonomies\n     * \n     * @since 1.0\n     */\n    public function taxonomy_custom_column($str, $column_name, $term_id) {\n        \n        switch ($column_name) {\n            case 'qts-slug':\n                echo get_term_meta($term_id, $this->get_meta_key(), true);\n                break;\n        }\n        return false;\n    }\n    \n    \n    \n    \n    /**\n     * Bug fix for multisite blog names\n     * \n     * @since 1.0\n     */\n    public function blog_names($blogs) {\n        \n        foreach ($blogs as $blog) {\n            $blog->blogname = __($blog->blogname);\n        }\n        \n        return $blogs;\n    }\n    \n    \n    \n    /**\n     * Initialise the Language Widget selector\n     * \n     * @since 1.0\n     */\n    public function widget_init() {\n        \n        if (class_exists('qTranslateWidget')) {\n            unregister_widget('qTranslateWidget');\n        }\n        if (class_exists('mqTranslateWidget')) {\n            unregister_widget('mqTranslateWidget');\n        }\n        if (class_exists('ppqTranslateWidget')) {\n            unregister_widget('ppqTranslateWidget');\n        }\n        \n        //if (class_exists('qTranslateXWidget')) {//it has additional features some people use.\n        //    unregister_widget('qTranslateXWidget');\n        //}\n        \n        register_widget('QtranslateSlugWidget');\n    }\n    \n    \n    \n    /**\n     * remove some default dashboard Widgets on Desktop\n     *\n     * @since 1.0\n     */\n    function remove_dashboard_widgets() {\n        global $wp_meta_boxes;\n        unset($wp_meta_boxes['dashboard']['side']['core']['dashboard_quick_press']);\n    } \n    \n    \n    \n    /**\n     * adds support for qtranslate nav menus\n     * \n     * @since 1.0\n     */\n    public function fix_nav_menu() {\n        global $pagenow;\n        \n        if( $pagenow != 'nav-menus.php' ) {\n            return;\n        }\n\t\t\t\t//FIXME: fix the nav menu box\n\t\t\t\t//        wp_enqueue_script( 'nav-menu-query',  plugins_url( 'assets/js/qts-nav-menu-min.js' , dirname(__FILE__ ) ), 'nav-menu', '1.0' );\n\t\t\t\t//        add_meta_box( 'qt-languages', __('Languages', 'qts'), array(&$this, 'nav_menu_meta_box'), 'nav-menus', 'side', 'default' );\n    }\n    \n    \n    \n    /**\n     * draws meta box for select language\n     * \n     * @since 1.0\n     */\n    public function nav_menu_meta_box() {\n        global $q_config;\n        echo '<p>';\n        foreach($q_config['enabled_languages'] as $id => $language) {\n            $checked = ($language == $q_config['language']) ? ' checked=\"checked\"' : '';\n            echo '<p style=\"margin:0 0 5px 0\"><input type=\"radio\" style=\"margin-right:5px\" name=\"wa_qt_lang\" value=\"' . $language . '\" id=\"wa_gt_lang_' . $id . '\" ' . $checked . '/>';\n            echo '<label for=\"wa_gt_lang_' . $id . '\">';\n            echo '<img src=\"' . trailingslashit(WP_CONTENT_URL).$q_config['flag_location'].$q_config['flag'][$language] . '\"/>&nbsp;';\n            echo __($q_config['language_name'][$language], 'qtranslate');\n            echo '</label></p>';\n        }\n         echo '<p style=\"margin:0 0 5px 0\"><input type=\"radio\" style=\"margin-right:5px\" name=\"wa_qt_lang\" value=\"all\" id=\"wa_gt_lang_999\" />';\n            echo '<label for=\"wa_gt_lang_999\">';\n            echo __('All languages', 'qts');\n            echo '</label></p>';\n        echo '</p>';\n    }\n    \n    \n    \n    /**\n     * Language select function for templating\n     *\n     * @param $type (string) choose the type of menu: 'text', 'image', 'both', 'dropdown' \n     * @param $args (array) some args for draw the menu: array( 'id', 'class', 'short' );\n     * \n     * @since 1.0\n     */\n    public function language_menu( $type = \"text\", $args = array() ) {\n        global $q_config;\n        \n\n        // default arguments\n        $defaults = array(\n            'id' => \"qts-lang-menu\",\n            'class' => \"qts-lang-menu\",\n            'short' => false\n        );\n        $args = wp_parse_args( $args, $defaults );\n        \n        $languages = call_user_func($this->get_plugin_prefix() . 'getSortedLanguages');\n        \n        // every type\n        switch ( $type ) {\n            \n            case 'image':\n            case 'text':\n            case 'both':\n            \n                $baseurl = dirname(plugins_url());\n                $num_languages = count($languages);\n                echo \"<ul id=\\\"{$args['id']}\\\" class=\\\"qts_type_{$type} {$args['class']}\\\">\". PHP_EOL;\n                \n                foreach( $languages as $index => $lang ):\n                    \n                    $url = $this->get_current_url($lang);\n                    // 43LC: hack to play nice with qtranslate-x\n                    if( \"qtranxf_\" === $this->plugin_prefix && $this->default_language === $lang ) {\n\n                        $url = qtranxf_convertURL('',$lang,false,true);\n                    }\n                    $item_class = array();\n                    if ( (string)$q_config['language'] == (string)$lang ) $item_class[] = 'current-menu-item';\n                    if ( $index == ( $num_languages - 1) ) $item_class[] = 'last-child';\n                    \n          \n                    $item_class = ' class=\"qts_lang_item ' . implode(' ', $item_class) . '\"';\n                    \n                    $language_name = ($args['short']) ? $lang : $q_config['language_name'][$lang];\n                    \n                    if ( $type == 'image' ) {\n                        $link_class = \" class=\\\"qtrans_flag qtrans_flag_$lang\\\"\";\n                        $link_content = \"<span style=\\\"display:none\\\">$language_name</span>\";\n                    } else if ( $type == 'both' ) {\n                        $link_class = \" class=\\\"qts_both qtrans_flag qtrans_flag_$lang\\\"\";\n                        $link_content = \"$language_name\";                        \n                    } else {\n                        $link_class = '';\n                        $link_content = $language_name;\n                        $link_flag ='';\n                    }\n                    if( $type == 'image' || $type == 'both' ) {\n                        $link_flag_url =  $baseurl . '/'.$q_config['flag_location'].$q_config['flag'][$lang];\n                        \n                        //TODO: add i18n for alt attribute\n                        //43LC: hardcoding height and width\n                        $link_flag = \"<img widht=\\\"18\\\" height=\\\"12\\\" src=\\\"$link_flag_url\\\" alt=\\\"$language_name\\\" />\";\n                    }\n\n                    echo \"<li $item_class><a href=\\\"$url\\\" lang=\\\"$lang\\\" hreflang=\\\"$lang\\\"$link_class>$link_flag$link_content</a></li>\" . PHP_EOL;\n                    \n                endforeach;\n                \n                echo \"</ul>\". PHP_EOL;\n                \n                break;\n                \n            case 'dropdown':\n            \n                echo \"<select id=\\\"{$args['id']}\\\" class=\\\"{$args['class']}\\\" onchange=\\\"window.location.href=this.options[this.selectedIndex].value\\\">\". PHP_EOL;\n                \n                foreach( $languages as $index => $lang ):\n                    \n                    $url = $this->get_current_url($lang);\n                    \n                    $item_class = '';\n                    if ( (string)$q_config['language'] == (string)$lang ) $item_class = 'selected=\"selected\"';\n                    \n                    $language_name = ($args['short']) ? $lang : $q_config['language_name'][$lang];\n                    \n                    echo \"<option value=\\\"$url\\\" $item_class>$language_name</option>\" . PHP_EOL;\n                    \n                endforeach;\n                \n                echo \"</select>\". PHP_EOL;\n\n                break;\n        }\n        \n    }\n}\n", "=== Qtranslate Slug ===\nContributors: carlos_a_sanz, pedroghandi  \nDonate link: https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=SYC46KSLRC4Q8\nTags: qtranslate, slug, multilanguage, widget\nRequires at least: 3.3\nTested up to: 4.1.1\nStable tag: 1.1.16\nLicense: GPLv2 or later\nLicense URI: http://www.gnu.org/licenses/gpl-2.0.html\n\nAdds support for permalink translations and fix some QTranslate deficiencies since wordpress 3.0\n\n== Description ==\n\n[Qtranslate](http://wordpress.org/plugins/qtranslate/) is a nice plugin but unfortunately today is **outdated**. **Qtranslate Slug** is an addon to QTranslate, which adds support for permalinks translations and fix some QTranslate deficiencies since wordpress 3.0. Check out all the new forks from qtranslate!\n\n**Version 1.0** has been written from scratch using OOP. The code has been structured better, the functions have been marked and commented and everything is better integrated with Wordpress API.\n\n= Requirements: =\n\n* Wordpress 3.3 (PHP 5.4 and MySQL 5)\n* mQtranslate 2.6.2.4 or Qtranslate 2.5.8 or qtranslate-x ( 2.9.1 )\n\n= New in 1.1.16 =\nMinor fix for the language menu using qtranslate's function\n\n= New in 1.1.15 =\n* Fixes the duplicated hreflang links in <head>\n\n= New in 1.1.14 =\n\nThe menu widget didn't allow the visitors to change to the default language if qtranslate-x was being used. So, adjusted the Language Menu widget to play nice with qtranslate-x. \nHope to bring some nice changes that were made in the github repository in the next version. For now, enjoy.\n\n= New in 1.1.13 =\n== Thanks to returning @pedro-mendonca for these commits: ==\n* Cleaned duplicated label in widget\n* Bug fix in \"Slug (%s)\" string translation\n* Changed text strings with no text-domain and with text-domain 'qtranlate' to text-domain 'qts'\n* pot catalog updated with current strings, including last found is \"More information about\".\n== Thanks to @johnclause for these : ==\n* Convenience links in notice_dependences\n* Menu compatibility with qTranslate-X\n* Fixed extra characters in widget\n### Thanks to vbkun for casting the much wanted function to get a slug based on an id and language\n* Added a global qts_get_slug( $id, $lang)\n### and sadly:\n* removed the menu admin box until better implementation\n\n\nSee you next Version!\n\n\n**Advice: If you're using a multisite installation, you will must activate qtranslate plugins by separately on each site.**\n\nYou can also check the [project website](http://not-only-code.github.com/qtranslate-slug/) hosted on [GitHub](http://not-only-code.github.com).\nThanks for use this plugin!\n\n= Contributors =\n\n* [Pedro de Carvalho](https://github.com/LC43/)\n* [Risto Niinemets](https://github.com/RistoNiinemets)\n* [Pedro Mendon\u00e7a](https://github.com/pedro-mendonca)\n* [codep0et](https://github.com/codep0et)\n* [Giraldi Maggio](https://github.com/bedex78)\n* [jinoOM](https://github.com/jinoOM)\n* [Juanfran](https://github.com/juanfran-granados)\n* [Arild](https://github.com/arildm)\n* [Rafa Aguilar](https://github.com/rafitaFCB)\n* [Bastian Heist](https://github.com/beheist)\n* [John Clause](https://github.com/johnclause)\n\n\n== Installation ==\n**This plugins requires [Qtranslate](http://wordpress.org/extend/plugins/qtranslate/) or [mqTranslate](https://wordpress.org/plugins/mqtranslate/) installed previously, if not, it will not activate.**\n\n1. Upload `qtranslate-slug` to the `/wp-content/plugins/` directory.\n1. Activate the plugin through the 'Plugins' menu in WordPress.\n1. That's all!\n\n= Changing base permastructs =\n\n1. In admin: navigate to *Settings/Slug options*.\n1. Set the base permastructs for **post types** and **taxonomies** (If you setup a base permastruct for *categories* or *tags* in *Settings/Permalinks*, these will be overwritten by the translated ones).\n1. Save settings and that's all!\n\n== Frequently Asked Questions ==\n\n= It works with posts and pages, but with other content type? =\n\nThis plugin allows to translate slugs of: posts, pages, custom post types, categories, tags and custom taxonomies.\n\n= Do I have to configure anything? =\n\nIf you want to translate also the base permastructs (ex. *category*, *tag*, etc). Visit the plugin settings page in the admin *Settings/Slug options*\n\n= How can i insert a language selector in my theme ? =\n\nYou can choose to:\n* use **Qtranslate Slug Widget** in your sidebar.\n* place in your template `<?php if (function_exists('qts_language_menu') ) qts_language_menu('text'); ?>`. Options are: `dropdown`, `text`, `image`, and `both`.\n\n= Appears an error 404, what can i do? =\n\nIn the admin go to *Settings/Permalinks* or *Settings/Slug options* and save.\n\n= I can't manage translations in Nav Menus. = \n\nThat's because language selector metabox is hidden, if you are in admin *nav menus* screen, press the button **Screen options** (on top and right) and after, check the option *Languages*. It will appear a **Language** meta box on top of the left sidebar.\n\n= How to get the current url in a specific language? =\n\nYou can use `qts_get_url()` or the awkwardly named `qTranslateSlug_getSelfUrl()` which is an alias for the first one.\n\n\n== Screenshots ==\n\n1. Edit page for: post / page / post_type, you can see the meta box for translated slugs on top and right.\n2. Add new taxonomy page\n3. Edit taxonomy page\n4. Qtranslate Slug options page for translate base permastructs of post_types and taxonomies.\n\n== Changelog ==\n\n\n= New in Versions 1.1.12 =\n\n* fixed warnings in settings\n* replace qtranslate with our own for taxonomies\n\n= New in Versions 1.1.10 and 1.1.11 =\n\n* Fixing wrong commit to wp.org\n* Clean deleted files \n= New in Version 1.1.9 =\n\nLots of bug fixes! Thanks again to everyone that contributed to this project, with commits, bug reports and suggestions.\n\n* Compatibility with qtranslate-X! ( thanks @beheist, pull #85, fixing most of #80 )\n* More updates to the portuguese translation ( thanks pedro-mendonca, pull #86)\n* Corrected the link to language files ( thanks pedro-mendonca )\n* Added translation for some hardcoded texts ( thanks pedro-mendonca )\n* Corrected a link from 'qtranslate' to 'qts' language files ( thanks pedro-mendonca )\n* Fixed taxonomies slugs ( thanks to [eirikv's bug report](https://wordpress.org/support/topic/categories-slug-dont-work) )\n* Fixed many warnings ( thanks piffpaffpuff, issue #78 and to [pedrodu1](https://wordpress.org/support/topic/warnings-qtranslate-slugphp) )\n* Changed the behaviour of \"Quick Edit\", from the wp forums [1](https://wordpress.org/support/topic/categories-tags-and-quick-edit-dont-show-in-admin) [2](https://wordpress.org/support/topic/quick-edit-inhibited-by-qtranslate-slug-with-wp-41-mqtranslate) ( thanks everyone!! )\n* Fixed the menus! Now you can properly use one menu for every language. Use the dropdown section \"Languages\", and for each item, change the \"Navigation Label\" and \"Title Attribute\". Select \"All languages\", to make sure everything is awesome! All these features were a consequence of fixing all the warnings based on [Gery's bug report](https://wordpress.org/support/topic/qtranslate-slug-conflicting-with-ubermenu). \n* Minor fixes, etc. \n\n\n= New in Version 1.1.9 =\n\nLots of bug fixes! Thanks again to everyone that contributed to this project, with commits, bug reports and suggestions.\n\n* Compatibility with qtranslate-X! ( thanks @beheist, pull #85, fixing most of #80 )\n* More updates to the portuguese translation ( thanks pedro-mendonca, pull #86)\n* Corrected the link to language files ( thanks pedro-mendonca )\n* Added translation for some hardcoded texts ( thanks pedro-mendonca )\n* Corrected a link from 'qtranslate' to 'qts' language files ( thanks pedro-mendonca )\n* Fixed taxonomies slugs ( thanks to [eirikv's bug report](https://wordpress.org/support/topic/categories-slug-dont-work)\n* Fixed many warnings ( thanks piffpaffpuff, issue #78 and to [pedrodu1](https://wordpress.org/support/topic/warnings-qtranslate-slugphp) )\n* Changed the behaviour of \"Quick Edit\", from the wp forums [1](https://wordpress.org/support/topic/categories-tags-and-quick-edit-dont-show-in-admin) [2](https://wordpress.org/support/topic/quick-edit-inhibited-by-qtranslate-slug-with-wp-41-mqtranslate) ( thanks everyone!! )\n* Fixed the menus! Now you can properly use one menu for every language. Use the dropdown section \"Languages\", and for each item, change the \"Navigation Label\" and \"Title Attribute\". Select \"All languages\", to make sure everything is awesome! All these features were a consequence of fixing all the warnings based on [Gery's bug report)[https://wordpress.org/support/topic/qtranslate-slug-conflicting-with-ubermenu). \n* Minor fixes, etc. \n\nSee you next Version!\n\n\n= 1.1.8 =\n\nMany thanks to everyone that contributed to this update, for their commits, bug reports and for simply using it\n\n* Portuguese translation and fixed some translation bugs  ( thanks pedro-mendonca )\n* removed mqtranslate switcher widget hook\n* Updated the plugin structure and coding style\n* solve some conflicts with search and pagination queries\n* Settings php errors, syntax indent and fixed settings assets url\n* Change titles when there is a click on pagination on show all pages tab ( thanks juanfran-granados )\n* Formatted dependency notice message ( thanks arildm )\n* Updated the deprecated jquery 'live' function and solve php strict standards error ( thanks rafitaFCB )  \n* Fixed error showing if PHP was newer than 5.3 ( thanks rafitaFCB )  \n* Strict standard advise prevented ( thanks rafitaFCB )\n* php notices are prevented in post edit, when using adding new translated tags  ( thanks rafitaFCB )\n* fixed the hreflang issue! 'bout time!\n* As discussed in issue #25, the flags are now img tags, intead of background-url.\n* Added another option to include the css style in a minified file. ( and also showing in the option screen the styles we would use.)\n\n= 1.1.7 = \n* removed styles from html elements and added options to use .css file or print inline styles\n* fixed tag creation on post edit.\n* fixed earlier bad post slug introduced in 1.1.6\n\n= 1.1.6 =\n* compatible with mqtranslate\n* php5.4+ compatible\n\n= 1.1.5 = \n* bugfixes\n\n= 1.1 = \n* added multisite support\n* fixed some parse url bugs\n* fixed slug bases validation \n\n= 1.0 =\n* **works** with any permalink combination and qtranslate mode.\n* new branch, the plugin has been rewritten: now the code is commented and wrapped inside a class, much code has change and the performance has been increased (use caches).\n* data system changed, no ID for slug type, then it don't needs install `qtrasnlate_slug` table. That means slugs now are stored on meta tables and installation creates a termmeta table with some new *core functions* to access/save data, based on [simple term meta](http://wordpress.org/extend/plugins/simple-term-meta/). Upgrade process when the plugin updates from older versions.\n* the plugin generates translated slug automatically from title in empty cases.\n* the plugin checks if the slug already exists (per each language and `post_type`/`taxonomy`), and adds a progressive number in this case. Works on ajax requests for example when new taxonomies are created in edit post page.\n* possibility to translate the base of permastructs for *post_types* and *taxonomies*, uses [$wp_rewrite](http://codex.wordpress.org/Class_Reference/WP_Rewrite). New admin options page for save the base permastructs.\n* added some filters, see in [other notes](http://wordpress.org/extend/plugins/qtranslate-slug/other_notes/).\n* added plugin language textdomain (.pot file).\n* updated **Language selector Widget**, and some new conventions like accessible functions for templating.\n* some bug fixes.\n* some Qtranslate patches.\n\n= 0.9 =\n* some wordpress qTranslate bug fixes\n* adds a javascript solution for qTranslate Nav Menus\n\n= 0.8 =\n* added support por Categories\n* added support por Tags\n* added support por Taxonomies\n* added support por Custom Post Types\n\n= 0.7 = [Zapo](http://www.qianqin.de/qtranslate/forum/viewtopic.php?f=4&t=1049&start=50#p7499)\n* added suport for qTranslate TLD domain mode (en: domain.com | fr: domain.fr) visit \n\n= 0.5 and 0.6 enhanched by Marco Del Percio =\n\n== Upgrade Notice ==\n\n= 1.0 =\nMajor version, the plugin has been rewritten. Better performance, and some enhancements.\n\n= 0.9 =\nThis version fix some bugs and allow multilanguage in nav-menus.\n\n= 0.8 =\nA lot of slugs content allowed\n\n= 0.7 =\nThis version allows TLD domain option for a different Qtranslate fork maded by Zappo\n\n\n== Other notes ==\n\nPlugin filters reference:\n\n= qts_validate_post_slug =  \nfilter to process the post slug before is saved on the database.  \n`args: $post (object), $slug (string), $lang (string)`\n\n= qts_validate_term_slug =  \nfilter to process the term slug before is saved on the database.  \n`args: $term (object), $slug (string), $lang (string)`\n\n= qts_url_args =  \nfilter to process the entire url after it has been generated.  \n`args: $url (string), $lang (string)`\n \n= qts_permastruct =  \nfilter to process the permastruct, used for change the base.  \n`args: $permastruct (string), $name (string)`\n\n\n= Todo =\n\n* detect Slug for each language and redirect accordingly in parse_query.\n* expand qtranslate for translate attachment names and descriptions ( useful for galleries )\n* translate other slugs like attachments.\n* qtranslate integration with other plugins like Jigoshop, e-commerce, etc. Addapt **$wp_rewrite**.\n", "\n\n= New in 1.1.16 =\nMinor fix for the language menu using qtranslate's function\n\n= New in 1.1.15 =\n* Fixes the duplicated hreflang links in <head>\n\n= New in 1.1.14 =\n\nThe menu widget didn't allow the visitors to change to the default language if qtranslate-x was being used. So, adjusted the Language Menu widget to play nice with qtranslate-x. \nHope to bring some nice changes that were made in the github repository in the next version. For now, enjoy.\n\n= 1.1.13 =\n== Thanks to returning @pedro-mendonca for these commits: ==\n* Cleaned duplicated label in widget\n* Bug fix in \"Slug (%s)\" string translation\n* Changed text strings with no text-domain and with text-domain 'qtranlate' to text-domain 'qts'\n* pot catalog updated with current strings, including last found is \"More information about\".\n== Thanks to @johnclause for these : ==\n* Convenience links in notice_dependences\n* Menu compatibility with qTranslate-X\n* Fixed extra characters in widget\n== Thanks to vbkun for casting this much wanted function ==\n* Added a global qts_get_slug( $id, $lang)\n== and sadly: ==\n* removed the menu admin box until better implementation\n\n= 1.1.12 =\n\n* fixed warnings in settings\n* replace qtranslate with our own for taxonomies\n\n= 1.1.10 and 1.1.11 =\n* Fixing wrong commit to wp.org\n* Clean deleted files\n\n= 1.1.9  =\n\nLots of bug fixes! Thanks again to everyone that contributed to this project, with commits, bug reports and suggestions.\n\n* Compatibility with qtranslate-X! ( thanks @beheist, pull #85, fixing most of #80 )\n* More updates to the portuguese translation ( thanks pedro-mendonca, pull #86)\n* Corrected the link to language files ( thanks pedro-mendonca )\n* Added translation for some hardcoded texts ( thanks pedro-mendonca )\n* Corrected a link from 'qtranslate' to 'qts' language files ( thanks pedro-mendonca )\n* Fixed taxonomies slugs ( thanks to [eirikv's bug report](https://wordpress.org/support/topic/categories-slug-dont-work) )\n* Fixed many warnings ( thanks piffpaffpuff, issue #78 and to [pedrodu1](https://wordpress.org/support/topic/warnings-qtranslate-slugphp) )\n* Changed the behaviour of \"Quick Edit\", from the wp forums [1](https://wordpress.org/support/topic/categories-tags-and-quick-edit-dont-show-in-admin) [2](https://wordpress.org/support/topic/quick-edit-inhibited-by-qtranslate-slug-with-wp-41-mqtranslate) ( thanks everyone!! )\n* Fixed the menus! Now you can properly use one menu for every language. Use the dropdown section \"Languages\", and for each item, change the \"Navigation Label\" and \"Title Attribute\". Select \"All languages\", to make sure everything is awesome! All these features were a consequence of fixing all the warnings based on [Gery's bug report](https://wordpress.org/support/topic/qtranslate-slug-conflicting-with-ubermenu). \n* Minor fixes, etc. \n\nSee you next Version!\n\n= 1.1.8 =\n\nMany thanks to everyone that contributed to this update, both for their commits and bug reports )\n\n* Portuguese translation and fixed some translation bugs  ( thanks pedro-mendonca )\n* removed mqtranslate switcher widget hook\n* Updated the plugin structure and coding style\n* solve some conflicts with search and pagination queries\n* Settings php errors, syntax indent and fixed settings assets url\n* Change titles when there is a click on pagination on show all pages tab ( thanks juanfran-granados )\n* Formatted dependency notice message ( thanks arildm )\n* Updated the deprecated jquery 'live' function and solve php strict standards error ( thanks rafitaFCB )  \n* Fixed error showing if PHP was newer than 5.3 ( thanks rafitaFCB )  \n* Strict standard advise prevented ( thanks rafitaFCB )\n* php notices are prevented in post edit, when using adding new translated tags  ( thanks rafitaFCB )\n* fixed the hreflang issue! 'bout time!\n* As discussed in issue #25, the flags are now img tags, intead of background-url.\n* Added another option to include the css style in a minified file. ( and also showing in the option screen the styles we would use.)\n\n= 1.1.7 = \n* removed styles from html elements and added options to use .css file or print inline styles\n* fixed tag creation on post edit.\n* fixed earlier bad post slug introduced in 1.1.6\n\n= 1.1.6 =\n* compatible with mqtranslate\n* php5.4+ compatible\n\n= 1.1.5 = \n* bugfixes\n\n= 1.1 = \n* added multisite support\n* fixed some parse url bugs\n* fixed slug bases validation \n\n= 1.0 =\n* new branch, the plugin has been rewrited: now the code is commented and wrapped inside a class, also all code has change and the performance has been increased.\n* structural changes:\n\t* no ID for slug type, then don't install qtrasnlate_slug table.\n\t* slugs now are stored on meta tables, installation creates a termmeta table with some new 'core functions' to access/save data, based on [simple term meta](http://wordpress.org/extend/plugins/simple-term-meta/).\n* some automation:\n\t* the plugin generates translated slug automatically from title in empty cases (like wordpress).\n\t* the plugin checks if the slug already exists (per each language and type / taxonomy), and adds a progressive number in this case (like wordpress).\n\t* works on ajax requests like creatig new taxonomies on edit post page.\n* possibility to translate the base of permastructs for 'post_types' and 'taxonomies' (uses $wp_rewrite).\n* added some filters:\n\t* 'qts_validate_post_slug' : args( $post (object), $slug (string), $lang (string) ) / filter to process the post slug before is saved on the database.\n\t* 'qts_validate_term_slug' : args( $term (object), $slug (string), $lang (string) ) / filter to process the term slug before is saved on the database.\n\t* 'qts_current_url' : args ( $url (string), $lang (string) ) / filter to process the entire url after it has been generated.\n\t* 'qts_permastruct' : args ( $permastruct (string), $name (string) ) / filter to process the permastruct, used for change the base.\n* added plugin language textdomain (.pot file)\n* new admin options page for save the base permastructs.\n* import process when the plugin updates older versions.\n* some bug fixes.\n* some Qtranslate patches.\n\n= 0.9 =\n* some wordpress qTranslate bug fixes\n* adds a javascript solution for qTranslate Nav Menus\n\n= 0.8 =\n* added support por Categories\n* added support por Tags\n* added support por Taxonomies\n* added support por Custom Post Types\n\n= 0.7 ( enhanced by Zapo (http://www.qianqin.de/qtranslate/forum/viewtopic.php?f=4&t=1049&start=50#p7499) ) =\n* added suport for qTranslate TLD domain mode (en: domain.com | fr: domain.fr) visit \n\n= 0.5 and 0.6 enhanched by Marco Del Percio ="], "fixing_code": ["<?php\n\n/**\n * QtranslateSlug class\n *\n * @since 1.0\n */\nclass QtranslateSlug {\n    \n    \n    /**\n     * array with old data system\n     *\n     * @var bool\n     *\n     * @since 1.0\n     */\n    private $old_data = null;\n    \n    \n    \n    /**\n     * stores permalink_structure option, for save queries to db\n     *\n     * @var string\n     *\n     * @since 1.0\n     */\n    private $permalink_structure;\n    \n    \n    \n    /**\n     * Stores options slugs from database\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    protected $options;\n    \n    \n    \n    /**\n     * Variable used to override the language\n     *\n     * @var string\n     *\n     * @since 1.0\n     */\n    private $lang = false;\n\t\n\t/**\n\t * variable for current language\n\t */\n    private $current_lang = false;\n    \n    /**\n\t * variable for default language\n\t */\n    private $default_language = false;\n    \n\t/**\n     * Array of enabled languages\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    private $enabled_languages = array();\n\t/**\n     * Array of enabled languages\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    private $url_path_mode = \"\";\n\t\n    \n    \n    /**\n     * slug in meta_key name in meta tables\n     *\n     * @var string\n     *\n     * @since 1.0\n     */\n    private $meta_key = \"_qts_slug_%s\";\n    \n    \n    \n    /**\n     * Array of translated versions of the current url\n     *\n     * @var array\n     *\n     * @since 1.0\n     */\n    private $current_url = array();\n    \n    \n    /**\n     * Variable that contains the prefix for base plugin function names (qtranslate/qtranslate-x)\n     *\n     * @var string\n     *\n     * @since ?\n     */\n    private $plugin_prefix = \"\";\n\t\n\t\n    /**\n     * return the current / temp language\n     *\n     * @since 1.0\n     */\n    private function get_lang() {\n        global $q_config;\n        \n        return ($this->lang) ? $this->lang : $q_config['language'];\n    }\n    /**\n     * return the current / temp language\n\t * we store and use it all the way!\n     *\n     * @since 1.1.9\n     */\n    private function get_currentlang() {\n        return $this->current_lang;\n    }\n    /**\n     * return the enabled languages\n\t * we store and use it all the way!\n     *\n     * @since 1.1.9\n     */\n    private function get_enabled_languages() {\n        return $this->enabled_languages;\n    }\n    /**\n     * return the enabled languages\n\t * we store and use it all the way!\n     *\n     * @since 1.1.9\n     */\n    private function get_url_path_mode() {\n        return $this->url_path_mode;\n    }\n    \n    \n    /**\n     * getter: options\n     *\n     * @since 1.0\n     */\n    public function get_options() {\n        $this->set_options();\n        return $this->options;\n    }\n\n    /**\n     * Returns the correct prefix for the function names of the different supported translation plugins.\n     * Will return 'qtranxf_' if qtranslate-x is used, 'qtrans_' otherwise.\n     *\n     * @return string the function name prefix for translation functions from other plugins\n     * @since 1.1.9\n     */\n\n    private function get_plugin_prefix(){\n        \n        return $this->plugin_prefix;\n    }\n    \n    \n    /**\n     * setter: options | permalink_structure\n     *\n     * @since 1.0\n     */\n    public function set_options() {\n\n        if (empty($this->options)) {\n            $this->options = get_option(QTS_OPTIONS_NAME);\n        }\n\n        if (!$this->options) {\n            add_option(QTS_OPTIONS_NAME, array());\n        }\n        \n        if (is_null($this->permalink_structure)) {\n            $this->permalink_structure = get_option('permalink_structure');\n        }\n    }\n    \n    /**\n\t * Sets the prefix for the active fork. See get_plugin_prefix\n\t * @since 1.1.9\n\t *\n\t */\n    private function set_plugin_prefix(){\n        if ('' === $this->plugin_prefix){\n            if (is_plugin_active('qtranslate-x/qtranslate.php')){\n                $this->plugin_prefix = 'qtranxf_';\n            } else {\n                $this->plugin_prefix = 'qtrans_';\n            }\n        }\n    }\n\n    /**\n     * Sets the url path mode based on the qtranslate or fork settings.\n     *\n     */\n\n    private function set_url_path_mode(){\n        if ('' === $this->url_path_mode){\n            if (is_plugin_active('qtranslate-x/qtranslate.php')){\n                $this->url_path_mode = QTX_URL_PATH;\n            } else {\n                $this->url_path_mode = QT_URL_PATH;\n            }\n        }\n    }\n    \n    /**\n     * setter: options | permalink_structure\n     *\n     * @since 1.0\n     */\n    public function save_options($new_options = false) {\n        if (!$new_options || empty($new_options)) {\n            return;\n        }\n        \n        if (count($this->options) != count($new_options)) {\n            return;\n        }\n        \n        update_option(QTS_OPTIONS_NAME, $new_options);\n        $this->options = $new_options;\n    }\n    \n    \n    \n    /**\n     * getter: meta key\n     *\n     * @since 1.0\n     */\n    public function get_meta_key( $force_lang = false ) {\n        global $q_config;\n        \n        $lang = $this->get_lang();\n        \n        if ($force_lang) {\n            $lang = $force_lang;\n        }\n       \n        return sprintf($this->meta_key, $lang); // returns: _qts_slug_en\n    }\n    \n    \n    \n    /**\n     * check dependences for activation\n     *\n     * @since 1.0\n     */\n    static function block_activate() {\n        global $wp_version;\n        \n        include_once( ABSPATH . 'wp-admin/includes/plugin.php' ); \n        \n        return (\n            version_compare($wp_version, \"3.3\", \"<\" ) ||\n                ( !is_plugin_active('qtranslate/qtranslate.php') && \n                !is_plugin_active('mqtranslate/mqtranslate.php') && \n                !is_plugin_active('qtranslate-x/qtranslate.php'))\n        );\n    }\n    \n    \n\t\n    \n    /**\n     * check if exists qtranslate and do the installation, support multisite\n     *\n     * @since 1.0\n     */\n    public function install() {\n        global $wpdb;\n        \n        if ( self::block_activate() ) {\n            return;\n        }\n        \n        if ( function_exists('is_multisite') && is_multisite() ) {\n\n            if (isset($_GET['networkwide']) && ($_GET['networkwide'] == 1)) {\n                \n                $old_blog = $wpdb->blogid;\n                $blogids = $wpdb->get_col($wpdb->prepare(\"SELECT blog_id FROM $wpdb->blogs\"));\n                foreach ($blogids as $blog_id) {\n                    switch_to_blog($blog_id);\n                    $this->activate();\n                }\n                switch_to_blog($old_blog);\n                return;\n            }\n        }\n        \n        $this->activate();\n    }\n    \n    \n    \n    /**\n     * activates and do the installation\n     *\n     * @since 1.0\n     */\n    private function activate() {\n        global $wp_rewrite;\n\n        $this->set_options();\n        \n        $qts_version = get_option('qts_version');\n        \n        // checks version and do the installation\n        if ( !$qts_version || $qts_version != QTS_VERSION ) {\n            \n            // install termmeta table using functions from Simple-Term-Meta \n            // ( http://wordpress.org/extend/plugins/simple-term-meta/ )\n            install_term_meta_table();\n            \n            // update installed option  \n            update_option('qts_version', QTS_VERSION);\n        }\n    \n        // regenerate rewrite rules in db\n        add_action( 'generate_rewrite_rules', array(&$this, 'modify_rewrite_rules') );\n        flush_rewrite_rules();\n    }\n  \n    \n\n    /**\n    * register front end styles and enqueue\n    *\n    * @since 1.1.7\n    */\n    public function register_plugin_styles() {\n\t\twp_register_style( 'qts_front_styles', plugins_url( '/assets/css/qts-default.css', dirname(__FILE__ ) ) );\n        wp_enqueue_style( 'qts_front_styles' );\n    }\n    /**\n    * register minified front end styles and enqueue\n    * 43LC: easier duplicating the function :|\n    * @since 1.1.8\n    */\n    public function register_plugin_styles_min() {\n\t\twp_register_style( 'qts_front_styles', plugins_url( '/assets/css/qts-default.min.css', dirname(__FILE__ ) ) );\n        wp_enqueue_style( 'qts_front_styles' );\n    }\n\n\n\n    /**\n    * print front end styles\n    *\n    * @since 1.1.7\n    */\n    public function print_plugin_styles() {\n\n        $css_path = dirname(__FILE__).'/assets/css/qts-default.css';\n\n        if (!file_exists($css_path) || !is_readable($css_path)) {\n            return;\n        }\n\n        $default_css_file = file_get_contents($css_path, FILE_USE_INCLUDE_PATH);\n\n        $css = \"<style media=\\\"screen\\\">\\n\";\n        $css .= \"$default_css_file\\n\";\n        $css .=\"</style>\\n\";\n        echo $css;\n    }\n  \n    \n\n    /**\n     * actions when deactivating the plugin\n     *\n     * @since 1.0\n     */\n    public function deactivate() {\n        global $wp_rewrite;\n        \n        // regenerate rewrite rules in db\n        remove_action( 'generate_rewrite_rules', array(&$this, 'modify_rewrite_rules') );\n        $wp_rewrite->flush_rules();\n    }\n    \n\n\n    /**\n     * admin notice: update your old data \n     *\n     * @since 1.0\n     */\n    function notice_update(){\n        global $current_screen;\n        \n        if ($current_screen->id != 'settings_page_qtranslate-slug-settings') {\n        \n            echo \"<div class=\\\"updated\\\">\" . PHP_EOL;\n            echo \"<p><strong>Qtranslate Slug:</strong></p>\" . PHP_EOL;\n            printf(\"<p>%s <a href=\\\"%s\\\" class=\\\"button\\\">%s</a></p>\", __('Please update your old data to the new system.', 'qts'), add_query_arg(array('page' => 'qtranslate-slug-settings'), 'options-general.php'), __('upgrade now', 'qts')) . PHP_EOL;\n            echo \"</div>\" . PHP_EOL;\n        }\n    }\n    \n    \n    \n    /**\n     * admin notice: update your old data \n     *\n     * @since 1.0\n     */\n    function notice_dependences(){\n        global $current_screen;\n        $ornewer=__('or newer','qts');\n        $info_url=admin_url('plugin-install.php?tab=plugin-information');\n        echo '<div class=\"error\">' . PHP_EOL;\n        echo '<p><strong>Qtranslate Slug:</strong></p>' . PHP_EOL;\n        echo '<p>';\n        printf(__('This plugin requires at least %s and either %s, or %s, or %s', 'qts'),'<strong>WordPress 3.3</strong>','<a href=\"'.$info_url.'&plugin=qtranslate-x&TB_iframe=true\" class=\"thickbox\" aria-label=\"'.__('More information about', 'qts').' '.'qTranslate-X\" data-title=\"qTranslate-X\"><strong>qTranslate-X</strong></a> (2.9 '.$ornewer.')','<a href=\"'.$info_url.'&plugin=mqtranslate&TB_iframe=true\" class=\"thickbox\" aria-label=\"'.__('More information about', 'qts').' '.'mqTranslate\" data-title=\"mqTranslate\"><strong>mqTranslate</strong></a> (2.6.2.4 '.$ornewer.')','<a href=\"'.$info_url.'&plugin=qtranslate&TB_iframe=true\" class=\"thickbox\" aria-label=\"'.__('More information about', 'qts').' '.'qTranslate\" data-title=\"qTranslate\"><strong>qTranslate</strong></a> (2.5.8 '.$ornewer.')');\n        echo '</p>' . PHP_EOL;\n        echo '</div>' . PHP_EOL; \n    }\n    \n    \n    \n    /**\n     * checks if old table 'qtranslate_slug' exists and is not empty\n     * \n     * @return object | false\n     *\n     * @since 1.0\n     */\n    public function check_old_data() {\n        global $wpdb;\n        \n        if ($this->old_data === false) {\n            return false;\n        }\n                    \n        $table_name = $wpdb->get_var(\"SHOW TABLES LIKE '{$wpdb->prefix}qtranslate_slug'\");\n            \n        if (!empty($table_name)) {\n            $this->old_data = $wpdb->get_results(\"SELECT * FROM {$wpdb->prefix}qtranslate_slug\");\n        }\n        \n        if ( empty($table_name) || empty($this->old_data) ) {\n            $this->old_data = false;\n        }\n        \n        return $this->old_data;\n    }\n    \n    \n    \n    /**\n     * actions when deactivating the plugin\n     *\n     * @since 1.0\n     */\n    private function check_old_versions() {\n        \n        if ( $this->check_old_data() ) {\n            add_action('admin_notices', array(&$this, 'notice_update'));\n        }\n    }\n    \n    \n    \n    /**\n     * Initialise the Class with all hooks\n     *\n     * @since 1.0\n     */\n    function init() {\n      \n\t\tload_plugin_textdomain( 'qts', false, basename( plugin_dir_path( dirname( __FILE__ ) ) ) . '/languages' );\n        \n        // checking plugin activate\n        if ( self::block_activate() ) {\n            if (is_admin()) {\n                add_action('admin_notices', array(&$this, 'notice_dependences'));\n            }\n            return;\n        }\n    \n        // caching qts options\n        $this->set_options();\n        \n\t\tglobal $q_config;\n\t\t\n\t\t// until we get  a proper function, this will make it for it.\n\t\t$this->current_lang = $q_config['language'];\n\t    $this->enabled_languages = $q_config['enabled_languages'];\n        $this->default_language  = $q_config['default_language'];\n\t\t$this->set_plugin_prefix();\n\t\t$this->set_url_path_mode();\n\t\t\n        if ( is_admin() ) {\n            \n            $this->check_old_versions();\n       \n            \n            // add filters\n            add_filter( 'qts_validate_post_slug', array(&$this, 'validate_post_slug'), 0, 3 );\n            add_filter( 'qts_validate_post_slug', array(&$this, 'unique_post_slug'), 1, 3 );\n            add_filter( 'qts_validate_term_slug', array(&$this, 'validate_term_slug'), 0, 3 );\n            add_filter( 'qts_validate_term_slug', array(&$this, 'unique_term_slug'), 1, 3 );\n            add_filter( 'wp_get_object_terms', array(&$this, 'get_object_terms'), 0, 4 );\n            add_filter( 'get_terms', array(&$this, 'get_terms'), 0, 3 );\n            \n            // admin actions\n            add_action( 'admin_menu', array(&$this, 'add_slug_meta_box') );\n            add_action( 'save_post', array(&$this, 'save_postdata'), 605, 2 );\n            add_action( 'delete_term', array(&$this, 'delete_term'), 0, 3);\n            add_action( 'created_term', array(&$this, 'save_term'), 605, 3);\n            add_action( 'edited_term', array(&$this, 'save_term'), 605, 3 );\n            add_action( 'admin_head', array(&$this, 'hide_slug_box'), 900 );\n            \n            add_action( 'init', array(&$this, 'taxonomies_hooks'), 805 );\n            \n            add_action( 'wp_dashboard_setup', array(&$this, 'remove_dashboard_widgets') );\n            add_action( 'admin_head', array(&$this, 'hide_quick_edit'), 600 );\n            if(!defined('QTRANSLATE_FILE'))\n              add_action( 'admin_init', array(&$this, 'fix_nav_menu') );\n            \n        } else {\n            \n            add_filter( 'request', array(&$this, 'filter_request') );\n\n            // adds external style file\n            $qts_options = $this->get_options();\n            if ( !isset($qts_options[QTS_PREFIX.'styles']) || $qts_options[QTS_PREFIX.'styles'] == \"file\" ) {\n                add_action( 'wp_enqueue_scripts', array( &$this, 'register_plugin_styles' ) );\n            } elseif ($qts_options[QTS_PREFIX.'styles'] == \"minified\" ) {\n                add_action( 'wp_enqueue_scripts', array( &$this, 'register_plugin_styles_min' ) );\n            } elseif ($qts_options[QTS_PREFIX.'styles'] == \"inline\" ) {\n                add_action( 'wp_print_styles', array( &$this, 'print_plugin_styles' ), 20 );\n            }\n        }\n        \n        add_filter( 'query_vars', array(&$this, 'query_vars'));\n        add_action( 'generate_rewrite_rules', array(&$this, 'modify_rewrite_rules') );\n        \n        // remove from qtranslate the discouraged meta http-equiv, inline styles\n        // (including flag URLs) and wrong hreflang links   \n        \n        remove_action('wp_head', $this->get_plugin_prefix() . 'header');\n        if( \"qtranxf_\" === $this->get_plugin_prefix() ) {\n            remove_action('wp_head', $this->get_plugin_prefix() . 'head');\n        }\n        \n        // add proper hreflang links\n        add_action('wp_head',array(&$this, 'qtranslate_slug_header_extended'));\n        \n        // remove some Qtranslate filters\n        remove_filter( 'page_link',     $this->get_plugin_prefix() . 'convertURL' );\n        remove_filter( 'post_link',     $this->get_plugin_prefix() . 'convertURL' );\n        remove_filter( 'category_link', $this->get_plugin_prefix() . 'convertURL' );\n        remove_filter( 'tag_link',      $this->get_plugin_prefix() . 'convertURL' );\n        \n        add_filter( 'qts_permastruct' , array(&$this, 'get_extra_permastruct'), 0, 2);\n        add_filter( 'qts_url_args',     array(&$this, 'parse_url_args'), 0, 1);\n        add_filter( 'home_url',         array(&$this, 'home_url'), 10, 4);  \n        add_filter( 'post_type_link',   array(&$this, 'post_type_link'), 600, 4 );\n        add_filter( 'post_link',        array(&$this, 'post_link'), 0, 3 );\n        add_filter( '_get_page_link',   array(&$this, '_get_page_link'), 0, 2 );\n        add_filter( 'term_link',        array(&$this, 'term_link'), 600, 3 );\n        \n        add_filter( 'single_term_title', $this->get_plugin_prefix() . 'useTermLib', 805 );\n        add_filter( 'get_blogs_of_user', array(&$this, 'blog_names'), 1  );\n        add_action( 'widgets_init', array(&$this, 'widget_init'), 100 );\n        // Add specific CSS class to body class based on current lang\n        add_filter('body_class', array($this, 'qts_body_class'), 600, 1 );\n        \n        add_filter( 'nav_menu_attr_title', array($this, 'qts_filter_attr_title'), 0, 3 );\n\n\n    }\n      \n     /**\n     * Filters menu link attribute\n     *  \n     * @since 1.1.9\n     */ \n    function qts_filter_attr_title( $attr_title ) {\n        return $this->qts_quickuse($attr_title);\n    }\n\n\n    /**\n     * Adds proper links to the content with available translations.\n     * Fixes issue #25\n     *  \n     * @global $qtranslate_slug used to convert the url\n     * @global $q_config available languages\n     *\n     * @since 1.1.8\n     */ \n    public function qtranslate_slug_header_extended(){\n    \tif(is_404()) return;\n        \n        //taken from qtx \n        echo '<link hreflang=\"x-default\" href=\"'.$this->get_current_url($this->default_language) .'\" rel=\"alternate\" />'.PHP_EOL;\n        foreach($this->get_enabled_languages() as $language) {\n\n            if($language != $this->get_currentlang() )\n                echo '<link hreflang=\"'.$language.'\" href=\"'.$this->get_current_url($language).'\" rel=\"alternate\" />'.\"\\n\";\n        }\n    }\n    \n\n    /**\n     * Add a class based on the current language\n     * @param array $classes list of classes\n     */\n    public function qts_body_class( $classes ) {\n        // add 'class-name' to the $classes array\n        $classes[] = call_user_func($this->get_plugin_prefix() . 'getLanguage');\n        \n        // return the $classes array\n        return $classes;\n    }\n\n\t\t/**\n     * Finds the translated slug of the given post \n     * based on: https://wordpress.org/support/topic/permalink-for-other-languages \n     * @param int $id the post id\n     * @param string $lang which language to look for\n\t\t * @return string the slug or empty if not found\n     * @author vbkun\n     * @since 1.1.13\n     */ \n\t\tpublic function get_slug($id, $lang){\n\t\t\t$slugArray = get_post_meta( $id, '_qts_slug_'.$lang );\n\t\t\treturn !empty($slugArray) ? $slugArray[0] : \"\";\n\t\t}\n\n\t// TODO: properly test this\n\t/**\n\t * Get text in $lang, or in the current lang\n\t *\n\t * @package Qtranslate Slug\n\t * @since 1.1.9\n\t * @param string $text the whole text\n\t * @param string $lang (optional) get the text in this language, or if empty, the current\n\t * @return array the text in the required language\n\t */\n\tpublic function qts_quickuse( $text,$lang='' ){\n\t    global $q_config;\n\t    $lang = '' == $lang ? $q_config['language'] : $lang;\n\t    $parsed_text = call_user_func($this->get_plugin_prefix() . 'getSortedLanguages',$text);\n\t    if( !empty($parsed_text[$lang])){\n\t      return $parsed_text[$lang];  \n\t    }  \n\t}\n\t\n\n    /**\n     * Adds news rules to translate the URL bases, \n     * this function must be called on flush_rewrite or 'flush_rewrite_rules' \n     * \n     * @param object $wp_rewrite\n     *\n     * @since 1.0\n     */ \n    public function modify_rewrite_rules() {\n        // do we need this global?\t\n        //global $wp_rewrite;\n        \n        // post types rules\n        $post_types = get_post_types( array('_builtin' => false ), 'objects');\n        foreach ( $post_types as $post_type ) {\n            $this->generate_extra_rules( $post_type->name );\n        }\n        \n        // taxonomies rules\n        $taxonomies = $this->get_public_taxonomies();\n        foreach ( $taxonomies as $taxonomy ) {\n            $this->generate_extra_rules( $taxonomy->name );\n        }\n    }\n    \n    \n    \n    /**\n     * Helper: news rules to translate the URL bases\n     * \n     * @param string $name name of extra permastruct\n     * @param string $type 'post_type' or 'taxonomy'\n     *\n     * @since 1.0\n     */\n    private function generate_extra_rules( $name = false ) {\n        global $wp_rewrite;\n        \n        foreach ($this->get_enabled_languages() as $lang):\n            \n            if ( $base = $this->get_base_slug( $name, $lang) ):\n                \n                $struct = $wp_rewrite->extra_permastructs[$name];\n                \n                if ( is_array( $struct ) ) {\n                    if ( count( $struct ) == 2 )\n                        $rules = $wp_rewrite->generate_rewrite_rules( \"/$base/%$name%\", $struct[1] );\n                    else\n                        $rules = $wp_rewrite->generate_rewrite_rules( \"/$base/%$name%\", $struct['ep_mask'], $struct['paged'], $struct['feed'], $struct['forcomments'], $struct['walk_dirs'], $struct['endpoints'] );\n                } else {\n                    $rules = $wp_rewrite->generate_rewrite_rules( \"/$base/%$name%\" );\n                }\n                \n                $wp_rewrite->rules = array_merge($rules, $wp_rewrite->rules);\n            \n            endif;\n            \n        endforeach;\n    }\n    \n    \n    \n    /**\n     * Helper that gets a base slug stored in options\n     * \n     * @param string $name of extra permastruct\n     * @return string base slug for 'post_type' and 'language' or false\n     *\n     * @since 1.0\n     */\n    public function get_base_slug($name = false, $lang = false) {\n        \n        if ( !$name || !$lang ) {\n            return false;\n        }\n        \n        if ( taxonomy_exists($name) ) {\n            $type = 'taxonomy';\n        } else if ( post_type_exists($name) ) {\n            $type = 'post_type';\n        } else {\n            return false;\n        }\n        \n        $qts_options = $this->get_options();\n        \n        $option_name = QTS_PREFIX . $type . '_' . $name;\n        \n        if ( !isset($qts_options[$option_name]) || empty($qts_options[$option_name]) ) {\n            return false;\n        }\n        \n        if (isset($qts_options[$option_name][$lang])) {\n            return $qts_options[$option_name][$lang];\n        }\n        \n        return false;\n    }\n    \n    \n    \n    /**\n     * Helper: returns public built-in and not built-in taxonomies\n     * \n     * @return array of public taxonomies objects\n     *\n     * @since 1.0\n     */\n    private function get_public_taxonomies() {\n        \n        $builtin = get_taxonomies( array( 'public' => true, 'show_ui' => true, '_builtin' => true ), 'object'); \n        $taxonomies = get_taxonomies( array( 'public' => true, 'show_ui' => true, '_builtin' => false ), 'object' ); \n        \n        return array_merge( $builtin, $taxonomies );\n    }\n    \n    \n    \n    /**\n     * parse and adds $_GET args passed to an url\n     * \n     * @param string $url parameters\n     * @param string $lang processed\n     * @return string converted url\n     *\n     * @since 1.0\n     */\n    public function parse_url_args( $url ) {\n        global $q_config;\n\n        if (is_admin()) {\n            return $url;\n        }\n        \n        $url = preg_replace('/&amp;/', '&', $url);\n        \n        // if no permalink structure ads ?lang=en\n        $base_query = parse_url($q_config['url_info']['original_url']);\n        $base_args = isset($base_query['query']) ? wp_parse_args($base_query['query']) : array();\n        \n        if ( empty($this->permalink_structure) || $q_config['url_mode'] == 1 ) {\n            $base_args['lang'] = $this->get_lang();\n\n        }\n\n        // rebuild query with all args\n        $url = add_query_arg($base_args, $url);\n\n        $url = str_replace('/?', '?', $url); // TODO: hack: improve this code\n        $url = str_replace('?', '/?', $url); // TODO: hack: improve this code\n        \n        return $url;\n    }\n    \n    \n    \n    /**\n     * Fix get_page_by_path when querying vars\n     * \n     * @param $query_vars objec query vars founded\n     * @return object $query_vars processed\n     *\n     * @since 1.0\n     */\n    public function query_vars( $query_vars ) {\n        global $wp, $wp_rewrite;\n\n        $wp->query_vars = array();\n        $post_type_query_vars = array();\n\n        // Fetch the rewrite rules.\n        $rewrite = $wp_rewrite->wp_rewrite_rules();\n\n        if ( ! empty($rewrite) ) {\n            // If we match a rewrite rule, this will be cleared.\n            $error = '404';\n            $wp->did_permalink = true;\n\n            if ( isset($_SERVER['PATH_INFO']) ) {\n                $pathinfo = $_SERVER['PATH_INFO'];\n            } else {\n                $pathinfo = '';\n            }\n            $pathinfo_array = explode('?', $pathinfo);\n            $pathinfo = str_replace(\"%\", \"%25\", $pathinfo_array[0]);\n            $req_uri = $_SERVER['REQUEST_URI'];\n            $req_uri_array = explode('?', $req_uri);\n            $req_uri = $req_uri_array[0];\n            $self = $_SERVER['PHP_SELF'];\n            $home_path = parse_url(home_url());\n            \n            if ( isset($home_path['path']) ) {\n                $home_path = $home_path['path'];\n            } else {\n                $home_path = '';\n            }\n            $home_path = trim($home_path, '/');\n\n            // Trim path info from the end and the leading home path from the\n            // front. For path info requests, this leaves us with the requesting\n            // filename, if any. For 404 requests, this leaves us with the\n            // requested permalink.\n            $req_uri = str_replace($pathinfo, '', $req_uri);\n            $req_uri = trim($req_uri, '/');\n            $req_uri = preg_replace(\"|^$home_path|\", '', $req_uri);\n            $req_uri = trim($req_uri, '/');\n            if ($GLOBALS['q_config']['url_mode'] == $this->get_url_path_mode()) {\n                $req_uri = preg_replace(\"/^{$GLOBALS['q_config']['language']}(\\/|$)/\", '', $req_uri);\n            }\n            $pathinfo = trim($pathinfo, '/');\n            $pathinfo = preg_replace(\"|^$home_path|\", '', $pathinfo);\n            $pathinfo = trim($pathinfo, '/');\n            $self = trim($self, '/');\n            $self = preg_replace(\"|^$home_path|\", '', $self);\n            $self = trim($self, '/');\n\n            // The requested permalink is in $pathinfo for path info requests and\n            //  $req_uri for other requests.\n            if ( ! empty($pathinfo) && !preg_match('|^.*' . $wp_rewrite->index . '$|', $pathinfo) ) {\n                $request = $pathinfo;\n            } else {\n                // If the request uri is the index, blank it out so that \n                // we don't try to match it against a rule.\n                if ( $req_uri == $wp_rewrite->index )\n                    $req_uri = '';\n                $request = $req_uri;\n            }\n            \n            $wp->request = $request;\n\n            // Look for matches.\n            $request_match = $request;\n            if ( empty( $request_match ) ) {\n                // An empty request could only match against ^$ regex\n                if ( isset( $rewrite['$'] ) ) {\n                    $wp->matched_rule = '$';\n                    $query = $rewrite['$'];\n                    $matches = array('');\n                }\n            } else if ( $req_uri != 'wp-app.php' ) {\n                foreach ( (array) $rewrite as $match => $query ) {\n                    // If the requesting file is the anchor of the match, prepend it to the path info.\n                    if ( ! empty($req_uri) && strpos($match, $req_uri) === 0 && $req_uri != $request ) {\n                        $request_match = $req_uri . '/' . $request;\n                    }\n\n                    if ( preg_match(\"#^$match#\", $request_match, $matches) || preg_match(\"#^$match#\", urldecode($request_match), $matches) ) {\n\n                        if ( $wp_rewrite->use_verbose_page_rules && preg_match( '/pagename=\\$matches\\[([0-9]+)\\]/', $query, $varmatch ) ) {\n                            // this is a verbose page match, lets check to be sure about it\n                            if ( ! $page_foundid = $this->get_page_by_path( $matches[ $varmatch[1] ] ) ) {\n                                continue;\n                            } else {\n                                wp_cache_set('qts_page_request', $page_foundid); // caching query :)\n                            }       \n                        }\n\n                        // Got a match.\n                        $wp->matched_rule = $match;\n                        break;\n                    }\n                }\n            }\n\n            if ( isset( $wp->matched_rule ) ) {\n                // Trim the query of everything up to the '?'.\n                $query = preg_replace(\"!^.+\\?!\", '', $query);\n\n                // Substitute the substring matches into the query.\n                $query = addslashes(WP_MatchesMapRegex::apply($query, $matches));\n\n                $wp->matched_query = $query;\n\n                // Parse the query.\n                parse_str($query, $perma_query_vars);\n\n                // If we're processing a 404 request, clear the error var\n                // since we found something.\n                unset( $_GET['error'] );\n                unset( $error );\n            }\n\n            // If req_uri is empty or if it is a request for ourself, unset error.\n            if ( empty($request) || $req_uri == $self || strpos($_SERVER['PHP_SELF'], 'wp-admin/') !== false ) {\n                unset( $_GET['error'] );\n                unset( $error );\n\n                if ( isset($perma_query_vars) && strpos($_SERVER['PHP_SELF'], 'wp-admin/') !== false ) {\n                    unset( $perma_query_vars );\n                }\n\n                $wp->did_permalink = false;\n            }\n        }\n\n        return count(array_diff($query_vars, $wp->public_query_vars)) > 0 ? $query_vars : $wp->public_query_vars;\n    }\n    \n    \n    \n    /**\n     * Function called when query parameters are processed by Wordpress.\n     * \n     * @param $query query parameters\n     * @return array() $query processed\n     *\n     * @since 1.0\n     */\n    function filter_request( $query ) {\n        global $wp_query, $wp;\n        if ((isset($wp->matched_query) || empty($query))  && ! isset($query['s']) ) {\n            $query = wp_parse_args($wp->matched_query);\n        }\n        \n        foreach (get_post_types() as $post_type) {\n            if ( array_key_exists($post_type, $query) && !in_array($post_type, array('post', 'page')) ) {\n                $query['post_type'] = $post_type;\n            }\n        }\n        \n        $page_foundit = false;\n        \n        // -> page\n        if ( isset($query['pagename']) || isset($query['page_id']) ):\n            \n            $page = wp_cache_get('qts_page_request');\n            if (!$page) \n                $page = isset($query['page_id']) ? get_post($query['page_id']) : $this->get_page_by_path($query['pagename']);\n            \n            if (!$page) return $query;\n            $id = $page->ID;\n            $cache_array = array($page);\n            update_post_caches($cache_array, 'page'); // caching query :)\n            wp_cache_delete('qts_page_request');\n            $query['pagename'] = get_page_uri($page);\n            $function = 'get_page_link';\n        \n        // -> custom post type\n        elseif ( isset($query['post_type']) ):\n            \n            $page_slug = ( isset($query['name']) && !empty($query['name']) ) ? $query['name'] : $query[$query['post_type']];\n            $page = $this->get_page_by_path($page_slug, OBJECT, $query['post_type']);\n            if (!$page) return $query;\n            $id = $page->ID;\n            $cache_array = array($page);\n            update_post_caches($cache_array, $query['post_type']); // caching query :)\n            $query['name'] = $query[$query['post_type']] = get_page_uri($page); \n            $function = 'get_post_permalink';\n        \n        // -> post\n        elseif ( isset($query['name']) || isset($query['p']) ):\n            \n            $post = isset($query['p']) ? get_post($query['p']) : $this->get_page_by_path($query['name'], OBJECT, 'post');\n            if (!$post) {\n                return $query;\n            }\n            $query['name'] = $post->post_name;\n            $id = $post->ID;\n            $cache_array = array($post);\n            update_post_caches($cache_array);\n            $function = 'get_permalink';\n            \n        // -> category\n        elseif ( ( isset($query['category_name']) || isset($query['cat'])) ):\n            if ( isset($query['category_name']) ) {\n                $term_slug = $this->get_last_slash( $query['category_name'] );\n            }\n            $term = isset($query['cat']) ? get_term($query['cat'], 'category') : $this->get_term_by('slug', $term_slug, 'category');\n            if (!$term) {\n                return $query;\n            }\n            $cache_array = array($term);\n            update_term_cache($cache_array, 'category'); // caching query :)\n            $id = $term->term_id;\n            $query['category_name'] = $term->slug; // uri\n            $function = 'get_category_link';\n        \n        // -> tag\n        elseif ( isset($query['tag']) ):\n            \n            $term = $this->get_term_by('slug', $query['tag'], 'post_tag');\n            if (!$term) {\n                return $query;\n            }\n            $cache_array = array($term);\n            update_term_cache($cache_array, 'post_tag'); // caching query :)\n            $id = $term->term_id;\n            $query['tag'] = $term->slug;\n            $function = 'get_tag_link';\n        \n        endif;\n\n        \n        // -> taxonomy\n        $taxonomies = get_taxonomies( array( 'public' => true, '_builtin' => false )  );\n        foreach ($taxonomies as $term_name):\n        if ( isset($query[$term_name]) ) {\n            \n            $term_slug = $this->get_last_slash( $query[$term_name] );\n            $term = $this->get_term_by('slug', $term_slug, $term_name);\n            if (!$term) {\n                return $query;\n            }\n            $cache_array = array($term);\n            update_term_cache($cache_array, $term_name); // caching query :)\n            $id = $term;\n            $query[$term_name] = $term->slug;\n            $function = 'get_term_link';\n            \n        }\n        endforeach;\n\n        // -> home url\n        if ( empty($query) ) {\n            \n            $function = 'home_url';\n            $id = '';\n            \n        }\n        \n        // -> search\n        if (isset($query['s'])) {\n\n          $id = $query['s'];\n          $function=\"get_search_link\";\n      \n        }\n        \n        if ( isset($function) ) {\n                    \n            // parse all languages links\n            foreach( $this->get_enabled_languages() as $lang ) {\n                \n                $this->lang = $lang;\n                $this->current_url[$lang] = esc_url(apply_filters('qts_url_args', call_user_func($function, $id)));\n            }\n\n            $this->lang = false;\n        }\n        \n        return $query;\n    }\n    \n    \n    \n    /**\n     * Parse a hierarquical name and extract the last one\n     *\n     * @param string $lang Page path\n     * @return string\n     *\n     * @since 1.0\n     */\n    public function get_current_url( $lang = false ) {\n        \n        if (!$lang) {\n            $lang = $this->get_lang();\n        }\n        \n        if (isset($this->current_url[$lang]) && !empty($this->current_url[$lang])) {\n            return $this->current_url[$lang];\n        }\n        \n        return '';\n    }\n    \n    \n    \n    /**\n     * Parse a hierarquical name and extract the last one \n     *\n     * @param string $slug Page path\n     * @return string\n     *\n     * @since 1.0\n     */\n    private function get_last_slash($slug) {\n        \n        $slug = rawurlencode( urldecode( $slug ) );\n        $slug = str_replace('%2F', '/', $slug);\n        $slug = str_replace('%20', ' ', $slug);\n        $exploded_slug = explode('/', $slug);\n\n        return array_pop( $exploded_slug );\n    }\n    \n    \n    \n    /**\n     * Retrieves a page id given its path.\n     *\n     * @param string $page_path Page path\n     * @param string $output Optional. Output type. OBJECT, ARRAY_N, or ARRAY_A. Default OBJECT.\n     * @param string $post_type Optional. Post type. Default page.\n     * @return mixed Null when complete.\n     *\n     * @since 1.0\n     */\n    private function get_page_id_by_path($page_path, $output = OBJECT, $post_type = 'page') {\n        global $wpdb;\n\n        $page_path = rawurlencode(urldecode($page_path));\n        $page_path = str_replace('%2F', '/', $page_path);\n        $page_path = str_replace('%20', ' ', $page_path);\n        $parts = explode( '/', trim( $page_path, '/' ) );\n        $parts = array_map( 'esc_sql', $parts );\n        $parts = array_map( 'sanitize_title_for_query', $parts );\n        $in_string = \"'\". implode( \"','\", $parts ) . \"'\";\n        $meta_key = $this->get_meta_key();\n        $post_type_sql = $post_type;\n        $wpdb->escape_by_ref( $post_type_sql );\n        \n        $pages = $wpdb->get_results( \"SELECT $wpdb->posts.ID, $wpdb->posts.post_parent, $wpdb->postmeta.meta_value FROM $wpdb->posts,$wpdb->postmeta WHERE $wpdb->posts.ID = $wpdb->postmeta.post_id AND $wpdb->postmeta.meta_key = '$meta_key' AND $wpdb->postmeta.meta_value IN ($in_string) AND ($wpdb->posts.post_type = '$post_type_sql' OR $wpdb->posts.post_type = 'attachment')\", OBJECT_K );\n\n        $revparts = array_reverse( $parts );\n\n        $foundid = 0;\n        foreach ( (array) $pages as $page ) {\n            if ( $page->meta_value == $revparts[0] ) {\n                $count = 0;\n                $p = $page;\n                while ( $p->post_parent != 0 && isset( $pages[ $p->post_parent ] ) ) {\n                    $count++;\n                    $parent = $pages[ $p->post_parent ];\n                    if ( ! isset( $revparts[ $count ] ) || $parent->meta_value != $revparts[ $count ] ) {\n                        break;\n                    }\n                    $p = $parent;\n                }\n\n                if ( $p->post_parent == 0 && $count+1 == count( $revparts ) && $p->meta_value == $revparts[ $count ] ) {\n                    $foundid = $page->ID;\n                    break;\n                }\n            }\n        }\n        \n        if ( $foundid ) {\n            return $foundid;\n            \n        } else {\n            \n            $last_part = array_pop($parts);\n            $page_id = $wpdb->get_var( \"SELECT ID FROM $wpdb->posts WHERE post_name = '$last_part' AND (post_type = '$post_type_sql' OR post_type = 'attachment')\" );\n            \n            if ( $page_id ) {\n                return $page_id;\n            }\n        }\n\n        return null;\n    }\n    \n    \n    \n    \n    /**\n     * Retrieves a page given its path.\n     *\n     * @param string $page_path Page path\n     * @param string $output Optional. Output type. OBJECT, ARRAY_N, or ARRAY_A. Default OBJECT.\n     * @param string $post_type Optional. Post type. Default page.\n     * @return mixed Null when complete.\n     *\n     * @since 1.0\n     */\n    private function get_page_by_path($page_path, $output = OBJECT, $post_type = 'page') {\n        \n        $foundid = $this->get_page_id_by_path($page_path, $output, $post_type);\n        if ( $foundid ) {\n            return get_post( $foundid, $output );\n        }\n        \n        return null;\n    }\n    \n    \n    \n    /**\n     * Ignores if the mod_rewrite func is the caller\n     *\n     * @return boolean\n     *\n     * @since 1.0\n     */\n    private function ignore_rewrite_caller() {\n        \n        $backtrace = debug_backtrace();\n        \n        $ignore_functions = array('mod_rewrite_rules', 'save_mod_rewrite_rules', 'flush_rules', 'rewrite_rules', 'wp_rewrite_rules', 'query_vars');\n        \n        if ( isset($backtrace['function']) ) {\n            if (in_array($backtrace['function'], $ignore_functions)) {\n                return true;\n            }\n        } else {\n            foreach ($backtrace as $trace) {\n                if ( isset($trace['function']) && in_array($trace['function'], $ignore_functions) ) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    \n    /**\n     * Retrieve the home url for a given site.\n     *\n     * @param  int $blog_id   (optional) Blog ID. Defaults to current blog.\n     * @param  string $path   (optional) Path relative to the home url.\n     * @param  string $scheme (optional) Scheme to give the home url context. Currently 'http', 'https'.\n     * @return string Home url link with optional path appended.\n     *\n     * @since 1.0\n     */\n    public function home_url($url, $path, $scheme, $blog_id) {\n        if ( !in_array( $scheme, array( 'http', 'https' ) ) ) {\n            $scheme = is_ssl() && !is_admin() ? 'https' : 'http';\n        }\n\n        if ( empty( $blog_id ) || !is_multisite() ) {\n            $url = get_option( 'home' );\n        } else {\n            $url = get_blog_option( $blog_id, 'home' );\n        }\n\n        if ( 'http' != $scheme ) {\n            $url = str_replace( 'http://', \"$scheme://\", $url );\n        }\n\n        $ignore_caller = $this->ignore_rewrite_caller();\n\n        if ( !empty( $path ) && is_string( $path ) && strpos( $path, '..' ) === false ) {\n            $url .= '/' . ltrim( $path, '/' );\n        }\n\n        if ( !$ignore_caller ) {\n            $url = call_user_func($this->get_plugin_prefix() . 'convertURL', $url, $this->get_lang(), true);\n        }\n\n        return $url;\n    }\n    \n    \n    \n    /**\n     * Filter that changes the permastruct depending\n     * \n     * @param string $permastruct default permastruct given b wp_rewrite\n     * @param string $name the name of the extra permastruct\n     * @return string processed permastruct\n     *\n     * @since 1.0\n     */\n    public function get_extra_permastruct( $permastruct = false, $name = false ) {\n        \n        if ( !$name || !$permastruct ) {\n            return '';\n        }\n        \n        if ( $base = $this->get_base_slug($name, $this->get_lang()) ) {\n            return \"/$base/%$name%\";\n        }\n        \n        return $permastruct;\n    }\n        \n    \n    \n    /**\n     * Filter that translates the slug parts in a page link\n     * \n     * @param $link the link for the page generated by Wordpress\n     * @param $id the id of the page\n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function post_type_link( $link, $post, $leavename, $sample ) {\n        global $wp_rewrite;\n\n        if ( is_wp_error( $post ) ) {\n            return $post;\n        }\n\n        $post_link = apply_filters( 'qts_permastruct', $wp_rewrite->get_extra_permastruct($post->post_type), $post->post_type);\n        \n        $slug = get_post_meta( $post->ID, $this->get_meta_key(), true );\n        if (!$slug) {\n            $slug =  $post->post_name;\n        }\n\n        $draft_or_pending = isset($post->post_status) && in_array( $post->post_status, array( 'draft', 'pending', 'auto-draft' ) );\n\n        $post_type = get_post_type_object($post->post_type);\n\n        if ( !empty($post_link) && ( !$draft_or_pending || $sample ) ) {\n            if ( ! $leavename ) {\n                if ( $post_type->hierarchical )\n                    $slug = $this->get_page_uri($post->ID);\n                $post_link = str_replace(\"%$post->post_type%\", $slug, $post_link);\n            }\n            \n            $post_link = home_url( user_trailingslashit($post_link) );\n            \n        } else {\n            \n            if ( $post_type->query_var && ( isset($post->post_status) && !$draft_or_pending ) ) {\n                $post_link = add_query_arg($post_type->query_var, $slug, '');\n            } else {\n                $post_link = add_query_arg(array('post_type' => $post->post_type, 'p' => $post->ID), '');\n            }\n            \n            $post_link = home_url($post_link);\n        }\n\n        return $post_link;\n    }\n    \n    \n    \n    /**\n     * Filter that translates the slug in a post link\n     * \n     * @param $link the link generated by wordpress\n     * @param $post the post data\n     * @param $leavename parameter used by get_permalink. Whether to keep post name or page name. \n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function post_link( $link, $post, $leavename ) {\n        global $q_config;\n        \n        $rewritecode = array(\n            '%year%',\n            '%monthnum%',\n            '%day%',\n            '%hour%',\n            '%minute%',\n            '%second%',\n            $leavename? '' : '%postname%',\n            '%post_id%',\n            '%category%',\n            '%author%',\n            $leavename? '' : '%pagename%',\n        );\n\n        if ( empty($post->ID) ) {\n            return false;\n        }\n\n        $permalink = $this->permalink_structure;\n\n        if ( '' != $permalink && !in_array($post->post_status, array('draft', 'pending', 'auto-draft')) ) {\n            $unixtime = strtotime($post->post_date);\n            \n            $category = '';\n            if ( strpos($permalink, '%category%') !== false ) {\n                $cats = get_the_category($post->ID);\n                if ( $cats ) {\n                    usort($cats, '_usort_terms_by_ID'); // order by ID\n                    \n                    $category = get_term_meta($cats[0]->term_id, $this->get_meta_key(), true );\n                    if (!$category) $category = $cats[0]->slug;\n                    \n                    if ( $parent = $cats[0]->parent )\n                        $category = $this->get_category_parents($parent, false, '/', true) . $category;\n                }\n                // show default category in permalinks, without\n                // having to assign it explicitly\n                if ( empty($category) ) {\n                    $default_category = get_category( get_option( 'default_category' ) );\n                    \n                    $default_category_slug = get_term_meta($default_category->term_id, $this->get_meta_key(), true );\n                    if (!$default_category_slug) $default_category_slug = $default_category->slug;\n                    \n                    $category = is_wp_error( $default_category ) ? '' : $default_category_slug;\n                }\n            }\n\n            $author = '';\n            if ( strpos($permalink, '%author%') !== false ) {\n                $authordata = get_userdata($post->post_author);\n                $author = $authordata->user_nicename;\n            }\n\n            $date = explode(\" \",date('Y m d H i s', $unixtime));\n            \n            $post_slug = get_post_meta($post->ID, $this->get_meta_key(), true );\n            if (!$post_slug) {\n                $post_slug = $post->post_name;\n            }\n            \n            $rewritereplace =\n            array(\n                $date[0],\n                $date[1],\n                $date[2],\n                $date[3],\n                $date[4],\n                $date[5],\n                $post_slug,\n                $post->ID,\n                $category,\n                $author,\n                $post_slug,\n            );\n            $permalink = home_url( str_replace($rewritecode, $rewritereplace, $permalink));\n            if ($q_config['url_mode'] != 1) {\n                $permalink = user_trailingslashit($permalink, 'single');\n            }\n        } else { // if they're not using the fancy permalink option\n            $permalink = home_url('?p=' . $post->ID);\n        }\n        \n        return $permalink;\n    }\n    \n    \n    \n    /**\n     * Retrieve category parents with separator.\n     *\n     * @param int $id Category ID.\n     * @param bool $link Optional, default is false. Whether to format with link.\n     * @param string $separator Optional, default is '/'. How to separate categories.\n     * @param bool $nicename Optional, default is false. Whether to use nice name for display.\n     * @param array $visited Optional. Already linked to categories to prevent duplicates.\n     * @return string\n     *\n     * @since 1.0\n     */\n    private function get_category_parents( $id, $link = false, $separator = '/', $nicename = false, $visited = array() ) {\n        \n        $chain = '';\n        if(phpversion() >= 5.4) {\n            $parent = get_category( $id );\n        } else {\n            $parent = &get_category( $id );\n        }\n\n        if ( is_wp_error( $parent ) ) {\n            return $parent;\n        }\n\n        if ( $nicename ) {\n\n            $name = get_term_meta($parent->term_id, $this->get_meta_key(), true );\n            if (!$name) {\n                $name = $parent->slug;\n            }\n        } else {\n            $name = $parent->name;\n        }\n\n        if ( $parent->parent && ( $parent->parent != $parent->term_id ) && !in_array( $parent->parent, $visited ) ) {\n            $visited[] = $parent->parent;\n            $chain .= $this->get_category_parents( $parent->parent, $link, $separator, $nicename, $visited );\n        }\n        \n        if ( $link ) {\n            $chain .= '<a href=\"' . get_category_link( $parent->term_id ) . '\" title=\"' . esc_attr( sprintf( __( \"View all posts in %s\", \"qts\" ), $parent->name ) ) . '\">'.$name.'</a>' . $separator;\n        } else {\n            $chain .= $name.$separator;\n        }\n        \n        return $chain;\n    }\n    \n\n    \n    \n    \n    /**\n     * Filter that translates the slug parts in a page link\n     * \n     * @param $link the link for the page generated by Wordpress\n     * @param $id the id of the page\n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function _get_page_link( $link, $id ) {\n        global $post, $wp_rewrite, $q_config;\n\n        $current_post = $post;\n\n        if ( !$id ) {\n            $id = (int) $post->ID;\n        } else {\n            if(phpversion() >= 5.4) {\n                $current_post = get_post($id);\n            } else {\n                $current_post = &get_post($id);\n            }\n        }\n\n        $draft_or_pending = in_array( $current_post->post_status, array( 'draft', 'pending', 'auto-draft' ) );\n\n        $link = $wp_rewrite->get_page_permastruct();\n\n        if ( !empty($link) && ( isset($current_post->post_status) && !$draft_or_pending ) ) {\n            \n            $link = str_replace('%pagename%', $this->get_page_uri($id), $link);\n            \n            $link = trim($link, '/'); // hack\n            $link = home_url(\"/$link/\"); // hack\n            \n            if ($q_config['url_mode'] != 1)\n                $link = user_trailingslashit($link, 'page');\n            \n        } else {\n            \n            $link = home_url(\"?page_id=$id\");\n        }\n\n        return $link;\n    }\n    \n    \n    \n    /**\n     * Builds URI for a page.\n     *\n     * Sub pages will be in the \"directory\" under the parent page post name.\n     *\n     * @param mixed $page Page object or page ID.\n     * @return string Page URI.\n     *\n     * @since 1.0\n     */\n    private function get_page_uri($page) {\n        \n        if ( ! is_object($page) ) {\n            $page = get_post($page);\n        }\n        \n        $uri = get_post_meta( $page->ID, $this->get_meta_key(), true );\n        if (!$uri) {\n            $uri =  $page->post_name;\n        }\n\n        // A page cannot be it's own parent.\n        if ( $page->post_parent == $page->ID ) {\n            return $uri;\n        }\n\n        while ($page->post_parent != 0) {\n            $page = get_post($page->post_parent);\n            \n            $page_name = get_post_meta( $page->ID, $this->get_meta_key(), true );\n            if (!$page_name) {\n                $page_name = $page->post_name;\n            }\n            \n            $uri = $page_name . \"/\" . $uri;\n        }\n\n        return $uri;\n    }\n    \n    \n    \n    /**\n     * Filter that translates the slug parts in a term link\n     * \n     * @param $link the link for the page generated by Wordpress\n     * @param $term object\n     * @param $taxonomy object\n     * @return the link translated\n     *\n     * @since 1.0\n     */\n    public function term_link( $link, $term, $taxonomy ) {\n        global $wp_rewrite;\n        \n        // parse normal term names for ?tag=tagname\n        if (empty($this->permalink_structure)) return $link;\n\n        if ( !is_object($term) ) {\n            if ( is_int($term) ) {\n                $term = &get_term($term, $taxonomy);\n            } else {\n                $term = $this->get_term_by('slug', $term, $taxonomy);\n            }\n        }\n\n        if ( !is_object($term) ) {\n            $term = new WP_Error('invalid_term', __('Empty Term', 'qts'));\n        }\n\n        if ( is_wp_error( $term ) ) {\n            return $term;\n        }\n\n        $taxonomy = $term->taxonomy;\n\n        $termlink = apply_filters( 'qts_permastruct', $wp_rewrite->get_extra_permastruct($taxonomy), $taxonomy);\n        \n        $slug = get_term_meta( $term->term_id, $this->get_meta_key(), true );\n        if (!$slug) {\n            $slug = $term->slug;\n        }\n        \n        $t = get_taxonomy($taxonomy);\n\n        if ( empty($termlink) ) {\n            if ( 'category' == $taxonomy )\n                $termlink = '?cat=' . $term->term_id;\n            elseif ( $t->query_var )\n                $termlink = \"?$t->query_var=$slug\";\n            else\n                $termlink = \"?taxonomy=$taxonomy&term=$slug\";\n            $termlink = home_url($termlink);\n        } else {\n            if ( $t->rewrite['hierarchical'] ) {\n                $hierarchical_slugs = array();\n                $ancestors = get_ancestors($term->term_id, $taxonomy);\n                foreach ( (array)$ancestors as $ancestor ) {\n                    $ancestor_term = get_term($ancestor, $taxonomy);\n                    \n                    $ancestor_slug = get_term_meta( $ancestor_term->term_id, $this->get_meta_key(), true );\n                    if (!$ancestor_slug) $ancestor_slug = $ancestor_term->slug;\n                    \n                    $hierarchical_slugs[] = $ancestor_slug;\n                }\n                $hierarchical_slugs = array_reverse($hierarchical_slugs);\n                $hierarchical_slugs[] = $slug;\n                $termlink = str_replace(\"%$taxonomy%\", implode('/', $hierarchical_slugs), $termlink);\n            } else {\n                $termlink = str_replace(\"%$taxonomy%\", $slug, $termlink);\n            }\n            $termlink = home_url( user_trailingslashit($termlink, 'category') );\n        }\n        return $termlink;\n    }\n    \n    \n    \n    /**\n     * Get all Term data from database by Term field and data.\n     *\n     * @param (string) $field Either 'slug', 'name', or 'id'\n     * @param (string|int) $value Search for this term value\n     * @param (string) $taxonomy Taxonomy Name\n     * @param (string) $output Constant OBJECT, ARRAY_A, or ARRAY_N\n     * @param (string) $filter Optional, default is raw or no WordPress defined filter will applied.\n     * @return (mixed) Term Row from database. Will return false if $taxonomy does not exist or $term was not found.\n     *\n     * @since 1.0\n     */\n    private function get_term_by($field, $value, $taxonomy, $output = OBJECT, $filter = 'raw') {\n        global $wpdb;\n        \n        $original_field = $field;\n\n        if ( ! taxonomy_exists($taxonomy) ) {\n            return false;\n        }\n\n        if ( 'slug' == $field ) {\n            $field = 'm.meta_key = \\''.$this->get_meta_key().'\\' AND m.meta_value';\n            $value = sanitize_title($value);\n            if ( empty($value) )\n                return false;\n        } else if ( 'name' == $field ) {\n            // Assume already escaped\n            $value = stripslashes($value);\n            $field = 't.name';\n        } else {\n            $term = get_term( (int) $value, $taxonomy, $output, $filter);\n            if ( is_wp_error( $term ) )\n                $term = false;\n            return $term;\n        }\n        \n        $term = $wpdb->get_row( $wpdb->prepare( \"SELECT t.*, tt.* FROM $wpdb->terms AS t, $wpdb->term_taxonomy AS tt, $wpdb->termmeta AS m WHERE t.term_id = tt.term_id AND tt.term_id = m.term_id AND tt.taxonomy = %s AND $field = %s LIMIT 1\", $taxonomy, $value) );\n\n        if ( !$term && 'slug' == $original_field ) {\n            $field = 't.slug';\n            $term = $wpdb->get_row( $wpdb->prepare( \"SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND $field = %s LIMIT 1\", $taxonomy, $value) );\n        }\n        \n        if ( !$term ) {\n            return false;\n        }\n\n        wp_cache_add($term->term_id, $term, $taxonomy);\n\n        $term = apply_filters('get_term', $term, $taxonomy);\n        $term = apply_filters(\"get_$taxonomy\", $term, $taxonomy);\n        $term = sanitize_term($term, $taxonomy, $filter);\n\n        if ( $output == OBJECT ) {\n            return $term;\n        } elseif ( $output == ARRAY_A ) {\n            return get_object_vars($term);\n        } elseif ( $output == ARRAY_N ) {\n            return array_values(get_object_vars($term));\n        } else {\n            return $term;\n        }\n    }\n\n\n\n    /**\n     * Fix for:\n     * - Taxonomy names in Taxonomy Manage page\n     * - 'Popular Tags' in Taxonomy (Tags) Manage page\n     * - Category filter dropdown menu in Post Manage page\n     * - Category list in Post Edit page\n     * - 'Most Used' tags list in Post Edit page (but have issues when saving)\n     * \n     * @param (array) $terms\n     * @param (string|array) $taxonomy\n     * @since 1.2\n     */\n    function get_terms($terms, $taxonomy) {\n        \n        global $pagenow;\n        \n        \n        if ( $pagenow != 'admin-ajax.php' ) {\n            \n            $meta = get_option('qtranslate_term_name');\n            $lang = call_user_func($this->get_plugin_prefix() . 'getLanguage');\n                    \n            \n            if ( !empty( $terms ) ) {\n                foreach ($terms as $term_index => $term) {\n                    // after saving, dont do anything\n                    if( ( isset($_POST['action'] ) && $_POST['action']  == \"editedtag\") ||\n                     !is_object( $term ) ) {\n                        return $terms;\n                    }\n                    $termname = $term->name;\n\t\t\t\t\tif( isset( $meta[$termname][$lang] ) ) {\n                        $term->name = $meta[$termname][$lang];\n                    }\n                };\n            };\n        }\n        return $terms;\n    }\n\n\n\n    /**\n     * Fix for:\n     * - Taxonomy & custom taxonomy names in Post Manage page\n     * - List of tags already added to the post in Post \n     * - Edit page (but have issues when saving)\n     *\n     * @param (array) $terms\n     * @param (int|array) $obj_id\n     * @param (string|array) $taxonomy\n     * @param (array) $taxonomy\n     * @since 1.2\n     */ \n    function get_object_terms($terms, $obj_id, $taxonomy, $args) {\n        \n        global $pagenow;\n        \n        // Although in post edit page the tags are translated,\n        // but when saving/updating the post Wordpress considers\n        // the translated tags as new tags. Due to this\n        // issue I limit this 'hack' to the post manage\n        // page only.\n        if ( $pagenow == 'edit.php' ) {\n            \n            // $taxonomy output seems to be wrapped\n            // in single quotes, thus remove them to\n            // make the output valid\n            $tax = str_replace(\"'\", \"\", $taxonomy);\n            \n            $meta = get_option('qtranslate_term_name');\n            $lang = call_user_func($this->get_plugin_prefix() . 'getLanguage');\n            \n            if ( !empty( $terms ) ) {\n                foreach ($terms as $term) {\n                    if( isset( $meta[$term->name][$lang] ) ) {\n                        $term->name = $meta[$term->name][$lang];\n                    }\n                };\n            };\n        \n        }\n        return $terms;\n    }\n\n\n\n    /**\n     * hide quickedit slug\n     * \n     * @since 1.0\n     */\n    public function hide_quick_edit() {\n        echo \"<!-- QTS remove quick edit box -->\" . PHP_EOL;\n        echo \"<style type=\\\"text/css\\\" media=\\\"screen\\\">\" . PHP_EOL;\n        echo \"  .inline-edit-row fieldset.inline-edit-col-left .inline-edit-col *:first-child + label + label  { display: none !important }\" . PHP_EOL;\n        echo \"</style>\" . PHP_EOL;\n    }\n    \n    \n    \n    /**\n     * Hide auttomatically the wordpress slug blog in edit posts page\n     *\n     * @since 1.0\n     */\n    public function hide_slug_box() {\n        global $pagenow;\n        \n        switch ( $pagenow ):\n            case 'edit-tags.php':\n            \n                echo \"<!-- QTS remove slug box -->\" . PHP_EOL;\n                echo \"<script type=\\\"text/javascript\\\" charset=\\\"utf-8\\\">\" . PHP_EOL;\n                echo \"  jQuery(document).ready(function($){\" . PHP_EOL;\n                echo \"      $(\\\"#tag-slug\\\").parent().hide();\" . PHP_EOL;\n                echo \"      $(\\\".form-field td #slug\\\").parent().parent().hide();\" . PHP_EOL;\n                echo \"  });\" . PHP_EOL;\n                echo \"</script>\" . PHP_EOL;\n                break;\n            \n            case 'post.php':\n            \n                echo \"<!-- QTS remove slug box -->\" . PHP_EOL;\n                echo \"<style type=\\\"text/css\\\" media=\\\"screen\\\">\" . PHP_EOL;\n                echo \"  #edit-slug-box { display: none !important}\" . PHP_EOL;\n                echo \"</style>\" . PHP_EOL;\n                break;\n        endswitch;\n    }\n    \n    \n        \n    /**\n     * Creates a metabox for every post, page and post type avaiable\n     *\n     * @since 1.0\n     */\n    public function add_slug_meta_box() {\n        \n        if ( function_exists( 'add_meta_box' ) ) {\n            \n            $context  = apply_filters(\"qts_admin_meta_box_context\",\"side\");\n            $priority = apply_filters(\"qts_admin_meta_box_priority\",\"high\");\n\n            add_meta_box( 'qts_sectionid', __('Slug', 'qts'), array(&$this, 'draw_meta_box'), 'post', $context, $priority);\n            add_meta_box( 'qts_sectionid', __('Slug', 'qts'), array(&$this, 'draw_meta_box'), 'page', $context, $priority);\n            \n            foreach ( get_post_types( array('_builtin' => false ) ) as $ptype )\n                add_meta_box( 'qts_sectionid', __('Slug', 'qts'), array(&$this, 'draw_meta_box'), $ptype, $context, $priority );\n        }\n    }\n    \n    \n    \n    /**\n     * Shows the fields where insert the translated slugs in the post and page edit form.\n     *\n     * @param $post (object) current post object\n     *\n     * @since 1.0\n     */\n    public function draw_meta_box( $post ) {\n        global $q_config;\n      \n        // Use nonce for verification\n        echo \"<table style=\\\"width:100%\\\">\" . PHP_EOL;\n        echo \"<input type=\\\"hidden\\\" name=\\\"qts_nonce\\\" id=\\\"qts_nonce\\\" value=\\\"\" . wp_create_nonce( 'qts_nonce' ) . \"\\\" />\" . PHP_EOL;\n  \n        foreach ($q_config['enabled_languages'] as $lang):\n            \n            $slug = get_post_meta( $post->ID, $this->get_meta_key($lang), true);\n            \n            $value = ( $slug ) ? htmlspecialchars( $slug , ENT_QUOTES ) : '';\n            \n            echo \"<tr>\" . PHP_EOL;\n            echo \"<th style=\\\"text-align:left; width:10%; color:#555 \\\"><label for=\\\"qts_{$lang}_slug\\\">\".__($q_config['language_name'][$lang], 'qtranslate').\"</label></th>\" . PHP_EOL;\n            echo \"<td><input type=\\\"text\\\" id=\\\"qts_{$lang}_slug\\\" name=\\\"qts_{$lang}_slug\\\" value=\\\"$value\\\" style=\\\"width:90%; margin-left:10%; color:#777\\\" /></td>\" . PHP_EOL;\n            echo \"</tr>\" . PHP_EOL;\n            \n        endforeach;\n        \n        echo '</table>' . PHP_EOL;\n    }\n    \n    \n    \n    /**\n     * Sanitize title as slug, if empty slug\n     * \n     * @param $post (object) the post object\n     * @param $slug (string) the slug name\n     * @param $lang (string) the language\n     * @return the slug validated\n     *\n     * @since 1.0\n     */\n    public function validate_post_slug( $slug, $post, $lang ) { \n            \n        $post_title = trim(call_user_func($this->get_plugin_prefix() . 'use',$lang, $_POST['post_title']));\n        $post_name = get_post_meta($post->ID, $this->get_meta_key($lang), true);\n        if (!$post_name) {\n            $post_name = $post->post_name;\n        }\n        \n        $name = ( $post_title == '' || strlen($post_title) == 0 ) ? $post_name : $post_title;\n        \n        $slug = trim($slug);\n            \n        $slug = (empty($slug)) ? sanitize_title($name) : sanitize_title($slug);\n        \n        \n        \n        return htmlspecialchars( $slug , ENT_QUOTES );\n    }\n    \n    \n    \n    /**\n     * Validates post slug against repetitions per language\n     * \n     * @param $post (object) the post object\n     * @param $slug (string) the slug name\n     * @param $lang (string) the language\n     * @return the slug validated\n     *\n     * @since 1.0\n     */\n    public function unique_post_slug( $slug, $post, $lang ) {\n        \n        $original_status = $post->post_status;\n        \n        if ( in_array($post->post_status, array('draft', 'pending')) ) {\n            $post->post_status = 'publish';\n        }\n        \n        $slug = $this->wp_unique_post_slug( $slug, $post->ID, $post->post_status, $post->post_type, $post->post_parent, $lang );\n        \n        $post->post_status = $original_status;\n        \n        return $slug;\n    }\n    \n    \n    \n    /**\n     * Computes a unique slug for the post and language, when given the desired slug and some post details.\n     *\n     * @param string $slug the desired slug (post_name)\n     * @param integer $post_ID\n     * @param string $post_status no uniqueness checks are made if the post is still draft or pending\n     * @param string $post_type\n     * @param integer $post_parent\n     * @return string unique slug for the post, based on language meta_value (with a -1, -2, etc. suffix)\n     *\n     * @since 1.0\n     */\n    public function wp_unique_post_slug( $slug, $post_ID, $post_status, $post_type, $post_parent, $lang ) {\n        if ( in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) ) {\n            return $slug;\n        }\n\n        global $wpdb, $wp_rewrite;\n\n        $feeds = $wp_rewrite->feeds;\n        if ( ! is_array( $feeds ) ) {\n            $feeds = array();\n        }\n        \n        $meta_key = $this->get_meta_key($lang);\n        if ( 'attachment' == $post_type ) {\n            // Attachment slugs must be unique across all types.\n            $check_sql = \"SELECT post_name FROM $wpdb->posts WHERE post_name = %s AND ID != %d LIMIT 1\";\n            $post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $slug, $post_ID ) );\n\n            if ( $post_name_check || in_array( $slug, $feeds ) || apply_filters( 'wp_unique_post_slug_is_bad_attachment_slug', false, $slug ) ) {\n                $suffix = 2;\n                do {\n                    $alt_post_name = substr ($slug, 0, 200 - ( strlen( $suffix ) + 1 ) ) . \"-$suffix\";\n                    $post_name_check = $wpdb->get_var( $wpdb->prepare($check_sql, $alt_post_name, $post_ID ) );\n                    $suffix++;\n                } while ( $post_name_check );\n                $slug = $alt_post_name;\n            }\n        } else {\n            // Post slugs must be unique across all posts.\n            $check_sql = \"SELECT $wpdb->postmeta.meta_value FROM $wpdb->posts,$wpdb->postmeta WHERE $wpdb->posts.ID = $wpdb->postmeta.post_id AND $wpdb->postmeta.meta_key = '%s' AND $wpdb->postmeta.meta_value = '%s' AND $wpdb->posts.post_type = %s AND ID != %d LIMIT 1\";\n            $post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $meta_key, $slug, $post_type, $post_ID ) );\n\n            if ( $post_name_check || in_array( $slug, $feeds ) || apply_filters( 'wp_unique_post_slug_is_bad_flat_slug', false, $slug, $post_type ) ) {\n                $suffix = 2;\n                do {\n                    $alt_post_name = substr( $slug, 0, 200 - ( strlen( $suffix ) + 1 ) ) . \"-$suffix\";\n                    $post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $meta_key, $alt_post_name, $post_type, $post_ID ) );\n                    $suffix++;\n                } while ( $post_name_check );\n                $slug = $alt_post_name;\n            }\n        }\n\n        return $slug;\n    }\n    \n    \n    \n    \n    /**\n     * Saves the translated slug when the page is saved\n     * \n     * @param $post_id the post id\n     * @param $post the post object\n     *\n     * @since 1.0\n     */\n    public function save_postdata( $post_id, $post ) {\n        \n        $post_type_object = get_post_type_object( $post->post_type);\n        \n        \n        if ((defined('DOING_AUTOSAVE') && DOING_AUTOSAVE)                       // check autosave\n        || (!isset($_POST['post_ID']) || $post_id != $_POST['post_ID']) // check revision\n        || (!wp_verify_nonce( $_POST['qts_nonce'], 'qts_nonce'))                // verify nonce\n        || (!current_user_can($post_type_object->cap->edit_post, $post_id))) {  // check permission\n            return $post_id;\n        }\n        foreach ($this->get_enabled_languages() as $lang) {\n            \n            $meta_name = $this->get_meta_key($lang);\n            $meta_value = apply_filters( 'qts_validate_post_slug', $_POST[\"qts_{$lang}_slug\"], $post, $lang);\n            delete_post_meta($post_id, $meta_name);\n            update_post_meta($post_id, $meta_name, $meta_value);\n            \n        }\n    }\n    \n    \n    \n    /**\n     * Display multiple input fields, one per language\n     * \n     * @param $term the term object\n     *\n     * @since 1.0\n     */\n    public function show_term_fields( $term ) {\n        global $q_config;\n        \n        // prints the fields in edit page\n        if (isset($_GET['action']) && $_GET['action'] == 'edit' ):\n  \n            echo \"<table class=\\\"form-table\\\">\" . PHP_EOL;\n            echo \"<input type=\\\"hidden\\\" name=\\\"qts_nonce\\\" id=\\\"qts_nonce\\\" value=\\\"\" .  wp_create_nonce( 'qts_nonce' ) . \"\\\" />\" . PHP_EOL;\n  \n            foreach( $q_config['enabled_languages'] as $lang ) {\n            \n                $slug = (is_object($term)) ? get_term_meta( $term->term_id, $this->get_meta_key($lang), true ) : '';\n            \n                $value = ( $slug ) ? htmlspecialchars( $slug , ENT_QUOTES ) : '';\n            \n                echo \"<tr class=\\\"form-field form-required\\\">\" . PHP_EOL;\n                echo \"<th scope=\\\"row\\\" valig=\\\"top\\\"><label for=\\\"qts_{$lang}_slug\\\">\".sprintf( __('Slug (%s)', 'qts'), $q_config['language_name'][$lang] ).\"</label></th>\" . PHP_EOL;\n                echo \"<td><input type=\\\"text\\\" name=\\\"qts_{$lang}_slug\\\" value=\\\"$value\\\" /></td></tr>\" . PHP_EOL;\n            \n            }\n        \n            echo '</table>';\n        \n        // prints the fields in new page\n        else:\n            echo \"<input type=\\\"hidden\\\" name=\\\"qts_nonce\\\" id=\\\"qts_nonce\\\" value=\\\"\" .  wp_create_nonce( 'qts_nonce' ) . \"\\\" />\" . PHP_EOL;\n  \n            foreach( $q_config['enabled_languages'] as $lang ) {\n                \n                echo \"<div class=\\\"form-field\\\">\" . PHP_EOL;\n            \n                $slug = (is_object($term)) ? get_term_meta( $term->term_id, $this->get_meta_key($lang), true ) : '';\n            \n                $value = ( $slug ) ? htmlspecialchars( $slug , ENT_QUOTES ) : '';\n            \n                echo \"<label for=\\\"qts_{$lang}_slug\\\">\".sprintf( __('Slug (%s)', 'qts'), $q_config['language_name'][$lang] ).\"</label>\" . PHP_EOL;\n                echo \"<input type=\\\"text\\\" name=\\\"qts_{$lang}_slug\\\" value=\\\"$value\\\" aria-required=\\\"true\\\">\" . PHP_EOL;\n                \n                echo '</div>';\n            \n            }\n\n        endif;\n    }\n    \n    \n    \n    /**\n     * Sanitize title as slug, if empty slug\n     * \n     * @param $term (object) the term object\n     * @param $slug (string) the slug name\n     * @param $lang (string) the language\n     * @return the slug validated\n     *\n     * @since 1.0\n     */\n    public function validate_term_slug( $slug, $term, $lang ) {\n\n        global $q_config;\n        \n        $lang_name = $q_config['term_name'][$term->name][$lang];\n        \n        $ajax_name = 'new' . $term->taxonomy;\n        \n        $post_name = isset($_POST['name']) ? $_POST['name'] : '';\n        \n        $term_name = isset($_POST[$ajax_name]) ? trim($_POST[$ajax_name]) : $post_name;\n    \n        if (empty($term_name)) {\n            return $slug;\n        }\n        \n        $name = ( $lang_name == '' || strlen($lang_name) == 0 ) ? $term_name : $lang_name;\n        \n        $slug = trim($slug);\n            \n        $slug = (empty($slug)) ? sanitize_title($name) : sanitize_title($slug);\n        \n        return htmlspecialchars( $slug , ENT_QUOTES );\n    }\n    \n    \n    \n    /**\n     * Will make slug unique per language, if it isn't already.\n     *\n     * @param string $slug The string that will be tried for a unique slug\n     * @param object $term The term object that the $slug will belong too\n     * @param object $lang The language reference \n     * @return string Will return a true unique slug.\n     *\n     * @since 1.0\n     */\n    public function unique_term_slug($slug, $term, $lang) {\n      \n        global $wpdb;\n\t\t\n        $meta_key_name = $this->get_meta_key($lang);\n        $query = $wpdb->prepare(\"SELECT term_id FROM $wpdb->termmeta WHERE meta_key = '%s' AND meta_value = '%s' AND term_id != %d \", $meta_key_name, $slug, $term->term_id);\n        $exists_slug = $wpdb->get_results($query);\n\n        if ( empty($exists_slug) ) {\n            return $slug;\n        }\n        \n        // If we didn't get a unique slug, try appending a number to make it unique.\n        $query = $wpdb->prepare(\"SELECT meta_value FROM $wpdb->termmeta WHERE meta_key = '%s' AND meta_value = '%s' AND term_id != %d\", $meta_key_name, $slug, $term->term_id);\n\n        if ( $wpdb->get_var( $query ) ) {\n          $num = 2;\n          do {\n            $alt_slug = $slug . \"-$num\";\n            $num++;\n            $slug_check = $wpdb->get_var(\n              $wpdb->prepare(\n               \"SELECT meta_value FROM $wpdb->termmeta WHERE meta_key = '%s' AND meta_value = '%s'\",\n               $meta_key_name,\n               $alt_slug) );\n          } while ( $slug_check );\n          $slug = $alt_slug;\n        }\n\n        return $slug;\n    }\n    \n    \n    \n    /**\n     * Display multiple input fields, one per language\n     * \n     * @param $term_id the term id\n     * @param $tt_id the term taxonomy id\n     * @param $taxonomy the term object\n     *\n     * @since 1.0\n     */\n    public function save_term( $term_id, $tt_id, $taxonomy ) {\n        \n        $cur_screen = get_current_screen();\n        if ( (defined('DOING_AUTOSAVE') && DOING_AUTOSAVE )  // check autosave\n        || ( !current_user_can('edit_posts') ) // check permission\n        || ( isset($cur_screen) && $cur_screen->id === \"nav-menus\") \n        ) {                  \n            return $term_id;\n        }\n        \n        $term = get_term( $term_id, $taxonomy);\n        foreach( $this->get_enabled_languages() as $lang ) {\n            $meta_name = $this->get_meta_key($lang);\n      \n            //43LC: when at the post edit screen and creating a new tag\n            // the $slug comes from $_POST with the value of the post slug,\n            // not with the term slug. \n            if ($_POST['action'] == \"editpost\")  {\n                // so we use the slug wp gave it\n                $term_slug = $term->slug;\n            } else {\n                // otherwise, its the edit term screen\n                $term_slug =  $_POST[\"qts_{$lang}_slug\"];\n            }\n            \n            $meta_value = apply_filters( 'qts_validate_term_slug', $term_slug, $term, $lang);\n                \n            delete_term_meta($term_id, $meta_name);\n            update_term_meta($term_id, $meta_name, $meta_value);\n       }\n    }\n    \n    \n    \n    /**\n     * deletes termmeta rows associated with the term\n     * \n     * @since 1.0\n     */ \n    public function delete_term($term_id, $tt_id, $taxonomy) {\n        global $wpdb;\n        \n        $wpdb->query( $wpdb->prepare( \"DELETE FROM $wpdb->termmeta WHERE term_id = %d\", $term_id ) );\n    }\n    \n    \n    \n    /**\n\t * creates and prints the forms and hides the default fields \n\t * @param object $term the term object \n\t * @since 1.1.12\n\t * \n\t * TODO: merge with our own form.\n\t * TODO: move code into js file\n\t *\n\t */\n\tpublic function qts_modify_term_form($term) {\n\t\techo \"<script type=\\\"text/javascript\\\">\\n// <![CDATA[\\r\\n\";\n\t\tif(is_object($term)&&isset($term->name)) {\n\t\t\t$termname = $term->name;\n\t\t} else {\n\t\t\t$termname = \"\";\n\t\t}\n\t    if(isset($_GET['action']) && $_GET['action']=='edit') {\n\t\t   foreach($this->get_enabled_languages() as $language) {\n\t\t\t   echo $this->qts_insert_term_input('name', __('Name','qts'), $termname, $language,\"edit\");\n\t        }\n\t    } else {\n\t\t   foreach($this->get_enabled_languages() as $language) {\n\t           echo $this->qts_insert_term_input('tag-name', __('Name','qts'), $termname, $language,\"new\");   \n\t        }\n\t    }\n\t\t// hide real category text\n\t\techo \"if (ins != null) ins.style.display='none';\\n\";\n\t\techo \"// ]]>\\n</script>\\n\";\n\t}\n\n\t/**\n\t * Helper for qts_modify_term_form_for\n\t * @param string $id the term id\n\t * @param object #term the term\n\t * @param string $language the term name\n\t * @param string $action the term name\n\t * @return string $html the new input fields\n\t * @since 1.1.12\n\t * TODO: use DocumentFragment\n\t */\n\tprivate function qts_insert_term_input($id,$name, $language,$action){\n\t\tglobal $q_config;\n\t\t$html = \"\";\n\t\tif( $action === \"new\") {\n\t\t    $html =\"\n\t        var il = document.getElementsByTagName('input'),\n\t        \t d = document.createElement('div'),\n                 l = document.createTextNode('\".$name.\" (\".$q_config['language_name'][$language].\")'),\n\t            ll = document.createElement('label'),\n\t             i = document.createElement('input'),\n\t           ins = null;\n\t        for(var j = 0; j < il.length; j++) {\n\t            if(il[j].id=='\".$id.\"') {\n\t                ins = il[j];\n\t                break;\n\t            }\n\t        }\n\t        i.type = 'text';\n\t        i.id = i.name = ll.htmlFor ='qtrans_term_\".$language.\"';\n\t    \";\n\t\t} elseif ( $action === \"edit\") {\n\t\t    $html =\"\n\t        var tr = document.createElement('tr'),\n\t            th = document.createElement('th'),\n\t            ll = document.createElement('label'),\n\t             l = document.createTextNode('\".$name.\" (\".$q_config['language_name'][$language].\")'),\n\t            td = document.createElement('td'),\n\t             i = document.createElement('input'),\n\t           ins = document.getElementById('\".$id.\"');\n\t        i.type = 'text';\n\t        i.id = i.name = ll.htmlFor ='qtrans_term_\".$language.\"';\n\t    \";\n\t    }\n\t\tif(isset($q_config['term_name'][$termname][$language])) {\n  \t\t $html .=\"\n\t\t     i.value = '\".addslashes(htmlspecialchars_decode($q_config['term_name'][$termname][$language], ENT_QUOTES)).\"';\";\n\t\t     //43LC: applied ENT_QUOTES to both edit and new forms. \n\t\t} else {\n\t\t  $html .=\"\n\t\t\t  if (ins != null)\n\t\t\t\t  i.value = ins.value;\n\t\t\t  \";\n\t\t}\n\t\t\n\t\tif($language == $this->default_language) {\n\t\t\t$html .=\"\n\t\t\t\ti.onchange = function() { \n\t\t\t\t\tvar il = document.getElementsByTagName('input'),\n\t\t\t\t\t   ins = null;\n\t\t\t\t\tfor(var j = 0; j < il.length; j++) {\n\t\t\t\t\t\tif(il[j].id=='\".$id.\"') {\n\t\t\t\t\t\t\tins = il[j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ins != null)\n\t\t\t\t\t\tins.value = document.getElementById('qtrans_term_\".$language.\"').value;\n\t\t\t\t};\n\t\t\t\t\";\n\t\t}\n\t\tif( $action === \"new\") {\n\t        $html .=\"\n\t        if (ins != null)\n\t            ins = ins.parentNode;\n\t        d.className = 'form-field form-required';\n\t        ll.appendChild(l);\n\t        d.appendChild(ll);\n\t        d.appendChild(i);\n\t        if (ins != null)\n\t            ins.parentNode.insertBefore(d,ins);\n\t        \";\n\t    } elseif ( $action === \"edit\") {\n\t        $html .=\"\n\t        ins = ins.parentNode.parentNode;\n\t        tr.className = 'form-field form-required';\n\t        th.scope = 'row';\n\t        th.vAlign = 'top';\n\t        ll.appendChild(l);\n\t        th.appendChild(ll);\n\t        tr.appendChild(th);\n\t        td.appendChild(i);\n\t        tr.appendChild(td);\n\t        ins.parentNode.insertBefore(tr,ins);\n\t        \";\n\t    }\n\t\treturn $html;\t\n\t}\n    /**\n     * adds support for qtranslate in taxonomies\n     *\n     * @since 1.0\n     */\n    public function taxonomies_hooks() {\n    \n        $taxonomies = $this->get_public_taxonomies();\n\n        if ($taxonomies) {\n            foreach ($taxonomies  as $taxonomy ) {\n                add_action( $taxonomy->name.'_add_form', array(&$this, 'qts_modify_term_form'));\n                add_action( $taxonomy->name.'_edit_form', array(&$this, 'qts_modify_term_form'));\n                add_action( $taxonomy->name.'_add_form',  array(&$this, 'show_term_fields'));\n                add_action( $taxonomy->name.'_edit_form_fields', array(&$this, 'show_term_fields') );\n                add_filter('manage_edit-'.$taxonomy->name.'_columns', array(&$this, 'taxonomy_columns'));\n                add_filter('manage_'.$taxonomy->name.'_custom_column', array(&$this, 'taxonomy_custom_column'), 0, 3);\n            }\n        }\n    }\n    \n    \n    \n    /*\n     * Bug fix for slug column in taxonomies\n     * \n     * @since 1.0\n     */\n    public function taxonomy_columns($columns) {\n        unset($columns['slug']);\n        unset($columns['posts']);\n        \n        $columns['qts-slug'] = __('Slug', 'qts');\n        $columns['posts'] = __('Posts', 'qts');\n        \n        return $columns;\n    }\n    \n    \n    \n    /*\n     * Bug fix for slug column in taxonomies\n     * \n     * @since 1.0\n     */\n    public function taxonomy_custom_column($str, $column_name, $term_id) {\n        \n        switch ($column_name) {\n            case 'qts-slug':\n                echo get_term_meta($term_id, $this->get_meta_key(), true);\n                break;\n        }\n        return false;\n    }\n    \n    \n    \n    \n    /**\n     * Bug fix for multisite blog names\n     * \n     * @since 1.0\n     */\n    public function blog_names($blogs) {\n        \n        foreach ($blogs as $blog) {\n            $blog->blogname = __($blog->blogname);\n        }\n        \n        return $blogs;\n    }\n    \n    \n    \n    /**\n     * Initialise the Language Widget selector\n     * \n     * @since 1.0\n     */\n    public function widget_init() {\n        \n        if (class_exists('qTranslateWidget')) {\n            unregister_widget('qTranslateWidget');\n        }\n        if (class_exists('mqTranslateWidget')) {\n            unregister_widget('mqTranslateWidget');\n        }\n        if (class_exists('ppqTranslateWidget')) {\n            unregister_widget('ppqTranslateWidget');\n        }\n        \n        //if (class_exists('qTranslateXWidget')) {//it has additional features some people use.\n        //    unregister_widget('qTranslateXWidget');\n        //}\n        \n        register_widget('QtranslateSlugWidget');\n    }\n    \n    \n    \n    /**\n     * remove some default dashboard Widgets on Desktop\n     *\n     * @since 1.0\n     */\n    function remove_dashboard_widgets() {\n        global $wp_meta_boxes;\n        unset($wp_meta_boxes['dashboard']['side']['core']['dashboard_quick_press']);\n    } \n    \n    \n    \n    /**\n     * adds support for qtranslate nav menus\n     * \n     * @since 1.0\n     */\n    public function fix_nav_menu() {\n        global $pagenow;\n        \n        if( $pagenow != 'nav-menus.php' ) {\n            return;\n        }\n\t\t\t\t//FIXME: fix the nav menu box\n\t\t\t\t//        wp_enqueue_script( 'nav-menu-query',  plugins_url( 'assets/js/qts-nav-menu-min.js' , dirname(__FILE__ ) ), 'nav-menu', '1.0' );\n\t\t\t\t//        add_meta_box( 'qt-languages', __('Languages', 'qts'), array(&$this, 'nav_menu_meta_box'), 'nav-menus', 'side', 'default' );\n    }\n    \n    \n    \n    /**\n     * draws meta box for select language\n     * \n     * @since 1.0\n     */\n    public function nav_menu_meta_box() {\n        global $q_config;\n        echo '<p>';\n        foreach($q_config['enabled_languages'] as $id => $language) {\n            $checked = ($language == $q_config['language']) ? ' checked=\"checked\"' : '';\n            echo '<p style=\"margin:0 0 5px 0\"><input type=\"radio\" style=\"margin-right:5px\" name=\"wa_qt_lang\" value=\"' . $language . '\" id=\"wa_gt_lang_' . $id . '\" ' . $checked . '/>';\n            echo '<label for=\"wa_gt_lang_' . $id . '\">';\n            echo '<img src=\"' . trailingslashit(WP_CONTENT_URL).$q_config['flag_location'].$q_config['flag'][$language] . '\"/>&nbsp;';\n            echo __($q_config['language_name'][$language], 'qtranslate');\n            echo '</label></p>';\n        }\n         echo '<p style=\"margin:0 0 5px 0\"><input type=\"radio\" style=\"margin-right:5px\" name=\"wa_qt_lang\" value=\"all\" id=\"wa_gt_lang_999\" />';\n            echo '<label for=\"wa_gt_lang_999\">';\n            echo __('All languages', 'qts');\n            echo '</label></p>';\n        echo '</p>';\n    }\n    \n    \n    \n    /**\n     * Language select function for templating\n     *\n     * @param $type (string) choose the type of menu: 'text', 'image', 'both', 'dropdown' \n     * @param $args (array) some args for draw the menu: array( 'id', 'class', 'short' );\n     * \n     * @since 1.0\n     */\n    public function language_menu( $type = \"text\", $args = array() ) {\n        global $q_config;\n        \n\n        // default arguments\n        $defaults = array(\n            'id' => \"qts-lang-menu\",\n            'class' => \"qts-lang-menu\",\n            'short' => false\n        );\n        $args = wp_parse_args( $args, $defaults );\n        \n        $languages = call_user_func($this->get_plugin_prefix() . 'getSortedLanguages');\n        \n        // every type\n        switch ( $type ) {\n            \n            case 'image':\n            case 'text':\n            case 'both':\n            \n                $baseurl = dirname(plugins_url());\n                $num_languages = count($languages);\n                echo \"<ul id=\\\"{$args['id']}\\\" class=\\\"qts_type_{$type} {$args['class']}\\\">\". PHP_EOL;\n                \n                foreach( $languages as $index => $lang ):\n                    \n                    $url = $this->get_current_url($lang);\n                    // 43LC: hack to play nice with qtranslate-x\n                    if( \"qtranxf_\" === $this->plugin_prefix && $this->default_language === $lang ) {\n\n                        $url = qtranxf_convertURL('',$lang,false,true);\n                    }\n                    $item_class = array();\n                    if ( (string)$q_config['language'] == (string)$lang ) $item_class[] = 'current-menu-item';\n                    if ( $index == ( $num_languages - 1) ) $item_class[] = 'last-child';\n                    \n          \n                    $item_class = ' class=\"qts_lang_item ' . implode(' ', $item_class) . '\"';\n                    \n                    $language_name = ($args['short']) ? $lang : $q_config['language_name'][$lang];\n                    \n                    if ( $type == 'image' ) {\n                        $link_class = \" class=\\\"qtrans_flag qtrans_flag_$lang\\\"\";\n                        $link_content = \"<span style=\\\"display:none\\\">$language_name</span>\";\n                    } else if ( $type == 'both' ) {\n                        $link_class = \" class=\\\"qts_both qtrans_flag qtrans_flag_$lang\\\"\";\n                        $link_content = \"$language_name\";                        \n                    } else {\n                        $link_class = '';\n                        $link_content = $language_name;\n                        $link_flag ='';\n                    }\n                    if( $type == 'image' || $type == 'both' ) {\n                        $link_flag_url =  $baseurl . '/'.$q_config['flag_location'].$q_config['flag'][$lang];\n                        \n                        //TODO: add i18n for alt attribute\n                        //43LC: hardcoding height and width\n                        $link_flag = \"<img widht=\\\"18\\\" height=\\\"12\\\" src=\\\"$link_flag_url\\\" alt=\\\"$language_name\\\" />\";\n                    }\n\n                    echo \"<li $item_class><a href=\\\"$url\\\" lang=\\\"$lang\\\" hreflang=\\\"$lang\\\"$link_class>$link_flag$link_content</a></li>\" . PHP_EOL;\n                    \n                endforeach;\n                \n                echo \"</ul>\". PHP_EOL;\n                \n                break;\n                \n            case 'dropdown':\n            \n                echo \"<select id=\\\"{$args['id']}\\\" class=\\\"{$args['class']}\\\" onchange=\\\"window.location.href=this.options[this.selectedIndex].value\\\">\". PHP_EOL;\n                \n                foreach( $languages as $index => $lang ):\n                    \n                    $url = $this->get_current_url($lang);\n                    \n                    $item_class = '';\n                    if ( (string)$q_config['language'] == (string)$lang ) $item_class = 'selected=\"selected\"';\n                    \n                    $language_name = ($args['short']) ? $lang : $q_config['language_name'][$lang];\n                    \n                    echo \"<option value=\\\"$url\\\" $item_class>$language_name</option>\" . PHP_EOL;\n                    \n                endforeach;\n                \n                echo \"</select>\". PHP_EOL;\n\n                break;\n        }\n        \n    }\n}\n", "=== Qtranslate Slug ===\nContributors: carlos_a_sanz, pedroghandi  \nDonate link: https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=SYC46KSLRC4Q8\nTags: qtranslate, slug, multilanguage, widget\nRequires at least: 3.3\nTested up to: 4.2.4\nStable tag: 1.1.17\nLicense: GPLv2 or later\nLicense URI: http://www.gnu.org/licenses/gpl-2.0.html\n\nAdds support for permalink translations to QTranslate-X since wordpress 3.0\n\n== Description ==\n\n[Qtranslate-X](http://wordpress.org/plugins/qtranslate-x/) is a nice plugin for Multilingual Websites. **Qtranslate Slug** is an addon to QTranslate, which adds support for permalinks translations.\n\n1.1.17 fixes a dangerous Security Exploit. Please update right now!\n\n= Requirements: =\n\n* Wordpress 3.3 (PHP 5.4 and MySQL 5)\n* mQtranslate 2.6.2.4 or Qtranslate 2.5.8 or qtranslate-x ( 2.9.1 )\n\n= New in 1.1.17 =\n* Hability to filter the position of the Metabox\n* Fixed dangerous security exploit!\n\n= New in 1.1.16 =\nMinor fix for the language menu using qtranslate's function\n\n= New in 1.1.15 =\n* Fixes the duplicated hreflang links in <head>\n\n= New in 1.1.14 =\n\nThe menu widget didn't allow the visitors to change to the default language if qtranslate-x was being used. So, adjusted the Language Menu widget to play nice with qtranslate-x. \nHope to bring some nice changes that were made in the github repository in the next version. For now, enjoy.\n\n= New in 1.1.13 =\n== Thanks to returning @pedro-mendonca for these commits: ==\n* Cleaned duplicated label in widget\n* Bug fix in \"Slug (%s)\" string translation\n* Changed text strings with no text-domain and with text-domain 'qtranlate' to text-domain 'qts'\n* pot catalog updated with current strings, including last found is \"More information about\".\n== Thanks to @johnclause for these : ==\n* Convenience links in notice_dependences\n* Menu compatibility with qTranslate-X\n* Fixed extra characters in widget\n### Thanks to vbkun for casting the much wanted function to get a slug based on an id and language\n* Added a global qts_get_slug( $id, $lang)\n### and sadly:\n* removed the menu admin box until better implementation\n\n\nSee you next Version!\n\n\n**Advice: If you're using a multisite installation, you will must activate qtranslate plugins by separately on each site.**\n\nYou can also check the [project website](http://not-only-code.github.com/qtranslate-slug/) hosted on [GitHub](http://not-only-code.github.com).\nThanks for use this plugin!\n\n= Contributors =\n\n* [Pedro de Carvalho](https://github.com/LC43/)\n* [Risto Niinemets](https://github.com/RistoNiinemets)\n* [Pedro Mendon\u00e7a](https://github.com/pedro-mendonca)\n* [codep0et](https://github.com/codep0et)\n* [Giraldi Maggio](https://github.com/bedex78)\n* [jinoOM](https://github.com/jinoOM)\n* [Juanfran](https://github.com/juanfran-granados)\n* [Arild](https://github.com/arildm)\n* [Rafa Aguilar](https://github.com/rafitaFCB)\n* [Bastian Heist](https://github.com/beheist)\n* [John Clause](https://github.com/johnclause)\n\n\n== Installation ==\n**This plugins requires [Qtranslate](http://wordpress.org/extend/plugins/qtranslate/) or [mqTranslate](https://wordpress.org/plugins/mqtranslate/) installed previously, if not, it will not activate.**\n\n1. Upload `qtranslate-slug` to the `/wp-content/plugins/` directory.\n1. Activate the plugin through the 'Plugins' menu in WordPress.\n1. That's all!\n\n= Changing base permastructs =\n\n1. In admin: navigate to *Settings/Slug options*.\n1. Set the base permastructs for **post types** and **taxonomies** (If you setup a base permastruct for *categories* or *tags* in *Settings/Permalinks*, these will be overwritten by the translated ones).\n1. Save settings and that's all!\n\n== Frequently Asked Questions ==\n\n= It works with posts and pages, but with other content type? =\n\nThis plugin allows to translate slugs of: posts, pages, custom post types, categories, tags and custom taxonomies.\n\n= Do I have to configure anything? =\n\nIf you want to translate also the base permastructs (ex. *category*, *tag*, etc). Visit the plugin settings page in the admin *Settings/Slug options*\n\n= How can i insert a language selector in my theme ? =\n\nYou can choose to:\n* use **Qtranslate Slug Widget** in your sidebar.\n* place in your template `<?php if (function_exists('qts_language_menu') ) qts_language_menu('text'); ?>`. Options are: `dropdown`, `text`, `image`, and `both`.\n\n= Appears an error 404, what can i do? =\n\nIn the admin go to *Settings/Permalinks* or *Settings/Slug options* and save.\n\n= I can't manage translations in Nav Menus. = \n\nThat's because language selector metabox is hidden, if you are in admin *nav menus* screen, press the button **Screen options** (on top and right) and after, check the option *Languages*. It will appear a **Language** meta box on top of the left sidebar.\n\n= How to get the current url in a specific language? =\n\nYou can use `qts_get_url()` or the awkwardly named `qTranslateSlug_getSelfUrl()` which is an alias for the first one.\n\n\n== Screenshots ==\n\n1. Edit page for: post / page / post_type, you can see the meta box for translated slugs on top and right.\n2. Add new taxonomy page\n3. Edit taxonomy page\n4. Qtranslate Slug options page for translate base permastructs of post_types and taxonomies.\n\n== Changelog ==\n\n\n= New in Versions 1.1.12 =\n\n* fixed warnings in settings\n* replace qtranslate with our own for taxonomies\n\n= New in Versions 1.1.10 and 1.1.11 =\n\n* Fixing wrong commit to wp.org\n* Clean deleted files \n= New in Version 1.1.9 =\n\nLots of bug fixes! Thanks again to everyone that contributed to this project, with commits, bug reports and suggestions.\n\n* Compatibility with qtranslate-X! ( thanks @beheist, pull #85, fixing most of #80 )\n* More updates to the portuguese translation ( thanks pedro-mendonca, pull #86)\n* Corrected the link to language files ( thanks pedro-mendonca )\n* Added translation for some hardcoded texts ( thanks pedro-mendonca )\n* Corrected a link from 'qtranslate' to 'qts' language files ( thanks pedro-mendonca )\n* Fixed taxonomies slugs ( thanks to [eirikv's bug report](https://wordpress.org/support/topic/categories-slug-dont-work) )\n* Fixed many warnings ( thanks piffpaffpuff, issue #78 and to [pedrodu1](https://wordpress.org/support/topic/warnings-qtranslate-slugphp) )\n* Changed the behaviour of \"Quick Edit\", from the wp forums [1](https://wordpress.org/support/topic/categories-tags-and-quick-edit-dont-show-in-admin) [2](https://wordpress.org/support/topic/quick-edit-inhibited-by-qtranslate-slug-with-wp-41-mqtranslate) ( thanks everyone!! )\n* Fixed the menus! Now you can properly use one menu for every language. Use the dropdown section \"Languages\", and for each item, change the \"Navigation Label\" and \"Title Attribute\". Select \"All languages\", to make sure everything is awesome! All these features were a consequence of fixing all the warnings based on [Gery's bug report](https://wordpress.org/support/topic/qtranslate-slug-conflicting-with-ubermenu). \n* Minor fixes, etc. \n\n\n= New in Version 1.1.9 =\n\nLots of bug fixes! Thanks again to everyone that contributed to this project, with commits, bug reports and suggestions.\n\n* Compatibility with qtranslate-X! ( thanks @beheist, pull #85, fixing most of #80 )\n* More updates to the portuguese translation ( thanks pedro-mendonca, pull #86)\n* Corrected the link to language files ( thanks pedro-mendonca )\n* Added translation for some hardcoded texts ( thanks pedro-mendonca )\n* Corrected a link from 'qtranslate' to 'qts' language files ( thanks pedro-mendonca )\n* Fixed taxonomies slugs ( thanks to [eirikv's bug report](https://wordpress.org/support/topic/categories-slug-dont-work)\n* Fixed many warnings ( thanks piffpaffpuff, issue #78 and to [pedrodu1](https://wordpress.org/support/topic/warnings-qtranslate-slugphp) )\n* Changed the behaviour of \"Quick Edit\", from the wp forums [1](https://wordpress.org/support/topic/categories-tags-and-quick-edit-dont-show-in-admin) [2](https://wordpress.org/support/topic/quick-edit-inhibited-by-qtranslate-slug-with-wp-41-mqtranslate) ( thanks everyone!! )\n* Fixed the menus! Now you can properly use one menu for every language. Use the dropdown section \"Languages\", and for each item, change the \"Navigation Label\" and \"Title Attribute\". Select \"All languages\", to make sure everything is awesome! All these features were a consequence of fixing all the warnings based on [Gery's bug report)[https://wordpress.org/support/topic/qtranslate-slug-conflicting-with-ubermenu). \n* Minor fixes, etc. \n\nSee you next Version!\n\n\n= 1.1.8 =\n\nMany thanks to everyone that contributed to this update, for their commits, bug reports and for simply using it\n\n* Portuguese translation and fixed some translation bugs  ( thanks pedro-mendonca )\n* removed mqtranslate switcher widget hook\n* Updated the plugin structure and coding style\n* solve some conflicts with search and pagination queries\n* Settings php errors, syntax indent and fixed settings assets url\n* Change titles when there is a click on pagination on show all pages tab ( thanks juanfran-granados )\n* Formatted dependency notice message ( thanks arildm )\n* Updated the deprecated jquery 'live' function and solve php strict standards error ( thanks rafitaFCB )  \n* Fixed error showing if PHP was newer than 5.3 ( thanks rafitaFCB )  \n* Strict standard advise prevented ( thanks rafitaFCB )\n* php notices are prevented in post edit, when using adding new translated tags  ( thanks rafitaFCB )\n* fixed the hreflang issue! 'bout time!\n* As discussed in issue #25, the flags are now img tags, intead of background-url.\n* Added another option to include the css style in a minified file. ( and also showing in the option screen the styles we would use.)\n\n= 1.1.7 = \n* removed styles from html elements and added options to use .css file or print inline styles\n* fixed tag creation on post edit.\n* fixed earlier bad post slug introduced in 1.1.6\n\n= 1.1.6 =\n* compatible with mqtranslate\n* php5.4+ compatible\n\n= 1.1.5 = \n* bugfixes\n\n= 1.1 = \n* added multisite support\n* fixed some parse url bugs\n* fixed slug bases validation \n\n= 1.0 =\n* **works** with any permalink combination and qtranslate mode.\n* new branch, the plugin has been rewritten: now the code is commented and wrapped inside a class, much code has change and the performance has been increased (use caches).\n* data system changed, no ID for slug type, then it don't needs install `qtrasnlate_slug` table. That means slugs now are stored on meta tables and installation creates a termmeta table with some new *core functions* to access/save data, based on [simple term meta](http://wordpress.org/extend/plugins/simple-term-meta/). Upgrade process when the plugin updates from older versions.\n* the plugin generates translated slug automatically from title in empty cases.\n* the plugin checks if the slug already exists (per each language and `post_type`/`taxonomy`), and adds a progressive number in this case. Works on ajax requests for example when new taxonomies are created in edit post page.\n* possibility to translate the base of permastructs for *post_types* and *taxonomies*, uses [$wp_rewrite](http://codex.wordpress.org/Class_Reference/WP_Rewrite). New admin options page for save the base permastructs.\n* added some filters, see in [other notes](http://wordpress.org/extend/plugins/qtranslate-slug/other_notes/).\n* added plugin language textdomain (.pot file).\n* updated **Language selector Widget**, and some new conventions like accessible functions for templating.\n* some bug fixes.\n* some Qtranslate patches.\n\n= 0.9 =\n* some wordpress qTranslate bug fixes\n* adds a javascript solution for qTranslate Nav Menus\n\n= 0.8 =\n* added support por Categories\n* added support por Tags\n* added support por Taxonomies\n* added support por Custom Post Types\n\n= 0.7 = [Zapo](http://www.qianqin.de/qtranslate/forum/viewtopic.php?f=4&t=1049&start=50#p7499)\n* added suport for qTranslate TLD domain mode (en: domain.com | fr: domain.fr) visit \n\n= 0.5 and 0.6 enhanched by Marco Del Percio =\n\n== Upgrade Notice ==\n\n= 1.0 =\nMajor version, the plugin has been rewritten. Better performance, and some enhancements.\n\n= 0.9 =\nThis version fix some bugs and allow multilanguage in nav-menus.\n\n= 0.8 =\nA lot of slugs content allowed\n\n= 0.7 =\nThis version allows TLD domain option for a different Qtranslate fork maded by Zappo\n\n\n== Other notes ==\n\nPlugin filters reference:\n\n= qts_validate_post_slug =  \nfilter to process the post slug before is saved on the database.  \n`args: $post (object), $slug (string), $lang (string)`\n\n= qts_validate_term_slug =  \nfilter to process the term slug before is saved on the database.  \n`args: $term (object), $slug (string), $lang (string)`\n\n= qts_url_args =  \nfilter to process the entire url after it has been generated.  \n`args: $url (string), $lang (string)`\n \n= qts_permastruct =  \nfilter to process the permastruct, used for change the base.  \n`args: $permastruct (string), $name (string)`\n\n\n= Todo =\n\n* detect Slug for each language and redirect accordingly in parse_query.\n* expand qtranslate for translate attachment names and descriptions ( useful for galleries )\n* translate other slugs like attachments.\n* qtranslate integration with other plugins like Jigoshop, e-commerce, etc. Addapt **$wp_rewrite**.\n", "= New in 1.1.17 =\n* Fixed dangerous security exploit!\n* Hability to filter the position of the Metabox\n\n= New in 1.1.16 =\nMinor fix for the language menu using qtranslate's function\n\n= New in 1.1.15 =\n* Fixes the duplicated hreflang links in <head>\n\n= New in 1.1.14 =\n\nThe menu widget didn't allow the visitors to change to the default language if qtranslate-x was being used. So, adjusted the Language Menu widget to play nice with qtranslate-x. \nHope to bring some nice changes that were made in the github repository in the next version. For now, enjoy.\n\n= 1.1.13 =\n== Thanks to returning @pedro-mendonca for these commits: ==\n* Cleaned duplicated label in widget\n* Bug fix in \"Slug (%s)\" string translation\n* Changed text strings with no text-domain and with text-domain 'qtranlate' to text-domain 'qts'\n* pot catalog updated with current strings, including last found is \"More information about\".\n== Thanks to @johnclause for these : ==\n* Convenience links in notice_dependences\n* Menu compatibility with qTranslate-X\n* Fixed extra characters in widget\n== Thanks to vbkun for casting this much wanted function ==\n* Added a global qts_get_slug( $id, $lang)\n== and sadly: ==\n* removed the menu admin box until better implementation\n\n= 1.1.12 =\n\n* fixed warnings in settings\n* replace qtranslate with our own for taxonomies\n\n= 1.1.10 and 1.1.11 =\n* Fixing wrong commit to wp.org\n* Clean deleted files\n\n= 1.1.9  =\n\nLots of bug fixes! Thanks again to everyone that contributed to this project, with commits, bug reports and suggestions.\n\n* Compatibility with qtranslate-X! ( thanks @beheist, pull #85, fixing most of #80 )\n* More updates to the portuguese translation ( thanks pedro-mendonca, pull #86)\n* Corrected the link to language files ( thanks pedro-mendonca )\n* Added translation for some hardcoded texts ( thanks pedro-mendonca )\n* Corrected a link from 'qtranslate' to 'qts' language files ( thanks pedro-mendonca )\n* Fixed taxonomies slugs ( thanks to [eirikv's bug report](https://wordpress.org/support/topic/categories-slug-dont-work) )\n* Fixed many warnings ( thanks piffpaffpuff, issue #78 and to [pedrodu1](https://wordpress.org/support/topic/warnings-qtranslate-slugphp) )\n* Changed the behaviour of \"Quick Edit\", from the wp forums [1](https://wordpress.org/support/topic/categories-tags-and-quick-edit-dont-show-in-admin) [2](https://wordpress.org/support/topic/quick-edit-inhibited-by-qtranslate-slug-with-wp-41-mqtranslate) ( thanks everyone!! )\n* Fixed the menus! Now you can properly use one menu for every language. Use the dropdown section \"Languages\", and for each item, change the \"Navigation Label\" and \"Title Attribute\". Select \"All languages\", to make sure everything is awesome! All these features were a consequence of fixing all the warnings based on [Gery's bug report](https://wordpress.org/support/topic/qtranslate-slug-conflicting-with-ubermenu). \n* Minor fixes, etc. \n\nSee you next Version!\n\n= 1.1.8 =\n\nMany thanks to everyone that contributed to this update, both for their commits and bug reports )\n\n* Portuguese translation and fixed some translation bugs  ( thanks pedro-mendonca )\n* removed mqtranslate switcher widget hook\n* Updated the plugin structure and coding style\n* solve some conflicts with search and pagination queries\n* Settings php errors, syntax indent and fixed settings assets url\n* Change titles when there is a click on pagination on show all pages tab ( thanks juanfran-granados )\n* Formatted dependency notice message ( thanks arildm )\n* Updated the deprecated jquery 'live' function and solve php strict standards error ( thanks rafitaFCB )  \n* Fixed error showing if PHP was newer than 5.3 ( thanks rafitaFCB )  \n* Strict standard advise prevented ( thanks rafitaFCB )\n* php notices are prevented in post edit, when using adding new translated tags  ( thanks rafitaFCB )\n* fixed the hreflang issue! 'bout time!\n* As discussed in issue #25, the flags are now img tags, intead of background-url.\n* Added another option to include the css style in a minified file. ( and also showing in the option screen the styles we would use.)\n\n= 1.1.7 = \n* removed styles from html elements and added options to use .css file or print inline styles\n* fixed tag creation on post edit.\n* fixed earlier bad post slug introduced in 1.1.6\n\n= 1.1.6 =\n* compatible with mqtranslate\n* php5.4+ compatible\n\n= 1.1.5 = \n* bugfixes\n\n= 1.1 = \n* added multisite support\n* fixed some parse url bugs\n* fixed slug bases validation \n\n= 1.0 =\n* new branch, the plugin has been rewrited: now the code is commented and wrapped inside a class, also all code has change and the performance has been increased.\n* structural changes:\n\t* no ID for slug type, then don't install qtrasnlate_slug table.\n\t* slugs now are stored on meta tables, installation creates a termmeta table with some new 'core functions' to access/save data, based on [simple term meta](http://wordpress.org/extend/plugins/simple-term-meta/).\n* some automation:\n\t* the plugin generates translated slug automatically from title in empty cases (like wordpress).\n\t* the plugin checks if the slug already exists (per each language and type / taxonomy), and adds a progressive number in this case (like wordpress).\n\t* works on ajax requests like creatig new taxonomies on edit post page.\n* possibility to translate the base of permastructs for 'post_types' and 'taxonomies' (uses $wp_rewrite).\n* added some filters:\n\t* 'qts_validate_post_slug' : args( $post (object), $slug (string), $lang (string) ) / filter to process the post slug before is saved on the database.\n\t* 'qts_validate_term_slug' : args( $term (object), $slug (string), $lang (string) ) / filter to process the term slug before is saved on the database.\n\t* 'qts_current_url' : args ( $url (string), $lang (string) ) / filter to process the entire url after it has been generated.\n\t* 'qts_permastruct' : args ( $permastruct (string), $name (string) ) / filter to process the permastruct, used for change the base.\n* added plugin language textdomain (.pot file)\n* new admin options page for save the base permastructs.\n* import process when the plugin updates older versions.\n* some bug fixes.\n* some Qtranslate patches.\n\n= 0.9 =\n* some wordpress qTranslate bug fixes\n* adds a javascript solution for qTranslate Nav Menus\n\n= 0.8 =\n* added support por Categories\n* added support por Tags\n* added support por Taxonomies\n* added support por Custom Post Types\n\n= 0.7 ( enhanced by Zapo (http://www.qianqin.de/qtranslate/forum/viewtopic.php?f=4&t=1049&start=50#p7499) ) =\n* added suport for qTranslate TLD domain mode (en: domain.com | fr: domain.fr) visit \n\n= 0.5 and 0.6 enhanched by Marco Del Percio ="], "filenames": ["includes/class-qtranslate-slug.php", "readme.txt", "version.txt"], "buggy_code_start_loc": [1111, 6, 1], "buggy_code_end_loc": [1933, 22, 2], "fixing_code_start_loc": [1111, 6, 1], "fixing_code_end_loc": [1936, 27, 4], "type": "CWE-79", "message": "A vulnerability was found in Qtranslate Slug Plugin up to 1.1.16. It has been classified as problematic. Affected is the function add_slug_meta_box of the file includes/class-qtranslate-slug.php. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 1.1.17 is able to address this issue. The name of the patch is 74b3932696f9868e14563e51b7d0bb68c53bf5e4. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-222324.", "other": {"cve": {"id": "CVE-2015-10092", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-06T06:15:09.733", "lastModified": "2023-03-10T22:43:45.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Qtranslate Slug Plugin up to 1.1.16. It has been classified as problematic. Affected is the function add_slug_meta_box of the file includes/class-qtranslate-slug.php. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 1.1.17 is able to address this issue. The name of the patch is 74b3932696f9868e14563e51b7d0bb68c53bf5e4. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-222324."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qtranslate_slug_project:qtranslate_slug:*:*:*:*:*:wordpress:*:*", "versionEndExcluding": "1.1.17", "matchCriteriaId": "A1CCAF38-AB70-48A7-961A-EBF7AF412983"}]}]}], "references": [{"url": "https://github.com/wp-plugins/qtranslate-slug/commit/74b3932696f9868e14563e51b7d0bb68c53bf5e4", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/wp-plugins/qtranslate-slug/releases/tag/1.1.17", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.222324", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.222324", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wp-plugins/qtranslate-slug/commit/74b3932696f9868e14563e51b7d0bb68c53bf5e4"}}