{"buggy_code": ["# vim:set et sts=4 sw=4:\n# -*- coding: utf-8 -*-\n#\n# ibus-anthy - The Anthy engine for IBus\n#\n# Copyright (c) 2007-2008 Peng Huang <shawn.p.huang@gmail.com>\n# Copyright (c) 2010-2013 Takao Fujiwara <takao.fujiwara1@gmail.com>\n# Copyright (c) 2007-2013 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nimport os\nfrom os import environ, path\nimport signal\nimport sys\nfrom gettext import dgettext\n\nfrom main import get_userhome\n\ntry:\n    from locale import getpreferredencoding\nexcept:\n    pass\n\nfrom gi.repository import GLib\nfrom gi.repository import IBus\n\nfrom gi.repository import Anthy\nNTH_UNCONVERTED_CANDIDATE = Anthy.NTH_UNCONVERTED_CANDIDATE\nNTH_KATAKANA_CANDIDATE = Anthy.NTH_KATAKANA_CANDIDATE\nNTH_HIRAGANA_CANDIDATE = Anthy.NTH_HIRAGANA_CANDIDATE\nNTH_HALFKANA_CANDIDATE = Anthy.NTH_HALFKANA_CANDIDATE\n\nimport _config as config\nfrom tables import *\nimport jastring\nfrom segment import unichar_half_to_full\n\nsys.path.append(path.join(config.PKGDATADIR, 'setup'))\nfrom anthyprefs import AnthyPrefs\n\n_  = lambda a : dgettext('ibus-anthy', a)\nN_ = lambda a : a\nUN = lambda a : unicode(a, 'utf-8')\n\nINPUT_MODE_HIRAGANA, \\\nINPUT_MODE_KATAKANA, \\\nINPUT_MODE_HALF_WIDTH_KATAKANA, \\\nINPUT_MODE_LATIN, \\\nINPUT_MODE_WIDE_LATIN = range(5)\n\nCONV_MODE_OFF, \\\nCONV_MODE_ANTHY, \\\nCONV_MODE_HIRAGANA, \\\nCONV_MODE_KATAKANA, \\\nCONV_MODE_HALF_WIDTH_KATAKANA, \\\nCONV_MODE_LATIN_0, \\\nCONV_MODE_LATIN_1, \\\nCONV_MODE_LATIN_2, \\\nCONV_MODE_LATIN_3, \\\nCONV_MODE_WIDE_LATIN_0, \\\nCONV_MODE_WIDE_LATIN_1, \\\nCONV_MODE_WIDE_LATIN_2, \\\nCONV_MODE_WIDE_LATIN_3, \\\nCONV_MODE_PREDICTION = range(14)\n\nSEGMENT_DEFAULT         = 0\nSEGMENT_SINGLE          = 1 << 0\nSEGMENT_IMMEDIATE       = 1 << 1\n\nCLIPBOARD_RECONVERT = range(1)\n\nLINK_DICT_EMBEDDED, \\\nLINK_DICT_SINGLE = range(2)\n\nIMPORTED_EMBEDDED_DICT_DIR = 'imported_words_default.d'\nIMPORTED_EMBEDDED_DICT_PREFIX = 'ibus__'\nIMPORTED_SINGLE_DICT_PREFIX = 'imported_words_ibus__'\n\nKP_Table = {}\nfor s in dir(IBus):\n    if s.startswith('KEY_KP_'):\n        v = IBus.keyval_from_name(s[7:])\n        if v:\n            KP_Table[IBus.keyval_from_name(s[4:])] = v\nfor k, v in zip(['KEY_KP_Add', 'KEY_KP_Decimal', 'KEY_KP_Divide', 'KEY_KP_Enter',\n                 'KEY_KP_Equal', 'KEY_KP_Multiply', 'KEY_KP_Separator',\n                 'KEY_KP_Space', 'KEY_KP_Subtract'],\n                ['KEY_plus', 'KEY_period', 'KEY_slash', 'KEY_Return',\n                 'KEY_equal', 'KEY_asterisk', 'KEY_comma',\n                 'KEY_space', 'KEY_minus']):\n    KP_Table[getattr(IBus, k)] = getattr(IBus, v)\n\nclass Engine(IBus.EngineSimple):\n    __input_mode = None\n    __typing_mode = None\n    __segment_mode = None\n    __dict_mode = None\n\n    __setup_pid = 0\n    __prefs = None\n    __keybind = {}\n    __thumb = None\n    __latin_with_shift = True\n\n    def __init__(self, bus, object_path):\n        super(Engine, self).__init__(connection=bus.get_connection(),\n                                     object_path=object_path)\n\n        # create anthy context\n        self.__context = Anthy.GContext()\n        self.__context.set_encoding(Anthy.UTF8_ENCODING)\n\n        # init state\n        self.__idle_id = 0\n        self.__prop_dict = {}\n        try:\n            self.__is_utf8 = (getpreferredencoding().lower() == 'utf-8')\n        except:\n            self.__is_utf8 = False\n        self.__ibus_version = 0.0\n\n#        self.__lookup_table = ibus.LookupTable.new(page_size=9,\n#                                                   cursor_pos=0,\n#                                                   cursor_visible=True,\n#                                                   round=True)\n        size = self.__prefs.get_value('common', 'page_size')\n        self.__lookup_table = IBus.LookupTable.new(page_size=size,\n                                                   cursor_pos=0,\n                                                   cursor_visible=True,\n                                                   round=True)\n        self.__prop_list = self.__init_props()\n\n        self.__init_signal()\n        # use reset to init values\n        self.__reset()\n\n        ibus_config = bus.get_config()\n        if ibus_config != None:\n            ibus_config.connect('value-changed',\n                                self.__config_value_changed_cb)\n\n    def __get_ibus_version(self):\n        if self.__ibus_version == 0.0:\n            self.__ibus_version = \\\n                IBus.MAJOR_VERSION + IBus.MINOR_VERSION / 1000.0 + \\\n                IBus.MICRO_VERSION / 1000000.0\n        return self.__ibus_version\n\n    # reset values of engine\n    def __reset(self):\n        self.__preedit_ja_string = jastring.JaString(Engine.__typing_mode,\n                                                     self.__latin_with_shift)\n        self.__convert_chars = u''\n        self.__cursor_pos = 0\n        self.__convert_mode = CONV_MODE_OFF\n        self.__segments = list()\n        self.__lookup_table.clear()\n        self.__lookup_table_visible = False\n        self._MM = 0\n        self._SS = 0\n        self._H = 0\n        self._RMM = 0\n        self._RSS = 0\n        if self.__idle_id != 0:\n            GLib.source_remove(self.__idle_id)\n            self.__idle_id = 0\n\n    def __init_props(self):\n        anthy_props = IBus.PropList()\n\n        self.__set_input_mode_props(anthy_props)\n        self.__set_typing_method_props(anthy_props)\n        self.__set_segment_mode_props(anthy_props)\n        self.__set_dict_mode_props(anthy_props)\n        self.__set_dict_config_props(anthy_props)\n\n        if not self.__prefs.get_value('common', 'show-preferences'):\n            return anthy_props\n\n        anthy_props.append(IBus.Property(key=u'setup',\n                                         label=IBus.Text.new_from_string(_(\"Preferences - Anthy\")),\n                                         icon=config.ICON_PREFERENCE,\n                                         tooltip=IBus.Text.new_from_string(_(\"Configure Anthy\")),\n                                         sensitive=True,\n                                         visible=True))\n\n        return anthy_props\n\n    def __init_signal(self):\n        signal.signal(signal.SIGHUP, self.__signal_cb)\n        signal.signal(signal.SIGINT, self.__signal_cb)\n        signal.signal(signal.SIGQUIT, self.__signal_cb)\n        signal.signal(signal.SIGABRT, self.__signal_cb)\n        signal.signal(signal.SIGTERM, self.__signal_cb)\n\n    def __signal_cb(self, signum, object):\n        self.__remove_dict_files()\n        signal.signal(signum, signal.SIG_DFL)\n        os.kill(os.getpid(), signum)\n\n    def __set_input_mode_props(self, anthy_props):\n        # The class method is kept even if the engine is switched.\n        if Engine.__input_mode == None:\n            # The config value is readonly for initial engine and\n            # the engine keeps the class method in the memory.\n            Engine.__input_mode = INPUT_MODE_HIRAGANA\n            Engine.__input_mode = self.__prefs.get_value('common',\n                                                         'input_mode')\n\n        if not self.__prefs.get_value('common', 'show-input-mode'):\n            return\n\n        # init input mode properties\n        symbol = '\u3042'\n        '''\n        Need to split _() by line for intltool to detect them.\n        '''\n        # Translators: Specify the order of %s with your translation.\n        # It will be \"Input Mode (A)\" for example.\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Input mode\"), 'symbol' : symbol }\n        input_mode_prop = IBus.Property(key=u'InputMode',\n                                        prop_type=IBus.PropType.MENU,\n                                        label=IBus.Text.new_from_string(label),\n                                        symbol=IBus.Text.new_from_string(symbol),\n                                        icon='',\n                                        tooltip=IBus.Text.new_from_string(_(\"Switch input mode\")),\n                                        sensitive=True,\n                                        visible=True,\n                                        state=IBus.PropState.UNCHECKED,\n                                        sub_props=None)\n        self.__prop_dict[u'InputMode'] = input_mode_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'InputMode.Hiragana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Hiragana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.Katakana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Katakana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.HalfWidthKatakana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Halfwidth Katakana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.Latin',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Latin\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.WideLatin',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Wide Latin\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n\n        props.get(Engine.__input_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        input_mode_prop.set_sub_props(props)\n        anthy_props.append(input_mode_prop)\n\n        mode = Engine.__input_mode\n        mode = 'InputMode.' + ['Hiragana', 'Katakana', 'HalfWidthKatakana',\n                               'Latin', 'WideLatin'][mode]\n        self.__input_mode_activate(mode, IBus.PropState.CHECKED)\n\n    def __set_typing_method_props(self, anthy_props):\n        if Engine.__typing_mode == None:\n            Engine.__typing_mode = jastring.TYPING_MODE_ROMAJI\n            Engine.__typing_mode = self.__prefs.get_value('common',\n                                                          'typing_method')\n\n        if not self.__prefs.get_value('common', 'show-typing-method'):\n            return\n\n        # typing input mode properties\n        symbol = 'R'\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Typing method\"), 'symbol' : symbol }\n        typing_mode_prop = IBus.Property(key=u'TypingMode',\n                                         prop_type=IBus.PropType.MENU,\n                                         label=IBus.Text.new_from_string(label),\n                                         symbol=IBus.Text.new_from_string(symbol),\n                                         icon='',\n                                         tooltip=IBus.Text.new_from_string(_(\"Switch typing method\")),\n                                         sensitive=True,\n                                         visible=True,\n                                         state=IBus.PropState.UNCHECKED,\n                                         sub_props=None)\n        self.__prop_dict[u'TypingMode'] = typing_mode_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'TypingMode.Romaji',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Romaji\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'TypingMode.Kana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Kana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'TypingMode.ThumbShift',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Thumb shift\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.get(Engine.__typing_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        typing_mode_prop.set_sub_props(props)\n        anthy_props.append(typing_mode_prop)\n\n        mode = Engine.__typing_mode\n        mode = 'TypingMode.' + ['Romaji', 'Kana', 'ThumbShift'][mode]\n        self.__typing_mode_activate(mode, IBus.PropState.CHECKED)\n\n    def __set_segment_mode_props(self, anthy_props):\n        if Engine.__segment_mode == None:\n            Engine.__segment_mode = SEGMENT_DEFAULT\n            Engine.__segment_mode = self.__prefs.get_value('common',\n                                                           'conversion_segment_mode')\n\n        if not self.__prefs.get_value('common', 'show-segment-mode'):\n            return\n\n        symbol = '\u9023'\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Segment mode\"), 'symbol' : symbol }\n        segment_mode_prop = IBus.Property(key=u'SegmentMode',\n                                          prop_type=IBus.PropType.MENU,\n                                          label=IBus.Text.new_from_string(label),\n                                          symbol=IBus.Text.new_from_string(symbol),\n                                          icon=None,\n                                          tooltip=IBus.Text.new_from_string(_(\"Switch conversion mode\")),\n                                          sensitive=True,\n                                          visible=True,\n                                          state=IBus.PropState.UNCHECKED,\n                                          sub_props=None)\n        self.__prop_dict[u'SegmentMode'] = segment_mode_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'SegmentMode.Multi',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Multiple segment\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'SegmentMode.Single',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Single segment\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'SegmentMode.ImmediateMulti',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Immediate conversion (multiple segment)\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'SegmentMode.ImmediateSingle',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Immediate conversion (single segment)\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.get(Engine.__segment_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        segment_mode_prop.set_sub_props(props)\n        anthy_props.append(segment_mode_prop)\n\n        mode = Engine.__segment_mode\n        mode = 'SegmentMode.' + ['Multi', 'Single',\n                                 'ImmediateMulti', 'ImmediateSingle'][mode]\n        self.__segment_mode_activate(mode, IBus.PropState.CHECKED)\n\n    def __set_dict_mode_props(self, anthy_props, update_prop=False):\n        if Engine.__dict_mode == None:\n            Engine.__dict_mode = 0\n\n        if not self.__prefs.get_value('common', 'show-dict-mode'):\n            return\n\n        short_label = self.__prefs.get_value('dict/file/embedded',\n                                             'short_label')\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Dictionary mode\"), 'symbol' : short_label }\n        dict_mode_prop = IBus.Property(key=u'DictMode',\n                                       prop_type=IBus.PropType.MENU,\n                                       label=IBus.Text.new_from_string(label),\n                                       symbol=IBus.Text.new_from_string(short_label),\n                                       icon=None,\n                                       tooltip=IBus.Text.new_from_string(_(\"Switch dictionary\")),\n                                       sensitive=True,\n                                       visible=True,\n                                       state=IBus.PropState.UNCHECKED,\n                                       sub_props=None)\n        self.__prop_dict[u'DictMode'] = dict_mode_prop\n        props = IBus.PropList()\n\n        long_label = self.__prefs.get_value('dict/file/embedded',\n                                            'long_label')\n        props.append(IBus.Property(key=u'DictMode.embedded',\n                                   prop_type=IBus.PropType.RADIO,\n                                   # if long_label is UTF-8\n                                   label=IBus.Text.new_from_string(UN(_(long_label))),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        for file in self.__prefs.get_value('dict', 'files'):\n            if not self.__link_dict_file(file):\n                continue\n            id = self.__get_dict_id_from_file(file)\n            section = 'dict/file/' + id\n            if not self.__prefs.get_value(section, 'single'):\n                continue\n            key = 'DictMode.' + id\n            long_label = self.__prefs.get_value(section, 'long_label')\n\n            # ibus-config 'value-changed' signal updated dict/files but\n            # not dict/file/new yet.\n            if long_label == None:\n                continue\n\n            # if long_label is UTF-8\n            if 'is_system' in self.__prefs.keys(section) and \\\n               self.__prefs.get_value(section, 'is_system'):\n                uni_long_label = UN(_(long_label))\n            else:\n                uni_long_label = UN(long_label)\n            props.append(IBus.Property(key=UN(key),\n                                       prop_type=IBus.PropType.RADIO,\n                                       label=IBus.Text.new_from_string(uni_long_label),\n                                       icon=None,\n                                       tooltip=None,\n                                       sensitive=True,\n                                       visible=True,\n                                       state=IBus.PropState.UNCHECKED,\n                                       sub_props=None))\n\n        props.get(Engine.__dict_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        dict_mode_prop.set_sub_props(props)\n\n        if update_prop:\n            # focus-in event will call register_properties().\n            # Need to switch another IME to update menus on GtkStatusIcon?\n            anthy_props.update_property(dict_mode_prop)\n        else:\n            anthy_props.append(dict_mode_prop)\n\n        prop_name = self.__dict_mode_get_prop_name(Engine.__dict_mode)\n        if prop_name == None:\n            return\n        self.__dict_mode_activate(prop_name,\n                                  IBus.PropState.CHECKED)\n\n    def __set_dict_config_props(self, anthy_props):\n        if not self.__prefs.get_value('common', 'show-dict-config'):\n            return\n\n        admin_command = self.__prefs.get_value('common', 'dict_admin_command')\n        icon_path = self.__prefs.get_value('common', 'dict_config_icon')\n\n        if not path.exists(admin_command[0]):\n            return\n        label = _(\"Dictionary - Anthy\")\n        # if icon_path is UTF-8\n        if icon_path and path.exists(icon_path):\n            icon = UN(icon_path)\n        else:\n            # Translators: \"Dic\" means 'dictionary', One kanji may be good.\n            label = _(\"Dic\")\n            icon = u''\n\n        dict_prop = IBus.Property(key=u'setup-dict-kasumi',\n                                  prop_type=IBus.PropType.MENU,\n                                  label=IBus.Text.new_from_string(label),\n                                  icon=icon,\n                                  tooltip=IBus.Text.new_from_string(_(\"Configure dictionaries\")),\n                                  sensitive=True,\n                                  visible=True,\n                                  state=IBus.PropState.UNCHECKED,\n                                  sub_props=None)\n        self.__prop_dict[u'setup-dict-kasumi'] = dict_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'setup-dict-kasumi-admin',\n                                   prop_type=IBus.PropType.NORMAL,\n                                   label=IBus.Text.new_from_string(_(\"Edit dictionaries\")),\n                                   icon=icon,\n                                   tooltip=IBus.Text.new_from_string(_(\"Launch the dictionary tool\")),\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'setup-dict-kasumi-word',\n                                   prop_type=IBus.PropType.NORMAL,\n                                   label=IBus.Text.new_from_string(_(\"Add words\")),\n                                   icon=icon,\n                                   tooltip=IBus.Text.new_from_string(_(\"Add words to the dictionary\")),\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        dict_prop.set_sub_props(props)\n        anthy_props.append(dict_prop)\n\n    def __get_clipboard(self, clipboard, text, data):\n        clipboard_text = clipboard.wait_for_text ()\n\n        if data == CLIPBOARD_RECONVERT:\n            self.__update_reconvert(clipboard_text)\n\n        return clipboard_text\n\n    def __get_single_dict_files(self):\n        files = self.__prefs.get_value('dict', 'files')\n        single_files = []\n        for file in files:\n            id = self.__get_dict_id_from_file(file)\n            section = 'dict/file/' + id\n            if self.__prefs.get_value(section, 'single'):\n                single_files.append(file)\n        return single_files\n\n    def __remove_dict_files(self):\n        for file in self.__prefs.get_value('dict', 'files'):\n            self.__remove_dict_file(file)\n\n    def update_preedit(self, string, attrs, cursor_pos, visible):\n        text = IBus.Text.new_from_string(string)\n        i = 0\n        while attrs.get(i) != None:\n            attr = attrs.get(i)\n            text.append_attribute(attr.get_attr_type(),\n                                  attr.get_value(),\n                                  attr.get_start_index(),\n                                  attr.get_end_index())\n            i += 1\n        mode = self.__prefs.get_value('common', 'behavior_on_focus_out')\n        if self.__get_ibus_version() >= 1.003 and mode == 1:\n            self.update_preedit_text_with_mode(text,\n                                               cursor_pos, visible,\n                                               IBus.PreeditFocusMode.COMMIT)\n        else:\n            self.update_preedit_text(text,\n                                     cursor_pos, visible)\n\n    def update_aux_string(self, string, attrs, visible):\n        text = IBus.Text.new_from_string(string)\n        i = 0\n        while attrs.get(i) != None:\n            attr = attrs.get(i)\n            text.append_attribute(attr.get_attr_type(),\n                                  attr.get_value(),\n                                  attr.get_start_index(),\n                                  attr.get_end_index())\n            i += 1\n        self.update_auxiliary_text(text, visible)\n\n    def do_page_up(self):\n        # only process cursor down in convert mode\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return False\n\n        if not self.__lookup_table.page_up():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_page_down(self):\n        # only process cursor down in convert mode\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return False\n\n        if not self.__lookup_table.page_down():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_cursor_up(self):\n        # only process cursor down in convert mode\n        # if self.__convert_mode != CONV_MODE_ANTHY:\n        if self.__convert_mode != CONV_MODE_ANTHY and self.__convert_mode != CONV_MODE_PREDICTION:\n            return False\n\n        if not self.__lookup_table.cursor_up():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_cursor_down(self):\n        # only process cursor down in convert mode\n        # if self.__convert_mode != CONV_MODE_ANTHY:\n        if self.__convert_mode != CONV_MODE_ANTHY and self.__convert_mode != CONV_MODE_PREDICTION:\n            return False\n\n        if not self.__lookup_table.cursor_down():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_candidate_clicked(self, index, button, state):\n        if index == 9:\n            keyval = IBus.KEY_0\n        else:\n            keyval = IBus.KEY_1 + index\n        self.__on_key_number(keyval)\n\n    def __commit_string(self, text):\n        self.__reset()\n        self.commit_text(IBus.Text.new_from_string(text))\n        self.__invalidate()\n\n    def __shrink_segment(self, relative_size):\n        self.__context.resize_segment(self.__cursor_pos, relative_size)\n        nr_segments = self.__context.get_nr_segments()\n        del self.__segments[self.__cursor_pos:]\n        for i in xrange(self.__cursor_pos, nr_segments):\n            buf = self.__context.get_segment(i, 0)\n            text = UN(buf)\n            self.__segments.append((0, text))\n        self.__lookup_table_visible = False\n        self.__fill_lookup_table()\n        self.__invalidate()\n        return True\n\n    def do_process_key_event(self, keyval, keycode, state):\n        try:\n            return self.__process_key_event_internal2(keyval, keycode, state)\n        except:\n            import traceback\n            traceback.print_exc()\n            return False\n\n    def do_property_activate(self, prop_name, state):\n\n        if state == IBus.PropState.CHECKED:\n            if prop_name == None:\n                return\n            elif prop_name.startswith(u'InputMode.'):\n                self.__input_mode_activate(prop_name, state)\n                return\n            elif prop_name.startswith(u'TypingMode.'):\n                self.__typing_mode_activate(prop_name, state)\n                return\n            elif prop_name.startswith(u'SegmentMode.'):\n                self.__segment_mode_activate(prop_name, state)\n                return\n            elif prop_name.startswith(u'DictMode.'):\n                self.__dict_mode_activate(prop_name, state)\n                return\n        else:\n            if prop_name == 'setup':\n                self.__start_setup()\n            elif prop_name == 'setup-dict-kasumi-admin':\n                self.__start_dict_admin()\n            elif prop_name == 'setup-dict-kasumi-word':\n                self.__start_add_word()\n            else:\n                self.__prop_dict[prop_name].set_state(state)\n                if prop_name == 'DictMode':\n                    sub_name = self.__dict_mode_get_prop_name(self.__dict_mode)\n                    if sub_name == None:\n                        return\n                    self.__dict_mode_activate(sub_name,\n                                              IBus.PropState.CHECKED)\n\n    def __input_mode_activate(self, prop_name, state):\n        input_modes = {\n            u'InputMode.Hiragana' : (INPUT_MODE_HIRAGANA, '\u3042'),\n            u'InputMode.Katakana' : (INPUT_MODE_KATAKANA, '\u30a2'),\n            u'InputMode.HalfWidthKatakana' : (INPUT_MODE_HALF_WIDTH_KATAKANA, '_\uff71'),\n            u'InputMode.Latin' : (INPUT_MODE_LATIN, '_A'),\n            u'InputMode.WideLatin' : (INPUT_MODE_WIDE_LATIN, '\uff21'),\n        }\n\n        if prop_name not in input_modes:\n            print >> sys.stderr, 'Unknown prop_name = %s' % prop_name\n            return\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n\n        mode, symbol = input_modes[prop_name]\n\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Input mode\"), 'symbol' : symbol }\n        Engine.__input_mode = mode\n        prop = self.__prop_dict[u'InputMode']\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__reset()\n        self.__invalidate()\n\n    def __typing_mode_activate(self, prop_name, state):\n        typing_modes = {\n            u'TypingMode.Romaji' : (jastring.TYPING_MODE_ROMAJI, 'R'),\n            u'TypingMode.Kana' : (jastring.TYPING_MODE_KANA, '\u304b'),\n            u'TypingMode.ThumbShift' : (jastring.TYPING_MODE_THUMB_SHIFT, '\u89aa'),\n        }\n\n        if prop_name not in typing_modes:\n            print >> sys.stderr, 'Unknown prop_name = %s' % prop_name\n            return\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n        if prop_name == u'TypingMode.ThumbShift':\n            self._reset_thumb()\n\n        mode, symbol = typing_modes[prop_name]\n\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Typing method\"), 'symbol' : symbol }\n        Engine.__typing_mode = mode\n        prop = self.__prop_dict[u'TypingMode']\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__reset()\n        self.__invalidate()\n\n    def __refresh_typing_mode_property(self):\n        if u'TypingMode' not in self.__prop_dict:\n            return\n\n        prop = self.__prop_dict[u'TypingMode']\n        modes = {\n            jastring.TYPING_MODE_ROMAJI : (u'TypingMode.Romaji', 'R'),\n            jastring.TYPING_MODE_KANA : (u'TypingMode.Kana', '\u304b'),\n            jastring.TYPING_MODE_THUMB_SHIFT : (u'TypingMode.ThumbShift', '\u89aa'),\n        }\n        prop_name, symbol = modes.get(Engine.__typing_mode, (None, None))\n        if prop_name == None or symbol == None:\n            return\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Typing method\"), 'symbol' : symbol }\n        _prop = self.__prop_dict[prop_name]\n        _prop.set_state(IBus.PropState.CHECKED)\n        self.update_property(_prop)\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n    def __segment_mode_activate(self, prop_name, state):\n        segment_modes = {\n            u'SegmentMode.Multi' : (SEGMENT_DEFAULT, '\u9023'),\n            u'SegmentMode.Single' : (SEGMENT_SINGLE, '\u5358'),\n            u'SegmentMode.ImmediateMulti' : (SEGMENT_IMMEDIATE, '\u9010|\u9023'),\n            u'SegmentMode.ImmediateSingle' :\n                (SEGMENT_IMMEDIATE | SEGMENT_SINGLE, '\u9010|\u5358'),\n        }\n\n        if prop_name not in segment_modes:\n            print >> sys.stderr, 'Unknown prop_name = %s' % prop_name\n            return\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n\n        mode, symbol = segment_modes[prop_name]\n\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Segment mode\"), 'symbol' : symbol }\n        Engine.__segment_mode = mode\n        prop = self.__prop_dict[u'SegmentMode']\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__reset()\n        self.__invalidate()\n\n    def __dict_mode_get_prop_name(self, mode):\n        if mode == 0:\n            id = 'embedded'\n        else:\n            single_files = self.__get_single_dict_files()\n            file = single_files[mode - 1]\n            id = self.__get_dict_id_from_file(file)\n        return 'DictMode.' + id\n\n    def __dict_mode_activate(self, prop_name, state):\n        if prop_name not in self.__prop_dict.keys():\n            # The prop_name is added. Need to restart.\n            return\n        i = prop_name.find('.')\n        if i < 0:\n            return\n        # The id is already quoted.\n        id = prop_name[i + 1:]\n\n        file = None\n        single_files = self.__get_single_dict_files()\n\n        if id == 'embedded':\n            pass\n        else:\n            found = False\n            for file in single_files:\n                if id == self.__get_quoted_id(file):\n                    found = True\n                    break\n            if found == False:\n                return\n\n        if id == 'embedded':\n            dict_name = 'default'\n            Engine.__dict_mode = 0\n        else:\n            if file not in single_files:\n                print >> sys.stderr, \"Index error \", file, single_files\n                return\n            dict_name = 'ibus__' + id\n            Engine.__dict_mode = single_files.index(file) + 1\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n        self.__context.init_personality()\n        # dict_name is unicode but the argument is str.\n        self.__context.do_set_personality(str(dict_name))\n\n        prop = self.__prop_dict[u'DictMode']\n        section = 'dict/file/' + id\n        symbol = self.__prefs.get_value(section, 'short_label')\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Dictionary mode\"), 'symbol' : symbol }\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n    def __argb(self, a, r, g, b):\n        return ((a & 0xff)<<24) + ((r & 0xff) << 16) + ((g & 0xff) << 8) + (b & 0xff)\n\n    def __rgb(self, r, g, b):\n        return self.__argb(255, r, g, b)\n\n    def do_focus_in(self):\n        self.register_properties(self.__prop_list)\n        self.__refresh_typing_mode_property()\n        mode = self.__prefs.get_value('common', 'behavior_on_focus_out')\n        if mode == 2:\n            self.__update_input_chars()\n#        self.__reset()\n#        self.__invalidate()\n        size = self.__prefs.get_value('common', 'page_size')\n        if size != self.__lookup_table.get_page_size():\n            self.__lookup_table.set_page_size(size)\n\n    def do_focus_out(self):\n        mode = self.__prefs.get_value('common', 'behavior_on_focus_out')\n        if mode == 0 or mode == 1:\n            self.__reset()\n            self.__invalidate()\n\n    def do_disable(self):\n        self.__reset()\n        self.__invalidate()\n\n    def do_reset(self):\n        self.__reset()\n        self.__invalidate()\n\n    def do_destroy(self):\n        if self.__idle_id != 0:\n            GLib.source_remove(self.__idle_id)\n            self.__idle_id = 0\n        self.__remove_dict_files()\n        # It seems the parent do_destroy and destroy are different.\n        # The parent do_destroy calls self destroy infinitely.\n        super(Engine,self).destroy()\n\n    def __join_all_segments(self):\n        while True:\n            nr_segments = self.__context.get_nr_segments()\n            seg = nr_segments - self.__cursor_pos\n\n            if seg > 1:\n                self.__context.resize_segment(self.__cursor_pos, 1)\n            else:\n                break\n\n    def __normalize_preedit(self, preedit):\n        if not self.__is_utf8:\n            return preedit\n        for key in romaji_normalize_rule.keys():\n            if preedit.find(key) >= 0:\n                for value in romaji_normalize_rule[key]:\n                    preedit = preedit.replace(key, value)\n        return preedit\n\n    # begine convert\n    def __begin_anthy_convert(self):\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            self.__end_anthy_convert()\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return\n        self.__convert_mode = CONV_MODE_ANTHY\n\n#        text, cursor = self.__preedit_ja_string.get_hiragana()\n        text, cursor = self.__preedit_ja_string.get_hiragana(True)\n\n        text = self.__normalize_preedit(text)\n        self.__context.set_string(text.encode('utf8'))\n        if Engine.__segment_mode & SEGMENT_SINGLE:\n            self.__join_all_segments()\n        nr_segments = self.__context.get_nr_segments()\n\n        for i in xrange(0, nr_segments):\n            buf = self.__context.get_segment(i, 0)\n            text = UN(buf)\n            self.__segments.append((0, text))\n\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            self.__cursor_pos = nr_segments - 1\n        else:\n            self.__cursor_pos = 0\n        self.__fill_lookup_table()\n        self.__lookup_table_visible = False\n\n    def __end_anthy_convert(self):\n        if self.__convert_mode == CONV_MODE_OFF:\n            return\n\n        self.__convert_mode = CONV_MODE_OFF\n        self.__convert_chars = u''\n        self.__segments = list()\n        self.__cursor_pos = 0\n        self.__lookup_table.clear()\n        self.__lookup_table_visible = False\n\n    def __end_convert(self):\n        self.__end_anthy_convert()\n\n    # test case 'verudhi' can show U+3046 + U+309B and U+3094\n    def __candidate_cb(self, candidate):\n        if not self.__is_utf8:\n            return\n        for key in romaji_utf8_rule.keys():\n            if candidate.find(key) >= 0:\n                for value in romaji_utf8_rule[key]:\n                    candidate = candidate.replace(key, value)\n                    self.__lookup_table.append_candidate(IBus.Text.new_from_string(candidate))\n\n    def __fill_lookup_table(self):\n        if self.__convert_mode == CONV_MODE_PREDICTION:\n            nr_predictions = self.__context.get_nr_predictions()\n\n            # fill lookup_table\n            self.__lookup_table.clear()\n            for i in xrange(0, seg_stat.nr_predictions):\n                buf = self.__context.get_prediction(i)\n                candidate = UN(buf)\n                self.__lookup_table.append_candidate(IBus.Text.new_from_string(candidate))\n                self.__candidate_cb(candidate)\n            return\n\n        # get segment stat\n        nr_candidates = self.__context.get_nr_candidates(self.__cursor_pos)\n\n        # fill lookup_table\n        self.__lookup_table.clear()\n        for i in xrange(0, nr_candidates):\n            buf = self.__context.get_segment(self.__cursor_pos, i)\n            candidate = UN(buf)\n            self.__lookup_table.append_candidate(IBus.Text.new_from_string(candidate))\n            self.__candidate_cb(candidate)\n\n\n    def __invalidate(self):\n        if self.__idle_id != 0:\n            return\n        self.__idle_id = GLib.idle_add(self.__update,\n                                       priority = GLib.PRIORITY_LOW)\n\n#    def __get_preedit(self):\n    def __get_preedit(self, commit=False):\n        if Engine.__input_mode == INPUT_MODE_HIRAGANA:\n#            text, cursor = self.__preedit_ja_string.get_hiragana()\n            text, cursor = self.__preedit_ja_string.get_hiragana(commit)\n        elif Engine.__input_mode == INPUT_MODE_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_katakana()\n            text, cursor = self.__preedit_ja_string.get_katakana(commit)\n        elif Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_half_width_katakana()\n            text, cursor = self.__preedit_ja_string.get_half_width_katakana(commit)\n        else:\n            text, cursor = u'', 0\n        return text, cursor\n\n    def __update_input_chars(self):\n        text, cursor = self.__get_preedit()\n        attrs = IBus.AttrList()\n        attrs.append(IBus.attr_underline_new(\n            IBus.AttrUnderline.SINGLE, 0,\n            len(text)))\n\n        self.update_preedit(text,\n            attrs, cursor, not self.__preedit_ja_string.is_empty())\n        self.update_aux_string(u'', IBus.AttrList(), False)\n        self.update_lookup_table(self.__lookup_table,\n            self.__lookup_table_visible)\n\n    def __update_convert_chars(self):\n#        if self.__convert_mode == CONV_MODE_ANTHY:\n        if self.__convert_mode == CONV_MODE_ANTHY or self.__convert_mode == CONV_MODE_PREDICTION:\n            self.__update_anthy_convert_chars()\n            return\n        if self.__convert_mode == CONV_MODE_HIRAGANA:\n#            text, cursor = self.__preedit_ja_string.get_hiragana()\n            text, cursor = self.__preedit_ja_string.get_hiragana(True)\n        elif self.__convert_mode == CONV_MODE_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_katakana()\n            text, cursor = self.__preedit_ja_string.get_katakana(True)\n        elif self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_half_width_katakana()\n            text, cursor = self.__preedit_ja_string.get_half_width_katakana(True)\n        elif self.__convert_mode == CONV_MODE_LATIN_0:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            if text == text.lower():\n                self.__convert_mode = CONV_MODE_LATIN_1\n        elif self.__convert_mode == CONV_MODE_LATIN_1:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            text = text.lower()\n        elif self.__convert_mode == CONV_MODE_LATIN_2:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            text = text.upper()\n        elif self.__convert_mode == CONV_MODE_LATIN_3:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            text = text.capitalize()\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_0:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            if text == text.lower():\n                self.__convert_mode = CONV_MODE_WIDE_LATIN_1\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_1:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            text = text.lower()\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_2:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            text = text.upper()\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_3:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            text = text.capitalize()\n        self.__convert_chars = text\n        attrs = IBus.AttrList()\n        attrs.append(IBus.attr_underline_new(\n            IBus.AttrUnderline.SINGLE, 0, len(text)))\n        attrs.append(IBus.attr_background_new(self.__rgb(200, 200, 240),\n            0, len(text)))\n        attrs.append(IBus.attr_foreground_new(self.__rgb(0, 0, 0),\n            0, len(text)))\n        self.update_preedit(text, attrs, len(text), True)\n\n        self.update_aux_string(u'',\n            IBus.AttrList(), self.__lookup_table_visible)\n        self.update_lookup_table(self.__lookup_table,\n            self.__lookup_table_visible)\n\n    def __update_anthy_convert_chars(self):\n        self.__convert_chars = u''\n        pos = 0\n        for i, (seg_index, text) in enumerate(self.__segments):\n            self.__convert_chars += text\n            if i < self.__cursor_pos:\n                pos += len(text)\n        attrs = IBus.AttrList()\n        attrs.append(IBus.attr_underline_new(\n            IBus.AttrUnderline.SINGLE, 0, len(self.__convert_chars)))\n        attrs.append(IBus.attr_background_new(self.__rgb(200, 200, 240),\n                pos, pos + len(self.__segments[self.__cursor_pos][1])))\n        attrs.append(IBus.attr_foreground_new(self.__rgb(0, 0, 0),\n                pos, pos + len(self.__segments[self.__cursor_pos][1])))\n        self.update_preedit(self.__convert_chars, attrs, pos, True)\n        aux_string = u'( %d / %d )' % (self.__lookup_table.get_cursor_pos() + 1, self.__lookup_table.get_number_of_candidates())\n        self.update_aux_string(aux_string,\n            IBus.AttrList(), self.__lookup_table_visible)\n        self.update_lookup_table(self.__lookup_table,\n            self.__lookup_table_visible)\n\n    def __update(self):\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__update_input_chars()\n        else:\n            self.__update_convert_chars()\n        self.__idle_id = 0\n\n    def __on_key_return(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n#            text, cursor = self.__get_preedit()\n            text, cursor = self.__get_preedit(True)\n            self.__commit_string(text)\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            for i, (seg_index, text) in enumerate(self.__segments):\n                self.__context.commit_segment(i, seg_index)\n            self.__commit_string(self.__convert_chars)\n        elif self.__convert_mode == CONV_MODE_PREDICTION:\n            self.__context.commit_prediction(self.__segments[0][0])\n            self.__commit_string(self.__convert_chars)\n        else:\n            self.__commit_string(self.__convert_chars)\n\n        return True\n\n    def __on_key_escape(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        self.__reset()\n        self.__invalidate()\n        return True\n\n    def __on_key_back_space(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode != CONV_MODE_OFF:\n            if self.__lookup_table_visible:\n                if self.__lookup_table.get_number_of_candidates() > 0:\n                    self.__lookup_table.set_cursor_pos(0)\n                candidate = UN(self.__lookup_table.get_candidate(0).get_text())\n                self.__segments[self.__cursor_pos] = 0, candidate\n                self.__lookup_table_visible = False\n            elif self.__segments[self.__cursor_pos][0] != \\\n                    NTH_UNCONVERTED_CANDIDATE:\n                buf = self.__context.get_segment(self.__cursor_pos,\n                                                 NTH_UNCONVERTED_CANDIDATE)\n                self.__segments[self.__cursor_pos] = \\\n                    NTH_UNCONVERTED_CANDIDATE, UN(buf)\n            #elif self._chk_mode('25'):\n                '''\n                # FIXME: Delete the last char in the active segment.\n                #\n                # If we are able to delete a char in the active segment,\n                # we also should be able to add a char in the active segment.\n                # Currently plain preedit, no segment mode, i.e.\n                # using self.__preedit_ja_string, can delete or add a char\n                # but anthy active segoment mode, i.e.\n                # using self.__segments, can not delete or add a char.\n                # Deleting a char could be easy here but adding a char is\n                # difficult because we need to update both self.__segments\n                # and self.__preedit_ja_string but self.__preedit_ja_string\n                # has no segment. To convert self.__segments to\n                # self.__preedit_ja_string, we may use the reconvert mode\n                # but no idea to convert keyvals to hiragana\n                # in self__on_key_common() with multiple key typings.\n\n                # Delete a char in the active segment\n                all_text = u''\n                nr_segments = self.__context.get_nr_segments()\n                for i in xrange(0, nr_segments):\n                    buf = self.__context.get_segment(i,\n                                                     NTH_UNCONVERTED_CANDIDATE)\n                    text = UN(buf)\n                    if i == self.__cursor_pos and len(text) > 0:\n                        text = text[:len(text) - 1]\n                    all_text += text\n\n                if all_text == u'':\n                    return\n\n                # Set self.__preedit_ja_string by anthy context.\n                self.__preedit_ja_string = jastring.JaString(Engine.__typing_mode,\n                                                             self.__latin_with_shift)\n                self.__convert_chars = self.__normalize_preedit(all_text)\n                for i in xrange(0, len(self.__convert_chars)):\n                    keyval = self.__convert_chars[i]\n                    self.__preedit_ja_string.insert(unichr(ord (keyval)))\n                self.__context.set_string(self.__convert_chars.encode('utf8'))\n\n                # Set self.__segments by anty context\n                # for editable self.__segments,\n                # save NTH_UNCONVERTED_CANDIDATE\n                nr_segments = self.__context.get_nr_segments()\n                if self.__cursor_pos >= nr_segments and \\\n                   nr_segments > 0:\n                    self.__cursor_pos = nr_segments - 1\n                for i in xrange(self.__cursor_pos, nr_segments):\n                    if i == self.__cursor_pos:\n                        index = NTH_UNCONVERTED_CANDIDATE\n                    else:\n                        index = 0\n                    buf = self.__context.get_segment(i,\n                                                     index)\n                    text = UN(buf)\n                    self.__segments[i] = index, text\n\n                # Update self.__lookup_table\n                self.__fill_lookup_table()\n                '''\n            else:\n                self.__end_convert()\n        else:\n            self.__preedit_ja_string.remove_before()\n\n        self.__invalidate()\n        return True\n\n    def __on_key_delete(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode != CONV_MODE_OFF:\n            self.__end_convert()\n        else:\n            self.__preedit_ja_string.remove_after()\n\n        self.__invalidate()\n        return True\n\n    '''def __on_key_hiragana_katakana(self):\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__end_anthy_convert()\n\n        if Engine.__input_mode >= INPUT_MODE_HIRAGANA and \\\n           Engine.__input_mode < INPUT_MODE_HALF_WIDTH_KATAKANA:\n            Engine.__input_mode += 1\n        else:\n            Engine.__input_mode = INPUT_MODE_HIRAGANA\n\n        modes = { INPUT_MODE_HIRAGANA: '\u3042',\n                  INPUT_MODE_KATAKANA: '\u30a2',\n                  INPUT_MODE_HALF_WIDTH_KATAKANA: '_\uff71' }\n\n        prop = self.__prop_dict[u'InputMode']\n        label = modes[Engine.__input_mode]\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__invalidate()\n        return True'''\n\n    '''def __on_key_muhenka(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__end_anthy_convert()\n\n        new_mode = CONV_MODE_HIRAGANA\n        if self.__convert_mode < CONV_MODE_WIDE_LATIN_3 and \\\n           self.__convert_mode >= CONV_MODE_HIRAGANA :\n            self.__convert_mode += 1\n        else:\n            self.__convert_mode = CONV_MODE_HIRAGANA\n\n        self.__invalidate()\n\n        return True'''\n\n    '''def __on_key_henkan(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            self.__begin_anthy_convert()\n            self.__invalidate()\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            self.__lookup_table_visible = True\n            self.do_cursor_down()\n        return True'''\n\n    '''def __on_key_space(self, wide=False):\n        if Engine.__input_mode == INPUT_MODE_WIDE_LATIN or wide:\n            # Input Wide space U+3000\n            wide_char = symbol_rule[unichr(IBus.KEY_space)]\n            self.__commit_string(wide_char)\n            return True\n\n        if self.__preedit_ja_string.is_empty():\n            if Engine.__input_mode in (INPUT_MODE_HIRAGANA, INPUT_MODE_KATAKANA):\n                # Input Wide space U+3000\n                wide_char = symbol_rule[unichr(IBus.KEY_space)]\n                self.__commit_string(wide_char)\n                return True\n            else:\n                # Input Half space U+0020\n                self.__commit_string(unichr(IBus.KEY_space))\n                return True\n\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            self.__begin_anthy_convert()\n            self.__invalidate()\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            self.__lookup_table_visible = True\n            self.do_cursor_down()\n        return True'''\n\n    def __on_key_up(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        self.__lookup_table_visible = True\n        self.do_cursor_up()\n        return True\n\n    def __on_key_down(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        self.__lookup_table_visible = True\n        self.do_cursor_down()\n        return True\n\n    def __on_key_page_up(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        if self.__lookup_table_visible == True:\n            self.do_page_up()\n        return True\n\n    def __on_key_page_down(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        if self.__lookup_table_visible == True:\n            self.do_page_down()\n        return True\n\n    '''def __on_key_left(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__preedit_ja_string.move_cursor(-1)\n            self.__invalidate()\n            return True\n\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return True\n\n        if self.__cursor_pos == 0:\n            return True\n        self.__cursor_pos -= 1\n        self.__lookup_table_visible = False\n        self.__fill_lookup_table()\n        self.__invalidate()\n        return True'''\n\n    def __on_key_right(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__preedit_ja_string.move_cursor(1)\n            self.__invalidate()\n            return True\n\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return True\n\n        if self.__cursor_pos + 1 >= len(self.__segments):\n            return True\n\n        self.__cursor_pos += 1\n        self.__lookup_table_visible = False\n        self.__fill_lookup_table()\n        self.__invalidate()\n        return True\n\n    def __on_key_number(self, keyval):\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return False\n        if not self.__lookup_table_visible:\n            return False\n\n        if keyval == IBus.KEY_0:\n            keyval = IBus.KEY_9 + 1\n        index = keyval - IBus.KEY_1\n\n        return self.__on_candidate_index_in_page(index)\n\n    def __on_key_conv(self, mode):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__end_anthy_convert()\n\n        if mode == 0 or mode == 1:\n            if self.__convert_mode == CONV_MODE_HIRAGANA + mode:\n                return True\n            self.__convert_mode = CONV_MODE_HIRAGANA + mode\n        elif mode == 2:\n            if self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n                return True\n            self.__convert_mode = CONV_MODE_HALF_WIDTH_KATAKANA\n        elif mode == 3:\n            if CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode <= CONV_MODE_WIDE_LATIN_3:\n                self.__convert_mode += 1\n                if self.__convert_mode > CONV_MODE_WIDE_LATIN_3:\n                    self.__convert_mode = CONV_MODE_WIDE_LATIN_1\n            else:\n                self.__convert_mode = CONV_MODE_WIDE_LATIN_0\n        elif mode == 4:\n            if CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n                self.__convert_mode += 1\n                if self.__convert_mode > CONV_MODE_LATIN_3:\n                    self.__convert_mode = CONV_MODE_LATIN_1\n            else:\n                self.__convert_mode = CONV_MODE_LATIN_0\n        else:\n            print >> sys.stderr, 'Unkown convert mode (%d)!' % mode\n            return False\n        self.__invalidate()\n        return True\n\n    def __on_key_common(self, keyval, state=0):\n\n        # If use-system-layout is FALSE in ibus 1.4.y or lower,\n        # ibus converts the keymap and ibus-anthy needed to use\n        # self.__commit_string\n        # ibus 1.5.y uses XKB directly so Latin mode can return FALSE.\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return False\n\n        elif Engine.__input_mode == INPUT_MODE_WIDE_LATIN:\n            #  Input Wide Latin chars\n            char = unichr(keyval)\n            wide_char = None#symbol_rule.get(char, None)\n            if wide_char == None:\n                wide_char = unichar_half_to_full(char)\n            self.__commit_string(wide_char)\n            return True\n\n        # Input Japanese\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            # Commit nothing\n            pass\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            for i, (seg_index, text) in enumerate(self.__segments):\n                self.__context.commit_segment(i, seg_index)\n            self.__commit_string(self.__convert_chars)\n        elif self.__convert_mode != CONV_MODE_OFF:\n            self.__commit_string(self.__convert_chars)\n\n        # 'n' + '\\'' == 'nn' in romaji\n        if (keyval >= ord('A') and keyval <= ord('Z')) or \\\n           (keyval >= ord('a') and keyval <= ord('z')):\n            shift = (state & IBus.ModifierType.SHIFT_MASK) != 0\n        else:\n            shift = False\n        self.__preedit_ja_string.set_shift(shift)\n        self.__preedit_ja_string.insert(unichr(keyval))\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            self.__begin_anthy_convert()\n        self.__invalidate()\n        return True\n\n#=======================================================================\n    @classmethod\n    def CONFIG_RELOADED(cls, bus):\n        if config.DEBUG:\n            print 'RELOADED'\n        if not cls.__prefs:\n            cls.__prefs = AnthyPrefs(bus)\n            cls._init_prefs()\n\n        cls.__keybind = cls._mk_keybind()\n\n        jastring.JaString.SET_PREFS(cls.__prefs)\n\n    @classmethod\n    def CONFIG_VALUE_CHANGED(cls, bus, section, name, variant):\n        if config.DEBUG:\n            print 'VALUE_CHAMGED =', section, name, variant\n\n        if not section.startswith('engine/anthy'):\n            # This value is used for IBus.config.set_value only.\n            return\n\n        # The key was deleted by dconf.\n        # test case: update /desktop/ibus/engine/anthy/thumb/ls\n        # and reset the key with dconf direclty.\n        if variant.get_type_string() == '()':\n            cls.__prefs.undo_item(section, name)\n            return\n\n        value = cls.__prefs.variant_to_value(variant)\n        base_sec = section[len(cls.__prefs._prefix) + 1:]\n        sec = cls._get_shortcut_type()\n        if base_sec == sec:\n            cmd = '_Engine__cmd_' + name\n            old = cls.__prefs.get_value(sec, name)\n            value = value if value != [''] else []\n            for s in set(old).difference(value):\n                cls.__keybind.get(cls._s_to_key(s), []).remove(cmd)\n\n            keys = cls.__prefs.keys(sec)\n            for s in set(value).difference(old):\n                cls.__keybind.setdefault(cls._s_to_key(s), []).append(cmd)\n                cls.__keybind.get(cls._s_to_key(s)).sort(\n                    lambda a, b: cmp(keys.index(a[13:]), keys.index(b[13:])))\n\n            cls.__prefs.set_value(sec, name, value)\n        elif base_sec == 'common':\n            cls.__prefs.set_value(base_sec, name, value)\n            if name == 'shortcut_type':\n                cls.__keybind = cls._mk_keybind()\n            if name == 'latin_with_shift':\n                cls.__latin_with_shift = value\n                jastring.JaString.RESET(cls.__prefs, base_sec, name, value)\n        elif base_sec.startswith('kana_typing_rule'):\n            jastring.JaString.RESET(cls.__prefs, base_sec, name, value)\n\n    @classmethod\n    def _init_prefs(cls):\n        prefs = cls.__prefs\n        value = prefs.get_value('common', 'latin_with_shift')\n        cls.__latin_with_shift = value\n\n    @classmethod\n    def _mk_keybind(cls):\n        keybind = {}\n        sec = cls._get_shortcut_type()\n        for k in cls.__prefs.keys(sec):\n            cmd = '_Engine__cmd_' + k\n            for s in cls.__prefs.get_value(sec, k):\n                keybind.setdefault(cls._s_to_key(s), []).append(cmd)\n        return keybind\n\n    @classmethod\n    def _get_shortcut_type(cls):\n        try:\n            t = 'shortcut/' + cls.__prefs.get_value('common', 'shortcut_type')\n        except:\n            t = 'shortcut/default'\n        return t\n\n    @classmethod\n    def _s_to_key(cls, s):\n        keyval = IBus.keyval_from_name(s.split('+')[-1])\n        s = s.lower()\n        state = ('shift+' in s and IBus.ModifierType.SHIFT_MASK or 0) | (\n                 'ctrl+' in s and IBus.ModifierType.CONTROL_MASK or 0) | (\n                 'alt+' in s and IBus.ModifierType.MOD1_MASK or 0)\n        return cls._mk_key(keyval, state)\n\n    @classmethod\n    def _reset_thumb(cls):\n        if cls.__thumb == None:\n            import thumb\n            cls.__thumb = thumb.ThumbShiftKeyboard(cls.__prefs)\n\n        else:\n            cls.__thumb.reset()\n\n    @staticmethod\n    def _mk_key(keyval, state):\n        if state & (IBus.ModifierType.CONTROL_MASK | IBus.ModifierType.MOD1_MASK):\n            if keyval < 0xff and \\\n               unichr(keyval) in u'!\"#$%^\\'()*+,-./:;<=>?@[\\]^_`{|}~':\n                state |= IBus.ModifierType.SHIFT_MASK\n            elif IBus.KEY_a <= keyval <= IBus.KEY_z:\n                keyval -= (IBus.KEY_a - IBus.KEY_A)\n\n        return repr([int(state), int(keyval)])\n\n    def process_key_event_thumb(self, keyval, keycode, state):\n        if self.__thumb == None:\n            self._reset_thumb()\n\n        def on_timeout(keyval):\n            if self._MM:\n                insert(self.__thumb.get_char(self._MM)[self._SS])\n            else:\n                cmd_exec([0, RS(), LS()][self._SS])\n            self._H = None\n\n        def start(t):\n            self._H = GLib.timeout_add(t, on_timeout, keyval)\n\n        def stop():\n            if self._H:\n                GLib.source_remove(self._H)\n                self._H = None\n                return True\n            return False\n\n        def insert(keyval):\n            try:\n                self._MM = self._SS = 0\n                ret = self.__on_key_common(ord(keyval))\n                if (keyval in u',.\u3001\u3002' and\n                    self.__prefs.get_value('common', 'behavior_on_period')):\n                    return self.__cmd_convert(keyval, state)\n                return ret\n            except:\n                pass\n\n        def cmd_exec(keyval, state=0):\n            key = self._mk_key(keyval, state)\n            for cmd in self.__keybind.get(key, []):\n                if config.DEBUG:\n                    print 'cmd =', cmd\n                try:\n                    if getattr(self, cmd)(keyval, state):\n                        return True\n                except:\n                    print >> sys.stderr, 'Unknown command = %s' % cmd\n            return False\n\n        def RS():\n            return self.__thumb.get_rs()\n\n        def LS():\n            return self.__thumb.get_ls()\n\n        def T1():\n            return self.__thumb.get_t1()\n\n        def T2():\n            return self.__thumb.get_t2()\n\n        state = state & (IBus.ModifierType.SHIFT_MASK |\n                         IBus.ModifierType.CONTROL_MASK |\n                         IBus.ModifierType.MOD1_MASK |\n                         IBus.ModifierType.RELEASE_MASK)\n\n        if keyval in KP_Table and self.__prefs.get_value('common',\n                                                         'ten_key_mode'):\n            keyval = KP_Table[keyval]\n\n        if state & IBus.ModifierType.RELEASE_MASK:\n            if keyval == self._MM:\n                if stop():\n                    insert(self.__thumb.get_char(self._MM)[self._SS])\n                self._MM = 0\n            elif (1 if keyval == RS() else 2) == self._SS:\n                if stop():\n                    cmd_exec([0, RS(), LS()][self._SS])\n                self._SS = 0\n            if keyval in [RS(), LS()]:\n                self._RSS = 0\n            elif keyval == self._RMM:\n                self._RMM = 0\n        else:\n            if keyval in [LS(), RS()] and state == 0:\n                if self._SS:\n                    stop()\n                    cmd_exec([0, RS(), LS()][self._SS])\n                    self._SS = 1 if keyval == RS() else 2\n                    start(T1())\n                elif self._MM:\n                    stop()\n                    self._RMM = self._MM\n                    self._RSS = 1 if keyval == RS() else 2\n                    insert(self.__thumb.get_char(self._MM)[1 if keyval == RS() else 2])\n                else:\n                    if self._RSS == (1 if keyval == RS() else 2):\n                        if self._RMM:\n                            insert(self.__thumb.get_char(self._RMM)[self._RSS])\n                    else:\n                        self._SS = 1 if keyval == RS() else 2\n                        start(T1())\n            elif keyval in self.__thumb.get_chars() and state == 0:\n                if self._MM:\n                    stop()\n                    insert(self.__thumb.get_char(self._MM)[self._SS])\n                    start(T2())\n                    self._MM = keyval\n                elif self._SS:\n                    stop()\n                    self._RMM = keyval\n                    self._RSS = self._SS\n                    insert(self.__thumb.get_char(keyval)[self._SS])\n                else:\n                    if self._RMM  == keyval:\n                        if self._RSS:\n                            insert(self.__thumb.get_char(self._RMM)[self._RSS])\n                    else:\n                        if cmd_exec(keyval, state):\n                            return True\n                        start(T2())\n                        self._MM = keyval\n            else:\n                if self._MM:\n                    stop()\n                    insert(self.__thumb.get_char(self._MM)[self._SS])\n                elif self._SS:\n                    stop()\n                    cmd_exec([0, RS(), LS()][self._SS])\n                if cmd_exec(keyval, state):\n                    return True\n                elif 0x21 <= keyval <= 0x7e and state & \\\n                        (IBus.ModifierType.CONTROL_MASK | IBus.ModifierType.MOD1_MASK) == 0:\n                    if state & IBus.ModifierType.SHIFT_MASK:\n                        insert(self.__thumb.get_shift_char(keyval, unichr(keyval)))\n                    elif self._SS == 0:\n                        insert(unichr(keyval))\n                else:\n                    if not self.__preedit_ja_string.is_empty():\n                        return True\n                    return False\n        return True\n\n    def __process_key_event_internal2(self, keyval, keycode, state):\n        if Engine.__typing_mode == jastring.TYPING_MODE_THUMB_SHIFT and \\\n           Engine.__input_mode not in [INPUT_MODE_LATIN, INPUT_MODE_WIDE_LATIN]:\n            return self.process_key_event_thumb(keyval, keycode, state)\n\n        is_press = (state & IBus.ModifierType.RELEASE_MASK) == 0\n\n        state = state & (IBus.ModifierType.SHIFT_MASK |\n                         IBus.ModifierType.CONTROL_MASK |\n                         IBus.ModifierType.MOD1_MASK)\n\n        # ignore key release events\n        if not is_press:\n            return False\n\n        if keyval in KP_Table and self.__prefs.get_value('common',\n                                                         'ten_key_mode'):\n            keyval = KP_Table[keyval]\n\n        key = self._mk_key(keyval, state)\n        for cmd in self.__keybind.get(key, []):\n            if config.DEBUG:\n                print 'cmd =', cmd\n            try:\n                if getattr(self, cmd)(keyval, state):\n                    return True\n            except:\n                print >> sys.stderr, 'Unknown command = %s' % cmd\n\n        if state & (IBus.ModifierType.CONTROL_MASK | IBus.ModifierType.MOD1_MASK):\n            return False\n\n        if (IBus.KEY_exclam <= keyval <= IBus.KEY_asciitilde or\n            keyval == IBus.KEY_yen):\n            if Engine.__typing_mode == jastring.TYPING_MODE_KANA:\n                if keyval == IBus.KEY_0 and state == IBus.ModifierType.SHIFT_MASK:\n                    keyval = IBus.KEY_asciitilde\n                elif keyval == IBus.KEY_backslash and keycode in [132-8, 133-8]:\n                    keyval = IBus.KEY_yen\n            ret = self.__on_key_common(keyval, state)\n            if (Engine.__input_mode != INPUT_MODE_LATIN and\n                unichr(keyval) in u',.' and\n                self.__prefs.get_value('common', 'behavior_on_period')):\n                return self.__cmd_convert(keyval, state)\n            return ret\n        else:\n            if not self.__preedit_ja_string.is_empty():\n                return True\n            return False\n\n    def _chk_mode(self, mode):\n        if '0' in mode and self.__preedit_ja_string.is_empty():\n            return True\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            if '1' in mode and not self.__preedit_ja_string.is_empty():\n                return True\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            if '2' in mode and not self.__lookup_table_visible:\n                return True\n        elif self.__convert_mode == CONV_MODE_PREDICTION:\n            if '3' in mode and not self.__lookup_table_visible:\n                return True\n        else:\n            if '4' in mode:\n                return True\n\n        if '5' in mode and self.__lookup_table_visible:\n            return True\n\n        return False\n\n    def __get_quoted_id(self, file):\n        id = file\n        has_mbcs = False\n\n        for i in xrange(0, len(id)):\n            if ord(id[i]) >= 0x7f:\n                    has_mbcs = True\n                    break\n        if has_mbcs:\n            id = id.encode('hex')\n\n        if id.find('/') >=0:\n            id = id[id.rindex('/') + 1:]\n        if id.find('.') >=0:\n            id = id[:id.rindex('.')]\n\n        if id.startswith('0x'):\n            id = id.encode('hex')\n            has_mbcs = True\n        if has_mbcs:\n            id = '0x' + id\n        return id\n\n    def __get_dict_id_from_file(self, file):\n        return self.__get_quoted_id(file)\n\n    def __link_dict_file_with_id(self, file, id, link_mode):\n        if id == None:\n            return\n        if link_mode == LINK_DICT_EMBEDDED:\n            directory = get_userhome() + '/.anthy/' + IMPORTED_EMBEDDED_DICT_DIR\n            name = IMPORTED_EMBEDDED_DICT_PREFIX + id\n        elif link_mode == LINK_DICT_SINGLE:\n            directory = get_userhome() + '/.anthy'\n            name = IMPORTED_SINGLE_DICT_PREFIX + id\n        else:\n            return\n        if path.exists(directory):\n            if not path.isdir(directory):\n                print >> sys.stderr, directory + ' is not a directory'\n                return\n        else:\n            os.makedirs(directory, 0700)\n        backup_dir = os.getcwd()\n        os.chdir(directory)\n        if path.lexists(directory + '/' + name):\n            if path.islink(directory + '/' + name):\n                print >> sys.stderr, 'Removing ' + name\n                os.unlink(directory + '/' + name)\n            else:\n                alternate = name + str(os.getpid())\n                print >> sys.stderr, 'Moving ' + name + ' to ' + alternate\n                os.rename(name, alternate)\n        os.symlink(file, directory + '/' + name)\n        if backup_dir != None:\n            os.chdir(backup_dir)\n\n    def __remove_dict_file_with_id(self, file, id, link_mode):\n        if id == None:\n            return\n        if link_mode == LINK_DICT_EMBEDDED:\n            directory = get_userhome() + '/.anthy/' + IMPORTED_EMBEDDED_DICT_DIR\n            name = IMPORTED_EMBEDDED_DICT_PREFIX + id\n        elif link_mode == LINK_DICT_SINGLE:\n            directory = get_userhome() + '/.anthy'\n            name = IMPORTED_SINGLE_DICT_PREFIX + id\n        else:\n            return\n        if path.exists(directory):\n            if not path.isdir(directory):\n                print >> sys.stderr, directory + ' is not a directory'\n                return\n        backup_dir = os.getcwd()\n        os.chdir(directory)\n        if path.lexists(directory + '/' + name):\n            os.unlink(directory + '/' + name)\n        if backup_dir != None:\n            os.chdir(backup_dir)\n\n    def __link_dict_file(self, file):\n        if not path.exists(file):\n            print >> sys.stderr, file + ' does not exist'\n            return False\n        id = self.__get_dict_id_from_file(file)\n        section = 'dict/file/' + id\n        if section not in self.__prefs.sections():\n            self.__fetch_dict_values(section)\n        if self.__prefs.get_value(section, 'embed'):\n            self.__link_dict_file_with_id(file, id, LINK_DICT_EMBEDDED)\n        if self.__prefs.get_value(section, 'single'):\n            self.__link_dict_file_with_id(file, id, LINK_DICT_SINGLE)\n        return True\n\n    def __remove_dict_file(self, file):\n        id = self.__get_dict_id_from_file(file)\n        section = 'dict/file/' + id\n        if section not in self.__prefs.sections():\n            self.__fetch_dict_values(section)\n        if self.__prefs.get_value(section, 'embed'):\n            self.__remove_dict_file_with_id(file, id, LINK_DICT_EMBEDDED)\n        if self.__prefs.get_value(section, 'single'):\n            self.__remove_dict_file_with_id(file, id, LINK_DICT_SINGLE)\n\n    def __set_dict_files_value(self, base_sec, name, value):\n        if name == 'files':\n            str_list = []\n            for file in value:\n                str_list.append(self.__prefs.str(file))\n            old_files = self.__prefs.get_value(base_sec, name)\n            for file in old_files:\n                if file in str_list:\n                    continue\n                self.__remove_dict_file(file)\n            for file in str_list:\n                if file in old_files:\n                    continue\n                self.__link_dict_file(file)\n            self.__prefs.set_value(base_sec, name, str_list)\n        else:\n            self.__prefs.set_value(base_sec, name, value)\n\n    def __fetch_dict_values(self, section):\n        self.__prefs.set_new_section(section)\n        self.__prefs.set_new_key(section, 'short_label')\n        self.__prefs.set_no_key_warning(True)\n        self.__prefs.fetch_item(section, 'short_label')\n        self.__prefs.set_new_key(section, 'long_label')\n        self.__prefs.fetch_item(section, 'long_label')\n        self.__prefs.set_new_key(section, 'embed')\n        self.__prefs.fetch_item(section, 'embed')\n        self.__prefs.set_new_key(section, 'single')\n        self.__prefs.fetch_item(section, 'single')\n        self.__prefs.set_new_key(section, 'reverse')\n        self.__prefs.fetch_item(section, 'reverse')\n        self.__prefs.set_no_key_warning(False)\n\n    def __config_value_changed_cb(self, ibus_config, section, name, variant):\n        if config.DEBUG:\n            print 'VALUE_CHAMGED =', section, name, variant\n\n        if not section.startswith('engine/anthy'):\n            # This value is used for IBus.config.set_value only.\n            return\n\n        # The key was deleted by dconf.\n        # test case: update /desktop/ibus/engine/anthy/thumb/ls\n        # and reset the key with dconf direclty.\n        if variant.get_type_string() == '()':\n            self.__prefs.undo_item(section, name)\n            return\n\n        value = self.__prefs.variant_to_value(variant)\n        base_sec = section[len(self.__prefs._prefix) + 1:]\n        sec = self._get_shortcut_type()\n\n        if base_sec == 'thumb':\n            self.__prefs.set_value(base_sec, name, value)\n            self._reset_thumb()\n        elif base_sec == 'dict':\n            self.__set_dict_files_value(base_sec, name, value)\n            self.__set_dict_mode_props(self.__prop_list, True)\n        elif base_sec.startswith('dict/file/'):\n            if base_sec not in self.__prefs.sections():\n                self.__fetch_dict_values(base_sec)\n            self.__prefs.set_value(base_sec, name, value)\n            self.__set_dict_mode_props(self.__prop_list, True)\n        elif base_sec:\n            self.__prefs.set_value(base_sec, name, value)\n        else:\n            self.__prefs.set_value(section, name, value)\n\n    #mod_keys\n    def __set_input_mode(self, mode):\n        self.__input_mode_activate(mode, IBus.PropState.CHECKED)\n        self.__reset()\n        self.__invalidate()\n\n        return True\n\n    def __unset_current_input_mode(self):\n        modes = {\n            INPUT_MODE_HIRAGANA: u'InputMode.Hiragana',\n            INPUT_MODE_KATAKANA: u'InputMode.Katakana',\n            INPUT_MODE_HALF_WIDTH_KATAKANA: u'InputMode.HalfWidthKatakana',\n            INPUT_MODE_LATIN: u'InputMode.Latin',\n            INPUT_MODE_WIDE_LATIN: u'InputMode.WideLatin'\n        }\n        self.__input_mode_activate(modes[Engine.__input_mode],\n                                   IBus.PropState.UNCHECKED)\n\n    def __cmd_on_off(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return self.__set_input_mode(u'InputMode.Hiragana')\n        else:\n            return self.__set_input_mode(u'InputMode.Latin')\n\n    def __cmd_circle_input_mode(self, keyval, state):\n        modes = {\n            INPUT_MODE_HIRAGANA: u'InputMode.Katakana',\n            INPUT_MODE_KATAKANA: u'InputMode.HalfWidthKatakana',\n            INPUT_MODE_HALF_WIDTH_KATAKANA: u'InputMode.Latin',\n            INPUT_MODE_LATIN: u'InputMode.WideLatin',\n            INPUT_MODE_WIDE_LATIN: u'InputMode.Hiragana'\n        }\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(modes[Engine.__input_mode])\n\n    def __cmd_circle_kana_mode(self, keyval, state):\n        modes = {\n            INPUT_MODE_HIRAGANA: u'InputMode.Katakana',\n            INPUT_MODE_KATAKANA: u'InputMode.HalfWidthKatakana',\n            INPUT_MODE_HALF_WIDTH_KATAKANA: u'InputMode.Hiragana',\n            INPUT_MODE_LATIN: u'InputMode.Hiragana',\n            INPUT_MODE_WIDE_LATIN: u'InputMode.Hiragana'\n        }\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(modes[Engine.__input_mode])\n\n    def __cmd_latin_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.Latin')\n\n    def __cmd_wide_latin_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.WideLatin')\n\n    def __cmd_hiragana_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.Hiragana')\n\n    def __cmd_katakana_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.Katakana')\n\n    def __cmd_half_katakana(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.HalfWidthKatakana')\n\n#    def __cmd_cancel_pseudo_ascii_mode_key(self, keyval, state):\n#        pass\n\n    def __unset_current_typing_mode(self):\n        modes = {\n            jastring.TYPING_MODE_ROMAJI: u'TypingMode.Romaji',\n            jastring.TYPING_MODE_KANA: u'TypingMode.Kana',\n            jastring.TYPING_MODE_THUMB_SHIFT: u'TypingMode.ThumbShift',\n        }\n        self.__typing_mode_activate(modes[Engine.__typing_mode],\n                                    IBus.PropState.UNCHECKED)\n\n    def __cmd_circle_typing_method(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        modes = {\n            jastring.TYPING_MODE_THUMB_SHIFT: u'TypingMode.Romaji',\n            jastring.TYPING_MODE_KANA: u'TypingMode.ThumbShift',\n            jastring.TYPING_MODE_ROMAJI: u'TypingMode.Kana',\n        }\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_typing_mode()\n        self.__typing_mode_activate(modes[Engine.__typing_mode],\n                                    IBus.PropState.CHECKED)\n        return True\n\n    def __cmd_circle_dict_method(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        # ibus 1.5 or later needs to send UNCHECKED\n        prop_name = self.__dict_mode_get_prop_name(Engine.__dict_mode)\n        if prop_name != None:\n            self.__dict_mode_activate(prop_name,\n                                      IBus.PropState.UNCHECKED)\n\n        single_files = self.__get_single_dict_files()\n        new_mode = Engine.__dict_mode + 1\n        if new_mode > len(single_files):\n            new_mode = 0\n        Engine.__dict_mode = new_mode\n        prop_name = self.__dict_mode_get_prop_name(Engine.__dict_mode)\n        if prop_name == None:\n            return False\n        self.__dict_mode_activate(prop_name,\n                                  IBus.PropState.CHECKED)\n        return True\n\n    #edit_keys\n    def __cmd_insert_space(self, keyval, state):\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return False\n        if (self.__prefs.get_value('common', 'half_width_space') or\n            Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA):\n            return self.__cmd_insert_half_space(keyval, state)\n        else:\n            return self.__cmd_insert_wide_space(keyval, state)\n\n    def __cmd_insert_alternate_space(self, keyval, state):\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return False\n        if (self.__prefs.get_value('common', 'half_width_space') or\n            Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA):\n            return self.__cmd_insert_wide_space(keyval, state)\n        else:\n            return self.__cmd_insert_half_space(keyval, state)\n\n    def __cmd_insert_half_space(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        if not self.__preedit_ja_string.is_empty():\n            return False\n        self.__commit_string(unichr(IBus.KEY_space))\n        return True\n\n    def __cmd_insert_wide_space(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        if not self.__preedit_ja_string.is_empty():\n            return False\n        char = unichr(IBus.KEY_space)\n        wide_char = symbol_rule.get(char, None)\n        if wide_char == None:\n            wide_char = unichar_half_to_full(char)\n        self.__commit_string(wide_char)\n        return True\n\n    def __cmd_backspace(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        return self.__on_key_back_space()\n\n    def __cmd_delete(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        return self.__on_key_delete()\n\n    def __cmd_commit(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        return self.__on_key_return()\n\n    def __cmd_convert(self, keyval, state):\n        if not self._chk_mode('14'):\n            return False\n\n        self.__begin_anthy_convert()\n        self.__invalidate()\n\n        return True\n\n    def __cmd_predict(self, keyval, state):\n        if not self._chk_mode('14'):\n            return False\n\n        text, cursor = self.__preedit_ja_string.get_hiragana(True)\n\n        self.__context.set_prediction_string(text.encode('utf8'))\n        nr_predictions = self.__context.get_nr_predictions()\n\n#        for i in range(nr_predictions):\n#            print self.__context.get_prediction(i)\n\n        buf = self.__context.get_prediction(0)\n        if not buf:\n            return False\n\n        text = UN(buf)\n        self.__segments.append((0, text))\n\n        self.__convert_mode = CONV_MODE_PREDICTION\n        self.__cursor_pos = 0\n        self.__fill_lookup_table()\n        self.__lookup_table_visible = False\n        self.__invalidate()\n\n        return True\n\n    def __cmd_cancel(self, keyval, state):\n        return self.__cmd_cancel_all(keyval, state)\n\n    def __cmd_cancel_all(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            return self.__on_key_escape()\n        else:\n            self.__end_convert()\n            self.__invalidate()\n            return True\n\n    def __cmd_reconvert(self, keyval, state):\n        if not self.__preedit_ja_string.is_empty():\n            # if user has inputed some chars\n            return False\n\n        # Move importing Gtk into Engine from the header\n        # because ibus-engine-anthy --xml does not requre to open X.\n        try:\n            from gi.repository import Gtk\n            clipboard_get = Gtk.Clipboard.get\n        except ImportError:\n            clipboard_get = lambda a : None\n        except RuntimeError:\n            # Do we support the engine without display?\n            print >> sys.stderr, \"Gtk couldn't be initialized\"\n            print >> sys.stderr, 'Could not open display'\n            clipboard_get = lambda a : None\n\n        # Use Gtk.Clipboard.request_text() instead of\n        # Gtk.Clipboard.wait_for_text() because DBus is timed out.\n        clipboard = clipboard_get ('PRIMARY')\n        if clipboard:\n            clipboard.request_text (self.__get_clipboard, CLIPBOARD_RECONVERT)\n\n        return True\n\n    def __update_reconvert(self, clipboard_text):\n        if clipboard_text == None:\n            return False\n\n        self.__convert_chars = UN(clipboard_text)\n        for i in xrange(0, len(self.__convert_chars)):\n            keyval = self.__convert_chars[i]\n            self.__preedit_ja_string.insert(unichr(ord (keyval)))\n\n        self.__context.set_string(self.__convert_chars.encode('utf-8'))\n        nr_segments = self.__context.get_nr_segments()\n\n        for i in xrange(0, nr_segments):\n            buf = self.__context.get_segment(i, 0)\n            text = UN(buf)\n            self.__segments.append((0, text))\n\n        self.__convert_mode = CONV_MODE_ANTHY\n        self.__cursor_pos = 0\n        self.__fill_lookup_table()\n        self.__lookup_table_visible = False\n        self.__invalidate()\n\n        return True\n\n#    def __cmd_do_nothing(self, keyval, state):\n#        return True\n\n    #caret_keys\n    def __move_caret(self, i):\n        if not self._chk_mode('1'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__preedit_ja_string.move_cursor(\n                -len(self.__preedit_ja_string.get_latin()[0]) if i == 0 else\n                i if i in [-1, 1] else\n                len(self.__preedit_ja_string.get_latin()[0]))\n            self.__invalidate()\n            return True\n\n        return False\n\n    def __cmd_move_caret_first(self, keyval, state):\n        return self.__move_caret(0)\n\n    def __cmd_move_caret_last(self, keyval, state):\n        return self.__move_caret(2)\n\n    def __cmd_move_caret_forward(self, keyval, state):\n        return self.__move_caret(1)\n\n    def __cmd_move_caret_backward(self, keyval, state):\n        return self.__move_caret(-1)\n\n    #segments_keys\n    def __select_segment(self, i):\n        if not self._chk_mode('25'):\n            return False\n\n        pos = 0 if i == 0 else \\\n              self.__cursor_pos + i if i in [-1, 1] else \\\n              len(self.__segments) - 1\n\n        if 0 <= pos < len(self.__segments) and pos != self.__cursor_pos:\n            self.__cursor_pos = pos\n            self.__lookup_table_visible = False\n            self.__fill_lookup_table()\n            self.__invalidate()\n\n        return True\n\n    def __cmd_select_first_segment(self, keyval, state):\n        return self.__select_segment(0)\n\n    def __cmd_select_last_segment(self, keyval, state):\n        return self.__select_segment(2)\n\n    def __cmd_select_next_segment(self, keyval, state):\n        return self.__select_segment(1)\n\n    def __cmd_select_prev_segment(self, keyval, state):\n        return self.__select_segment(-1)\n\n    def __cmd_shrink_segment(self, keyval, state):\n        if not self._chk_mode('25'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__shrink_segment(-1)\n            return True\n\n    def __cmd_expand_segment(self, keyval, state):\n        if not self._chk_mode('25'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__shrink_segment(1)\n            return True\n\n    def __move_cursor_char_length(self, length):\n        if Engine.__input_mode == INPUT_MODE_HIRAGANA:\n            self.__preedit_ja_string.move_cursor_hiragana_length(length)\n        elif Engine.__input_mode == INPUT_MODE_KATAKANA:\n            self.__preedit_ja_string.move_cursor_katakana_length(length)\n        elif Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA:\n            self.__preedit_ja_string.move_cursor_half_with_katakana_length(length)\n        else:\n            self.__preedit_ja_string.move_cursor(length)\n\n    def __commit_nth_segment(self, commit_index, keyval, state):\n\n        if commit_index >= len(self.__segments):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            for i in xrange(0, commit_index + 1):\n                (seg_index, text) = self.__segments[i]\n                self.commit_text(IBus.Text.new_from_string(text))\n\n            text, cursor = self.__get_preedit()\n            commit_length = 0\n            for i in xrange(0, commit_index + 1):\n                buf = self.__context.get_segment(i, NTH_UNCONVERTED_CANDIDATE)\n                commit_length += len(UN(buf))\n            self.__move_cursor_char_length(commit_length - cursor)\n            for i in xrange(0, commit_length):\n                self.__preedit_ja_string.remove_before()\n            self.__move_cursor_char_length(cursor - commit_length)\n\n            del self.__segments[0:commit_index + 1]\n\n        if len(self.__segments) == 0:\n            self.__reset()\n        else:\n            if self.__cursor_pos > commit_index:\n                self.__cursor_pos -= (commit_index + 1)\n            else:\n                self.__cursor_pos = 0\n            text, cursor = self.__get_preedit()\n            self.__convert_chars = text\n            self.__context.set_string(text.encode ('utf-8'))\n\n        self.__lookup_table.clear()\n        self.__lookup_table.set_cursor_visible(False)\n        self.__lookup_table_visible = False\n        self.update_aux_string(u'', IBus.AttrList(),\n            self.__lookup_table_visible)\n        self.__fill_lookup_table()\n        self.__invalidate()\n        self.__update_input_chars()\n\n        return True\n\n    def __cmd_commit_first_segment(self, keyval, state):\n        return self.__commit_nth_segment(0, keyval, state)\n\n    def __cmd_commit_selected_segment(self, keyval, state):\n        return self.__commit_nth_segment(self.__cursor_pos, keyval, state)\n\n    #candidates_keys\n    def __on_candidate_index_in_page(self, index):\n        if not self._chk_mode('5'):\n            return False\n\n        if index >= self.__lookup_table.get_page_size():\n            return False\n        cursor_pos = self.__lookup_table.get_cursor_pos()\n        cursor_in_page = self.__lookup_table.get_cursor_in_page()\n        real_index = cursor_pos - cursor_in_page + index\n        if real_index >= self.__lookup_table.get_number_of_candidates():\n            return False\n        self.__lookup_table.set_cursor_pos(real_index)\n        index = self.__lookup_table.get_cursor_pos()\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__lookup_table_visible = False\n        self.__on_key_right()\n        self.__invalidate()\n        return True\n\n    def __cmd_select_first_candidate(self, keyval, state):\n        return self.__on_candidate_index_in_page(0)\n\n    def __cmd_select_last_candidate(self, keyval, state):\n        return self.__on_candidate_index_in_page(\n            self.__lookup_table.get_page_size() - 1)\n\n    def __cmd_select_next_candidate(self, keyval, state):\n        if not self._chk_mode('235'):\n            return False\n\n        return self.__on_key_down()\n\n    def __cmd_select_prev_candidate(self, keyval, state):\n        if not self._chk_mode('235'):\n            return False\n\n        return self.__on_key_up()\n\n    def __cmd_candidates_page_up(self, keyval, state):\n        if not self._chk_mode('5'):\n            return False\n\n        return self.__on_key_page_up()\n\n    def __cmd_candidates_page_down(self, keyval, state):\n        if not self._chk_mode('5'):\n            return False\n\n        return self.__on_key_page_down()\n\n    #direct_select_keys\n    def __select_keyval(self, keyval):\n        if not self._chk_mode('5'):\n            return False\n\n        return self.__on_key_number(keyval)\n\n    def __cmd_select_candidates_1(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_2(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_3(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_4(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_5(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_6(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_7(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_8(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_9(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_0(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    #convert_keys\n    def __cmd_convert_to_char_type_forward(self, keyval, state):\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            n = self.__segments[self.__cursor_pos][0]\n            if n == NTH_HIRAGANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_KATAKANA_CANDIDATE)\n            elif n == NTH_KATAKANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n            elif n == NTH_HALFKANA_CANDIDATE:\n                return self.__convert_segment_to_latin(-100)\n            elif n == -100:\n                return self.__convert_segment_to_latin(-101)\n            else:\n                return self.__convert_segment_to_kana(NTH_HIRAGANA_CANDIDATE)\n\n        if self.__convert_mode == CONV_MODE_KATAKANA:\n            return self.__cmd_convert_to_half_katakana(keyval, state)\n        elif self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n            return self.__cmd_convert_to_latin(keyval, state)\n        elif CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n            return self.__cmd_convert_to_wide_latin(keyval, state)\n        elif (CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode\n                                     <= CONV_MODE_WIDE_LATIN_3):\n            return self.__cmd_convert_to_hiragana(keyval, state)\n        else:\n            return self.__cmd_convert_to_katakana(keyval, state)\n\n    def __cmd_convert_to_char_type_backward(self, keyval, state):\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            n = self.__segments[self.__cursor_pos][0]\n            if n == NTH_KATAKANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_HIRAGANA_CANDIDATE)\n            elif n == NTH_HALFKANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_KATAKANA_CANDIDATE)\n            elif n == -100:\n                return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n            elif n == -101:\n                return self.__convert_segment_to_latin(-100)\n            else:\n                return self.__convert_segment_to_latin(-101)\n\n        if self.__convert_mode == CONV_MODE_KATAKANA:\n            return self.__cmd_convert_to_hiragana(keyval, state)\n        elif self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n            return self.__cmd_convert_to_katakana(keyval, state)\n        elif CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n            return self.__cmd_convert_to_half_katakana(keyval, state)\n        elif (CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode\n                                     <= CONV_MODE_WIDE_LATIN_3):\n            return self.__cmd_convert_to_latin(keyval, state)\n        else:\n            return self.__cmd_convert_to_wide_latin(keyval, state)\n\n    def __convert_segment_to_kana(self, n):\n        if self.__convert_mode == CONV_MODE_ANTHY and -4 <= n <= -2:\n            buf = self.__context.get_segment(self.__cursor_pos, n)\n            self.__segments[self.__cursor_pos] = n, UN(buf)\n            self.__lookup_table_visible = False\n            self.__invalidate()\n            return True\n\n        return False\n\n    def __cmd_convert_to_hiragana(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return self.__convert_segment_to_kana(NTH_HIRAGANA_CANDIDATE)\n\n        return self.__on_key_conv(0)\n\n    def __cmd_convert_to_katakana(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return self.__convert_segment_to_kana(NTH_KATAKANA_CANDIDATE)\n\n        return self.__on_key_conv(1)\n\n    def __cmd_convert_to_half(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            i, s = self.__segments[self.__cursor_pos]\n            if i == -101:\n                return self.__convert_segment_to_latin(-100)\n            elif i == -100:\n                return self.__convert_segment_to_latin(-100)\n            return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n\n        elif CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode <= CONV_MODE_WIDE_LATIN_3:\n            return self.__on_key_conv(4)\n        elif CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n            return self.__on_key_conv(4)\n        return self.__on_key_conv(2)\n\n    def __cmd_convert_to_half_katakana(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n\n        return self.__on_key_conv(2)\n\n    def __convert_segment_to_latin(self, n):\n        if self.__convert_mode == CONV_MODE_ANTHY and n in [-100, -101]:\n            start = 0\n            for i in range(self.__cursor_pos):\n                start += len(UN(self.__context.get_segment(i, NTH_UNCONVERTED_CANDIDATE)))\n            end = start + len(UN(self.__context.get_segment(self.__cursor_pos, NTH_UNCONVERTED_CANDIDATE)))\n            i, s = self.__segments[self.__cursor_pos]\n            s2 = self.__preedit_ja_string.get_raw(start, end)\n            if n == -101:\n                s2 = u''.join([unichar_half_to_full(c) for c in s2])\n            if i == n:\n                if s == s2.lower():\n                    s2 = s2.upper()\n                elif s == s2.upper():\n                    s2 = s2.capitalize()\n                elif s == s2 or s == s2.capitalize():\n                    s2 = s2.lower()\n            self.__segments[self.__cursor_pos] = n, s2\n            self.__lookup_table_visible = False\n            self.__invalidate()\n            return True\n\n        return False\n\n    def __cmd_convert_to_wide_latin(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n           return self.__convert_segment_to_latin(-101)\n\n        return self.__on_key_conv(3)\n\n    def __cmd_convert_to_latin(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n           return self.__convert_segment_to_latin(-100)\n\n        return self.__on_key_conv(4)\n\n    #dictonary_keys\n    def __cmd_dict_admin(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        self.__start_dict_admin()\n        return True\n\n    def __cmd_add_word(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        self.__start_add_word()\n        return True\n\n    def __cmd_start_setup(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        self.__start_setup()\n        return True\n\n    def __start_dict_admin(self):\n        command = self.__prefs.get_value('common', 'dict_admin_command')\n        os.spawnl(os.P_NOWAIT, *command)\n\n    def __start_add_word(self):\n        command = self.__prefs.get_value('common', 'add_word_command')\n        os.spawnl(os.P_NOWAIT, *command)\n\n    def __start_setup(self):\n        if Engine.__setup_pid != 0:\n            pid, state = os.waitpid(Engine.__setup_pid, os.P_NOWAIT)\n            if pid != Engine.__setup_pid:\n                return\n            Engine.__setup_pid = 0\n        setup_cmd = path.join(config.LIBEXECDIR, 'ibus-setup-anthy')\n        Engine.__setup_pid = os.spawnl(os.P_NOWAIT, setup_cmd, 'ibus-setup-anthy')\n\n    def __cmd_hiragana_for_latin_with_shift(self, keyval, state):\n        self.__preedit_ja_string.set_hiragana_katakana(True)\n\n"], "fixing_code": ["# vim:set et sts=4 sw=4:\n# -*- coding: utf-8 -*-\n#\n# ibus-anthy - The Anthy engine for IBus\n#\n# Copyright (c) 2007-2008 Peng Huang <shawn.p.huang@gmail.com>\n# Copyright (c) 2010-2013 Takao Fujiwara <takao.fujiwara1@gmail.com>\n# Copyright (c) 2007-2013 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nimport os\nfrom os import environ, path\nimport signal\nimport sys\nfrom gettext import dgettext\n\nfrom main import get_userhome\n\ntry:\n    from locale import getpreferredencoding\nexcept:\n    pass\n\nfrom gi.repository import GLib\nfrom gi.repository import IBus\n\nfrom gi.repository import Anthy\nNTH_UNCONVERTED_CANDIDATE = Anthy.NTH_UNCONVERTED_CANDIDATE\nNTH_KATAKANA_CANDIDATE = Anthy.NTH_KATAKANA_CANDIDATE\nNTH_HIRAGANA_CANDIDATE = Anthy.NTH_HIRAGANA_CANDIDATE\nNTH_HALFKANA_CANDIDATE = Anthy.NTH_HALFKANA_CANDIDATE\n\nimport _config as config\nfrom tables import *\nimport jastring\nfrom segment import unichar_half_to_full\n\nsys.path.append(path.join(config.PKGDATADIR, 'setup'))\nfrom anthyprefs import AnthyPrefs\n\n_  = lambda a : dgettext('ibus-anthy', a)\nN_ = lambda a : a\nUN = lambda a : unicode(a, 'utf-8')\n\nINPUT_MODE_HIRAGANA, \\\nINPUT_MODE_KATAKANA, \\\nINPUT_MODE_HALF_WIDTH_KATAKANA, \\\nINPUT_MODE_LATIN, \\\nINPUT_MODE_WIDE_LATIN = range(5)\n\nCONV_MODE_OFF, \\\nCONV_MODE_ANTHY, \\\nCONV_MODE_HIRAGANA, \\\nCONV_MODE_KATAKANA, \\\nCONV_MODE_HALF_WIDTH_KATAKANA, \\\nCONV_MODE_LATIN_0, \\\nCONV_MODE_LATIN_1, \\\nCONV_MODE_LATIN_2, \\\nCONV_MODE_LATIN_3, \\\nCONV_MODE_WIDE_LATIN_0, \\\nCONV_MODE_WIDE_LATIN_1, \\\nCONV_MODE_WIDE_LATIN_2, \\\nCONV_MODE_WIDE_LATIN_3, \\\nCONV_MODE_PREDICTION = range(14)\n\nSEGMENT_DEFAULT         = 0\nSEGMENT_SINGLE          = 1 << 0\nSEGMENT_IMMEDIATE       = 1 << 1\n\nCLIPBOARD_RECONVERT = range(1)\n\nLINK_DICT_EMBEDDED, \\\nLINK_DICT_SINGLE = range(2)\n\nIMPORTED_EMBEDDED_DICT_DIR = 'imported_words_default.d'\nIMPORTED_EMBEDDED_DICT_PREFIX = 'ibus__'\nIMPORTED_SINGLE_DICT_PREFIX = 'imported_words_ibus__'\n\nKP_Table = {}\nfor s in dir(IBus):\n    if s.startswith('KEY_KP_'):\n        v = IBus.keyval_from_name(s[7:])\n        if v:\n            KP_Table[IBus.keyval_from_name(s[4:])] = v\nfor k, v in zip(['KEY_KP_Add', 'KEY_KP_Decimal', 'KEY_KP_Divide', 'KEY_KP_Enter',\n                 'KEY_KP_Equal', 'KEY_KP_Multiply', 'KEY_KP_Separator',\n                 'KEY_KP_Space', 'KEY_KP_Subtract'],\n                ['KEY_plus', 'KEY_period', 'KEY_slash', 'KEY_Return',\n                 'KEY_equal', 'KEY_asterisk', 'KEY_comma',\n                 'KEY_space', 'KEY_minus']):\n    KP_Table[getattr(IBus, k)] = getattr(IBus, v)\n\nclass Engine(IBus.EngineSimple):\n    __input_mode = None\n    __typing_mode = None\n    __segment_mode = None\n    __dict_mode = None\n\n    __setup_pid = 0\n    __prefs = None\n    __keybind = {}\n    __thumb = None\n    __latin_with_shift = True\n\n    def __init__(self, bus, object_path):\n        super(Engine, self).__init__(connection=bus.get_connection(),\n                                     object_path=object_path)\n\n        # create anthy context\n        self.__context = Anthy.GContext()\n        self.__context.set_encoding(Anthy.UTF8_ENCODING)\n\n        # init state\n        self.__idle_id = 0\n        self.__prop_dict = {}\n        self.__input_purpose = 0\n        self.__has_input_purpose = False\n        if hasattr(IBus, 'InputPurpose'):\n            self.__has_input_purpose = True\n        try:\n            self.__is_utf8 = (getpreferredencoding().lower() == 'utf-8')\n        except:\n            self.__is_utf8 = False\n        self.__ibus_version = 0.0\n\n#        self.__lookup_table = ibus.LookupTable.new(page_size=9,\n#                                                   cursor_pos=0,\n#                                                   cursor_visible=True,\n#                                                   round=True)\n        size = self.__prefs.get_value('common', 'page_size')\n        self.__lookup_table = IBus.LookupTable.new(page_size=size,\n                                                   cursor_pos=0,\n                                                   cursor_visible=True,\n                                                   round=True)\n        self.__prop_list = self.__init_props()\n\n        self.__init_signal()\n        # use reset to init values\n        self.__reset()\n\n        ibus_config = bus.get_config()\n        if ibus_config != None:\n            ibus_config.connect('value-changed',\n                                self.__config_value_changed_cb)\n\n    def __get_ibus_version(self):\n        if self.__ibus_version == 0.0:\n            self.__ibus_version = \\\n                IBus.MAJOR_VERSION + IBus.MINOR_VERSION / 1000.0 + \\\n                IBus.MICRO_VERSION / 1000000.0\n        return self.__ibus_version\n\n    # reset values of engine\n    def __reset(self):\n        self.__preedit_ja_string = jastring.JaString(Engine.__typing_mode,\n                                                     self.__latin_with_shift)\n        self.__convert_chars = u''\n        self.__cursor_pos = 0\n        self.__convert_mode = CONV_MODE_OFF\n        self.__segments = list()\n        self.__lookup_table.clear()\n        self.__lookup_table_visible = False\n        self._MM = 0\n        self._SS = 0\n        self._H = 0\n        self._RMM = 0\n        self._RSS = 0\n        if self.__idle_id != 0:\n            GLib.source_remove(self.__idle_id)\n            self.__idle_id = 0\n\n    def __init_props(self):\n        anthy_props = IBus.PropList()\n\n        self.__set_input_mode_props(anthy_props)\n        self.__set_typing_method_props(anthy_props)\n        self.__set_segment_mode_props(anthy_props)\n        self.__set_dict_mode_props(anthy_props)\n        self.__set_dict_config_props(anthy_props)\n\n        if not self.__prefs.get_value('common', 'show-preferences'):\n            return anthy_props\n\n        anthy_props.append(IBus.Property(key=u'setup',\n                                         label=IBus.Text.new_from_string(_(\"Preferences - Anthy\")),\n                                         icon=config.ICON_PREFERENCE,\n                                         tooltip=IBus.Text.new_from_string(_(\"Configure Anthy\")),\n                                         sensitive=True,\n                                         visible=True))\n\n        return anthy_props\n\n    def __init_signal(self):\n        signal.signal(signal.SIGHUP, self.__signal_cb)\n        signal.signal(signal.SIGINT, self.__signal_cb)\n        signal.signal(signal.SIGQUIT, self.__signal_cb)\n        signal.signal(signal.SIGABRT, self.__signal_cb)\n        signal.signal(signal.SIGTERM, self.__signal_cb)\n\n    def __signal_cb(self, signum, object):\n        self.__remove_dict_files()\n        signal.signal(signum, signal.SIG_DFL)\n        os.kill(os.getpid(), signum)\n\n    def __set_input_mode_props(self, anthy_props):\n        # The class method is kept even if the engine is switched.\n        if Engine.__input_mode == None:\n            # The config value is readonly for initial engine and\n            # the engine keeps the class method in the memory.\n            Engine.__input_mode = INPUT_MODE_HIRAGANA\n            Engine.__input_mode = self.__prefs.get_value('common',\n                                                         'input_mode')\n\n        if not self.__prefs.get_value('common', 'show-input-mode'):\n            return\n\n        # init input mode properties\n        symbol = '\u3042'\n        '''\n        Need to split _() by line for intltool to detect them.\n        '''\n        # Translators: Specify the order of %s with your translation.\n        # It will be \"Input Mode (A)\" for example.\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Input mode\"), 'symbol' : symbol }\n        input_mode_prop = IBus.Property(key=u'InputMode',\n                                        prop_type=IBus.PropType.MENU,\n                                        label=IBus.Text.new_from_string(label),\n                                        symbol=IBus.Text.new_from_string(symbol),\n                                        icon='',\n                                        tooltip=IBus.Text.new_from_string(_(\"Switch input mode\")),\n                                        sensitive=True,\n                                        visible=True,\n                                        state=IBus.PropState.UNCHECKED,\n                                        sub_props=None)\n        self.__prop_dict[u'InputMode'] = input_mode_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'InputMode.Hiragana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Hiragana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.Katakana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Katakana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.HalfWidthKatakana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Halfwidth Katakana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.Latin',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Latin\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'InputMode.WideLatin',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Wide Latin\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n\n        props.get(Engine.__input_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        input_mode_prop.set_sub_props(props)\n        anthy_props.append(input_mode_prop)\n\n        mode = Engine.__input_mode\n        mode = 'InputMode.' + ['Hiragana', 'Katakana', 'HalfWidthKatakana',\n                               'Latin', 'WideLatin'][mode]\n        self.__input_mode_activate(mode, IBus.PropState.CHECKED)\n\n    def __set_typing_method_props(self, anthy_props):\n        if Engine.__typing_mode == None:\n            Engine.__typing_mode = jastring.TYPING_MODE_ROMAJI\n            Engine.__typing_mode = self.__prefs.get_value('common',\n                                                          'typing_method')\n\n        if not self.__prefs.get_value('common', 'show-typing-method'):\n            return\n\n        # typing input mode properties\n        symbol = 'R'\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Typing method\"), 'symbol' : symbol }\n        typing_mode_prop = IBus.Property(key=u'TypingMode',\n                                         prop_type=IBus.PropType.MENU,\n                                         label=IBus.Text.new_from_string(label),\n                                         symbol=IBus.Text.new_from_string(symbol),\n                                         icon='',\n                                         tooltip=IBus.Text.new_from_string(_(\"Switch typing method\")),\n                                         sensitive=True,\n                                         visible=True,\n                                         state=IBus.PropState.UNCHECKED,\n                                         sub_props=None)\n        self.__prop_dict[u'TypingMode'] = typing_mode_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'TypingMode.Romaji',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Romaji\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'TypingMode.Kana',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Kana\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'TypingMode.ThumbShift',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Thumb shift\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.get(Engine.__typing_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        typing_mode_prop.set_sub_props(props)\n        anthy_props.append(typing_mode_prop)\n\n        mode = Engine.__typing_mode\n        mode = 'TypingMode.' + ['Romaji', 'Kana', 'ThumbShift'][mode]\n        self.__typing_mode_activate(mode, IBus.PropState.CHECKED)\n\n    def __set_segment_mode_props(self, anthy_props):\n        if Engine.__segment_mode == None:\n            Engine.__segment_mode = SEGMENT_DEFAULT\n            Engine.__segment_mode = self.__prefs.get_value('common',\n                                                           'conversion_segment_mode')\n\n        if not self.__prefs.get_value('common', 'show-segment-mode'):\n            return\n\n        symbol = '\u9023'\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Segment mode\"), 'symbol' : symbol }\n        segment_mode_prop = IBus.Property(key=u'SegmentMode',\n                                          prop_type=IBus.PropType.MENU,\n                                          label=IBus.Text.new_from_string(label),\n                                          symbol=IBus.Text.new_from_string(symbol),\n                                          icon=None,\n                                          tooltip=IBus.Text.new_from_string(_(\"Switch conversion mode\")),\n                                          sensitive=True,\n                                          visible=True,\n                                          state=IBus.PropState.UNCHECKED,\n                                          sub_props=None)\n        self.__prop_dict[u'SegmentMode'] = segment_mode_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'SegmentMode.Multi',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Multiple segment\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'SegmentMode.Single',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Single segment\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'SegmentMode.ImmediateMulti',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Immediate conversion (multiple segment)\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'SegmentMode.ImmediateSingle',\n                                   prop_type=IBus.PropType.RADIO,\n                                   label=IBus.Text.new_from_string(_(\"Immediate conversion (single segment)\")),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.get(Engine.__segment_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        segment_mode_prop.set_sub_props(props)\n        anthy_props.append(segment_mode_prop)\n\n        mode = Engine.__segment_mode\n        mode = 'SegmentMode.' + ['Multi', 'Single',\n                                 'ImmediateMulti', 'ImmediateSingle'][mode]\n        self.__segment_mode_activate(mode, IBus.PropState.CHECKED)\n\n    def __set_dict_mode_props(self, anthy_props, update_prop=False):\n        if Engine.__dict_mode == None:\n            Engine.__dict_mode = 0\n\n        if not self.__prefs.get_value('common', 'show-dict-mode'):\n            return\n\n        short_label = self.__prefs.get_value('dict/file/embedded',\n                                             'short_label')\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Dictionary mode\"), 'symbol' : short_label }\n        dict_mode_prop = IBus.Property(key=u'DictMode',\n                                       prop_type=IBus.PropType.MENU,\n                                       label=IBus.Text.new_from_string(label),\n                                       symbol=IBus.Text.new_from_string(short_label),\n                                       icon=None,\n                                       tooltip=IBus.Text.new_from_string(_(\"Switch dictionary\")),\n                                       sensitive=True,\n                                       visible=True,\n                                       state=IBus.PropState.UNCHECKED,\n                                       sub_props=None)\n        self.__prop_dict[u'DictMode'] = dict_mode_prop\n        props = IBus.PropList()\n\n        long_label = self.__prefs.get_value('dict/file/embedded',\n                                            'long_label')\n        props.append(IBus.Property(key=u'DictMode.embedded',\n                                   prop_type=IBus.PropType.RADIO,\n                                   # if long_label is UTF-8\n                                   label=IBus.Text.new_from_string(UN(_(long_label))),\n                                   icon=None,\n                                   tooltip=None,\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        for file in self.__prefs.get_value('dict', 'files'):\n            if not self.__link_dict_file(file):\n                continue\n            id = self.__get_dict_id_from_file(file)\n            section = 'dict/file/' + id\n            if not self.__prefs.get_value(section, 'single'):\n                continue\n            key = 'DictMode.' + id\n            long_label = self.__prefs.get_value(section, 'long_label')\n\n            # ibus-config 'value-changed' signal updated dict/files but\n            # not dict/file/new yet.\n            if long_label == None:\n                continue\n\n            # if long_label is UTF-8\n            if 'is_system' in self.__prefs.keys(section) and \\\n               self.__prefs.get_value(section, 'is_system'):\n                uni_long_label = UN(_(long_label))\n            else:\n                uni_long_label = UN(long_label)\n            props.append(IBus.Property(key=UN(key),\n                                       prop_type=IBus.PropType.RADIO,\n                                       label=IBus.Text.new_from_string(uni_long_label),\n                                       icon=None,\n                                       tooltip=None,\n                                       sensitive=True,\n                                       visible=True,\n                                       state=IBus.PropState.UNCHECKED,\n                                       sub_props=None))\n\n        props.get(Engine.__dict_mode).set_state(IBus.PropState.CHECKED)\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        dict_mode_prop.set_sub_props(props)\n\n        if update_prop:\n            # focus-in event will call register_properties().\n            # Need to switch another IME to update menus on GtkStatusIcon?\n            anthy_props.update_property(dict_mode_prop)\n        else:\n            anthy_props.append(dict_mode_prop)\n\n        prop_name = self.__dict_mode_get_prop_name(Engine.__dict_mode)\n        if prop_name == None:\n            return\n        self.__dict_mode_activate(prop_name,\n                                  IBus.PropState.CHECKED)\n\n    def __set_dict_config_props(self, anthy_props):\n        if not self.__prefs.get_value('common', 'show-dict-config'):\n            return\n\n        admin_command = self.__prefs.get_value('common', 'dict_admin_command')\n        icon_path = self.__prefs.get_value('common', 'dict_config_icon')\n\n        if not path.exists(admin_command[0]):\n            return\n        label = _(\"Dictionary - Anthy\")\n        # if icon_path is UTF-8\n        if icon_path and path.exists(icon_path):\n            icon = UN(icon_path)\n        else:\n            # Translators: \"Dic\" means 'dictionary', One kanji may be good.\n            label = _(\"Dic\")\n            icon = u''\n\n        dict_prop = IBus.Property(key=u'setup-dict-kasumi',\n                                  prop_type=IBus.PropType.MENU,\n                                  label=IBus.Text.new_from_string(label),\n                                  icon=icon,\n                                  tooltip=IBus.Text.new_from_string(_(\"Configure dictionaries\")),\n                                  sensitive=True,\n                                  visible=True,\n                                  state=IBus.PropState.UNCHECKED,\n                                  sub_props=None)\n        self.__prop_dict[u'setup-dict-kasumi'] = dict_prop\n\n        props = IBus.PropList()\n        props.append(IBus.Property(key=u'setup-dict-kasumi-admin',\n                                   prop_type=IBus.PropType.NORMAL,\n                                   label=IBus.Text.new_from_string(_(\"Edit dictionaries\")),\n                                   icon=icon,\n                                   tooltip=IBus.Text.new_from_string(_(\"Launch the dictionary tool\")),\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n        props.append(IBus.Property(key=u'setup-dict-kasumi-word',\n                                   prop_type=IBus.PropType.NORMAL,\n                                   label=IBus.Text.new_from_string(_(\"Add words\")),\n                                   icon=icon,\n                                   tooltip=IBus.Text.new_from_string(_(\"Add words to the dictionary\")),\n                                   sensitive=True,\n                                   visible=True,\n                                   state=IBus.PropState.UNCHECKED,\n                                   sub_props=None))\n\n        i = 0\n        while props.get(i) != None:\n            prop = props.get(i)\n            self.__prop_dict[prop.get_key()] = prop\n            i += 1\n\n        dict_prop.set_sub_props(props)\n        anthy_props.append(dict_prop)\n\n    def __get_clipboard(self, clipboard, text, data):\n        clipboard_text = clipboard.wait_for_text ()\n\n        if data == CLIPBOARD_RECONVERT:\n            self.__update_reconvert(clipboard_text)\n\n        return clipboard_text\n\n    def __get_single_dict_files(self):\n        files = self.__prefs.get_value('dict', 'files')\n        single_files = []\n        for file in files:\n            id = self.__get_dict_id_from_file(file)\n            section = 'dict/file/' + id\n            if self.__prefs.get_value(section, 'single'):\n                single_files.append(file)\n        return single_files\n\n    def __remove_dict_files(self):\n        for file in self.__prefs.get_value('dict', 'files'):\n            self.__remove_dict_file(file)\n\n    def update_preedit(self, string, attrs, cursor_pos, visible):\n        text = IBus.Text.new_from_string(string)\n        i = 0\n        while attrs.get(i) != None:\n            attr = attrs.get(i)\n            text.append_attribute(attr.get_attr_type(),\n                                  attr.get_value(),\n                                  attr.get_start_index(),\n                                  attr.get_end_index())\n            i += 1\n        mode = self.__prefs.get_value('common', 'behavior_on_focus_out')\n        if self.__get_ibus_version() >= 1.003 and mode == 1:\n            self.update_preedit_text_with_mode(text,\n                                               cursor_pos, visible,\n                                               IBus.PreeditFocusMode.COMMIT)\n        else:\n            self.update_preedit_text(text,\n                                     cursor_pos, visible)\n\n    def update_aux_string(self, string, attrs, visible):\n        text = IBus.Text.new_from_string(string)\n        i = 0\n        while attrs.get(i) != None:\n            attr = attrs.get(i)\n            text.append_attribute(attr.get_attr_type(),\n                                  attr.get_value(),\n                                  attr.get_start_index(),\n                                  attr.get_end_index())\n            i += 1\n        self.update_auxiliary_text(text, visible)\n\n    def do_page_up(self):\n        # only process cursor down in convert mode\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return False\n\n        if not self.__lookup_table.page_up():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_page_down(self):\n        # only process cursor down in convert mode\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return False\n\n        if not self.__lookup_table.page_down():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_cursor_up(self):\n        # only process cursor down in convert mode\n        # if self.__convert_mode != CONV_MODE_ANTHY:\n        if self.__convert_mode != CONV_MODE_ANTHY and self.__convert_mode != CONV_MODE_PREDICTION:\n            return False\n\n        if not self.__lookup_table.cursor_up():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_cursor_down(self):\n        # only process cursor down in convert mode\n        # if self.__convert_mode != CONV_MODE_ANTHY:\n        if self.__convert_mode != CONV_MODE_ANTHY and self.__convert_mode != CONV_MODE_PREDICTION:\n            return False\n\n        if not self.__lookup_table.cursor_down():\n            return False\n\n        index = self.__lookup_table.get_cursor_pos()\n        # if candidate is UTF-8\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__invalidate()\n        return True\n\n    def do_candidate_clicked(self, index, button, state):\n        if index == 9:\n            keyval = IBus.KEY_0\n        else:\n            keyval = IBus.KEY_1 + index\n        self.__on_key_number(keyval)\n\n    def __commit_string(self, text):\n        self.__reset()\n        self.commit_text(IBus.Text.new_from_string(text))\n        self.__invalidate()\n\n    def __shrink_segment(self, relative_size):\n        self.__context.resize_segment(self.__cursor_pos, relative_size)\n        nr_segments = self.__context.get_nr_segments()\n        del self.__segments[self.__cursor_pos:]\n        for i in xrange(self.__cursor_pos, nr_segments):\n            buf = self.__context.get_segment(i, 0)\n            text = UN(buf)\n            self.__segments.append((0, text))\n        self.__lookup_table_visible = False\n        self.__fill_lookup_table()\n        self.__invalidate()\n        return True\n\n    def do_process_key_event(self, keyval, keycode, state):\n        try:\n            return self.__process_key_event_internal2(keyval, keycode, state)\n        except:\n            import traceback\n            traceback.print_exc()\n            return False\n\n    def do_property_activate(self, prop_name, state):\n\n        if state == IBus.PropState.CHECKED:\n            if prop_name == None:\n                return\n            elif prop_name.startswith(u'InputMode.'):\n                self.__input_mode_activate(prop_name, state)\n                return\n            elif prop_name.startswith(u'TypingMode.'):\n                self.__typing_mode_activate(prop_name, state)\n                return\n            elif prop_name.startswith(u'SegmentMode.'):\n                self.__segment_mode_activate(prop_name, state)\n                return\n            elif prop_name.startswith(u'DictMode.'):\n                self.__dict_mode_activate(prop_name, state)\n                return\n        else:\n            if prop_name == 'setup':\n                self.__start_setup()\n            elif prop_name == 'setup-dict-kasumi-admin':\n                self.__start_dict_admin()\n            elif prop_name == 'setup-dict-kasumi-word':\n                self.__start_add_word()\n            else:\n                self.__prop_dict[prop_name].set_state(state)\n                if prop_name == 'DictMode':\n                    sub_name = self.__dict_mode_get_prop_name(self.__dict_mode)\n                    if sub_name == None:\n                        return\n                    self.__dict_mode_activate(sub_name,\n                                              IBus.PropState.CHECKED)\n\n    def __input_mode_activate(self, prop_name, state):\n        input_modes = {\n            u'InputMode.Hiragana' : (INPUT_MODE_HIRAGANA, '\u3042'),\n            u'InputMode.Katakana' : (INPUT_MODE_KATAKANA, '\u30a2'),\n            u'InputMode.HalfWidthKatakana' : (INPUT_MODE_HALF_WIDTH_KATAKANA, '_\uff71'),\n            u'InputMode.Latin' : (INPUT_MODE_LATIN, '_A'),\n            u'InputMode.WideLatin' : (INPUT_MODE_WIDE_LATIN, '\uff21'),\n        }\n\n        if prop_name not in input_modes:\n            print >> sys.stderr, 'Unknown prop_name = %s' % prop_name\n            return\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n\n        mode, symbol = input_modes[prop_name]\n\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Input mode\"), 'symbol' : symbol }\n        Engine.__input_mode = mode\n        prop = self.__prop_dict[u'InputMode']\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__reset()\n        self.__invalidate()\n\n    def __typing_mode_activate(self, prop_name, state):\n        typing_modes = {\n            u'TypingMode.Romaji' : (jastring.TYPING_MODE_ROMAJI, 'R'),\n            u'TypingMode.Kana' : (jastring.TYPING_MODE_KANA, '\u304b'),\n            u'TypingMode.ThumbShift' : (jastring.TYPING_MODE_THUMB_SHIFT, '\u89aa'),\n        }\n\n        if prop_name not in typing_modes:\n            print >> sys.stderr, 'Unknown prop_name = %s' % prop_name\n            return\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n        if prop_name == u'TypingMode.ThumbShift':\n            self._reset_thumb()\n\n        mode, symbol = typing_modes[prop_name]\n\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Typing method\"), 'symbol' : symbol }\n        Engine.__typing_mode = mode\n        prop = self.__prop_dict[u'TypingMode']\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__reset()\n        self.__invalidate()\n\n    def __refresh_typing_mode_property(self):\n        if u'TypingMode' not in self.__prop_dict:\n            return\n\n        prop = self.__prop_dict[u'TypingMode']\n        modes = {\n            jastring.TYPING_MODE_ROMAJI : (u'TypingMode.Romaji', 'R'),\n            jastring.TYPING_MODE_KANA : (u'TypingMode.Kana', '\u304b'),\n            jastring.TYPING_MODE_THUMB_SHIFT : (u'TypingMode.ThumbShift', '\u89aa'),\n        }\n        prop_name, symbol = modes.get(Engine.__typing_mode, (None, None))\n        if prop_name == None or symbol == None:\n            return\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Typing method\"), 'symbol' : symbol }\n        _prop = self.__prop_dict[prop_name]\n        _prop.set_state(IBus.PropState.CHECKED)\n        self.update_property(_prop)\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n    def __segment_mode_activate(self, prop_name, state):\n        segment_modes = {\n            u'SegmentMode.Multi' : (SEGMENT_DEFAULT, '\u9023'),\n            u'SegmentMode.Single' : (SEGMENT_SINGLE, '\u5358'),\n            u'SegmentMode.ImmediateMulti' : (SEGMENT_IMMEDIATE, '\u9010|\u9023'),\n            u'SegmentMode.ImmediateSingle' :\n                (SEGMENT_IMMEDIATE | SEGMENT_SINGLE, '\u9010|\u5358'),\n        }\n\n        if prop_name not in segment_modes:\n            print >> sys.stderr, 'Unknown prop_name = %s' % prop_name\n            return\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n\n        mode, symbol = segment_modes[prop_name]\n\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Segment mode\"), 'symbol' : symbol }\n        Engine.__segment_mode = mode\n        prop = self.__prop_dict[u'SegmentMode']\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__reset()\n        self.__invalidate()\n\n    def __dict_mode_get_prop_name(self, mode):\n        if mode == 0:\n            id = 'embedded'\n        else:\n            single_files = self.__get_single_dict_files()\n            file = single_files[mode - 1]\n            id = self.__get_dict_id_from_file(file)\n        return 'DictMode.' + id\n\n    def __dict_mode_activate(self, prop_name, state):\n        if prop_name not in self.__prop_dict.keys():\n            # The prop_name is added. Need to restart.\n            return\n        i = prop_name.find('.')\n        if i < 0:\n            return\n        # The id is already quoted.\n        id = prop_name[i + 1:]\n\n        file = None\n        single_files = self.__get_single_dict_files()\n\n        if id == 'embedded':\n            pass\n        else:\n            found = False\n            for file in single_files:\n                if id == self.__get_quoted_id(file):\n                    found = True\n                    break\n            if found == False:\n                return\n\n        if id == 'embedded':\n            dict_name = 'default'\n            Engine.__dict_mode = 0\n        else:\n            if file not in single_files:\n                print >> sys.stderr, \"Index error \", file, single_files\n                return\n            dict_name = 'ibus__' + id\n            Engine.__dict_mode = single_files.index(file) + 1\n        self.__prop_dict[prop_name].set_state(state)\n        self.update_property(self.__prop_dict[prop_name])\n        self.__context.init_personality()\n        # dict_name is unicode but the argument is str.\n        self.__context.do_set_personality(str(dict_name))\n\n        prop = self.__prop_dict[u'DictMode']\n        section = 'dict/file/' + id\n        symbol = self.__prefs.get_value(section, 'short_label')\n        label = _(\"%(description)s (%(symbol)s)\") % \\\n            { 'description' : _(\"Dictionary mode\"), 'symbol' : symbol }\n        prop.set_symbol(IBus.Text.new_from_string(symbol))\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n    def __argb(self, a, r, g, b):\n        return ((a & 0xff)<<24) + ((r & 0xff) << 16) + ((g & 0xff) << 8) + (b & 0xff)\n\n    def __rgb(self, r, g, b):\n        return self.__argb(255, r, g, b)\n\n    def do_focus_in(self):\n        self.register_properties(self.__prop_list)\n        self.__refresh_typing_mode_property()\n        mode = self.__prefs.get_value('common', 'behavior_on_focus_out')\n        if mode == 2:\n            self.__update_input_chars()\n#        self.__reset()\n#        self.__invalidate()\n        size = self.__prefs.get_value('common', 'page_size')\n        if size != self.__lookup_table.get_page_size():\n            self.__lookup_table.set_page_size(size)\n\n    def do_focus_out(self):\n        if self.__has_input_purpose:\n            self.__input_purpose = 0\n        mode = self.__prefs.get_value('common', 'behavior_on_focus_out')\n        if mode == 0 or mode == 1:\n            self.__reset()\n            self.__invalidate()\n\n    def do_set_content_type(self, purpose, hints):\n        if self.__has_input_purpose:\n            self.__input_purpose = purpose\n\n    def do_disable(self):\n        self.__reset()\n        self.__invalidate()\n\n    def do_reset(self):\n        self.__reset()\n        self.__invalidate()\n\n    def do_destroy(self):\n        if self.__idle_id != 0:\n            GLib.source_remove(self.__idle_id)\n            self.__idle_id = 0\n        self.__remove_dict_files()\n        # It seems the parent do_destroy and destroy are different.\n        # The parent do_destroy calls self destroy infinitely.\n        super(Engine,self).destroy()\n\n    def __join_all_segments(self):\n        while True:\n            nr_segments = self.__context.get_nr_segments()\n            seg = nr_segments - self.__cursor_pos\n\n            if seg > 1:\n                self.__context.resize_segment(self.__cursor_pos, 1)\n            else:\n                break\n\n    def __normalize_preedit(self, preedit):\n        if not self.__is_utf8:\n            return preedit\n        for key in romaji_normalize_rule.keys():\n            if preedit.find(key) >= 0:\n                for value in romaji_normalize_rule[key]:\n                    preedit = preedit.replace(key, value)\n        return preedit\n\n    # begine convert\n    def __begin_anthy_convert(self):\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            self.__end_anthy_convert()\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return\n        self.__convert_mode = CONV_MODE_ANTHY\n\n#        text, cursor = self.__preedit_ja_string.get_hiragana()\n        text, cursor = self.__preedit_ja_string.get_hiragana(True)\n\n        text = self.__normalize_preedit(text)\n        self.__context.set_string(text.encode('utf8'))\n        if Engine.__segment_mode & SEGMENT_SINGLE:\n            self.__join_all_segments()\n        nr_segments = self.__context.get_nr_segments()\n\n        for i in xrange(0, nr_segments):\n            buf = self.__context.get_segment(i, 0)\n            text = UN(buf)\n            self.__segments.append((0, text))\n\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            self.__cursor_pos = nr_segments - 1\n        else:\n            self.__cursor_pos = 0\n        self.__fill_lookup_table()\n        self.__lookup_table_visible = False\n\n    def __end_anthy_convert(self):\n        if self.__convert_mode == CONV_MODE_OFF:\n            return\n\n        self.__convert_mode = CONV_MODE_OFF\n        self.__convert_chars = u''\n        self.__segments = list()\n        self.__cursor_pos = 0\n        self.__lookup_table.clear()\n        self.__lookup_table_visible = False\n\n    def __end_convert(self):\n        self.__end_anthy_convert()\n\n    # test case 'verudhi' can show U+3046 + U+309B and U+3094\n    def __candidate_cb(self, candidate):\n        if not self.__is_utf8:\n            return\n        for key in romaji_utf8_rule.keys():\n            if candidate.find(key) >= 0:\n                for value in romaji_utf8_rule[key]:\n                    candidate = candidate.replace(key, value)\n                    self.__lookup_table.append_candidate(IBus.Text.new_from_string(candidate))\n\n    def __fill_lookup_table(self):\n        if self.__convert_mode == CONV_MODE_PREDICTION:\n            nr_predictions = self.__context.get_nr_predictions()\n\n            # fill lookup_table\n            self.__lookup_table.clear()\n            for i in xrange(0, seg_stat.nr_predictions):\n                buf = self.__context.get_prediction(i)\n                candidate = UN(buf)\n                self.__lookup_table.append_candidate(IBus.Text.new_from_string(candidate))\n                self.__candidate_cb(candidate)\n            return\n\n        # get segment stat\n        nr_candidates = self.__context.get_nr_candidates(self.__cursor_pos)\n\n        # fill lookup_table\n        self.__lookup_table.clear()\n        for i in xrange(0, nr_candidates):\n            buf = self.__context.get_segment(self.__cursor_pos, i)\n            candidate = UN(buf)\n            self.__lookup_table.append_candidate(IBus.Text.new_from_string(candidate))\n            self.__candidate_cb(candidate)\n\n\n    def __invalidate(self):\n        if self.__idle_id != 0:\n            return\n        self.__idle_id = GLib.idle_add(self.__update,\n                                       priority = GLib.PRIORITY_LOW)\n\n#    def __get_preedit(self):\n    def __get_preedit(self, commit=False):\n        if Engine.__input_mode == INPUT_MODE_HIRAGANA:\n#            text, cursor = self.__preedit_ja_string.get_hiragana()\n            text, cursor = self.__preedit_ja_string.get_hiragana(commit)\n        elif Engine.__input_mode == INPUT_MODE_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_katakana()\n            text, cursor = self.__preedit_ja_string.get_katakana(commit)\n        elif Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_half_width_katakana()\n            text, cursor = self.__preedit_ja_string.get_half_width_katakana(commit)\n        else:\n            text, cursor = u'', 0\n        return text, cursor\n\n    def __update_input_chars(self):\n        text, cursor = self.__get_preedit()\n        attrs = IBus.AttrList()\n        attrs.append(IBus.attr_underline_new(\n            IBus.AttrUnderline.SINGLE, 0,\n            len(text)))\n\n        self.update_preedit(text,\n            attrs, cursor, not self.__preedit_ja_string.is_empty())\n        self.update_aux_string(u'', IBus.AttrList(), False)\n        self.update_lookup_table(self.__lookup_table,\n            self.__lookup_table_visible)\n\n    def __update_convert_chars(self):\n#        if self.__convert_mode == CONV_MODE_ANTHY:\n        if self.__convert_mode == CONV_MODE_ANTHY or self.__convert_mode == CONV_MODE_PREDICTION:\n            self.__update_anthy_convert_chars()\n            return\n        if self.__convert_mode == CONV_MODE_HIRAGANA:\n#            text, cursor = self.__preedit_ja_string.get_hiragana()\n            text, cursor = self.__preedit_ja_string.get_hiragana(True)\n        elif self.__convert_mode == CONV_MODE_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_katakana()\n            text, cursor = self.__preedit_ja_string.get_katakana(True)\n        elif self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n#            text, cursor = self.__preedit_ja_string.get_half_width_katakana()\n            text, cursor = self.__preedit_ja_string.get_half_width_katakana(True)\n        elif self.__convert_mode == CONV_MODE_LATIN_0:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            if text == text.lower():\n                self.__convert_mode = CONV_MODE_LATIN_1\n        elif self.__convert_mode == CONV_MODE_LATIN_1:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            text = text.lower()\n        elif self.__convert_mode == CONV_MODE_LATIN_2:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            text = text.upper()\n        elif self.__convert_mode == CONV_MODE_LATIN_3:\n            text, cursor = self.__preedit_ja_string.get_latin()\n            text = text.capitalize()\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_0:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            if text == text.lower():\n                self.__convert_mode = CONV_MODE_WIDE_LATIN_1\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_1:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            text = text.lower()\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_2:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            text = text.upper()\n        elif self.__convert_mode == CONV_MODE_WIDE_LATIN_3:\n            text, cursor = self.__preedit_ja_string.get_wide_latin()\n            text = text.capitalize()\n        self.__convert_chars = text\n        attrs = IBus.AttrList()\n        attrs.append(IBus.attr_underline_new(\n            IBus.AttrUnderline.SINGLE, 0, len(text)))\n        attrs.append(IBus.attr_background_new(self.__rgb(200, 200, 240),\n            0, len(text)))\n        attrs.append(IBus.attr_foreground_new(self.__rgb(0, 0, 0),\n            0, len(text)))\n        self.update_preedit(text, attrs, len(text), True)\n\n        self.update_aux_string(u'',\n            IBus.AttrList(), self.__lookup_table_visible)\n        self.update_lookup_table(self.__lookup_table,\n            self.__lookup_table_visible)\n\n    def __update_anthy_convert_chars(self):\n        self.__convert_chars = u''\n        pos = 0\n        for i, (seg_index, text) in enumerate(self.__segments):\n            self.__convert_chars += text\n            if i < self.__cursor_pos:\n                pos += len(text)\n        attrs = IBus.AttrList()\n        attrs.append(IBus.attr_underline_new(\n            IBus.AttrUnderline.SINGLE, 0, len(self.__convert_chars)))\n        attrs.append(IBus.attr_background_new(self.__rgb(200, 200, 240),\n                pos, pos + len(self.__segments[self.__cursor_pos][1])))\n        attrs.append(IBus.attr_foreground_new(self.__rgb(0, 0, 0),\n                pos, pos + len(self.__segments[self.__cursor_pos][1])))\n        self.update_preedit(self.__convert_chars, attrs, pos, True)\n        aux_string = u'( %d / %d )' % (self.__lookup_table.get_cursor_pos() + 1, self.__lookup_table.get_number_of_candidates())\n        self.update_aux_string(aux_string,\n            IBus.AttrList(), self.__lookup_table_visible)\n        self.update_lookup_table(self.__lookup_table,\n            self.__lookup_table_visible)\n\n    def __update(self):\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__update_input_chars()\n        else:\n            self.__update_convert_chars()\n        self.__idle_id = 0\n\n    def __on_key_return(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n#            text, cursor = self.__get_preedit()\n            text, cursor = self.__get_preedit(True)\n            self.__commit_string(text)\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            for i, (seg_index, text) in enumerate(self.__segments):\n                self.__context.commit_segment(i, seg_index)\n            self.__commit_string(self.__convert_chars)\n        elif self.__convert_mode == CONV_MODE_PREDICTION:\n            self.__context.commit_prediction(self.__segments[0][0])\n            self.__commit_string(self.__convert_chars)\n        else:\n            self.__commit_string(self.__convert_chars)\n\n        return True\n\n    def __on_key_escape(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        self.__reset()\n        self.__invalidate()\n        return True\n\n    def __on_key_back_space(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode != CONV_MODE_OFF:\n            if self.__lookup_table_visible:\n                if self.__lookup_table.get_number_of_candidates() > 0:\n                    self.__lookup_table.set_cursor_pos(0)\n                candidate = UN(self.__lookup_table.get_candidate(0).get_text())\n                self.__segments[self.__cursor_pos] = 0, candidate\n                self.__lookup_table_visible = False\n            elif self.__segments[self.__cursor_pos][0] != \\\n                    NTH_UNCONVERTED_CANDIDATE:\n                buf = self.__context.get_segment(self.__cursor_pos,\n                                                 NTH_UNCONVERTED_CANDIDATE)\n                self.__segments[self.__cursor_pos] = \\\n                    NTH_UNCONVERTED_CANDIDATE, UN(buf)\n            #elif self._chk_mode('25'):\n                '''\n                # FIXME: Delete the last char in the active segment.\n                #\n                # If we are able to delete a char in the active segment,\n                # we also should be able to add a char in the active segment.\n                # Currently plain preedit, no segment mode, i.e.\n                # using self.__preedit_ja_string, can delete or add a char\n                # but anthy active segoment mode, i.e.\n                # using self.__segments, can not delete or add a char.\n                # Deleting a char could be easy here but adding a char is\n                # difficult because we need to update both self.__segments\n                # and self.__preedit_ja_string but self.__preedit_ja_string\n                # has no segment. To convert self.__segments to\n                # self.__preedit_ja_string, we may use the reconvert mode\n                # but no idea to convert keyvals to hiragana\n                # in self__on_key_common() with multiple key typings.\n\n                # Delete a char in the active segment\n                all_text = u''\n                nr_segments = self.__context.get_nr_segments()\n                for i in xrange(0, nr_segments):\n                    buf = self.__context.get_segment(i,\n                                                     NTH_UNCONVERTED_CANDIDATE)\n                    text = UN(buf)\n                    if i == self.__cursor_pos and len(text) > 0:\n                        text = text[:len(text) - 1]\n                    all_text += text\n\n                if all_text == u'':\n                    return\n\n                # Set self.__preedit_ja_string by anthy context.\n                self.__preedit_ja_string = jastring.JaString(Engine.__typing_mode,\n                                                             self.__latin_with_shift)\n                self.__convert_chars = self.__normalize_preedit(all_text)\n                for i in xrange(0, len(self.__convert_chars)):\n                    keyval = self.__convert_chars[i]\n                    self.__preedit_ja_string.insert(unichr(ord (keyval)))\n                self.__context.set_string(self.__convert_chars.encode('utf8'))\n\n                # Set self.__segments by anty context\n                # for editable self.__segments,\n                # save NTH_UNCONVERTED_CANDIDATE\n                nr_segments = self.__context.get_nr_segments()\n                if self.__cursor_pos >= nr_segments and \\\n                   nr_segments > 0:\n                    self.__cursor_pos = nr_segments - 1\n                for i in xrange(self.__cursor_pos, nr_segments):\n                    if i == self.__cursor_pos:\n                        index = NTH_UNCONVERTED_CANDIDATE\n                    else:\n                        index = 0\n                    buf = self.__context.get_segment(i,\n                                                     index)\n                    text = UN(buf)\n                    self.__segments[i] = index, text\n\n                # Update self.__lookup_table\n                self.__fill_lookup_table()\n                '''\n            else:\n                self.__end_convert()\n        else:\n            self.__preedit_ja_string.remove_before()\n\n        self.__invalidate()\n        return True\n\n    def __on_key_delete(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode != CONV_MODE_OFF:\n            self.__end_convert()\n        else:\n            self.__preedit_ja_string.remove_after()\n\n        self.__invalidate()\n        return True\n\n    '''def __on_key_hiragana_katakana(self):\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__end_anthy_convert()\n\n        if Engine.__input_mode >= INPUT_MODE_HIRAGANA and \\\n           Engine.__input_mode < INPUT_MODE_HALF_WIDTH_KATAKANA:\n            Engine.__input_mode += 1\n        else:\n            Engine.__input_mode = INPUT_MODE_HIRAGANA\n\n        modes = { INPUT_MODE_HIRAGANA: '\u3042',\n                  INPUT_MODE_KATAKANA: '\u30a2',\n                  INPUT_MODE_HALF_WIDTH_KATAKANA: '_\uff71' }\n\n        prop = self.__prop_dict[u'InputMode']\n        label = modes[Engine.__input_mode]\n        prop.set_label(IBus.Text.new_from_string(label))\n        self.update_property(prop)\n\n        self.__invalidate()\n        return True'''\n\n    '''def __on_key_muhenka(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__end_anthy_convert()\n\n        new_mode = CONV_MODE_HIRAGANA\n        if self.__convert_mode < CONV_MODE_WIDE_LATIN_3 and \\\n           self.__convert_mode >= CONV_MODE_HIRAGANA :\n            self.__convert_mode += 1\n        else:\n            self.__convert_mode = CONV_MODE_HIRAGANA\n\n        self.__invalidate()\n\n        return True'''\n\n    '''def __on_key_henkan(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            self.__begin_anthy_convert()\n            self.__invalidate()\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            self.__lookup_table_visible = True\n            self.do_cursor_down()\n        return True'''\n\n    '''def __on_key_space(self, wide=False):\n        if Engine.__input_mode == INPUT_MODE_WIDE_LATIN or wide:\n            # Input Wide space U+3000\n            wide_char = symbol_rule[unichr(IBus.KEY_space)]\n            self.__commit_string(wide_char)\n            return True\n\n        if self.__preedit_ja_string.is_empty():\n            if Engine.__input_mode in (INPUT_MODE_HIRAGANA, INPUT_MODE_KATAKANA):\n                # Input Wide space U+3000\n                wide_char = symbol_rule[unichr(IBus.KEY_space)]\n                self.__commit_string(wide_char)\n                return True\n            else:\n                # Input Half space U+0020\n                self.__commit_string(unichr(IBus.KEY_space))\n                return True\n\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            self.__begin_anthy_convert()\n            self.__invalidate()\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            self.__lookup_table_visible = True\n            self.do_cursor_down()\n        return True'''\n\n    def __on_key_up(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        self.__lookup_table_visible = True\n        self.do_cursor_up()\n        return True\n\n    def __on_key_down(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        self.__lookup_table_visible = True\n        self.do_cursor_down()\n        return True\n\n    def __on_key_page_up(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        if self.__lookup_table_visible == True:\n            self.do_page_up()\n        return True\n\n    def __on_key_page_down(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n        if self.__lookup_table_visible == True:\n            self.do_page_down()\n        return True\n\n    '''def __on_key_left(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__preedit_ja_string.move_cursor(-1)\n            self.__invalidate()\n            return True\n\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return True\n\n        if self.__cursor_pos == 0:\n            return True\n        self.__cursor_pos -= 1\n        self.__lookup_table_visible = False\n        self.__fill_lookup_table()\n        self.__invalidate()\n        return True'''\n\n    def __on_key_right(self):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__preedit_ja_string.move_cursor(1)\n            self.__invalidate()\n            return True\n\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return True\n\n        if self.__cursor_pos + 1 >= len(self.__segments):\n            return True\n\n        self.__cursor_pos += 1\n        self.__lookup_table_visible = False\n        self.__fill_lookup_table()\n        self.__invalidate()\n        return True\n\n    def __on_key_number(self, keyval):\n        if self.__convert_mode != CONV_MODE_ANTHY:\n            return False\n        if not self.__lookup_table_visible:\n            return False\n\n        if keyval == IBus.KEY_0:\n            keyval = IBus.KEY_9 + 1\n        index = keyval - IBus.KEY_1\n\n        return self.__on_candidate_index_in_page(index)\n\n    def __on_key_conv(self, mode):\n        if self.__preedit_ja_string.is_empty():\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__end_anthy_convert()\n\n        if mode == 0 or mode == 1:\n            if self.__convert_mode == CONV_MODE_HIRAGANA + mode:\n                return True\n            self.__convert_mode = CONV_MODE_HIRAGANA + mode\n        elif mode == 2:\n            if self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n                return True\n            self.__convert_mode = CONV_MODE_HALF_WIDTH_KATAKANA\n        elif mode == 3:\n            if CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode <= CONV_MODE_WIDE_LATIN_3:\n                self.__convert_mode += 1\n                if self.__convert_mode > CONV_MODE_WIDE_LATIN_3:\n                    self.__convert_mode = CONV_MODE_WIDE_LATIN_1\n            else:\n                self.__convert_mode = CONV_MODE_WIDE_LATIN_0\n        elif mode == 4:\n            if CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n                self.__convert_mode += 1\n                if self.__convert_mode > CONV_MODE_LATIN_3:\n                    self.__convert_mode = CONV_MODE_LATIN_1\n            else:\n                self.__convert_mode = CONV_MODE_LATIN_0\n        else:\n            print >> sys.stderr, 'Unkown convert mode (%d)!' % mode\n            return False\n        self.__invalidate()\n        return True\n\n    def __on_key_common(self, keyval, state=0):\n\n        # If use-system-layout is FALSE in ibus 1.4.y or lower,\n        # ibus converts the keymap and ibus-anthy needed to use\n        # self.__commit_string\n        # ibus 1.5.y uses XKB directly so Latin mode can return FALSE.\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return False\n\n        elif Engine.__input_mode == INPUT_MODE_WIDE_LATIN:\n            #  Input Wide Latin chars\n            char = unichr(keyval)\n            wide_char = None#symbol_rule.get(char, None)\n            if wide_char == None:\n                wide_char = unichar_half_to_full(char)\n            self.__commit_string(wide_char)\n            return True\n\n        # Input Japanese\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            # Commit nothing\n            pass\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            for i, (seg_index, text) in enumerate(self.__segments):\n                self.__context.commit_segment(i, seg_index)\n            self.__commit_string(self.__convert_chars)\n        elif self.__convert_mode != CONV_MODE_OFF:\n            self.__commit_string(self.__convert_chars)\n\n        # 'n' + '\\'' == 'nn' in romaji\n        if (keyval >= ord('A') and keyval <= ord('Z')) or \\\n           (keyval >= ord('a') and keyval <= ord('z')):\n            shift = (state & IBus.ModifierType.SHIFT_MASK) != 0\n        else:\n            shift = False\n        self.__preedit_ja_string.set_shift(shift)\n        self.__preedit_ja_string.insert(unichr(keyval))\n        if Engine.__segment_mode & SEGMENT_IMMEDIATE:\n            self.__begin_anthy_convert()\n        self.__invalidate()\n        return True\n\n#=======================================================================\n    @classmethod\n    def CONFIG_RELOADED(cls, bus):\n        if config.DEBUG:\n            print 'RELOADED'\n        if not cls.__prefs:\n            cls.__prefs = AnthyPrefs(bus)\n            cls._init_prefs()\n\n        cls.__keybind = cls._mk_keybind()\n\n        jastring.JaString.SET_PREFS(cls.__prefs)\n\n    @classmethod\n    def CONFIG_VALUE_CHANGED(cls, bus, section, name, variant):\n        if config.DEBUG:\n            print 'VALUE_CHAMGED =', section, name, variant\n\n        if not section.startswith('engine/anthy'):\n            # This value is used for IBus.config.set_value only.\n            return\n\n        # The key was deleted by dconf.\n        # test case: update /desktop/ibus/engine/anthy/thumb/ls\n        # and reset the key with dconf direclty.\n        if variant.get_type_string() == '()':\n            cls.__prefs.undo_item(section, name)\n            return\n\n        value = cls.__prefs.variant_to_value(variant)\n        base_sec = section[len(cls.__prefs._prefix) + 1:]\n        sec = cls._get_shortcut_type()\n        if base_sec == sec:\n            cmd = '_Engine__cmd_' + name\n            old = cls.__prefs.get_value(sec, name)\n            value = value if value != [''] else []\n            for s in set(old).difference(value):\n                cls.__keybind.get(cls._s_to_key(s), []).remove(cmd)\n\n            keys = cls.__prefs.keys(sec)\n            for s in set(value).difference(old):\n                cls.__keybind.setdefault(cls._s_to_key(s), []).append(cmd)\n                cls.__keybind.get(cls._s_to_key(s)).sort(\n                    lambda a, b: cmp(keys.index(a[13:]), keys.index(b[13:])))\n\n            cls.__prefs.set_value(sec, name, value)\n        elif base_sec == 'common':\n            cls.__prefs.set_value(base_sec, name, value)\n            if name == 'shortcut_type':\n                cls.__keybind = cls._mk_keybind()\n            if name == 'latin_with_shift':\n                cls.__latin_with_shift = value\n                jastring.JaString.RESET(cls.__prefs, base_sec, name, value)\n        elif base_sec.startswith('kana_typing_rule'):\n            jastring.JaString.RESET(cls.__prefs, base_sec, name, value)\n\n    @classmethod\n    def _init_prefs(cls):\n        prefs = cls.__prefs\n        value = prefs.get_value('common', 'latin_with_shift')\n        cls.__latin_with_shift = value\n\n    @classmethod\n    def _mk_keybind(cls):\n        keybind = {}\n        sec = cls._get_shortcut_type()\n        for k in cls.__prefs.keys(sec):\n            cmd = '_Engine__cmd_' + k\n            for s in cls.__prefs.get_value(sec, k):\n                keybind.setdefault(cls._s_to_key(s), []).append(cmd)\n        return keybind\n\n    @classmethod\n    def _get_shortcut_type(cls):\n        try:\n            t = 'shortcut/' + cls.__prefs.get_value('common', 'shortcut_type')\n        except:\n            t = 'shortcut/default'\n        return t\n\n    @classmethod\n    def _s_to_key(cls, s):\n        keyval = IBus.keyval_from_name(s.split('+')[-1])\n        s = s.lower()\n        state = ('shift+' in s and IBus.ModifierType.SHIFT_MASK or 0) | (\n                 'ctrl+' in s and IBus.ModifierType.CONTROL_MASK or 0) | (\n                 'alt+' in s and IBus.ModifierType.MOD1_MASK or 0)\n        return cls._mk_key(keyval, state)\n\n    @classmethod\n    def _reset_thumb(cls):\n        if cls.__thumb == None:\n            import thumb\n            cls.__thumb = thumb.ThumbShiftKeyboard(cls.__prefs)\n\n        else:\n            cls.__thumb.reset()\n\n    @staticmethod\n    def _mk_key(keyval, state):\n        if state & (IBus.ModifierType.CONTROL_MASK | IBus.ModifierType.MOD1_MASK):\n            if keyval < 0xff and \\\n               unichr(keyval) in u'!\"#$%^\\'()*+,-./:;<=>?@[\\]^_`{|}~':\n                state |= IBus.ModifierType.SHIFT_MASK\n            elif IBus.KEY_a <= keyval <= IBus.KEY_z:\n                keyval -= (IBus.KEY_a - IBus.KEY_A)\n\n        return repr([int(state), int(keyval)])\n\n    def process_key_event_thumb(self, keyval, keycode, state):\n        if self.__thumb == None:\n            self._reset_thumb()\n\n        def on_timeout(keyval):\n            if self._MM:\n                insert(self.__thumb.get_char(self._MM)[self._SS])\n            else:\n                cmd_exec([0, RS(), LS()][self._SS])\n            self._H = None\n\n        def start(t):\n            self._H = GLib.timeout_add(t, on_timeout, keyval)\n\n        def stop():\n            if self._H:\n                GLib.source_remove(self._H)\n                self._H = None\n                return True\n            return False\n\n        def insert(keyval):\n            try:\n                self._MM = self._SS = 0\n                ret = self.__on_key_common(ord(keyval))\n                if (keyval in u',.\u3001\u3002' and\n                    self.__prefs.get_value('common', 'behavior_on_period')):\n                    return self.__cmd_convert(keyval, state)\n                return ret\n            except:\n                pass\n\n        def cmd_exec(keyval, state=0):\n            key = self._mk_key(keyval, state)\n            for cmd in self.__keybind.get(key, []):\n                if config.DEBUG:\n                    print 'cmd =', cmd\n                try:\n                    if getattr(self, cmd)(keyval, state):\n                        return True\n                except:\n                    print >> sys.stderr, 'Unknown command = %s' % cmd\n            return False\n\n        def RS():\n            return self.__thumb.get_rs()\n\n        def LS():\n            return self.__thumb.get_ls()\n\n        def T1():\n            return self.__thumb.get_t1()\n\n        def T2():\n            return self.__thumb.get_t2()\n\n        state = state & (IBus.ModifierType.SHIFT_MASK |\n                         IBus.ModifierType.CONTROL_MASK |\n                         IBus.ModifierType.MOD1_MASK |\n                         IBus.ModifierType.RELEASE_MASK)\n\n        if keyval in KP_Table and self.__prefs.get_value('common',\n                                                         'ten_key_mode'):\n            keyval = KP_Table[keyval]\n\n        if state & IBus.ModifierType.RELEASE_MASK:\n            if keyval == self._MM:\n                if stop():\n                    insert(self.__thumb.get_char(self._MM)[self._SS])\n                self._MM = 0\n            elif (1 if keyval == RS() else 2) == self._SS:\n                if stop():\n                    cmd_exec([0, RS(), LS()][self._SS])\n                self._SS = 0\n            if keyval in [RS(), LS()]:\n                self._RSS = 0\n            elif keyval == self._RMM:\n                self._RMM = 0\n        else:\n            if keyval in [LS(), RS()] and state == 0:\n                if self._SS:\n                    stop()\n                    cmd_exec([0, RS(), LS()][self._SS])\n                    self._SS = 1 if keyval == RS() else 2\n                    start(T1())\n                elif self._MM:\n                    stop()\n                    self._RMM = self._MM\n                    self._RSS = 1 if keyval == RS() else 2\n                    insert(self.__thumb.get_char(self._MM)[1 if keyval == RS() else 2])\n                else:\n                    if self._RSS == (1 if keyval == RS() else 2):\n                        if self._RMM:\n                            insert(self.__thumb.get_char(self._RMM)[self._RSS])\n                    else:\n                        self._SS = 1 if keyval == RS() else 2\n                        start(T1())\n            elif keyval in self.__thumb.get_chars() and state == 0:\n                if self._MM:\n                    stop()\n                    insert(self.__thumb.get_char(self._MM)[self._SS])\n                    start(T2())\n                    self._MM = keyval\n                elif self._SS:\n                    stop()\n                    self._RMM = keyval\n                    self._RSS = self._SS\n                    insert(self.__thumb.get_char(keyval)[self._SS])\n                else:\n                    if self._RMM  == keyval:\n                        if self._RSS:\n                            insert(self.__thumb.get_char(self._RMM)[self._RSS])\n                    else:\n                        if cmd_exec(keyval, state):\n                            return True\n                        start(T2())\n                        self._MM = keyval\n            else:\n                if self._MM:\n                    stop()\n                    insert(self.__thumb.get_char(self._MM)[self._SS])\n                elif self._SS:\n                    stop()\n                    cmd_exec([0, RS(), LS()][self._SS])\n                if cmd_exec(keyval, state):\n                    return True\n                elif 0x21 <= keyval <= 0x7e and state & \\\n                        (IBus.ModifierType.CONTROL_MASK | IBus.ModifierType.MOD1_MASK) == 0:\n                    if state & IBus.ModifierType.SHIFT_MASK:\n                        insert(self.__thumb.get_shift_char(keyval, unichr(keyval)))\n                    elif self._SS == 0:\n                        insert(unichr(keyval))\n                else:\n                    if not self.__preedit_ja_string.is_empty():\n                        return True\n                    return False\n        return True\n\n    def __process_key_event_internal2(self, keyval, keycode, state):\n        if self.__has_input_purpose and \\\n           self.__input_purpose == IBus.InputPurpose.PASSWORD:\n            return False\n\n        if Engine.__typing_mode == jastring.TYPING_MODE_THUMB_SHIFT and \\\n           Engine.__input_mode not in [INPUT_MODE_LATIN, INPUT_MODE_WIDE_LATIN]:\n            return self.process_key_event_thumb(keyval, keycode, state)\n\n        is_press = (state & IBus.ModifierType.RELEASE_MASK) == 0\n\n        state = state & (IBus.ModifierType.SHIFT_MASK |\n                         IBus.ModifierType.CONTROL_MASK |\n                         IBus.ModifierType.MOD1_MASK)\n\n        # ignore key release events\n        if not is_press:\n            return False\n\n        if keyval in KP_Table and self.__prefs.get_value('common',\n                                                         'ten_key_mode'):\n            keyval = KP_Table[keyval]\n\n        key = self._mk_key(keyval, state)\n        for cmd in self.__keybind.get(key, []):\n            if config.DEBUG:\n                print 'cmd =', cmd\n            try:\n                if getattr(self, cmd)(keyval, state):\n                    return True\n            except:\n                print >> sys.stderr, 'Unknown command = %s' % cmd\n\n        if state & (IBus.ModifierType.CONTROL_MASK | IBus.ModifierType.MOD1_MASK):\n            return False\n\n        if (IBus.KEY_exclam <= keyval <= IBus.KEY_asciitilde or\n            keyval == IBus.KEY_yen):\n            if Engine.__typing_mode == jastring.TYPING_MODE_KANA:\n                if keyval == IBus.KEY_0 and state == IBus.ModifierType.SHIFT_MASK:\n                    keyval = IBus.KEY_asciitilde\n                elif keyval == IBus.KEY_backslash and keycode in [132-8, 133-8]:\n                    keyval = IBus.KEY_yen\n            ret = self.__on_key_common(keyval, state)\n            if (Engine.__input_mode != INPUT_MODE_LATIN and\n                unichr(keyval) in u',.' and\n                self.__prefs.get_value('common', 'behavior_on_period')):\n                return self.__cmd_convert(keyval, state)\n            return ret\n        else:\n            if not self.__preedit_ja_string.is_empty():\n                return True\n            return False\n\n    def _chk_mode(self, mode):\n        if '0' in mode and self.__preedit_ja_string.is_empty():\n            return True\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            if '1' in mode and not self.__preedit_ja_string.is_empty():\n                return True\n        elif self.__convert_mode == CONV_MODE_ANTHY:\n            if '2' in mode and not self.__lookup_table_visible:\n                return True\n        elif self.__convert_mode == CONV_MODE_PREDICTION:\n            if '3' in mode and not self.__lookup_table_visible:\n                return True\n        else:\n            if '4' in mode:\n                return True\n\n        if '5' in mode and self.__lookup_table_visible:\n            return True\n\n        return False\n\n    def __get_quoted_id(self, file):\n        id = file\n        has_mbcs = False\n\n        for i in xrange(0, len(id)):\n            if ord(id[i]) >= 0x7f:\n                    has_mbcs = True\n                    break\n        if has_mbcs:\n            id = id.encode('hex')\n\n        if id.find('/') >=0:\n            id = id[id.rindex('/') + 1:]\n        if id.find('.') >=0:\n            id = id[:id.rindex('.')]\n\n        if id.startswith('0x'):\n            id = id.encode('hex')\n            has_mbcs = True\n        if has_mbcs:\n            id = '0x' + id\n        return id\n\n    def __get_dict_id_from_file(self, file):\n        return self.__get_quoted_id(file)\n\n    def __link_dict_file_with_id(self, file, id, link_mode):\n        if id == None:\n            return\n        if link_mode == LINK_DICT_EMBEDDED:\n            directory = get_userhome() + '/.anthy/' + IMPORTED_EMBEDDED_DICT_DIR\n            name = IMPORTED_EMBEDDED_DICT_PREFIX + id\n        elif link_mode == LINK_DICT_SINGLE:\n            directory = get_userhome() + '/.anthy'\n            name = IMPORTED_SINGLE_DICT_PREFIX + id\n        else:\n            return\n        if path.exists(directory):\n            if not path.isdir(directory):\n                print >> sys.stderr, directory + ' is not a directory'\n                return\n        else:\n            os.makedirs(directory, 0700)\n        backup_dir = os.getcwd()\n        os.chdir(directory)\n        if path.lexists(directory + '/' + name):\n            if path.islink(directory + '/' + name):\n                print >> sys.stderr, 'Removing ' + name\n                os.unlink(directory + '/' + name)\n            else:\n                alternate = name + str(os.getpid())\n                print >> sys.stderr, 'Moving ' + name + ' to ' + alternate\n                os.rename(name, alternate)\n        os.symlink(file, directory + '/' + name)\n        if backup_dir != None:\n            os.chdir(backup_dir)\n\n    def __remove_dict_file_with_id(self, file, id, link_mode):\n        if id == None:\n            return\n        if link_mode == LINK_DICT_EMBEDDED:\n            directory = get_userhome() + '/.anthy/' + IMPORTED_EMBEDDED_DICT_DIR\n            name = IMPORTED_EMBEDDED_DICT_PREFIX + id\n        elif link_mode == LINK_DICT_SINGLE:\n            directory = get_userhome() + '/.anthy'\n            name = IMPORTED_SINGLE_DICT_PREFIX + id\n        else:\n            return\n        if path.exists(directory):\n            if not path.isdir(directory):\n                print >> sys.stderr, directory + ' is not a directory'\n                return\n        backup_dir = os.getcwd()\n        os.chdir(directory)\n        if path.lexists(directory + '/' + name):\n            os.unlink(directory + '/' + name)\n        if backup_dir != None:\n            os.chdir(backup_dir)\n\n    def __link_dict_file(self, file):\n        if not path.exists(file):\n            print >> sys.stderr, file + ' does not exist'\n            return False\n        id = self.__get_dict_id_from_file(file)\n        section = 'dict/file/' + id\n        if section not in self.__prefs.sections():\n            self.__fetch_dict_values(section)\n        if self.__prefs.get_value(section, 'embed'):\n            self.__link_dict_file_with_id(file, id, LINK_DICT_EMBEDDED)\n        if self.__prefs.get_value(section, 'single'):\n            self.__link_dict_file_with_id(file, id, LINK_DICT_SINGLE)\n        return True\n\n    def __remove_dict_file(self, file):\n        id = self.__get_dict_id_from_file(file)\n        section = 'dict/file/' + id\n        if section not in self.__prefs.sections():\n            self.__fetch_dict_values(section)\n        if self.__prefs.get_value(section, 'embed'):\n            self.__remove_dict_file_with_id(file, id, LINK_DICT_EMBEDDED)\n        if self.__prefs.get_value(section, 'single'):\n            self.__remove_dict_file_with_id(file, id, LINK_DICT_SINGLE)\n\n    def __set_dict_files_value(self, base_sec, name, value):\n        if name == 'files':\n            str_list = []\n            for file in value:\n                str_list.append(self.__prefs.str(file))\n            old_files = self.__prefs.get_value(base_sec, name)\n            for file in old_files:\n                if file in str_list:\n                    continue\n                self.__remove_dict_file(file)\n            for file in str_list:\n                if file in old_files:\n                    continue\n                self.__link_dict_file(file)\n            self.__prefs.set_value(base_sec, name, str_list)\n        else:\n            self.__prefs.set_value(base_sec, name, value)\n\n    def __fetch_dict_values(self, section):\n        self.__prefs.set_new_section(section)\n        self.__prefs.set_new_key(section, 'short_label')\n        self.__prefs.set_no_key_warning(True)\n        self.__prefs.fetch_item(section, 'short_label')\n        self.__prefs.set_new_key(section, 'long_label')\n        self.__prefs.fetch_item(section, 'long_label')\n        self.__prefs.set_new_key(section, 'embed')\n        self.__prefs.fetch_item(section, 'embed')\n        self.__prefs.set_new_key(section, 'single')\n        self.__prefs.fetch_item(section, 'single')\n        self.__prefs.set_new_key(section, 'reverse')\n        self.__prefs.fetch_item(section, 'reverse')\n        self.__prefs.set_no_key_warning(False)\n\n    def __config_value_changed_cb(self, ibus_config, section, name, variant):\n        if config.DEBUG:\n            print 'VALUE_CHAMGED =', section, name, variant\n\n        if not section.startswith('engine/anthy'):\n            # This value is used for IBus.config.set_value only.\n            return\n\n        # The key was deleted by dconf.\n        # test case: update /desktop/ibus/engine/anthy/thumb/ls\n        # and reset the key with dconf direclty.\n        if variant.get_type_string() == '()':\n            self.__prefs.undo_item(section, name)\n            return\n\n        value = self.__prefs.variant_to_value(variant)\n        base_sec = section[len(self.__prefs._prefix) + 1:]\n        sec = self._get_shortcut_type()\n\n        if base_sec == 'thumb':\n            self.__prefs.set_value(base_sec, name, value)\n            self._reset_thumb()\n        elif base_sec == 'dict':\n            self.__set_dict_files_value(base_sec, name, value)\n            self.__set_dict_mode_props(self.__prop_list, True)\n        elif base_sec.startswith('dict/file/'):\n            if base_sec not in self.__prefs.sections():\n                self.__fetch_dict_values(base_sec)\n            self.__prefs.set_value(base_sec, name, value)\n            self.__set_dict_mode_props(self.__prop_list, True)\n        elif base_sec:\n            self.__prefs.set_value(base_sec, name, value)\n        else:\n            self.__prefs.set_value(section, name, value)\n\n    #mod_keys\n    def __set_input_mode(self, mode):\n        self.__input_mode_activate(mode, IBus.PropState.CHECKED)\n        self.__reset()\n        self.__invalidate()\n\n        return True\n\n    def __unset_current_input_mode(self):\n        modes = {\n            INPUT_MODE_HIRAGANA: u'InputMode.Hiragana',\n            INPUT_MODE_KATAKANA: u'InputMode.Katakana',\n            INPUT_MODE_HALF_WIDTH_KATAKANA: u'InputMode.HalfWidthKatakana',\n            INPUT_MODE_LATIN: u'InputMode.Latin',\n            INPUT_MODE_WIDE_LATIN: u'InputMode.WideLatin'\n        }\n        self.__input_mode_activate(modes[Engine.__input_mode],\n                                   IBus.PropState.UNCHECKED)\n\n    def __cmd_on_off(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return self.__set_input_mode(u'InputMode.Hiragana')\n        else:\n            return self.__set_input_mode(u'InputMode.Latin')\n\n    def __cmd_circle_input_mode(self, keyval, state):\n        modes = {\n            INPUT_MODE_HIRAGANA: u'InputMode.Katakana',\n            INPUT_MODE_KATAKANA: u'InputMode.HalfWidthKatakana',\n            INPUT_MODE_HALF_WIDTH_KATAKANA: u'InputMode.Latin',\n            INPUT_MODE_LATIN: u'InputMode.WideLatin',\n            INPUT_MODE_WIDE_LATIN: u'InputMode.Hiragana'\n        }\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(modes[Engine.__input_mode])\n\n    def __cmd_circle_kana_mode(self, keyval, state):\n        modes = {\n            INPUT_MODE_HIRAGANA: u'InputMode.Katakana',\n            INPUT_MODE_KATAKANA: u'InputMode.HalfWidthKatakana',\n            INPUT_MODE_HALF_WIDTH_KATAKANA: u'InputMode.Hiragana',\n            INPUT_MODE_LATIN: u'InputMode.Hiragana',\n            INPUT_MODE_WIDE_LATIN: u'InputMode.Hiragana'\n        }\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(modes[Engine.__input_mode])\n\n    def __cmd_latin_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.Latin')\n\n    def __cmd_wide_latin_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.WideLatin')\n\n    def __cmd_hiragana_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.Hiragana')\n\n    def __cmd_katakana_mode(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.Katakana')\n\n    def __cmd_half_katakana(self, keyval, state):\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_input_mode()\n        return self.__set_input_mode(u'InputMode.HalfWidthKatakana')\n\n#    def __cmd_cancel_pseudo_ascii_mode_key(self, keyval, state):\n#        pass\n\n    def __unset_current_typing_mode(self):\n        modes = {\n            jastring.TYPING_MODE_ROMAJI: u'TypingMode.Romaji',\n            jastring.TYPING_MODE_KANA: u'TypingMode.Kana',\n            jastring.TYPING_MODE_THUMB_SHIFT: u'TypingMode.ThumbShift',\n        }\n        self.__typing_mode_activate(modes[Engine.__typing_mode],\n                                    IBus.PropState.UNCHECKED)\n\n    def __cmd_circle_typing_method(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        modes = {\n            jastring.TYPING_MODE_THUMB_SHIFT: u'TypingMode.Romaji',\n            jastring.TYPING_MODE_KANA: u'TypingMode.ThumbShift',\n            jastring.TYPING_MODE_ROMAJI: u'TypingMode.Kana',\n        }\n        # ibus 1.5 or later needs to send UNCHECKED\n        self.__unset_current_typing_mode()\n        self.__typing_mode_activate(modes[Engine.__typing_mode],\n                                    IBus.PropState.CHECKED)\n        return True\n\n    def __cmd_circle_dict_method(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        # ibus 1.5 or later needs to send UNCHECKED\n        prop_name = self.__dict_mode_get_prop_name(Engine.__dict_mode)\n        if prop_name != None:\n            self.__dict_mode_activate(prop_name,\n                                      IBus.PropState.UNCHECKED)\n\n        single_files = self.__get_single_dict_files()\n        new_mode = Engine.__dict_mode + 1\n        if new_mode > len(single_files):\n            new_mode = 0\n        Engine.__dict_mode = new_mode\n        prop_name = self.__dict_mode_get_prop_name(Engine.__dict_mode)\n        if prop_name == None:\n            return False\n        self.__dict_mode_activate(prop_name,\n                                  IBus.PropState.CHECKED)\n        return True\n\n    #edit_keys\n    def __cmd_insert_space(self, keyval, state):\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return False\n        if (self.__prefs.get_value('common', 'half_width_space') or\n            Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA):\n            return self.__cmd_insert_half_space(keyval, state)\n        else:\n            return self.__cmd_insert_wide_space(keyval, state)\n\n    def __cmd_insert_alternate_space(self, keyval, state):\n        if Engine.__input_mode == INPUT_MODE_LATIN:\n            return False\n        if (self.__prefs.get_value('common', 'half_width_space') or\n            Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA):\n            return self.__cmd_insert_wide_space(keyval, state)\n        else:\n            return self.__cmd_insert_half_space(keyval, state)\n\n    def __cmd_insert_half_space(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        if not self.__preedit_ja_string.is_empty():\n            return False\n        self.__commit_string(unichr(IBus.KEY_space))\n        return True\n\n    def __cmd_insert_wide_space(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        if not self.__preedit_ja_string.is_empty():\n            return False\n        char = unichr(IBus.KEY_space)\n        wide_char = symbol_rule.get(char, None)\n        if wide_char == None:\n            wide_char = unichar_half_to_full(char)\n        self.__commit_string(wide_char)\n        return True\n\n    def __cmd_backspace(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        return self.__on_key_back_space()\n\n    def __cmd_delete(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        return self.__on_key_delete()\n\n    def __cmd_commit(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        return self.__on_key_return()\n\n    def __cmd_convert(self, keyval, state):\n        if not self._chk_mode('14'):\n            return False\n\n        self.__begin_anthy_convert()\n        self.__invalidate()\n\n        return True\n\n    def __cmd_predict(self, keyval, state):\n        if not self._chk_mode('14'):\n            return False\n\n        text, cursor = self.__preedit_ja_string.get_hiragana(True)\n\n        self.__context.set_prediction_string(text.encode('utf8'))\n        nr_predictions = self.__context.get_nr_predictions()\n\n#        for i in range(nr_predictions):\n#            print self.__context.get_prediction(i)\n\n        buf = self.__context.get_prediction(0)\n        if not buf:\n            return False\n\n        text = UN(buf)\n        self.__segments.append((0, text))\n\n        self.__convert_mode = CONV_MODE_PREDICTION\n        self.__cursor_pos = 0\n        self.__fill_lookup_table()\n        self.__lookup_table_visible = False\n        self.__invalidate()\n\n        return True\n\n    def __cmd_cancel(self, keyval, state):\n        return self.__cmd_cancel_all(keyval, state)\n\n    def __cmd_cancel_all(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            return self.__on_key_escape()\n        else:\n            self.__end_convert()\n            self.__invalidate()\n            return True\n\n    def __cmd_reconvert(self, keyval, state):\n        if not self.__preedit_ja_string.is_empty():\n            # if user has inputed some chars\n            return False\n\n        # Move importing Gtk into Engine from the header\n        # because ibus-engine-anthy --xml does not requre to open X.\n        try:\n            from gi.repository import Gtk\n            clipboard_get = Gtk.Clipboard.get\n        except ImportError:\n            clipboard_get = lambda a : None\n        except RuntimeError:\n            # Do we support the engine without display?\n            print >> sys.stderr, \"Gtk couldn't be initialized\"\n            print >> sys.stderr, 'Could not open display'\n            clipboard_get = lambda a : None\n\n        # Use Gtk.Clipboard.request_text() instead of\n        # Gtk.Clipboard.wait_for_text() because DBus is timed out.\n        clipboard = clipboard_get ('PRIMARY')\n        if clipboard:\n            clipboard.request_text (self.__get_clipboard, CLIPBOARD_RECONVERT)\n\n        return True\n\n    def __update_reconvert(self, clipboard_text):\n        if clipboard_text == None:\n            return False\n\n        self.__convert_chars = UN(clipboard_text)\n        for i in xrange(0, len(self.__convert_chars)):\n            keyval = self.__convert_chars[i]\n            self.__preedit_ja_string.insert(unichr(ord (keyval)))\n\n        self.__context.set_string(self.__convert_chars.encode('utf-8'))\n        nr_segments = self.__context.get_nr_segments()\n\n        for i in xrange(0, nr_segments):\n            buf = self.__context.get_segment(i, 0)\n            text = UN(buf)\n            self.__segments.append((0, text))\n\n        self.__convert_mode = CONV_MODE_ANTHY\n        self.__cursor_pos = 0\n        self.__fill_lookup_table()\n        self.__lookup_table_visible = False\n        self.__invalidate()\n\n        return True\n\n#    def __cmd_do_nothing(self, keyval, state):\n#        return True\n\n    #caret_keys\n    def __move_caret(self, i):\n        if not self._chk_mode('1'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_OFF:\n            self.__preedit_ja_string.move_cursor(\n                -len(self.__preedit_ja_string.get_latin()[0]) if i == 0 else\n                i if i in [-1, 1] else\n                len(self.__preedit_ja_string.get_latin()[0]))\n            self.__invalidate()\n            return True\n\n        return False\n\n    def __cmd_move_caret_first(self, keyval, state):\n        return self.__move_caret(0)\n\n    def __cmd_move_caret_last(self, keyval, state):\n        return self.__move_caret(2)\n\n    def __cmd_move_caret_forward(self, keyval, state):\n        return self.__move_caret(1)\n\n    def __cmd_move_caret_backward(self, keyval, state):\n        return self.__move_caret(-1)\n\n    #segments_keys\n    def __select_segment(self, i):\n        if not self._chk_mode('25'):\n            return False\n\n        pos = 0 if i == 0 else \\\n              self.__cursor_pos + i if i in [-1, 1] else \\\n              len(self.__segments) - 1\n\n        if 0 <= pos < len(self.__segments) and pos != self.__cursor_pos:\n            self.__cursor_pos = pos\n            self.__lookup_table_visible = False\n            self.__fill_lookup_table()\n            self.__invalidate()\n\n        return True\n\n    def __cmd_select_first_segment(self, keyval, state):\n        return self.__select_segment(0)\n\n    def __cmd_select_last_segment(self, keyval, state):\n        return self.__select_segment(2)\n\n    def __cmd_select_next_segment(self, keyval, state):\n        return self.__select_segment(1)\n\n    def __cmd_select_prev_segment(self, keyval, state):\n        return self.__select_segment(-1)\n\n    def __cmd_shrink_segment(self, keyval, state):\n        if not self._chk_mode('25'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__shrink_segment(-1)\n            return True\n\n    def __cmd_expand_segment(self, keyval, state):\n        if not self._chk_mode('25'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            self.__shrink_segment(1)\n            return True\n\n    def __move_cursor_char_length(self, length):\n        if Engine.__input_mode == INPUT_MODE_HIRAGANA:\n            self.__preedit_ja_string.move_cursor_hiragana_length(length)\n        elif Engine.__input_mode == INPUT_MODE_KATAKANA:\n            self.__preedit_ja_string.move_cursor_katakana_length(length)\n        elif Engine.__input_mode == INPUT_MODE_HALF_WIDTH_KATAKANA:\n            self.__preedit_ja_string.move_cursor_half_with_katakana_length(length)\n        else:\n            self.__preedit_ja_string.move_cursor(length)\n\n    def __commit_nth_segment(self, commit_index, keyval, state):\n\n        if commit_index >= len(self.__segments):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            for i in xrange(0, commit_index + 1):\n                (seg_index, text) = self.__segments[i]\n                self.commit_text(IBus.Text.new_from_string(text))\n\n            text, cursor = self.__get_preedit()\n            commit_length = 0\n            for i in xrange(0, commit_index + 1):\n                buf = self.__context.get_segment(i, NTH_UNCONVERTED_CANDIDATE)\n                commit_length += len(UN(buf))\n            self.__move_cursor_char_length(commit_length - cursor)\n            for i in xrange(0, commit_length):\n                self.__preedit_ja_string.remove_before()\n            self.__move_cursor_char_length(cursor - commit_length)\n\n            del self.__segments[0:commit_index + 1]\n\n        if len(self.__segments) == 0:\n            self.__reset()\n        else:\n            if self.__cursor_pos > commit_index:\n                self.__cursor_pos -= (commit_index + 1)\n            else:\n                self.__cursor_pos = 0\n            text, cursor = self.__get_preedit()\n            self.__convert_chars = text\n            self.__context.set_string(text.encode ('utf-8'))\n\n        self.__lookup_table.clear()\n        self.__lookup_table.set_cursor_visible(False)\n        self.__lookup_table_visible = False\n        self.update_aux_string(u'', IBus.AttrList(),\n            self.__lookup_table_visible)\n        self.__fill_lookup_table()\n        self.__invalidate()\n        self.__update_input_chars()\n\n        return True\n\n    def __cmd_commit_first_segment(self, keyval, state):\n        return self.__commit_nth_segment(0, keyval, state)\n\n    def __cmd_commit_selected_segment(self, keyval, state):\n        return self.__commit_nth_segment(self.__cursor_pos, keyval, state)\n\n    #candidates_keys\n    def __on_candidate_index_in_page(self, index):\n        if not self._chk_mode('5'):\n            return False\n\n        if index >= self.__lookup_table.get_page_size():\n            return False\n        cursor_pos = self.__lookup_table.get_cursor_pos()\n        cursor_in_page = self.__lookup_table.get_cursor_in_page()\n        real_index = cursor_pos - cursor_in_page + index\n        if real_index >= self.__lookup_table.get_number_of_candidates():\n            return False\n        self.__lookup_table.set_cursor_pos(real_index)\n        index = self.__lookup_table.get_cursor_pos()\n        candidate = UN(self.__lookup_table.get_candidate(index).get_text())\n        self.__segments[self.__cursor_pos] = index, candidate\n        self.__lookup_table_visible = False\n        self.__on_key_right()\n        self.__invalidate()\n        return True\n\n    def __cmd_select_first_candidate(self, keyval, state):\n        return self.__on_candidate_index_in_page(0)\n\n    def __cmd_select_last_candidate(self, keyval, state):\n        return self.__on_candidate_index_in_page(\n            self.__lookup_table.get_page_size() - 1)\n\n    def __cmd_select_next_candidate(self, keyval, state):\n        if not self._chk_mode('235'):\n            return False\n\n        return self.__on_key_down()\n\n    def __cmd_select_prev_candidate(self, keyval, state):\n        if not self._chk_mode('235'):\n            return False\n\n        return self.__on_key_up()\n\n    def __cmd_candidates_page_up(self, keyval, state):\n        if not self._chk_mode('5'):\n            return False\n\n        return self.__on_key_page_up()\n\n    def __cmd_candidates_page_down(self, keyval, state):\n        if not self._chk_mode('5'):\n            return False\n\n        return self.__on_key_page_down()\n\n    #direct_select_keys\n    def __select_keyval(self, keyval):\n        if not self._chk_mode('5'):\n            return False\n\n        return self.__on_key_number(keyval)\n\n    def __cmd_select_candidates_1(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_2(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_3(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_4(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_5(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_6(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_7(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_8(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_9(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    def __cmd_select_candidates_0(self, keyval, state):\n        return self.__select_keyval(keyval)\n\n    #convert_keys\n    def __cmd_convert_to_char_type_forward(self, keyval, state):\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            n = self.__segments[self.__cursor_pos][0]\n            if n == NTH_HIRAGANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_KATAKANA_CANDIDATE)\n            elif n == NTH_KATAKANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n            elif n == NTH_HALFKANA_CANDIDATE:\n                return self.__convert_segment_to_latin(-100)\n            elif n == -100:\n                return self.__convert_segment_to_latin(-101)\n            else:\n                return self.__convert_segment_to_kana(NTH_HIRAGANA_CANDIDATE)\n\n        if self.__convert_mode == CONV_MODE_KATAKANA:\n            return self.__cmd_convert_to_half_katakana(keyval, state)\n        elif self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n            return self.__cmd_convert_to_latin(keyval, state)\n        elif CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n            return self.__cmd_convert_to_wide_latin(keyval, state)\n        elif (CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode\n                                     <= CONV_MODE_WIDE_LATIN_3):\n            return self.__cmd_convert_to_hiragana(keyval, state)\n        else:\n            return self.__cmd_convert_to_katakana(keyval, state)\n\n    def __cmd_convert_to_char_type_backward(self, keyval, state):\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            n = self.__segments[self.__cursor_pos][0]\n            if n == NTH_KATAKANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_HIRAGANA_CANDIDATE)\n            elif n == NTH_HALFKANA_CANDIDATE:\n                return self.__convert_segment_to_kana(NTH_KATAKANA_CANDIDATE)\n            elif n == -100:\n                return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n            elif n == -101:\n                return self.__convert_segment_to_latin(-100)\n            else:\n                return self.__convert_segment_to_latin(-101)\n\n        if self.__convert_mode == CONV_MODE_KATAKANA:\n            return self.__cmd_convert_to_hiragana(keyval, state)\n        elif self.__convert_mode == CONV_MODE_HALF_WIDTH_KATAKANA:\n            return self.__cmd_convert_to_katakana(keyval, state)\n        elif CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n            return self.__cmd_convert_to_half_katakana(keyval, state)\n        elif (CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode\n                                     <= CONV_MODE_WIDE_LATIN_3):\n            return self.__cmd_convert_to_latin(keyval, state)\n        else:\n            return self.__cmd_convert_to_wide_latin(keyval, state)\n\n    def __convert_segment_to_kana(self, n):\n        if self.__convert_mode == CONV_MODE_ANTHY and -4 <= n <= -2:\n            buf = self.__context.get_segment(self.__cursor_pos, n)\n            self.__segments[self.__cursor_pos] = n, UN(buf)\n            self.__lookup_table_visible = False\n            self.__invalidate()\n            return True\n\n        return False\n\n    def __cmd_convert_to_hiragana(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return self.__convert_segment_to_kana(NTH_HIRAGANA_CANDIDATE)\n\n        return self.__on_key_conv(0)\n\n    def __cmd_convert_to_katakana(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return self.__convert_segment_to_kana(NTH_KATAKANA_CANDIDATE)\n\n        return self.__on_key_conv(1)\n\n    def __cmd_convert_to_half(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            i, s = self.__segments[self.__cursor_pos]\n            if i == -101:\n                return self.__convert_segment_to_latin(-100)\n            elif i == -100:\n                return self.__convert_segment_to_latin(-100)\n            return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n\n        elif CONV_MODE_WIDE_LATIN_0 <= self.__convert_mode <= CONV_MODE_WIDE_LATIN_3:\n            return self.__on_key_conv(4)\n        elif CONV_MODE_LATIN_0 <= self.__convert_mode <= CONV_MODE_LATIN_3:\n            return self.__on_key_conv(4)\n        return self.__on_key_conv(2)\n\n    def __cmd_convert_to_half_katakana(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n            return self.__convert_segment_to_kana(NTH_HALFKANA_CANDIDATE)\n\n        return self.__on_key_conv(2)\n\n    def __convert_segment_to_latin(self, n):\n        if self.__convert_mode == CONV_MODE_ANTHY and n in [-100, -101]:\n            start = 0\n            for i in range(self.__cursor_pos):\n                start += len(UN(self.__context.get_segment(i, NTH_UNCONVERTED_CANDIDATE)))\n            end = start + len(UN(self.__context.get_segment(self.__cursor_pos, NTH_UNCONVERTED_CANDIDATE)))\n            i, s = self.__segments[self.__cursor_pos]\n            s2 = self.__preedit_ja_string.get_raw(start, end)\n            if n == -101:\n                s2 = u''.join([unichar_half_to_full(c) for c in s2])\n            if i == n:\n                if s == s2.lower():\n                    s2 = s2.upper()\n                elif s == s2.upper():\n                    s2 = s2.capitalize()\n                elif s == s2 or s == s2.capitalize():\n                    s2 = s2.lower()\n            self.__segments[self.__cursor_pos] = n, s2\n            self.__lookup_table_visible = False\n            self.__invalidate()\n            return True\n\n        return False\n\n    def __cmd_convert_to_wide_latin(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n           return self.__convert_segment_to_latin(-101)\n\n        return self.__on_key_conv(3)\n\n    def __cmd_convert_to_latin(self, keyval, state):\n        if not self._chk_mode('12345'):\n            return False\n\n        if self.__convert_mode == CONV_MODE_ANTHY:\n           return self.__convert_segment_to_latin(-100)\n\n        return self.__on_key_conv(4)\n\n    #dictonary_keys\n    def __cmd_dict_admin(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        self.__start_dict_admin()\n        return True\n\n    def __cmd_add_word(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        self.__start_add_word()\n        return True\n\n    def __cmd_start_setup(self, keyval, state):\n        if not self._chk_mode('0'):\n            return False\n\n        self.__start_setup()\n        return True\n\n    def __start_dict_admin(self):\n        command = self.__prefs.get_value('common', 'dict_admin_command')\n        os.spawnl(os.P_NOWAIT, *command)\n\n    def __start_add_word(self):\n        command = self.__prefs.get_value('common', 'add_word_command')\n        os.spawnl(os.P_NOWAIT, *command)\n\n    def __start_setup(self):\n        if Engine.__setup_pid != 0:\n            pid, state = os.waitpid(Engine.__setup_pid, os.P_NOWAIT)\n            if pid != Engine.__setup_pid:\n                return\n            Engine.__setup_pid = 0\n        setup_cmd = path.join(config.LIBEXECDIR, 'ibus-setup-anthy')\n        Engine.__setup_pid = os.spawnl(os.P_NOWAIT, setup_cmd, 'ibus-setup-anthy')\n\n    def __cmd_hiragana_for_latin_with_shift(self, keyval, state):\n        self.__preedit_ja_string.set_hiragana_katakana(True)\n\n"], "filenames": ["engine/engine.py"], "buggy_code_start_loc": [128], "buggy_code_end_loc": [1809], "fixing_code_start_loc": [129], "fixing_code_end_loc": [1824], "type": "CWE-255", "message": "The default configuration of IBUS 1.5.4, and possibly 1.5.2 and earlier, when IBus.InputPurpose.PASSWORD is not set and used with GNOME 3, does not obscure the entered password characters, which allows physically proximate attackers to obtain a user password by reading the lockscreen.", "other": {"cve": {"id": "CVE-2013-4509", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-23T19:55:03.613", "lastModified": "2023-02-13T04:47:03.750", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The default configuration of IBUS 1.5.4, and possibly 1.5.2 and earlier, when IBus.InputPurpose.PASSWORD is not set and used with GNOME 3, does not obscure the entered password characters, which allows physically proximate attackers to obtain a user password by reading the lockscreen."}, {"lang": "es", "value": "La configuraci\u00f3n predeterminada de IBUS 1.5.4, y posiblemente de 1.5.2 y anteriores, cuando IBus.InputPurpose.PASSWORD no se establece y utiliza con GNOME 3, no oscurece los caracteres escritos, lo que permite a atacantes f\u00edsicamente pr\u00f3ximos obtener una contrase\u00f1a de usuario mediante la lectura de la pantalla de bloqueo."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-255"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ibus_project:ibus:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5.2", "matchCriteriaId": "E220A758-86E2-40F7-8E9E-89DBF26C1778"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ibus_project:ibus:1.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "0D52B705-2959-4021-8AC8-E52D58FE3C54"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2013-11/msg00036.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00024.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-01/msg00045.html", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1027028", "source": "secalert@redhat.com"}, {"url": "https://code.google.com/p/mozc/issues/attachmentText?id=199&aid=1990002000&name=ibus-mozc_support_ibus-1.5.4_rev2.diff&token=P62umpXGXx68XJT6zyvBA727wqE%3A1383693105690", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/ibus/ibus-anthy/commit/6aae0a9f145f536515e268dd6b25aa740a5edfe7", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://groups.google.com/forum/#%21topic/ibus-user/mvCHDO1BJUw", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/ibus/ibus-anthy/commit/6aae0a9f145f536515e268dd6b25aa740a5edfe7"}}