{"buggy_code": ["\n/* pngrutil.c - utilities to read a PNG file\n *\n * Last changed in libpng 1.6.35 [(PENDING RELEASE)]\n * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n *\n * This code is released under the libpng license.\n * For conditions of distribution and use, see the disclaimer\n * and license in png.h\n *\n * This file contains routines that are only called from within\n * libpng itself during the course of reading an image.\n */\n\n#include \"pngpriv.h\"\n\n#ifdef PNG_READ_SUPPORTED\n\npng_uint_32 PNGAPI\npng_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n\n   if (uval > PNG_UINT_31_MAX)\n      png_error(png_ptr, \"PNG unsigned integer out of range\");\n\n   return (uval);\n}\n\n#if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)\n/* The following is a variation on the above for use with the fixed\n * point values used for gAMA and cHRM.  Instead of png_error it\n * issues a warning and returns (-1) - an invalid value because both\n * gAMA and cHRM use *unsigned* integers for fixed point values.\n */\n#define PNG_FIXED_ERROR (-1)\n\nstatic png_fixed_point /* PRIVATE */\npng_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n\n   if (uval <= PNG_UINT_31_MAX)\n      return (png_fixed_point)uval; /* known to be in range */\n\n   /* The caller can turn off the warning by passing NULL. */\n   if (png_ptr != NULL)\n      png_warning(png_ptr, \"PNG fixed point integer out of range\");\n\n   return PNG_FIXED_ERROR;\n}\n#endif\n\n#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED\n/* NOTE: the read macros will obscure these definitions, so that if\n * PNG_USE_READ_MACROS is set the library will not use them internally,\n * but the APIs will still be available externally.\n *\n * The parentheses around \"PNGAPI function_name\" in the following three\n * functions are necessary because they allow the macros to co-exist with\n * these (unused but exported) functions.\n */\n\n/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\npng_uint_32 (PNGAPI\npng_get_uint_32)(png_const_bytep buf)\n{\n   png_uint_32 uval =\n       ((png_uint_32)(*(buf    )) << 24) +\n       ((png_uint_32)(*(buf + 1)) << 16) +\n       ((png_uint_32)(*(buf + 2)) <<  8) +\n       ((png_uint_32)(*(buf + 3))      ) ;\n\n   return uval;\n}\n\n/* Grab a signed 32-bit integer from a buffer in big-endian format.  The\n * data is stored in the PNG file in two's complement format and there\n * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore\n * the following code does a two's complement to native conversion.\n */\npng_int_32 (PNGAPI\npng_get_int_32)(png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n   if ((uval & 0x80000000) == 0) /* non-negative */\n      return (png_int_32)uval;\n\n   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */\n   if ((uval & 0x80000000) == 0) /* no overflow */\n      return -(png_int_32)uval;\n   /* The following has to be safe; this function only gets called on PNG data\n    * and if we get here that data is invalid.  0 is the most safe value and\n    * if not then an attacker would surely just generate a PNG with 0 instead.\n    */\n   return 0;\n}\n\n/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */\npng_uint_16 (PNGAPI\npng_get_uint_16)(png_const_bytep buf)\n{\n   /* ANSI-C requires an int value to accommodate at least 16 bits so this\n    * works and allows the compiler not to worry about possible narrowing\n    * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller\n    * than 16 bits either.)\n    */\n   unsigned int val =\n       ((unsigned int)(*buf) << 8) +\n       ((unsigned int)(*(buf + 1)));\n\n   return (png_uint_16)val;\n}\n\n#endif /* READ_INT_FUNCTIONS */\n\n/* Read and check the PNG file signature */\nvoid /* PRIVATE */\npng_read_sig(png_structrp png_ptr, png_inforp info_ptr)\n{\n   size_t num_checked, num_to_check;\n\n   /* Exit if the user application does not expect a signature. */\n   if (png_ptr->sig_bytes >= 8)\n      return;\n\n   num_checked = png_ptr->sig_bytes;\n   num_to_check = 8 - num_checked;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;\n#endif\n\n   /* The signature must be serialized in a single I/O call. */\n   png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);\n   png_ptr->sig_bytes = 8;\n\n   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check) != 0)\n   {\n      if (num_checked < 4 &&\n          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n         png_error(png_ptr, \"Not a PNG file\");\n      else\n         png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\n   }\n   if (num_checked < 3)\n      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;\n}\n\n/* Read the chunk header (length + type name).\n * Put the type name into png_ptr->chunk_name, and return the length.\n */\npng_uint_32 /* PRIVATE */\npng_read_chunk_header(png_structrp png_ptr)\n{\n   png_byte buf[8];\n   png_uint_32 length;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;\n#endif\n\n   /* Read the length and the chunk name.\n    * This must be performed in a single I/O call.\n    */\n   png_read_data(png_ptr, buf, 8);\n   length = png_get_uint_31(png_ptr, buf);\n\n   /* Put the chunk name into png_ptr->chunk_name. */\n   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n\n   png_debug2(0, \"Reading %lx chunk, length = %lu\",\n       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\n\n   /* Reset the crc and run it over the chunk name. */\n   png_reset_crc(png_ptr);\n   png_calculate_crc(png_ptr, buf + 4, 4);\n\n   /* Check to see if chunk name is valid. */\n   png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n\n   /* Check for too-large chunk length */\n   png_check_chunk_length(png_ptr, length);\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;\n#endif\n\n   return length;\n}\n\n/* Read data, and (optionally) run it through the CRC. */\nvoid /* PRIVATE */\npng_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)\n{\n   if (png_ptr == NULL)\n      return;\n\n   png_read_data(png_ptr, buf, length);\n   png_calculate_crc(png_ptr, buf, length);\n}\n\n/* Optionally skip data and then check the CRC.  Depending on whether we\n * are reading an ancillary or critical chunk, and how the program has set\n * things up, we may calculate the CRC on the data and print a message.\n * Returns '1' if there was a CRC error, '0' otherwise.\n */\nint /* PRIVATE */\npng_crc_finish(png_structrp png_ptr, png_uint_32 skip)\n{\n   /* The size of the local buffer for inflate is a good guess as to a\n    * reasonable size to use for buffering reads from the application.\n    */\n   while (skip > 0)\n   {\n      png_uint_32 len;\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\n\n      len = (sizeof tmpbuf);\n      if (len > skip)\n         len = skip;\n      skip -= len;\n\n      png_crc_read(png_ptr, tmpbuf, len);\n   }\n\n   if (png_crc_error(png_ptr) != 0)\n   {\n      if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?\n          (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :\n          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)\n      {\n         png_chunk_warning(png_ptr, \"CRC error\");\n      }\n\n      else\n         png_chunk_error(png_ptr, \"CRC error\");\n\n      return (1);\n   }\n\n   return (0);\n}\n\n/* Compare the CRC stored in the PNG file with that calculated by libpng from\n * the data it has read thus far.\n */\nint /* PRIVATE */\npng_crc_error(png_structrp png_ptr)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n\n   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n\n   else /* critical */\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n         need_crc = 0;\n   }\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n#endif\n\n   /* The chunk CRC must be serialized in a single I/O call. */\n   png_read_data(png_ptr, crc_bytes, 4);\n\n   if (need_crc != 0)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n\n   else\n      return (0);\n}\n\n#if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\\\n    defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\\\n    defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\\\n    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)\n/* Manage the read buffer; this simply reallocates the buffer if it is not small\n * enough (or if it is not allocated).  The routine returns a pointer to the\n * buffer; if an error occurs and 'warn' is set the routine returns NULL, else\n * it will call png_error (via png_malloc) on failure.  (warn == 2 means\n * 'silent').\n */\nstatic png_bytep\npng_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size, int warn)\n{\n   png_bytep buffer = png_ptr->read_buffer;\n\n   if (buffer != NULL && new_size > png_ptr->read_buffer_size)\n   {\n      png_ptr->read_buffer = NULL;\n      png_ptr->read_buffer = NULL;\n      png_ptr->read_buffer_size = 0;\n      png_free(png_ptr, buffer);\n      buffer = NULL;\n   }\n\n   if (buffer == NULL)\n   {\n      buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size));\n\n      if (buffer != NULL)\n      {\n         memset(buffer, 0, new_size); /* just in case */\n         png_ptr->read_buffer = buffer;\n         png_ptr->read_buffer_size = new_size;\n      }\n\n      else if (warn < 2) /* else silent */\n      {\n         if (warn != 0)\n             png_chunk_warning(png_ptr, \"insufficient memory to read chunk\");\n\n         else\n             png_chunk_error(png_ptr, \"insufficient memory to read chunk\");\n      }\n   }\n\n   return buffer;\n}\n#endif /* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */\n\n/* png_inflate_claim: claim the zstream for some nefarious purpose that involves\n * decompression.  Returns Z_OK on success, else a zlib error code.  It checks\n * the owner but, in final release builds, just issues a warning if some other\n * chunk apparently owns the stream.  Prior to release it does a png_error.\n */\nstatic int\npng_inflate_claim(png_structrp png_ptr, png_uint_32 owner)\n{\n   if (png_ptr->zowner != 0)\n   {\n      char msg[64];\n\n      PNG_STRING_FROM_CHUNK(msg, png_ptr->zowner);\n      /* So the message that results is \"<chunk> using zstream\"; this is an\n       * internal error, but is very useful for debugging.  i18n requirements\n       * are minimal.\n       */\n      (void)png_safecat(msg, (sizeof msg), 4, \" using zstream\");\n#if PNG_RELEASE_BUILD\n      png_chunk_warning(png_ptr, msg);\n      png_ptr->zowner = 0;\n#else\n      png_chunk_error(png_ptr, msg);\n#endif\n   }\n\n   /* Implementation note: unlike 'png_deflate_claim' this internal function\n    * does not take the size of the data as an argument.  Some efficiency could\n    * be gained by using this when it is known *if* the zlib stream itself does\n    * not record the number; however, this is an illusion: the original writer\n    * of the PNG may have selected a lower window size, and we really must\n    * follow that because, for systems with with limited capabilities, we\n    * would otherwise reject the application's attempts to use a smaller window\n    * size (zlib doesn't have an interface to say \"this or lower\"!).\n    *\n    * inflateReset2 was added to zlib 1.2.4; before this the window could not be\n    * reset, therefore it is necessary to always allocate the maximum window\n    * size with earlier zlibs just in case later compressed chunks need it.\n    */\n   {\n      int ret; /* zlib return code */\n#if ZLIB_VERNUM >= 0x1240\n      int window_bits = 0;\n\n# if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)\n      if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==\n          PNG_OPTION_ON)\n      {\n         window_bits = 15;\n         png_ptr->zstream_start = 0; /* fixed window size */\n      }\n\n      else\n      {\n         png_ptr->zstream_start = 1;\n      }\n# endif\n\n#endif /* ZLIB_VERNUM >= 0x1240 */\n\n      /* Set this for safety, just in case the previous owner left pointers to\n       * memory allocations.\n       */\n      png_ptr->zstream.next_in = NULL;\n      png_ptr->zstream.avail_in = 0;\n      png_ptr->zstream.next_out = NULL;\n      png_ptr->zstream.avail_out = 0;\n\n      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)\n      {\n#if ZLIB_VERNUM >= 0x1240\n         ret = inflateReset2(&png_ptr->zstream, window_bits);\n#else\n         ret = inflateReset(&png_ptr->zstream);\n#endif\n      }\n\n      else\n      {\n#if ZLIB_VERNUM >= 0x1240\n         ret = inflateInit2(&png_ptr->zstream, window_bits);\n#else\n         ret = inflateInit(&png_ptr->zstream);\n#endif\n\n         if (ret == Z_OK)\n            png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;\n      }\n\n#if ZLIB_VERNUM >= 0x1290 && \\\n   defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_IGNORE_ADLER32)\n      if (((png_ptr->options >> PNG_IGNORE_ADLER32) & 3) == PNG_OPTION_ON)\n         /* Turn off validation of the ADLER32 checksum in IDAT chunks */\n         ret = inflateValidate(&png_ptr->zstream, 0);\n#endif\n\n      if (ret == Z_OK)\n         png_ptr->zowner = owner;\n\n      else\n         png_zstream_error(png_ptr, ret);\n\n      return ret;\n   }\n\n#ifdef window_bits\n# undef window_bits\n#endif\n}\n\n#if ZLIB_VERNUM >= 0x1240\n/* Handle the start of the inflate stream if we called inflateInit2(strm,0);\n * in this case some zlib versions skip validation of the CINFO field and, in\n * certain circumstances, libpng may end up displaying an invalid image, in\n * contrast to implementations that call zlib in the normal way (e.g. libpng\n * 1.5).\n */\nint /* PRIVATE */\npng_zlib_inflate(png_structrp png_ptr, int flush)\n{\n   if (png_ptr->zstream_start && png_ptr->zstream.avail_in > 0)\n   {\n      if ((*png_ptr->zstream.next_in >> 4) > 7)\n      {\n         png_ptr->zstream.msg = \"invalid window size (libpng)\";\n         return Z_DATA_ERROR;\n      }\n\n      png_ptr->zstream_start = 0;\n   }\n\n   return inflate(&png_ptr->zstream, flush);\n}\n#endif /* Zlib >= 1.2.4 */\n\n#ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED\n#if defined(PNG_READ_zTXt_SUPPORTED) || defined (PNG_READ_iTXt_SUPPORTED)\n/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to\n * allow the caller to do multiple calls if required.  If the 'finish' flag is\n * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must\n * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and\n * Z_OK or Z_STREAM_END will be returned on success.\n *\n * The input and output sizes are updated to the actual amounts of data consumed\n * or written, not the amount available (as in a z_stream).  The data pointers\n * are not changed, so the next input is (data+input_size) and the next\n * available output is (output+output_size).\n */\nstatic int\npng_inflate(png_structrp png_ptr, png_uint_32 owner, int finish,\n    /* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,\n    /* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)\n{\n   if (png_ptr->zowner == owner) /* Else not claimed */\n   {\n      int ret;\n      png_alloc_size_t avail_out = *output_size_ptr;\n      png_uint_32 avail_in = *input_size_ptr;\n\n      /* zlib can't necessarily handle more than 65535 bytes at once (i.e. it\n       * can't even necessarily handle 65536 bytes) because the type uInt is\n       * \"16 bits or more\".  Consequently it is necessary to chunk the input to\n       * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the\n       * maximum value that can be stored in a uInt.)  It is possible to set\n       * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have\n       * a performance advantage, because it reduces the amount of data accessed\n       * at each step and that may give the OS more time to page it in.\n       */\n      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);\n      /* avail_in and avail_out are set below from 'size' */\n      png_ptr->zstream.avail_in = 0;\n      png_ptr->zstream.avail_out = 0;\n\n      /* Read directly into the output if it is available (this is set to\n       * a local buffer below if output is NULL).\n       */\n      if (output != NULL)\n         png_ptr->zstream.next_out = output;\n\n      do\n      {\n         uInt avail;\n         Byte local_buffer[PNG_INFLATE_BUF_SIZE];\n\n         /* zlib INPUT BUFFER */\n         /* The setting of 'avail_in' used to be outside the loop; by setting it\n          * inside it is possible to chunk the input to zlib and simply rely on\n          * zlib to advance the 'next_in' pointer.  This allows arbitrary\n          * amounts of data to be passed through zlib at the unavoidable cost of\n          * requiring a window save (memcpy of up to 32768 output bytes)\n          * every ZLIB_IO_MAX input bytes.\n          */\n         avail_in += png_ptr->zstream.avail_in; /* not consumed last time */\n\n         avail = ZLIB_IO_MAX;\n\n         if (avail_in < avail)\n            avail = (uInt)avail_in; /* safe: < than ZLIB_IO_MAX */\n\n         avail_in -= avail;\n         png_ptr->zstream.avail_in = avail;\n\n         /* zlib OUTPUT BUFFER */\n         avail_out += png_ptr->zstream.avail_out; /* not written last time */\n\n         avail = ZLIB_IO_MAX; /* maximum zlib can process */\n\n         if (output == NULL)\n         {\n            /* Reset the output buffer each time round if output is NULL and\n             * make available the full buffer, up to 'remaining_space'\n             */\n            png_ptr->zstream.next_out = local_buffer;\n            if ((sizeof local_buffer) < avail)\n               avail = (sizeof local_buffer);\n         }\n\n         if (avail_out < avail)\n            avail = (uInt)avail_out; /* safe: < ZLIB_IO_MAX */\n\n         png_ptr->zstream.avail_out = avail;\n         avail_out -= avail;\n\n         /* zlib inflate call */\n         /* In fact 'avail_out' may be 0 at this point, that happens at the end\n          * of the read when the final LZ end code was not passed at the end of\n          * the previous chunk of input data.  Tell zlib if we have reached the\n          * end of the output buffer.\n          */\n         ret = PNG_INFLATE(png_ptr, avail_out > 0 ? Z_NO_FLUSH :\n             (finish ? Z_FINISH : Z_SYNC_FLUSH));\n      } while (ret == Z_OK);\n\n      /* For safety kill the local buffer pointer now */\n      if (output == NULL)\n         png_ptr->zstream.next_out = NULL;\n\n      /* Claw back the 'size' and 'remaining_space' byte counts. */\n      avail_in += png_ptr->zstream.avail_in;\n      avail_out += png_ptr->zstream.avail_out;\n\n      /* Update the input and output sizes; the updated values are the amount\n       * consumed or written, effectively the inverse of what zlib uses.\n       */\n      if (avail_out > 0)\n         *output_size_ptr -= avail_out;\n\n      if (avail_in > 0)\n         *input_size_ptr -= avail_in;\n\n      /* Ensure png_ptr->zstream.msg is set (even in the success case!) */\n      png_zstream_error(png_ptr, ret);\n      return ret;\n   }\n\n   else\n   {\n      /* This is a bad internal error.  The recovery assigns to the zstream msg\n       * pointer, which is not owned by the caller, but this is safe; it's only\n       * used on errors!\n       */\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\n      return Z_STREAM_ERROR;\n   }\n}\n\n/*\n * Decompress trailing data in a chunk.  The assumption is that read_buffer\n * points at an allocated area holding the contents of a chunk with a\n * trailing compressed part.  What we get back is an allocated area\n * holding the original prefix part and an uncompressed version of the\n * trailing part (the malloc area passed in is freed).\n */\nstatic int\npng_decompress_chunk(png_structrp png_ptr,\n    png_uint_32 chunklength, png_uint_32 prefix_size,\n    png_alloc_size_t *newlength /* must be initialized to the maximum! */,\n    int terminate /*add a '\\0' to the end of the uncompressed data*/)\n{\n   /* TODO: implement different limits for different types of chunk.\n    *\n    * The caller supplies *newlength set to the maximum length of the\n    * uncompressed data, but this routine allocates space for the prefix and\n    * maybe a '\\0' terminator too.  We have to assume that 'prefix_size' is\n    * limited only by the maximum chunk size.\n    */\n   png_alloc_size_t limit = PNG_SIZE_MAX;\n\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n\n   if (limit >= prefix_size + (terminate != 0))\n   {\n      int ret;\n\n      limit -= prefix_size + (terminate != 0);\n\n      if (limit < *newlength)\n         *newlength = limit;\n\n      /* Now try to claim the stream. */\n      ret = png_inflate_claim(png_ptr, png_ptr->chunk_name);\n\n      if (ret == Z_OK)\n      {\n         png_uint_32 lzsize = chunklength - prefix_size;\n\n         ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\n             /* input: */ png_ptr->read_buffer + prefix_size, &lzsize,\n             /* output: */ NULL, newlength);\n\n         if (ret == Z_STREAM_END)\n         {\n            /* Use 'inflateReset' here, not 'inflateReset2' because this\n             * preserves the previously decided window size (otherwise it would\n             * be necessary to store the previous window size.)  In practice\n             * this doesn't matter anyway, because png_inflate will call inflate\n             * with Z_FINISH in almost all cases, so the window will not be\n             * maintained.\n             */\n            if (inflateReset(&png_ptr->zstream) == Z_OK)\n            {\n               /* Because of the limit checks above we know that the new,\n                * expanded, size will fit in a size_t (let alone an\n                * png_alloc_size_t).  Use png_malloc_base here to avoid an\n                * extra OOM message.\n                */\n               png_alloc_size_t new_size = *newlength;\n               png_alloc_size_t buffer_size = prefix_size + new_size +\n                   (terminate != 0);\n               png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,\n                   buffer_size));\n\n               if (text != NULL)\n               {\n                  memset(text, 0, buffer_size);\n\n                  ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\n                      png_ptr->read_buffer + prefix_size, &lzsize,\n                      text + prefix_size, newlength);\n\n                  if (ret == Z_STREAM_END)\n                  {\n                     if (new_size == *newlength)\n                     {\n                        if (terminate != 0)\n                           text[prefix_size + *newlength] = 0;\n\n                        if (prefix_size > 0)\n                           memcpy(text, png_ptr->read_buffer, prefix_size);\n\n                        {\n                           png_bytep old_ptr = png_ptr->read_buffer;\n\n                           png_ptr->read_buffer = text;\n                           png_ptr->read_buffer_size = buffer_size;\n                           text = old_ptr; /* freed below */\n                        }\n                     }\n\n                     else\n                     {\n                        /* The size changed on the second read, there can be no\n                         * guarantee that anything is correct at this point.\n                         * The 'msg' pointer has been set to \"unexpected end of\n                         * LZ stream\", which is fine, but return an error code\n                         * that the caller won't accept.\n                         */\n                        ret = PNG_UNEXPECTED_ZLIB_RETURN;\n                     }\n                  }\n\n                  else if (ret == Z_OK)\n                     ret = PNG_UNEXPECTED_ZLIB_RETURN; /* for safety */\n\n                  /* Free the text pointer (this is the old read_buffer on\n                   * success)\n                   */\n                  png_free(png_ptr, text);\n\n                  /* This really is very benign, but it's still an error because\n                   * the extra space may otherwise be used as a Trojan Horse.\n                   */\n                  if (ret == Z_STREAM_END &&\n                      chunklength - prefix_size != lzsize)\n                     png_chunk_benign_error(png_ptr, \"extra compressed data\");\n               }\n\n               else\n               {\n                  /* Out of memory allocating the buffer */\n                  ret = Z_MEM_ERROR;\n                  png_zstream_error(png_ptr, Z_MEM_ERROR);\n               }\n            }\n\n            else\n            {\n               /* inflateReset failed, store the error message */\n               png_zstream_error(png_ptr, ret);\n               ret = PNG_UNEXPECTED_ZLIB_RETURN;\n            }\n         }\n\n         else if (ret == Z_OK)\n            ret = PNG_UNEXPECTED_ZLIB_RETURN;\n\n         /* Release the claimed stream */\n         png_ptr->zowner = 0;\n      }\n\n      else /* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */\n         ret = PNG_UNEXPECTED_ZLIB_RETURN;\n\n      return ret;\n   }\n\n   else\n   {\n      /* Application/configuration limits exceeded */\n      png_zstream_error(png_ptr, Z_MEM_ERROR);\n      return Z_MEM_ERROR;\n   }\n}\n#endif /* READ_zTXt || READ_iTXt */\n#endif /* READ_COMPRESSED_TEXT */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n/* Perform a partial read and decompress, producing 'avail_out' bytes and\n * reading from the current chunk as required.\n */\nstatic int\npng_inflate_read(png_structrp png_ptr, png_bytep read_buffer, uInt read_size,\n    png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,\n    int finish)\n{\n   if (png_ptr->zowner == png_ptr->chunk_name)\n   {\n      int ret;\n\n      /* next_in and avail_in must have been initialized by the caller. */\n      png_ptr->zstream.next_out = next_out;\n      png_ptr->zstream.avail_out = 0; /* set in the loop */\n\n      do\n      {\n         if (png_ptr->zstream.avail_in == 0)\n         {\n            if (read_size > *chunk_bytes)\n               read_size = (uInt)*chunk_bytes;\n            *chunk_bytes -= read_size;\n\n            if (read_size > 0)\n               png_crc_read(png_ptr, read_buffer, read_size);\n\n            png_ptr->zstream.next_in = read_buffer;\n            png_ptr->zstream.avail_in = read_size;\n         }\n\n         if (png_ptr->zstream.avail_out == 0)\n         {\n            uInt avail = ZLIB_IO_MAX;\n            if (avail > *out_size)\n               avail = (uInt)*out_size;\n            *out_size -= avail;\n\n            png_ptr->zstream.avail_out = avail;\n         }\n\n         /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all\n          * the available output is produced; this allows reading of truncated\n          * streams.\n          */\n         ret = PNG_INFLATE(png_ptr, *chunk_bytes > 0 ?\n             Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));\n      }\n      while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));\n\n      *out_size += png_ptr->zstream.avail_out;\n      png_ptr->zstream.avail_out = 0; /* Should not be required, but is safe */\n\n      /* Ensure the error message pointer is always set: */\n      png_zstream_error(png_ptr, ret);\n      return ret;\n   }\n\n   else\n   {\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\n      return Z_STREAM_ERROR;\n   }\n}\n#endif /* READ_iCCP */\n\n/* Read and check the IDHR chunk */\n\nvoid /* PRIVATE */\npng_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[13];\n   png_uint_32 width, height;\n   int bit_depth, color_type, compression_type, filter_type;\n   int interlace_type;\n\n   png_debug(1, \"in png_handle_IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) != 0)\n      png_chunk_error(png_ptr, \"out of place\");\n\n   /* Check the length */\n   if (length != 13)\n      png_chunk_error(png_ptr, \"invalid\");\n\n   png_ptr->mode |= PNG_HAVE_IHDR;\n\n   png_crc_read(png_ptr, buf, 13);\n   png_crc_finish(png_ptr, 0);\n\n   width = png_get_uint_31(png_ptr, buf);\n   height = png_get_uint_31(png_ptr, buf + 4);\n   bit_depth = buf[8];\n   color_type = buf[9];\n   compression_type = buf[10];\n   filter_type = buf[11];\n   interlace_type = buf[12];\n\n   /* Set internal variables */\n   png_ptr->width = width;\n   png_ptr->height = height;\n   png_ptr->bit_depth = (png_byte)bit_depth;\n   png_ptr->interlaced = (png_byte)interlace_type;\n   png_ptr->color_type = (png_byte)color_type;\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   png_ptr->filter_type = (png_byte)filter_type;\n#endif\n   png_ptr->compression_type = (png_byte)compression_type;\n\n   /* Find number of channels */\n   switch (png_ptr->color_type)\n   {\n      default: /* invalid, png_set_IHDR calls png_error */\n      case PNG_COLOR_TYPE_GRAY:\n      case PNG_COLOR_TYPE_PALETTE:\n         png_ptr->channels = 1;\n         break;\n\n      case PNG_COLOR_TYPE_RGB:\n         png_ptr->channels = 3;\n         break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         png_ptr->channels = 2;\n         break;\n\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         png_ptr->channels = 4;\n         break;\n   }\n\n   /* Set up other useful info */\n   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth * png_ptr->channels);\n   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);\n   png_debug1(3, \"bit_depth = %d\", png_ptr->bit_depth);\n   png_debug1(3, \"channels = %d\", png_ptr->channels);\n   png_debug1(3, \"rowbytes = %lu\", (unsigned long)png_ptr->rowbytes);\n   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,\n       color_type, interlace_type, compression_type, filter_type);\n}\n\n/* Read and check the palette */\nvoid /* PRIVATE */\npng_handle_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_color palette[PNG_MAX_PALETTE_LENGTH];\n   int max_palette_length, num, i;\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\n   png_colorp pal_ptr;\n#endif\n\n   png_debug(1, \"in png_handle_PLTE\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   /* Moved to before the 'after IDAT' check below because otherwise duplicate\n    * PLTE chunks are potentially ignored (the spec says there shall not be more\n    * than one PLTE, the error is not treated as benign, so this check trumps\n    * the requirement that PLTE appears before IDAT.)\n    */\n   else if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)\n      png_chunk_error(png_ptr, \"duplicate\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      /* This is benign because the non-benign error happened before, when an\n       * IDAT was encountered in a color-mapped image with no PLTE.\n       */\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   png_ptr->mode |= PNG_HAVE_PLTE;\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"ignored in grayscale PNG\");\n      return;\n   }\n\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n#endif\n\n   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)\n   {\n      png_crc_finish(png_ptr, length);\n\n      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n         png_chunk_benign_error(png_ptr, \"invalid\");\n\n      else\n         png_chunk_error(png_ptr, \"invalid\");\n\n      return;\n   }\n\n   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */\n   num = (int)length / 3;\n\n   /* If the palette has 256 or fewer entries but is too large for the bit\n    * depth, we don't issue an error, to preserve the behavior of previous\n    * libpng versions. We silently truncate the unused extra palette entries\n    * here.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      max_palette_length = (1 << png_ptr->bit_depth);\n   else\n      max_palette_length = PNG_MAX_PALETTE_LENGTH;\n\n   if (num > max_palette_length)\n      num = max_palette_length;\n\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\n   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)\n   {\n      png_byte buf[3];\n\n      png_crc_read(png_ptr, buf, 3);\n      pal_ptr->red = buf[0];\n      pal_ptr->green = buf[1];\n      pal_ptr->blue = buf[2];\n   }\n#else\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[3];\n\n      png_crc_read(png_ptr, buf, 3);\n      /* Don't depend upon png_color being any order */\n      palette[i].red = buf[0];\n      palette[i].green = buf[1];\n      palette[i].blue = buf[2];\n   }\n#endif\n\n   /* If we actually need the PLTE chunk (ie for a paletted image), we do\n    * whatever the normal CRC configuration tells us.  However, if we\n    * have an RGB image, the PLTE can be considered ancillary, so\n    * we will act as though it is.\n    */\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n#endif\n   {\n      png_crc_finish(png_ptr, (png_uint_32) (length - (unsigned int)num * 3));\n   }\n\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n   else if (png_crc_error(png_ptr) != 0)  /* Only if we have a CRC error */\n   {\n      /* If we don't want to use the data from an ancillary chunk,\n       * we have two options: an error abort, or a warning and we\n       * ignore the data in this chunk (which should be OK, since\n       * it's considered ancillary for a RGB or RGBA image).\n       *\n       * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the\n       * chunk type to determine whether to check the ancillary or the critical\n       * flags.\n       */\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE) == 0)\n      {\n         if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) != 0)\n            return;\n\n         else\n            png_chunk_error(png_ptr, \"CRC error\");\n      }\n\n      /* Otherwise, we (optionally) emit a warning and use the chunk. */\n      else if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)\n         png_chunk_warning(png_ptr, \"CRC error\");\n   }\n#endif\n\n   /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its\n    * own copy of the palette.  This has the side effect that when png_start_row\n    * is called (this happens after any call to png_read_update_info) the\n    * info_ptr palette gets changed.  This is extremely unexpected and\n    * confusing.\n    *\n    * Fix this by not sharing the palette in this way.\n    */\n   png_set_PLTE(png_ptr, info_ptr, palette, num);\n\n   /* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before\n    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely\n    * checked the apparent validity of a tRNS chunk inserted before PLTE on a\n    * palette PNG.  1.6.0 attempts to rigorously follow the standard and\n    * therefore does a benign error if the erroneous condition is detected *and*\n    * cancels the tRNS if the benign error returns.  The alternative is to\n    * amend the standard since it would be rather hypocritical of the standards\n    * maintainers to ignore it.\n    */\n#ifdef PNG_READ_tRNS_SUPPORTED\n   if (png_ptr->num_trans > 0 ||\n       (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0))\n   {\n      /* Cancel this because otherwise it would be used if the transforms\n       * require it.  Don't cancel the 'valid' flag because this would prevent\n       * detection of duplicate chunks.\n       */\n      png_ptr->num_trans = 0;\n\n      if (info_ptr != NULL)\n         info_ptr->num_trans = 0;\n\n      png_chunk_benign_error(png_ptr, \"tRNS must be after\");\n   }\n#endif\n\n#ifdef PNG_READ_hIST_SUPPORTED\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n      png_chunk_benign_error(png_ptr, \"hIST must be after\");\n#endif\n\n#ifdef PNG_READ_bKGD_SUPPORTED\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n      png_chunk_benign_error(png_ptr, \"bKGD must be after\");\n#endif\n}\n\nvoid /* PRIVATE */\npng_handle_IEND(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_debug(1, \"in png_handle_IEND\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0 ||\n       (png_ptr->mode & PNG_HAVE_IDAT) == 0)\n      png_chunk_error(png_ptr, \"out of place\");\n\n   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);\n\n   png_crc_finish(png_ptr, length);\n\n   if (length != 0)\n      png_chunk_benign_error(png_ptr, \"invalid\");\n\n   PNG_UNUSED(info_ptr)\n}\n\n#ifdef PNG_READ_gAMA_SUPPORTED\nvoid /* PRIVATE */\npng_handle_gAMA(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_fixed_point igamma;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_gAMA\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (length != 4)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 4);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   igamma = png_get_fixed_point(NULL, buf);\n\n   png_colorspace_set_gamma(png_ptr, &png_ptr->colorspace, igamma);\n   png_colorspace_sync(png_ptr, info_ptr);\n}\n#endif\n\n#ifdef PNG_READ_sBIT_SUPPORTED\nvoid /* PRIVATE */\npng_handle_sBIT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int truelen, i;\n   png_byte sample_depth;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_sBIT\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      truelen = 3;\n      sample_depth = 8;\n   }\n\n   else\n   {\n      truelen = png_ptr->channels;\n      sample_depth = png_ptr->bit_depth;\n   }\n\n   if (length != truelen || length > 4)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   buf[0] = buf[1] = buf[2] = buf[3] = sample_depth;\n   png_crc_read(png_ptr, buf, truelen);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   for (i=0; i<truelen; ++i)\n   {\n      if (buf[i] == 0 || buf[i] > sample_depth)\n      {\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n   }\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[1];\n      png_ptr->sig_bit.blue = buf[2];\n      png_ptr->sig_bit.alpha = buf[3];\n   }\n\n   else\n   {\n      png_ptr->sig_bit.gray = buf[0];\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[0];\n      png_ptr->sig_bit.blue = buf[0];\n      png_ptr->sig_bit.alpha = buf[1];\n   }\n\n   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));\n}\n#endif\n\n#ifdef PNG_READ_cHRM_SUPPORTED\nvoid /* PRIVATE */\npng_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[32];\n   png_xy xy;\n\n   png_debug(1, \"in png_handle_cHRM\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (length != 32)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 32);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   xy.whitex = png_get_fixed_point(NULL, buf);\n   xy.whitey = png_get_fixed_point(NULL, buf + 4);\n   xy.redx   = png_get_fixed_point(NULL, buf + 8);\n   xy.redy   = png_get_fixed_point(NULL, buf + 12);\n   xy.greenx = png_get_fixed_point(NULL, buf + 16);\n   xy.greeny = png_get_fixed_point(NULL, buf + 20);\n   xy.bluex  = png_get_fixed_point(NULL, buf + 24);\n   xy.bluey  = png_get_fixed_point(NULL, buf + 28);\n\n   if (xy.whitex == PNG_FIXED_ERROR ||\n       xy.whitey == PNG_FIXED_ERROR ||\n       xy.redx   == PNG_FIXED_ERROR ||\n       xy.redy   == PNG_FIXED_ERROR ||\n       xy.greenx == PNG_FIXED_ERROR ||\n       xy.greeny == PNG_FIXED_ERROR ||\n       xy.bluex  == PNG_FIXED_ERROR ||\n       xy.bluey  == PNG_FIXED_ERROR)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid values\");\n      return;\n   }\n\n   /* If a colorspace error has already been output skip this chunk */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n      return;\n\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0)\n   {\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n      png_colorspace_sync(png_ptr, info_ptr);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   png_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n   (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,\n       1/*prefer cHRM values*/);\n   png_colorspace_sync(png_ptr, info_ptr);\n}\n#endif\n\n#ifdef PNG_READ_sRGB_SUPPORTED\nvoid /* PRIVATE */\npng_handle_sRGB(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte intent;\n\n   png_debug(1, \"in png_handle_sRGB\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (length != 1)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, &intent, 1);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* If a colorspace error has already been output skip this chunk */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n      return;\n\n   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n    * this.\n    */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) != 0)\n   {\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n      png_colorspace_sync(png_ptr, info_ptr);\n      png_chunk_benign_error(png_ptr, \"too many profiles\");\n      return;\n   }\n\n   (void)png_colorspace_set_sRGB(png_ptr, &png_ptr->colorspace, intent);\n   png_colorspace_sync(png_ptr, info_ptr);\n}\n#endif /* READ_sRGB */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\nvoid /* PRIVATE */\npng_handle_iCCP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle profiles that are > 64K under DOS */\n{\n   png_const_charp errmsg = NULL; /* error message output, or no error */\n   int finished = 0; /* crc checked */\n\n   png_debug(1, \"in png_handle_iCCP\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   /* Consistent with all the above colorspace handling an obviously *invalid*\n    * chunk is just ignored, so does not invalidate the color space.  An\n    * alternative is to set the 'invalid' flags at the start of this routine\n    * and only clear them in they were not set before and all the tests pass.\n    */\n\n   /* The keyword must be at least one character and there is a\n    * terminator (0) byte and the compression method byte, and the\n    * 'zlib' datastream is at least 11 bytes.\n    */\n   if (length < 14)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too short\");\n      return;\n   }\n\n   /* If a colorspace error has already been output skip this chunk */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n    * this.\n    */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) == 0)\n   {\n      uInt read_length, keyword_length;\n      char keyword[81];\n\n      /* Find the keyword; the keyword plus separator and compression method\n       * bytes can be at most 81 characters long.\n       */\n      read_length = 81; /* maximum */\n      if (read_length > length)\n         read_length = (uInt)length;\n\n      png_crc_read(png_ptr, (png_bytep)keyword, read_length);\n      length -= read_length;\n\n      /* The minimum 'zlib' stream is assumed to be just the 2 byte header,\n       * 5 bytes minimum 'deflate' stream, and the 4 byte checksum.\n       */\n      if (length < 11)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"too short\");\n         return;\n      }\n\n      keyword_length = 0;\n      while (keyword_length < 80 && keyword_length < read_length &&\n         keyword[keyword_length] != 0)\n         ++keyword_length;\n\n      /* TODO: make the keyword checking common */\n      if (keyword_length >= 1 && keyword_length <= 79)\n      {\n         /* We only understand '0' compression - deflate - so if we get a\n          * different value we can't safely decode the chunk.\n          */\n         if (keyword_length+1 < read_length &&\n            keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)\n         {\n            read_length -= keyword_length+2;\n\n            if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)\n            {\n               Byte profile_header[132]={0};\n               Byte local_buffer[PNG_INFLATE_BUF_SIZE];\n               png_alloc_size_t size = (sizeof profile_header);\n\n               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);\n               png_ptr->zstream.avail_in = read_length;\n               (void)png_inflate_read(png_ptr, local_buffer,\n                   (sizeof local_buffer), &length, profile_header, &size,\n                   0/*finish: don't, because the output is too small*/);\n\n               if (size == 0)\n               {\n                  /* We have the ICC profile header; do the basic header checks.\n                   */\n                  const png_uint_32 profile_length =\n                     png_get_uint_32(profile_header);\n\n                  if (png_icc_check_length(png_ptr, &png_ptr->colorspace,\n                      keyword, profile_length) != 0)\n                  {\n                     /* The length is apparently ok, so we can check the 132\n                      * byte header.\n                      */\n                     if (png_icc_check_header(png_ptr, &png_ptr->colorspace,\n                         keyword, profile_length, profile_header,\n                         png_ptr->color_type) != 0)\n                     {\n                        /* Now read the tag table; a variable size buffer is\n                         * needed at this point, allocate one for the whole\n                         * profile.  The header check has already validated\n                         * that none of this stuff will overflow.\n                         */\n                        const png_uint_32 tag_count = png_get_uint_32(\n                            profile_header+128);\n                        png_bytep profile = png_read_buffer(png_ptr,\n                            profile_length, 2/*silent*/);\n\n                        if (profile != NULL)\n                        {\n                           memcpy(profile, profile_header,\n                               (sizeof profile_header));\n\n                           size = 12 * tag_count;\n\n                           (void)png_inflate_read(png_ptr, local_buffer,\n                               (sizeof local_buffer), &length,\n                               profile + (sizeof profile_header), &size, 0);\n\n                           /* Still expect a buffer error because we expect\n                            * there to be some tag data!\n                            */\n                           if (size == 0)\n                           {\n                              if (png_icc_check_tag_table(png_ptr,\n                                  &png_ptr->colorspace, keyword, profile_length,\n                                  profile) != 0)\n                              {\n                                 /* The profile has been validated for basic\n                                  * security issues, so read the whole thing in.\n                                  */\n                                 size = profile_length - (sizeof profile_header)\n                                     - 12 * tag_count;\n\n                                 (void)png_inflate_read(png_ptr, local_buffer,\n                                     (sizeof local_buffer), &length,\n                                     profile + (sizeof profile_header) +\n                                     12 * tag_count, &size, 1/*finish*/);\n\n                                 if (length > 0 && !(png_ptr->flags &\n                                     PNG_FLAG_BENIGN_ERRORS_WARN))\n                                    errmsg = \"extra compressed data\";\n\n                                 /* But otherwise allow extra data: */\n                                 else if (size == 0)\n                                 {\n                                    if (length > 0)\n                                    {\n                                       /* This can be handled completely, so\n                                        * keep going.\n                                        */\n                                       png_chunk_warning(png_ptr,\n                                           \"extra compressed data\");\n                                    }\n\n                                    png_crc_finish(png_ptr, length);\n                                    finished = 1;\n\n# if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0\n                                    /* Check for a match against sRGB */\n                                    png_icc_set_sRGB(png_ptr,\n                                        &png_ptr->colorspace, profile,\n                                        png_ptr->zstream.adler);\n# endif\n\n                                    /* Steal the profile for info_ptr. */\n                                    if (info_ptr != NULL)\n                                    {\n                                       png_free_data(png_ptr, info_ptr,\n                                           PNG_FREE_ICCP, 0);\n\n                                       info_ptr->iccp_name = png_voidcast(char*,\n                                           png_malloc_base(png_ptr,\n                                           keyword_length+1));\n                                       if (info_ptr->iccp_name != NULL)\n                                       {\n                                          memcpy(info_ptr->iccp_name, keyword,\n                                              keyword_length+1);\n                                          info_ptr->iccp_proflen =\n                                              profile_length;\n                                          info_ptr->iccp_profile = profile;\n                                          png_ptr->read_buffer = NULL; /*steal*/\n                                          info_ptr->free_me |= PNG_FREE_ICCP;\n                                          info_ptr->valid |= PNG_INFO_iCCP;\n                                       }\n\n                                       else\n                                       {\n                                          png_ptr->colorspace.flags |=\n                                             PNG_COLORSPACE_INVALID;\n                                          errmsg = \"out of memory\";\n                                       }\n                                    }\n\n                                    /* else the profile remains in the read\n                                     * buffer which gets reused for subsequent\n                                     * chunks.\n                                     */\n\n                                    if (info_ptr != NULL)\n                                       png_colorspace_sync(png_ptr, info_ptr);\n\n                                    if (errmsg == NULL)\n                                    {\n                                       png_ptr->zowner = 0;\n                                       return;\n                                    }\n                                 }\n                                 if (errmsg == NULL)\n                                    errmsg = png_ptr->zstream.msg;\n                              }\n                              /* else png_icc_check_tag_table output an error */\n                           }\n                           else /* profile truncated */\n                              errmsg = png_ptr->zstream.msg;\n                        }\n\n                        else\n                           errmsg = \"out of memory\";\n                     }\n\n                     /* else png_icc_check_header output an error */\n                  }\n\n                  /* else png_icc_check_length output an error */\n               }\n\n               else /* profile truncated */\n                  errmsg = png_ptr->zstream.msg;\n\n               /* Release the stream */\n               png_ptr->zowner = 0;\n            }\n\n            else /* png_inflate_claim failed */\n               errmsg = png_ptr->zstream.msg;\n         }\n\n         else\n            errmsg = \"bad compression method\"; /* or missing */\n      }\n\n      else\n         errmsg = \"bad keyword\";\n   }\n\n   else\n      errmsg = \"too many profiles\";\n\n   /* Failure: the reason is in 'errmsg' */\n   if (finished == 0)\n      png_crc_finish(png_ptr, length);\n\n   png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n   png_colorspace_sync(png_ptr, info_ptr);\n   if (errmsg != NULL) /* else already output */\n      png_chunk_benign_error(png_ptr, errmsg);\n}\n#endif /* READ_iCCP */\n\n#ifdef PNG_READ_sPLT_SUPPORTED\nvoid /* PRIVATE */\npng_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle chunks that are > 64K under DOS */\n{\n   png_bytep entry_start, buffer;\n   png_sPLT_t new_palette;\n   png_sPLT_entryp pp;\n   png_uint_32 data_length;\n   int entry_size, i;\n   png_uint_32 skip = 0;\n   png_uint_32 dl;\n   size_t max_dl;\n\n   png_debug(1, \"in png_handle_sPLT\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_warning(png_ptr, \"No space in chunk cache for sPLT\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > 65535U)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n      return;\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n\n   /* WARNING: this may break if size_t is less than 32 bits; it is assumed\n    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a\n    * potential breakage point if the types in pngconf.h aren't exactly right.\n    */\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return;\n\n   buffer[length] = 0;\n\n   for (entry_start = buffer; *entry_start; entry_start++)\n      /* Empty loop to find end of name */ ;\n\n   ++entry_start;\n\n   /* A sample depth should follow the separator, and we should be on it  */\n   if (length < 2U || entry_start > buffer + (length - 2U))\n   {\n      png_warning(png_ptr, \"malformed sPLT chunk\");\n      return;\n   }\n\n   new_palette.depth = *entry_start++;\n   entry_size = (new_palette.depth == 8 ? 6 : 10);\n   /* This must fit in a png_uint_32 because it is derived from the original\n    * chunk data length.\n    */\n   data_length = length - (png_uint_32)(entry_start - buffer);\n\n   /* Integrity-check the data length */\n   if ((data_length % (unsigned int)entry_size) != 0)\n   {\n      png_warning(png_ptr, \"sPLT chunk has bad length\");\n      return;\n   }\n\n   dl = (png_uint_32)(data_length / (unsigned int)entry_size);\n   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));\n\n   if (dl > max_dl)\n   {\n      png_warning(png_ptr, \"sPLT chunk too long\");\n      return;\n   }\n\n   new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);\n\n   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,\n       (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));\n\n   if (new_palette.entries == NULL)\n   {\n      png_warning(png_ptr, \"sPLT chunk requires too much memory\");\n      return;\n   }\n\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n      pp = new_palette.entries + i;\n\n      if (new_palette.depth == 8)\n      {\n         pp->red = *entry_start++;\n         pp->green = *entry_start++;\n         pp->blue = *entry_start++;\n         pp->alpha = *entry_start++;\n      }\n\n      else\n      {\n         pp->red   = png_get_uint_16(entry_start); entry_start += 2;\n         pp->green = png_get_uint_16(entry_start); entry_start += 2;\n         pp->blue  = png_get_uint_16(entry_start); entry_start += 2;\n         pp->alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n\n      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n#else\n   pp = new_palette.entries;\n\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n\n      if (new_palette.depth == 8)\n      {\n         pp[i].red   = *entry_start++;\n         pp[i].green = *entry_start++;\n         pp[i].blue  = *entry_start++;\n         pp[i].alpha = *entry_start++;\n      }\n\n      else\n      {\n         pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;\n         pp[i].green = png_get_uint_16(entry_start); entry_start += 2;\n         pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;\n         pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n\n      pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n#endif\n\n   /* Discard all chunk data except the name and stash that */\n   new_palette.name = (png_charp)buffer;\n\n   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);\n\n   png_free(png_ptr, new_palette.entries);\n}\n#endif /* READ_sPLT */\n\n#ifdef PNG_READ_tRNS_SUPPORTED\nvoid /* PRIVATE */\npng_handle_tRNS(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_tRNS\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_byte buf[2];\n\n      if (length != 2)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.gray = png_get_uint_16(buf);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_byte buf[6];\n\n      if (length != 6)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, length);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.red = png_get_uint_16(buf);\n      png_ptr->trans_color.green = png_get_uint_16(buf + 2);\n      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)\n      {\n         /* TODO: is this actually an error in the ISO spec? */\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"out of place\");\n         return;\n      }\n\n      if (length > (unsigned int) png_ptr->num_palette ||\n         length > (unsigned int) PNG_MAX_PALETTE_LENGTH ||\n         length == 0)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n\n      png_crc_read(png_ptr, readbuf, length);\n      png_ptr->num_trans = (png_uint_16)length;\n   }\n\n   else\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid with alpha channel\");\n      return;\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n   {\n      png_ptr->num_trans = 0;\n      return;\n   }\n\n   /* TODO: this is a horrible side effect in the palette case because the\n    * png_struct ends up with a pointer to the tRNS buffer owned by the\n    * png_info.  Fix this.\n    */\n   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,\n       &(png_ptr->trans_color));\n}\n#endif\n\n#ifdef PNG_READ_bKGD_SUPPORTED\nvoid /* PRIVATE */\npng_handle_bKGD(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int truelen;\n   png_byte buf[6];\n   png_color_16 background;\n\n   png_debug(1, \"in png_handle_bKGD\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n       (png_ptr->mode & PNG_HAVE_PLTE) == 0))\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      truelen = 1;\n\n   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n      truelen = 6;\n\n   else\n      truelen = 2;\n\n   if (length != truelen)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, truelen);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* We convert the index value into RGB components so that we can allow\n    * arbitrary RGB values for background when we have transparency, and\n    * so it is easy to determine the RGB values of the background color\n    * from the info_ptr struct.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      background.index = buf[0];\n\n      if (info_ptr != NULL && info_ptr->num_palette != 0)\n      {\n         if (buf[0] >= info_ptr->num_palette)\n         {\n            png_chunk_benign_error(png_ptr, \"invalid index\");\n            return;\n         }\n\n         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;\n         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;\n         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;\n      }\n\n      else\n         background.red = background.green = background.blue = 0;\n\n      background.gray = 0;\n   }\n\n   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0) /* GRAY */\n   {\n      if (png_ptr->bit_depth <= 8)\n      {\n         if (buf[0] != 0 || buf[1] >= (unsigned int)(1 << png_ptr->bit_depth))\n         {\n            png_chunk_benign_error(png_ptr, \"invalid gray level\");\n            return;\n         }\n      }\n\n      background.index = 0;\n      background.red =\n      background.green =\n      background.blue =\n      background.gray = png_get_uint_16(buf);\n   }\n\n   else\n   {\n      if (png_ptr->bit_depth <= 8)\n      {\n         if (buf[0] != 0 || buf[2] != 0 || buf[4] != 0)\n         {\n            png_chunk_benign_error(png_ptr, \"invalid color\");\n            return;\n         }\n      }\n\n      background.index = 0;\n      background.red = png_get_uint_16(buf);\n      background.green = png_get_uint_16(buf + 2);\n      background.blue = png_get_uint_16(buf + 4);\n      background.gray = 0;\n   }\n\n   png_set_bKGD(png_ptr, info_ptr, &background);\n}\n#endif\n\n#ifdef PNG_READ_eXIf_SUPPORTED\nvoid /* PRIVATE */\npng_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int i;\n\n   png_debug(1, \"in png_handle_eXIf\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if (length < 2)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too short\");\n      return;\n   }\n\n   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   info_ptr->free_me |= PNG_FREE_EXIF;\n\n   info_ptr->eXIf_buf = png_voidcast(png_bytep,\n             png_malloc_warn(png_ptr, length));\n\n   if (info_ptr->eXIf_buf == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   for (i = 0; i < length; i++)\n   {\n      png_byte buf[1];\n      png_crc_read(png_ptr, buf, 1);\n      info_ptr->eXIf_buf[i] = buf[0];\n      if (i == 1 && buf[0] != 'M' && buf[0] != 'I'\n                 && info_ptr->eXIf_buf[0] != buf[0])\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"incorrect byte-order specifier\");\n         png_free(png_ptr, info_ptr->eXIf_buf);\n         info_ptr->eXIf_buf = NULL;\n         return;\n      }\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);\n\n   png_free(png_ptr, info_ptr->eXIf_buf);\n   info_ptr->eXIf_buf = NULL;\n}\n#endif\n\n#ifdef PNG_READ_hIST_SUPPORTED\nvoid /* PRIVATE */\npng_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int num, i;\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_hIST\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n       (png_ptr->mode & PNG_HAVE_PLTE) == 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   num = length / 2 ;\n\n   if (num != (unsigned int) png_ptr->num_palette ||\n       num > (unsigned int) PNG_MAX_PALETTE_LENGTH)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n\n      png_crc_read(png_ptr, buf, 2);\n      readbuf[i] = png_get_uint_16(buf);\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   png_set_hIST(png_ptr, info_ptr, readbuf);\n}\n#endif\n\n#ifdef PNG_READ_pHYs_SUPPORTED\nvoid /* PRIVATE */\npng_handle_pHYs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[9];\n   png_uint_32 res_x, res_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_pHYs\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (length != 9)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 9);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   res_x = png_get_uint_32(buf);\n   res_y = png_get_uint_32(buf + 4);\n   unit_type = buf[8];\n   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n}\n#endif\n\n#ifdef PNG_READ_oFFs_SUPPORTED\nvoid /* PRIVATE */\npng_handle_oFFs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[9];\n   png_int_32 offset_x, offset_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_oFFs\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (length != 9)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 9);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   offset_x = png_get_int_32(buf);\n   offset_y = png_get_int_32(buf + 4);\n   unit_type = buf[8];\n   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);\n}\n#endif\n\n#ifdef PNG_READ_pCAL_SUPPORTED\n/* Read the pCAL chunk (described in the PNG Extensions document) */\nvoid /* PRIVATE */\npng_handle_pCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_int_32 X0, X1;\n   png_byte type, nparams;\n   png_bytep buffer, buf, units, endptr;\n   png_charpp params;\n   int i;\n\n   png_debug(1, \"in png_handle_pCAL\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading pCAL chunk data (%u bytes)\",\n       length + 1);\n\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   buffer[length] = 0; /* Null terminate the last string */\n\n   png_debug(3, \"Finding end of pCAL purpose string\");\n   for (buf = buffer; *buf; buf++)\n      /* Empty loop */ ;\n\n   endptr = buffer + length;\n\n   /* We need to have at least 12 bytes after the purpose string\n    * in order to get the parameter information.\n    */\n   if (endptr - buf <= 12)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_debug(3, \"Reading pCAL X0, X1, type, nparams, and units\");\n   X0 = png_get_int_32((png_bytep)buf+1);\n   X1 = png_get_int_32((png_bytep)buf+5);\n   type = buf[9];\n   nparams = buf[10];\n   units = buf + 11;\n\n   png_debug(3, \"Checking pCAL equation type and number of parameters\");\n   /* Check that we have the right number of parameters for known\n    * equation types.\n    */\n   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||\n       (type == PNG_EQUATION_BASE_E && nparams != 3) ||\n       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||\n       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))\n   {\n      png_chunk_benign_error(png_ptr, \"invalid parameter count\");\n      return;\n   }\n\n   else if (type >= PNG_EQUATION_LAST)\n   {\n      png_chunk_benign_error(png_ptr, \"unrecognized equation type\");\n   }\n\n   for (buf = units; *buf; buf++)\n      /* Empty loop to move past the units string. */ ;\n\n   png_debug(3, \"Allocating pCAL parameters array\");\n\n   params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,\n       nparams * (sizeof (png_charp))));\n\n   if (params == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   /* Get pointers to the start of each parameter string. */\n   for (i = 0; i < nparams; i++)\n   {\n      buf++; /* Skip the null string terminator from previous parameter. */\n\n      png_debug1(3, \"Reading pCAL parameter %d\", i);\n\n      for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)\n         /* Empty loop to move past each parameter string */ ;\n\n      /* Make sure we haven't run out of data yet */\n      if (buf > endptr)\n      {\n         png_free(png_ptr, params);\n         png_chunk_benign_error(png_ptr, \"invalid data\");\n         return;\n      }\n   }\n\n   png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,\n       (png_charp)units, params);\n\n   png_free(png_ptr, params);\n}\n#endif\n\n#ifdef PNG_READ_sCAL_SUPPORTED\n/* Read the sCAL chunk */\nvoid /* PRIVATE */\npng_handle_sCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_bytep buffer;\n   size_t i;\n   int state;\n\n   png_debug(1, \"in png_handle_sCAL\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   /* Need unit type, width, \\0, height: minimum 4 bytes */\n   else if (length < 4)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading sCAL chunk data (%u bytes)\",\n       length + 1);\n\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\n\n   if (buffer == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n   buffer[length] = 0; /* Null terminate the last string */\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* Validate the unit. */\n   if (buffer[0] != 1 && buffer[0] != 2)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid unit\");\n      return;\n   }\n\n   /* Validate the ASCII numbers, need two ASCII numbers separated by\n    * a '\\0' and they need to fit exactly in the chunk data.\n    */\n   i = 1;\n   state = 0;\n\n   if (png_check_fp_number((png_const_charp)buffer, length, &state, &i) == 0 ||\n       i >= length || buffer[i++] != 0)\n      png_chunk_benign_error(png_ptr, \"bad width format\");\n\n   else if (PNG_FP_IS_POSITIVE(state) == 0)\n      png_chunk_benign_error(png_ptr, \"non-positive width\");\n\n   else\n   {\n      size_t heighti = i;\n\n      state = 0;\n      if (png_check_fp_number((png_const_charp)buffer, length,\n          &state, &i) == 0 || i != length)\n         png_chunk_benign_error(png_ptr, \"bad height format\");\n\n      else if (PNG_FP_IS_POSITIVE(state) == 0)\n         png_chunk_benign_error(png_ptr, \"non-positive height\");\n\n      else\n         /* This is the (only) success case. */\n         png_set_sCAL_s(png_ptr, info_ptr, buffer[0],\n             (png_charp)buffer+1, (png_charp)buffer+heighti);\n   }\n}\n#endif\n\n#ifdef PNG_READ_tIME_SUPPORTED\nvoid /* PRIVATE */\npng_handle_tIME(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[7];\n   png_time mod_time;\n\n   png_debug(1, \"in png_handle_tIME\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   if (length != 7)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 7);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   mod_time.second = buf[6];\n   mod_time.minute = buf[5];\n   mod_time.hour = buf[4];\n   mod_time.day = buf[3];\n   mod_time.month = buf[2];\n   mod_time.year = png_get_uint_16(buf);\n\n   png_set_tIME(png_ptr, info_ptr, &mod_time);\n}\n#endif\n\n#ifdef PNG_READ_tEXt_SUPPORTED\n/* Note: this does not properly handle chunks that are > 64K under DOS */\nvoid /* PRIVATE */\npng_handle_tEXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_text  text_info;\n   png_bytep buffer;\n   png_charp key;\n   png_charp text;\n   png_uint_32 skip = 0;\n\n   png_debug(1, \"in png_handle_tEXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > 65535U)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n      return;\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);\n\n   if (buffer == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return;\n\n   key = (png_charp)buffer;\n   key[length] = 0;\n\n   for (text = key; *text; text++)\n      /* Empty loop to find end of key */ ;\n\n   if (text != key + length)\n      text++;\n\n   text_info.compression = PNG_TEXT_COMPRESSION_NONE;\n   text_info.key = key;\n   text_info.lang = NULL;\n   text_info.lang_key = NULL;\n   text_info.itxt_length = 0;\n   text_info.text = text;\n   text_info.text_length = strlen(text);\n\n   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)\n      png_warning(png_ptr, \"Insufficient memory to process text chunk\");\n}\n#endif\n\n#ifdef PNG_READ_zTXt_SUPPORTED\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\nvoid /* PRIVATE */\npng_handle_zTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_const_charp errmsg = NULL;\n   png_bytep       buffer;\n   png_uint_32     keyword_length;\n\n   png_debug(1, \"in png_handle_zTXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   /* Note, \"length\" is sufficient here; we won't be adding\n    * a null terminator later.\n    */\n   buffer = png_read_buffer(png_ptr, length, 2/*silent*/);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* TODO: also check that the keyword contents match the spec! */\n   for (keyword_length = 0;\n      keyword_length < length && buffer[keyword_length] != 0;\n      ++keyword_length)\n      /* Empty loop to find end of name */ ;\n\n   if (keyword_length > 79 || keyword_length < 1)\n      errmsg = \"bad keyword\";\n\n   /* zTXt must have some LZ data after the keyword, although it may expand to\n    * zero bytes; we need a '\\0' at the end of the keyword, the compression type\n    * then the LZ data:\n    */\n   else if (keyword_length + 3 > length)\n      errmsg = \"truncated\";\n\n   else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)\n      errmsg = \"unknown compression type\";\n\n   else\n   {\n      png_alloc_size_t uncompressed_length = PNG_SIZE_MAX;\n\n      /* TODO: at present png_decompress_chunk imposes a single application\n       * level memory limit, this should be split to different values for iCCP\n       * and text chunks.\n       */\n      if (png_decompress_chunk(png_ptr, length, keyword_length+2,\n          &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\n      {\n         png_text text;\n\n         if (png_ptr->read_buffer == NULL)\n           errmsg=\"Read failure in png_handle_zTXt\";\n         else\n         {\n            /* It worked; png_ptr->read_buffer now looks like a tEXt chunk\n             * except for the extra compression type byte and the fact that\n             * it isn't necessarily '\\0' terminated.\n             */\n            buffer = png_ptr->read_buffer;\n            buffer[uncompressed_length+(keyword_length+2)] = 0;\n\n            text.compression = PNG_TEXT_COMPRESSION_zTXt;\n            text.key = (png_charp)buffer;\n            text.text = (png_charp)(buffer + keyword_length+2);\n            text.text_length = uncompressed_length;\n            text.itxt_length = 0;\n            text.lang = NULL;\n            text.lang_key = NULL;\n\n            if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n               errmsg = \"insufficient memory\";\n         }\n      }\n\n      else\n         errmsg = png_ptr->zstream.msg;\n   }\n\n   if (errmsg != NULL)\n      png_chunk_benign_error(png_ptr, errmsg);\n}\n#endif\n\n#ifdef PNG_READ_iTXt_SUPPORTED\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\nvoid /* PRIVATE */\npng_handle_iTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_const_charp errmsg = NULL;\n   png_bytep buffer;\n   png_uint_32 prefix_length;\n\n   png_debug(1, \"in png_handle_iTXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* First the keyword. */\n   for (prefix_length=0;\n      prefix_length < length && buffer[prefix_length] != 0;\n      ++prefix_length)\n      /* Empty loop */ ;\n\n   /* Perform a basic check on the keyword length here. */\n   if (prefix_length > 79 || prefix_length < 1)\n      errmsg = \"bad keyword\";\n\n   /* Expect keyword, compression flag, compression type, language, translated\n    * keyword (both may be empty but are 0 terminated) then the text, which may\n    * be empty.\n    */\n   else if (prefix_length + 5 > length)\n      errmsg = \"truncated\";\n\n   else if (buffer[prefix_length+1] == 0 ||\n      (buffer[prefix_length+1] == 1 &&\n      buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))\n   {\n      int compressed = buffer[prefix_length+1] != 0;\n      png_uint_32 language_offset, translated_keyword_offset;\n      png_alloc_size_t uncompressed_length = 0;\n\n      /* Now the language tag */\n      prefix_length += 3;\n      language_offset = prefix_length;\n\n      for (; prefix_length < length && buffer[prefix_length] != 0;\n         ++prefix_length)\n         /* Empty loop */ ;\n\n      /* WARNING: the length may be invalid here, this is checked below. */\n      translated_keyword_offset = ++prefix_length;\n\n      for (; prefix_length < length && buffer[prefix_length] != 0;\n         ++prefix_length)\n         /* Empty loop */ ;\n\n      /* prefix_length should now be at the trailing '\\0' of the translated\n       * keyword, but it may already be over the end.  None of this arithmetic\n       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit\n       * systems the available allocation may overflow.\n       */\n      ++prefix_length;\n\n      if (compressed == 0 && prefix_length <= length)\n         uncompressed_length = length - prefix_length;\n\n      else if (compressed != 0 && prefix_length < length)\n      {\n         uncompressed_length = PNG_SIZE_MAX;\n\n         /* TODO: at present png_decompress_chunk imposes a single application\n          * level memory limit, this should be split to different values for\n          * iCCP and text chunks.\n          */\n         if (png_decompress_chunk(png_ptr, length, prefix_length,\n             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\n            buffer = png_ptr->read_buffer;\n\n         else\n            errmsg = png_ptr->zstream.msg;\n      }\n\n      else\n         errmsg = \"truncated\";\n\n      if (errmsg == NULL)\n      {\n         png_text text;\n\n         buffer[uncompressed_length+prefix_length] = 0;\n\n         if (compressed == 0)\n            text.compression = PNG_ITXT_COMPRESSION_NONE;\n\n         else\n            text.compression = PNG_ITXT_COMPRESSION_zTXt;\n\n         text.key = (png_charp)buffer;\n         text.lang = (png_charp)buffer + language_offset;\n         text.lang_key = (png_charp)buffer + translated_keyword_offset;\n         text.text = (png_charp)buffer + prefix_length;\n         text.text_length = 0;\n         text.itxt_length = uncompressed_length;\n\n         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n            errmsg = \"insufficient memory\";\n      }\n   }\n\n   else\n      errmsg = \"bad compression info\";\n\n   if (errmsg != NULL)\n      png_chunk_benign_error(png_ptr, errmsg);\n}\n#endif\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */\nstatic int\npng_cache_unknown_chunk(png_structrp png_ptr, png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_SIZE_MAX;\n\n   if (png_ptr->unknown_chunk.data != NULL)\n   {\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n      png_ptr->unknown_chunk.data = NULL;\n   }\n\n#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n\n#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n#  endif\n\n   if (length <= limit)\n   {\n      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);\n      /* The following is safe because of the PNG_SIZE_MAX init above */\n      png_ptr->unknown_chunk.size = (size_t)length/*SAFE*/;\n      /* 'mode' is a flag array, only the bottom four bits matter here */\n      png_ptr->unknown_chunk.location = (png_byte)png_ptr->mode/*SAFE*/;\n\n      if (length == 0)\n         png_ptr->unknown_chunk.data = NULL;\n\n      else\n      {\n         /* Do a 'warn' here - it is handled below. */\n         png_ptr->unknown_chunk.data = png_voidcast(png_bytep,\n             png_malloc_warn(png_ptr, length));\n      }\n   }\n\n   if (png_ptr->unknown_chunk.data == NULL && length > 0)\n   {\n      /* This is benign because we clean up correctly */\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"unknown chunk exceeds memory limits\");\n      return 0;\n   }\n\n   else\n   {\n      if (length > 0)\n         png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);\n      png_crc_finish(png_ptr, 0);\n      return 1;\n   }\n}\n#endif /* READ_UNKNOWN_CHUNKS */\n\n/* Handle an unknown, or known but disabled, chunk */\nvoid /* PRIVATE */\npng_handle_unknown(png_structrp png_ptr, png_inforp info_ptr,\n    png_uint_32 length, int keep)\n{\n   int handled = 0; /* the chunk was handled */\n\n   png_debug(1, \"in png_handle_unknown\");\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing\n    * the bug which meant that setting a non-default behavior for a specific\n    * chunk would be ignored (the default was always used unless a user\n    * callback was installed).\n    *\n    * 'keep' is the value from the png_chunk_unknown_handling, the setting for\n    * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it\n    * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.\n    * This is just an optimization to avoid multiple calls to the lookup\n    * function.\n    */\n#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n#     ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\n   keep = png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name);\n#     endif\n#  endif\n\n   /* One of the following methods will read the chunk or skip it (at least one\n    * of these is always defined because this is the only way to switch on\n    * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\n    */\n#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n   /* The user callback takes precedence over the chunk keep value, but the\n    * keep value is still required to validate a save of a critical chunk.\n    */\n   if (png_ptr->read_user_chunk_fn != NULL)\n   {\n      if (png_cache_unknown_chunk(png_ptr, length) != 0)\n      {\n         /* Callback to user unknown chunk handler */\n         int ret = (*(png_ptr->read_user_chunk_fn))(png_ptr,\n             &png_ptr->unknown_chunk);\n\n         /* ret is:\n          * negative: An error occurred; png_chunk_error will be called.\n          *     zero: The chunk was not handled, the chunk will be discarded\n          *           unless png_set_keep_unknown_chunks has been used to set\n          *           a 'keep' behavior for this particular chunk, in which\n          *           case that will be used.  A critical chunk will cause an\n          *           error at this point unless it is to be saved.\n          * positive: The chunk was handled, libpng will ignore/discard it.\n          */\n         if (ret < 0)\n            png_chunk_error(png_ptr, \"error in user chunk\");\n\n         else if (ret == 0)\n         {\n            /* If the keep value is 'default' or 'never' override it, but\n             * still error out on critical chunks unless the keep value is\n             * 'always'  While this is weird it is the behavior in 1.4.12.\n             * A possible improvement would be to obey the value set for the\n             * chunk, but this would be an API change that would probably\n             * damage some applications.\n             *\n             * The png_app_warning below catches the case that matters, where\n             * the application has not set specific save or ignore for this\n             * chunk or global save or ignore.\n             */\n            if (keep < PNG_HANDLE_CHUNK_IF_SAFE)\n            {\n#              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\n               if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)\n               {\n                  png_chunk_warning(png_ptr, \"Saving unknown chunk:\");\n                  png_app_warning(png_ptr,\n                      \"forcing save of an unhandled chunk;\"\n                      \" please call png_set_keep_unknown_chunks\");\n                      /* with keep = PNG_HANDLE_CHUNK_IF_SAFE */\n               }\n#              endif\n               keep = PNG_HANDLE_CHUNK_IF_SAFE;\n            }\n         }\n\n         else /* chunk was handled */\n         {\n            handled = 1;\n            /* Critical chunks can be safely discarded at this point. */\n            keep = PNG_HANDLE_CHUNK_NEVER;\n         }\n      }\n\n      else\n         keep = PNG_HANDLE_CHUNK_NEVER; /* insufficient memory */\n   }\n\n   else\n   /* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */\n#  endif /* READ_USER_CHUNKS */\n\n#  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED\n   {\n      /* keep is currently just the per-chunk setting, if there was no\n       * setting change it to the global default now (not that this may\n       * still be AS_DEFAULT) then obtain the cache of the chunk if required,\n       * if not simply skip the chunk.\n       */\n      if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n         keep = png_ptr->unknown_default;\n\n      if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\n         (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\n          PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\n      {\n         if (png_cache_unknown_chunk(png_ptr, length) == 0)\n            keep = PNG_HANDLE_CHUNK_NEVER;\n      }\n\n      else\n         png_crc_finish(png_ptr, length);\n   }\n#  else\n#     ifndef PNG_READ_USER_CHUNKS_SUPPORTED\n#        error no method to support READ_UNKNOWN_CHUNKS\n#     endif\n\n   {\n      /* If here there is no read callback pointer set and no support is\n       * compiled in to just save the unknown chunks, so simply skip this\n       * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then\n       * the app has erroneously asked for unknown chunk saving when there\n       * is no support.\n       */\n      if (keep > PNG_HANDLE_CHUNK_NEVER)\n         png_app_error(png_ptr, \"no unknown chunk support available\");\n\n      png_crc_finish(png_ptr, length);\n   }\n#  endif\n\n#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n   /* Now store the chunk in the chunk list if appropriate, and if the limits\n    * permit it.\n    */\n   if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\n      (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\n       PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\n   {\n#     ifdef PNG_USER_LIMITS_SUPPORTED\n      switch (png_ptr->user_chunk_cache_max)\n      {\n         case 2:\n            png_ptr->user_chunk_cache_max = 1;\n            png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n            /* FALLTHROUGH */\n         case 1:\n            /* NOTE: prior to 1.6.0 this case resulted in an unknown critical\n             * chunk being skipped, now there will be a hard error below.\n             */\n            break;\n\n         default: /* not at limit */\n            --(png_ptr->user_chunk_cache_max);\n            /* FALLTHROUGH */\n         case 0: /* no limit */\n#  endif /* USER_LIMITS */\n            /* Here when the limit isn't reached or when limits are compiled\n             * out; store the chunk.\n             */\n            png_set_unknown_chunks(png_ptr, info_ptr,\n                &png_ptr->unknown_chunk, 1);\n            handled = 1;\n#  ifdef PNG_USER_LIMITS_SUPPORTED\n            break;\n      }\n#  endif\n   }\n#  else /* no store support: the chunk must be handled by the user callback */\n   PNG_UNUSED(info_ptr)\n#  endif\n\n   /* Regardless of the error handling below the cached data (if any) can be\n    * freed now.  Notice that the data is not freed if there is a png_error, but\n    * it will be freed by destroy_read_struct.\n    */\n   if (png_ptr->unknown_chunk.data != NULL)\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n   png_ptr->unknown_chunk.data = NULL;\n\n#else /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */\n   /* There is no support to read an unknown chunk, so just skip it. */\n   png_crc_finish(png_ptr, length);\n   PNG_UNUSED(info_ptr)\n   PNG_UNUSED(keep)\n#endif /* !READ_UNKNOWN_CHUNKS */\n\n   /* Check for unhandled critical chunks */\n   if (handled == 0 && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\n      png_chunk_error(png_ptr, \"unhandled critical chunk\");\n}\n\n/* This function is called to verify that a chunk name is valid.\n * This function can't have the \"critical chunk check\" incorporated\n * into it, since in the future we will need to be able to call user\n * functions to handle unknown critical chunks after we check that\n * the chunk name itself is valid.\n */\n\n/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:\n *\n * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\n */\n\nvoid /* PRIVATE */\npng_check_chunk_name(png_const_structrp png_ptr, const png_uint_32 chunk_name)\n{\n   int i;\n   png_uint_32 cn=chunk_name;\n\n   png_debug(1, \"in png_check_chunk_name\");\n\n   for (i=1; i<=4; ++i)\n   {\n      int c = cn & 0xff;\n\n      if (c < 65 || c > 122 || (c > 90 && c < 97))\n         png_chunk_error(png_ptr, \"invalid chunk type\");\n\n      cn >>= 8;\n   }\n}\n\nvoid /* PRIVATE */\npng_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */\n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}\n\n/* Combines the row recently read in with the existing pixels in the row.  This\n * routine takes care of alpha and transparency if requested.  This routine also\n * handles the two methods of progressive display of interlaced images,\n * depending on the 'display' value; if 'display' is true then the whole row\n * (dp) is filled from the start by replicating the available pixels.  If\n * 'display' is false only those pixels present in the pass are filled in.\n */\nvoid /* PRIVATE */\npng_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)\n{\n   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;\n   png_const_bytep sp = png_ptr->row_buf + 1;\n   png_alloc_size_t row_width = png_ptr->width;\n   unsigned int pass = png_ptr->pass;\n   png_bytep end_ptr = 0;\n   png_byte end_byte = 0;\n   unsigned int end_mask;\n\n   png_debug(1, \"in png_combine_row\");\n\n   /* Added in 1.5.6: it should not be possible to enter this routine until at\n    * least one row has been read from the PNG data and transformed.\n    */\n   if (pixel_depth == 0)\n      png_error(png_ptr, \"internal row logic error\");\n\n   /* Added in 1.5.4: the pixel depth should match the information returned by\n    * any call to png_read_update_info at this point.  Do not continue if we got\n    * this wrong.\n    */\n   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=\n          PNG_ROWBYTES(pixel_depth, row_width))\n      png_error(png_ptr, \"internal row size calculation error\");\n\n   /* Don't expect this to ever happen: */\n   if (row_width == 0)\n      png_error(png_ptr, \"internal row width error\");\n\n   /* Preserve the last byte in cases where only part of it will be overwritten,\n    * the multiply below may overflow, we don't care because ANSI-C guarantees\n    * we get the low bits.\n    */\n   end_mask = (pixel_depth * row_width) & 7;\n   if (end_mask != 0)\n   {\n      /* end_ptr == NULL is a flag to say do nothing */\n      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;\n      end_byte = *end_ptr;\n#     ifdef PNG_READ_PACKSWAP_SUPPORTED\n      if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n         /* little-endian byte */\n         end_mask = (unsigned int)(0xff << end_mask);\n\n      else /* big-endian byte */\n#     endif\n      end_mask = 0xff >> end_mask;\n      /* end_mask is now the bits to *keep* from the destination row */\n   }\n\n   /* For non-interlaced images this reduces to a memcpy(). A memcpy()\n    * will also happen if interlacing isn't supported or if the application\n    * does not call png_set_interlace_handling().  In the latter cases the\n    * caller just gets a sequence of the unexpanded rows from each interlace\n    * pass.\n    */\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if (png_ptr->interlaced != 0 &&\n       (png_ptr->transformations & PNG_INTERLACE) != 0 &&\n       pass < 6 && (display == 0 ||\n       /* The following copies everything for 'display' on passes 0, 2 and 4. */\n       (display == 1 && (pass & 1) != 0)))\n   {\n      /* Narrow images may have no bits in a pass; the caller should handle\n       * this, but this test is cheap:\n       */\n      if (row_width <= PNG_PASS_START_COL(pass))\n         return;\n\n      if (pixel_depth < 8)\n      {\n         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit\n          * into 32 bits, then a single loop over the bytes using the four byte\n          * values in the 32-bit mask can be used.  For the 'display' option the\n          * expanded mask may also not require any masking within a byte.  To\n          * make this work the PACKSWAP option must be taken into account - it\n          * simply requires the pixels to be reversed in each byte.\n          *\n          * The 'regular' case requires a mask for each of the first 6 passes,\n          * the 'display' case does a copy for the even passes in the range\n          * 0..6.  This has already been handled in the test above.\n          *\n          * The masks are arranged as four bytes with the first byte to use in\n          * the lowest bits (little-endian) regardless of the order (PACKSWAP or\n          * not) of the pixels in each byte.\n          *\n          * NOTE: the whole of this logic depends on the caller of this function\n          * only calling it on rows appropriate to the pass.  This function only\n          * understands the 'x' logic; the 'y' logic is handled by the caller.\n          *\n          * The following defines allow generation of compile time constant bit\n          * masks for each pixel depth and each possibility of swapped or not\n          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,\n          * is in the range 0..7; and the result is 1 if the pixel is to be\n          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'\n          * for the block method.\n          *\n          * With some compilers a compile time expression of the general form:\n          *\n          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)\n          *\n          * Produces warnings with values of 'shift' in the range 33 to 63\n          * because the right hand side of the ?: expression is evaluated by\n          * the compiler even though it isn't used.  Microsoft Visual C (various\n          * versions) and the Intel C compiler are known to do this.  To avoid\n          * this the following macros are used in 1.5.6.  This is a temporary\n          * solution to avoid destabilizing the code during the release process.\n          */\n#        if PNG_USE_COMPILE_TIME_MASKS\n#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))\n#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))\n#        else\n#           define PNG_LSR(x,s) ((x)>>(s))\n#           define PNG_LSL(x,s) ((x)<<(s))\n#        endif\n#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)\n#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)\n\n         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is\n          * little endian - the first pixel is at bit 0 - however the extra\n          * parameter 's' can be set to cause the mask position to be swapped\n          * within each byte, to match the PNG format.  This is done by XOR of\n          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.\n          */\n#        define PIXEL_MASK(p,x,d,s) \\\n            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))\n\n         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.\n          */\n#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n\n         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp\n          * cases the result needs replicating, for the 4-bpp case the above\n          * generates a full 32 bits.\n          */\n#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))\n\n#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\\\n            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\\\n            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)\n\n#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\\\n            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\\\n            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)\n\n#if PNG_USE_COMPILE_TIME_MASKS\n         /* Utility macros to construct all the masks for a depth/swap\n          * combination.  The 's' parameter says whether the format is PNG\n          * (big endian bytes) or not.  Only the three odd-numbered passes are\n          * required for the display/block algorithm.\n          */\n#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\\\n            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }\n\n#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }\n\n#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))\n\n         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and\n          * then pass:\n          */\n         static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }\n         };\n\n         /* display_mask has only three entries for the odd passes, so index by\n          * pass>>1.\n          */\n         static PNG_CONST png_uint_32 display_mask[2][3][3] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }\n         };\n\n#        define MASK(pass,depth,display,png)\\\n            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\\\n               row_mask[png][DEPTH_INDEX(depth)][pass])\n\n#else /* !PNG_USE_COMPILE_TIME_MASKS */\n         /* This is the runtime alternative: it seems unlikely that this will\n          * ever be either smaller or faster than the compile time approach.\n          */\n#        define MASK(pass,depth,display,png)\\\n            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))\n#endif /* !USE_COMPILE_TIME_MASKS */\n\n         /* Use the appropriate mask to copy the required bits.  In some cases\n          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is\n          * the number of pixels, but the code copies bytes, so it is necessary\n          * to special case the end.\n          */\n         png_uint_32 pixels_per_byte = 8 / pixel_depth;\n         png_uint_32 mask;\n\n#        ifdef PNG_READ_PACKSWAP_SUPPORTED\n         if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n            mask = MASK(pass, pixel_depth, display, 0);\n\n         else\n#        endif\n         mask = MASK(pass, pixel_depth, display, 1);\n\n         for (;;)\n         {\n            png_uint_32 m;\n\n            /* It doesn't matter in the following if png_uint_32 has more than\n             * 32 bits because the high bits always match those in m<<24; it is,\n             * however, essential to use OR here, not +, because of this.\n             */\n            m = mask;\n            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */\n            m &= 0xff;\n\n            if (m != 0) /* something to copy */\n            {\n               if (m != 0xff)\n                  *dp = (png_byte)((*dp & ~m) | (*sp & m));\n               else\n                  *dp = *sp;\n            }\n\n            /* NOTE: this may overwrite the last byte with garbage if the image\n             * is not an exact number of bytes wide; libpng has always done\n             * this.\n             */\n            if (row_width <= pixels_per_byte)\n               break; /* May need to restore part of the last byte */\n\n            row_width -= pixels_per_byte;\n            ++dp;\n            ++sp;\n         }\n      }\n\n      else /* pixel_depth >= 8 */\n      {\n         unsigned int bytes_to_copy, bytes_to_jump;\n\n         /* Validate the depth - it must be a multiple of 8 */\n         if (pixel_depth & 7)\n            png_error(png_ptr, \"invalid user transform pixel depth\");\n\n         pixel_depth >>= 3; /* now in bytes */\n         row_width *= pixel_depth;\n\n         /* Regardless of pass number the Adam 7 interlace always results in a\n          * fixed number of pixels to copy then to skip.  There may be a\n          * different number of pixels to skip at the start though.\n          */\n         {\n            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;\n\n            row_width -= offset;\n            dp += offset;\n            sp += offset;\n         }\n\n         /* Work out the bytes to copy. */\n         if (display != 0)\n         {\n            /* When doing the 'block' algorithm the pixel in the pass gets\n             * replicated to adjacent pixels.  This is why the even (0,2,4,6)\n             * passes are skipped above - the entire expanded row is copied.\n             */\n            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;\n\n            /* But don't allow this number to exceed the actual row width. */\n            if (bytes_to_copy > row_width)\n               bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n         }\n\n         else /* normal row; Adam7 only ever gives us one pixel to copy. */\n            bytes_to_copy = pixel_depth;\n\n         /* In Adam7 there is a constant offset between where the pixels go. */\n         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;\n\n         /* And simply copy these bytes.  Some optimization is possible here,\n          * depending on the value of 'bytes_to_copy'.  Special case the low\n          * byte counts, which we know to be frequent.\n          *\n          * Notice that these cases all 'return' rather than 'break' - this\n          * avoids an unnecessary test on whether to restore the last byte\n          * below.\n          */\n         switch (bytes_to_copy)\n         {\n            case 1:\n               for (;;)\n               {\n                  *dp = *sp;\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  dp += bytes_to_jump;\n                  sp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            case 2:\n               /* There is a possibility of a partial copy at the end here; this\n                * slows the code down somewhat.\n                */\n               do\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n               while (row_width > 1);\n\n               /* And there can only be one byte left at this point: */\n               *dp = *sp;\n               return;\n\n            case 3:\n               /* This can only be the RGB case, so each copy is exactly one\n                * pixel and it is not necessary to check for a partial copy.\n                */\n               for (;;)\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            default:\n#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE\n               /* Check for double byte alignment and, if possible, use a\n                * 16-bit copy.  Don't attempt this for narrow images - ones that\n                * are less than an interlace panel wide.  Don't attempt it for\n                * wide bytes_to_copy either - use the memcpy there.\n                */\n               if (bytes_to_copy < 16 /*else use memcpy*/ &&\n                   png_isaligned(dp, png_uint_16) &&\n                   png_isaligned(sp, png_uint_16) &&\n                   bytes_to_copy % (sizeof (png_uint_16)) == 0 &&\n                   bytes_to_jump % (sizeof (png_uint_16)) == 0)\n               {\n                  /* Everything is aligned for png_uint_16 copies, but try for\n                   * png_uint_32 first.\n                   */\n                  if (png_isaligned(dp, png_uint_32) &&\n                      png_isaligned(sp, png_uint_32) &&\n                      bytes_to_copy % (sizeof (png_uint_32)) == 0 &&\n                      bytes_to_jump % (sizeof (png_uint_32)) == 0)\n                  {\n                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);\n                     png_const_uint_32p sp32 = png_aligncastconst(\n                         png_const_uint_32p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                         (sizeof (png_uint_32));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp32++ = *sp32++;\n                           c -= (sizeof (png_uint_32));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp32 += skip;\n                        sp32 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* Get to here when the row_width truncates the final copy.\n                      * There will be 1-3 bytes left to copy, so don't try the\n                      * 16-bit loop below.\n                      */\n                     dp = (png_bytep)dp32;\n                     sp = (png_const_bytep)sp32;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n\n                  /* Else do it in 16-bit quantities, but only if the size is\n                   * not too large.\n                   */\n                  else\n                  {\n                     png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);\n                     png_const_uint_16p sp16 = png_aligncastconst(\n                        png_const_uint_16p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                        (sizeof (png_uint_16));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp16++ = *sp16++;\n                           c -= (sizeof (png_uint_16));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp16 += skip;\n                        sp16 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* End of row - 1 byte left, bytes_to_copy > row_width: */\n                     dp = (png_bytep)dp16;\n                     sp = (png_const_bytep)sp16;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n               }\n#endif /* ALIGN_TYPE code */\n\n               /* The true default - use a memcpy: */\n               for (;;)\n               {\n                  memcpy(dp, sp, bytes_to_copy);\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n                  if (bytes_to_copy > row_width)\n                     bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n               }\n         }\n\n         /* NOT REACHED*/\n      } /* pixel_depth >= 8 */\n\n      /* Here if pixel_depth < 8 to check 'end_ptr' below. */\n   }\n   else\n#endif /* READ_INTERLACING */\n\n   /* If here then the switch above wasn't used so just memcpy the whole row\n    * from the temporary row buffer (notice that this overwrites the end of the\n    * destination row if it is a partial byte.)\n    */\n   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));\n\n   /* Restore the overwritten bits from the last byte if necessary. */\n   if (end_ptr != NULL)\n      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));\n}\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\nvoid /* PRIVATE */\npng_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,\n    png_uint_32 transformations /* Because these may affect the byte layout */)\n{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n   /* Offset to next interlace block */\n   static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   png_debug(1, \"in png_do_read_interlace\");\n   if (row != NULL && row_info != NULL)\n   {\n      png_uint_32 final_width;\n\n      final_width = row_info->width * png_pass_inc[pass];\n\n      switch (row_info->pixel_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 3);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 3);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_byte v;\n            png_uint_32 i;\n            int j;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n                sshift = ((row_info->width + 7) & 0x07);\n                dshift = ((final_width + 7) & 0x07);\n                s_start = 7;\n                s_end = 0;\n                s_inc = -1;\n            }\n\n            else\n#endif\n            {\n                sshift = 7 - ((row_info->width + 7) & 0x07);\n                dshift = 7 - ((final_width + 7) & 0x07);\n                s_start = 0;\n                s_end = 7;\n                s_inc = 1;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               v = (png_byte)((*sp >> sshift) & 0x01);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 2:\n         {\n            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);\n            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 3) & 0x03) << 1);\n               dshift = (((final_width + 3) & 0x03) << 1);\n               s_start = 6;\n               s_end = 0;\n               s_inc = -2;\n            }\n\n            else\n#endif\n            {\n               sshift = ((3 - ((row_info->width + 3) & 0x03)) << 1);\n               dshift = ((3 - ((final_width + 3) & 0x03)) << 1);\n               s_start = 0;\n               s_end = 6;\n               s_inc = 2;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v;\n               int j;\n\n               v = (png_byte)((*sp >> sshift) & 0x03);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 1);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 1);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            png_uint_32 i;\n            int jstop = (int)png_pass_inc[pass];\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 1) & 0x01) << 2);\n               dshift = (((final_width + 1) & 0x01) << 2);\n               s_start = 4;\n               s_end = 0;\n               s_inc = -4;\n            }\n\n            else\n#endif\n            {\n               sshift = ((1 - ((row_info->width + 1) & 0x01)) << 2);\n               dshift = ((1 - ((final_width + 1) & 0x01)) << 2);\n               s_start = 0;\n               s_end = 4;\n               s_inc = 4;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);\n               int j;\n\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         default:\n         {\n            size_t pixel_bytes = (row_info->pixel_depth >> 3);\n\n            png_bytep sp = row + (size_t)(row_info->width - 1)\n                * pixel_bytes;\n\n            png_bytep dp = row + (size_t)(final_width - 1) * pixel_bytes;\n\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */\n               int j;\n\n               memcpy(v, sp, pixel_bytes);\n\n               for (j = 0; j < jstop; j++)\n               {\n                  memcpy(dp, v, pixel_bytes);\n                  dp -= pixel_bytes;\n               }\n\n               sp -= pixel_bytes;\n            }\n            break;\n         }\n      }\n\n      row_info->width = final_width;\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);\n   }\n#ifndef PNG_READ_PACKSWAP_SUPPORTED\n   PNG_UNUSED(transformations)  /* Silence compiler warning */\n#endif\n}\n#endif /* READ_INTERLACING */\n\nstatic void\npng_read_filter_row_sub(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   size_t istop = row_info->rowbytes;\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   png_bytep rp = row + bpp;\n\n   PNG_UNUSED(prev_row)\n\n   for (i = bpp; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);\n      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_up(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   size_t istop = row_info->rowbytes;\n   png_bytep rp = row;\n   png_const_bytep pp = prev_row;\n\n   for (i = 0; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);\n      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_avg(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   png_bytep rp = row;\n   png_const_bytep pp = prev_row;\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   size_t istop = row_info->rowbytes - bpp;\n\n   for (i = 0; i < bpp; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) +\n         ((int)(*pp++) / 2 )) & 0xff);\n\n      rp++;\n   }\n\n   for (i = 0; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) +\n         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);\n\n      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   png_bytep rp_end = row + row_info->rowbytes;\n   int a, c;\n\n   /* First pixel/byte */\n   c = *prev_row++;\n   a = *row + c;\n   *row++ = (png_byte)a;\n\n   /* Remainder */\n   while (row < rp_end)\n   {\n      int b, pa, pb, pc, p;\n\n      a &= 0xff; /* From previous iteration or start */\n      b = *prev_row++;\n\n      p = b - c;\n      pc = a - c;\n\n#ifdef PNG_USE_ABS\n      pa = abs(p);\n      pb = abs(pc);\n      pc = abs(p + pc);\n#else\n      pa = p < 0 ? -p : p;\n      pb = pc < 0 ? -pc : pc;\n      pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n\n      /* Find the best predictor, the least of pa, pb, pc favoring the earlier\n       * ones in the case of a tie.\n       */\n      if (pb < pa)\n      {\n         pa = pb; a = b;\n      }\n      if (pc < pa) a = c;\n\n      /* Calculate the current pixel in a, and move the previous row pixel to c\n       * for the next time round the loop\n       */\n      c = b;\n      a += *row;\n      *row++ = (png_byte)a;\n   }\n}\n\nstatic void\npng_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   png_bytep rp_end = row + bpp;\n\n   /* Process the first pixel in the row completely (this is the same as 'up'\n    * because there is only one candidate predictor for the first row).\n    */\n   while (row < rp_end)\n   {\n      int a = *row + *prev_row++;\n      *row++ = (png_byte)a;\n   }\n\n   /* Remainder */\n   rp_end = rp_end + (row_info->rowbytes - bpp);\n\n   while (row < rp_end)\n   {\n      int a, b, c, pa, pb, pc, p;\n\n      c = *(prev_row - bpp);\n      a = *(row - bpp);\n      b = *prev_row++;\n\n      p = b - c;\n      pc = a - c;\n\n#ifdef PNG_USE_ABS\n      pa = abs(p);\n      pb = abs(pc);\n      pc = abs(p + pc);\n#else\n      pa = p < 0 ? -p : p;\n      pb = pc < 0 ? -pc : pc;\n      pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n\n      if (pb < pa)\n      {\n         pa = pb; a = b;\n      }\n      if (pc < pa) a = c;\n\n      a += *row;\n      *row++ = (png_byte)a;\n   }\n}\n\nstatic void\npng_init_filter_functions(png_structrp pp)\n   /* This function is called once for every PNG image (except for PNG images\n    * that only use PNG_FILTER_VALUE_NONE for all rows) to set the\n    * implementations required to reverse the filtering of PNG rows.  Reversing\n    * the filter is the first transformation performed on the row data.  It is\n    * performed in place, therefore an implementation can be selected based on\n    * the image pixel format.  If the implementation depends on image width then\n    * take care to ensure that it works correctly if the image is interlaced -\n    * interlacing causes the actual row width to vary.\n    */\n{\n   unsigned int bpp = (pp->pixel_depth + 7) >> 3;\n\n   pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;\n   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;\n   pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;\n   if (bpp == 1)\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n         png_read_filter_row_paeth_1byte_pixel;\n   else\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n         png_read_filter_row_paeth_multibyte_pixel;\n\n#ifdef PNG_FILTER_OPTIMIZATIONS\n   /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to\n    * call to install hardware optimizations for the above functions; simply\n    * replace whatever elements of the pp->read_filter[] array with a hardware\n    * specific (or, for that matter, generic) optimization.\n    *\n    * To see an example of this examine what configure.ac does when\n    * --enable-arm-neon is specified on the command line.\n    */\n   PNG_FILTER_OPTIMIZATIONS(pp, bpp);\n#endif\n}\n\nvoid /* PRIVATE */\npng_read_filter_row(png_structrp pp, png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row, int filter)\n{\n   /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define\n    * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic\n    * implementations.  See png_init_filter_functions above.\n    */\n   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)\n   {\n      if (pp->read_filter[0] == NULL)\n         png_init_filter_functions(pp);\n\n      pp->read_filter[filter-1](row_info, row, prev_row);\n   }\n}\n\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\nvoid /* PRIVATE */\npng_read_IDAT_data(png_structrp png_ptr, png_bytep output,\n    png_alloc_size_t avail_out)\n{\n   /* Loop reading IDATs and decompressing the result into output[avail_out] */\n   png_ptr->zstream.next_out = output;\n   png_ptr->zstream.avail_out = 0; /* safety: set below */\n\n   if (output == NULL)\n      avail_out = 0;\n\n   do\n   {\n      int ret;\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\n\n      if (png_ptr->zstream.avail_in == 0)\n      {\n         uInt avail_in;\n         png_bytep buffer;\n\n         while (png_ptr->idat_size == 0)\n         {\n            png_crc_finish(png_ptr, 0);\n\n            png_ptr->idat_size = png_read_chunk_header(png_ptr);\n            /* This is an error even in the 'check' case because the code just\n             * consumed a non-IDAT header.\n             */\n            if (png_ptr->chunk_name != png_IDAT)\n               png_error(png_ptr, \"Not enough image data\");\n         }\n\n         avail_in = png_ptr->IDAT_read_size;\n\n         if (avail_in > png_ptr->idat_size)\n            avail_in = (uInt)png_ptr->idat_size;\n\n         /* A PNG with a gradually increasing IDAT size will defeat this attempt\n          * to minimize memory usage by causing lots of re-allocs, but\n          * realistically doing IDAT_read_size re-allocs is not likely to be a\n          * big problem.\n          */\n         buffer = png_read_buffer(png_ptr, avail_in, 0/*error*/);\n\n         png_crc_read(png_ptr, buffer, avail_in);\n         png_ptr->idat_size -= avail_in;\n\n         png_ptr->zstream.next_in = buffer;\n         png_ptr->zstream.avail_in = avail_in;\n      }\n\n      /* And set up the output side. */\n      if (output != NULL) /* standard read */\n      {\n         uInt out = ZLIB_IO_MAX;\n\n         if (out > avail_out)\n            out = (uInt)avail_out;\n\n         avail_out -= out;\n         png_ptr->zstream.avail_out = out;\n      }\n\n      else /* after last row, checking for end */\n      {\n         png_ptr->zstream.next_out = tmpbuf;\n         png_ptr->zstream.avail_out = (sizeof tmpbuf);\n      }\n\n      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the\n       * process.  If the LZ stream is truncated the sequential reader will\n       * terminally damage the stream, above, by reading the chunk header of the\n       * following chunk (it then exits with png_error).\n       *\n       * TODO: deal more elegantly with truncated IDAT lists.\n       */\n      ret = PNG_INFLATE(png_ptr, Z_NO_FLUSH);\n\n      /* Take the unconsumed output back. */\n      if (output != NULL)\n         avail_out += png_ptr->zstream.avail_out;\n\n      else /* avail_out counts the extra bytes */\n         avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;\n\n      png_ptr->zstream.avail_out = 0;\n\n      if (ret == Z_STREAM_END)\n      {\n         /* Do this for safety; we won't read any more into this row. */\n         png_ptr->zstream.next_out = NULL;\n\n         png_ptr->mode |= PNG_AFTER_IDAT;\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\n\n         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)\n            png_chunk_benign_error(png_ptr, \"Extra compressed data\");\n         break;\n      }\n\n      if (ret != Z_OK)\n      {\n         png_zstream_error(png_ptr, ret);\n\n         if (output != NULL)\n            png_chunk_error(png_ptr, png_ptr->zstream.msg);\n\n         else /* checking */\n         {\n            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);\n            return;\n         }\n      }\n   } while (avail_out > 0);\n\n   if (avail_out > 0)\n   {\n      /* The stream ended before the image; this is the same as too few IDATs so\n       * should be handled the same way.\n       */\n      if (output != NULL)\n         png_error(png_ptr, \"Not enough image data\");\n\n      else /* the deflate stream contained extra data */\n         png_chunk_benign_error(png_ptr, \"Too much image data\");\n   }\n}\n\nvoid /* PRIVATE */\npng_read_finish_IDAT(png_structrp png_ptr)\n{\n   /* We don't need any more data and the stream should have ended, however the\n    * LZ end code may actually not have been processed.  In this case we must\n    * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk\n    * may still remain to be consumed.\n    */\n   if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)\n   {\n      /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in\n       * the compressed stream, but the stream may be damaged too, so even after\n       * this call we may need to terminate the zstream ownership.\n       */\n      png_read_IDAT_data(png_ptr, NULL, 0);\n      png_ptr->zstream.next_out = NULL; /* safety */\n\n      /* Now clear everything out for safety; the following may not have been\n       * done.\n       */\n      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)\n      {\n         png_ptr->mode |= PNG_AFTER_IDAT;\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\n      }\n   }\n\n   /* If the zstream has not been released do it now *and* terminate the reading\n    * of the final IDAT chunk.\n    */\n   if (png_ptr->zowner == png_IDAT)\n   {\n      /* Always do this; the pointers otherwise point into the read buffer. */\n      png_ptr->zstream.next_in = NULL;\n      png_ptr->zstream.avail_in = 0;\n\n      /* Now we no longer own the zstream. */\n      png_ptr->zowner = 0;\n\n      /* The slightly weird semantics of the sequential IDAT reading is that we\n       * are always in or at the end of an IDAT chunk, so we always need to do a\n       * crc_finish here.  If idat_size is non-zero we also need to read the\n       * spurious bytes at the end of the chunk now.\n       */\n      (void)png_crc_finish(png_ptr, png_ptr->idat_size);\n   }\n}\n\nvoid /* PRIVATE */\npng_read_finish_row(png_structrp png_ptr)\n{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* Start of interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* Offset to next interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n\n   png_debug(1, \"in png_read_finish_row\");\n   png_ptr->row_number++;\n   if (png_ptr->row_number < png_ptr->num_rows)\n      return;\n\n   if (png_ptr->interlaced != 0)\n   {\n      png_ptr->row_number = 0;\n\n      /* TO DO: don't do this if prev_row isn't needed (requires\n       * read-ahead of the next row's filter byte.\n       */\n      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n      do\n      {\n         png_ptr->pass++;\n\n         if (png_ptr->pass >= 7)\n            break;\n\n         png_ptr->iwidth = (png_ptr->width +\n            png_pass_inc[png_ptr->pass] - 1 -\n            png_pass_start[png_ptr->pass]) /\n            png_pass_inc[png_ptr->pass];\n\n         if ((png_ptr->transformations & PNG_INTERLACE) == 0)\n         {\n            png_ptr->num_rows = (png_ptr->height +\n                png_pass_yinc[png_ptr->pass] - 1 -\n                png_pass_ystart[png_ptr->pass]) /\n                png_pass_yinc[png_ptr->pass];\n         }\n\n         else  /* if (png_ptr->transformations & PNG_INTERLACE) */\n            break; /* libpng deinterlacing sees every row */\n\n      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);\n\n      if (png_ptr->pass < 7)\n         return;\n   }\n\n   /* Here after at the end of the last row of the last pass. */\n   png_read_finish_IDAT(png_ptr);\n}\n#endif /* SEQUENTIAL_READ */\n\nvoid /* PRIVATE */\npng_read_start_row(png_structrp png_ptr)\n{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* Start of interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* Offset to next interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n\n   unsigned int max_pixel_depth;\n   size_t row_bytes;\n\n   png_debug(1, \"in png_read_start_row\");\n\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\n   png_init_read_transformations(png_ptr);\n#endif\n   if (png_ptr->interlaced != 0)\n   {\n      if ((png_ptr->transformations & PNG_INTERLACE) == 0)\n         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -\n             png_pass_ystart[0]) / png_pass_yinc[0];\n\n      else\n         png_ptr->num_rows = png_ptr->height;\n\n      png_ptr->iwidth = (png_ptr->width +\n          png_pass_inc[png_ptr->pass] - 1 -\n          png_pass_start[png_ptr->pass]) /\n          png_pass_inc[png_ptr->pass];\n   }\n\n   else\n   {\n      png_ptr->num_rows = png_ptr->height;\n      png_ptr->iwidth = png_ptr->width;\n   }\n\n   max_pixel_depth = (unsigned int)png_ptr->pixel_depth;\n\n   /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of\n    * calculations to calculate the final pixel depth, then\n    * png_do_read_transforms actually does the transforms.  This means that the\n    * code which effectively calculates this value is actually repeated in three\n    * separate places.  They must all match.  Innocent changes to the order of\n    * transformations can and will break libpng in a way that causes memory\n    * overwrites.\n    *\n    * TODO: fix this.\n    */\n#ifdef PNG_READ_PACK_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACK) != 0 && png_ptr->bit_depth < 8)\n      max_pixel_depth = 8;\n#endif\n\n#ifdef PNG_READ_EXPAND_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND) != 0)\n   {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (png_ptr->num_trans != 0)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 24;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (max_pixel_depth < 8)\n            max_pixel_depth = 8;\n\n         if (png_ptr->num_trans != 0)\n            max_pixel_depth *= 2;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n      {\n         if (png_ptr->num_trans != 0)\n         {\n            max_pixel_depth *= 4;\n            max_pixel_depth /= 3;\n         }\n      }\n   }\n#endif\n\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)\n   {\n#  ifdef PNG_READ_EXPAND_SUPPORTED\n      /* In fact it is an error if it isn't supported, but checking is\n       * the safe way.\n       */\n      if ((png_ptr->transformations & PNG_EXPAND) != 0)\n      {\n         if (png_ptr->bit_depth < 16)\n            max_pixel_depth *= 2;\n      }\n      else\n#  endif\n      png_ptr->transformations &= ~PNG_EXPAND_16;\n   }\n#endif\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n   if ((png_ptr->transformations & (PNG_FILLER)) != 0)\n   {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (max_pixel_depth <= 8)\n            max_pixel_depth = 16;\n\n         else\n            max_pixel_depth = 32;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB ||\n         png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (max_pixel_depth <= 32)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 64;\n      }\n   }\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)\n   {\n      if (\n#ifdef PNG_READ_EXPAND_SUPPORTED\n          (png_ptr->num_trans != 0 &&\n          (png_ptr->transformations & PNG_EXPAND) != 0) ||\n#endif\n#ifdef PNG_READ_FILLER_SUPPORTED\n          (png_ptr->transformations & (PNG_FILLER)) != 0 ||\n#endif\n          png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      {\n         if (max_pixel_depth <= 16)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 64;\n      }\n\n      else\n      {\n         if (max_pixel_depth <= 8)\n         {\n            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n               max_pixel_depth = 32;\n\n            else\n               max_pixel_depth = 24;\n         }\n\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            max_pixel_depth = 64;\n\n         else\n            max_pixel_depth = 48;\n      }\n   }\n#endif\n\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \\\ndefined(PNG_USER_TRANSFORM_PTR_SUPPORTED)\n   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)\n   {\n      unsigned int user_pixel_depth = png_ptr->user_transform_depth *\n         png_ptr->user_transform_channels;\n\n      if (user_pixel_depth > max_pixel_depth)\n         max_pixel_depth = user_pixel_depth;\n   }\n#endif\n\n   /* This value is stored in png_struct and double checked in the row read\n    * code.\n    */\n   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;\n   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */\n\n   /* Align the width on the next larger 8 pixels.  Mainly used\n    * for interlacing\n    */\n   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));\n   /* Calculate the maximum bytes needed, adding a byte and a pixel\n    * for safety's sake\n    */\n   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +\n       1 + ((max_pixel_depth + 7) >> 3U);\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (row_bytes > (png_uint_32)65536L)\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\n#endif\n\n   if (row_bytes + 48 > png_ptr->old_big_row_buf_size)\n   {\n      png_free(png_ptr, png_ptr->big_row_buf);\n      png_free(png_ptr, png_ptr->big_prev_row);\n\n      if (png_ptr->interlaced != 0)\n         png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,\n             row_bytes + 48);\n\n      else\n         png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\n\n      png_ptr->big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\n\n#ifdef PNG_ALIGNED_MEMORY_SUPPORTED\n      /* Use 16-byte aligned memory for row_buf with at least 16 bytes\n       * of padding before and after row_buf; treat prev_row similarly.\n       * NOTE: the alignment is to the start of the pixels, one beyond the start\n       * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this\n       * was incorrect; the filter byte was aligned, which had the exact\n       * opposite effect of that intended.\n       */\n      {\n         png_bytep temp = png_ptr->big_row_buf + 32;\n         int extra = (int)((temp - (png_bytep)0) & 0x0f);\n         png_ptr->row_buf = temp - extra - 1/*filter byte*/;\n\n         temp = png_ptr->big_prev_row + 32;\n         extra = (int)((temp - (png_bytep)0) & 0x0f);\n         png_ptr->prev_row = temp - extra - 1/*filter byte*/;\n      }\n\n#else\n      /* Use 31 bytes of padding before and 17 bytes after row_buf. */\n      png_ptr->row_buf = png_ptr->big_row_buf + 31;\n      png_ptr->prev_row = png_ptr->big_prev_row + 31;\n#endif\n      png_ptr->old_big_row_buf_size = row_bytes + 48;\n   }\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (png_ptr->rowbytes > 65535)\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\n\n#endif\n   if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))\n      png_error(png_ptr, \"Row has too many bytes to allocate in memory\");\n\n   memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n   png_debug1(3, \"width = %u,\", png_ptr->width);\n   png_debug1(3, \"height = %u,\", png_ptr->height);\n   png_debug1(3, \"iwidth = %u,\", png_ptr->iwidth);\n   png_debug1(3, \"num_rows = %u,\", png_ptr->num_rows);\n   png_debug1(3, \"rowbytes = %lu,\", (unsigned long)png_ptr->rowbytes);\n   png_debug1(3, \"irowbytes = %lu\",\n       (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);\n\n   /* The sequential reader needs a buffer for IDAT, but the progressive reader\n    * does not, so free the read buffer now regardless; the sequential reader\n    * reallocates it on demand.\n    */\n   if (png_ptr->read_buffer != NULL)\n   {\n      png_bytep buffer = png_ptr->read_buffer;\n\n      png_ptr->read_buffer_size = 0;\n      png_ptr->read_buffer = NULL;\n      png_free(png_ptr, buffer);\n   }\n\n   /* Finally claim the zstream for the inflate of the IDAT data, use the bits\n    * value from the stream (note that this will result in a fatal error if the\n    * IDAT stream has a bogus deflate header window_bits value, but this should\n    * not be happening any longer!)\n    */\n   if (png_inflate_claim(png_ptr, png_IDAT) != Z_OK)\n      png_error(png_ptr, png_ptr->zstream.msg);\n\n   png_ptr->flags |= PNG_FLAG_ROW_INIT;\n}\n#endif /* READ */\n"], "fixing_code": ["\n/* pngrutil.c - utilities to read a PNG file\n *\n * Last changed in libpng 1.6.35 [(PENDING RELEASE)]\n * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\n *\n * This code is released under the libpng license.\n * For conditions of distribution and use, see the disclaimer\n * and license in png.h\n *\n * This file contains routines that are only called from within\n * libpng itself during the course of reading an image.\n */\n\n#include \"pngpriv.h\"\n\n#ifdef PNG_READ_SUPPORTED\n\npng_uint_32 PNGAPI\npng_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n\n   if (uval > PNG_UINT_31_MAX)\n      png_error(png_ptr, \"PNG unsigned integer out of range\");\n\n   return (uval);\n}\n\n#if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)\n/* The following is a variation on the above for use with the fixed\n * point values used for gAMA and cHRM.  Instead of png_error it\n * issues a warning and returns (-1) - an invalid value because both\n * gAMA and cHRM use *unsigned* integers for fixed point values.\n */\n#define PNG_FIXED_ERROR (-1)\n\nstatic png_fixed_point /* PRIVATE */\npng_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n\n   if (uval <= PNG_UINT_31_MAX)\n      return (png_fixed_point)uval; /* known to be in range */\n\n   /* The caller can turn off the warning by passing NULL. */\n   if (png_ptr != NULL)\n      png_warning(png_ptr, \"PNG fixed point integer out of range\");\n\n   return PNG_FIXED_ERROR;\n}\n#endif\n\n#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED\n/* NOTE: the read macros will obscure these definitions, so that if\n * PNG_USE_READ_MACROS is set the library will not use them internally,\n * but the APIs will still be available externally.\n *\n * The parentheses around \"PNGAPI function_name\" in the following three\n * functions are necessary because they allow the macros to co-exist with\n * these (unused but exported) functions.\n */\n\n/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\npng_uint_32 (PNGAPI\npng_get_uint_32)(png_const_bytep buf)\n{\n   png_uint_32 uval =\n       ((png_uint_32)(*(buf    )) << 24) +\n       ((png_uint_32)(*(buf + 1)) << 16) +\n       ((png_uint_32)(*(buf + 2)) <<  8) +\n       ((png_uint_32)(*(buf + 3))      ) ;\n\n   return uval;\n}\n\n/* Grab a signed 32-bit integer from a buffer in big-endian format.  The\n * data is stored in the PNG file in two's complement format and there\n * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore\n * the following code does a two's complement to native conversion.\n */\npng_int_32 (PNGAPI\npng_get_int_32)(png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n   if ((uval & 0x80000000) == 0) /* non-negative */\n      return (png_int_32)uval;\n\n   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */\n   if ((uval & 0x80000000) == 0) /* no overflow */\n      return -(png_int_32)uval;\n   /* The following has to be safe; this function only gets called on PNG data\n    * and if we get here that data is invalid.  0 is the most safe value and\n    * if not then an attacker would surely just generate a PNG with 0 instead.\n    */\n   return 0;\n}\n\n/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */\npng_uint_16 (PNGAPI\npng_get_uint_16)(png_const_bytep buf)\n{\n   /* ANSI-C requires an int value to accommodate at least 16 bits so this\n    * works and allows the compiler not to worry about possible narrowing\n    * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller\n    * than 16 bits either.)\n    */\n   unsigned int val =\n       ((unsigned int)(*buf) << 8) +\n       ((unsigned int)(*(buf + 1)));\n\n   return (png_uint_16)val;\n}\n\n#endif /* READ_INT_FUNCTIONS */\n\n/* Read and check the PNG file signature */\nvoid /* PRIVATE */\npng_read_sig(png_structrp png_ptr, png_inforp info_ptr)\n{\n   size_t num_checked, num_to_check;\n\n   /* Exit if the user application does not expect a signature. */\n   if (png_ptr->sig_bytes >= 8)\n      return;\n\n   num_checked = png_ptr->sig_bytes;\n   num_to_check = 8 - num_checked;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;\n#endif\n\n   /* The signature must be serialized in a single I/O call. */\n   png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);\n   png_ptr->sig_bytes = 8;\n\n   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check) != 0)\n   {\n      if (num_checked < 4 &&\n          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n         png_error(png_ptr, \"Not a PNG file\");\n      else\n         png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\n   }\n   if (num_checked < 3)\n      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;\n}\n\n/* Read the chunk header (length + type name).\n * Put the type name into png_ptr->chunk_name, and return the length.\n */\npng_uint_32 /* PRIVATE */\npng_read_chunk_header(png_structrp png_ptr)\n{\n   png_byte buf[8];\n   png_uint_32 length;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;\n#endif\n\n   /* Read the length and the chunk name.\n    * This must be performed in a single I/O call.\n    */\n   png_read_data(png_ptr, buf, 8);\n   length = png_get_uint_31(png_ptr, buf);\n\n   /* Put the chunk name into png_ptr->chunk_name. */\n   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n\n   png_debug2(0, \"Reading %lx chunk, length = %lu\",\n       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\n\n   /* Reset the crc and run it over the chunk name. */\n   png_reset_crc(png_ptr);\n   png_calculate_crc(png_ptr, buf + 4, 4);\n\n   /* Check to see if chunk name is valid. */\n   png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n\n   /* Check for too-large chunk length */\n   png_check_chunk_length(png_ptr, length);\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;\n#endif\n\n   return length;\n}\n\n/* Read data, and (optionally) run it through the CRC. */\nvoid /* PRIVATE */\npng_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)\n{\n   if (png_ptr == NULL)\n      return;\n\n   png_read_data(png_ptr, buf, length);\n   png_calculate_crc(png_ptr, buf, length);\n}\n\n/* Optionally skip data and then check the CRC.  Depending on whether we\n * are reading an ancillary or critical chunk, and how the program has set\n * things up, we may calculate the CRC on the data and print a message.\n * Returns '1' if there was a CRC error, '0' otherwise.\n */\nint /* PRIVATE */\npng_crc_finish(png_structrp png_ptr, png_uint_32 skip)\n{\n   /* The size of the local buffer for inflate is a good guess as to a\n    * reasonable size to use for buffering reads from the application.\n    */\n   while (skip > 0)\n   {\n      png_uint_32 len;\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\n\n      len = (sizeof tmpbuf);\n      if (len > skip)\n         len = skip;\n      skip -= len;\n\n      png_crc_read(png_ptr, tmpbuf, len);\n   }\n\n   if (png_crc_error(png_ptr) != 0)\n   {\n      if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?\n          (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :\n          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)\n      {\n         png_chunk_warning(png_ptr, \"CRC error\");\n      }\n\n      else\n         png_chunk_error(png_ptr, \"CRC error\");\n\n      return (1);\n   }\n\n   return (0);\n}\n\n/* Compare the CRC stored in the PNG file with that calculated by libpng from\n * the data it has read thus far.\n */\nint /* PRIVATE */\npng_crc_error(png_structrp png_ptr)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n\n   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n\n   else /* critical */\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n         need_crc = 0;\n   }\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n#endif\n\n   /* The chunk CRC must be serialized in a single I/O call. */\n   png_read_data(png_ptr, crc_bytes, 4);\n\n   if (need_crc != 0)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n\n   else\n      return (0);\n}\n\n#if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\\\n    defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\\\n    defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\\\n    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)\n/* Manage the read buffer; this simply reallocates the buffer if it is not small\n * enough (or if it is not allocated).  The routine returns a pointer to the\n * buffer; if an error occurs and 'warn' is set the routine returns NULL, else\n * it will call png_error (via png_malloc) on failure.  (warn == 2 means\n * 'silent').\n */\nstatic png_bytep\npng_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size, int warn)\n{\n   png_bytep buffer = png_ptr->read_buffer;\n\n   if (buffer != NULL && new_size > png_ptr->read_buffer_size)\n   {\n      png_ptr->read_buffer = NULL;\n      png_ptr->read_buffer = NULL;\n      png_ptr->read_buffer_size = 0;\n      png_free(png_ptr, buffer);\n      buffer = NULL;\n   }\n\n   if (buffer == NULL)\n   {\n      buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size));\n\n      if (buffer != NULL)\n      {\n         memset(buffer, 0, new_size); /* just in case */\n         png_ptr->read_buffer = buffer;\n         png_ptr->read_buffer_size = new_size;\n      }\n\n      else if (warn < 2) /* else silent */\n      {\n         if (warn != 0)\n             png_chunk_warning(png_ptr, \"insufficient memory to read chunk\");\n\n         else\n             png_chunk_error(png_ptr, \"insufficient memory to read chunk\");\n      }\n   }\n\n   return buffer;\n}\n#endif /* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */\n\n/* png_inflate_claim: claim the zstream for some nefarious purpose that involves\n * decompression.  Returns Z_OK on success, else a zlib error code.  It checks\n * the owner but, in final release builds, just issues a warning if some other\n * chunk apparently owns the stream.  Prior to release it does a png_error.\n */\nstatic int\npng_inflate_claim(png_structrp png_ptr, png_uint_32 owner)\n{\n   if (png_ptr->zowner != 0)\n   {\n      char msg[64];\n\n      PNG_STRING_FROM_CHUNK(msg, png_ptr->zowner);\n      /* So the message that results is \"<chunk> using zstream\"; this is an\n       * internal error, but is very useful for debugging.  i18n requirements\n       * are minimal.\n       */\n      (void)png_safecat(msg, (sizeof msg), 4, \" using zstream\");\n#if PNG_RELEASE_BUILD\n      png_chunk_warning(png_ptr, msg);\n      png_ptr->zowner = 0;\n#else\n      png_chunk_error(png_ptr, msg);\n#endif\n   }\n\n   /* Implementation note: unlike 'png_deflate_claim' this internal function\n    * does not take the size of the data as an argument.  Some efficiency could\n    * be gained by using this when it is known *if* the zlib stream itself does\n    * not record the number; however, this is an illusion: the original writer\n    * of the PNG may have selected a lower window size, and we really must\n    * follow that because, for systems with with limited capabilities, we\n    * would otherwise reject the application's attempts to use a smaller window\n    * size (zlib doesn't have an interface to say \"this or lower\"!).\n    *\n    * inflateReset2 was added to zlib 1.2.4; before this the window could not be\n    * reset, therefore it is necessary to always allocate the maximum window\n    * size with earlier zlibs just in case later compressed chunks need it.\n    */\n   {\n      int ret; /* zlib return code */\n#if ZLIB_VERNUM >= 0x1240\n      int window_bits = 0;\n\n# if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)\n      if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==\n          PNG_OPTION_ON)\n      {\n         window_bits = 15;\n         png_ptr->zstream_start = 0; /* fixed window size */\n      }\n\n      else\n      {\n         png_ptr->zstream_start = 1;\n      }\n# endif\n\n#endif /* ZLIB_VERNUM >= 0x1240 */\n\n      /* Set this for safety, just in case the previous owner left pointers to\n       * memory allocations.\n       */\n      png_ptr->zstream.next_in = NULL;\n      png_ptr->zstream.avail_in = 0;\n      png_ptr->zstream.next_out = NULL;\n      png_ptr->zstream.avail_out = 0;\n\n      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)\n      {\n#if ZLIB_VERNUM >= 0x1240\n         ret = inflateReset2(&png_ptr->zstream, window_bits);\n#else\n         ret = inflateReset(&png_ptr->zstream);\n#endif\n      }\n\n      else\n      {\n#if ZLIB_VERNUM >= 0x1240\n         ret = inflateInit2(&png_ptr->zstream, window_bits);\n#else\n         ret = inflateInit(&png_ptr->zstream);\n#endif\n\n         if (ret == Z_OK)\n            png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;\n      }\n\n#if ZLIB_VERNUM >= 0x1290 && \\\n   defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_IGNORE_ADLER32)\n      if (((png_ptr->options >> PNG_IGNORE_ADLER32) & 3) == PNG_OPTION_ON)\n         /* Turn off validation of the ADLER32 checksum in IDAT chunks */\n         ret = inflateValidate(&png_ptr->zstream, 0);\n#endif\n\n      if (ret == Z_OK)\n         png_ptr->zowner = owner;\n\n      else\n         png_zstream_error(png_ptr, ret);\n\n      return ret;\n   }\n\n#ifdef window_bits\n# undef window_bits\n#endif\n}\n\n#if ZLIB_VERNUM >= 0x1240\n/* Handle the start of the inflate stream if we called inflateInit2(strm,0);\n * in this case some zlib versions skip validation of the CINFO field and, in\n * certain circumstances, libpng may end up displaying an invalid image, in\n * contrast to implementations that call zlib in the normal way (e.g. libpng\n * 1.5).\n */\nint /* PRIVATE */\npng_zlib_inflate(png_structrp png_ptr, int flush)\n{\n   if (png_ptr->zstream_start && png_ptr->zstream.avail_in > 0)\n   {\n      if ((*png_ptr->zstream.next_in >> 4) > 7)\n      {\n         png_ptr->zstream.msg = \"invalid window size (libpng)\";\n         return Z_DATA_ERROR;\n      }\n\n      png_ptr->zstream_start = 0;\n   }\n\n   return inflate(&png_ptr->zstream, flush);\n}\n#endif /* Zlib >= 1.2.4 */\n\n#ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED\n#if defined(PNG_READ_zTXt_SUPPORTED) || defined (PNG_READ_iTXt_SUPPORTED)\n/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to\n * allow the caller to do multiple calls if required.  If the 'finish' flag is\n * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must\n * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and\n * Z_OK or Z_STREAM_END will be returned on success.\n *\n * The input and output sizes are updated to the actual amounts of data consumed\n * or written, not the amount available (as in a z_stream).  The data pointers\n * are not changed, so the next input is (data+input_size) and the next\n * available output is (output+output_size).\n */\nstatic int\npng_inflate(png_structrp png_ptr, png_uint_32 owner, int finish,\n    /* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,\n    /* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)\n{\n   if (png_ptr->zowner == owner) /* Else not claimed */\n   {\n      int ret;\n      png_alloc_size_t avail_out = *output_size_ptr;\n      png_uint_32 avail_in = *input_size_ptr;\n\n      /* zlib can't necessarily handle more than 65535 bytes at once (i.e. it\n       * can't even necessarily handle 65536 bytes) because the type uInt is\n       * \"16 bits or more\".  Consequently it is necessary to chunk the input to\n       * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the\n       * maximum value that can be stored in a uInt.)  It is possible to set\n       * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have\n       * a performance advantage, because it reduces the amount of data accessed\n       * at each step and that may give the OS more time to page it in.\n       */\n      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);\n      /* avail_in and avail_out are set below from 'size' */\n      png_ptr->zstream.avail_in = 0;\n      png_ptr->zstream.avail_out = 0;\n\n      /* Read directly into the output if it is available (this is set to\n       * a local buffer below if output is NULL).\n       */\n      if (output != NULL)\n         png_ptr->zstream.next_out = output;\n\n      do\n      {\n         uInt avail;\n         Byte local_buffer[PNG_INFLATE_BUF_SIZE];\n\n         /* zlib INPUT BUFFER */\n         /* The setting of 'avail_in' used to be outside the loop; by setting it\n          * inside it is possible to chunk the input to zlib and simply rely on\n          * zlib to advance the 'next_in' pointer.  This allows arbitrary\n          * amounts of data to be passed through zlib at the unavoidable cost of\n          * requiring a window save (memcpy of up to 32768 output bytes)\n          * every ZLIB_IO_MAX input bytes.\n          */\n         avail_in += png_ptr->zstream.avail_in; /* not consumed last time */\n\n         avail = ZLIB_IO_MAX;\n\n         if (avail_in < avail)\n            avail = (uInt)avail_in; /* safe: < than ZLIB_IO_MAX */\n\n         avail_in -= avail;\n         png_ptr->zstream.avail_in = avail;\n\n         /* zlib OUTPUT BUFFER */\n         avail_out += png_ptr->zstream.avail_out; /* not written last time */\n\n         avail = ZLIB_IO_MAX; /* maximum zlib can process */\n\n         if (output == NULL)\n         {\n            /* Reset the output buffer each time round if output is NULL and\n             * make available the full buffer, up to 'remaining_space'\n             */\n            png_ptr->zstream.next_out = local_buffer;\n            if ((sizeof local_buffer) < avail)\n               avail = (sizeof local_buffer);\n         }\n\n         if (avail_out < avail)\n            avail = (uInt)avail_out; /* safe: < ZLIB_IO_MAX */\n\n         png_ptr->zstream.avail_out = avail;\n         avail_out -= avail;\n\n         /* zlib inflate call */\n         /* In fact 'avail_out' may be 0 at this point, that happens at the end\n          * of the read when the final LZ end code was not passed at the end of\n          * the previous chunk of input data.  Tell zlib if we have reached the\n          * end of the output buffer.\n          */\n         ret = PNG_INFLATE(png_ptr, avail_out > 0 ? Z_NO_FLUSH :\n             (finish ? Z_FINISH : Z_SYNC_FLUSH));\n      } while (ret == Z_OK);\n\n      /* For safety kill the local buffer pointer now */\n      if (output == NULL)\n         png_ptr->zstream.next_out = NULL;\n\n      /* Claw back the 'size' and 'remaining_space' byte counts. */\n      avail_in += png_ptr->zstream.avail_in;\n      avail_out += png_ptr->zstream.avail_out;\n\n      /* Update the input and output sizes; the updated values are the amount\n       * consumed or written, effectively the inverse of what zlib uses.\n       */\n      if (avail_out > 0)\n         *output_size_ptr -= avail_out;\n\n      if (avail_in > 0)\n         *input_size_ptr -= avail_in;\n\n      /* Ensure png_ptr->zstream.msg is set (even in the success case!) */\n      png_zstream_error(png_ptr, ret);\n      return ret;\n   }\n\n   else\n   {\n      /* This is a bad internal error.  The recovery assigns to the zstream msg\n       * pointer, which is not owned by the caller, but this is safe; it's only\n       * used on errors!\n       */\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\n      return Z_STREAM_ERROR;\n   }\n}\n\n/*\n * Decompress trailing data in a chunk.  The assumption is that read_buffer\n * points at an allocated area holding the contents of a chunk with a\n * trailing compressed part.  What we get back is an allocated area\n * holding the original prefix part and an uncompressed version of the\n * trailing part (the malloc area passed in is freed).\n */\nstatic int\npng_decompress_chunk(png_structrp png_ptr,\n    png_uint_32 chunklength, png_uint_32 prefix_size,\n    png_alloc_size_t *newlength /* must be initialized to the maximum! */,\n    int terminate /*add a '\\0' to the end of the uncompressed data*/)\n{\n   /* TODO: implement different limits for different types of chunk.\n    *\n    * The caller supplies *newlength set to the maximum length of the\n    * uncompressed data, but this routine allocates space for the prefix and\n    * maybe a '\\0' terminator too.  We have to assume that 'prefix_size' is\n    * limited only by the maximum chunk size.\n    */\n   png_alloc_size_t limit = PNG_SIZE_MAX;\n\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n\n   if (limit >= prefix_size + (terminate != 0))\n   {\n      int ret;\n\n      limit -= prefix_size + (terminate != 0);\n\n      if (limit < *newlength)\n         *newlength = limit;\n\n      /* Now try to claim the stream. */\n      ret = png_inflate_claim(png_ptr, png_ptr->chunk_name);\n\n      if (ret == Z_OK)\n      {\n         png_uint_32 lzsize = chunklength - prefix_size;\n\n         ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\n             /* input: */ png_ptr->read_buffer + prefix_size, &lzsize,\n             /* output: */ NULL, newlength);\n\n         if (ret == Z_STREAM_END)\n         {\n            /* Use 'inflateReset' here, not 'inflateReset2' because this\n             * preserves the previously decided window size (otherwise it would\n             * be necessary to store the previous window size.)  In practice\n             * this doesn't matter anyway, because png_inflate will call inflate\n             * with Z_FINISH in almost all cases, so the window will not be\n             * maintained.\n             */\n            if (inflateReset(&png_ptr->zstream) == Z_OK)\n            {\n               /* Because of the limit checks above we know that the new,\n                * expanded, size will fit in a size_t (let alone an\n                * png_alloc_size_t).  Use png_malloc_base here to avoid an\n                * extra OOM message.\n                */\n               png_alloc_size_t new_size = *newlength;\n               png_alloc_size_t buffer_size = prefix_size + new_size +\n                   (terminate != 0);\n               png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,\n                   buffer_size));\n\n               if (text != NULL)\n               {\n                  memset(text, 0, buffer_size);\n\n                  ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\n                      png_ptr->read_buffer + prefix_size, &lzsize,\n                      text + prefix_size, newlength);\n\n                  if (ret == Z_STREAM_END)\n                  {\n                     if (new_size == *newlength)\n                     {\n                        if (terminate != 0)\n                           text[prefix_size + *newlength] = 0;\n\n                        if (prefix_size > 0)\n                           memcpy(text, png_ptr->read_buffer, prefix_size);\n\n                        {\n                           png_bytep old_ptr = png_ptr->read_buffer;\n\n                           png_ptr->read_buffer = text;\n                           png_ptr->read_buffer_size = buffer_size;\n                           text = old_ptr; /* freed below */\n                        }\n                     }\n\n                     else\n                     {\n                        /* The size changed on the second read, there can be no\n                         * guarantee that anything is correct at this point.\n                         * The 'msg' pointer has been set to \"unexpected end of\n                         * LZ stream\", which is fine, but return an error code\n                         * that the caller won't accept.\n                         */\n                        ret = PNG_UNEXPECTED_ZLIB_RETURN;\n                     }\n                  }\n\n                  else if (ret == Z_OK)\n                     ret = PNG_UNEXPECTED_ZLIB_RETURN; /* for safety */\n\n                  /* Free the text pointer (this is the old read_buffer on\n                   * success)\n                   */\n                  png_free(png_ptr, text);\n\n                  /* This really is very benign, but it's still an error because\n                   * the extra space may otherwise be used as a Trojan Horse.\n                   */\n                  if (ret == Z_STREAM_END &&\n                      chunklength - prefix_size != lzsize)\n                     png_chunk_benign_error(png_ptr, \"extra compressed data\");\n               }\n\n               else\n               {\n                  /* Out of memory allocating the buffer */\n                  ret = Z_MEM_ERROR;\n                  png_zstream_error(png_ptr, Z_MEM_ERROR);\n               }\n            }\n\n            else\n            {\n               /* inflateReset failed, store the error message */\n               png_zstream_error(png_ptr, ret);\n               ret = PNG_UNEXPECTED_ZLIB_RETURN;\n            }\n         }\n\n         else if (ret == Z_OK)\n            ret = PNG_UNEXPECTED_ZLIB_RETURN;\n\n         /* Release the claimed stream */\n         png_ptr->zowner = 0;\n      }\n\n      else /* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */\n         ret = PNG_UNEXPECTED_ZLIB_RETURN;\n\n      return ret;\n   }\n\n   else\n   {\n      /* Application/configuration limits exceeded */\n      png_zstream_error(png_ptr, Z_MEM_ERROR);\n      return Z_MEM_ERROR;\n   }\n}\n#endif /* READ_zTXt || READ_iTXt */\n#endif /* READ_COMPRESSED_TEXT */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n/* Perform a partial read and decompress, producing 'avail_out' bytes and\n * reading from the current chunk as required.\n */\nstatic int\npng_inflate_read(png_structrp png_ptr, png_bytep read_buffer, uInt read_size,\n    png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,\n    int finish)\n{\n   if (png_ptr->zowner == png_ptr->chunk_name)\n   {\n      int ret;\n\n      /* next_in and avail_in must have been initialized by the caller. */\n      png_ptr->zstream.next_out = next_out;\n      png_ptr->zstream.avail_out = 0; /* set in the loop */\n\n      do\n      {\n         if (png_ptr->zstream.avail_in == 0)\n         {\n            if (read_size > *chunk_bytes)\n               read_size = (uInt)*chunk_bytes;\n            *chunk_bytes -= read_size;\n\n            if (read_size > 0)\n               png_crc_read(png_ptr, read_buffer, read_size);\n\n            png_ptr->zstream.next_in = read_buffer;\n            png_ptr->zstream.avail_in = read_size;\n         }\n\n         if (png_ptr->zstream.avail_out == 0)\n         {\n            uInt avail = ZLIB_IO_MAX;\n            if (avail > *out_size)\n               avail = (uInt)*out_size;\n            *out_size -= avail;\n\n            png_ptr->zstream.avail_out = avail;\n         }\n\n         /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all\n          * the available output is produced; this allows reading of truncated\n          * streams.\n          */\n         ret = PNG_INFLATE(png_ptr, *chunk_bytes > 0 ?\n             Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));\n      }\n      while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));\n\n      *out_size += png_ptr->zstream.avail_out;\n      png_ptr->zstream.avail_out = 0; /* Should not be required, but is safe */\n\n      /* Ensure the error message pointer is always set: */\n      png_zstream_error(png_ptr, ret);\n      return ret;\n   }\n\n   else\n   {\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\n      return Z_STREAM_ERROR;\n   }\n}\n#endif /* READ_iCCP */\n\n/* Read and check the IDHR chunk */\n\nvoid /* PRIVATE */\npng_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[13];\n   png_uint_32 width, height;\n   int bit_depth, color_type, compression_type, filter_type;\n   int interlace_type;\n\n   png_debug(1, \"in png_handle_IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) != 0)\n      png_chunk_error(png_ptr, \"out of place\");\n\n   /* Check the length */\n   if (length != 13)\n      png_chunk_error(png_ptr, \"invalid\");\n\n   png_ptr->mode |= PNG_HAVE_IHDR;\n\n   png_crc_read(png_ptr, buf, 13);\n   png_crc_finish(png_ptr, 0);\n\n   width = png_get_uint_31(png_ptr, buf);\n   height = png_get_uint_31(png_ptr, buf + 4);\n   bit_depth = buf[8];\n   color_type = buf[9];\n   compression_type = buf[10];\n   filter_type = buf[11];\n   interlace_type = buf[12];\n\n   /* Set internal variables */\n   png_ptr->width = width;\n   png_ptr->height = height;\n   png_ptr->bit_depth = (png_byte)bit_depth;\n   png_ptr->interlaced = (png_byte)interlace_type;\n   png_ptr->color_type = (png_byte)color_type;\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   png_ptr->filter_type = (png_byte)filter_type;\n#endif\n   png_ptr->compression_type = (png_byte)compression_type;\n\n   /* Find number of channels */\n   switch (png_ptr->color_type)\n   {\n      default: /* invalid, png_set_IHDR calls png_error */\n      case PNG_COLOR_TYPE_GRAY:\n      case PNG_COLOR_TYPE_PALETTE:\n         png_ptr->channels = 1;\n         break;\n\n      case PNG_COLOR_TYPE_RGB:\n         png_ptr->channels = 3;\n         break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         png_ptr->channels = 2;\n         break;\n\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         png_ptr->channels = 4;\n         break;\n   }\n\n   /* Set up other useful info */\n   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth * png_ptr->channels);\n   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);\n   png_debug1(3, \"bit_depth = %d\", png_ptr->bit_depth);\n   png_debug1(3, \"channels = %d\", png_ptr->channels);\n   png_debug1(3, \"rowbytes = %lu\", (unsigned long)png_ptr->rowbytes);\n   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,\n       color_type, interlace_type, compression_type, filter_type);\n}\n\n/* Read and check the palette */\nvoid /* PRIVATE */\npng_handle_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_color palette[PNG_MAX_PALETTE_LENGTH];\n   int max_palette_length, num, i;\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\n   png_colorp pal_ptr;\n#endif\n\n   png_debug(1, \"in png_handle_PLTE\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   /* Moved to before the 'after IDAT' check below because otherwise duplicate\n    * PLTE chunks are potentially ignored (the spec says there shall not be more\n    * than one PLTE, the error is not treated as benign, so this check trumps\n    * the requirement that PLTE appears before IDAT.)\n    */\n   else if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)\n      png_chunk_error(png_ptr, \"duplicate\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      /* This is benign because the non-benign error happened before, when an\n       * IDAT was encountered in a color-mapped image with no PLTE.\n       */\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   png_ptr->mode |= PNG_HAVE_PLTE;\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"ignored in grayscale PNG\");\n      return;\n   }\n\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n#endif\n\n   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)\n   {\n      png_crc_finish(png_ptr, length);\n\n      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n         png_chunk_benign_error(png_ptr, \"invalid\");\n\n      else\n         png_chunk_error(png_ptr, \"invalid\");\n\n      return;\n   }\n\n   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */\n   num = (int)length / 3;\n\n   /* If the palette has 256 or fewer entries but is too large for the bit\n    * depth, we don't issue an error, to preserve the behavior of previous\n    * libpng versions. We silently truncate the unused extra palette entries\n    * here.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      max_palette_length = (1 << png_ptr->bit_depth);\n   else\n      max_palette_length = PNG_MAX_PALETTE_LENGTH;\n\n   if (num > max_palette_length)\n      num = max_palette_length;\n\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\n   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)\n   {\n      png_byte buf[3];\n\n      png_crc_read(png_ptr, buf, 3);\n      pal_ptr->red = buf[0];\n      pal_ptr->green = buf[1];\n      pal_ptr->blue = buf[2];\n   }\n#else\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[3];\n\n      png_crc_read(png_ptr, buf, 3);\n      /* Don't depend upon png_color being any order */\n      palette[i].red = buf[0];\n      palette[i].green = buf[1];\n      palette[i].blue = buf[2];\n   }\n#endif\n\n   /* If we actually need the PLTE chunk (ie for a paletted image), we do\n    * whatever the normal CRC configuration tells us.  However, if we\n    * have an RGB image, the PLTE can be considered ancillary, so\n    * we will act as though it is.\n    */\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n#endif\n   {\n      png_crc_finish(png_ptr, (png_uint_32) (length - (unsigned int)num * 3));\n   }\n\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n   else if (png_crc_error(png_ptr) != 0)  /* Only if we have a CRC error */\n   {\n      /* If we don't want to use the data from an ancillary chunk,\n       * we have two options: an error abort, or a warning and we\n       * ignore the data in this chunk (which should be OK, since\n       * it's considered ancillary for a RGB or RGBA image).\n       *\n       * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the\n       * chunk type to determine whether to check the ancillary or the critical\n       * flags.\n       */\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE) == 0)\n      {\n         if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) != 0)\n            return;\n\n         else\n            png_chunk_error(png_ptr, \"CRC error\");\n      }\n\n      /* Otherwise, we (optionally) emit a warning and use the chunk. */\n      else if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)\n         png_chunk_warning(png_ptr, \"CRC error\");\n   }\n#endif\n\n   /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its\n    * own copy of the palette.  This has the side effect that when png_start_row\n    * is called (this happens after any call to png_read_update_info) the\n    * info_ptr palette gets changed.  This is extremely unexpected and\n    * confusing.\n    *\n    * Fix this by not sharing the palette in this way.\n    */\n   png_set_PLTE(png_ptr, info_ptr, palette, num);\n\n   /* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before\n    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely\n    * checked the apparent validity of a tRNS chunk inserted before PLTE on a\n    * palette PNG.  1.6.0 attempts to rigorously follow the standard and\n    * therefore does a benign error if the erroneous condition is detected *and*\n    * cancels the tRNS if the benign error returns.  The alternative is to\n    * amend the standard since it would be rather hypocritical of the standards\n    * maintainers to ignore it.\n    */\n#ifdef PNG_READ_tRNS_SUPPORTED\n   if (png_ptr->num_trans > 0 ||\n       (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0))\n   {\n      /* Cancel this because otherwise it would be used if the transforms\n       * require it.  Don't cancel the 'valid' flag because this would prevent\n       * detection of duplicate chunks.\n       */\n      png_ptr->num_trans = 0;\n\n      if (info_ptr != NULL)\n         info_ptr->num_trans = 0;\n\n      png_chunk_benign_error(png_ptr, \"tRNS must be after\");\n   }\n#endif\n\n#ifdef PNG_READ_hIST_SUPPORTED\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n      png_chunk_benign_error(png_ptr, \"hIST must be after\");\n#endif\n\n#ifdef PNG_READ_bKGD_SUPPORTED\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n      png_chunk_benign_error(png_ptr, \"bKGD must be after\");\n#endif\n}\n\nvoid /* PRIVATE */\npng_handle_IEND(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_debug(1, \"in png_handle_IEND\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0 ||\n       (png_ptr->mode & PNG_HAVE_IDAT) == 0)\n      png_chunk_error(png_ptr, \"out of place\");\n\n   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);\n\n   png_crc_finish(png_ptr, length);\n\n   if (length != 0)\n      png_chunk_benign_error(png_ptr, \"invalid\");\n\n   PNG_UNUSED(info_ptr)\n}\n\n#ifdef PNG_READ_gAMA_SUPPORTED\nvoid /* PRIVATE */\npng_handle_gAMA(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_fixed_point igamma;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_gAMA\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (length != 4)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 4);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   igamma = png_get_fixed_point(NULL, buf);\n\n   png_colorspace_set_gamma(png_ptr, &png_ptr->colorspace, igamma);\n   png_colorspace_sync(png_ptr, info_ptr);\n}\n#endif\n\n#ifdef PNG_READ_sBIT_SUPPORTED\nvoid /* PRIVATE */\npng_handle_sBIT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int truelen, i;\n   png_byte sample_depth;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_sBIT\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      truelen = 3;\n      sample_depth = 8;\n   }\n\n   else\n   {\n      truelen = png_ptr->channels;\n      sample_depth = png_ptr->bit_depth;\n   }\n\n   if (length != truelen || length > 4)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   buf[0] = buf[1] = buf[2] = buf[3] = sample_depth;\n   png_crc_read(png_ptr, buf, truelen);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   for (i=0; i<truelen; ++i)\n   {\n      if (buf[i] == 0 || buf[i] > sample_depth)\n      {\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n   }\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[1];\n      png_ptr->sig_bit.blue = buf[2];\n      png_ptr->sig_bit.alpha = buf[3];\n   }\n\n   else\n   {\n      png_ptr->sig_bit.gray = buf[0];\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[0];\n      png_ptr->sig_bit.blue = buf[0];\n      png_ptr->sig_bit.alpha = buf[1];\n   }\n\n   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));\n}\n#endif\n\n#ifdef PNG_READ_cHRM_SUPPORTED\nvoid /* PRIVATE */\npng_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[32];\n   png_xy xy;\n\n   png_debug(1, \"in png_handle_cHRM\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (length != 32)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 32);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   xy.whitex = png_get_fixed_point(NULL, buf);\n   xy.whitey = png_get_fixed_point(NULL, buf + 4);\n   xy.redx   = png_get_fixed_point(NULL, buf + 8);\n   xy.redy   = png_get_fixed_point(NULL, buf + 12);\n   xy.greenx = png_get_fixed_point(NULL, buf + 16);\n   xy.greeny = png_get_fixed_point(NULL, buf + 20);\n   xy.bluex  = png_get_fixed_point(NULL, buf + 24);\n   xy.bluey  = png_get_fixed_point(NULL, buf + 28);\n\n   if (xy.whitex == PNG_FIXED_ERROR ||\n       xy.whitey == PNG_FIXED_ERROR ||\n       xy.redx   == PNG_FIXED_ERROR ||\n       xy.redy   == PNG_FIXED_ERROR ||\n       xy.greenx == PNG_FIXED_ERROR ||\n       xy.greeny == PNG_FIXED_ERROR ||\n       xy.bluex  == PNG_FIXED_ERROR ||\n       xy.bluey  == PNG_FIXED_ERROR)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid values\");\n      return;\n   }\n\n   /* If a colorspace error has already been output skip this chunk */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n      return;\n\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0)\n   {\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n      png_colorspace_sync(png_ptr, info_ptr);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   png_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n   (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,\n       1/*prefer cHRM values*/);\n   png_colorspace_sync(png_ptr, info_ptr);\n}\n#endif\n\n#ifdef PNG_READ_sRGB_SUPPORTED\nvoid /* PRIVATE */\npng_handle_sRGB(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte intent;\n\n   png_debug(1, \"in png_handle_sRGB\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   if (length != 1)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, &intent, 1);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* If a colorspace error has already been output skip this chunk */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n      return;\n\n   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n    * this.\n    */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) != 0)\n   {\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n      png_colorspace_sync(png_ptr, info_ptr);\n      png_chunk_benign_error(png_ptr, \"too many profiles\");\n      return;\n   }\n\n   (void)png_colorspace_set_sRGB(png_ptr, &png_ptr->colorspace, intent);\n   png_colorspace_sync(png_ptr, info_ptr);\n}\n#endif /* READ_sRGB */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\nvoid /* PRIVATE */\npng_handle_iCCP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle profiles that are > 64K under DOS */\n{\n   png_const_charp errmsg = NULL; /* error message output, or no error */\n   int finished = 0; /* crc checked */\n\n   png_debug(1, \"in png_handle_iCCP\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   /* Consistent with all the above colorspace handling an obviously *invalid*\n    * chunk is just ignored, so does not invalidate the color space.  An\n    * alternative is to set the 'invalid' flags at the start of this routine\n    * and only clear them in they were not set before and all the tests pass.\n    */\n\n   /* The keyword must be at least one character and there is a\n    * terminator (0) byte and the compression method byte, and the\n    * 'zlib' datastream is at least 11 bytes.\n    */\n   if (length < 14)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too short\");\n      return;\n   }\n\n   /* If a colorspace error has already been output skip this chunk */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n    * this.\n    */\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) == 0)\n   {\n      uInt read_length, keyword_length;\n      char keyword[81];\n\n      /* Find the keyword; the keyword plus separator and compression method\n       * bytes can be at most 81 characters long.\n       */\n      read_length = 81; /* maximum */\n      if (read_length > length)\n         read_length = (uInt)length;\n\n      png_crc_read(png_ptr, (png_bytep)keyword, read_length);\n      length -= read_length;\n\n      /* The minimum 'zlib' stream is assumed to be just the 2 byte header,\n       * 5 bytes minimum 'deflate' stream, and the 4 byte checksum.\n       */\n      if (length < 11)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"too short\");\n         return;\n      }\n\n      keyword_length = 0;\n      while (keyword_length < 80 && keyword_length < read_length &&\n         keyword[keyword_length] != 0)\n         ++keyword_length;\n\n      /* TODO: make the keyword checking common */\n      if (keyword_length >= 1 && keyword_length <= 79)\n      {\n         /* We only understand '0' compression - deflate - so if we get a\n          * different value we can't safely decode the chunk.\n          */\n         if (keyword_length+1 < read_length &&\n            keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)\n         {\n            read_length -= keyword_length+2;\n\n            if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)\n            {\n               Byte profile_header[132]={0};\n               Byte local_buffer[PNG_INFLATE_BUF_SIZE];\n               png_alloc_size_t size = (sizeof profile_header);\n\n               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);\n               png_ptr->zstream.avail_in = read_length;\n               (void)png_inflate_read(png_ptr, local_buffer,\n                   (sizeof local_buffer), &length, profile_header, &size,\n                   0/*finish: don't, because the output is too small*/);\n\n               if (size == 0)\n               {\n                  /* We have the ICC profile header; do the basic header checks.\n                   */\n                  const png_uint_32 profile_length =\n                     png_get_uint_32(profile_header);\n\n                  if (png_icc_check_length(png_ptr, &png_ptr->colorspace,\n                      keyword, profile_length) != 0)\n                  {\n                     /* The length is apparently ok, so we can check the 132\n                      * byte header.\n                      */\n                     if (png_icc_check_header(png_ptr, &png_ptr->colorspace,\n                         keyword, profile_length, profile_header,\n                         png_ptr->color_type) != 0)\n                     {\n                        /* Now read the tag table; a variable size buffer is\n                         * needed at this point, allocate one for the whole\n                         * profile.  The header check has already validated\n                         * that none of this stuff will overflow.\n                         */\n                        const png_uint_32 tag_count = png_get_uint_32(\n                            profile_header+128);\n                        png_bytep profile = png_read_buffer(png_ptr,\n                            profile_length, 2/*silent*/);\n\n                        if (profile != NULL)\n                        {\n                           memcpy(profile, profile_header,\n                               (sizeof profile_header));\n\n                           size = 12 * tag_count;\n\n                           (void)png_inflate_read(png_ptr, local_buffer,\n                               (sizeof local_buffer), &length,\n                               profile + (sizeof profile_header), &size, 0);\n\n                           /* Still expect a buffer error because we expect\n                            * there to be some tag data!\n                            */\n                           if (size == 0)\n                           {\n                              if (png_icc_check_tag_table(png_ptr,\n                                  &png_ptr->colorspace, keyword, profile_length,\n                                  profile) != 0)\n                              {\n                                 /* The profile has been validated for basic\n                                  * security issues, so read the whole thing in.\n                                  */\n                                 size = profile_length - (sizeof profile_header)\n                                     - 12 * tag_count;\n\n                                 (void)png_inflate_read(png_ptr, local_buffer,\n                                     (sizeof local_buffer), &length,\n                                     profile + (sizeof profile_header) +\n                                     12 * tag_count, &size, 1/*finish*/);\n\n                                 if (length > 0 && !(png_ptr->flags &\n                                     PNG_FLAG_BENIGN_ERRORS_WARN))\n                                    errmsg = \"extra compressed data\";\n\n                                 /* But otherwise allow extra data: */\n                                 else if (size == 0)\n                                 {\n                                    if (length > 0)\n                                    {\n                                       /* This can be handled completely, so\n                                        * keep going.\n                                        */\n                                       png_chunk_warning(png_ptr,\n                                           \"extra compressed data\");\n                                    }\n\n                                    png_crc_finish(png_ptr, length);\n                                    finished = 1;\n\n# if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0\n                                    /* Check for a match against sRGB */\n                                    png_icc_set_sRGB(png_ptr,\n                                        &png_ptr->colorspace, profile,\n                                        png_ptr->zstream.adler);\n# endif\n\n                                    /* Steal the profile for info_ptr. */\n                                    if (info_ptr != NULL)\n                                    {\n                                       png_free_data(png_ptr, info_ptr,\n                                           PNG_FREE_ICCP, 0);\n\n                                       info_ptr->iccp_name = png_voidcast(char*,\n                                           png_malloc_base(png_ptr,\n                                           keyword_length+1));\n                                       if (info_ptr->iccp_name != NULL)\n                                       {\n                                          memcpy(info_ptr->iccp_name, keyword,\n                                              keyword_length+1);\n                                          info_ptr->iccp_proflen =\n                                              profile_length;\n                                          info_ptr->iccp_profile = profile;\n                                          png_ptr->read_buffer = NULL; /*steal*/\n                                          info_ptr->free_me |= PNG_FREE_ICCP;\n                                          info_ptr->valid |= PNG_INFO_iCCP;\n                                       }\n\n                                       else\n                                       {\n                                          png_ptr->colorspace.flags |=\n                                             PNG_COLORSPACE_INVALID;\n                                          errmsg = \"out of memory\";\n                                       }\n                                    }\n\n                                    /* else the profile remains in the read\n                                     * buffer which gets reused for subsequent\n                                     * chunks.\n                                     */\n\n                                    if (info_ptr != NULL)\n                                       png_colorspace_sync(png_ptr, info_ptr);\n\n                                    if (errmsg == NULL)\n                                    {\n                                       png_ptr->zowner = 0;\n                                       return;\n                                    }\n                                 }\n                                 if (errmsg == NULL)\n                                    errmsg = png_ptr->zstream.msg;\n                              }\n                              /* else png_icc_check_tag_table output an error */\n                           }\n                           else /* profile truncated */\n                              errmsg = png_ptr->zstream.msg;\n                        }\n\n                        else\n                           errmsg = \"out of memory\";\n                     }\n\n                     /* else png_icc_check_header output an error */\n                  }\n\n                  /* else png_icc_check_length output an error */\n               }\n\n               else /* profile truncated */\n                  errmsg = png_ptr->zstream.msg;\n\n               /* Release the stream */\n               png_ptr->zowner = 0;\n            }\n\n            else /* png_inflate_claim failed */\n               errmsg = png_ptr->zstream.msg;\n         }\n\n         else\n            errmsg = \"bad compression method\"; /* or missing */\n      }\n\n      else\n         errmsg = \"bad keyword\";\n   }\n\n   else\n      errmsg = \"too many profiles\";\n\n   /* Failure: the reason is in 'errmsg' */\n   if (finished == 0)\n      png_crc_finish(png_ptr, length);\n\n   png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n   png_colorspace_sync(png_ptr, info_ptr);\n   if (errmsg != NULL) /* else already output */\n      png_chunk_benign_error(png_ptr, errmsg);\n}\n#endif /* READ_iCCP */\n\n#ifdef PNG_READ_sPLT_SUPPORTED\nvoid /* PRIVATE */\npng_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle chunks that are > 64K under DOS */\n{\n   png_bytep entry_start, buffer;\n   png_sPLT_t new_palette;\n   png_sPLT_entryp pp;\n   png_uint_32 data_length;\n   int entry_size, i;\n   png_uint_32 skip = 0;\n   png_uint_32 dl;\n   size_t max_dl;\n\n   png_debug(1, \"in png_handle_sPLT\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_warning(png_ptr, \"No space in chunk cache for sPLT\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > 65535U)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n      return;\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n\n   /* WARNING: this may break if size_t is less than 32 bits; it is assumed\n    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a\n    * potential breakage point if the types in pngconf.h aren't exactly right.\n    */\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return;\n\n   buffer[length] = 0;\n\n   for (entry_start = buffer; *entry_start; entry_start++)\n      /* Empty loop to find end of name */ ;\n\n   ++entry_start;\n\n   /* A sample depth should follow the separator, and we should be on it  */\n   if (length < 2U || entry_start > buffer + (length - 2U))\n   {\n      png_warning(png_ptr, \"malformed sPLT chunk\");\n      return;\n   }\n\n   new_palette.depth = *entry_start++;\n   entry_size = (new_palette.depth == 8 ? 6 : 10);\n   /* This must fit in a png_uint_32 because it is derived from the original\n    * chunk data length.\n    */\n   data_length = length - (png_uint_32)(entry_start - buffer);\n\n   /* Integrity-check the data length */\n   if ((data_length % (unsigned int)entry_size) != 0)\n   {\n      png_warning(png_ptr, \"sPLT chunk has bad length\");\n      return;\n   }\n\n   dl = (png_uint_32)(data_length / (unsigned int)entry_size);\n   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));\n\n   if (dl > max_dl)\n   {\n      png_warning(png_ptr, \"sPLT chunk too long\");\n      return;\n   }\n\n   new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);\n\n   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,\n       (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));\n\n   if (new_palette.entries == NULL)\n   {\n      png_warning(png_ptr, \"sPLT chunk requires too much memory\");\n      return;\n   }\n\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n      pp = new_palette.entries + i;\n\n      if (new_palette.depth == 8)\n      {\n         pp->red = *entry_start++;\n         pp->green = *entry_start++;\n         pp->blue = *entry_start++;\n         pp->alpha = *entry_start++;\n      }\n\n      else\n      {\n         pp->red   = png_get_uint_16(entry_start); entry_start += 2;\n         pp->green = png_get_uint_16(entry_start); entry_start += 2;\n         pp->blue  = png_get_uint_16(entry_start); entry_start += 2;\n         pp->alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n\n      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n#else\n   pp = new_palette.entries;\n\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n\n      if (new_palette.depth == 8)\n      {\n         pp[i].red   = *entry_start++;\n         pp[i].green = *entry_start++;\n         pp[i].blue  = *entry_start++;\n         pp[i].alpha = *entry_start++;\n      }\n\n      else\n      {\n         pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;\n         pp[i].green = png_get_uint_16(entry_start); entry_start += 2;\n         pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;\n         pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n\n      pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n#endif\n\n   /* Discard all chunk data except the name and stash that */\n   new_palette.name = (png_charp)buffer;\n\n   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);\n\n   png_free(png_ptr, new_palette.entries);\n}\n#endif /* READ_sPLT */\n\n#ifdef PNG_READ_tRNS_SUPPORTED\nvoid /* PRIVATE */\npng_handle_tRNS(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_tRNS\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_byte buf[2];\n\n      if (length != 2)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.gray = png_get_uint_16(buf);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_byte buf[6];\n\n      if (length != 6)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, length);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.red = png_get_uint_16(buf);\n      png_ptr->trans_color.green = png_get_uint_16(buf + 2);\n      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)\n      {\n         /* TODO: is this actually an error in the ISO spec? */\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"out of place\");\n         return;\n      }\n\n      if (length > (unsigned int) png_ptr->num_palette ||\n         length > (unsigned int) PNG_MAX_PALETTE_LENGTH ||\n         length == 0)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return;\n      }\n\n      png_crc_read(png_ptr, readbuf, length);\n      png_ptr->num_trans = (png_uint_16)length;\n   }\n\n   else\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid with alpha channel\");\n      return;\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n   {\n      png_ptr->num_trans = 0;\n      return;\n   }\n\n   /* TODO: this is a horrible side effect in the palette case because the\n    * png_struct ends up with a pointer to the tRNS buffer owned by the\n    * png_info.  Fix this.\n    */\n   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,\n       &(png_ptr->trans_color));\n}\n#endif\n\n#ifdef PNG_READ_bKGD_SUPPORTED\nvoid /* PRIVATE */\npng_handle_bKGD(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int truelen;\n   png_byte buf[6];\n   png_color_16 background;\n\n   png_debug(1, \"in png_handle_bKGD\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n       (png_ptr->mode & PNG_HAVE_PLTE) == 0))\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      truelen = 1;\n\n   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n      truelen = 6;\n\n   else\n      truelen = 2;\n\n   if (length != truelen)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, truelen);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* We convert the index value into RGB components so that we can allow\n    * arbitrary RGB values for background when we have transparency, and\n    * so it is easy to determine the RGB values of the background color\n    * from the info_ptr struct.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      background.index = buf[0];\n\n      if (info_ptr != NULL && info_ptr->num_palette != 0)\n      {\n         if (buf[0] >= info_ptr->num_palette)\n         {\n            png_chunk_benign_error(png_ptr, \"invalid index\");\n            return;\n         }\n\n         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;\n         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;\n         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;\n      }\n\n      else\n         background.red = background.green = background.blue = 0;\n\n      background.gray = 0;\n   }\n\n   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0) /* GRAY */\n   {\n      if (png_ptr->bit_depth <= 8)\n      {\n         if (buf[0] != 0 || buf[1] >= (unsigned int)(1 << png_ptr->bit_depth))\n         {\n            png_chunk_benign_error(png_ptr, \"invalid gray level\");\n            return;\n         }\n      }\n\n      background.index = 0;\n      background.red =\n      background.green =\n      background.blue =\n      background.gray = png_get_uint_16(buf);\n   }\n\n   else\n   {\n      if (png_ptr->bit_depth <= 8)\n      {\n         if (buf[0] != 0 || buf[2] != 0 || buf[4] != 0)\n         {\n            png_chunk_benign_error(png_ptr, \"invalid color\");\n            return;\n         }\n      }\n\n      background.index = 0;\n      background.red = png_get_uint_16(buf);\n      background.green = png_get_uint_16(buf + 2);\n      background.blue = png_get_uint_16(buf + 4);\n      background.gray = 0;\n   }\n\n   png_set_bKGD(png_ptr, info_ptr, &background);\n}\n#endif\n\n#ifdef PNG_READ_eXIf_SUPPORTED\nvoid /* PRIVATE */\npng_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int i;\n\n   png_debug(1, \"in png_handle_eXIf\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if (length < 2)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too short\");\n      return;\n   }\n\n   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   info_ptr->free_me |= PNG_FREE_EXIF;\n\n   info_ptr->eXIf_buf = png_voidcast(png_bytep,\n             png_malloc_warn(png_ptr, length));\n\n   if (info_ptr->eXIf_buf == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   for (i = 0; i < length; i++)\n   {\n      png_byte buf[1];\n      png_crc_read(png_ptr, buf, 1);\n      info_ptr->eXIf_buf[i] = buf[0];\n      if (i == 1 && buf[0] != 'M' && buf[0] != 'I'\n                 && info_ptr->eXIf_buf[0] != buf[0])\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"incorrect byte-order specifier\");\n         png_free(png_ptr, info_ptr->eXIf_buf);\n         info_ptr->eXIf_buf = NULL;\n         return;\n      }\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);\n\n   png_free(png_ptr, info_ptr->eXIf_buf);\n   info_ptr->eXIf_buf = NULL;\n}\n#endif\n\n#ifdef PNG_READ_hIST_SUPPORTED\nvoid /* PRIVATE */\npng_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int num, i;\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_hIST\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n       (png_ptr->mode & PNG_HAVE_PLTE) == 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   num = length / 2 ;\n\n   if (num != (unsigned int) png_ptr->num_palette ||\n       num > (unsigned int) PNG_MAX_PALETTE_LENGTH)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n\n      png_crc_read(png_ptr, buf, 2);\n      readbuf[i] = png_get_uint_16(buf);\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   png_set_hIST(png_ptr, info_ptr, readbuf);\n}\n#endif\n\n#ifdef PNG_READ_pHYs_SUPPORTED\nvoid /* PRIVATE */\npng_handle_pHYs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[9];\n   png_uint_32 res_x, res_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_pHYs\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (length != 9)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 9);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   res_x = png_get_uint_32(buf);\n   res_y = png_get_uint_32(buf + 4);\n   unit_type = buf[8];\n   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n}\n#endif\n\n#ifdef PNG_READ_oFFs_SUPPORTED\nvoid /* PRIVATE */\npng_handle_oFFs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[9];\n   png_int_32 offset_x, offset_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_oFFs\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if (length != 9)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 9);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   offset_x = png_get_int_32(buf);\n   offset_y = png_get_int_32(buf + 4);\n   unit_type = buf[8];\n   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);\n}\n#endif\n\n#ifdef PNG_READ_pCAL_SUPPORTED\n/* Read the pCAL chunk (described in the PNG Extensions document) */\nvoid /* PRIVATE */\npng_handle_pCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_int_32 X0, X1;\n   png_byte type, nparams;\n   png_bytep buffer, buf, units, endptr;\n   png_charpp params;\n   int i;\n\n   png_debug(1, \"in png_handle_pCAL\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading pCAL chunk data (%u bytes)\",\n       length + 1);\n\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   buffer[length] = 0; /* Null terminate the last string */\n\n   png_debug(3, \"Finding end of pCAL purpose string\");\n   for (buf = buffer; *buf; buf++)\n      /* Empty loop */ ;\n\n   endptr = buffer + length;\n\n   /* We need to have at least 12 bytes after the purpose string\n    * in order to get the parameter information.\n    */\n   if (endptr - buf <= 12)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_debug(3, \"Reading pCAL X0, X1, type, nparams, and units\");\n   X0 = png_get_int_32((png_bytep)buf+1);\n   X1 = png_get_int_32((png_bytep)buf+5);\n   type = buf[9];\n   nparams = buf[10];\n   units = buf + 11;\n\n   png_debug(3, \"Checking pCAL equation type and number of parameters\");\n   /* Check that we have the right number of parameters for known\n    * equation types.\n    */\n   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||\n       (type == PNG_EQUATION_BASE_E && nparams != 3) ||\n       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||\n       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))\n   {\n      png_chunk_benign_error(png_ptr, \"invalid parameter count\");\n      return;\n   }\n\n   else if (type >= PNG_EQUATION_LAST)\n   {\n      png_chunk_benign_error(png_ptr, \"unrecognized equation type\");\n   }\n\n   for (buf = units; *buf; buf++)\n      /* Empty loop to move past the units string. */ ;\n\n   png_debug(3, \"Allocating pCAL parameters array\");\n\n   params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,\n       nparams * (sizeof (png_charp))));\n\n   if (params == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   /* Get pointers to the start of each parameter string. */\n   for (i = 0; i < nparams; i++)\n   {\n      buf++; /* Skip the null string terminator from previous parameter. */\n\n      png_debug1(3, \"Reading pCAL parameter %d\", i);\n\n      for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)\n         /* Empty loop to move past each parameter string */ ;\n\n      /* Make sure we haven't run out of data yet */\n      if (buf > endptr)\n      {\n         png_free(png_ptr, params);\n         png_chunk_benign_error(png_ptr, \"invalid data\");\n         return;\n      }\n   }\n\n   png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,\n       (png_charp)units, params);\n\n   png_free(png_ptr, params);\n}\n#endif\n\n#ifdef PNG_READ_sCAL_SUPPORTED\n/* Read the sCAL chunk */\nvoid /* PRIVATE */\npng_handle_sCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_bytep buffer;\n   size_t i;\n   int state;\n\n   png_debug(1, \"in png_handle_sCAL\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   /* Need unit type, width, \\0, height: minimum 4 bytes */\n   else if (length < 4)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading sCAL chunk data (%u bytes)\",\n       length + 1);\n\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\n\n   if (buffer == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n   buffer[length] = 0; /* Null terminate the last string */\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* Validate the unit. */\n   if (buffer[0] != 1 && buffer[0] != 2)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid unit\");\n      return;\n   }\n\n   /* Validate the ASCII numbers, need two ASCII numbers separated by\n    * a '\\0' and they need to fit exactly in the chunk data.\n    */\n   i = 1;\n   state = 0;\n\n   if (png_check_fp_number((png_const_charp)buffer, length, &state, &i) == 0 ||\n       i >= length || buffer[i++] != 0)\n      png_chunk_benign_error(png_ptr, \"bad width format\");\n\n   else if (PNG_FP_IS_POSITIVE(state) == 0)\n      png_chunk_benign_error(png_ptr, \"non-positive width\");\n\n   else\n   {\n      size_t heighti = i;\n\n      state = 0;\n      if (png_check_fp_number((png_const_charp)buffer, length,\n          &state, &i) == 0 || i != length)\n         png_chunk_benign_error(png_ptr, \"bad height format\");\n\n      else if (PNG_FP_IS_POSITIVE(state) == 0)\n         png_chunk_benign_error(png_ptr, \"non-positive height\");\n\n      else\n         /* This is the (only) success case. */\n         png_set_sCAL_s(png_ptr, info_ptr, buffer[0],\n             (png_charp)buffer+1, (png_charp)buffer+heighti);\n   }\n}\n#endif\n\n#ifdef PNG_READ_tIME_SUPPORTED\nvoid /* PRIVATE */\npng_handle_tIME(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[7];\n   png_time mod_time;\n\n   png_debug(1, \"in png_handle_tIME\");\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   if (length != 7)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 7);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   mod_time.second = buf[6];\n   mod_time.minute = buf[5];\n   mod_time.hour = buf[4];\n   mod_time.day = buf[3];\n   mod_time.month = buf[2];\n   mod_time.year = png_get_uint_16(buf);\n\n   png_set_tIME(png_ptr, info_ptr, &mod_time);\n}\n#endif\n\n#ifdef PNG_READ_tEXt_SUPPORTED\n/* Note: this does not properly handle chunks that are > 64K under DOS */\nvoid /* PRIVATE */\npng_handle_tEXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_text  text_info;\n   png_bytep buffer;\n   png_charp key;\n   png_charp text;\n   png_uint_32 skip = 0;\n\n   png_debug(1, \"in png_handle_tEXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > 65535U)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n      return;\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);\n\n   if (buffer == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return;\n\n   key = (png_charp)buffer;\n   key[length] = 0;\n\n   for (text = key; *text; text++)\n      /* Empty loop to find end of key */ ;\n\n   if (text != key + length)\n      text++;\n\n   text_info.compression = PNG_TEXT_COMPRESSION_NONE;\n   text_info.key = key;\n   text_info.lang = NULL;\n   text_info.lang_key = NULL;\n   text_info.itxt_length = 0;\n   text_info.text = text;\n   text_info.text_length = strlen(text);\n\n   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)\n      png_warning(png_ptr, \"Insufficient memory to process text chunk\");\n}\n#endif\n\n#ifdef PNG_READ_zTXt_SUPPORTED\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\nvoid /* PRIVATE */\npng_handle_zTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_const_charp errmsg = NULL;\n   png_bytep       buffer;\n   png_uint_32     keyword_length;\n\n   png_debug(1, \"in png_handle_zTXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   /* Note, \"length\" is sufficient here; we won't be adding\n    * a null terminator later.\n    */\n   buffer = png_read_buffer(png_ptr, length, 2/*silent*/);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* TODO: also check that the keyword contents match the spec! */\n   for (keyword_length = 0;\n      keyword_length < length && buffer[keyword_length] != 0;\n      ++keyword_length)\n      /* Empty loop to find end of name */ ;\n\n   if (keyword_length > 79 || keyword_length < 1)\n      errmsg = \"bad keyword\";\n\n   /* zTXt must have some LZ data after the keyword, although it may expand to\n    * zero bytes; we need a '\\0' at the end of the keyword, the compression type\n    * then the LZ data:\n    */\n   else if (keyword_length + 3 > length)\n      errmsg = \"truncated\";\n\n   else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)\n      errmsg = \"unknown compression type\";\n\n   else\n   {\n      png_alloc_size_t uncompressed_length = PNG_SIZE_MAX;\n\n      /* TODO: at present png_decompress_chunk imposes a single application\n       * level memory limit, this should be split to different values for iCCP\n       * and text chunks.\n       */\n      if (png_decompress_chunk(png_ptr, length, keyword_length+2,\n          &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\n      {\n         png_text text;\n\n         if (png_ptr->read_buffer == NULL)\n           errmsg=\"Read failure in png_handle_zTXt\";\n         else\n         {\n            /* It worked; png_ptr->read_buffer now looks like a tEXt chunk\n             * except for the extra compression type byte and the fact that\n             * it isn't necessarily '\\0' terminated.\n             */\n            buffer = png_ptr->read_buffer;\n            buffer[uncompressed_length+(keyword_length+2)] = 0;\n\n            text.compression = PNG_TEXT_COMPRESSION_zTXt;\n            text.key = (png_charp)buffer;\n            text.text = (png_charp)(buffer + keyword_length+2);\n            text.text_length = uncompressed_length;\n            text.itxt_length = 0;\n            text.lang = NULL;\n            text.lang_key = NULL;\n\n            if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n               errmsg = \"insufficient memory\";\n         }\n      }\n\n      else\n         errmsg = png_ptr->zstream.msg;\n   }\n\n   if (errmsg != NULL)\n      png_chunk_benign_error(png_ptr, errmsg);\n}\n#endif\n\n#ifdef PNG_READ_iTXt_SUPPORTED\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\nvoid /* PRIVATE */\npng_handle_iTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_const_charp errmsg = NULL;\n   png_bytep buffer;\n   png_uint_32 prefix_length;\n\n   png_debug(1, \"in png_handle_iTXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n\n   /* First the keyword. */\n   for (prefix_length=0;\n      prefix_length < length && buffer[prefix_length] != 0;\n      ++prefix_length)\n      /* Empty loop */ ;\n\n   /* Perform a basic check on the keyword length here. */\n   if (prefix_length > 79 || prefix_length < 1)\n      errmsg = \"bad keyword\";\n\n   /* Expect keyword, compression flag, compression type, language, translated\n    * keyword (both may be empty but are 0 terminated) then the text, which may\n    * be empty.\n    */\n   else if (prefix_length + 5 > length)\n      errmsg = \"truncated\";\n\n   else if (buffer[prefix_length+1] == 0 ||\n      (buffer[prefix_length+1] == 1 &&\n      buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))\n   {\n      int compressed = buffer[prefix_length+1] != 0;\n      png_uint_32 language_offset, translated_keyword_offset;\n      png_alloc_size_t uncompressed_length = 0;\n\n      /* Now the language tag */\n      prefix_length += 3;\n      language_offset = prefix_length;\n\n      for (; prefix_length < length && buffer[prefix_length] != 0;\n         ++prefix_length)\n         /* Empty loop */ ;\n\n      /* WARNING: the length may be invalid here, this is checked below. */\n      translated_keyword_offset = ++prefix_length;\n\n      for (; prefix_length < length && buffer[prefix_length] != 0;\n         ++prefix_length)\n         /* Empty loop */ ;\n\n      /* prefix_length should now be at the trailing '\\0' of the translated\n       * keyword, but it may already be over the end.  None of this arithmetic\n       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit\n       * systems the available allocation may overflow.\n       */\n      ++prefix_length;\n\n      if (compressed == 0 && prefix_length <= length)\n         uncompressed_length = length - prefix_length;\n\n      else if (compressed != 0 && prefix_length < length)\n      {\n         uncompressed_length = PNG_SIZE_MAX;\n\n         /* TODO: at present png_decompress_chunk imposes a single application\n          * level memory limit, this should be split to different values for\n          * iCCP and text chunks.\n          */\n         if (png_decompress_chunk(png_ptr, length, prefix_length,\n             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\n            buffer = png_ptr->read_buffer;\n\n         else\n            errmsg = png_ptr->zstream.msg;\n      }\n\n      else\n         errmsg = \"truncated\";\n\n      if (errmsg == NULL)\n      {\n         png_text text;\n\n         buffer[uncompressed_length+prefix_length] = 0;\n\n         if (compressed == 0)\n            text.compression = PNG_ITXT_COMPRESSION_NONE;\n\n         else\n            text.compression = PNG_ITXT_COMPRESSION_zTXt;\n\n         text.key = (png_charp)buffer;\n         text.lang = (png_charp)buffer + language_offset;\n         text.lang_key = (png_charp)buffer + translated_keyword_offset;\n         text.text = (png_charp)buffer + prefix_length;\n         text.text_length = 0;\n         text.itxt_length = uncompressed_length;\n\n         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n            errmsg = \"insufficient memory\";\n      }\n   }\n\n   else\n      errmsg = \"bad compression info\";\n\n   if (errmsg != NULL)\n      png_chunk_benign_error(png_ptr, errmsg);\n}\n#endif\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */\nstatic int\npng_cache_unknown_chunk(png_structrp png_ptr, png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_SIZE_MAX;\n\n   if (png_ptr->unknown_chunk.data != NULL)\n   {\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n      png_ptr->unknown_chunk.data = NULL;\n   }\n\n#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n\n#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n#  endif\n\n   if (length <= limit)\n   {\n      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);\n      /* The following is safe because of the PNG_SIZE_MAX init above */\n      png_ptr->unknown_chunk.size = (size_t)length/*SAFE*/;\n      /* 'mode' is a flag array, only the bottom four bits matter here */\n      png_ptr->unknown_chunk.location = (png_byte)png_ptr->mode/*SAFE*/;\n\n      if (length == 0)\n         png_ptr->unknown_chunk.data = NULL;\n\n      else\n      {\n         /* Do a 'warn' here - it is handled below. */\n         png_ptr->unknown_chunk.data = png_voidcast(png_bytep,\n             png_malloc_warn(png_ptr, length));\n      }\n   }\n\n   if (png_ptr->unknown_chunk.data == NULL && length > 0)\n   {\n      /* This is benign because we clean up correctly */\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"unknown chunk exceeds memory limits\");\n      return 0;\n   }\n\n   else\n   {\n      if (length > 0)\n         png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);\n      png_crc_finish(png_ptr, 0);\n      return 1;\n   }\n}\n#endif /* READ_UNKNOWN_CHUNKS */\n\n/* Handle an unknown, or known but disabled, chunk */\nvoid /* PRIVATE */\npng_handle_unknown(png_structrp png_ptr, png_inforp info_ptr,\n    png_uint_32 length, int keep)\n{\n   int handled = 0; /* the chunk was handled */\n\n   png_debug(1, \"in png_handle_unknown\");\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing\n    * the bug which meant that setting a non-default behavior for a specific\n    * chunk would be ignored (the default was always used unless a user\n    * callback was installed).\n    *\n    * 'keep' is the value from the png_chunk_unknown_handling, the setting for\n    * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it\n    * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.\n    * This is just an optimization to avoid multiple calls to the lookup\n    * function.\n    */\n#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n#     ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\n   keep = png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name);\n#     endif\n#  endif\n\n   /* One of the following methods will read the chunk or skip it (at least one\n    * of these is always defined because this is the only way to switch on\n    * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\n    */\n#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n   /* The user callback takes precedence over the chunk keep value, but the\n    * keep value is still required to validate a save of a critical chunk.\n    */\n   if (png_ptr->read_user_chunk_fn != NULL)\n   {\n      if (png_cache_unknown_chunk(png_ptr, length) != 0)\n      {\n         /* Callback to user unknown chunk handler */\n         int ret = (*(png_ptr->read_user_chunk_fn))(png_ptr,\n             &png_ptr->unknown_chunk);\n\n         /* ret is:\n          * negative: An error occurred; png_chunk_error will be called.\n          *     zero: The chunk was not handled, the chunk will be discarded\n          *           unless png_set_keep_unknown_chunks has been used to set\n          *           a 'keep' behavior for this particular chunk, in which\n          *           case that will be used.  A critical chunk will cause an\n          *           error at this point unless it is to be saved.\n          * positive: The chunk was handled, libpng will ignore/discard it.\n          */\n         if (ret < 0)\n            png_chunk_error(png_ptr, \"error in user chunk\");\n\n         else if (ret == 0)\n         {\n            /* If the keep value is 'default' or 'never' override it, but\n             * still error out on critical chunks unless the keep value is\n             * 'always'  While this is weird it is the behavior in 1.4.12.\n             * A possible improvement would be to obey the value set for the\n             * chunk, but this would be an API change that would probably\n             * damage some applications.\n             *\n             * The png_app_warning below catches the case that matters, where\n             * the application has not set specific save or ignore for this\n             * chunk or global save or ignore.\n             */\n            if (keep < PNG_HANDLE_CHUNK_IF_SAFE)\n            {\n#              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\n               if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)\n               {\n                  png_chunk_warning(png_ptr, \"Saving unknown chunk:\");\n                  png_app_warning(png_ptr,\n                      \"forcing save of an unhandled chunk;\"\n                      \" please call png_set_keep_unknown_chunks\");\n                      /* with keep = PNG_HANDLE_CHUNK_IF_SAFE */\n               }\n#              endif\n               keep = PNG_HANDLE_CHUNK_IF_SAFE;\n            }\n         }\n\n         else /* chunk was handled */\n         {\n            handled = 1;\n            /* Critical chunks can be safely discarded at this point. */\n            keep = PNG_HANDLE_CHUNK_NEVER;\n         }\n      }\n\n      else\n         keep = PNG_HANDLE_CHUNK_NEVER; /* insufficient memory */\n   }\n\n   else\n   /* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */\n#  endif /* READ_USER_CHUNKS */\n\n#  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED\n   {\n      /* keep is currently just the per-chunk setting, if there was no\n       * setting change it to the global default now (not that this may\n       * still be AS_DEFAULT) then obtain the cache of the chunk if required,\n       * if not simply skip the chunk.\n       */\n      if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n         keep = png_ptr->unknown_default;\n\n      if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\n         (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\n          PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\n      {\n         if (png_cache_unknown_chunk(png_ptr, length) == 0)\n            keep = PNG_HANDLE_CHUNK_NEVER;\n      }\n\n      else\n         png_crc_finish(png_ptr, length);\n   }\n#  else\n#     ifndef PNG_READ_USER_CHUNKS_SUPPORTED\n#        error no method to support READ_UNKNOWN_CHUNKS\n#     endif\n\n   {\n      /* If here there is no read callback pointer set and no support is\n       * compiled in to just save the unknown chunks, so simply skip this\n       * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then\n       * the app has erroneously asked for unknown chunk saving when there\n       * is no support.\n       */\n      if (keep > PNG_HANDLE_CHUNK_NEVER)\n         png_app_error(png_ptr, \"no unknown chunk support available\");\n\n      png_crc_finish(png_ptr, length);\n   }\n#  endif\n\n#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n   /* Now store the chunk in the chunk list if appropriate, and if the limits\n    * permit it.\n    */\n   if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\n      (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\n       PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\n   {\n#     ifdef PNG_USER_LIMITS_SUPPORTED\n      switch (png_ptr->user_chunk_cache_max)\n      {\n         case 2:\n            png_ptr->user_chunk_cache_max = 1;\n            png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n            /* FALLTHROUGH */\n         case 1:\n            /* NOTE: prior to 1.6.0 this case resulted in an unknown critical\n             * chunk being skipped, now there will be a hard error below.\n             */\n            break;\n\n         default: /* not at limit */\n            --(png_ptr->user_chunk_cache_max);\n            /* FALLTHROUGH */\n         case 0: /* no limit */\n#  endif /* USER_LIMITS */\n            /* Here when the limit isn't reached or when limits are compiled\n             * out; store the chunk.\n             */\n            png_set_unknown_chunks(png_ptr, info_ptr,\n                &png_ptr->unknown_chunk, 1);\n            handled = 1;\n#  ifdef PNG_USER_LIMITS_SUPPORTED\n            break;\n      }\n#  endif\n   }\n#  else /* no store support: the chunk must be handled by the user callback */\n   PNG_UNUSED(info_ptr)\n#  endif\n\n   /* Regardless of the error handling below the cached data (if any) can be\n    * freed now.  Notice that the data is not freed if there is a png_error, but\n    * it will be freed by destroy_read_struct.\n    */\n   if (png_ptr->unknown_chunk.data != NULL)\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n   png_ptr->unknown_chunk.data = NULL;\n\n#else /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */\n   /* There is no support to read an unknown chunk, so just skip it. */\n   png_crc_finish(png_ptr, length);\n   PNG_UNUSED(info_ptr)\n   PNG_UNUSED(keep)\n#endif /* !READ_UNKNOWN_CHUNKS */\n\n   /* Check for unhandled critical chunks */\n   if (handled == 0 && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\n      png_chunk_error(png_ptr, \"unhandled critical chunk\");\n}\n\n/* This function is called to verify that a chunk name is valid.\n * This function can't have the \"critical chunk check\" incorporated\n * into it, since in the future we will need to be able to call user\n * functions to handle unknown critical chunks after we check that\n * the chunk name itself is valid.\n */\n\n/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:\n *\n * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\n */\n\nvoid /* PRIVATE */\npng_check_chunk_name(png_const_structrp png_ptr, const png_uint_32 chunk_name)\n{\n   int i;\n   png_uint_32 cn=chunk_name;\n\n   png_debug(1, \"in png_check_chunk_name\");\n\n   for (i=1; i<=4; ++i)\n   {\n      int c = cn & 0xff;\n\n      if (c < 65 || c > 122 || (c > 90 && c < 97))\n         png_chunk_error(png_ptr, \"invalid chunk type\");\n\n      cn >>= 8;\n   }\n}\n\nvoid /* PRIVATE */\npng_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (size_t)png_ptr->width\n         * (size_t)png_ptr->channels\n         * (png_ptr->bit_depth > 8? 2: 1)\n         + 1\n         + (png_ptr->interlaced? 6: 0);\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit = PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */\n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}\n\n/* Combines the row recently read in with the existing pixels in the row.  This\n * routine takes care of alpha and transparency if requested.  This routine also\n * handles the two methods of progressive display of interlaced images,\n * depending on the 'display' value; if 'display' is true then the whole row\n * (dp) is filled from the start by replicating the available pixels.  If\n * 'display' is false only those pixels present in the pass are filled in.\n */\nvoid /* PRIVATE */\npng_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)\n{\n   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;\n   png_const_bytep sp = png_ptr->row_buf + 1;\n   png_alloc_size_t row_width = png_ptr->width;\n   unsigned int pass = png_ptr->pass;\n   png_bytep end_ptr = 0;\n   png_byte end_byte = 0;\n   unsigned int end_mask;\n\n   png_debug(1, \"in png_combine_row\");\n\n   /* Added in 1.5.6: it should not be possible to enter this routine until at\n    * least one row has been read from the PNG data and transformed.\n    */\n   if (pixel_depth == 0)\n      png_error(png_ptr, \"internal row logic error\");\n\n   /* Added in 1.5.4: the pixel depth should match the information returned by\n    * any call to png_read_update_info at this point.  Do not continue if we got\n    * this wrong.\n    */\n   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=\n          PNG_ROWBYTES(pixel_depth, row_width))\n      png_error(png_ptr, \"internal row size calculation error\");\n\n   /* Don't expect this to ever happen: */\n   if (row_width == 0)\n      png_error(png_ptr, \"internal row width error\");\n\n   /* Preserve the last byte in cases where only part of it will be overwritten,\n    * the multiply below may overflow, we don't care because ANSI-C guarantees\n    * we get the low bits.\n    */\n   end_mask = (pixel_depth * row_width) & 7;\n   if (end_mask != 0)\n   {\n      /* end_ptr == NULL is a flag to say do nothing */\n      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;\n      end_byte = *end_ptr;\n#     ifdef PNG_READ_PACKSWAP_SUPPORTED\n      if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n         /* little-endian byte */\n         end_mask = (unsigned int)(0xff << end_mask);\n\n      else /* big-endian byte */\n#     endif\n      end_mask = 0xff >> end_mask;\n      /* end_mask is now the bits to *keep* from the destination row */\n   }\n\n   /* For non-interlaced images this reduces to a memcpy(). A memcpy()\n    * will also happen if interlacing isn't supported or if the application\n    * does not call png_set_interlace_handling().  In the latter cases the\n    * caller just gets a sequence of the unexpanded rows from each interlace\n    * pass.\n    */\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if (png_ptr->interlaced != 0 &&\n       (png_ptr->transformations & PNG_INTERLACE) != 0 &&\n       pass < 6 && (display == 0 ||\n       /* The following copies everything for 'display' on passes 0, 2 and 4. */\n       (display == 1 && (pass & 1) != 0)))\n   {\n      /* Narrow images may have no bits in a pass; the caller should handle\n       * this, but this test is cheap:\n       */\n      if (row_width <= PNG_PASS_START_COL(pass))\n         return;\n\n      if (pixel_depth < 8)\n      {\n         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit\n          * into 32 bits, then a single loop over the bytes using the four byte\n          * values in the 32-bit mask can be used.  For the 'display' option the\n          * expanded mask may also not require any masking within a byte.  To\n          * make this work the PACKSWAP option must be taken into account - it\n          * simply requires the pixels to be reversed in each byte.\n          *\n          * The 'regular' case requires a mask for each of the first 6 passes,\n          * the 'display' case does a copy for the even passes in the range\n          * 0..6.  This has already been handled in the test above.\n          *\n          * The masks are arranged as four bytes with the first byte to use in\n          * the lowest bits (little-endian) regardless of the order (PACKSWAP or\n          * not) of the pixels in each byte.\n          *\n          * NOTE: the whole of this logic depends on the caller of this function\n          * only calling it on rows appropriate to the pass.  This function only\n          * understands the 'x' logic; the 'y' logic is handled by the caller.\n          *\n          * The following defines allow generation of compile time constant bit\n          * masks for each pixel depth and each possibility of swapped or not\n          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,\n          * is in the range 0..7; and the result is 1 if the pixel is to be\n          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'\n          * for the block method.\n          *\n          * With some compilers a compile time expression of the general form:\n          *\n          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)\n          *\n          * Produces warnings with values of 'shift' in the range 33 to 63\n          * because the right hand side of the ?: expression is evaluated by\n          * the compiler even though it isn't used.  Microsoft Visual C (various\n          * versions) and the Intel C compiler are known to do this.  To avoid\n          * this the following macros are used in 1.5.6.  This is a temporary\n          * solution to avoid destabilizing the code during the release process.\n          */\n#        if PNG_USE_COMPILE_TIME_MASKS\n#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))\n#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))\n#        else\n#           define PNG_LSR(x,s) ((x)>>(s))\n#           define PNG_LSL(x,s) ((x)<<(s))\n#        endif\n#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)\n#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)\n\n         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is\n          * little endian - the first pixel is at bit 0 - however the extra\n          * parameter 's' can be set to cause the mask position to be swapped\n          * within each byte, to match the PNG format.  This is done by XOR of\n          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.\n          */\n#        define PIXEL_MASK(p,x,d,s) \\\n            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))\n\n         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.\n          */\n#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n\n         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp\n          * cases the result needs replicating, for the 4-bpp case the above\n          * generates a full 32 bits.\n          */\n#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))\n\n#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\\\n            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\\\n            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)\n\n#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\\\n            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\\\n            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)\n\n#if PNG_USE_COMPILE_TIME_MASKS\n         /* Utility macros to construct all the masks for a depth/swap\n          * combination.  The 's' parameter says whether the format is PNG\n          * (big endian bytes) or not.  Only the three odd-numbered passes are\n          * required for the display/block algorithm.\n          */\n#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\\\n            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }\n\n#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }\n\n#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))\n\n         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and\n          * then pass:\n          */\n         static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }\n         };\n\n         /* display_mask has only three entries for the odd passes, so index by\n          * pass>>1.\n          */\n         static PNG_CONST png_uint_32 display_mask[2][3][3] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }\n         };\n\n#        define MASK(pass,depth,display,png)\\\n            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\\\n               row_mask[png][DEPTH_INDEX(depth)][pass])\n\n#else /* !PNG_USE_COMPILE_TIME_MASKS */\n         /* This is the runtime alternative: it seems unlikely that this will\n          * ever be either smaller or faster than the compile time approach.\n          */\n#        define MASK(pass,depth,display,png)\\\n            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))\n#endif /* !USE_COMPILE_TIME_MASKS */\n\n         /* Use the appropriate mask to copy the required bits.  In some cases\n          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is\n          * the number of pixels, but the code copies bytes, so it is necessary\n          * to special case the end.\n          */\n         png_uint_32 pixels_per_byte = 8 / pixel_depth;\n         png_uint_32 mask;\n\n#        ifdef PNG_READ_PACKSWAP_SUPPORTED\n         if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n            mask = MASK(pass, pixel_depth, display, 0);\n\n         else\n#        endif\n         mask = MASK(pass, pixel_depth, display, 1);\n\n         for (;;)\n         {\n            png_uint_32 m;\n\n            /* It doesn't matter in the following if png_uint_32 has more than\n             * 32 bits because the high bits always match those in m<<24; it is,\n             * however, essential to use OR here, not +, because of this.\n             */\n            m = mask;\n            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */\n            m &= 0xff;\n\n            if (m != 0) /* something to copy */\n            {\n               if (m != 0xff)\n                  *dp = (png_byte)((*dp & ~m) | (*sp & m));\n               else\n                  *dp = *sp;\n            }\n\n            /* NOTE: this may overwrite the last byte with garbage if the image\n             * is not an exact number of bytes wide; libpng has always done\n             * this.\n             */\n            if (row_width <= pixels_per_byte)\n               break; /* May need to restore part of the last byte */\n\n            row_width -= pixels_per_byte;\n            ++dp;\n            ++sp;\n         }\n      }\n\n      else /* pixel_depth >= 8 */\n      {\n         unsigned int bytes_to_copy, bytes_to_jump;\n\n         /* Validate the depth - it must be a multiple of 8 */\n         if (pixel_depth & 7)\n            png_error(png_ptr, \"invalid user transform pixel depth\");\n\n         pixel_depth >>= 3; /* now in bytes */\n         row_width *= pixel_depth;\n\n         /* Regardless of pass number the Adam 7 interlace always results in a\n          * fixed number of pixels to copy then to skip.  There may be a\n          * different number of pixels to skip at the start though.\n          */\n         {\n            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;\n\n            row_width -= offset;\n            dp += offset;\n            sp += offset;\n         }\n\n         /* Work out the bytes to copy. */\n         if (display != 0)\n         {\n            /* When doing the 'block' algorithm the pixel in the pass gets\n             * replicated to adjacent pixels.  This is why the even (0,2,4,6)\n             * passes are skipped above - the entire expanded row is copied.\n             */\n            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;\n\n            /* But don't allow this number to exceed the actual row width. */\n            if (bytes_to_copy > row_width)\n               bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n         }\n\n         else /* normal row; Adam7 only ever gives us one pixel to copy. */\n            bytes_to_copy = pixel_depth;\n\n         /* In Adam7 there is a constant offset between where the pixels go. */\n         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;\n\n         /* And simply copy these bytes.  Some optimization is possible here,\n          * depending on the value of 'bytes_to_copy'.  Special case the low\n          * byte counts, which we know to be frequent.\n          *\n          * Notice that these cases all 'return' rather than 'break' - this\n          * avoids an unnecessary test on whether to restore the last byte\n          * below.\n          */\n         switch (bytes_to_copy)\n         {\n            case 1:\n               for (;;)\n               {\n                  *dp = *sp;\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  dp += bytes_to_jump;\n                  sp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            case 2:\n               /* There is a possibility of a partial copy at the end here; this\n                * slows the code down somewhat.\n                */\n               do\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n               while (row_width > 1);\n\n               /* And there can only be one byte left at this point: */\n               *dp = *sp;\n               return;\n\n            case 3:\n               /* This can only be the RGB case, so each copy is exactly one\n                * pixel and it is not necessary to check for a partial copy.\n                */\n               for (;;)\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            default:\n#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE\n               /* Check for double byte alignment and, if possible, use a\n                * 16-bit copy.  Don't attempt this for narrow images - ones that\n                * are less than an interlace panel wide.  Don't attempt it for\n                * wide bytes_to_copy either - use the memcpy there.\n                */\n               if (bytes_to_copy < 16 /*else use memcpy*/ &&\n                   png_isaligned(dp, png_uint_16) &&\n                   png_isaligned(sp, png_uint_16) &&\n                   bytes_to_copy % (sizeof (png_uint_16)) == 0 &&\n                   bytes_to_jump % (sizeof (png_uint_16)) == 0)\n               {\n                  /* Everything is aligned for png_uint_16 copies, but try for\n                   * png_uint_32 first.\n                   */\n                  if (png_isaligned(dp, png_uint_32) &&\n                      png_isaligned(sp, png_uint_32) &&\n                      bytes_to_copy % (sizeof (png_uint_32)) == 0 &&\n                      bytes_to_jump % (sizeof (png_uint_32)) == 0)\n                  {\n                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);\n                     png_const_uint_32p sp32 = png_aligncastconst(\n                         png_const_uint_32p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                         (sizeof (png_uint_32));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp32++ = *sp32++;\n                           c -= (sizeof (png_uint_32));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp32 += skip;\n                        sp32 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* Get to here when the row_width truncates the final copy.\n                      * There will be 1-3 bytes left to copy, so don't try the\n                      * 16-bit loop below.\n                      */\n                     dp = (png_bytep)dp32;\n                     sp = (png_const_bytep)sp32;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n\n                  /* Else do it in 16-bit quantities, but only if the size is\n                   * not too large.\n                   */\n                  else\n                  {\n                     png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);\n                     png_const_uint_16p sp16 = png_aligncastconst(\n                        png_const_uint_16p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                        (sizeof (png_uint_16));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp16++ = *sp16++;\n                           c -= (sizeof (png_uint_16));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp16 += skip;\n                        sp16 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* End of row - 1 byte left, bytes_to_copy > row_width: */\n                     dp = (png_bytep)dp16;\n                     sp = (png_const_bytep)sp16;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n               }\n#endif /* ALIGN_TYPE code */\n\n               /* The true default - use a memcpy: */\n               for (;;)\n               {\n                  memcpy(dp, sp, bytes_to_copy);\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n                  if (bytes_to_copy > row_width)\n                     bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n               }\n         }\n\n         /* NOT REACHED*/\n      } /* pixel_depth >= 8 */\n\n      /* Here if pixel_depth < 8 to check 'end_ptr' below. */\n   }\n   else\n#endif /* READ_INTERLACING */\n\n   /* If here then the switch above wasn't used so just memcpy the whole row\n    * from the temporary row buffer (notice that this overwrites the end of the\n    * destination row if it is a partial byte.)\n    */\n   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));\n\n   /* Restore the overwritten bits from the last byte if necessary. */\n   if (end_ptr != NULL)\n      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));\n}\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\nvoid /* PRIVATE */\npng_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,\n    png_uint_32 transformations /* Because these may affect the byte layout */)\n{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n   /* Offset to next interlace block */\n   static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   png_debug(1, \"in png_do_read_interlace\");\n   if (row != NULL && row_info != NULL)\n   {\n      png_uint_32 final_width;\n\n      final_width = row_info->width * png_pass_inc[pass];\n\n      switch (row_info->pixel_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 3);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 3);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_byte v;\n            png_uint_32 i;\n            int j;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n                sshift = ((row_info->width + 7) & 0x07);\n                dshift = ((final_width + 7) & 0x07);\n                s_start = 7;\n                s_end = 0;\n                s_inc = -1;\n            }\n\n            else\n#endif\n            {\n                sshift = 7 - ((row_info->width + 7) & 0x07);\n                dshift = 7 - ((final_width + 7) & 0x07);\n                s_start = 0;\n                s_end = 7;\n                s_inc = 1;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               v = (png_byte)((*sp >> sshift) & 0x01);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 2:\n         {\n            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);\n            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 3) & 0x03) << 1);\n               dshift = (((final_width + 3) & 0x03) << 1);\n               s_start = 6;\n               s_end = 0;\n               s_inc = -2;\n            }\n\n            else\n#endif\n            {\n               sshift = ((3 - ((row_info->width + 3) & 0x03)) << 1);\n               dshift = ((3 - ((final_width + 3) & 0x03)) << 1);\n               s_start = 0;\n               s_end = 6;\n               s_inc = 2;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v;\n               int j;\n\n               v = (png_byte)((*sp >> sshift) & 0x03);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 1);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 1);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            png_uint_32 i;\n            int jstop = (int)png_pass_inc[pass];\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 1) & 0x01) << 2);\n               dshift = (((final_width + 1) & 0x01) << 2);\n               s_start = 4;\n               s_end = 0;\n               s_inc = -4;\n            }\n\n            else\n#endif\n            {\n               sshift = ((1 - ((row_info->width + 1) & 0x01)) << 2);\n               dshift = ((1 - ((final_width + 1) & 0x01)) << 2);\n               s_start = 0;\n               s_end = 4;\n               s_inc = 4;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);\n               int j;\n\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         default:\n         {\n            size_t pixel_bytes = (row_info->pixel_depth >> 3);\n\n            png_bytep sp = row + (size_t)(row_info->width - 1)\n                * pixel_bytes;\n\n            png_bytep dp = row + (size_t)(final_width - 1) * pixel_bytes;\n\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */\n               int j;\n\n               memcpy(v, sp, pixel_bytes);\n\n               for (j = 0; j < jstop; j++)\n               {\n                  memcpy(dp, v, pixel_bytes);\n                  dp -= pixel_bytes;\n               }\n\n               sp -= pixel_bytes;\n            }\n            break;\n         }\n      }\n\n      row_info->width = final_width;\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);\n   }\n#ifndef PNG_READ_PACKSWAP_SUPPORTED\n   PNG_UNUSED(transformations)  /* Silence compiler warning */\n#endif\n}\n#endif /* READ_INTERLACING */\n\nstatic void\npng_read_filter_row_sub(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   size_t istop = row_info->rowbytes;\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   png_bytep rp = row + bpp;\n\n   PNG_UNUSED(prev_row)\n\n   for (i = bpp; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);\n      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_up(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   size_t istop = row_info->rowbytes;\n   png_bytep rp = row;\n   png_const_bytep pp = prev_row;\n\n   for (i = 0; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);\n      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_avg(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   png_bytep rp = row;\n   png_const_bytep pp = prev_row;\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   size_t istop = row_info->rowbytes - bpp;\n\n   for (i = 0; i < bpp; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) +\n         ((int)(*pp++) / 2 )) & 0xff);\n\n      rp++;\n   }\n\n   for (i = 0; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) +\n         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);\n\n      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   png_bytep rp_end = row + row_info->rowbytes;\n   int a, c;\n\n   /* First pixel/byte */\n   c = *prev_row++;\n   a = *row + c;\n   *row++ = (png_byte)a;\n\n   /* Remainder */\n   while (row < rp_end)\n   {\n      int b, pa, pb, pc, p;\n\n      a &= 0xff; /* From previous iteration or start */\n      b = *prev_row++;\n\n      p = b - c;\n      pc = a - c;\n\n#ifdef PNG_USE_ABS\n      pa = abs(p);\n      pb = abs(pc);\n      pc = abs(p + pc);\n#else\n      pa = p < 0 ? -p : p;\n      pb = pc < 0 ? -pc : pc;\n      pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n\n      /* Find the best predictor, the least of pa, pb, pc favoring the earlier\n       * ones in the case of a tie.\n       */\n      if (pb < pa)\n      {\n         pa = pb; a = b;\n      }\n      if (pc < pa) a = c;\n\n      /* Calculate the current pixel in a, and move the previous row pixel to c\n       * for the next time round the loop\n       */\n      c = b;\n      a += *row;\n      *row++ = (png_byte)a;\n   }\n}\n\nstatic void\npng_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   png_bytep rp_end = row + bpp;\n\n   /* Process the first pixel in the row completely (this is the same as 'up'\n    * because there is only one candidate predictor for the first row).\n    */\n   while (row < rp_end)\n   {\n      int a = *row + *prev_row++;\n      *row++ = (png_byte)a;\n   }\n\n   /* Remainder */\n   rp_end = rp_end + (row_info->rowbytes - bpp);\n\n   while (row < rp_end)\n   {\n      int a, b, c, pa, pb, pc, p;\n\n      c = *(prev_row - bpp);\n      a = *(row - bpp);\n      b = *prev_row++;\n\n      p = b - c;\n      pc = a - c;\n\n#ifdef PNG_USE_ABS\n      pa = abs(p);\n      pb = abs(pc);\n      pc = abs(p + pc);\n#else\n      pa = p < 0 ? -p : p;\n      pb = pc < 0 ? -pc : pc;\n      pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n\n      if (pb < pa)\n      {\n         pa = pb; a = b;\n      }\n      if (pc < pa) a = c;\n\n      a += *row;\n      *row++ = (png_byte)a;\n   }\n}\n\nstatic void\npng_init_filter_functions(png_structrp pp)\n   /* This function is called once for every PNG image (except for PNG images\n    * that only use PNG_FILTER_VALUE_NONE for all rows) to set the\n    * implementations required to reverse the filtering of PNG rows.  Reversing\n    * the filter is the first transformation performed on the row data.  It is\n    * performed in place, therefore an implementation can be selected based on\n    * the image pixel format.  If the implementation depends on image width then\n    * take care to ensure that it works correctly if the image is interlaced -\n    * interlacing causes the actual row width to vary.\n    */\n{\n   unsigned int bpp = (pp->pixel_depth + 7) >> 3;\n\n   pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;\n   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;\n   pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;\n   if (bpp == 1)\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n         png_read_filter_row_paeth_1byte_pixel;\n   else\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n         png_read_filter_row_paeth_multibyte_pixel;\n\n#ifdef PNG_FILTER_OPTIMIZATIONS\n   /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to\n    * call to install hardware optimizations for the above functions; simply\n    * replace whatever elements of the pp->read_filter[] array with a hardware\n    * specific (or, for that matter, generic) optimization.\n    *\n    * To see an example of this examine what configure.ac does when\n    * --enable-arm-neon is specified on the command line.\n    */\n   PNG_FILTER_OPTIMIZATIONS(pp, bpp);\n#endif\n}\n\nvoid /* PRIVATE */\npng_read_filter_row(png_structrp pp, png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row, int filter)\n{\n   /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define\n    * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic\n    * implementations.  See png_init_filter_functions above.\n    */\n   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)\n   {\n      if (pp->read_filter[0] == NULL)\n         png_init_filter_functions(pp);\n\n      pp->read_filter[filter-1](row_info, row, prev_row);\n   }\n}\n\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\nvoid /* PRIVATE */\npng_read_IDAT_data(png_structrp png_ptr, png_bytep output,\n    png_alloc_size_t avail_out)\n{\n   /* Loop reading IDATs and decompressing the result into output[avail_out] */\n   png_ptr->zstream.next_out = output;\n   png_ptr->zstream.avail_out = 0; /* safety: set below */\n\n   if (output == NULL)\n      avail_out = 0;\n\n   do\n   {\n      int ret;\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\n\n      if (png_ptr->zstream.avail_in == 0)\n      {\n         uInt avail_in;\n         png_bytep buffer;\n\n         while (png_ptr->idat_size == 0)\n         {\n            png_crc_finish(png_ptr, 0);\n\n            png_ptr->idat_size = png_read_chunk_header(png_ptr);\n            /* This is an error even in the 'check' case because the code just\n             * consumed a non-IDAT header.\n             */\n            if (png_ptr->chunk_name != png_IDAT)\n               png_error(png_ptr, \"Not enough image data\");\n         }\n\n         avail_in = png_ptr->IDAT_read_size;\n\n         if (avail_in > png_ptr->idat_size)\n            avail_in = (uInt)png_ptr->idat_size;\n\n         /* A PNG with a gradually increasing IDAT size will defeat this attempt\n          * to minimize memory usage by causing lots of re-allocs, but\n          * realistically doing IDAT_read_size re-allocs is not likely to be a\n          * big problem.\n          */\n         buffer = png_read_buffer(png_ptr, avail_in, 0/*error*/);\n\n         png_crc_read(png_ptr, buffer, avail_in);\n         png_ptr->idat_size -= avail_in;\n\n         png_ptr->zstream.next_in = buffer;\n         png_ptr->zstream.avail_in = avail_in;\n      }\n\n      /* And set up the output side. */\n      if (output != NULL) /* standard read */\n      {\n         uInt out = ZLIB_IO_MAX;\n\n         if (out > avail_out)\n            out = (uInt)avail_out;\n\n         avail_out -= out;\n         png_ptr->zstream.avail_out = out;\n      }\n\n      else /* after last row, checking for end */\n      {\n         png_ptr->zstream.next_out = tmpbuf;\n         png_ptr->zstream.avail_out = (sizeof tmpbuf);\n      }\n\n      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the\n       * process.  If the LZ stream is truncated the sequential reader will\n       * terminally damage the stream, above, by reading the chunk header of the\n       * following chunk (it then exits with png_error).\n       *\n       * TODO: deal more elegantly with truncated IDAT lists.\n       */\n      ret = PNG_INFLATE(png_ptr, Z_NO_FLUSH);\n\n      /* Take the unconsumed output back. */\n      if (output != NULL)\n         avail_out += png_ptr->zstream.avail_out;\n\n      else /* avail_out counts the extra bytes */\n         avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;\n\n      png_ptr->zstream.avail_out = 0;\n\n      if (ret == Z_STREAM_END)\n      {\n         /* Do this for safety; we won't read any more into this row. */\n         png_ptr->zstream.next_out = NULL;\n\n         png_ptr->mode |= PNG_AFTER_IDAT;\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\n\n         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)\n            png_chunk_benign_error(png_ptr, \"Extra compressed data\");\n         break;\n      }\n\n      if (ret != Z_OK)\n      {\n         png_zstream_error(png_ptr, ret);\n\n         if (output != NULL)\n            png_chunk_error(png_ptr, png_ptr->zstream.msg);\n\n         else /* checking */\n         {\n            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);\n            return;\n         }\n      }\n   } while (avail_out > 0);\n\n   if (avail_out > 0)\n   {\n      /* The stream ended before the image; this is the same as too few IDATs so\n       * should be handled the same way.\n       */\n      if (output != NULL)\n         png_error(png_ptr, \"Not enough image data\");\n\n      else /* the deflate stream contained extra data */\n         png_chunk_benign_error(png_ptr, \"Too much image data\");\n   }\n}\n\nvoid /* PRIVATE */\npng_read_finish_IDAT(png_structrp png_ptr)\n{\n   /* We don't need any more data and the stream should have ended, however the\n    * LZ end code may actually not have been processed.  In this case we must\n    * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk\n    * may still remain to be consumed.\n    */\n   if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)\n   {\n      /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in\n       * the compressed stream, but the stream may be damaged too, so even after\n       * this call we may need to terminate the zstream ownership.\n       */\n      png_read_IDAT_data(png_ptr, NULL, 0);\n      png_ptr->zstream.next_out = NULL; /* safety */\n\n      /* Now clear everything out for safety; the following may not have been\n       * done.\n       */\n      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)\n      {\n         png_ptr->mode |= PNG_AFTER_IDAT;\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\n      }\n   }\n\n   /* If the zstream has not been released do it now *and* terminate the reading\n    * of the final IDAT chunk.\n    */\n   if (png_ptr->zowner == png_IDAT)\n   {\n      /* Always do this; the pointers otherwise point into the read buffer. */\n      png_ptr->zstream.next_in = NULL;\n      png_ptr->zstream.avail_in = 0;\n\n      /* Now we no longer own the zstream. */\n      png_ptr->zowner = 0;\n\n      /* The slightly weird semantics of the sequential IDAT reading is that we\n       * are always in or at the end of an IDAT chunk, so we always need to do a\n       * crc_finish here.  If idat_size is non-zero we also need to read the\n       * spurious bytes at the end of the chunk now.\n       */\n      (void)png_crc_finish(png_ptr, png_ptr->idat_size);\n   }\n}\n\nvoid /* PRIVATE */\npng_read_finish_row(png_structrp png_ptr)\n{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* Start of interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* Offset to next interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n\n   png_debug(1, \"in png_read_finish_row\");\n   png_ptr->row_number++;\n   if (png_ptr->row_number < png_ptr->num_rows)\n      return;\n\n   if (png_ptr->interlaced != 0)\n   {\n      png_ptr->row_number = 0;\n\n      /* TO DO: don't do this if prev_row isn't needed (requires\n       * read-ahead of the next row's filter byte.\n       */\n      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n      do\n      {\n         png_ptr->pass++;\n\n         if (png_ptr->pass >= 7)\n            break;\n\n         png_ptr->iwidth = (png_ptr->width +\n            png_pass_inc[png_ptr->pass] - 1 -\n            png_pass_start[png_ptr->pass]) /\n            png_pass_inc[png_ptr->pass];\n\n         if ((png_ptr->transformations & PNG_INTERLACE) == 0)\n         {\n            png_ptr->num_rows = (png_ptr->height +\n                png_pass_yinc[png_ptr->pass] - 1 -\n                png_pass_ystart[png_ptr->pass]) /\n                png_pass_yinc[png_ptr->pass];\n         }\n\n         else  /* if (png_ptr->transformations & PNG_INTERLACE) */\n            break; /* libpng deinterlacing sees every row */\n\n      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);\n\n      if (png_ptr->pass < 7)\n         return;\n   }\n\n   /* Here after at the end of the last row of the last pass. */\n   png_read_finish_IDAT(png_ptr);\n}\n#endif /* SEQUENTIAL_READ */\n\nvoid /* PRIVATE */\npng_read_start_row(png_structrp png_ptr)\n{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* Start of interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* Offset to next interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n\n   unsigned int max_pixel_depth;\n   size_t row_bytes;\n\n   png_debug(1, \"in png_read_start_row\");\n\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\n   png_init_read_transformations(png_ptr);\n#endif\n   if (png_ptr->interlaced != 0)\n   {\n      if ((png_ptr->transformations & PNG_INTERLACE) == 0)\n         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -\n             png_pass_ystart[0]) / png_pass_yinc[0];\n\n      else\n         png_ptr->num_rows = png_ptr->height;\n\n      png_ptr->iwidth = (png_ptr->width +\n          png_pass_inc[png_ptr->pass] - 1 -\n          png_pass_start[png_ptr->pass]) /\n          png_pass_inc[png_ptr->pass];\n   }\n\n   else\n   {\n      png_ptr->num_rows = png_ptr->height;\n      png_ptr->iwidth = png_ptr->width;\n   }\n\n   max_pixel_depth = (unsigned int)png_ptr->pixel_depth;\n\n   /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of\n    * calculations to calculate the final pixel depth, then\n    * png_do_read_transforms actually does the transforms.  This means that the\n    * code which effectively calculates this value is actually repeated in three\n    * separate places.  They must all match.  Innocent changes to the order of\n    * transformations can and will break libpng in a way that causes memory\n    * overwrites.\n    *\n    * TODO: fix this.\n    */\n#ifdef PNG_READ_PACK_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACK) != 0 && png_ptr->bit_depth < 8)\n      max_pixel_depth = 8;\n#endif\n\n#ifdef PNG_READ_EXPAND_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND) != 0)\n   {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (png_ptr->num_trans != 0)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 24;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (max_pixel_depth < 8)\n            max_pixel_depth = 8;\n\n         if (png_ptr->num_trans != 0)\n            max_pixel_depth *= 2;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n      {\n         if (png_ptr->num_trans != 0)\n         {\n            max_pixel_depth *= 4;\n            max_pixel_depth /= 3;\n         }\n      }\n   }\n#endif\n\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)\n   {\n#  ifdef PNG_READ_EXPAND_SUPPORTED\n      /* In fact it is an error if it isn't supported, but checking is\n       * the safe way.\n       */\n      if ((png_ptr->transformations & PNG_EXPAND) != 0)\n      {\n         if (png_ptr->bit_depth < 16)\n            max_pixel_depth *= 2;\n      }\n      else\n#  endif\n      png_ptr->transformations &= ~PNG_EXPAND_16;\n   }\n#endif\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n   if ((png_ptr->transformations & (PNG_FILLER)) != 0)\n   {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (max_pixel_depth <= 8)\n            max_pixel_depth = 16;\n\n         else\n            max_pixel_depth = 32;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB ||\n         png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (max_pixel_depth <= 32)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 64;\n      }\n   }\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)\n   {\n      if (\n#ifdef PNG_READ_EXPAND_SUPPORTED\n          (png_ptr->num_trans != 0 &&\n          (png_ptr->transformations & PNG_EXPAND) != 0) ||\n#endif\n#ifdef PNG_READ_FILLER_SUPPORTED\n          (png_ptr->transformations & (PNG_FILLER)) != 0 ||\n#endif\n          png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      {\n         if (max_pixel_depth <= 16)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 64;\n      }\n\n      else\n      {\n         if (max_pixel_depth <= 8)\n         {\n            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n               max_pixel_depth = 32;\n\n            else\n               max_pixel_depth = 24;\n         }\n\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            max_pixel_depth = 64;\n\n         else\n            max_pixel_depth = 48;\n      }\n   }\n#endif\n\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \\\ndefined(PNG_USER_TRANSFORM_PTR_SUPPORTED)\n   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)\n   {\n      unsigned int user_pixel_depth = png_ptr->user_transform_depth *\n         png_ptr->user_transform_channels;\n\n      if (user_pixel_depth > max_pixel_depth)\n         max_pixel_depth = user_pixel_depth;\n   }\n#endif\n\n   /* This value is stored in png_struct and double checked in the row read\n    * code.\n    */\n   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;\n   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */\n\n   /* Align the width on the next larger 8 pixels.  Mainly used\n    * for interlacing\n    */\n   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));\n   /* Calculate the maximum bytes needed, adding a byte and a pixel\n    * for safety's sake\n    */\n   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +\n       1 + ((max_pixel_depth + 7) >> 3U);\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (row_bytes > (png_uint_32)65536L)\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\n#endif\n\n   if (row_bytes + 48 > png_ptr->old_big_row_buf_size)\n   {\n      png_free(png_ptr, png_ptr->big_row_buf);\n      png_free(png_ptr, png_ptr->big_prev_row);\n\n      if (png_ptr->interlaced != 0)\n         png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,\n             row_bytes + 48);\n\n      else\n         png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\n\n      png_ptr->big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\n\n#ifdef PNG_ALIGNED_MEMORY_SUPPORTED\n      /* Use 16-byte aligned memory for row_buf with at least 16 bytes\n       * of padding before and after row_buf; treat prev_row similarly.\n       * NOTE: the alignment is to the start of the pixels, one beyond the start\n       * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this\n       * was incorrect; the filter byte was aligned, which had the exact\n       * opposite effect of that intended.\n       */\n      {\n         png_bytep temp = png_ptr->big_row_buf + 32;\n         int extra = (int)((temp - (png_bytep)0) & 0x0f);\n         png_ptr->row_buf = temp - extra - 1/*filter byte*/;\n\n         temp = png_ptr->big_prev_row + 32;\n         extra = (int)((temp - (png_bytep)0) & 0x0f);\n         png_ptr->prev_row = temp - extra - 1/*filter byte*/;\n      }\n\n#else\n      /* Use 31 bytes of padding before and 17 bytes after row_buf. */\n      png_ptr->row_buf = png_ptr->big_row_buf + 31;\n      png_ptr->prev_row = png_ptr->big_prev_row + 31;\n#endif\n      png_ptr->old_big_row_buf_size = row_bytes + 48;\n   }\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (png_ptr->rowbytes > 65535)\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\n\n#endif\n   if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))\n      png_error(png_ptr, \"Row has too many bytes to allocate in memory\");\n\n   memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n   png_debug1(3, \"width = %u,\", png_ptr->width);\n   png_debug1(3, \"height = %u,\", png_ptr->height);\n   png_debug1(3, \"iwidth = %u,\", png_ptr->iwidth);\n   png_debug1(3, \"num_rows = %u,\", png_ptr->num_rows);\n   png_debug1(3, \"rowbytes = %lu,\", (unsigned long)png_ptr->rowbytes);\n   png_debug1(3, \"irowbytes = %lu\",\n       (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);\n\n   /* The sequential reader needs a buffer for IDAT, but the progressive reader\n    * does not, so free the read buffer now regardless; the sequential reader\n    * reallocates it on demand.\n    */\n   if (png_ptr->read_buffer != NULL)\n   {\n      png_bytep buffer = png_ptr->read_buffer;\n\n      png_ptr->read_buffer_size = 0;\n      png_ptr->read_buffer = NULL;\n      png_free(png_ptr, buffer);\n   }\n\n   /* Finally claim the zstream for the inflate of the IDAT data, use the bits\n    * value from the stream (note that this will result in a fatal error if the\n    * IDAT stream has a bogus deflate header window_bits value, but this should\n    * not be happening any longer!)\n    */\n   if (png_inflate_claim(png_ptr, png_IDAT) != Z_OK)\n      png_error(png_ptr, png_ptr->zstream.msg);\n\n   png_ptr->flags |= PNG_FLAG_ROW_INIT;\n}\n#endif /* READ */\n"], "filenames": ["pngrutil.c"], "buggy_code_start_loc": [3170], "buggy_code_end_loc": [3174], "fixing_code_start_loc": [3170], "fixing_code_end_loc": [3177], "type": "CWE-190", "message": "In libpng 1.6.34, a wrong calculation of row_factor in the png_check_chunk_length function (pngrutil.c) may trigger an integer overflow and resultant divide-by-zero while processing a crafted PNG file, leading to a denial of service.", "other": {"cve": {"id": "CVE-2018-13785", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-09T13:29:00.443", "lastModified": "2022-06-27T17:35:26.610", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In libpng 1.6.34, a wrong calculation of row_factor in the png_check_chunk_length function (pngrutil.c) may trigger an integer overflow and resultant divide-by-zero while processing a crafted PNG file, leading to a denial of service."}, {"lang": "es", "value": "En libpng 1.6.34, un c\u00e1lculo err\u00f3neo de row_factor en la funci\u00f3n png_check_chunk_length (pngrutil.c) podr\u00eda desencadenar un desbordamiento de enteros y una divisi\u00f3n entre cero resultante al procesar un archivo PNG manipulado, lo que conducir\u00eda a una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libpng:libpng:1.6.34:*:*:*:*:*:*:*", "matchCriteriaId": "8CD36A99-1431-4B6C-9C92-3D94B56B4BED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jdk:1.6.0:update201:*:*:*:*:*:*", "matchCriteriaId": "9C07DBB8-760D-4A9E-B7C7-A382D650658B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jdk:1.7.0:update191:*:*:*:*:*:*", "matchCriteriaId": "ED6BF214-B45C-405E-83AC-C8A084A6E4C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jdk:1.8.0:update181:*:*:*:*:*:*", "matchCriteriaId": "7D8C0DB7-6178-4D70-B460-97A49F012560"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jdk:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "CE66FC86-ADF3-4295-9C10-2A0AF16A538C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jre:1.6.0:update201:*:*:*:*:*:*", "matchCriteriaId": "BBE0F763-B860-4B30-A5E9-2FCE78F5932D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jre:1.7.0:update191:*:*:*:*:*:*", "matchCriteriaId": "C192F54C-108C-4E40-BC29-CF911C3B9EB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jre:1.8.0:update181:*:*:*:*:*:*", "matchCriteriaId": "4ADC2C70-B7C4-49AC-B4CC-C5FC60903F3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jre:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "32548053-521C-4D17-8791-680074D5C55E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/105599", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1041889", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3000", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3001", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3002", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3003", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3007", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3008", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3533", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3534", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3671", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3672", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3779", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3852", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/glennrp/libpng/commit/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201908-10", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20181018-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://sourceforge.net/p/libpng/bugs/278/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3712-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/glennrp/libpng/commit/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2"}}