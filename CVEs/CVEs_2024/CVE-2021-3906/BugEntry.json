{"buggy_code": ["<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Auth\\Permissions\\PermissionService;\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Exceptions\\ImageUploadException;\nuse Exception;\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass ImageRepo\n{\n    protected $image;\n    protected $imageService;\n    protected $restrictionService;\n    protected $page;\n\n    protected static $supportedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\n\n    /**\n     * ImageRepo constructor.\n     */\n    public function __construct(\n        Image $image,\n        ImageService $imageService,\n        PermissionService $permissionService,\n        Page $page\n    ) {\n        $this->image = $image;\n        $this->imageService = $imageService;\n        $this->restrictionService = $permissionService;\n        $this->page = $page;\n    }\n\n    /**\n     * Check if the given image extension is supported by BookStack.\n     */\n    public function imageExtensionSupported(string $extension): bool\n    {\n        return in_array(trim($extension, '. \\t\\n\\r\\0\\x0B'), static::$supportedExtensions);\n    }\n\n    /**\n     * Get an image with the given id.\n     */\n    public function getById($id): Image\n    {\n        return $this->image->findOrFail($id);\n    }\n\n    /**\n     * Execute a paginated query, returning in a standard format.\n     * Also runs the query through the restriction system.\n     */\n    private function returnPaginated($query, $page = 1, $pageSize = 24): array\n    {\n        $images = $query->orderBy('created_at', 'desc')->skip($pageSize * ($page - 1))->take($pageSize + 1)->get();\n        $hasMore = count($images) > $pageSize;\n\n        $returnImages = $images->take($pageSize);\n        $returnImages->each(function ($image) {\n            $this->loadThumbs($image);\n        });\n\n        return [\n            'images'   => $returnImages,\n            'has_more' => $hasMore,\n        ];\n    }\n\n    /**\n     * Fetch a list of images in a paginated format, filtered by image type.\n     * Can be filtered by uploaded to and also by name.\n     */\n    public function getPaginatedByType(\n        string $type,\n        int $page = 0,\n        int $pageSize = 24,\n        int $uploadedTo = null,\n        string $search = null,\n        callable $whereClause = null\n    ): array {\n        $imageQuery = $this->image->newQuery()->where('type', '=', strtolower($type));\n\n        if ($uploadedTo !== null) {\n            $imageQuery = $imageQuery->where('uploaded_to', '=', $uploadedTo);\n        }\n\n        if ($search !== null) {\n            $imageQuery = $imageQuery->where('name', 'LIKE', '%' . $search . '%');\n        }\n\n        // Filter by page access\n        $imageQuery = $this->restrictionService->filterRelatedEntity(Page::class, $imageQuery, 'images', 'uploaded_to');\n\n        if ($whereClause !== null) {\n            $imageQuery = $imageQuery->where($whereClause);\n        }\n\n        return $this->returnPaginated($imageQuery, $page, $pageSize);\n    }\n\n    /**\n     * Get paginated gallery images within a specific page or book.\n     */\n    public function getEntityFiltered(\n        string $type,\n        string $filterType = null,\n        int $page = 0,\n        int $pageSize = 24,\n        int $uploadedTo = null,\n        string $search = null\n    ): array {\n        $contextPage = $this->page->findOrFail($uploadedTo);\n        $parentFilter = null;\n\n        if ($filterType === 'book' || $filterType === 'page') {\n            $parentFilter = function (Builder $query) use ($filterType, $contextPage) {\n                if ($filterType === 'page') {\n                    $query->where('uploaded_to', '=', $contextPage->id);\n                } elseif ($filterType === 'book') {\n                    $validPageIds = $contextPage->book->pages()->visible()->get(['id'])->pluck('id')->toArray();\n                    $query->whereIn('uploaded_to', $validPageIds);\n                }\n            };\n        }\n\n        return $this->getPaginatedByType($type, $page, $pageSize, null, $search, $parentFilter);\n    }\n\n    /**\n     * Save a new image into storage and return the new image.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNew(UploadedFile $uploadFile, string $type, int $uploadedTo = 0, int $resizeWidth = null, int $resizeHeight = null, bool $keepRatio = true): Image\n    {\n        $image = $this->imageService->saveNewFromUpload($uploadFile, $type, $uploadedTo, $resizeWidth, $resizeHeight, $keepRatio);\n        $this->loadThumbs($image);\n\n        return $image;\n    }\n\n    /**\n     * Save a new image from an existing image data string.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNewFromData(string $imageName, string $imageData, string $type, int $uploadedTo = 0)\n    {\n        $image = $this->imageService->saveNew($imageName, $imageData, $type, $uploadedTo);\n        $this->loadThumbs($image);\n\n        return $image;\n    }\n\n    /**\n     * Save a drawing the the database.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveDrawing(string $base64Uri, int $uploadedTo): Image\n    {\n        $name = 'Drawing-' . strval(user()->id) . '-' . strval(time()) . '.png';\n\n        return $this->imageService->saveNewFromBase64Uri($base64Uri, $name, 'drawio', $uploadedTo);\n    }\n\n    /**\n     * Update the details of an image via an array of properties.\n     *\n     * @throws ImageUploadException\n     * @throws Exception\n     */\n    public function updateImageDetails(Image $image, $updateDetails): Image\n    {\n        $image->fill($updateDetails);\n        $image->save();\n        $this->loadThumbs($image);\n\n        return $image;\n    }\n\n    /**\n     * Destroys an Image object along with its revisions, files and thumbnails.\n     *\n     * @throws Exception\n     */\n    public function destroyImage(Image $image = null): bool\n    {\n        if ($image) {\n            $this->imageService->destroy($image);\n        }\n\n        return true;\n    }\n\n    /**\n     * Destroy all images of a certain type.\n     *\n     * @throws Exception\n     */\n    public function destroyByType(string $imageType)\n    {\n        $images = $this->image->where('type', '=', $imageType)->get();\n        foreach ($images as $image) {\n            $this->destroyImage($image);\n        }\n    }\n\n    /**\n     * Load thumbnails onto an image object.\n     *\n     * @throws Exception\n     */\n    public function loadThumbs(Image $image)\n    {\n        $image->thumbs = [\n            'gallery' => $this->getThumbnail($image, 150, 150, false),\n            'display' => $this->getThumbnail($image, 1680, null, true),\n        ];\n    }\n\n    /**\n     * Get the thumbnail for an image.\n     * If $keepRatio is true only the width will be used.\n     * Checks the cache then storage to avoid creating / accessing the filesystem on every check.\n     *\n     * @throws Exception\n     */\n    protected function getThumbnail(Image $image, ?int $width = 220, ?int $height = 220, bool $keepRatio = false): ?string\n    {\n        try {\n            return $this->imageService->getThumbnail($image, $width, $height, $keepRatio);\n        } catch (Exception $exception) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the raw image data from an Image.\n     */\n    public function getImageData(Image $image): ?string\n    {\n        try {\n            return $this->imageService->getImageData($image);\n        } catch (Exception $exception) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the user visible pages using the given image.\n     */\n    public function getPagesUsingImage(Image $image): array\n    {\n        $pages = Page::visible()\n            ->where('html', 'like', '%' . $image->url . '%')\n            ->get(['id', 'name', 'slug', 'book_id']);\n\n        foreach ($pages as $page) {\n            $page->url = $page->getUrl();\n        }\n\n        return $pages->all();\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Auth\\Permissions\\PermissionService;\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Exceptions\\ImageUploadException;\nuse Exception;\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass ImageRepo\n{\n    protected $image;\n    protected $imageService;\n    protected $restrictionService;\n    protected $page;\n\n    protected static $supportedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\n\n    /**\n     * ImageRepo constructor.\n     */\n    public function __construct(\n        Image $image,\n        ImageService $imageService,\n        PermissionService $permissionService,\n        Page $page\n    ) {\n        $this->image = $image;\n        $this->imageService = $imageService;\n        $this->restrictionService = $permissionService;\n        $this->page = $page;\n    }\n\n    /**\n     * Check if the given image extension is supported by BookStack.\n     */\n    public function imageExtensionSupported(string $extension): bool\n    {\n        return in_array(trim($extension, \". \\t\\n\\r\\0\\x0B\"), static::$supportedExtensions);\n    }\n\n    /**\n     * Get an image with the given id.\n     */\n    public function getById($id): Image\n    {\n        return $this->image->findOrFail($id);\n    }\n\n    /**\n     * Execute a paginated query, returning in a standard format.\n     * Also runs the query through the restriction system.\n     */\n    private function returnPaginated($query, $page = 1, $pageSize = 24): array\n    {\n        $images = $query->orderBy('created_at', 'desc')->skip($pageSize * ($page - 1))->take($pageSize + 1)->get();\n        $hasMore = count($images) > $pageSize;\n\n        $returnImages = $images->take($pageSize);\n        $returnImages->each(function ($image) {\n            $this->loadThumbs($image);\n        });\n\n        return [\n            'images'   => $returnImages,\n            'has_more' => $hasMore,\n        ];\n    }\n\n    /**\n     * Fetch a list of images in a paginated format, filtered by image type.\n     * Can be filtered by uploaded to and also by name.\n     */\n    public function getPaginatedByType(\n        string $type,\n        int $page = 0,\n        int $pageSize = 24,\n        int $uploadedTo = null,\n        string $search = null,\n        callable $whereClause = null\n    ): array {\n        $imageQuery = $this->image->newQuery()->where('type', '=', strtolower($type));\n\n        if ($uploadedTo !== null) {\n            $imageQuery = $imageQuery->where('uploaded_to', '=', $uploadedTo);\n        }\n\n        if ($search !== null) {\n            $imageQuery = $imageQuery->where('name', 'LIKE', '%' . $search . '%');\n        }\n\n        // Filter by page access\n        $imageQuery = $this->restrictionService->filterRelatedEntity(Page::class, $imageQuery, 'images', 'uploaded_to');\n\n        if ($whereClause !== null) {\n            $imageQuery = $imageQuery->where($whereClause);\n        }\n\n        return $this->returnPaginated($imageQuery, $page, $pageSize);\n    }\n\n    /**\n     * Get paginated gallery images within a specific page or book.\n     */\n    public function getEntityFiltered(\n        string $type,\n        string $filterType = null,\n        int $page = 0,\n        int $pageSize = 24,\n        int $uploadedTo = null,\n        string $search = null\n    ): array {\n        $contextPage = $this->page->findOrFail($uploadedTo);\n        $parentFilter = null;\n\n        if ($filterType === 'book' || $filterType === 'page') {\n            $parentFilter = function (Builder $query) use ($filterType, $contextPage) {\n                if ($filterType === 'page') {\n                    $query->where('uploaded_to', '=', $contextPage->id);\n                } elseif ($filterType === 'book') {\n                    $validPageIds = $contextPage->book->pages()->visible()->get(['id'])->pluck('id')->toArray();\n                    $query->whereIn('uploaded_to', $validPageIds);\n                }\n            };\n        }\n\n        return $this->getPaginatedByType($type, $page, $pageSize, null, $search, $parentFilter);\n    }\n\n    /**\n     * Save a new image into storage and return the new image.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNew(UploadedFile $uploadFile, string $type, int $uploadedTo = 0, int $resizeWidth = null, int $resizeHeight = null, bool $keepRatio = true): Image\n    {\n        $image = $this->imageService->saveNewFromUpload($uploadFile, $type, $uploadedTo, $resizeWidth, $resizeHeight, $keepRatio);\n        $this->loadThumbs($image);\n\n        return $image;\n    }\n\n    /**\n     * Save a new image from an existing image data string.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNewFromData(string $imageName, string $imageData, string $type, int $uploadedTo = 0)\n    {\n        $image = $this->imageService->saveNew($imageName, $imageData, $type, $uploadedTo);\n        $this->loadThumbs($image);\n\n        return $image;\n    }\n\n    /**\n     * Save a drawing the the database.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveDrawing(string $base64Uri, int $uploadedTo): Image\n    {\n        $name = 'Drawing-' . strval(user()->id) . '-' . strval(time()) . '.png';\n\n        return $this->imageService->saveNewFromBase64Uri($base64Uri, $name, 'drawio', $uploadedTo);\n    }\n\n    /**\n     * Update the details of an image via an array of properties.\n     *\n     * @throws ImageUploadException\n     * @throws Exception\n     */\n    public function updateImageDetails(Image $image, $updateDetails): Image\n    {\n        $image->fill($updateDetails);\n        $image->save();\n        $this->loadThumbs($image);\n\n        return $image;\n    }\n\n    /**\n     * Destroys an Image object along with its revisions, files and thumbnails.\n     *\n     * @throws Exception\n     */\n    public function destroyImage(Image $image = null): bool\n    {\n        if ($image) {\n            $this->imageService->destroy($image);\n        }\n\n        return true;\n    }\n\n    /**\n     * Destroy all images of a certain type.\n     *\n     * @throws Exception\n     */\n    public function destroyByType(string $imageType)\n    {\n        $images = $this->image->where('type', '=', $imageType)->get();\n        foreach ($images as $image) {\n            $this->destroyImage($image);\n        }\n    }\n\n    /**\n     * Load thumbnails onto an image object.\n     *\n     * @throws Exception\n     */\n    public function loadThumbs(Image $image)\n    {\n        $image->thumbs = [\n            'gallery' => $this->getThumbnail($image, 150, 150, false),\n            'display' => $this->getThumbnail($image, 1680, null, true),\n        ];\n    }\n\n    /**\n     * Get the thumbnail for an image.\n     * If $keepRatio is true only the width will be used.\n     * Checks the cache then storage to avoid creating / accessing the filesystem on every check.\n     *\n     * @throws Exception\n     */\n    protected function getThumbnail(Image $image, ?int $width = 220, ?int $height = 220, bool $keepRatio = false): ?string\n    {\n        try {\n            return $this->imageService->getThumbnail($image, $width, $height, $keepRatio);\n        } catch (Exception $exception) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the raw image data from an Image.\n     */\n    public function getImageData(Image $image): ?string\n    {\n        try {\n            return $this->imageService->getImageData($image);\n        } catch (Exception $exception) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the user visible pages using the given image.\n     */\n    public function getPagesUsingImage(Image $image): array\n    {\n        $pages = Page::visible()\n            ->where('html', 'like', '%' . $image->url . '%')\n            ->get(['id', 'name', 'slug', 'book_id']);\n\n        foreach ($pages as $page) {\n            $page->url = $page->getUrl();\n        }\n\n        return $pages->all();\n    }\n}\n"], "filenames": ["app/Uploads/ImageRepo.php"], "buggy_code_start_loc": [41], "buggy_code_end_loc": [42], "fixing_code_start_loc": [41], "fixing_code_end_loc": [42], "type": "CWE-434", "message": "bookstack is vulnerable to Unrestricted Upload of File with Dangerous Type", "other": {"cve": {"id": "CVE-2021-3906", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-27T22:15:07.817", "lastModified": "2021-11-03T14:30:27.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "bookstack is vulnerable to Unrestricted Upload of File with Dangerous Type"}, {"lang": "es", "value": "bookstack es vulnerable a una Carga no Restringida de Archivos de Tipo Peligroso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bookstackapp:bookstack:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.10.1", "matchCriteriaId": "91F81186-7056-4717-BFAE-66CC63117B8F"}]}]}], "references": [{"url": "https://github.com/bookstackapp/bookstack/commit/64937ab826b56d086af9ecea532510d37520ebc8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f115bdf5-c06b-4627-a6fa-ba6904a43ba3", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bookstackapp/bookstack/commit/64937ab826b56d086af9ecea532510d37520ebc8"}}