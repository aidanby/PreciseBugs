{"buggy_code": ["#include \"cache.h\"\n#include \"config.h\"\n#include \"credential.h\"\n#include \"string-list.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n#include \"prompt.h\"\n\nvoid credential_init(struct credential *c)\n{\n\tmemset(c, 0, sizeof(*c));\n\tc->helpers.strdup_strings = 1;\n}\n\nvoid credential_clear(struct credential *c)\n{\n\tfree(c->protocol);\n\tfree(c->host);\n\tfree(c->path);\n\tfree(c->username);\n\tfree(c->password);\n\tstring_list_clear(&c->helpers, 0);\n\n\tcredential_init(c);\n}\n\nint credential_match(const struct credential *want,\n\t\t     const struct credential *have)\n{\n#define CHECK(x) (!want->x || (have->x && !strcmp(want->x, have->x)))\n\treturn CHECK(protocol) &&\n\t       CHECK(host) &&\n\t       CHECK(path) &&\n\t       CHECK(username);\n#undef CHECK\n}\n\nstatic int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key, *dot;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tdot = strrchr(key, '.');\n\tif (dot) {\n\t\tstruct credential want = CREDENTIAL_INIT;\n\t\tchar *url = xmemdupz(key, dot - key);\n\t\tint matched;\n\n\t\tcredential_from_url(&want, url);\n\t\tmatched = credential_match(&want, c);\n\n\t\tcredential_clear(&want);\n\t\tfree(url);\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t\tkey = dot + 1;\n\t}\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username)\n\t\t\tc->username = xstrdup(value);\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}\n\nstatic int proto_is_http(const char *s)\n{\n\tif (!s)\n\t\treturn 0;\n\treturn !strcmp(s, \"https\") || !strcmp(s, \"http\");\n}\n\nstatic void credential_apply_config(struct credential *c)\n{\n\tif (c->configured)\n\t\treturn;\n\tgit_config(credential_config_callback, c);\n\tc->configured = 1;\n\n\tif (!c->use_http_path && proto_is_http(c->protocol)) {\n\t\tFREE_AND_NULL(c->path);\n\t}\n}\n\nstatic void credential_describe(struct credential *c, struct strbuf *out)\n{\n\tif (!c->protocol)\n\t\treturn;\n\tstrbuf_addf(out, \"%s://\", c->protocol);\n\tif (c->username && *c->username)\n\t\tstrbuf_addf(out, \"%s@\", c->username);\n\tif (c->host)\n\t\tstrbuf_addstr(out, c->host);\n\tif (c->path)\n\t\tstrbuf_addf(out, \"/%s\", c->path);\n}\n\nstatic char *credential_ask_one(const char *what, struct credential *c,\n\t\t\t\tint flags)\n{\n\tstruct strbuf desc = STRBUF_INIT;\n\tstruct strbuf prompt = STRBUF_INIT;\n\tchar *r;\n\n\tcredential_describe(c, &desc);\n\tif (desc.len)\n\t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc.buf);\n\telse\n\t\tstrbuf_addf(&prompt, \"%s: \", what);\n\n\tr = git_prompt(prompt.buf, flags);\n\n\tstrbuf_release(&desc);\n\tstrbuf_release(&prompt);\n\treturn xstrdup(r);\n}\n\nstatic void credential_getpass(struct credential *c)\n{\n\tif (!c->username)\n\t\tc->username = credential_ask_one(\"Username\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS|PROMPT_ECHO);\n\tif (!c->password)\n\t\tc->password = credential_ask_one(\"Password\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS);\n}\n\nint credential_read(struct credential *c, FILE *fp)\n{\n\tstruct strbuf line = STRBUF_INIT;\n\n\twhile (strbuf_getline_lf(&line, fp) != EOF) {\n\t\tchar *key = line.buf;\n\t\tchar *value = strchr(key, '=');\n\n\t\tif (!line.len)\n\t\t\tbreak;\n\n\t\tif (!value) {\n\t\t\twarning(\"invalid credential line: %s\", key);\n\t\t\tstrbuf_release(&line);\n\t\t\treturn -1;\n\t\t}\n\t\t*value++ = '\\0';\n\n\t\tif (!strcmp(key, \"username\")) {\n\t\t\tfree(c->username);\n\t\t\tc->username = xstrdup(value);\n\t\t} else if (!strcmp(key, \"password\")) {\n\t\t\tfree(c->password);\n\t\t\tc->password = xstrdup(value);\n\t\t} else if (!strcmp(key, \"protocol\")) {\n\t\t\tfree(c->protocol);\n\t\t\tc->protocol = xstrdup(value);\n\t\t} else if (!strcmp(key, \"host\")) {\n\t\t\tfree(c->host);\n\t\t\tc->host = xstrdup(value);\n\t\t} else if (!strcmp(key, \"path\")) {\n\t\t\tfree(c->path);\n\t\t\tc->path = xstrdup(value);\n\t\t} else if (!strcmp(key, \"url\")) {\n\t\t\tcredential_from_url(c, value);\n\t\t} else if (!strcmp(key, \"quit\")) {\n\t\t\tc->quit = !!git_config_bool(\"quit\", value);\n\t\t}\n\t\t/*\n\t\t * Ignore other lines; we don't know what they mean, but\n\t\t * this future-proofs us when later versions of git do\n\t\t * learn new lines, and the helpers are updated to match.\n\t\t */\n\t}\n\n\tstrbuf_release(&line);\n\treturn 0;\n}\n\nstatic void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}\n\nvoid credential_write(const struct credential *c, FILE *fp)\n{\n\tcredential_write_item(fp, \"protocol\", c->protocol);\n\tcredential_write_item(fp, \"host\", c->host);\n\tcredential_write_item(fp, \"path\", c->path);\n\tcredential_write_item(fp, \"username\", c->username);\n\tcredential_write_item(fp, \"password\", c->password);\n}\n\nstatic int run_credential_helper(struct credential *c,\n\t\t\t\t const char *cmd,\n\t\t\t\t int want_output)\n{\n\tstruct child_process helper = CHILD_PROCESS_INIT;\n\tconst char *argv[] = { NULL, NULL };\n\tFILE *fp;\n\n\targv[0] = cmd;\n\thelper.argv = argv;\n\thelper.use_shell = 1;\n\thelper.in = -1;\n\tif (want_output)\n\t\thelper.out = -1;\n\telse\n\t\thelper.no_stdout = 1;\n\n\tif (start_command(&helper) < 0)\n\t\treturn -1;\n\n\tfp = xfdopen(helper.in, \"w\");\n\tcredential_write(c, fp);\n\tfclose(fp);\n\n\tif (want_output) {\n\t\tint r;\n\t\tfp = xfdopen(helper.out, \"r\");\n\t\tr = credential_read(c, fp);\n\t\tfclose(fp);\n\t\tif (r < 0) {\n\t\t\tfinish_command(&helper);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (finish_command(&helper))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int credential_do(struct credential *c, const char *helper,\n\t\t\t const char *operation)\n{\n\tstruct strbuf cmd = STRBUF_INIT;\n\tint r;\n\n\tif (helper[0] == '!')\n\t\tstrbuf_addstr(&cmd, helper + 1);\n\telse if (is_absolute_path(helper))\n\t\tstrbuf_addstr(&cmd, helper);\n\telse\n\t\tstrbuf_addf(&cmd, \"git credential-%s\", helper);\n\n\tstrbuf_addf(&cmd, \" %s\", operation);\n\tr = run_credential_helper(c, cmd.buf, !strcmp(operation, \"get\"));\n\n\tstrbuf_release(&cmd);\n\treturn r;\n}\n\nvoid credential_fill(struct credential *c)\n{\n\tint i;\n\n\tif (c->username && c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++) {\n\t\tcredential_do(c, c->helpers.items[i].string, \"get\");\n\t\tif (c->username && c->password)\n\t\t\treturn;\n\t\tif (c->quit)\n\t\t\tdie(\"credential helper '%s' told us to quit\",\n\t\t\t    c->helpers.items[i].string);\n\t}\n\n\tcredential_getpass(c);\n\tif (!c->username && !c->password)\n\t\tdie(\"unable to get password from user\");\n}\n\nvoid credential_approve(struct credential *c)\n{\n\tint i;\n\n\tif (c->approved)\n\t\treturn;\n\tif (!c->username || !c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"store\");\n\tc->approved = 1;\n}\n\nvoid credential_reject(struct credential *c)\n{\n\tint i;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"erase\");\n\n\tFREE_AND_NULL(c->username);\n\tFREE_AND_NULL(c->password);\n\tc->approved = 0;\n}\n\nvoid credential_from_url(struct credential *c, const char *url)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end)\n\t\treturn;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tif (slash - host > 0)\n\t\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n}\n", "#!/bin/sh\n\ntest_description='basic credential helper tests'\n. ./test-lib.sh\n. \"$TEST_DIRECTORY\"/lib-credential.sh\n\ntest_expect_success 'setup helper scripts' '\n\tcat >dump <<-\\EOF &&\n\twhoami=$(echo $0 | sed s/.*git-credential-//)\n\techo >&2 \"$whoami: $*\"\n\tOIFS=$IFS\n\tIFS==\n\twhile read key value; do\n\t\techo >&2 \"$whoami: $key=$value\"\n\t\teval \"$key=$value\"\n\tdone\n\tIFS=$OIFS\n\tEOF\n\n\twrite_script git-credential-useless <<-\\EOF &&\n\t. ./dump\n\texit 0\n\tEOF\n\n\twrite_script git-credential-verbatim <<-\\EOF &&\n\tuser=$1; shift\n\tpass=$1; shift\n\t. ./dump\n\ttest -z \"$user\" || echo username=$user\n\ttest -z \"$pass\" || echo password=$pass\n\tEOF\n\n\tPATH=\"$PWD:$PATH\"\n'\n\ntest_expect_success 'credential_fill invokes helper' '\n\tcheck fill \"verbatim foo bar\" <<-\\EOF\n\t--\n\tusername=foo\n\tpassword=bar\n\t--\n\tverbatim: get\n\tEOF\n'\n\ntest_expect_success 'credential_fill invokes multiple helpers' '\n\tcheck fill useless \"verbatim foo bar\" <<-\\EOF\n\t--\n\tusername=foo\n\tpassword=bar\n\t--\n\tuseless: get\n\tverbatim: get\n\tEOF\n'\n\ntest_expect_success 'credential_fill stops when we get a full response' '\n\tcheck fill \"verbatim one two\" \"verbatim three four\" <<-\\EOF\n\t--\n\tusername=one\n\tpassword=two\n\t--\n\tverbatim: get\n\tEOF\n'\n\ntest_expect_success 'credential_fill continues through partial response' '\n\tcheck fill \"verbatim one \\\"\\\"\" \"verbatim two three\" <<-\\EOF\n\t--\n\tusername=two\n\tpassword=three\n\t--\n\tverbatim: get\n\tverbatim: get\n\tverbatim: username=one\n\tEOF\n'\n\ntest_expect_success 'credential_fill passes along metadata' '\n\tcheck fill \"verbatim one two\" <<-\\EOF\n\tprotocol=ftp\n\thost=example.com\n\tpath=foo.git\n\t--\n\tprotocol=ftp\n\thost=example.com\n\tpath=foo.git\n\tusername=one\n\tpassword=two\n\t--\n\tverbatim: get\n\tverbatim: protocol=ftp\n\tverbatim: host=example.com\n\tverbatim: path=foo.git\n\tEOF\n'\n\ntest_expect_success 'credential_approve calls all helpers' '\n\tcheck approve useless \"verbatim one two\" <<-\\EOF\n\tusername=foo\n\tpassword=bar\n\t--\n\t--\n\tuseless: store\n\tuseless: username=foo\n\tuseless: password=bar\n\tverbatim: store\n\tverbatim: username=foo\n\tverbatim: password=bar\n\tEOF\n'\n\ntest_expect_success 'do not bother storing password-less credential' '\n\tcheck approve useless <<-\\EOF\n\tusername=foo\n\t--\n\t--\n\tEOF\n'\n\n\ntest_expect_success 'credential_reject calls all helpers' '\n\tcheck reject useless \"verbatim one two\" <<-\\EOF\n\tusername=foo\n\tpassword=bar\n\t--\n\t--\n\tuseless: erase\n\tuseless: username=foo\n\tuseless: password=bar\n\tverbatim: erase\n\tverbatim: username=foo\n\tverbatim: password=bar\n\tEOF\n'\n\ntest_expect_success 'usernames can be preserved' '\n\tcheck fill \"verbatim \\\"\\\" three\" <<-\\EOF\n\tusername=one\n\t--\n\tusername=one\n\tpassword=three\n\t--\n\tverbatim: get\n\tverbatim: username=one\n\tEOF\n'\n\ntest_expect_success 'usernames can be overridden' '\n\tcheck fill \"verbatim two three\" <<-\\EOF\n\tusername=one\n\t--\n\tusername=two\n\tpassword=three\n\t--\n\tverbatim: get\n\tverbatim: username=one\n\tEOF\n'\n\ntest_expect_success 'do not bother completing already-full credential' '\n\tcheck fill \"verbatim three four\" <<-\\EOF\n\tusername=one\n\tpassword=two\n\t--\n\tusername=one\n\tpassword=two\n\t--\n\tEOF\n'\n\n# We can't test the basic terminal password prompt here because\n# getpass() tries too hard to find the real terminal. But if our\n# askpass helper is run, we know the internal getpass is working.\ntest_expect_success 'empty helper list falls back to internal getpass' '\n\tcheck fill <<-\\EOF\n\t--\n\tusername=askpass-username\n\tpassword=askpass-password\n\t--\n\taskpass: Username:\n\taskpass: Password:\n\tEOF\n'\n\ntest_expect_success 'internal getpass does not ask for known username' '\n\tcheck fill <<-\\EOF\n\tusername=foo\n\t--\n\tusername=foo\n\tpassword=askpass-password\n\t--\n\taskpass: Password:\n\tEOF\n'\n\nHELPER=\"!f() {\n\t\tcat >/dev/null\n\t\techo username=foo\n\t\techo password=bar\n\t}; f\"\ntest_expect_success 'respect configured credentials' '\n\ttest_config credential.helper \"$HELPER\" &&\n\tcheck fill <<-\\EOF\n\t--\n\tusername=foo\n\tpassword=bar\n\t--\n\tEOF\n'\n\ntest_expect_success 'match configured credential' '\n\ttest_config credential.https://example.com.helper \"$HELPER\" &&\n\tcheck fill <<-\\EOF\n\tprotocol=https\n\thost=example.com\n\tpath=repo.git\n\t--\n\tprotocol=https\n\thost=example.com\n\tusername=foo\n\tpassword=bar\n\t--\n\tEOF\n'\n\ntest_expect_success 'do not match configured credential' '\n\ttest_config credential.https://foo.helper \"$HELPER\" &&\n\tcheck fill <<-\\EOF\n\tprotocol=https\n\thost=bar\n\t--\n\tprotocol=https\n\thost=bar\n\tusername=askpass-username\n\tpassword=askpass-password\n\t--\n\taskpass: Username for '\\''https://bar'\\'':\n\taskpass: Password for '\\''https://askpass-username@bar'\\'':\n\tEOF\n'\n\ntest_expect_success 'pull username from config' '\n\ttest_config credential.https://example.com.username foo &&\n\tcheck fill <<-\\EOF\n\tprotocol=https\n\thost=example.com\n\t--\n\tprotocol=https\n\thost=example.com\n\tusername=foo\n\tpassword=askpass-password\n\t--\n\taskpass: Password for '\\''https://foo@example.com'\\'':\n\tEOF\n'\n\ntest_expect_success 'http paths can be part of context' '\n\tcheck fill \"verbatim foo bar\" <<-\\EOF &&\n\tprotocol=https\n\thost=example.com\n\tpath=foo.git\n\t--\n\tprotocol=https\n\thost=example.com\n\tusername=foo\n\tpassword=bar\n\t--\n\tverbatim: get\n\tverbatim: protocol=https\n\tverbatim: host=example.com\n\tEOF\n\ttest_config credential.https://example.com.useHttpPath true &&\n\tcheck fill \"verbatim foo bar\" <<-\\EOF\n\tprotocol=https\n\thost=example.com\n\tpath=foo.git\n\t--\n\tprotocol=https\n\thost=example.com\n\tpath=foo.git\n\tusername=foo\n\tpassword=bar\n\t--\n\tverbatim: get\n\tverbatim: protocol=https\n\tverbatim: host=example.com\n\tverbatim: path=foo.git\n\tEOF\n'\n\ntest_expect_success 'helpers can abort the process' '\n\ttest_must_fail git \\\n\t\t-c credential.helper=\"!f() { echo quit=1; }; f\" \\\n\t\t-c credential.helper=\"verbatim foo bar\" \\\n\t\tcredential fill >stdout &&\n\t>expect &&\n\ttest_cmp expect stdout\n'\n\ntest_expect_success 'empty helper spec resets helper list' '\n\ttest_config credential.helper \"verbatim file file\" &&\n\tcheck fill \"\" \"verbatim cmdline cmdline\" <<-\\EOF\n\t--\n\tusername=cmdline\n\tpassword=cmdline\n\t--\n\tverbatim: get\n\tEOF\n'\n\ntest_done\n"], "fixing_code": ["#include \"cache.h\"\n#include \"config.h\"\n#include \"credential.h\"\n#include \"string-list.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n#include \"prompt.h\"\n\nvoid credential_init(struct credential *c)\n{\n\tmemset(c, 0, sizeof(*c));\n\tc->helpers.strdup_strings = 1;\n}\n\nvoid credential_clear(struct credential *c)\n{\n\tfree(c->protocol);\n\tfree(c->host);\n\tfree(c->path);\n\tfree(c->username);\n\tfree(c->password);\n\tstring_list_clear(&c->helpers, 0);\n\n\tcredential_init(c);\n}\n\nint credential_match(const struct credential *want,\n\t\t     const struct credential *have)\n{\n#define CHECK(x) (!want->x || (have->x && !strcmp(want->x, have->x)))\n\treturn CHECK(protocol) &&\n\t       CHECK(host) &&\n\t       CHECK(path) &&\n\t       CHECK(username);\n#undef CHECK\n}\n\nstatic int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key, *dot;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tdot = strrchr(key, '.');\n\tif (dot) {\n\t\tstruct credential want = CREDENTIAL_INIT;\n\t\tchar *url = xmemdupz(key, dot - key);\n\t\tint matched;\n\n\t\tcredential_from_url(&want, url);\n\t\tmatched = credential_match(&want, c);\n\n\t\tcredential_clear(&want);\n\t\tfree(url);\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t\tkey = dot + 1;\n\t}\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username)\n\t\t\tc->username = xstrdup(value);\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}\n\nstatic int proto_is_http(const char *s)\n{\n\tif (!s)\n\t\treturn 0;\n\treturn !strcmp(s, \"https\") || !strcmp(s, \"http\");\n}\n\nstatic void credential_apply_config(struct credential *c)\n{\n\tif (c->configured)\n\t\treturn;\n\tgit_config(credential_config_callback, c);\n\tc->configured = 1;\n\n\tif (!c->use_http_path && proto_is_http(c->protocol)) {\n\t\tFREE_AND_NULL(c->path);\n\t}\n}\n\nstatic void credential_describe(struct credential *c, struct strbuf *out)\n{\n\tif (!c->protocol)\n\t\treturn;\n\tstrbuf_addf(out, \"%s://\", c->protocol);\n\tif (c->username && *c->username)\n\t\tstrbuf_addf(out, \"%s@\", c->username);\n\tif (c->host)\n\t\tstrbuf_addstr(out, c->host);\n\tif (c->path)\n\t\tstrbuf_addf(out, \"/%s\", c->path);\n}\n\nstatic char *credential_ask_one(const char *what, struct credential *c,\n\t\t\t\tint flags)\n{\n\tstruct strbuf desc = STRBUF_INIT;\n\tstruct strbuf prompt = STRBUF_INIT;\n\tchar *r;\n\n\tcredential_describe(c, &desc);\n\tif (desc.len)\n\t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc.buf);\n\telse\n\t\tstrbuf_addf(&prompt, \"%s: \", what);\n\n\tr = git_prompt(prompt.buf, flags);\n\n\tstrbuf_release(&desc);\n\tstrbuf_release(&prompt);\n\treturn xstrdup(r);\n}\n\nstatic void credential_getpass(struct credential *c)\n{\n\tif (!c->username)\n\t\tc->username = credential_ask_one(\"Username\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS|PROMPT_ECHO);\n\tif (!c->password)\n\t\tc->password = credential_ask_one(\"Password\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS);\n}\n\nint credential_read(struct credential *c, FILE *fp)\n{\n\tstruct strbuf line = STRBUF_INIT;\n\n\twhile (strbuf_getline_lf(&line, fp) != EOF) {\n\t\tchar *key = line.buf;\n\t\tchar *value = strchr(key, '=');\n\n\t\tif (!line.len)\n\t\t\tbreak;\n\n\t\tif (!value) {\n\t\t\twarning(\"invalid credential line: %s\", key);\n\t\t\tstrbuf_release(&line);\n\t\t\treturn -1;\n\t\t}\n\t\t*value++ = '\\0';\n\n\t\tif (!strcmp(key, \"username\")) {\n\t\t\tfree(c->username);\n\t\t\tc->username = xstrdup(value);\n\t\t} else if (!strcmp(key, \"password\")) {\n\t\t\tfree(c->password);\n\t\t\tc->password = xstrdup(value);\n\t\t} else if (!strcmp(key, \"protocol\")) {\n\t\t\tfree(c->protocol);\n\t\t\tc->protocol = xstrdup(value);\n\t\t} else if (!strcmp(key, \"host\")) {\n\t\t\tfree(c->host);\n\t\t\tc->host = xstrdup(value);\n\t\t} else if (!strcmp(key, \"path\")) {\n\t\t\tfree(c->path);\n\t\t\tc->path = xstrdup(value);\n\t\t} else if (!strcmp(key, \"url\")) {\n\t\t\tcredential_from_url(c, value);\n\t\t} else if (!strcmp(key, \"quit\")) {\n\t\t\tc->quit = !!git_config_bool(\"quit\", value);\n\t\t}\n\t\t/*\n\t\t * Ignore other lines; we don't know what they mean, but\n\t\t * this future-proofs us when later versions of git do\n\t\t * learn new lines, and the helpers are updated to match.\n\t\t */\n\t}\n\n\tstrbuf_release(&line);\n\treturn 0;\n}\n\nstatic void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}\n\nvoid credential_write(const struct credential *c, FILE *fp)\n{\n\tcredential_write_item(fp, \"protocol\", c->protocol);\n\tcredential_write_item(fp, \"host\", c->host);\n\tcredential_write_item(fp, \"path\", c->path);\n\tcredential_write_item(fp, \"username\", c->username);\n\tcredential_write_item(fp, \"password\", c->password);\n}\n\nstatic int run_credential_helper(struct credential *c,\n\t\t\t\t const char *cmd,\n\t\t\t\t int want_output)\n{\n\tstruct child_process helper = CHILD_PROCESS_INIT;\n\tconst char *argv[] = { NULL, NULL };\n\tFILE *fp;\n\n\targv[0] = cmd;\n\thelper.argv = argv;\n\thelper.use_shell = 1;\n\thelper.in = -1;\n\tif (want_output)\n\t\thelper.out = -1;\n\telse\n\t\thelper.no_stdout = 1;\n\n\tif (start_command(&helper) < 0)\n\t\treturn -1;\n\n\tfp = xfdopen(helper.in, \"w\");\n\tcredential_write(c, fp);\n\tfclose(fp);\n\n\tif (want_output) {\n\t\tint r;\n\t\tfp = xfdopen(helper.out, \"r\");\n\t\tr = credential_read(c, fp);\n\t\tfclose(fp);\n\t\tif (r < 0) {\n\t\t\tfinish_command(&helper);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (finish_command(&helper))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int credential_do(struct credential *c, const char *helper,\n\t\t\t const char *operation)\n{\n\tstruct strbuf cmd = STRBUF_INIT;\n\tint r;\n\n\tif (helper[0] == '!')\n\t\tstrbuf_addstr(&cmd, helper + 1);\n\telse if (is_absolute_path(helper))\n\t\tstrbuf_addstr(&cmd, helper);\n\telse\n\t\tstrbuf_addf(&cmd, \"git credential-%s\", helper);\n\n\tstrbuf_addf(&cmd, \" %s\", operation);\n\tr = run_credential_helper(c, cmd.buf, !strcmp(operation, \"get\"));\n\n\tstrbuf_release(&cmd);\n\treturn r;\n}\n\nvoid credential_fill(struct credential *c)\n{\n\tint i;\n\n\tif (c->username && c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++) {\n\t\tcredential_do(c, c->helpers.items[i].string, \"get\");\n\t\tif (c->username && c->password)\n\t\t\treturn;\n\t\tif (c->quit)\n\t\t\tdie(\"credential helper '%s' told us to quit\",\n\t\t\t    c->helpers.items[i].string);\n\t}\n\n\tcredential_getpass(c);\n\tif (!c->username && !c->password)\n\t\tdie(\"unable to get password from user\");\n}\n\nvoid credential_approve(struct credential *c)\n{\n\tint i;\n\n\tif (c->approved)\n\t\treturn;\n\tif (!c->username || !c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"store\");\n\tc->approved = 1;\n}\n\nvoid credential_reject(struct credential *c)\n{\n\tint i;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"erase\");\n\n\tFREE_AND_NULL(c->username);\n\tFREE_AND_NULL(c->password);\n\tc->approved = 0;\n}\n\nvoid credential_from_url(struct credential *c, const char *url)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end)\n\t\treturn;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tif (slash - host > 0)\n\t\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n}\n", "#!/bin/sh\n\ntest_description='basic credential helper tests'\n. ./test-lib.sh\n. \"$TEST_DIRECTORY\"/lib-credential.sh\n\ntest_expect_success 'setup helper scripts' '\n\tcat >dump <<-\\EOF &&\n\twhoami=$(echo $0 | sed s/.*git-credential-//)\n\techo >&2 \"$whoami: $*\"\n\tOIFS=$IFS\n\tIFS==\n\twhile read key value; do\n\t\techo >&2 \"$whoami: $key=$value\"\n\t\teval \"$key=$value\"\n\tdone\n\tIFS=$OIFS\n\tEOF\n\n\twrite_script git-credential-useless <<-\\EOF &&\n\t. ./dump\n\texit 0\n\tEOF\n\n\twrite_script git-credential-verbatim <<-\\EOF &&\n\tuser=$1; shift\n\tpass=$1; shift\n\t. ./dump\n\ttest -z \"$user\" || echo username=$user\n\ttest -z \"$pass\" || echo password=$pass\n\tEOF\n\n\tPATH=\"$PWD:$PATH\"\n'\n\ntest_expect_success 'credential_fill invokes helper' '\n\tcheck fill \"verbatim foo bar\" <<-\\EOF\n\t--\n\tusername=foo\n\tpassword=bar\n\t--\n\tverbatim: get\n\tEOF\n'\n\ntest_expect_success 'credential_fill invokes multiple helpers' '\n\tcheck fill useless \"verbatim foo bar\" <<-\\EOF\n\t--\n\tusername=foo\n\tpassword=bar\n\t--\n\tuseless: get\n\tverbatim: get\n\tEOF\n'\n\ntest_expect_success 'credential_fill stops when we get a full response' '\n\tcheck fill \"verbatim one two\" \"verbatim three four\" <<-\\EOF\n\t--\n\tusername=one\n\tpassword=two\n\t--\n\tverbatim: get\n\tEOF\n'\n\ntest_expect_success 'credential_fill continues through partial response' '\n\tcheck fill \"verbatim one \\\"\\\"\" \"verbatim two three\" <<-\\EOF\n\t--\n\tusername=two\n\tpassword=three\n\t--\n\tverbatim: get\n\tverbatim: get\n\tverbatim: username=one\n\tEOF\n'\n\ntest_expect_success 'credential_fill passes along metadata' '\n\tcheck fill \"verbatim one two\" <<-\\EOF\n\tprotocol=ftp\n\thost=example.com\n\tpath=foo.git\n\t--\n\tprotocol=ftp\n\thost=example.com\n\tpath=foo.git\n\tusername=one\n\tpassword=two\n\t--\n\tverbatim: get\n\tverbatim: protocol=ftp\n\tverbatim: host=example.com\n\tverbatim: path=foo.git\n\tEOF\n'\n\ntest_expect_success 'credential_approve calls all helpers' '\n\tcheck approve useless \"verbatim one two\" <<-\\EOF\n\tusername=foo\n\tpassword=bar\n\t--\n\t--\n\tuseless: store\n\tuseless: username=foo\n\tuseless: password=bar\n\tverbatim: store\n\tverbatim: username=foo\n\tverbatim: password=bar\n\tEOF\n'\n\ntest_expect_success 'do not bother storing password-less credential' '\n\tcheck approve useless <<-\\EOF\n\tusername=foo\n\t--\n\t--\n\tEOF\n'\n\n\ntest_expect_success 'credential_reject calls all helpers' '\n\tcheck reject useless \"verbatim one two\" <<-\\EOF\n\tusername=foo\n\tpassword=bar\n\t--\n\t--\n\tuseless: erase\n\tuseless: username=foo\n\tuseless: password=bar\n\tverbatim: erase\n\tverbatim: username=foo\n\tverbatim: password=bar\n\tEOF\n'\n\ntest_expect_success 'usernames can be preserved' '\n\tcheck fill \"verbatim \\\"\\\" three\" <<-\\EOF\n\tusername=one\n\t--\n\tusername=one\n\tpassword=three\n\t--\n\tverbatim: get\n\tverbatim: username=one\n\tEOF\n'\n\ntest_expect_success 'usernames can be overridden' '\n\tcheck fill \"verbatim two three\" <<-\\EOF\n\tusername=one\n\t--\n\tusername=two\n\tpassword=three\n\t--\n\tverbatim: get\n\tverbatim: username=one\n\tEOF\n'\n\ntest_expect_success 'do not bother completing already-full credential' '\n\tcheck fill \"verbatim three four\" <<-\\EOF\n\tusername=one\n\tpassword=two\n\t--\n\tusername=one\n\tpassword=two\n\t--\n\tEOF\n'\n\n# We can't test the basic terminal password prompt here because\n# getpass() tries too hard to find the real terminal. But if our\n# askpass helper is run, we know the internal getpass is working.\ntest_expect_success 'empty helper list falls back to internal getpass' '\n\tcheck fill <<-\\EOF\n\t--\n\tusername=askpass-username\n\tpassword=askpass-password\n\t--\n\taskpass: Username:\n\taskpass: Password:\n\tEOF\n'\n\ntest_expect_success 'internal getpass does not ask for known username' '\n\tcheck fill <<-\\EOF\n\tusername=foo\n\t--\n\tusername=foo\n\tpassword=askpass-password\n\t--\n\taskpass: Password:\n\tEOF\n'\n\nHELPER=\"!f() {\n\t\tcat >/dev/null\n\t\techo username=foo\n\t\techo password=bar\n\t}; f\"\ntest_expect_success 'respect configured credentials' '\n\ttest_config credential.helper \"$HELPER\" &&\n\tcheck fill <<-\\EOF\n\t--\n\tusername=foo\n\tpassword=bar\n\t--\n\tEOF\n'\n\ntest_expect_success 'match configured credential' '\n\ttest_config credential.https://example.com.helper \"$HELPER\" &&\n\tcheck fill <<-\\EOF\n\tprotocol=https\n\thost=example.com\n\tpath=repo.git\n\t--\n\tprotocol=https\n\thost=example.com\n\tusername=foo\n\tpassword=bar\n\t--\n\tEOF\n'\n\ntest_expect_success 'do not match configured credential' '\n\ttest_config credential.https://foo.helper \"$HELPER\" &&\n\tcheck fill <<-\\EOF\n\tprotocol=https\n\thost=bar\n\t--\n\tprotocol=https\n\thost=bar\n\tusername=askpass-username\n\tpassword=askpass-password\n\t--\n\taskpass: Username for '\\''https://bar'\\'':\n\taskpass: Password for '\\''https://askpass-username@bar'\\'':\n\tEOF\n'\n\ntest_expect_success 'pull username from config' '\n\ttest_config credential.https://example.com.username foo &&\n\tcheck fill <<-\\EOF\n\tprotocol=https\n\thost=example.com\n\t--\n\tprotocol=https\n\thost=example.com\n\tusername=foo\n\tpassword=askpass-password\n\t--\n\taskpass: Password for '\\''https://foo@example.com'\\'':\n\tEOF\n'\n\ntest_expect_success 'http paths can be part of context' '\n\tcheck fill \"verbatim foo bar\" <<-\\EOF &&\n\tprotocol=https\n\thost=example.com\n\tpath=foo.git\n\t--\n\tprotocol=https\n\thost=example.com\n\tusername=foo\n\tpassword=bar\n\t--\n\tverbatim: get\n\tverbatim: protocol=https\n\tverbatim: host=example.com\n\tEOF\n\ttest_config credential.https://example.com.useHttpPath true &&\n\tcheck fill \"verbatim foo bar\" <<-\\EOF\n\tprotocol=https\n\thost=example.com\n\tpath=foo.git\n\t--\n\tprotocol=https\n\thost=example.com\n\tpath=foo.git\n\tusername=foo\n\tpassword=bar\n\t--\n\tverbatim: get\n\tverbatim: protocol=https\n\tverbatim: host=example.com\n\tverbatim: path=foo.git\n\tEOF\n'\n\ntest_expect_success 'helpers can abort the process' '\n\ttest_must_fail git \\\n\t\t-c credential.helper=\"!f() { echo quit=1; }; f\" \\\n\t\t-c credential.helper=\"verbatim foo bar\" \\\n\t\tcredential fill >stdout &&\n\t>expect &&\n\ttest_cmp expect stdout\n'\n\ntest_expect_success 'empty helper spec resets helper list' '\n\ttest_config credential.helper \"verbatim file file\" &&\n\tcheck fill \"\" \"verbatim cmdline cmdline\" <<-\\EOF\n\t--\n\tusername=cmdline\n\tpassword=cmdline\n\t--\n\tverbatim: get\n\tEOF\n'\n\ntest_expect_success 'url parser rejects embedded newlines' '\n\ttest_must_fail git credential fill <<-\\EOF\n\turl=https://one.example.com?%0ahost=two.example.com/\n\tEOF\n'\n\ntest_done\n"], "filenames": ["credential.c", "t/t0300-credentials.sh"], "buggy_code_start_loc": [196, 311], "buggy_code_end_loc": [196, 311], "fixing_code_start_loc": [197, 312], "fixing_code_end_loc": [199, 318], "type": "CWE-522", "message": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that contain an encoded newline can inject unintended values into the credential helper protocol stream, causing the credential helper to retrieve the password for one server (e.g., good.example.com) for an HTTP request being made to another server (e.g., evil.example.com), resulting in credentials for the former being sent to the latter. There are no restrictions on the relationship between the two, meaning that an attacker can craft a URL that will present stored credentials for any host to a host of their choosing. The vulnerability can be triggered by feeding a malicious URL to git clone. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The problem has been patched in the versions published on April 14th, 2020, going back to v2.17.x. Anyone wishing to backport the change further can do so by applying commit 9a6bbee (the full release includes extra checks for git fsck, but that commit is sufficient to protect clients against the vulnerability). The patched versions are: 2.17.4, 2.18.3, 2.19.4, 2.20.3, 2.21.2, 2.22.3, 2.23.2, 2.24.2, 2.25.3, 2.26.1.", "other": {"cve": {"id": "CVE-2020-5260", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-14T23:15:12.607", "lastModified": "2021-03-19T18:21:21.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that contain an encoded newline can inject unintended values into the credential helper protocol stream, causing the credential helper to retrieve the password for one server (e.g., good.example.com) for an HTTP request being made to another server (e.g., evil.example.com), resulting in credentials for the former being sent to the latter. There are no restrictions on the relationship between the two, meaning that an attacker can craft a URL that will present stored credentials for any host to a host of their choosing. The vulnerability can be triggered by feeding a malicious URL to git clone. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The problem has been patched in the versions published on April 14th, 2020, going back to v2.17.x. Anyone wishing to backport the change further can do so by applying commit 9a6bbee (the full release includes extra checks for git fsck, but that commit is sufficient to protect clients against the vulnerability). The patched versions are: 2.17.4, 2.18.3, 2.19.4, 2.20.3, 2.21.2, 2.22.3, 2.23.2, 2.24.2, 2.25.3, 2.26.1."}, {"lang": "es", "value": "Las versiones afectadas de Git presentan una vulnerabilidad por la cual Git puede ser enga\u00f1ado para enviar credenciales privadas a un host controlado por un atacante. Git usa programas externos de \"credential helper\" para almacenar y recuperar contrase\u00f1as u otras credenciales del almacenamiento seguro provistas por el sistema operativo. Las URL especialmente dise\u00f1adas que contienen una nueva l\u00ednea codificada pueden inyectar valores no deseados en la secuencia del protocolo credential helper, causando que el asistente de credenciales recupere la contrase\u00f1a de un servidor (por ejemplo, good.example.com) para una petici\u00f3n HTTP que se lleva a cabo en otro servidor ( por ejemplo, evil.example.com), resultando en que las credenciales para el primero se env\u00eden al segundo. No existen restricciones en la relaci\u00f3n entre los dos, lo que significa que un atacante puede crear una URL que presente credenciales almacenadas para cualquier host a un host de su elecci\u00f3n. La vulnerabilidad puede ser activada alimentando una URL maliciosa a git clone. Sin embargo, las URL afectadas lucen bastante sospechosas; el vector probable ser\u00eda por medio de sistemas que clonan autom\u00e1ticamente las URL no visibles para el usuario, como subm\u00f3dulos de Git o sistemas de paquetes creados alrededor de Git. El problema se ha corregido en las versiones publicadas el 14 de abril de 2020, que se remontan a las versiones v2.17.x. Cualquiera que desee respaldar el cambio a\u00fan m\u00e1s puede hacerlo aplicando el commit 9a6bbee (la versi\u00f3n completa incluye comprobaciones adicionales para git fsck, pero ese commit es suficiente para proteger a los clientes contra la vulnerabilidad). Las versiones parcheadas son: 2.17.4, 2.18.3, 2.19.4, 2.20.3, 2.21.2, 2.22.3, 2.23.2, 2.24.2, 2.25.3, 2.26.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git:git:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.17.4", "matchCriteriaId": "6FA998D4-C2C4-44EE-901D-CF5936D7D1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.22.0", "versionEndExcluding": "2.22.3", "matchCriteriaId": "B14A2B17-C2F7-4DB6-8CC1-B77C4FF9ACD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.18.0", "versionEndExcluding": "2.18.3", "matchCriteriaId": "E405970A-87F9-4EE3-A039-50B150ADAD85"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.19.0", "versionEndExcluding": "2.19.4", "matchCriteriaId": "40D4CABA-6F48-49AD-96A4-E036EAB3177A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.20.0", "versionEndExcluding": "2.20.3", "matchCriteriaId": "0655FC8A-0AB5-4148-A97F-8673C2741D81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.21.0", "versionEndExcluding": "2.21.2", "matchCriteriaId": "038B2F58-867C-4D3D-9DB8-AE2481285786"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.23.0", "versionEndExcluding": "2.23.2", "matchCriteriaId": "51FB16E7-BC48-4333-85FF-335318B987CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.24.0", "versionEndExcluding": "2.24.2", "matchCriteriaId": "8AF1F1BC-33E7-4E0E-8BBB-159D91724133"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.25.0", "versionEndExcluding": "2.25.3", "matchCriteriaId": "DA825115-AFF5-4F6A-AB80-ABF1540744B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.26.0", "versionEndExcluding": "2.26.1", "matchCriteriaId": "D3219B2B-172D-4DAF-B345-6EDC0330CC8F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00027.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00003.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/157250/Git-Credential-Helper-Protocol-Newline-Injection.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/04/15/5", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/04/15/6", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/04/20/1", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/git/git/commit/9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/git/git/security/advisories/GHSA-qm7j-c969-7j4q", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/04/msg00010.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/74Q7WVJ6FKLIN62VS2JD2XCNWK5TNKOW/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7TVS5UG6JD3MYIGSBKMIOS6AF7CR5IPI/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MOCTR2SEHCPSCOVUQJAGFPGKFMI2VE6V/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PN3FUOXKX3AXTULYV53ACABER2W2FSOU/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XPCEOIFLLEF24L6GLVJVFZX4CREDEHDF/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lore.kernel.org/git/xmqqy2qy7xn8.fsf@gitster.c.googlers.com/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202004-13", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT211141", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4329-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4657", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b"}}