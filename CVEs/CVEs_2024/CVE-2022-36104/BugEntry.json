{"buggy_code": ["<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Error\\PageErrorHandler;\n\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse TYPO3\\CMS\\Core\\Cache\\CacheManager;\nuse TYPO3\\CMS\\Core\\Cache\\Frontend\\FrontendInterface;\nuse TYPO3\\CMS\\Core\\Configuration\\Features;\nuse TYPO3\\CMS\\Core\\Exception\\SiteNotFoundException;\nuse TYPO3\\CMS\\Core\\Http\\HtmlResponse;\nuse TYPO3\\CMS\\Core\\Http\\RequestFactory;\nuse TYPO3\\CMS\\Core\\Http\\Response;\nuse TYPO3\\CMS\\Core\\Http\\Stream;\nuse TYPO3\\CMS\\Core\\Http\\Uri;\nuse TYPO3\\CMS\\Core\\LinkHandling\\LinkService;\nuse TYPO3\\CMS\\Core\\Routing\\InvalidRouteArgumentsException;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\Site;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\SiteLanguage;\nuse TYPO3\\CMS\\Core\\Site\\SiteFinder;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Frontend\\Http\\Application;\n\n/**\n * Renders the content of a page to be displayed (also in relation to language etc)\n * This is typically configured via the \"Sites configuration\" module in the backend.\n */\nclass PageContentErrorHandler implements PageErrorHandlerInterface\n{\n    protected int $statusCode;\n\n    protected array $errorHandlerConfiguration;\n\n    protected int $pageUid = 0;\n\n    protected Application $application;\n\n    protected RequestFactory $requestFactory;\n\n    protected ResponseFactoryInterface $responseFactory;\n\n    protected SiteFinder $siteFinder;\n\n    protected LinkService $link;\n\n    protected FrontendInterface $cache;\n\n    protected bool $useSubrequest;\n\n    /**\n     * PageContentErrorHandler constructor.\n     * @param int $statusCode\n     * @param array $configuration\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(int $statusCode, array $configuration)\n    {\n        $this->statusCode = $statusCode;\n        if (empty($configuration['errorContentSource'])) {\n            throw new \\InvalidArgumentException('PageContentErrorHandler needs to have a proper link set.', 1522826413);\n        }\n        $this->errorHandlerConfiguration = $configuration;\n\n        // @todo Convert this to DI once this class can be injected properly.\n        $container = GeneralUtility::getContainer();\n        $this->application = $container->get(Application::class);\n        $this->requestFactory = $container->get(RequestFactory::class);\n        $this->responseFactory = $container->get(ResponseFactoryInterface::class);\n        $this->siteFinder = GeneralUtility::makeInstance(SiteFinder::class);\n        $this->link = $container->get(LinkService::class);\n        $this->cache = $container->get(CacheManager::class)->getCache('pages');\n        $this->useSubrequest = GeneralUtility::makeInstance(Features::class)->isFeatureEnabled('subrequestPageErrors');\n    }\n\n    public function handlePageError(ServerRequestInterface $request, string $message, array $reasons = []): ResponseInterface\n    {\n        try {\n            $urlParams = $this->link->resolve($this->errorHandlerConfiguration['errorContentSource']);\n            $urlParams['pageuid'] = (int)($urlParams['pageuid'] ?? 0);\n            $resolvedUrl = $this->resolveUrl($request, $urlParams);\n\n            if ($this->useSubrequest) {\n                // Create a subrequest and do not take any special query parameters into account\n                $subRequest = $request->withQueryParams([])->withUri(new Uri($resolvedUrl))->withMethod('GET');\n                $subResponse = $this->stashEnvironment(fn (): ResponseInterface => $this->sendSubRequest($subRequest, $urlParams['pageuid']));\n            } else {\n                try {\n                    $subResponse = $this->cachePageRequest($resolvedUrl, $this->pageUid, fn () => $this->sendRawRequest($resolvedUrl));\n                } catch (\\Exception $e) {\n                    throw new \\RuntimeException(sprintf('Error handler could not fetch error page \"%s\", reason: %s', $resolvedUrl, $e->getMessage()), 1544172838, $e);\n                }\n            }\n\n            if ($subResponse->getStatusCode() >= 300) {\n                throw new \\RuntimeException(sprintf('Error handler could not fetch error page \"%s\", status code: %s', $resolvedUrl, $subResponse->getStatusCode()), 1544172839);\n            }\n\n            return $this->responseFactory->createResponse($this->statusCode)\n                ->withHeader('content-type', $subResponse->getHeader('content-type'))\n                ->withBody($subResponse->getBody());\n        } catch (InvalidRouteArgumentsException | SiteNotFoundException $e) {\n            return new HtmlResponse('Invalid error handler configuration: ' . $this->errorHandlerConfiguration['errorContentSource']);\n        }\n    }\n\n    /**\n     * Stash and restore portions of the global environment around a subreqest callable.\n     */\n    protected function stashEnvironment(callable $fetcher): ResponseInterface\n    {\n        $parkedTsfe = $GLOBALS['TSFE'] ?? null;\n        $GLOBALS['TSFE'] = null;\n\n        $result = $fetcher();\n\n        $GLOBALS['TSFE'] = $parkedTsfe;\n\n        return $result;\n    }\n\n    /**\n     * Caches a subrequest fetch.\n     */\n    protected function cachePageRequest(string $resolvedUrl, int $pageId, callable $fetcher): ResponseInterface\n    {\n        $cacheIdentifier = 'errorPage_' . md5($resolvedUrl);\n        $responseData = $this->cache->get($cacheIdentifier);\n\n        if (!is_array($responseData)) {\n            /** @var ResponseInterface $response */\n            $response = $fetcher();\n            $cacheTags = [];\n            if ($response->getStatusCode() === 200) {\n                $cacheTags[] = 'errorPage';\n                if ($pageId > 0) {\n                    // Cache Tag \"pageId_\" ensures, cache is purged when content of 404 page changes\n                    $cacheTags[] = 'pageId_' . $pageId;\n                }\n                $responseData = [\n                    'headers' => $response->getHeaders(),\n                    'body' => $response->getBody()->getContents(),\n                    'reasonPhrase' => $response->getReasonPhrase(),\n                ];\n                $this->cache->set($cacheIdentifier, $responseData, $cacheTags);\n            }\n        } else {\n            $body = new Stream('php://temp', 'wb+');\n            $body->write($responseData['body'] ?? '');\n            $body->rewind();\n            $response = new Response(\n                $body,\n                200,\n                $responseData['headers'] ?? [],\n                $responseData['reasonPhrase'] ?? ''\n            );\n        }\n\n        return $response;\n    }\n\n    /**\n     * Sends a full HTTP request to the specified URL.\n     */\n    protected function sendRawRequest(string $resolvedUrl): ResponseInterface\n    {\n        return $this->requestFactory->request($resolvedUrl, 'GET', $this->getSubRequestOptions());\n    }\n\n    /**\n     * Sends an in-process subrequest.\n     *\n     * The $pageId is used to ensure the correct site is accessed.\n     */\n    protected function sendSubRequest(ServerRequestInterface $request, int $pageId): ResponseInterface\n    {\n        $site = $request->getAttribute('site', null);\n        if (!$site instanceof Site) {\n            $site = $this->siteFinder->getSiteByPageId($pageId);\n            $request = $request->withAttribute('site', $site);\n        }\n\n        return $this->application->handle($request);\n    }\n\n    /**\n     * Returns request options for the subrequest\n     *\n     * @return array|int[]\n     */\n    protected function getSubRequestOptions(): array\n    {\n        $options = [];\n        if ((int)$GLOBALS['TYPO3_CONF_VARS']['HTTP']['timeout'] === 0) {\n            $options = [\n                'timeout' => 30,\n            ];\n        }\n        return $options;\n    }\n\n    /**\n     * Resolve the URL (currently only page and external URL are supported)\n     */\n    protected function resolveUrl(ServerRequestInterface $request, array $urlParams): string\n    {\n        if (!in_array($urlParams['type'], ['page', 'url'])) {\n            throw new \\InvalidArgumentException('PageContentErrorHandler can only handle TYPO3 urls of types \"page\" or \"url\"', 1522826609);\n        }\n        if ($urlParams['type'] === 'url') {\n            return $urlParams['url'];\n        }\n\n        // Get the site related to the configured error page\n        $site = $this->siteFinder->getSiteByPageId($urlParams['pageuid']);\n        // Fall back to current request for the site\n        if (!$site instanceof Site) {\n            $site = $request->getAttribute('site', null);\n        }\n        /** @var SiteLanguage $requestLanguage */\n        $requestLanguage = $request->getAttribute('language', null);\n        // Try to get the current request language from the site that was found above\n        if ($requestLanguage instanceof SiteLanguage && $requestLanguage->isEnabled()) {\n            try {\n                $language = $site->getLanguageById($requestLanguage->getLanguageId());\n            } catch (\\InvalidArgumentException $e) {\n                $language = $site->getDefaultLanguage();\n            }\n        } else {\n            $language = $site->getDefaultLanguage();\n        }\n\n        // Build Url\n        $uri = $site->getRouter()->generateUri(\n            (int)$urlParams['pageuid'],\n            ['_language' => $language]\n        );\n\n        // Fallback to the current URL if the site is not having a proper scheme and host\n        $currentUri = $request->getUri();\n        if (empty($uri->getScheme())) {\n            $uri = $uri->withScheme($currentUri->getScheme());\n        }\n        if (empty($uri->getUserInfo())) {\n            $uri = $uri->withUserInfo($currentUri->getUserInfo());\n        }\n        if (empty($uri->getHost())) {\n            $uri = $uri->withHost($currentUri->getHost());\n        }\n        if ($uri->getPort() === null) {\n            $uri = $uri->withPort($currentUri->getPort());\n        }\n\n        return (string)$uri;\n    }\n}\n"], "fixing_code": ["<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Error\\PageErrorHandler;\n\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse TYPO3\\CMS\\Core\\Cache\\CacheManager;\nuse TYPO3\\CMS\\Core\\Cache\\Frontend\\FrontendInterface;\nuse TYPO3\\CMS\\Core\\Configuration\\Features;\nuse TYPO3\\CMS\\Core\\Exception\\SiteNotFoundException;\nuse TYPO3\\CMS\\Core\\Http\\HtmlResponse;\nuse TYPO3\\CMS\\Core\\Http\\RequestFactory;\nuse TYPO3\\CMS\\Core\\Http\\Response;\nuse TYPO3\\CMS\\Core\\Http\\Stream;\nuse TYPO3\\CMS\\Core\\Http\\Uri;\nuse TYPO3\\CMS\\Core\\LinkHandling\\LinkService;\nuse TYPO3\\CMS\\Core\\Routing\\InvalidRouteArgumentsException;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\Site;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\SiteLanguage;\nuse TYPO3\\CMS\\Core\\Site\\SiteFinder;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Frontend\\Http\\Application;\n\n/**\n * Renders the content of a page to be displayed (also in relation to language etc)\n * This is typically configured via the \"Sites configuration\" module in the backend.\n */\nclass PageContentErrorHandler implements PageErrorHandlerInterface\n{\n    protected int $statusCode;\n\n    protected array $errorHandlerConfiguration;\n\n    protected int $pageUid = 0;\n\n    protected Application $application;\n\n    protected RequestFactory $requestFactory;\n\n    protected ResponseFactoryInterface $responseFactory;\n\n    protected SiteFinder $siteFinder;\n\n    protected LinkService $link;\n\n    protected FrontendInterface $cache;\n\n    protected bool $useSubrequest;\n\n    /**\n     * PageContentErrorHandler constructor.\n     * @param int $statusCode\n     * @param array $configuration\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(int $statusCode, array $configuration)\n    {\n        $this->statusCode = $statusCode;\n        if (empty($configuration['errorContentSource'])) {\n            throw new \\InvalidArgumentException('PageContentErrorHandler needs to have a proper link set.', 1522826413);\n        }\n        $this->errorHandlerConfiguration = $configuration;\n\n        // @todo Convert this to DI once this class can be injected properly.\n        $container = GeneralUtility::getContainer();\n        $this->application = $container->get(Application::class);\n        $this->requestFactory = $container->get(RequestFactory::class);\n        $this->responseFactory = $container->get(ResponseFactoryInterface::class);\n        $this->siteFinder = GeneralUtility::makeInstance(SiteFinder::class);\n        $this->link = $container->get(LinkService::class);\n        $this->cache = $container->get(CacheManager::class)->getCache('pages');\n        $this->useSubrequest = GeneralUtility::makeInstance(Features::class)->isFeatureEnabled('subrequestPageErrors');\n    }\n\n    public function handlePageError(ServerRequestInterface $request, string $message, array $reasons = []): ResponseInterface\n    {\n        try {\n            $urlParams = $this->link->resolve($this->errorHandlerConfiguration['errorContentSource']);\n            $urlParams['pageuid'] = (int)($urlParams['pageuid'] ?? 0);\n            $resolvedUrl = $this->resolveUrl($request, $urlParams);\n\n            // avoid denial-of-service amplification scenario\n            if ($resolvedUrl === (string)$request->getUri()) {\n                return new HtmlResponse(\n                    'The error page could not be resolved, as the error page itself is not accessible',\n                    $this->statusCode\n                );\n            }\n            if ($this->useSubrequest) {\n                // Create a subrequest and do not take any special query parameters into account\n                $subRequest = $request->withQueryParams([])->withUri(new Uri($resolvedUrl))->withMethod('GET');\n                $subResponse = $this->stashEnvironment(fn (): ResponseInterface => $this->sendSubRequest($subRequest, $urlParams['pageuid']));\n            } else {\n                try {\n                    $subResponse = $this->cachePageRequest($resolvedUrl, $this->pageUid, fn () => $this->sendRawRequest($resolvedUrl));\n                } catch (\\Exception $e) {\n                    throw new \\RuntimeException(sprintf('Error handler could not fetch error page \"%s\", reason: %s', $resolvedUrl, $e->getMessage()), 1544172838, $e);\n                }\n            }\n\n            if ($subResponse->getStatusCode() >= 300) {\n                throw new \\RuntimeException(sprintf('Error handler could not fetch error page \"%s\", status code: %s', $resolvedUrl, $subResponse->getStatusCode()), 1544172839);\n            }\n\n            return $this->responseFactory->createResponse($this->statusCode)\n                ->withHeader('content-type', $subResponse->getHeader('content-type'))\n                ->withBody($subResponse->getBody());\n        } catch (InvalidRouteArgumentsException | SiteNotFoundException $e) {\n            return new HtmlResponse('Invalid error handler configuration: ' . $this->errorHandlerConfiguration['errorContentSource']);\n        }\n    }\n\n    /**\n     * Stash and restore portions of the global environment around a subreqest callable.\n     */\n    protected function stashEnvironment(callable $fetcher): ResponseInterface\n    {\n        $parkedTsfe = $GLOBALS['TSFE'] ?? null;\n        $GLOBALS['TSFE'] = null;\n\n        $result = $fetcher();\n\n        $GLOBALS['TSFE'] = $parkedTsfe;\n\n        return $result;\n    }\n\n    /**\n     * Caches a subrequest fetch.\n     */\n    protected function cachePageRequest(string $resolvedUrl, int $pageId, callable $fetcher): ResponseInterface\n    {\n        $cacheIdentifier = 'errorPage_' . md5($resolvedUrl);\n        $responseData = $this->cache->get($cacheIdentifier);\n\n        if (!is_array($responseData)) {\n            /** @var ResponseInterface $response */\n            $response = $fetcher();\n            $cacheTags = [];\n            if ($response->getStatusCode() === 200) {\n                $cacheTags[] = 'errorPage';\n                if ($pageId > 0) {\n                    // Cache Tag \"pageId_\" ensures, cache is purged when content of 404 page changes\n                    $cacheTags[] = 'pageId_' . $pageId;\n                }\n                $responseData = [\n                    'headers' => $response->getHeaders(),\n                    'body' => $response->getBody()->getContents(),\n                    'reasonPhrase' => $response->getReasonPhrase(),\n                ];\n                $this->cache->set($cacheIdentifier, $responseData, $cacheTags);\n            }\n        } else {\n            $body = new Stream('php://temp', 'wb+');\n            $body->write($responseData['body'] ?? '');\n            $body->rewind();\n            $response = new Response(\n                $body,\n                200,\n                $responseData['headers'] ?? [],\n                $responseData['reasonPhrase'] ?? ''\n            );\n        }\n\n        return $response;\n    }\n\n    /**\n     * Sends a full HTTP request to the specified URL.\n     */\n    protected function sendRawRequest(string $resolvedUrl): ResponseInterface\n    {\n        return $this->requestFactory->request($resolvedUrl, 'GET', $this->getSubRequestOptions());\n    }\n\n    /**\n     * Sends an in-process subrequest.\n     *\n     * The $pageId is used to ensure the correct site is accessed.\n     */\n    protected function sendSubRequest(ServerRequestInterface $request, int $pageId): ResponseInterface\n    {\n        $site = $request->getAttribute('site', null);\n        if (!$site instanceof Site) {\n            $site = $this->siteFinder->getSiteByPageId($pageId);\n            $request = $request->withAttribute('site', $site);\n        }\n\n        return $this->application->handle($request);\n    }\n\n    /**\n     * Returns request options for the subrequest\n     *\n     * @return array|int[]\n     */\n    protected function getSubRequestOptions(): array\n    {\n        $options = [];\n        if ((int)$GLOBALS['TYPO3_CONF_VARS']['HTTP']['timeout'] === 0) {\n            $options = [\n                'timeout' => 30,\n            ];\n        }\n        return $options;\n    }\n\n    /**\n     * Resolve the URL (currently only page and external URL are supported)\n     */\n    protected function resolveUrl(ServerRequestInterface $request, array $urlParams): string\n    {\n        if (!in_array($urlParams['type'], ['page', 'url'])) {\n            throw new \\InvalidArgumentException('PageContentErrorHandler can only handle TYPO3 urls of types \"page\" or \"url\"', 1522826609);\n        }\n        if ($urlParams['type'] === 'url') {\n            return $urlParams['url'];\n        }\n\n        // Get the site related to the configured error page\n        $site = $this->siteFinder->getSiteByPageId($urlParams['pageuid']);\n        // Fall back to current request for the site\n        if (!$site instanceof Site) {\n            $site = $request->getAttribute('site', null);\n        }\n        /** @var SiteLanguage $requestLanguage */\n        $requestLanguage = $request->getAttribute('language', null);\n        // Try to get the current request language from the site that was found above\n        if ($requestLanguage instanceof SiteLanguage && $requestLanguage->isEnabled()) {\n            try {\n                $language = $site->getLanguageById($requestLanguage->getLanguageId());\n            } catch (\\InvalidArgumentException $e) {\n                $language = $site->getDefaultLanguage();\n            }\n        } else {\n            $language = $site->getDefaultLanguage();\n        }\n\n        // Build Url\n        $uri = $site->getRouter()->generateUri(\n            (int)$urlParams['pageuid'],\n            ['_language' => $language]\n        );\n\n        // Fallback to the current URL if the site is not having a proper scheme and host\n        $currentUri = $request->getUri();\n        if (empty($uri->getScheme())) {\n            $uri = $uri->withScheme($currentUri->getScheme());\n        }\n        if (empty($uri->getUserInfo())) {\n            $uri = $uri->withUserInfo($currentUri->getUserInfo());\n        }\n        if (empty($uri->getHost())) {\n            $uri = $uri->withHost($currentUri->getHost());\n        }\n        if ($uri->getPort() === null) {\n            $uri = $uri->withPort($currentUri->getPort());\n        }\n\n        return (string)$uri;\n    }\n}\n"], "filenames": ["typo3/sysext/core/Classes/Error/PageErrorHandler/PageContentErrorHandler.php"], "buggy_code_start_loc": [97], "buggy_code_end_loc": [97], "fixing_code_start_loc": [98], "fixing_code_end_loc": [105], "type": "CWE-770", "message": "TYPO3 is an open source PHP based web content management system released under the GNU GPL. In affected versions requesting invalid or non-existing resources via HTTP triggers the page error handler which again could retrieve content to be shown as an error message from another page. This leads to a scenario in which the application is calling itself recursively - amplifying the impact of the initial attack until the limits of the web server are exceeded. Users are advised to update to TYPO3 version 11.5.16 to resolve this issue. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-36104", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-13T18:15:14.703", "lastModified": "2022-09-16T13:11:57.760", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TYPO3 is an open source PHP based web content management system released under the GNU GPL. In affected versions requesting invalid or non-existing resources via HTTP triggers the page error handler which again could retrieve content to be shown as an error message from another page. This leads to a scenario in which the application is calling itself recursively - amplifying the impact of the initial attack until the limits of the web server are exceeded. Users are advised to update to TYPO3 version 11.5.16 to resolve this issue. There are no known workarounds for this issue."}, {"lang": "es", "value": "TYPO3 es un sistema de administraci\u00f3n de contenidos web de c\u00f3digo abierto basado en PHP y publicado bajo la licencia GNU GPL. En versiones afectadas, la petici\u00f3n de recursos no v\u00e1lidos o inexistentes por medio de HTTP desencadena el manejador de errores de la p\u00e1gina que, de nuevo, podr\u00eda recuperar el contenido para mostrarlo como un mensaje de error desde otra p\u00e1gina. Esto conlleva a un escenario en el que la aplicaci\u00f3n es llamado a si mismo de forma recursiva, amplificando el impacto del ataque inicial hasta que son superados los l\u00edmites del servidor web. Es recomendado a usuarios actualizar a TYPO3 versi\u00f3n 11.5.16 para resolver este problema. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.4.0", "versionEndIncluding": "11.5.15", "matchCriteriaId": "13B1EBA5-8D98-4595-93CB-03A0C3611DA1"}]}]}], "references": [{"url": "https://github.com/TYPO3/typo3/commit/179dd7cd78947081d573fee2050e197faa556f13", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TYPO3/typo3/security/advisories/GHSA-fffr-7x4x-f98q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-core-sa-2022-006", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/TYPO3/typo3/commit/179dd7cd78947081d573fee2050e197faa556f13"}}