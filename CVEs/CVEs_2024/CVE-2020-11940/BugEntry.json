{"buggy_code": ["/*\n * ssh.c\n *\n * Copyright (C) 2009-2011 by ipoque GmbH\n * Copyright (C) 2011-20 - ntop.org\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_SSH\n\n#include \"ndpi_api.h\"\n#include \"ndpi_md5.h\"\n\n/*\n  HASSH - https://github.com/salesforce/hassh\n\n  https://github.com/salesforce/hassh/blob/master/python/hassh.py\n\n  [server]\n  skex = packet.ssh.kex_algorithms\n  seastc = packet.ssh.encryption_algorithms_server_to_client\n  smastc = packet.ssh.mac_algorithms_server_to_client\n  scastc = packet.ssh.compression_algorithms_server_to_client\n  hasshs_str = ';'.join([skex, seastc, smastc, scastc]) \n\n  [client]\n  ckex = packet.ssh.kex_algorithms\n  ceacts = packet.ssh.encryption_algorithms_client_to_server\n  cmacts = packet.ssh.mac_algorithms_client_to_server\n  ccacts = packet.ssh.compression_algorithms_client_to_server\n  hassh_str = ';'.join([ckex, ceacts, cmacts, ccacts]) \n\n  NOTE\n  THe ECDSA key fingerprint is SHA256 -> ssh.kex.h_sig (wireshark)\n  is in the Message Code: Diffie-Hellman Key Exchange Reply (31) \n  that usually is packet 14\n*/\n\n/* #define SSH_DEBUG 1 */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow);\n  \n/* ************************************************************************ */\n\nstatic int search_ssh_again(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  ndpi_search_ssh_tcp(ndpi_struct, flow);\n\n  if((flow->protos.ssh.hassh_client[0] != '\\0')\n     && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n    /* stop extra processing */\n    flow->extra_packets_func = NULL; /* We're good now */\n    return(0);\n  }\n\n  /* Possibly more processing */\n  return(1);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_int_ssh_add_connection(struct ndpi_detection_module_struct\n\t\t\t\t\t*ndpi_struct, struct ndpi_flow_struct *flow) {\n  if(flow->extra_packets_func != NULL)\n    return;\n\n  flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n  \n  /* This is necessary to inform the core to call this dissector again */\n  flow->check_extra_packets = 1;\n  flow->max_extra_packets_to_check = 12;\n  flow->extra_packets_func = search_ssh_again;\n  \n  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_SSH, NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ************************************************************************ */\n\nstatic u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int16_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4 + len;\n\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_ssh_zap_cr(char *str, int len) {\n  len--;\n\n  while(len > 0) {\n    if((str[len] == '\\n') || (str[len] == '\\r')) {\n      str[len] = '\\0';\n      len--;\n    } else\n      break;\n  }\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s()\\n\", __FUNCTION__);\n#endif\n\n  if(flow->l4.tcp.ssh_stage == 0) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 100\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.client_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.client_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.client_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.client_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [client_signature: %s]\\n\", flow->protos.ssh.client_signature);\n#endif      \n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 0 passed\\n\");\n      flow->l4.tcp.ssh_stage = 1 + packet->packet_direction;\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n      return;\n    }\n  } else if(flow->l4.tcp.ssh_stage == (2 - packet->packet_direction)) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 500\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.server_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.server_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.server_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.server_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [server_signature: %s]\\n\", flow->protos.ssh.server_signature);\n#endif\n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 1 passed\\n\");\n      flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [completed stage: %u]\\n\", flow->l4.tcp.ssh_stage);\n#endif\n\n      flow->l4.tcp.ssh_stage = 3;\n      return;\n    }\n  } else if(packet->payload_packet_len > 5) {\n    u_int8_t msgcode = *(packet->payload + 5);\n    ndpi_MD5_CTX ctx;\n    \n    if(msgcode == 20 /* key exchange init */) {\n      char *hassh_buf = ndpi_calloc(packet->payload_packet_len, sizeof(char));\n      u_int i, len;\n\n#ifdef SSH_DEBUG\n      printf(\"[SSH] [stage: %u][msg: %u][direction: %u][key exchange init]\\n\", flow->l4.tcp.ssh_stage, msgcode, packet->packet_direction);\n#endif\n\n      if(hassh_buf) {\n\tif(packet->packet_direction == 0 /* client */) {\n\t  u_char fingerprint_client[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 1 /* client */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_client, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [client][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_client[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_client[i*2], \"%02X\", fingerprint_client[i] & 0xFF);\n\t  flow->protos.ssh.hassh_client[32] = '\\0';\n\t} else {\n\t  u_char fingerprint_server[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 0 /* server */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_server, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [server][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_server[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_server[i*2], \"%02X\", fingerprint_server[i] & 0xFF);\n\t  flow->protos.ssh.hassh_server[32] = '\\0';\n\t}\n\n\tndpi_free(hassh_buf);\n      }\n\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n    }\n\n    if((flow->protos.ssh.hassh_client[0] != '\\0') && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n#ifdef SSH_DEBUG\n      printf(\"[SSH] Dissection completed\\n\");\n#endif\n      flow->extra_packets_func = NULL; /* We're good now */\n    }\n\n    return;\n  }\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Excluding SSH\");\n#endif\n\n  NDPI_LOG_DBG(ndpi_struct, \"excluding ssh at stage %d\\n\", flow->l4.tcp.ssh_stage);\n  NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_SSH);\n}\n\n/* ************************************************************************ */\n\nvoid init_ssh_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)\n{\n  ndpi_set_bitmask_protocol_detection(\"SSH\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_SSH,\n\t\t\t\t      ndpi_search_ssh_tcp,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "fixing_code": ["/*\n * ssh.c\n *\n * Copyright (C) 2009-2011 by ipoque GmbH\n * Copyright (C) 2011-20 - ntop.org\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_SSH\n\n#include \"ndpi_api.h\"\n#include \"ndpi_md5.h\"\n\n/*\n  HASSH - https://github.com/salesforce/hassh\n\n  https://github.com/salesforce/hassh/blob/master/python/hassh.py\n\n  [server]\n  skex = packet.ssh.kex_algorithms\n  seastc = packet.ssh.encryption_algorithms_server_to_client\n  smastc = packet.ssh.mac_algorithms_server_to_client\n  scastc = packet.ssh.compression_algorithms_server_to_client\n  hasshs_str = ';'.join([skex, seastc, smastc, scastc]) \n\n  [client]\n  ckex = packet.ssh.kex_algorithms\n  ceacts = packet.ssh.encryption_algorithms_client_to_server\n  cmacts = packet.ssh.mac_algorithms_client_to_server\n  ccacts = packet.ssh.compression_algorithms_client_to_server\n  hassh_str = ';'.join([ckex, ceacts, cmacts, ccacts]) \n\n  NOTE\n  THe ECDSA key fingerprint is SHA256 -> ssh.kex.h_sig (wireshark)\n  is in the Message Code: Diffie-Hellman Key Exchange Reply (31) \n  that usually is packet 14\n*/\n\n/* #define SSH_DEBUG 1 */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow);\n  \n/* ************************************************************************ */\n\nstatic int search_ssh_again(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  ndpi_search_ssh_tcp(ndpi_struct, flow);\n\n  if((flow->protos.ssh.hassh_client[0] != '\\0')\n     && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n    /* stop extra processing */\n    flow->extra_packets_func = NULL; /* We're good now */\n    return(0);\n  }\n\n  /* Possibly more processing */\n  return(1);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_int_ssh_add_connection(struct ndpi_detection_module_struct\n\t\t\t\t\t*ndpi_struct, struct ndpi_flow_struct *flow) {\n  if(flow->extra_packets_func != NULL)\n    return;\n\n  flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n  \n  /* This is necessary to inform the core to call this dissector again */\n  flow->check_extra_packets = 1;\n  flow->max_extra_packets_to_check = 12;\n  flow->extra_packets_func = search_ssh_again;\n  \n  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_SSH, NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ************************************************************************ */\n\nstatic u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int16_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_ssh_zap_cr(char *str, int len) {\n  len--;\n\n  while(len > 0) {\n    if((str[len] == '\\n') || (str[len] == '\\r')) {\n      str[len] = '\\0';\n      len--;\n    } else\n      break;\n  }\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s()\\n\", __FUNCTION__);\n#endif\n\n  if(flow->l4.tcp.ssh_stage == 0) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 100\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.client_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.client_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.client_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.client_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [client_signature: %s]\\n\", flow->protos.ssh.client_signature);\n#endif      \n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 0 passed\\n\");\n      flow->l4.tcp.ssh_stage = 1 + packet->packet_direction;\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n      return;\n    }\n  } else if(flow->l4.tcp.ssh_stage == (2 - packet->packet_direction)) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 500\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.server_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.server_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.server_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.server_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [server_signature: %s]\\n\", flow->protos.ssh.server_signature);\n#endif\n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 1 passed\\n\");\n      flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [completed stage: %u]\\n\", flow->l4.tcp.ssh_stage);\n#endif\n\n      flow->l4.tcp.ssh_stage = 3;\n      return;\n    }\n  } else if(packet->payload_packet_len > 5) {\n    u_int8_t msgcode = *(packet->payload + 5);\n    ndpi_MD5_CTX ctx;\n    \n    if(msgcode == 20 /* key exchange init */) {\n      char *hassh_buf = ndpi_calloc(packet->payload_packet_len, sizeof(char));\n      u_int i, len;\n\n#ifdef SSH_DEBUG\n      printf(\"[SSH] [stage: %u][msg: %u][direction: %u][key exchange init]\\n\", flow->l4.tcp.ssh_stage, msgcode, packet->packet_direction);\n#endif\n\n      if(hassh_buf) {\n\tif(packet->packet_direction == 0 /* client */) {\n\t  u_char fingerprint_client[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 1 /* client */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_client, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [client][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_client[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_client[i*2], \"%02X\", fingerprint_client[i] & 0xFF);\n\t  flow->protos.ssh.hassh_client[32] = '\\0';\n\t} else {\n\t  u_char fingerprint_server[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 0 /* server */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_server, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [server][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_server[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_server[i*2], \"%02X\", fingerprint_server[i] & 0xFF);\n\t  flow->protos.ssh.hassh_server[32] = '\\0';\n\t}\n\n\tndpi_free(hassh_buf);\n      }\n\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n    }\n\n    if((flow->protos.ssh.hassh_client[0] != '\\0') && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n#ifdef SSH_DEBUG\n      printf(\"[SSH] Dissection completed\\n\");\n#endif\n      flow->extra_packets_func = NULL; /* We're good now */\n    }\n\n    return;\n  }\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Excluding SSH\");\n#endif\n\n  NDPI_LOG_DBG(ndpi_struct, \"excluding ssh at stage %d\\n\", flow->l4.tcp.ssh_stage);\n  NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_SSH);\n}\n\n/* ************************************************************************ */\n\nvoid init_ssh_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)\n{\n  ndpi_set_bitmask_protocol_detection(\"SSH\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_SSH,\n\t\t\t\t      ndpi_search_ssh_tcp,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "filenames": ["src/lib/protocols/ssh.c"], "buggy_code_start_loc": [112], "buggy_code_end_loc": [197], "fixing_code_start_loc": [113], "fixing_code_end_loc": [210], "type": "CWE-125", "message": "In nDPI through 3.2 Stable, an out-of-bounds read in concat_hash_string in ssh.c can be exploited by a network-positioned attacker that can send malformed SSH protocol messages on a network segment monitored by nDPI's library.", "other": {"cve": {"id": "CVE-2020-11940", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-23T15:15:14.153", "lastModified": "2020-05-06T19:48:23.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In nDPI through 3.2 Stable, an out-of-bounds read in concat_hash_string in ssh.c can be exploited by a network-positioned attacker that can send malformed SSH protocol messages on a network segment monitored by nDPI's library."}, {"lang": "es", "value": "En nDPI versiones hasta 3.2 Stable, una lectura fuera de l\u00edmites en la funci\u00f3n concat_hash_string en el archivo ssh.c puede ser explotada por un atacante posicionado en red que puede enviar mensajes en protocolo SSH malformado en un segmento de red monitoreado por la biblioteca de nDPI."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntop:ndpi:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2", "matchCriteriaId": "97EDB1C6-9886-4C0B-8F09-5A4C52DC5A45"}]}]}], "references": [{"url": "https://github.com/ntop/nDPI/commit/3bbb0cd3296023f6f922c71d21a1c374d2b0a435", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2020-051_052-ntop-ndpi", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntop/nDPI/commit/3bbb0cd3296023f6f922c71d21a1c374d2b0a435"}}