{"buggy_code": ["/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n */\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <net/netlink.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n\n/* bpf_check() is a static code analyzer that walks eBPF program\n * instruction by instruction and updates register/stack state.\n * All paths of conditional branches are analyzed until 'bpf_exit' insn.\n *\n * The first pass is depth-first-search to check that the program is a DAG.\n * It rejects the following programs:\n * - larger than BPF_MAXINSNS insns\n * - if loop is present (detected via back-edge)\n * - unreachable insns exist (shouldn't be a forest. program = one function)\n * - out of bounds or malformed jumps\n * The second pass is all possible path descent from the 1st insn.\n * Since it's analyzing all pathes through the program, the length of the\n * analysis is limited to 32k insn, which may be hit even if total number of\n * insn is less then 4K, but there are too many branches that change stack/regs.\n * Number of 'branches to be analyzed' is limited to 1k\n *\n * On entry to each instruction, each register has a type, and the instruction\n * changes the types of the registers depending on instruction semantics.\n * If instruction is BPF_MOV64_REG(BPF_REG_1, BPF_REG_5), then type of R5 is\n * copied to R1.\n *\n * All registers are 64-bit.\n * R0 - return register\n * R1-R5 argument passing registers\n * R6-R9 callee saved registers\n * R10 - frame pointer read-only\n *\n * At the start of BPF program the register R1 contains a pointer to bpf_context\n * and has type PTR_TO_CTX.\n *\n * Verifier tracks arithmetic operations on pointers in case:\n *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),\n * 1st insn copies R10 (which has FRAME_PTR) type into R1\n * and 2nd arithmetic instruction is pattern matched to recognize\n * that it wants to construct a pointer to some element within stack.\n * So after 2nd insn, the register R1 has type PTR_TO_STACK\n * (and -20 constant is saved for further stack bounds checking).\n * Meaning that this reg is a pointer to stack plus known immediate constant.\n *\n * Most of the time the registers have UNKNOWN_VALUE type, which\n * means the register has some value, but it's not a valid pointer.\n * (like pointer plus pointer becomes UNKNOWN_VALUE type)\n *\n * When verifier sees load or store instructions the type of base register\n * can be: PTR_TO_MAP_VALUE, PTR_TO_CTX, FRAME_PTR. These are three pointer\n * types recognized by check_mem_access() function.\n *\n * PTR_TO_MAP_VALUE means that this register is pointing to 'map element value'\n * and the range of [ptr, ptr + map's value_size) is accessible.\n *\n * registers used to pass values to function calls are checked against\n * function argument constraints.\n *\n * ARG_PTR_TO_MAP_KEY is one of such argument constraints.\n * It means that the register type passed to this function must be\n * PTR_TO_STACK and it will be used inside the function as\n * 'pointer to map element key'\n *\n * For example the argument constraints for bpf_map_lookup_elem():\n *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,\n *   .arg1_type = ARG_CONST_MAP_PTR,\n *   .arg2_type = ARG_PTR_TO_MAP_KEY,\n *\n * ret_type says that this function returns 'pointer to map elem value or null'\n * function expects 1st argument to be a const pointer to 'struct bpf_map' and\n * 2nd argument should be a pointer to stack, which will be used inside\n * the helper function as a pointer to map element key.\n *\n * On the kernel side the helper function looks like:\n * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n * {\n *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;\n *    void *key = (void *) (unsigned long) r2;\n *    void *value;\n *\n *    here kernel can access 'key' and 'map' pointers safely, knowing that\n *    [key, key + map->key_size) bytes are valid and were initialized on\n *    the stack of eBPF program.\n * }\n *\n * Corresponding eBPF program may look like:\n *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // after this insn R2 type is FRAME_PTR\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // after this insn R2 type is PTR_TO_STACK\n *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // after this insn R1 type is CONST_PTR_TO_MAP\n *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n * here verifier looks at prototype of map_lookup_elem() and sees:\n * .arg1_type == ARG_CONST_MAP_PTR and R1->type == CONST_PTR_TO_MAP, which is ok,\n * Now verifier knows that this map has key of R1->map_ptr->key_size bytes\n *\n * Then .arg2_type == ARG_PTR_TO_MAP_KEY and R2->type == PTR_TO_STACK, ok so far,\n * Now verifier checks that [R2, R2 + map's key_size) are within stack limits\n * and were initialized prior to this call.\n * If it's ok, then verifier allows this BPF_CALL insn and looks at\n * .ret_type which is RET_PTR_TO_MAP_VALUE_OR_NULL, so it sets\n * R0->type = PTR_TO_MAP_VALUE_OR_NULL which means bpf_map_lookup_elem() function\n * returns ether pointer to map value or NULL.\n *\n * When type PTR_TO_MAP_VALUE_OR_NULL passes through 'if (reg != 0) goto +off'\n * insn, the register holding that pointer in the true branch changes state to\n * PTR_TO_MAP_VALUE and the same register changes state to CONST_IMM in the false\n * branch. See check_cond_jmp_op().\n *\n * After the call R0 is set to return type of the function and registers R1-R5\n * are set to NOT_INIT to indicate that they are no longer readable.\n */\n\n/* types of values stored in eBPF registers */\nenum bpf_reg_type {\n\tNOT_INIT = 0,\t\t /* nothing was written into register */\n\tUNKNOWN_VALUE,\t\t /* reg doesn't contain a valid pointer */\n\tPTR_TO_CTX,\t\t /* reg points to bpf_context */\n\tCONST_PTR_TO_MAP,\t /* reg points to struct bpf_map */\n\tPTR_TO_MAP_VALUE,\t /* reg points to map element value */\n\tPTR_TO_MAP_VALUE_OR_NULL,/* points to map elem value or NULL */\n\tFRAME_PTR,\t\t /* reg == frame_pointer */\n\tPTR_TO_STACK,\t\t /* reg == frame_pointer + imm */\n\tCONST_IMM,\t\t /* constant integer value */\n};\n\nstruct reg_state {\n\tenum bpf_reg_type type;\n\tunion {\n\t\t/* valid when type == CONST_IMM | PTR_TO_STACK */\n\t\tint imm;\n\n\t\t/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |\n\t\t *   PTR_TO_MAP_VALUE_OR_NULL\n\t\t */\n\t\tstruct bpf_map *map_ptr;\n\t};\n};\n\nenum bpf_stack_slot_type {\n\tSTACK_INVALID,    /* nothing was stored in this stack slot */\n\tSTACK_SPILL,      /* register spilled into stack */\n\tSTACK_MISC\t  /* BPF program wrote some data into this slot */\n};\n\n#define BPF_REG_SIZE 8\t/* size of eBPF register in bytes */\n\n/* state of the program:\n * type of all registers and stack info\n */\nstruct verifier_state {\n\tstruct reg_state regs[MAX_BPF_REG];\n\tu8 stack_slot_type[MAX_BPF_STACK];\n\tstruct reg_state spilled_regs[MAX_BPF_STACK / BPF_REG_SIZE];\n};\n\n/* linked list of verifier states used to prune search */\nstruct verifier_state_list {\n\tstruct verifier_state state;\n\tstruct verifier_state_list *next;\n};\n\n/* verifier_state + insn_idx are pushed to stack when branch is encountered */\nstruct verifier_stack_elem {\n\t/* verifer state is 'st'\n\t * before processing instruction 'insn_idx'\n\t * and after processing instruction 'prev_insn_idx'\n\t */\n\tstruct verifier_state st;\n\tint insn_idx;\n\tint prev_insn_idx;\n\tstruct verifier_stack_elem *next;\n};\n\n#define MAX_USED_MAPS 64 /* max number of maps accessed by one eBPF program */\n\n/* single container for all structs\n * one verifier_env per bpf_check() call\n */\nstruct verifier_env {\n\tstruct bpf_prog *prog;\t\t/* eBPF program being verified */\n\tstruct verifier_stack_elem *head; /* stack of verifier states to be processed */\n\tint stack_size;\t\t\t/* number of states to be processed */\n\tstruct verifier_state cur_state; /* current verifier state */\n\tstruct verifier_state_list **explored_states; /* search pruning optimization */\n\tstruct bpf_map *used_maps[MAX_USED_MAPS]; /* array of map's used by eBPF program */\n\tu32 used_map_cnt;\t\t/* number of used maps */\n\tbool allow_ptr_leaks;\n};\n\n/* verbose verifier prints what it's seeing\n * bpf_check() is called under lock, so no race to access these global vars\n */\nstatic u32 log_level, log_size, log_len;\nstatic char *log_buf;\n\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\n/* log_level controls verbosity level of eBPF verifier.\n * verbose() is used to dump the verification trace to the log, so the user\n * can figure out what's wrong with the program\n */\nstatic __printf(1, 2) void verbose(const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (log_level == 0 || log_len >= log_size - 1)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tlog_len += vscnprintf(log_buf + log_len, log_size - log_len, fmt, args);\n\tva_end(args);\n}\n\n/* string representation of 'enum bpf_reg_type' */\nstatic const char * const reg_type_str[] = {\n\t[NOT_INIT]\t\t= \"?\",\n\t[UNKNOWN_VALUE]\t\t= \"inv\",\n\t[PTR_TO_CTX]\t\t= \"ctx\",\n\t[CONST_PTR_TO_MAP]\t= \"map_ptr\",\n\t[PTR_TO_MAP_VALUE]\t= \"map_value\",\n\t[PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",\n\t[FRAME_PTR]\t\t= \"fp\",\n\t[PTR_TO_STACK]\t\t= \"fp\",\n\t[CONST_IMM]\t\t= \"imm\",\n};\n\nstatic const struct {\n\tint map_type;\n\tint func_id;\n} func_limit[] = {\n\t{BPF_MAP_TYPE_PROG_ARRAY, BPF_FUNC_tail_call},\n\t{BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_FUNC_perf_event_read},\n\t{BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_FUNC_perf_event_output},\n};\n\nstatic void print_verifier_state(struct verifier_env *env)\n{\n\tenum bpf_reg_type t;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tt = env->cur_state.regs[i].type;\n\t\tif (t == NOT_INIT)\n\t\t\tcontinue;\n\t\tverbose(\" R%d=%s\", i, reg_type_str[t]);\n\t\tif (t == CONST_IMM || t == PTR_TO_STACK)\n\t\t\tverbose(\"%d\", env->cur_state.regs[i].imm);\n\t\telse if (t == CONST_PTR_TO_MAP || t == PTR_TO_MAP_VALUE ||\n\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\tverbose(\"(ks=%d,vs=%d)\",\n\t\t\t\tenv->cur_state.regs[i].map_ptr->key_size,\n\t\t\t\tenv->cur_state.regs[i].map_ptr->value_size);\n\t}\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (env->cur_state.stack_slot_type[i] == STACK_SPILL)\n\t\t\tverbose(\" fp%d=%s\", -MAX_BPF_STACK + i,\n\t\t\t\treg_type_str[env->cur_state.spilled_regs[i / BPF_REG_SIZE].type]);\n\t}\n\tverbose(\"\\n\");\n}\n\nstatic const char *const bpf_class_string[] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_RET]   = \"BUG\",\n\t[BPF_ALU64] = \"alu64\",\n};\n\nstatic const char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};\n\nstatic const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};\n\nstatic const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};\n\nstatic void print_bpf_insn(struct bpf_insn *insn)\n{\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {\n\t\t\tverbose(\"(%02x) r%d = 0x%x\\n\",\n\t\t\t\tinsn->code, insn->dst_reg, insn->imm);\n\t\t} else {\n\t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %d\\n\", insn->code, insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}\n\nstatic int pop_stack(struct verifier_env *env, int *prev_insn_idx)\n{\n\tstruct verifier_stack_elem *elem;\n\tint insn_idx;\n\n\tif (env->head == NULL)\n\t\treturn -1;\n\n\tmemcpy(&env->cur_state, &env->head->st, sizeof(env->cur_state));\n\tinsn_idx = env->head->insn_idx;\n\tif (prev_insn_idx)\n\t\t*prev_insn_idx = env->head->prev_insn_idx;\n\telem = env->head->next;\n\tkfree(env->head);\n\tenv->head = elem;\n\tenv->stack_size--;\n\treturn insn_idx;\n}\n\nstatic struct verifier_state *push_stack(struct verifier_env *env, int insn_idx,\n\t\t\t\t\t int prev_insn_idx)\n{\n\tstruct verifier_stack_elem *elem;\n\n\telem = kmalloc(sizeof(struct verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\tmemcpy(&elem->st, &env->cur_state, sizeof(env->cur_state));\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\tif (env->stack_size > 1024) {\n\t\tverbose(\"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\t/* pop all elements and return */\n\twhile (pop_stack(env, NULL) >= 0);\n\treturn NULL;\n}\n\n#define CALLER_SAVED_REGS 6\nstatic const int caller_saved[CALLER_SAVED_REGS] = {\n\tBPF_REG_0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5\n};\n\nstatic void init_reg_state(struct reg_state *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tregs[i].type = NOT_INIT;\n\t\tregs[i].imm = 0;\n\t\tregs[i].map_ptr = NULL;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = FRAME_PTR;\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n}\n\nstatic void mark_reg_unknown_value(struct reg_state *regs, u32 regno)\n{\n\tBUG_ON(regno >= MAX_BPF_REG);\n\tregs[regno].type = UNKNOWN_VALUE;\n\tregs[regno].imm = 0;\n\tregs[regno].map_ptr = NULL;\n}\n\nenum reg_arg_type {\n\tSRC_OP,\t\t/* register is used as source operand */\n\tDST_OP,\t\t/* register is used as destination operand */\n\tDST_OP_NO_MARK\t/* same as above, check only, don't mark */\n};\n\nstatic int check_reg_arg(struct reg_state *regs, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(\"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t == SRC_OP) {\n\t\t/* check whether register used as source operand can be read */\n\t\tif (regs[regno].type == NOT_INIT) {\n\t\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\t/* check whether register used as dest operand can be written to */\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(\"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown_value(regs, regno);\n\t}\n\treturn 0;\n}\n\nstatic int bpf_size_to_bytes(int bpf_size)\n{\n\tif (bpf_size == BPF_W)\n\t\treturn 4;\n\telse if (bpf_size == BPF_H)\n\t\treturn 2;\n\telse if (bpf_size == BPF_B)\n\t\treturn 1;\n\telse if (bpf_size == BPF_DW)\n\t\treturn 8;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic bool is_spillable_regtype(enum bpf_reg_type type)\n{\n\tswitch (type) {\n\tcase PTR_TO_MAP_VALUE:\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_CTX:\n\tcase FRAME_PTR:\n\tcase CONST_PTR_TO_MAP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* check_stack_read/write functions track spill/fill of registers,\n * stack boundary and alignment are checked in check_mem_access()\n */\nstatic int check_stack_write(struct verifier_state *state, int off, int size,\n\t\t\t     int value_regno)\n{\n\tint i;\n\t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n\t * so it's aligned access and [off, off + size) are within stack limits\n\t */\n\n\tif (value_regno >= 0 &&\n\t    is_spillable_regtype(state->regs[value_regno].type)) {\n\n\t\t/* register containing pointer is being spilled into stack */\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* save register state */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\tstate->regs[value_regno];\n\n\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_SPILL;\n\t} else {\n\t\t/* regular write of data into stack */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\t(struct reg_state) {};\n\n\t\tfor (i = 0; i < size; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_MISC;\n\t}\n\treturn 0;\n}\n\nstatic int check_stack_read(struct verifier_state *state, int off, int size,\n\t\t\t    int value_regno)\n{\n\tu8 *slot_type;\n\tint i;\n\n\tslot_type = &state->stack_slot_type[MAX_BPF_STACK + off];\n\n\tif (slot_type[0] == STACK_SPILL) {\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfor (i = 1; i < BPF_REG_SIZE; i++) {\n\t\t\tif (slot_type[i] != STACK_SPILL) {\n\t\t\t\tverbose(\"corrupted spill memory\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >= 0)\n\t\t\t/* restore register state from stack */\n\t\t\tstate->regs[value_regno] =\n\t\t\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE];\n\t\treturn 0;\n\t} else {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (slot_type[i] != STACK_MISC) {\n\t\t\t\tverbose(\"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\t\toff, i, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t\tif (value_regno >= 0)\n\t\t\t/* have read misc data from the stack */\n\t\t\tmark_reg_unknown_value(state->regs, value_regno);\n\t\treturn 0;\n\t}\n}\n\n/* check read/write into map element returned by bpf_map_lookup_elem() */\nstatic int check_map_access(struct verifier_env *env, u32 regno, int off,\n\t\t\t    int size)\n{\n\tstruct bpf_map *map = env->cur_state.regs[regno].map_ptr;\n\n\tif (off < 0 || off + size > map->value_size) {\n\t\tverbose(\"invalid access to map value, value_size=%d off=%d size=%d\\n\",\n\t\t\tmap->value_size, off, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n/* check access to 'struct bpf_context' fields */\nstatic int check_ctx_access(struct verifier_env *env, int off, int size,\n\t\t\t    enum bpf_access_type t)\n{\n\tif (env->prog->aux->ops->is_valid_access &&\n\t    env->prog->aux->ops->is_valid_access(off, size, t))\n\t\treturn 0;\n\n\tverbose(\"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}\n\nstatic bool is_pointer_value(struct verifier_env *env, int regno)\n{\n\tif (env->allow_ptr_leaks)\n\t\treturn false;\n\n\tswitch (env->cur_state.regs[regno].type) {\n\tcase UNKNOWN_VALUE:\n\tcase CONST_IMM:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\n/* check whether memory at (regno + off) is accessible for t = (read | write)\n * if t==write, value_regno is a register which value is stored into memory\n * if t==read, value_regno is a register which will receive the value from memory\n * if t==write && value_regno==-1, some unknown value is stored into memory\n * if t==read && value_regno==-1, don't care what we read from memory\n */\nstatic int check_mem_access(struct verifier_env *env, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tint size, err = 0;\n\n\tif (state->regs[regno].type == PTR_TO_STACK)\n\t\toff += state->regs[regno].imm;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\tif (off % size != 0) {\n\t\tverbose(\"misaligned access off %d size %d\\n\", off, size);\n\t\treturn -EACCES;\n\t}\n\n\tif (state->regs[regno].type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access(env, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value(state->regs, value_regno);\n\n\t} else if (state->regs[regno].type == PTR_TO_CTX) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, off, size, t);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value(state->regs, value_regno);\n\n\t} else if (state->regs[regno].type == FRAME_PTR ||\n\t\t   state->regs[regno].type == PTR_TO_STACK) {\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(\"invalid stack off=%d size=%d\\n\", off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE) {\n\t\t\tif (!env->allow_ptr_leaks &&\n\t\t\t    state->stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &&\n\t\t\t    size != BPF_REG_SIZE) {\n\t\t\t\tverbose(\"attempt to corrupt spilled pointer on stack\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\terr = check_stack_write(state, off, size, value_regno);\n\t\t} else {\n\t\t\terr = check_stack_read(state, off, size, value_regno);\n\t\t}\n\t} else {\n\t\tverbose(\"R%d invalid mem access '%s'\\n\",\n\t\t\tregno, reg_type_str[state->regs[regno].type]);\n\t\treturn -EACCES;\n\t}\n\treturn err;\n}\n\nstatic int check_xadd(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif ((BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) ||\n\t    insn->imm != 0) {\n\t\tverbose(\"BPF_XADD uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check src1 operand */\n\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can read the memory */\n\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t       BPF_SIZE(insn->code), BPF_READ, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can write into the same memory */\n\treturn check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\tBPF_SIZE(insn->code), BPF_WRITE, -1);\n}\n\n/* when register 'regno' is passed into function that will read 'access_size'\n * bytes from that pointer, make sure that it's within stack boundary\n * and all elements of stack are initialized\n */\nstatic int check_stack_boundary(struct verifier_env *env,\n\t\t\t\tint regno, int access_size)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tstruct reg_state *regs = state->regs;\n\tint off, i;\n\n\tif (regs[regno].type != PTR_TO_STACK)\n\t\treturn -EACCES;\n\n\toff = regs[regno].imm;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size <= 0) {\n\t\tverbose(\"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tif (state->stack_slot_type[MAX_BPF_STACK + off + i] != STACK_MISC) {\n\t\t\tverbose(\"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_func_arg(struct verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type, struct bpf_map **mapp)\n{\n\tstruct reg_state *reg = env->cur_state.regs + regno;\n\tenum bpf_reg_type expected_type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\tif (reg->type == NOT_INIT) {\n\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(\"R%d leaks addr into helper function\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_STACK || arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t} else if (arg_type == ARG_CONST_STACK_SIZE) {\n\t\texpected_type = CONST_IMM;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t} else {\n\t\tverbose(\"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (reg->type != expected_type) {\n\t\tverbose(\"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[reg->type], reg_type_str[expected_type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\t*mapp = reg->map_ptr;\n\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!*mapp) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(\"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_stack_boundary(env, regno, (*mapp)->key_size);\n\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!*mapp) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_stack_boundary(env, regno, (*mapp)->value_size);\n\n\t} else if (arg_type == ARG_CONST_STACK_SIZE) {\n\t\t/* bpf_xxx(..., buf, len) call will access 'len' bytes\n\t\t * from stack pointer 'buf'. Check it\n\t\t * note: regno == len, regno - 1 == buf\n\t\t */\n\t\tif (regno == 0) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"ARG_CONST_STACK_SIZE cannot be first argument\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_stack_boundary(env, regno - 1, reg->imm);\n\t}\n\n\treturn err;\n}\n\nstatic int check_map_func_compatibility(struct bpf_map *map, int func_id)\n{\n\tbool bool_map, bool_func;\n\tint i;\n\n\tif (!map)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(func_limit); i++) {\n\t\tbool_map = (map->map_type == func_limit[i].map_type);\n\t\tbool_func = (func_id == func_limit[i].func_id);\n\t\t/* only when map & func pair match it can continue.\n\t\t * don't allow any other map type to be passed into\n\t\t * the special func;\n\t\t */\n\t\tif (bool_func && bool_map != bool_func)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_call(struct verifier_env *env, int func_id)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tconst struct bpf_func_proto *fn = NULL;\n\tstruct reg_state *regs = state->regs;\n\tstruct bpf_map *map = NULL;\n\tstruct reg_state *reg;\n\tint i, err;\n\n\t/* find function prototype */\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(\"invalid func %d\\n\", func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->prog->aux->ops->get_func_proto)\n\t\tfn = env->prog->aux->ops->get_func_proto(func_id);\n\n\tif (!fn) {\n\t\tverbose(\"unknown func %d\\n\", func_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(\"cannot call GPL only function from proprietary program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check args */\n\terr = check_func_arg(env, BPF_REG_1, fn->arg1_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_2, fn->arg2_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_3, fn->arg3_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_4, fn->arg4_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_5, fn->arg5_type, &map);\n\tif (err)\n\t\treturn err;\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* update return register */\n\tif (fn->ret_type == RET_INTEGER) {\n\t\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\t} else if (fn->ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (map == NULL) {\n\t\t\tverbose(\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = map;\n\t} else {\n\t\tverbose(\"unknown return type %d of func %d\\n\",\n\t\t\tfn->ret_type, func_id);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_map_func_compatibility(map, func_id);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/* check validity of 32-bit and 64-bit arithmetic operations */\nstatic int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(\"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64)) {\n\t\t\t\tverbose(\"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t} else {\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tregs[insn->dst_reg].type = UNKNOWN_VALUE;\n\t\t\t\tregs[insn->dst_reg].map_ptr = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(\"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tbool stack_relative = false;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(\"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(\"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* pattern match 'bpf_add Rx, imm' instruction */\n\t\tif (opcode == BPF_ADD && BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t    regs[insn->dst_reg].type == FRAME_PTR &&\n\t\t    BPF_SRC(insn->code) == BPF_K) {\n\t\t\tstack_relative = true;\n\t\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t} else if (BPF_SRC(insn->code) == BPF_X &&\n\t\t\t   is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (stack_relative) {\n\t\t\tregs[insn->dst_reg].type = PTR_TO_STACK;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_cond_jmp_op(struct verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tstruct verifier_state *other_branch;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode > BPF_EXIT) {\n\t\tverbose(\"invalid BPF_JMP opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* detect if R == 0 where R was initialized to zero earlier */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    regs[insn->dst_reg].type == CONST_IMM &&\n\t    regs[insn->dst_reg].imm == insn->imm) {\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* if (imm == imm) goto pc+off;\n\t\t\t * only follow the goto, ignore fall-through\n\t\t\t */\n\t\t\t*insn_idx += insn->off;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* if (imm != imm) goto pc+off;\n\t\t\t * only follow fall-through branch, since\n\t\t\t * that's where the program will go\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\n\t/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ ||\n\t\t\t       opcode == BPF_JNE) &&\n\t    regs[insn->dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* next fallthrough insn can access memory via\n\t\t\t * this register\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = PTR_TO_MAP_VALUE;\n\t\t\t/* branch targer cannot access it, since reg == 0 */\n\t\t\tother_branch->regs[insn->dst_reg].type = CONST_IMM;\n\t\t\tother_branch->regs[insn->dst_reg].imm = 0;\n\t\t} else {\n\t\t\tother_branch->regs[insn->dst_reg].type = PTR_TO_MAP_VALUE;\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = 0;\n\t\t}\n\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(\"R%d pointer comparison prohibited\\n\", insn->dst_reg);\n\t\treturn -EACCES;\n\t} else if (BPF_SRC(insn->code) == BPF_K &&\n\t\t   (opcode == BPF_JEQ || opcode == BPF_JNE)) {\n\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* detect if (R == imm) goto\n\t\t\t * and in the target state recognize that R = imm\n\t\t\t */\n\t\t\tother_branch->regs[insn->dst_reg].type = CONST_IMM;\n\t\t\tother_branch->regs[insn->dst_reg].imm = insn->imm;\n\t\t} else {\n\t\t\t/* detect if (R != imm) goto\n\t\t\t * and in the fall-through state recognize that R = imm\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t}\n\t}\n\tif (log_level)\n\t\tprint_verifier_state(env);\n\treturn 0;\n}\n\n/* return the map pointer stored inside BPF_LD_IMM64 instruction */\nstatic struct bpf_map *ld_imm64_to_map_ptr(struct bpf_insn *insn)\n{\n\tu64 imm64 = ((u64) (u32) insn[0].imm) | ((u64) (u32) insn[1].imm) << 32;\n\n\treturn (struct bpf_map *) (unsigned long) imm64;\n}\n\n/* verify BPF_LD_IMM64 instruction */\nstatic int check_ld_imm(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif (BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(\"invalid BPF_LD_IMM insn\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (insn->off != 0) {\n\t\tverbose(\"BPF_LD_IMM64 uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (insn->src_reg == 0)\n\t\t/* generic move 64-bit immediate into a register */\n\t\treturn 0;\n\n\t/* replace_map_fd_with_map_ptr() should have caught bad ld_imm64 */\n\tBUG_ON(insn->src_reg != BPF_PSEUDO_MAP_FD);\n\n\tregs[insn->dst_reg].type = CONST_PTR_TO_MAP;\n\tregs[insn->dst_reg].map_ptr = ld_imm64_to_map_ptr(insn);\n\treturn 0;\n}\n\nstatic bool may_access_skb(enum bpf_prog_type type)\n{\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_SOCKET_FILTER:\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* verify safety of LD_ABS|LD_IND instructions:\n * - they can only appear in the programs where ctx == skb\n * - since they are wrappers of function calls, they scratch R1-R5 registers,\n *   preserve R6-R9, and store return value into R0\n *\n * Implicit input:\n *   ctx == skb == R6 == CTX\n *\n * Explicit input:\n *   SRC == any register\n *   IMM == 32-bit immediate\n *\n * Output:\n *   R0 - 8/16/32-bit skb data converted to cpu endianness\n */\nstatic int check_ld_abs(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tu8 mode = BPF_MODE(insn->code);\n\tstruct reg_state *reg;\n\tint i, err;\n\n\tif (!may_access_skb(env->prog->type)) {\n\t\tverbose(\"BPF_LD_ABS|IND instructions not allowed for this program type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (insn->dst_reg != BPF_REG_0 || insn->off != 0 ||\n\t    (mode == BPF_ABS && insn->src_reg != BPF_REG_0)) {\n\t\tverbose(\"BPF_LD_ABS uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check whether implicit source operand (register R6) is readable */\n\terr = check_reg_arg(regs, BPF_REG_6, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (regs[BPF_REG_6].type != PTR_TO_CTX) {\n\t\tverbose(\"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == BPF_IND) {\n\t\t/* check explicit source operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reset caller saved regs to unreadable */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* mark destination R0 register as readable, since it contains\n\t * the value fetched from the packet\n\t */\n\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\treturn 0;\n}\n\n/* non-recursive DFS pseudo code\n * 1  procedure DFS-iterative(G,v):\n * 2      label v as discovered\n * 3      let S be a stack\n * 4      S.push(v)\n * 5      while S is not empty\n * 6            t <- S.pop()\n * 7            if t is what we're looking for:\n * 8                return t\n * 9            for all edges e in G.adjacentEdges(t) do\n * 10               if edge e is already labelled\n * 11                   continue with the next edge\n * 12               w <- G.adjacentVertex(t,e)\n * 13               if vertex w is not discovered and not explored\n * 14                   label e as tree-edge\n * 15                   label w as discovered\n * 16                   S.push(w)\n * 17                   continue at 5\n * 18               else if vertex w is discovered\n * 19                   label e as back-edge\n * 20               else\n * 21                   // vertex w is explored\n * 22                   label e as forward- or cross-edge\n * 23           label t as explored\n * 24           S.pop()\n *\n * convention:\n * 0x10 - discovered\n * 0x11 - discovered and fall-through edge labelled\n * 0x12 - discovered and fall-through and branch edges labelled\n * 0x20 - explored\n */\n\nenum {\n\tDISCOVERED = 0x10,\n\tEXPLORED = 0x20,\n\tFALLTHROUGH = 1,\n\tBRANCH = 2,\n};\n\n#define STATE_LIST_MARK ((struct verifier_state_list *) -1L)\n\nstatic int *insn_stack;\t/* stack of insns to process */\nstatic int cur_stack;\t/* current stack index */\nstatic int *insn_state;\n\n/* t, w, e - match pseudo-code above:\n * t - index of current instruction\n * w - next instruction\n * e - edge\n */\nstatic int push_insn(int t, int w, int e, struct verifier_env *env)\n{\n\tif (e == FALLTHROUGH && insn_state[t] >= (DISCOVERED | FALLTHROUGH))\n\t\treturn 0;\n\n\tif (e == BRANCH && insn_state[t] >= (DISCOVERED | BRANCH))\n\t\treturn 0;\n\n\tif (w < 0 || w >= env->prog->len) {\n\t\tverbose(\"jump out of range from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e == BRANCH)\n\t\t/* mark branch target for state pruning */\n\t\tenv->explored_states[w] = STATE_LIST_MARK;\n\n\tif (insn_state[w] == 0) {\n\t\t/* tree-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t\tinsn_state[w] = DISCOVERED;\n\t\tif (cur_stack >= env->prog->len)\n\t\t\treturn -E2BIG;\n\t\tinsn_stack[cur_stack++] = w;\n\t\treturn 1;\n\t} else if ((insn_state[w] & 0xF0) == DISCOVERED) {\n\t\tverbose(\"back-edge from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t} else if (insn_state[w] == EXPLORED) {\n\t\t/* forward- or cross-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t} else {\n\t\tverbose(\"insn state internal bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* non-recursive depth-first-search to detect loops in BPF program\n * loop == back-edge in directed graph\n */\nstatic int check_cfg(struct verifier_env *env)\n{\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint ret = 0;\n\tint i, t;\n\n\tinsn_state = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_state)\n\t\treturn -ENOMEM;\n\n\tinsn_stack = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_stack) {\n\t\tkfree(insn_state);\n\t\treturn -ENOMEM;\n\t}\n\n\tinsn_state[0] = DISCOVERED; /* mark 1st insn as discovered */\n\tinsn_stack[0] = 0; /* 0 is the first instruction */\n\tcur_stack = 1;\n\npeek_stack:\n\tif (cur_stack == 0)\n\t\tgoto check_state;\n\tt = insn_stack[cur_stack - 1];\n\n\tif (BPF_CLASS(insns[t].code) == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insns[t].code);\n\n\t\tif (opcode == BPF_EXIT) {\n\t\t\tgoto mark_explored;\n\t\t} else if (opcode == BPF_CALL) {\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t} else if (opcode == BPF_JA) {\n\t\t\tif (BPF_SRC(insns[t].code) != BPF_K) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t/* unconditional jump with single edge */\n\t\t\tret = push_insn(t, t + insns[t].off + 1,\n\t\t\t\t\tFALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\t/* tell verifier to check for equivalent states\n\t\t\t * after every call and jump\n\t\t\t */\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->explored_states[t + 1] = STATE_LIST_MARK;\n\t\t} else {\n\t\t\t/* conditional jump with two edges */\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\n\t\t\tret = push_insn(t, t + insns[t].off + 1, BRANCH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t}\n\t} else {\n\t\t/* all other non-branch instructions with single\n\t\t * fall-through edge\n\t\t */\n\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\tif (ret == 1)\n\t\t\tgoto peek_stack;\n\t\telse if (ret < 0)\n\t\t\tgoto err_free;\n\t}\n\nmark_explored:\n\tinsn_state[t] = EXPLORED;\n\tif (cur_stack-- <= 0) {\n\t\tverbose(\"pop stack internal bug\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_free;\n\t}\n\tgoto peek_stack;\n\ncheck_state:\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (insn_state[i] != EXPLORED) {\n\t\t\tverbose(\"unreachable insn %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\tret = 0; /* cfg looks good */\n\nerr_free:\n\tkfree(insn_state);\n\tkfree(insn_stack);\n\treturn ret;\n}\n\n/* compare two verifier states\n *\n * all states stored in state_list are known to be valid, since\n * verifier reached 'bpf_exit' instruction through them\n *\n * this function is called when verifier exploring different branches of\n * execution popped from the state stack. If it sees an old state that has\n * more strict register state and more strict stack state then this execution\n * branch doesn't need to be explored further, since verifier already\n * concluded that more strict state leads to valid finish.\n *\n * Therefore two states are equivalent if register state is more conservative\n * and explored stack state is more conservative than the current one.\n * Example:\n *       explored                   current\n * (slot1=INV slot2=MISC) == (slot1=MISC slot2=MISC)\n * (slot1=MISC slot2=MISC) != (slot1=INV slot2=MISC)\n *\n * In other words if current stack state (one being explored) has more\n * valid slots than old one that already passed validation, it means\n * the verifier can stop exploring and conclude that current state is valid too\n *\n * Similarly with registers. If explored state has register type as invalid\n * whereas register type in current state is meaningful, it means that\n * the current state will reach 'bpf_exit' instruction safely\n */\nstatic bool states_equal(struct verifier_state *old, struct verifier_state *cur)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tif (memcmp(&old->regs[i], &cur->regs[i],\n\t\t\t   sizeof(old->regs[0])) != 0) {\n\t\t\tif (old->regs[i].type == NOT_INIT ||\n\t\t\t    (old->regs[i].type == UNKNOWN_VALUE &&\n\t\t\t     cur->regs[i].type != NOT_INIT))\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_BPF_STACK; i++) {\n\t\tif (old->stack_slot_type[i] == STACK_INVALID)\n\t\t\tcontinue;\n\t\tif (old->stack_slot_type[i] != cur->stack_slot_type[i])\n\t\t\t/* Ex: old explored (safe) state has STACK_SPILL in\n\t\t\t * this stack slot, but current has has STACK_MISC ->\n\t\t\t * this verifier states are not equivalent,\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\tif (i % BPF_REG_SIZE)\n\t\t\tcontinue;\n\t\tif (memcmp(&old->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   &cur->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   sizeof(old->spilled_regs[0])))\n\t\t\t/* when explored and current stack slot types are\n\t\t\t * the same, check that stored pointers types\n\t\t\t * are the same as well.\n\t\t\t * Ex: explored safe path could have stored\n\t\t\t * (struct reg_state) {.type = PTR_TO_STACK, .imm = -8}\n\t\t\t * but current path has stored:\n\t\t\t * (struct reg_state) {.type = PTR_TO_STACK, .imm = -16}\n\t\t\t * such verifier states are not equivalent.\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\telse\n\t\t\tcontinue;\n\t}\n\treturn true;\n}\n\nstatic int is_state_visited(struct verifier_env *env, int insn_idx)\n{\n\tstruct verifier_state_list *new_sl;\n\tstruct verifier_state_list *sl;\n\n\tsl = env->explored_states[insn_idx];\n\tif (!sl)\n\t\t/* this 'insn_idx' instruction wasn't marked, so we will not\n\t\t * be doing state search here\n\t\t */\n\t\treturn 0;\n\n\twhile (sl != STATE_LIST_MARK) {\n\t\tif (states_equal(&sl->state, &env->cur_state))\n\t\t\t/* reached equivalent register/stack state,\n\t\t\t * prune the search\n\t\t\t */\n\t\t\treturn 1;\n\t\tsl = sl->next;\n\t}\n\n\t/* there were no equivalent states, remember current one.\n\t * technically the current state is not proven to be safe yet,\n\t * but it will either reach bpf_exit (which means it's safe) or\n\t * it will be rejected. Since there are no loops, we won't be\n\t * seeing this 'insn_idx' instruction again on the way to bpf_exit\n\t */\n\tnew_sl = kmalloc(sizeof(struct verifier_state_list), GFP_USER);\n\tif (!new_sl)\n\t\treturn -ENOMEM;\n\n\t/* add new state to the head of linked list */\n\tmemcpy(&new_sl->state, &env->cur_state, sizeof(env->cur_state));\n\tnew_sl->next = env->explored_states[insn_idx];\n\tenv->explored_states[insn_idx] = new_sl;\n\treturn 0;\n}\n\nstatic int do_check(struct verifier_env *env)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct reg_state *regs = state->regs;\n\tint insn_cnt = env->prog->len;\n\tint insn_idx, prev_insn_idx = 0;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tinit_reg_state(regs);\n\tinsn_idx = 0;\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (insn_idx >= insn_cnt) {\n\t\t\tverbose(\"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tinsn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > 32768) {\n\t\t\tverbose(\"BPF program is too large. Proccessed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(env);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (log_level) {\n\t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(insn);\n\t\t}\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, insn->src_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_READ,\n\t\t\t\t\t       insn->dst_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (BPF_SIZE(insn->code) != BPF_W) {\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (insn->imm == 0) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * use reserved 'imm' field to mark this insn\n\t\t\t\t */\n\t\t\t\tinsn->imm = src_reg_type;\n\n\t\t\t} else if (src_reg_type != insn->imm &&\n\t\t\t\t   (src_reg_type == PTR_TO_CTX ||\n\t\t\t\t    insn->imm == PTR_TO_CTX)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       insn->src_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (insn->imm == 0) {\n\t\t\t\tinsn->imm = dst_reg_type;\n\t\t\t} else if (dst_reg_type != insn->imm &&\n\t\t\t\t   (dst_reg_type == PTR_TO_CTX ||\n\t\t\t\t    insn->imm == PTR_TO_CTX)) {\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(\"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       -1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\terr = check_call(env, insn->imm);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tinsn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(regs, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(\"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\nprocess_bpf_exit:\n\t\t\t\tinsn_idx = pop_stack(env, &prev_insn_idx);\n\t\t\t\tif (insn_idx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tinsn_idx++;\n\t\t\t} else {\n\t\t\t\tverbose(\"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tverbose(\"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn_idx++;\n\t}\n\n\treturn 0;\n}\n\n/* look for pseudo eBPF instructions that access map FDs and\n * replace them with actual map pointers\n */\nstatic int replace_map_fd_with_map_ptr(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(\"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tverbose(\"fd %d is not pointing to valid bpf_map\\n\",\n\t\t\t\t\tinsn->imm);\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\n\t\t\t/* store map pointer inside BPF_LD_IMM64 instruction */\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* remember this map */\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tbpf_map_inc(map, false);\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n\n/* drop refcnt of maps used by the rejected program */\nstatic void release_maps(struct verifier_env *env)\n{\n\tint i;\n\n\tfor (i = 0; i < env->used_map_cnt; i++)\n\t\tbpf_map_put(env->used_maps[i]);\n}\n\n/* convert pseudo BPF_LD_IMM64 into generic BPF_LD_IMM64 */\nstatic void convert_pseudo_ld_imm64(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++)\n\t\tif (insn->code == (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tinsn->src_reg = 0;\n}\n\nstatic void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\n\t\t/* adjust offset of jmps if necessary */\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}\n\n/* convert load instructions that access fields of 'struct __sk_buff'\n * into sequence of instructions that access fields of 'struct sk_buff'\n */\nstatic int convert_ctx_accesses(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tu32 cnt;\n\tint i;\n\tenum bpf_access_type type;\n\n\tif (!env->prog->aux->ops->convert_ctx_access)\n\t\treturn 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_LDX | BPF_MEM | BPF_W))\n\t\t\ttype = BPF_READ;\n\t\telse if (insn->code == (BPF_STX | BPF_MEM | BPF_W))\n\t\t\ttype = BPF_WRITE;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (insn->imm != PTR_TO_CTX) {\n\t\t\t/* clear internal mark */\n\t\t\tinsn->imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcnt = env->prog->aux->ops->\n\t\t\tconvert_ctx_access(type, insn->dst_reg, insn->src_reg,\n\t\t\t\t\t   insn->off, insn_buf, env->prog);\n\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cnt == 1) {\n\t\t\tmemcpy(insn, insn_buf, sizeof(*insn));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* several new insns need to be inserted. Make room for them */\n\t\tinsn_cnt += cnt - 1;\n\t\tnew_prog = bpf_prog_realloc(env->prog,\n\t\t\t\t\t    bpf_prog_size(insn_cnt),\n\t\t\t\t\t    GFP_USER);\n\t\tif (!new_prog)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_prog->len = insn_cnt;\n\n\t\tmemmove(new_prog->insnsi + i + cnt, new_prog->insns + i + 1,\n\t\t\tsizeof(*insn) * (insn_cnt - i - cnt));\n\n\t\t/* copy substitute insns in place of load instruction */\n\t\tmemcpy(new_prog->insnsi + i, insn_buf, sizeof(*insn) * cnt);\n\n\t\t/* adjust branches in the whole program */\n\t\tadjust_branches(new_prog, i, cnt - 1);\n\n\t\t/* keep walking new program and skip insns we just inserted */\n\t\tenv->prog = new_prog;\n\t\tinsn = new_prog->insnsi + i + cnt - 1;\n\t\ti += cnt - 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_states(struct verifier_env *env)\n{\n\tstruct verifier_state_list *sl, *sln;\n\tint i;\n\n\tif (!env->explored_states)\n\t\treturn;\n\n\tfor (i = 0; i < env->prog->len; i++) {\n\t\tsl = env->explored_states[i];\n\n\t\tif (sl)\n\t\t\twhile (sl != STATE_LIST_MARK) {\n\t\t\t\tsln = sl->next;\n\t\t\t\tkfree(sl);\n\t\t\t\tsl = sln;\n\t\t\t}\n\t}\n\n\tkfree(env->explored_states);\n}\n\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tchar __user *log_ubuf = NULL;\n\tstruct verifier_env *env;\n\tint ret = -EINVAL;\n\n\tif ((*prog)->len <= 0 || (*prog)->len > BPF_MAXINSNS)\n\t\treturn -E2BIG;\n\n\t/* 'struct verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->prog = *prog;\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog_level = attr->log_level;\n\t\tlog_ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog_size = attr->log_size;\n\t\tlog_len = 0;\n\n\t\tret = -EINVAL;\n\t\t/* log_* values have to be sane */\n\t\tif (log_size < 128 || log_size > UINT_MAX >> 8 ||\n\t\t    log_level == 0 || log_ubuf == NULL)\n\t\t\tgoto free_env;\n\n\t\tret = -ENOMEM;\n\t\tlog_buf = vmalloc(log_size);\n\t\tif (!log_buf)\n\t\t\tgoto free_env;\n\t} else {\n\t\tlog_level = 0;\n\t}\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, NULL) >= 0);\n\tfree_states(env);\n\n\tif (ret == 0)\n\t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n\t\tret = convert_ctx_accesses(env);\n\n\tif (log_level && log_len >= log_size - 1) {\n\t\tBUG_ON(log_len >= log_size);\n\t\t/* verifier log exceeded user supplied buffer */\n\t\tret = -ENOSPC;\n\t\t/* fall through to return what was recorded */\n\t}\n\n\t/* copy verifier log back to user space including trailing zero */\n\tif (log_level && copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_log_buf;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_log_buf;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nfree_log_buf:\n\tif (log_level)\n\t\tvfree(log_buf);\nfree_env:\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_bpf_prog_info() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\n\tkfree(env);\n\tmutex_unlock(&bpf_verifier_lock);\n\treturn ret;\n}\n"], "fixing_code": ["/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n */\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <net/netlink.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n\n/* bpf_check() is a static code analyzer that walks eBPF program\n * instruction by instruction and updates register/stack state.\n * All paths of conditional branches are analyzed until 'bpf_exit' insn.\n *\n * The first pass is depth-first-search to check that the program is a DAG.\n * It rejects the following programs:\n * - larger than BPF_MAXINSNS insns\n * - if loop is present (detected via back-edge)\n * - unreachable insns exist (shouldn't be a forest. program = one function)\n * - out of bounds or malformed jumps\n * The second pass is all possible path descent from the 1st insn.\n * Since it's analyzing all pathes through the program, the length of the\n * analysis is limited to 32k insn, which may be hit even if total number of\n * insn is less then 4K, but there are too many branches that change stack/regs.\n * Number of 'branches to be analyzed' is limited to 1k\n *\n * On entry to each instruction, each register has a type, and the instruction\n * changes the types of the registers depending on instruction semantics.\n * If instruction is BPF_MOV64_REG(BPF_REG_1, BPF_REG_5), then type of R5 is\n * copied to R1.\n *\n * All registers are 64-bit.\n * R0 - return register\n * R1-R5 argument passing registers\n * R6-R9 callee saved registers\n * R10 - frame pointer read-only\n *\n * At the start of BPF program the register R1 contains a pointer to bpf_context\n * and has type PTR_TO_CTX.\n *\n * Verifier tracks arithmetic operations on pointers in case:\n *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),\n * 1st insn copies R10 (which has FRAME_PTR) type into R1\n * and 2nd arithmetic instruction is pattern matched to recognize\n * that it wants to construct a pointer to some element within stack.\n * So after 2nd insn, the register R1 has type PTR_TO_STACK\n * (and -20 constant is saved for further stack bounds checking).\n * Meaning that this reg is a pointer to stack plus known immediate constant.\n *\n * Most of the time the registers have UNKNOWN_VALUE type, which\n * means the register has some value, but it's not a valid pointer.\n * (like pointer plus pointer becomes UNKNOWN_VALUE type)\n *\n * When verifier sees load or store instructions the type of base register\n * can be: PTR_TO_MAP_VALUE, PTR_TO_CTX, FRAME_PTR. These are three pointer\n * types recognized by check_mem_access() function.\n *\n * PTR_TO_MAP_VALUE means that this register is pointing to 'map element value'\n * and the range of [ptr, ptr + map's value_size) is accessible.\n *\n * registers used to pass values to function calls are checked against\n * function argument constraints.\n *\n * ARG_PTR_TO_MAP_KEY is one of such argument constraints.\n * It means that the register type passed to this function must be\n * PTR_TO_STACK and it will be used inside the function as\n * 'pointer to map element key'\n *\n * For example the argument constraints for bpf_map_lookup_elem():\n *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,\n *   .arg1_type = ARG_CONST_MAP_PTR,\n *   .arg2_type = ARG_PTR_TO_MAP_KEY,\n *\n * ret_type says that this function returns 'pointer to map elem value or null'\n * function expects 1st argument to be a const pointer to 'struct bpf_map' and\n * 2nd argument should be a pointer to stack, which will be used inside\n * the helper function as a pointer to map element key.\n *\n * On the kernel side the helper function looks like:\n * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n * {\n *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;\n *    void *key = (void *) (unsigned long) r2;\n *    void *value;\n *\n *    here kernel can access 'key' and 'map' pointers safely, knowing that\n *    [key, key + map->key_size) bytes are valid and were initialized on\n *    the stack of eBPF program.\n * }\n *\n * Corresponding eBPF program may look like:\n *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // after this insn R2 type is FRAME_PTR\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // after this insn R2 type is PTR_TO_STACK\n *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // after this insn R1 type is CONST_PTR_TO_MAP\n *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n * here verifier looks at prototype of map_lookup_elem() and sees:\n * .arg1_type == ARG_CONST_MAP_PTR and R1->type == CONST_PTR_TO_MAP, which is ok,\n * Now verifier knows that this map has key of R1->map_ptr->key_size bytes\n *\n * Then .arg2_type == ARG_PTR_TO_MAP_KEY and R2->type == PTR_TO_STACK, ok so far,\n * Now verifier checks that [R2, R2 + map's key_size) are within stack limits\n * and were initialized prior to this call.\n * If it's ok, then verifier allows this BPF_CALL insn and looks at\n * .ret_type which is RET_PTR_TO_MAP_VALUE_OR_NULL, so it sets\n * R0->type = PTR_TO_MAP_VALUE_OR_NULL which means bpf_map_lookup_elem() function\n * returns ether pointer to map value or NULL.\n *\n * When type PTR_TO_MAP_VALUE_OR_NULL passes through 'if (reg != 0) goto +off'\n * insn, the register holding that pointer in the true branch changes state to\n * PTR_TO_MAP_VALUE and the same register changes state to CONST_IMM in the false\n * branch. See check_cond_jmp_op().\n *\n * After the call R0 is set to return type of the function and registers R1-R5\n * are set to NOT_INIT to indicate that they are no longer readable.\n */\n\n/* types of values stored in eBPF registers */\nenum bpf_reg_type {\n\tNOT_INIT = 0,\t\t /* nothing was written into register */\n\tUNKNOWN_VALUE,\t\t /* reg doesn't contain a valid pointer */\n\tPTR_TO_CTX,\t\t /* reg points to bpf_context */\n\tCONST_PTR_TO_MAP,\t /* reg points to struct bpf_map */\n\tPTR_TO_MAP_VALUE,\t /* reg points to map element value */\n\tPTR_TO_MAP_VALUE_OR_NULL,/* points to map elem value or NULL */\n\tFRAME_PTR,\t\t /* reg == frame_pointer */\n\tPTR_TO_STACK,\t\t /* reg == frame_pointer + imm */\n\tCONST_IMM,\t\t /* constant integer value */\n};\n\nstruct reg_state {\n\tenum bpf_reg_type type;\n\tunion {\n\t\t/* valid when type == CONST_IMM | PTR_TO_STACK */\n\t\tint imm;\n\n\t\t/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |\n\t\t *   PTR_TO_MAP_VALUE_OR_NULL\n\t\t */\n\t\tstruct bpf_map *map_ptr;\n\t};\n};\n\nenum bpf_stack_slot_type {\n\tSTACK_INVALID,    /* nothing was stored in this stack slot */\n\tSTACK_SPILL,      /* register spilled into stack */\n\tSTACK_MISC\t  /* BPF program wrote some data into this slot */\n};\n\n#define BPF_REG_SIZE 8\t/* size of eBPF register in bytes */\n\n/* state of the program:\n * type of all registers and stack info\n */\nstruct verifier_state {\n\tstruct reg_state regs[MAX_BPF_REG];\n\tu8 stack_slot_type[MAX_BPF_STACK];\n\tstruct reg_state spilled_regs[MAX_BPF_STACK / BPF_REG_SIZE];\n};\n\n/* linked list of verifier states used to prune search */\nstruct verifier_state_list {\n\tstruct verifier_state state;\n\tstruct verifier_state_list *next;\n};\n\n/* verifier_state + insn_idx are pushed to stack when branch is encountered */\nstruct verifier_stack_elem {\n\t/* verifer state is 'st'\n\t * before processing instruction 'insn_idx'\n\t * and after processing instruction 'prev_insn_idx'\n\t */\n\tstruct verifier_state st;\n\tint insn_idx;\n\tint prev_insn_idx;\n\tstruct verifier_stack_elem *next;\n};\n\n#define MAX_USED_MAPS 64 /* max number of maps accessed by one eBPF program */\n\n/* single container for all structs\n * one verifier_env per bpf_check() call\n */\nstruct verifier_env {\n\tstruct bpf_prog *prog;\t\t/* eBPF program being verified */\n\tstruct verifier_stack_elem *head; /* stack of verifier states to be processed */\n\tint stack_size;\t\t\t/* number of states to be processed */\n\tstruct verifier_state cur_state; /* current verifier state */\n\tstruct verifier_state_list **explored_states; /* search pruning optimization */\n\tstruct bpf_map *used_maps[MAX_USED_MAPS]; /* array of map's used by eBPF program */\n\tu32 used_map_cnt;\t\t/* number of used maps */\n\tbool allow_ptr_leaks;\n};\n\n/* verbose verifier prints what it's seeing\n * bpf_check() is called under lock, so no race to access these global vars\n */\nstatic u32 log_level, log_size, log_len;\nstatic char *log_buf;\n\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\n/* log_level controls verbosity level of eBPF verifier.\n * verbose() is used to dump the verification trace to the log, so the user\n * can figure out what's wrong with the program\n */\nstatic __printf(1, 2) void verbose(const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (log_level == 0 || log_len >= log_size - 1)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tlog_len += vscnprintf(log_buf + log_len, log_size - log_len, fmt, args);\n\tva_end(args);\n}\n\n/* string representation of 'enum bpf_reg_type' */\nstatic const char * const reg_type_str[] = {\n\t[NOT_INIT]\t\t= \"?\",\n\t[UNKNOWN_VALUE]\t\t= \"inv\",\n\t[PTR_TO_CTX]\t\t= \"ctx\",\n\t[CONST_PTR_TO_MAP]\t= \"map_ptr\",\n\t[PTR_TO_MAP_VALUE]\t= \"map_value\",\n\t[PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",\n\t[FRAME_PTR]\t\t= \"fp\",\n\t[PTR_TO_STACK]\t\t= \"fp\",\n\t[CONST_IMM]\t\t= \"imm\",\n};\n\nstatic const struct {\n\tint map_type;\n\tint func_id;\n} func_limit[] = {\n\t{BPF_MAP_TYPE_PROG_ARRAY, BPF_FUNC_tail_call},\n\t{BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_FUNC_perf_event_read},\n\t{BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_FUNC_perf_event_output},\n};\n\nstatic void print_verifier_state(struct verifier_env *env)\n{\n\tenum bpf_reg_type t;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tt = env->cur_state.regs[i].type;\n\t\tif (t == NOT_INIT)\n\t\t\tcontinue;\n\t\tverbose(\" R%d=%s\", i, reg_type_str[t]);\n\t\tif (t == CONST_IMM || t == PTR_TO_STACK)\n\t\t\tverbose(\"%d\", env->cur_state.regs[i].imm);\n\t\telse if (t == CONST_PTR_TO_MAP || t == PTR_TO_MAP_VALUE ||\n\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\tverbose(\"(ks=%d,vs=%d)\",\n\t\t\t\tenv->cur_state.regs[i].map_ptr->key_size,\n\t\t\t\tenv->cur_state.regs[i].map_ptr->value_size);\n\t}\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (env->cur_state.stack_slot_type[i] == STACK_SPILL)\n\t\t\tverbose(\" fp%d=%s\", -MAX_BPF_STACK + i,\n\t\t\t\treg_type_str[env->cur_state.spilled_regs[i / BPF_REG_SIZE].type]);\n\t}\n\tverbose(\"\\n\");\n}\n\nstatic const char *const bpf_class_string[] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_RET]   = \"BUG\",\n\t[BPF_ALU64] = \"alu64\",\n};\n\nstatic const char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};\n\nstatic const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};\n\nstatic const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};\n\nstatic void print_bpf_insn(struct bpf_insn *insn)\n{\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {\n\t\t\tverbose(\"(%02x) r%d = 0x%x\\n\",\n\t\t\t\tinsn->code, insn->dst_reg, insn->imm);\n\t\t} else {\n\t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %d\\n\", insn->code, insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}\n\nstatic int pop_stack(struct verifier_env *env, int *prev_insn_idx)\n{\n\tstruct verifier_stack_elem *elem;\n\tint insn_idx;\n\n\tif (env->head == NULL)\n\t\treturn -1;\n\n\tmemcpy(&env->cur_state, &env->head->st, sizeof(env->cur_state));\n\tinsn_idx = env->head->insn_idx;\n\tif (prev_insn_idx)\n\t\t*prev_insn_idx = env->head->prev_insn_idx;\n\telem = env->head->next;\n\tkfree(env->head);\n\tenv->head = elem;\n\tenv->stack_size--;\n\treturn insn_idx;\n}\n\nstatic struct verifier_state *push_stack(struct verifier_env *env, int insn_idx,\n\t\t\t\t\t int prev_insn_idx)\n{\n\tstruct verifier_stack_elem *elem;\n\n\telem = kmalloc(sizeof(struct verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\tmemcpy(&elem->st, &env->cur_state, sizeof(env->cur_state));\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\tif (env->stack_size > 1024) {\n\t\tverbose(\"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\t/* pop all elements and return */\n\twhile (pop_stack(env, NULL) >= 0);\n\treturn NULL;\n}\n\n#define CALLER_SAVED_REGS 6\nstatic const int caller_saved[CALLER_SAVED_REGS] = {\n\tBPF_REG_0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5\n};\n\nstatic void init_reg_state(struct reg_state *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tregs[i].type = NOT_INIT;\n\t\tregs[i].imm = 0;\n\t\tregs[i].map_ptr = NULL;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = FRAME_PTR;\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n}\n\nstatic void mark_reg_unknown_value(struct reg_state *regs, u32 regno)\n{\n\tBUG_ON(regno >= MAX_BPF_REG);\n\tregs[regno].type = UNKNOWN_VALUE;\n\tregs[regno].imm = 0;\n\tregs[regno].map_ptr = NULL;\n}\n\nenum reg_arg_type {\n\tSRC_OP,\t\t/* register is used as source operand */\n\tDST_OP,\t\t/* register is used as destination operand */\n\tDST_OP_NO_MARK\t/* same as above, check only, don't mark */\n};\n\nstatic int check_reg_arg(struct reg_state *regs, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(\"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t == SRC_OP) {\n\t\t/* check whether register used as source operand can be read */\n\t\tif (regs[regno].type == NOT_INIT) {\n\t\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\t/* check whether register used as dest operand can be written to */\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(\"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown_value(regs, regno);\n\t}\n\treturn 0;\n}\n\nstatic int bpf_size_to_bytes(int bpf_size)\n{\n\tif (bpf_size == BPF_W)\n\t\treturn 4;\n\telse if (bpf_size == BPF_H)\n\t\treturn 2;\n\telse if (bpf_size == BPF_B)\n\t\treturn 1;\n\telse if (bpf_size == BPF_DW)\n\t\treturn 8;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic bool is_spillable_regtype(enum bpf_reg_type type)\n{\n\tswitch (type) {\n\tcase PTR_TO_MAP_VALUE:\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_CTX:\n\tcase FRAME_PTR:\n\tcase CONST_PTR_TO_MAP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* check_stack_read/write functions track spill/fill of registers,\n * stack boundary and alignment are checked in check_mem_access()\n */\nstatic int check_stack_write(struct verifier_state *state, int off, int size,\n\t\t\t     int value_regno)\n{\n\tint i;\n\t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n\t * so it's aligned access and [off, off + size) are within stack limits\n\t */\n\n\tif (value_regno >= 0 &&\n\t    is_spillable_regtype(state->regs[value_regno].type)) {\n\n\t\t/* register containing pointer is being spilled into stack */\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* save register state */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\tstate->regs[value_regno];\n\n\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_SPILL;\n\t} else {\n\t\t/* regular write of data into stack */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\t(struct reg_state) {};\n\n\t\tfor (i = 0; i < size; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_MISC;\n\t}\n\treturn 0;\n}\n\nstatic int check_stack_read(struct verifier_state *state, int off, int size,\n\t\t\t    int value_regno)\n{\n\tu8 *slot_type;\n\tint i;\n\n\tslot_type = &state->stack_slot_type[MAX_BPF_STACK + off];\n\n\tif (slot_type[0] == STACK_SPILL) {\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfor (i = 1; i < BPF_REG_SIZE; i++) {\n\t\t\tif (slot_type[i] != STACK_SPILL) {\n\t\t\t\tverbose(\"corrupted spill memory\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >= 0)\n\t\t\t/* restore register state from stack */\n\t\t\tstate->regs[value_regno] =\n\t\t\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE];\n\t\treturn 0;\n\t} else {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (slot_type[i] != STACK_MISC) {\n\t\t\t\tverbose(\"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\t\toff, i, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t\tif (value_regno >= 0)\n\t\t\t/* have read misc data from the stack */\n\t\t\tmark_reg_unknown_value(state->regs, value_regno);\n\t\treturn 0;\n\t}\n}\n\n/* check read/write into map element returned by bpf_map_lookup_elem() */\nstatic int check_map_access(struct verifier_env *env, u32 regno, int off,\n\t\t\t    int size)\n{\n\tstruct bpf_map *map = env->cur_state.regs[regno].map_ptr;\n\n\tif (off < 0 || off + size > map->value_size) {\n\t\tverbose(\"invalid access to map value, value_size=%d off=%d size=%d\\n\",\n\t\t\tmap->value_size, off, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n/* check access to 'struct bpf_context' fields */\nstatic int check_ctx_access(struct verifier_env *env, int off, int size,\n\t\t\t    enum bpf_access_type t)\n{\n\tif (env->prog->aux->ops->is_valid_access &&\n\t    env->prog->aux->ops->is_valid_access(off, size, t))\n\t\treturn 0;\n\n\tverbose(\"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}\n\nstatic bool is_pointer_value(struct verifier_env *env, int regno)\n{\n\tif (env->allow_ptr_leaks)\n\t\treturn false;\n\n\tswitch (env->cur_state.regs[regno].type) {\n\tcase UNKNOWN_VALUE:\n\tcase CONST_IMM:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\n/* check whether memory at (regno + off) is accessible for t = (read | write)\n * if t==write, value_regno is a register which value is stored into memory\n * if t==read, value_regno is a register which will receive the value from memory\n * if t==write && value_regno==-1, some unknown value is stored into memory\n * if t==read && value_regno==-1, don't care what we read from memory\n */\nstatic int check_mem_access(struct verifier_env *env, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tint size, err = 0;\n\n\tif (state->regs[regno].type == PTR_TO_STACK)\n\t\toff += state->regs[regno].imm;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\tif (off % size != 0) {\n\t\tverbose(\"misaligned access off %d size %d\\n\", off, size);\n\t\treturn -EACCES;\n\t}\n\n\tif (state->regs[regno].type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access(env, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value(state->regs, value_regno);\n\n\t} else if (state->regs[regno].type == PTR_TO_CTX) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, off, size, t);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value(state->regs, value_regno);\n\n\t} else if (state->regs[regno].type == FRAME_PTR ||\n\t\t   state->regs[regno].type == PTR_TO_STACK) {\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(\"invalid stack off=%d size=%d\\n\", off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE) {\n\t\t\tif (!env->allow_ptr_leaks &&\n\t\t\t    state->stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &&\n\t\t\t    size != BPF_REG_SIZE) {\n\t\t\t\tverbose(\"attempt to corrupt spilled pointer on stack\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\terr = check_stack_write(state, off, size, value_regno);\n\t\t} else {\n\t\t\terr = check_stack_read(state, off, size, value_regno);\n\t\t}\n\t} else {\n\t\tverbose(\"R%d invalid mem access '%s'\\n\",\n\t\t\tregno, reg_type_str[state->regs[regno].type]);\n\t\treturn -EACCES;\n\t}\n\treturn err;\n}\n\nstatic int check_xadd(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif ((BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) ||\n\t    insn->imm != 0) {\n\t\tverbose(\"BPF_XADD uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check src1 operand */\n\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can read the memory */\n\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t       BPF_SIZE(insn->code), BPF_READ, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can write into the same memory */\n\treturn check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\tBPF_SIZE(insn->code), BPF_WRITE, -1);\n}\n\n/* when register 'regno' is passed into function that will read 'access_size'\n * bytes from that pointer, make sure that it's within stack boundary\n * and all elements of stack are initialized\n */\nstatic int check_stack_boundary(struct verifier_env *env,\n\t\t\t\tint regno, int access_size)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tstruct reg_state *regs = state->regs;\n\tint off, i;\n\n\tif (regs[regno].type != PTR_TO_STACK)\n\t\treturn -EACCES;\n\n\toff = regs[regno].imm;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size <= 0) {\n\t\tverbose(\"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tif (state->stack_slot_type[MAX_BPF_STACK + off + i] != STACK_MISC) {\n\t\t\tverbose(\"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_func_arg(struct verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type, struct bpf_map **mapp)\n{\n\tstruct reg_state *reg = env->cur_state.regs + regno;\n\tenum bpf_reg_type expected_type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\tif (reg->type == NOT_INIT) {\n\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(\"R%d leaks addr into helper function\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_STACK || arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t} else if (arg_type == ARG_CONST_STACK_SIZE) {\n\t\texpected_type = CONST_IMM;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t} else {\n\t\tverbose(\"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (reg->type != expected_type) {\n\t\tverbose(\"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[reg->type], reg_type_str[expected_type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\t*mapp = reg->map_ptr;\n\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!*mapp) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(\"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_stack_boundary(env, regno, (*mapp)->key_size);\n\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!*mapp) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_stack_boundary(env, regno, (*mapp)->value_size);\n\n\t} else if (arg_type == ARG_CONST_STACK_SIZE) {\n\t\t/* bpf_xxx(..., buf, len) call will access 'len' bytes\n\t\t * from stack pointer 'buf'. Check it\n\t\t * note: regno == len, regno - 1 == buf\n\t\t */\n\t\tif (regno == 0) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"ARG_CONST_STACK_SIZE cannot be first argument\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_stack_boundary(env, regno - 1, reg->imm);\n\t}\n\n\treturn err;\n}\n\nstatic int check_map_func_compatibility(struct bpf_map *map, int func_id)\n{\n\tbool bool_map, bool_func;\n\tint i;\n\n\tif (!map)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(func_limit); i++) {\n\t\tbool_map = (map->map_type == func_limit[i].map_type);\n\t\tbool_func = (func_id == func_limit[i].func_id);\n\t\t/* only when map & func pair match it can continue.\n\t\t * don't allow any other map type to be passed into\n\t\t * the special func;\n\t\t */\n\t\tif (bool_func && bool_map != bool_func)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_call(struct verifier_env *env, int func_id)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tconst struct bpf_func_proto *fn = NULL;\n\tstruct reg_state *regs = state->regs;\n\tstruct bpf_map *map = NULL;\n\tstruct reg_state *reg;\n\tint i, err;\n\n\t/* find function prototype */\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(\"invalid func %d\\n\", func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->prog->aux->ops->get_func_proto)\n\t\tfn = env->prog->aux->ops->get_func_proto(func_id);\n\n\tif (!fn) {\n\t\tverbose(\"unknown func %d\\n\", func_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(\"cannot call GPL only function from proprietary program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check args */\n\terr = check_func_arg(env, BPF_REG_1, fn->arg1_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_2, fn->arg2_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_3, fn->arg3_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_4, fn->arg4_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_5, fn->arg5_type, &map);\n\tif (err)\n\t\treturn err;\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* update return register */\n\tif (fn->ret_type == RET_INTEGER) {\n\t\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\t} else if (fn->ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (map == NULL) {\n\t\t\tverbose(\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = map;\n\t} else {\n\t\tverbose(\"unknown return type %d of func %d\\n\",\n\t\t\tfn->ret_type, func_id);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_map_func_compatibility(map, func_id);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/* check validity of 32-bit and 64-bit arithmetic operations */\nstatic int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(\"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64)) {\n\t\t\t\tverbose(\"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t} else {\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tregs[insn->dst_reg].type = UNKNOWN_VALUE;\n\t\t\t\tregs[insn->dst_reg].map_ptr = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(\"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tbool stack_relative = false;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(\"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(\"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* pattern match 'bpf_add Rx, imm' instruction */\n\t\tif (opcode == BPF_ADD && BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t    regs[insn->dst_reg].type == FRAME_PTR &&\n\t\t    BPF_SRC(insn->code) == BPF_K) {\n\t\t\tstack_relative = true;\n\t\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t} else if (BPF_SRC(insn->code) == BPF_X &&\n\t\t\t   is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (stack_relative) {\n\t\t\tregs[insn->dst_reg].type = PTR_TO_STACK;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_cond_jmp_op(struct verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tstruct verifier_state *other_branch;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode > BPF_EXIT) {\n\t\tverbose(\"invalid BPF_JMP opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* detect if R == 0 where R was initialized to zero earlier */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    regs[insn->dst_reg].type == CONST_IMM &&\n\t    regs[insn->dst_reg].imm == insn->imm) {\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* if (imm == imm) goto pc+off;\n\t\t\t * only follow the goto, ignore fall-through\n\t\t\t */\n\t\t\t*insn_idx += insn->off;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* if (imm != imm) goto pc+off;\n\t\t\t * only follow fall-through branch, since\n\t\t\t * that's where the program will go\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\n\t/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ ||\n\t\t\t       opcode == BPF_JNE) &&\n\t    regs[insn->dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* next fallthrough insn can access memory via\n\t\t\t * this register\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = PTR_TO_MAP_VALUE;\n\t\t\t/* branch targer cannot access it, since reg == 0 */\n\t\t\tother_branch->regs[insn->dst_reg].type = CONST_IMM;\n\t\t\tother_branch->regs[insn->dst_reg].imm = 0;\n\t\t} else {\n\t\t\tother_branch->regs[insn->dst_reg].type = PTR_TO_MAP_VALUE;\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = 0;\n\t\t}\n\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(\"R%d pointer comparison prohibited\\n\", insn->dst_reg);\n\t\treturn -EACCES;\n\t} else if (BPF_SRC(insn->code) == BPF_K &&\n\t\t   (opcode == BPF_JEQ || opcode == BPF_JNE)) {\n\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* detect if (R == imm) goto\n\t\t\t * and in the target state recognize that R = imm\n\t\t\t */\n\t\t\tother_branch->regs[insn->dst_reg].type = CONST_IMM;\n\t\t\tother_branch->regs[insn->dst_reg].imm = insn->imm;\n\t\t} else {\n\t\t\t/* detect if (R != imm) goto\n\t\t\t * and in the fall-through state recognize that R = imm\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t}\n\t}\n\tif (log_level)\n\t\tprint_verifier_state(env);\n\treturn 0;\n}\n\n/* return the map pointer stored inside BPF_LD_IMM64 instruction */\nstatic struct bpf_map *ld_imm64_to_map_ptr(struct bpf_insn *insn)\n{\n\tu64 imm64 = ((u64) (u32) insn[0].imm) | ((u64) (u32) insn[1].imm) << 32;\n\n\treturn (struct bpf_map *) (unsigned long) imm64;\n}\n\n/* verify BPF_LD_IMM64 instruction */\nstatic int check_ld_imm(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif (BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(\"invalid BPF_LD_IMM insn\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (insn->off != 0) {\n\t\tverbose(\"BPF_LD_IMM64 uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (insn->src_reg == 0)\n\t\t/* generic move 64-bit immediate into a register */\n\t\treturn 0;\n\n\t/* replace_map_fd_with_map_ptr() should have caught bad ld_imm64 */\n\tBUG_ON(insn->src_reg != BPF_PSEUDO_MAP_FD);\n\n\tregs[insn->dst_reg].type = CONST_PTR_TO_MAP;\n\tregs[insn->dst_reg].map_ptr = ld_imm64_to_map_ptr(insn);\n\treturn 0;\n}\n\nstatic bool may_access_skb(enum bpf_prog_type type)\n{\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_SOCKET_FILTER:\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* verify safety of LD_ABS|LD_IND instructions:\n * - they can only appear in the programs where ctx == skb\n * - since they are wrappers of function calls, they scratch R1-R5 registers,\n *   preserve R6-R9, and store return value into R0\n *\n * Implicit input:\n *   ctx == skb == R6 == CTX\n *\n * Explicit input:\n *   SRC == any register\n *   IMM == 32-bit immediate\n *\n * Output:\n *   R0 - 8/16/32-bit skb data converted to cpu endianness\n */\nstatic int check_ld_abs(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->cur_state.regs;\n\tu8 mode = BPF_MODE(insn->code);\n\tstruct reg_state *reg;\n\tint i, err;\n\n\tif (!may_access_skb(env->prog->type)) {\n\t\tverbose(\"BPF_LD_ABS|IND instructions not allowed for this program type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (insn->dst_reg != BPF_REG_0 || insn->off != 0 ||\n\t    (mode == BPF_ABS && insn->src_reg != BPF_REG_0)) {\n\t\tverbose(\"BPF_LD_ABS uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check whether implicit source operand (register R6) is readable */\n\terr = check_reg_arg(regs, BPF_REG_6, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (regs[BPF_REG_6].type != PTR_TO_CTX) {\n\t\tverbose(\"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == BPF_IND) {\n\t\t/* check explicit source operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reset caller saved regs to unreadable */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* mark destination R0 register as readable, since it contains\n\t * the value fetched from the packet\n\t */\n\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\treturn 0;\n}\n\n/* non-recursive DFS pseudo code\n * 1  procedure DFS-iterative(G,v):\n * 2      label v as discovered\n * 3      let S be a stack\n * 4      S.push(v)\n * 5      while S is not empty\n * 6            t <- S.pop()\n * 7            if t is what we're looking for:\n * 8                return t\n * 9            for all edges e in G.adjacentEdges(t) do\n * 10               if edge e is already labelled\n * 11                   continue with the next edge\n * 12               w <- G.adjacentVertex(t,e)\n * 13               if vertex w is not discovered and not explored\n * 14                   label e as tree-edge\n * 15                   label w as discovered\n * 16                   S.push(w)\n * 17                   continue at 5\n * 18               else if vertex w is discovered\n * 19                   label e as back-edge\n * 20               else\n * 21                   // vertex w is explored\n * 22                   label e as forward- or cross-edge\n * 23           label t as explored\n * 24           S.pop()\n *\n * convention:\n * 0x10 - discovered\n * 0x11 - discovered and fall-through edge labelled\n * 0x12 - discovered and fall-through and branch edges labelled\n * 0x20 - explored\n */\n\nenum {\n\tDISCOVERED = 0x10,\n\tEXPLORED = 0x20,\n\tFALLTHROUGH = 1,\n\tBRANCH = 2,\n};\n\n#define STATE_LIST_MARK ((struct verifier_state_list *) -1L)\n\nstatic int *insn_stack;\t/* stack of insns to process */\nstatic int cur_stack;\t/* current stack index */\nstatic int *insn_state;\n\n/* t, w, e - match pseudo-code above:\n * t - index of current instruction\n * w - next instruction\n * e - edge\n */\nstatic int push_insn(int t, int w, int e, struct verifier_env *env)\n{\n\tif (e == FALLTHROUGH && insn_state[t] >= (DISCOVERED | FALLTHROUGH))\n\t\treturn 0;\n\n\tif (e == BRANCH && insn_state[t] >= (DISCOVERED | BRANCH))\n\t\treturn 0;\n\n\tif (w < 0 || w >= env->prog->len) {\n\t\tverbose(\"jump out of range from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e == BRANCH)\n\t\t/* mark branch target for state pruning */\n\t\tenv->explored_states[w] = STATE_LIST_MARK;\n\n\tif (insn_state[w] == 0) {\n\t\t/* tree-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t\tinsn_state[w] = DISCOVERED;\n\t\tif (cur_stack >= env->prog->len)\n\t\t\treturn -E2BIG;\n\t\tinsn_stack[cur_stack++] = w;\n\t\treturn 1;\n\t} else if ((insn_state[w] & 0xF0) == DISCOVERED) {\n\t\tverbose(\"back-edge from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t} else if (insn_state[w] == EXPLORED) {\n\t\t/* forward- or cross-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t} else {\n\t\tverbose(\"insn state internal bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* non-recursive depth-first-search to detect loops in BPF program\n * loop == back-edge in directed graph\n */\nstatic int check_cfg(struct verifier_env *env)\n{\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint ret = 0;\n\tint i, t;\n\n\tinsn_state = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_state)\n\t\treturn -ENOMEM;\n\n\tinsn_stack = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_stack) {\n\t\tkfree(insn_state);\n\t\treturn -ENOMEM;\n\t}\n\n\tinsn_state[0] = DISCOVERED; /* mark 1st insn as discovered */\n\tinsn_stack[0] = 0; /* 0 is the first instruction */\n\tcur_stack = 1;\n\npeek_stack:\n\tif (cur_stack == 0)\n\t\tgoto check_state;\n\tt = insn_stack[cur_stack - 1];\n\n\tif (BPF_CLASS(insns[t].code) == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insns[t].code);\n\n\t\tif (opcode == BPF_EXIT) {\n\t\t\tgoto mark_explored;\n\t\t} else if (opcode == BPF_CALL) {\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t} else if (opcode == BPF_JA) {\n\t\t\tif (BPF_SRC(insns[t].code) != BPF_K) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t/* unconditional jump with single edge */\n\t\t\tret = push_insn(t, t + insns[t].off + 1,\n\t\t\t\t\tFALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\t/* tell verifier to check for equivalent states\n\t\t\t * after every call and jump\n\t\t\t */\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->explored_states[t + 1] = STATE_LIST_MARK;\n\t\t} else {\n\t\t\t/* conditional jump with two edges */\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\n\t\t\tret = push_insn(t, t + insns[t].off + 1, BRANCH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t}\n\t} else {\n\t\t/* all other non-branch instructions with single\n\t\t * fall-through edge\n\t\t */\n\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\tif (ret == 1)\n\t\t\tgoto peek_stack;\n\t\telse if (ret < 0)\n\t\t\tgoto err_free;\n\t}\n\nmark_explored:\n\tinsn_state[t] = EXPLORED;\n\tif (cur_stack-- <= 0) {\n\t\tverbose(\"pop stack internal bug\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_free;\n\t}\n\tgoto peek_stack;\n\ncheck_state:\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (insn_state[i] != EXPLORED) {\n\t\t\tverbose(\"unreachable insn %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\tret = 0; /* cfg looks good */\n\nerr_free:\n\tkfree(insn_state);\n\tkfree(insn_stack);\n\treturn ret;\n}\n\n/* compare two verifier states\n *\n * all states stored in state_list are known to be valid, since\n * verifier reached 'bpf_exit' instruction through them\n *\n * this function is called when verifier exploring different branches of\n * execution popped from the state stack. If it sees an old state that has\n * more strict register state and more strict stack state then this execution\n * branch doesn't need to be explored further, since verifier already\n * concluded that more strict state leads to valid finish.\n *\n * Therefore two states are equivalent if register state is more conservative\n * and explored stack state is more conservative than the current one.\n * Example:\n *       explored                   current\n * (slot1=INV slot2=MISC) == (slot1=MISC slot2=MISC)\n * (slot1=MISC slot2=MISC) != (slot1=INV slot2=MISC)\n *\n * In other words if current stack state (one being explored) has more\n * valid slots than old one that already passed validation, it means\n * the verifier can stop exploring and conclude that current state is valid too\n *\n * Similarly with registers. If explored state has register type as invalid\n * whereas register type in current state is meaningful, it means that\n * the current state will reach 'bpf_exit' instruction safely\n */\nstatic bool states_equal(struct verifier_state *old, struct verifier_state *cur)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tif (memcmp(&old->regs[i], &cur->regs[i],\n\t\t\t   sizeof(old->regs[0])) != 0) {\n\t\t\tif (old->regs[i].type == NOT_INIT ||\n\t\t\t    (old->regs[i].type == UNKNOWN_VALUE &&\n\t\t\t     cur->regs[i].type != NOT_INIT))\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_BPF_STACK; i++) {\n\t\tif (old->stack_slot_type[i] == STACK_INVALID)\n\t\t\tcontinue;\n\t\tif (old->stack_slot_type[i] != cur->stack_slot_type[i])\n\t\t\t/* Ex: old explored (safe) state has STACK_SPILL in\n\t\t\t * this stack slot, but current has has STACK_MISC ->\n\t\t\t * this verifier states are not equivalent,\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\tif (i % BPF_REG_SIZE)\n\t\t\tcontinue;\n\t\tif (memcmp(&old->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   &cur->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   sizeof(old->spilled_regs[0])))\n\t\t\t/* when explored and current stack slot types are\n\t\t\t * the same, check that stored pointers types\n\t\t\t * are the same as well.\n\t\t\t * Ex: explored safe path could have stored\n\t\t\t * (struct reg_state) {.type = PTR_TO_STACK, .imm = -8}\n\t\t\t * but current path has stored:\n\t\t\t * (struct reg_state) {.type = PTR_TO_STACK, .imm = -16}\n\t\t\t * such verifier states are not equivalent.\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\telse\n\t\t\tcontinue;\n\t}\n\treturn true;\n}\n\nstatic int is_state_visited(struct verifier_env *env, int insn_idx)\n{\n\tstruct verifier_state_list *new_sl;\n\tstruct verifier_state_list *sl;\n\n\tsl = env->explored_states[insn_idx];\n\tif (!sl)\n\t\t/* this 'insn_idx' instruction wasn't marked, so we will not\n\t\t * be doing state search here\n\t\t */\n\t\treturn 0;\n\n\twhile (sl != STATE_LIST_MARK) {\n\t\tif (states_equal(&sl->state, &env->cur_state))\n\t\t\t/* reached equivalent register/stack state,\n\t\t\t * prune the search\n\t\t\t */\n\t\t\treturn 1;\n\t\tsl = sl->next;\n\t}\n\n\t/* there were no equivalent states, remember current one.\n\t * technically the current state is not proven to be safe yet,\n\t * but it will either reach bpf_exit (which means it's safe) or\n\t * it will be rejected. Since there are no loops, we won't be\n\t * seeing this 'insn_idx' instruction again on the way to bpf_exit\n\t */\n\tnew_sl = kmalloc(sizeof(struct verifier_state_list), GFP_USER);\n\tif (!new_sl)\n\t\treturn -ENOMEM;\n\n\t/* add new state to the head of linked list */\n\tmemcpy(&new_sl->state, &env->cur_state, sizeof(env->cur_state));\n\tnew_sl->next = env->explored_states[insn_idx];\n\tenv->explored_states[insn_idx] = new_sl;\n\treturn 0;\n}\n\nstatic int do_check(struct verifier_env *env)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct reg_state *regs = state->regs;\n\tint insn_cnt = env->prog->len;\n\tint insn_idx, prev_insn_idx = 0;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tinit_reg_state(regs);\n\tinsn_idx = 0;\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (insn_idx >= insn_cnt) {\n\t\t\tverbose(\"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tinsn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > 32768) {\n\t\t\tverbose(\"BPF program is too large. Proccessed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(env);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (log_level) {\n\t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(insn);\n\t\t}\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, insn->src_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_READ,\n\t\t\t\t\t       insn->dst_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (BPF_SIZE(insn->code) != BPF_W) {\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (insn->imm == 0) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * use reserved 'imm' field to mark this insn\n\t\t\t\t */\n\t\t\t\tinsn->imm = src_reg_type;\n\n\t\t\t} else if (src_reg_type != insn->imm &&\n\t\t\t\t   (src_reg_type == PTR_TO_CTX ||\n\t\t\t\t    insn->imm == PTR_TO_CTX)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       insn->src_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (insn->imm == 0) {\n\t\t\t\tinsn->imm = dst_reg_type;\n\t\t\t} else if (dst_reg_type != insn->imm &&\n\t\t\t\t   (dst_reg_type == PTR_TO_CTX ||\n\t\t\t\t    insn->imm == PTR_TO_CTX)) {\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(\"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       -1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\terr = check_call(env, insn->imm);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tinsn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(regs, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(\"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\nprocess_bpf_exit:\n\t\t\t\tinsn_idx = pop_stack(env, &prev_insn_idx);\n\t\t\t\tif (insn_idx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tinsn_idx++;\n\t\t\t} else {\n\t\t\t\tverbose(\"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tverbose(\"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn_idx++;\n\t}\n\n\treturn 0;\n}\n\n/* look for pseudo eBPF instructions that access map FDs and\n * replace them with actual map pointers\n */\nstatic int replace_map_fd_with_map_ptr(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(\"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tverbose(\"fd %d is not pointing to valid bpf_map\\n\",\n\t\t\t\t\tinsn->imm);\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\n\t\t\t/* store map pointer inside BPF_LD_IMM64 instruction */\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* remember this map */\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tbpf_map_inc(map, false);\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n\n/* drop refcnt of maps used by the rejected program */\nstatic void release_maps(struct verifier_env *env)\n{\n\tint i;\n\n\tfor (i = 0; i < env->used_map_cnt; i++)\n\t\tbpf_map_put(env->used_maps[i]);\n}\n\n/* convert pseudo BPF_LD_IMM64 into generic BPF_LD_IMM64 */\nstatic void convert_pseudo_ld_imm64(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++)\n\t\tif (insn->code == (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tinsn->src_reg = 0;\n}\n\nstatic void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\n\t\t/* adjust offset of jmps if necessary */\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos + delta && i + insn->off + 1 <= pos + delta)\n\t\t\tinsn->off -= delta;\n\t}\n}\n\n/* convert load instructions that access fields of 'struct __sk_buff'\n * into sequence of instructions that access fields of 'struct sk_buff'\n */\nstatic int convert_ctx_accesses(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tu32 cnt;\n\tint i;\n\tenum bpf_access_type type;\n\n\tif (!env->prog->aux->ops->convert_ctx_access)\n\t\treturn 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_LDX | BPF_MEM | BPF_W))\n\t\t\ttype = BPF_READ;\n\t\telse if (insn->code == (BPF_STX | BPF_MEM | BPF_W))\n\t\t\ttype = BPF_WRITE;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (insn->imm != PTR_TO_CTX) {\n\t\t\t/* clear internal mark */\n\t\t\tinsn->imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcnt = env->prog->aux->ops->\n\t\t\tconvert_ctx_access(type, insn->dst_reg, insn->src_reg,\n\t\t\t\t\t   insn->off, insn_buf, env->prog);\n\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cnt == 1) {\n\t\t\tmemcpy(insn, insn_buf, sizeof(*insn));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* several new insns need to be inserted. Make room for them */\n\t\tinsn_cnt += cnt - 1;\n\t\tnew_prog = bpf_prog_realloc(env->prog,\n\t\t\t\t\t    bpf_prog_size(insn_cnt),\n\t\t\t\t\t    GFP_USER);\n\t\tif (!new_prog)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_prog->len = insn_cnt;\n\n\t\tmemmove(new_prog->insnsi + i + cnt, new_prog->insns + i + 1,\n\t\t\tsizeof(*insn) * (insn_cnt - i - cnt));\n\n\t\t/* copy substitute insns in place of load instruction */\n\t\tmemcpy(new_prog->insnsi + i, insn_buf, sizeof(*insn) * cnt);\n\n\t\t/* adjust branches in the whole program */\n\t\tadjust_branches(new_prog, i, cnt - 1);\n\n\t\t/* keep walking new program and skip insns we just inserted */\n\t\tenv->prog = new_prog;\n\t\tinsn = new_prog->insnsi + i + cnt - 1;\n\t\ti += cnt - 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_states(struct verifier_env *env)\n{\n\tstruct verifier_state_list *sl, *sln;\n\tint i;\n\n\tif (!env->explored_states)\n\t\treturn;\n\n\tfor (i = 0; i < env->prog->len; i++) {\n\t\tsl = env->explored_states[i];\n\n\t\tif (sl)\n\t\t\twhile (sl != STATE_LIST_MARK) {\n\t\t\t\tsln = sl->next;\n\t\t\t\tkfree(sl);\n\t\t\t\tsl = sln;\n\t\t\t}\n\t}\n\n\tkfree(env->explored_states);\n}\n\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tchar __user *log_ubuf = NULL;\n\tstruct verifier_env *env;\n\tint ret = -EINVAL;\n\n\tif ((*prog)->len <= 0 || (*prog)->len > BPF_MAXINSNS)\n\t\treturn -E2BIG;\n\n\t/* 'struct verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->prog = *prog;\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog_level = attr->log_level;\n\t\tlog_ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog_size = attr->log_size;\n\t\tlog_len = 0;\n\n\t\tret = -EINVAL;\n\t\t/* log_* values have to be sane */\n\t\tif (log_size < 128 || log_size > UINT_MAX >> 8 ||\n\t\t    log_level == 0 || log_ubuf == NULL)\n\t\t\tgoto free_env;\n\n\t\tret = -ENOMEM;\n\t\tlog_buf = vmalloc(log_size);\n\t\tif (!log_buf)\n\t\t\tgoto free_env;\n\t} else {\n\t\tlog_level = 0;\n\t}\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, NULL) >= 0);\n\tfree_states(env);\n\n\tif (ret == 0)\n\t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n\t\tret = convert_ctx_accesses(env);\n\n\tif (log_level && log_len >= log_size - 1) {\n\t\tBUG_ON(log_len >= log_size);\n\t\t/* verifier log exceeded user supplied buffer */\n\t\tret = -ENOSPC;\n\t\t/* fall through to return what was recorded */\n\t}\n\n\t/* copy verifier log back to user space including trailing zero */\n\tif (log_level && copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_log_buf;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_log_buf;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nfree_log_buf:\n\tif (log_level)\n\t\tvfree(log_buf);\nfree_env:\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_bpf_prog_info() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\n\tkfree(env);\n\tmutex_unlock(&bpf_verifier_lock);\n\treturn ret;\n}\n"], "filenames": ["kernel/bpf/verifier.c"], "buggy_code_start_loc": [2085], "buggy_code_end_loc": [2086], "fixing_code_start_loc": [2085], "fixing_code_end_loc": [2086], "type": "NVD-CWE-noinfo", "message": "The adjust_branches function in kernel/bpf/verifier.c in the Linux kernel before 4.5 does not consider the delta in the backward-jump case, which allows local users to obtain sensitive information from kernel memory by creating a packet filter and then loading crafted BPF instructions.", "other": {"cve": {"id": "CVE-2016-2383", "sourceIdentifier": "security@debian.org", "published": "2016-04-27T17:59:10.943", "lastModified": "2022-01-31T18:55:04.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The adjust_branches function in kernel/bpf/verifier.c in the Linux kernel before 4.5 does not consider the delta in the backward-jump case, which allows local users to obtain sensitive information from kernel memory by creating a packet filter and then loading crafted BPF instructions."}, {"lang": "es", "value": "La funci\u00f3n adjust_branches en kernel/bpf/verifier.c en el kernel de Linux en versiones anteriores a 4.5 no tiene en cuenta el delta en el caso de salto de retroceso, lo que permite a usuarios locales obtener informaci\u00f3n sensible del kernel de memoria creando un filtro de paquetes y posteriormente cargando instrucciones BPF manipuladas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5.0", "matchCriteriaId": "8B6177A4-8E9B-448D-A6C1-1F88863DE391"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "2BEB8150-FFE5-47FA-A056-9029F00744AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.5.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "1D74F82A-BF09-477E-A12B-6E8ED832486E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.5.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "57CCE12F-9DF0-4378-ABAA-BF94A361E569"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=a1b14d27ed0965838350f1377ff97c93ee383492", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00015.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/02/14/1", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2947-1", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2947-2", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2947-3", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1308452", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a1b14d27ed0965838350f1377ff97c93ee383492", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a1b14d27ed0965838350f1377ff97c93ee383492"}}