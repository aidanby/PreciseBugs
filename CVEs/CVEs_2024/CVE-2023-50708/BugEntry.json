{"buggy_code": ["Yii Framework 2 authclient extension Change Log\n===============================================\n\n2.2.15 under development\n------------------------\n\n- Bug #364: Use issuer claim from OpenID Configuration (radwouters)\n- Enh #367: Throw more specific `ClientErrorResponseException` when the response code in `BaseOAuth::sendRequest()` is a 4xx (rhertogh)\n- Enh GHSA-rw54-6826-c8j5: Improved security for OAuth2 client by requiring an `authCodeVerifier` if PKCE is enabled and clearing it after usage (rhertogh)\n\n\n2.2.14 November 18, 2022\n------------------------\n\n- Bug #351: Unable to set TokenParamKey in OAuth2 config, gets hard overwritten in OAuth2::createToken() (DSTester)\n\n\n2.2.13 September 04, 2022\n-------------------------\n\n- Bug #354: Fix PHP 8.1 deprecated message in BaseOAuth `stripos(): Passing null to parameter #1 ($haystack) of type string is deprecated` (marty-macfly)\n\n\n2.2.12 December 03, 2021\n------------------------\n\n- Bug #330: OpenID Connect client now defaults to `'client_secret_basic'` in case `token_endpoint_auth_methods_supported` isn't specified (rhertogh)\n- Bug #331: OpenID Connect `aud` claim can either be a string or a list of strings (azmeuk)\n- Bug #332: OpenID Connect `aud` nonce is passed from the authentication request to the token request (azmeuk)\n- Bug #339: OpenID Connect client now regenerates a new `nonce` when refreshing the access token (rhertogh)\n- Bug #344: Fix Facebook OAuth 400 error when latin characters are used in App name (pawelkania)\n- Enh #279: Add `AuthAction::$defaultClientId` and `AuthAction::getClientId()` (ditibal)\n- Enh #341: OpenID Connect client now uses access token `'id_token'` claim for `getUserAttributes()` if `userinfo_endpoint` is not available (rhertogh)\n- Enh #342: OpenID Connect client support for JWT in `userinfo_endpoint` response (rhertogh)\n\n\n2.2.11 August 09, 2021\n----------------------\n\n- Enh #318: Add `statusCode` from response to init `InvalidResponseException` in `sendRequest` method of `yii\\authclient\\BaseOAuth` class (vleedev)\n- Enh #327: Use `random_int()` when generating OAuth1 nonce (samdark)\n\n\n2.2.10 May 05, 2021\n-------------------\n\n- Chg #315: Add proof key for code exchange PKCE support to oauth2 (AdeAttwood)\n\n\n2.2.9 November 13, 2020\n-----------------------\n\n- Bug #312: do not refresh access token if it is not expired (albertborsos)\n\n\n2.2.8 November 10, 2020\n-----------------------\n\n- Bug #309: Try to refresh token in `BaseOAuth->beforeApiRequestSend()` if `BaseOAuth->autoRefreshAccessToken = true` instead of throwing \"Invalid access token\" exception (marty-macfly)\n- Bug #311: Fix PHP 8 compatibility (samdark)\n\n\n2.2.7 February 12, 2020\n-----------------------\n\n- Bug #292: Updated GitHub token transfer method according to https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api/#authenticating-using-query-parameters (raidkon)\n\n\n2.2.6 November 19, 2019\n-----------------------\n\n- Bug #288: Default request option for turning off SSL peer verification was removed (Rutger, samdark)\n- Enh #205: Add alternative storage system based on cache component (marty-macfly, tunecino)\n\n\n2.2.5 November 05, 2019\n-----------------------\n\n- Enh #217: Replace spomky-labs/jose by JWT Framework (marty-macfly, smcyr)\n\n\n2.2.4 July 02, 2019\n-------------------\n\n- Enh #276: Bumped VK API version to 5.95, according to developers recommendation (EvgeniyRRU)\n- Enh #278: Keep only selected parameters in default return URLs of OAuth services (albertborsos)\n\n\n2.2.3 June 04, 2019\n-------------------\n\n- Chg #273: `OpenIdConnect::validateClaims()` is now protected (samdark)\n\n\n2.2.2 May 14, 2019\n------------------\n\n- Bug #270: Updated Facebook icon to match brand guidelines (ServerDotBiz)\n\n\n2.2.1 April 23, 2019\n--------------------\n\n- Bug #252: Fix bug when `OAuthToken` is incorrectly instantiated if configuration array has incorrect order (rob006)\n\n\n2.2.0 April 16, 2019\n--------------------\n\n- Bug #266: Updated Google client image (nurielmeni)\n- Bug #267: Upgrade LinkedIn client to v2 (machour)\n\n\n2.1.8 January 28, 2019\n----------------------\n\n- Bug #237: Fix redirect from LinkedIn if user refused to authorize permissions request (jakim)\n- Enh #218: Allow configuring user component in `AuthAction` (samdark, lab362)\n- Enh #258: Use Google Sign-in API instead of Google Plus in `yii\\authclient\\clients\\Google` as Google Plus is deprecated (alexeevdv)\n- Enh #259: Allow to pass buildAuthUrl params to OAuth flows in `AuthAction` (albertborsos)\n\n\n2.1.7 September 20, 2018\n------------------------\n\n- Bug #241: Unset parameter `scope` on `defaultReturnUrl` for `OAuth2` class since it was causing bad request response from Google provider (okiwan)\n\n\n2.1.6 September 07, 2018\n------------------------\n\n- Bug #211: `RsaSha` was not passing `$key` to `openssl_pkey_get_private()` in `generateSignature()` (cfhodges)\n- Bug #220: Make `OpenIdConnect` client send token as bearer auth instead of querystring parameter (lukos)\n- Bug #237: Fixed redirect if user cancels login in auth form (msvit1989)\n- Enh #203: Updated VKontakte client to use API version 5.0 (Shketkol)\n\n\n2.1.5 February 08, 2018\n-----------------------\n\n- Enh #187: URL endpoints for `authUrl` and `tokenUrl` for `yii\\authclient\\clients\\LinkedIn` updated (Felli)\n- Enh #195: `yii\\authclient\\AuthAction` refactored to use `yii\\web\\Application::$request` for request data access (klimov-paul)\n- Enh #196: Added `yii\\authclient\\AuthAction::$cancelCallback` allowing custom handling for authentication cancelation (terales, klimov-paul)\n\n\n2.1.4 November 03, 2017\n-----------------------\n\n- Bug #152: Fixed JavaScript callback generated by `\\yii\\authclient\\widgets\\GooglePlusButton` consider 'immediate_failed' as instant auth error (klimov-paul)\n- Bug: Usage of deprecated `yii\\base\\Object` changed to `yii\\base\\BaseObject` allowing compatibility with PHP 7.2 (klimov-paul)\n- Enh #178: Added `yii\\authclient\\clients\\TwitterOAuth2` supporting 'application-only authentication' workflow for Twitter (klimov-paul)\n- Enh #179: Added `apiVersion` at `yii\\authclient\\clients\\VKontakte` (isudakoff)\n- Enh #185: `yii\\authclient\\clients\\VKontakte::initUserAttributes()` now throws verbose exception on unexpected API response instead of PHP error (klimov-paul)\n\n\n2.1.3 June 23, 2017\n-------------------\n\n- Bug #152: Fixed `\\yii\\authclient\\OAuth1::fetchRequestToken()` skips formatting for `yii\\httpclient\\Request` (klimov-paul)\n- Bug #160: Fixed `\\yii\\authclient\\OAuth1::composeSignatureBaseString()` does not take URL query string into account (klimov-paul)\n- Enh #155: Added `\\yii\\authclient\\OpenIdConnect` supporting [OpenID Connect](https://openid.net/connect/) protocol (klimov-paul)\n- Enh #156: Added `\\yii\\authclient\\signature\\RsaSha` and `\\yii\\authclient\\signature\\HmacSha` supporting general 'SHAwithRSA' and 'HMAC SHA' signature methods (klimov-paul)\n- Enh #157: Added `\\yii\\authclient\\OAuth2::authenticateUserJwt()` supporting authentication via JSON Web Token (JWT) (klimov-paul)\n- Enh #163: Added support for exchanging access token at `yii\\authclient\\clients\\Facebook` (klimov-paul)\n- Enh #163: Added support for client-specific access tokens at `yii\\authclient\\clients\\Facebook` (klimov-paul)\n- Chg #163: `yii\\authclient\\clients\\Facebook::$autoRefreshAccessToken` is now disabled by default (klimov-paul)\n\n\n2.1.2 February 15, 2017\n-----------------------\n\n- Bug #135: Fixed `\\yii\\authclient\\OAuth1::fetchRequestToken()` duplicates auth params in the request body, which may cause error on some OAuth 1.0 providers (klimov-paul)\n- Bug #149: Changed `$` to `jQuery` to prevent global conflicts in widget JavaScript (Ariestattoo)\n- Enh #67: Added `appsecret_proof` generation for the API requests at `yii\\authclient\\clients\\Facebook` (blackhpro, SDKiller, klimov-paul)\n\n\n2.1.1 August 29, 2016\n---------------------\n\n- Bug #128: Fixed `\\yii\\authclient\\BaseClient::createRequest()` does not apply `defaultRequestOptions` and `requestOptions` (klimov-paul)\n- Bug #130: Fixed `\\yii\\authclient\\OAuth1::fetchRequestToken()` unable to unset current access token (klimov-paul)\n- Enh #27: Added `\\yii\\authclient\\OAuth1::authorizationHeaderMethods` option allowing to control request methods, which require authorization header (klimov-paul)\n- Enh #132: URL endpoints for `authUrl` and `tokenUrl` for `yii\\authclient\\clients\\VKontakte` updated (KhristenkoYura)\n\n\n2.1.0 August 04, 2016\n---------------------\n\n- Enh #27: This extension no longer require PHP 'cURL' extension to be installed (klimov-paul)\n- Enh #30: Added support for 'client_credentials' grant type via `\\yii\\authclient\\OAuth2::authenticateClient()` (klimov-paul)\n- Enh #33: Added ability to pass raw request content at `\\yii\\authclient\\BaseOAuth::api()` (klimov-paul)\n- Enh #41: Added support for signature generation from request token at `\\yii\\authclient\\OAuth1::fetchAccessToken()` (klimov-paul)\n- Enh #63: Markup for `\\yii\\authclient\\widgets\\AuthChoice` simplified (klimov-paul)\n- Enh #108: This extension now uses `yii2-httpclient` library for the HTTP requests (klimov-paul)\n- Enh #118: Added support for 'password' grant type via `\\yii\\authclient\\OAuth2::authenticateUser()` (klimov-paul)\n- Enh #121: Auth client 'State Storage' abstraction layer extracted (klimov-paul)\n- Enh #124: Methods `clientLink()` and `renderMainContent()` of `yii\\authclient\\widgets\\AuthChoice` reworked to return HTML instead of echo (klimov-paul)\n- Enh #127: Auth 'state' validation added to `OAuth2` for preventing cross-site request forgery (klimov-paul)\n\n\n2.0.6 July 08, 2016\n-------------------\n\n- Bug #37: Fixed `\\yii\\authclient\\widgets\\AuthChoice` overrides any `<a>` tag click behavior between `begin()` and `end()` methods (klimov-paul)\n- Enh #31: Allow to disable automatic 'refresh access token' requests (klimov-paul)\n- Enh #58: Added support for user attribute request params setup for Twitter (umanamente, klimov-paul)\n- Enh #111: `yii\\authclient\\clients\\GitHub` now retrieves user email even if it is set as 'private' at GitHub account (klimov-paul)\n\n\n2.0.5 September 23, 2015\n------------------------\n\n- Bug #25: `yii\\authclient\\BaseOAuth` now can be used without without `session` application component available (klimov-paul)\n- Enh #40: Added `attributeNames` field to `yii\\authclient\\clients\\Facebook`, which allows definition of attributes list fetched from API (samdark)\n- Chg: #47: Default popup size for `yii\\authclient\\clients\\Facebook` has been increased up to 860x480 (lame07, klimov-paul)\n\n\n2.0.4 May 10, 2015\n------------------\n\n- Bug #7224: Fixed incorrect POST fields composition at `yii\\authclient\\OAuth1` (klimov-paul)\n- Bug #7639: Automatic exception throw on 'error' key presence at `yii\\authclient\\BaseOAuth::processResponse()` removed (klimov-paul)\n- Enh #17: Added `attributeNames` field to `yii\\authclient\\clients\\VKontakte` and `yii\\authclient\\clients\\LinkedIn`, which allows definition of attributes list fetched from API (klimov-paul)\n- Enh #6743: Icon for Google at `yii\\authclient\\widgets\\AuthChoice` fixed to follow the Google Brand guidelines (klimov-paul)\n- Enh #7733: `yii\\authclient\\clients\\VKontakte` now gets attributes from access token also (klimov-paul)\n- Enh #7754: New client `yii\\authclient\\clients\\GooglePlus` added to support Google recommended auth flow (klimov-paul)\n- Chg: #7754: `yii\\authclient\\clients\\GoogleOpenId` is now deprecated because this auth method is no longer supported by Google as of April 20, 2015 (klimov-paul)\n\n\n2.0.3 March 01, 2015\n--------------------\n\n- Enh #6892: Default value of `yii\\authclient\\clients\\Twitter::$authUrl` changed to 'authenticate', allowing usage of previous logged user without request an access (kotchuprik)\n\n\n2.0.2 January 11, 2015\n----------------------\n\n- Bug #6502: Fixed `\\yii\\authclient\\OAuth2::refreshAccessToken()` does not save fetched token (sebathi)\n- Bug #6510: Fixed infinite redirect loop using default `\\yii\\authclient\\AuthAction::cancelUrl` (klimov-paul)\n\n\n2.0.1 December 07, 2014\n-----------------------\n\n- Bug #6000: Fixed CCS for `yii\\authclient\\widgets\\AuthChoice` does not loaded if `popupMode` disabled (klimov-paul)\n\n\n2.0.0 October 12, 2014\n----------------------\n\n- Enh #5135: Added ability to operate nested and complex attributes via `yii\\authclient\\BaseClient::normalizeUserAttributeMap` (zinzinday, klimov-paul)\n\n\n2.0.0-rc September 27, 2014\n---------------------------\n\n- Bug #3633: OpenId return URL comparison advanced to prevent url encode problem (klimov-paul)\n- Bug #4490: `yii\\authclient\\widgets\\AuthChoice` does not preserve initial settings while opening popup (klimov-paul)\n- Bug #5011: OAuth API Response with 20x status were not considered success (ychongsaytc)\n- Enh #3416: VKontakte OAuth support added (klimov-paul)\n- Enh #4076: Request HTTP headers argument added to `yii\\authclient\\BaseOAuth::api()` method (klimov-paul)\n- Enh #4134: `yii\\authclient\\InvalidResponseException` added for tracking invalid remote server response (klimov-paul)\n- Enh #4139: User attributes requesting at GoogleOAuth switched to Google+ API (klimov-paul)\n\n\n2.0.0-beta April 13, 2014\n-------------------------\n\n- Initial release.\n\n\n\n", "<?php\n/**\n * @link https://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license https://www.yiiframework.com/license/\n */\n\nnamespace yii\\authclient;\n\nuse Yii;\nuse yii\\base\\InvalidParamException;\nuse yii\\httpclient\\Request;\nuse yii\\web\\HttpException;\n\n/**\n * OAuth1 serves as a client for the OAuth 1/1.0a flow.\n *\n * In order to acquire access token perform following sequence:\n *\n * ```php\n * use yii\\authclient\\OAuth1;\n * use Yii;\n *\n * // assuming class MyAuthClient extends OAuth1\n * $oauthClient = new MyAuthClient();\n * $requestToken = $oauthClient->fetchRequestToken(); // Get request token\n * $url = $oauthClient->buildAuthUrl($requestToken); // Get authorization URL\n * return Yii::$app->getResponse()->redirect($url); // Redirect to authorization URL\n *\n * // After user returns at our site:\n * $accessToken = $oauthClient->fetchAccessToken(Yii::$app->request->get('oauth_token'), $requestToken); // Upgrade to access token\n * ```\n *\n * @see https://oauth.net/1/\n * https://tools.ietf.org/html/rfc5849\n *\n * @author Paul Klimov <klimov.paul@gmail.com>\n * @since 2.0\n */\nabstract class OAuth1 extends BaseOAuth\n{\n    /**\n     * @var string protocol version.\n     */\n    public $version = '1.0';\n    /**\n     * @var string OAuth consumer key.\n     */\n    public $consumerKey;\n    /**\n     * @var string OAuth consumer secret.\n     */\n    public $consumerSecret;\n    /**\n     * @var string OAuth request token URL.\n     */\n    public $requestTokenUrl;\n    /**\n     * @var string request token HTTP method.\n     */\n    public $requestTokenMethod = 'GET';\n    /**\n     * @var string OAuth access token URL.\n     */\n    public $accessTokenUrl;\n    /**\n     * @var string access token HTTP method.\n     */\n    public $accessTokenMethod = 'GET';\n    /**\n     * @var array|null list of the request methods, which require adding 'Authorization' header.\n     * By default only POST requests will have 'Authorization' header.\n     * You may set this option to `null` in order to make all requests to use 'Authorization' header.\n     * @since 2.1.1\n     */\n    public $authorizationHeaderMethods = ['POST'];\n\n\n    /**\n     * Fetches the OAuth request token.\n     * @param array $params additional request params.\n     * @return OAuthToken request token.\n     */\n    public function fetchRequestToken(array $params = [])\n    {\n        $this->setAccessToken(null);\n        $defaultParams = [\n            'oauth_consumer_key' => $this->consumerKey,\n            'oauth_callback' => $this->getReturnUrl(),\n            //'xoauth_displayname' => Yii::$app->name,\n        ];\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod($this->requestTokenMethod)\n            ->setUrl($this->requestTokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->signRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken([\n            'params' => $response\n        ]);\n        $this->setState('requestToken', $token);\n\n        return $token;\n    }\n\n    /**\n     * Composes user authorization URL.\n     * @param OAuthToken $requestToken OAuth request token.\n     * @param array $params additional request params.\n     * @return string authorize URL\n     * @throws InvalidParamException on failure.\n     */\n    public function buildAuthUrl(OAuthToken $requestToken = null, array $params = [])\n    {\n        if (!is_object($requestToken)) {\n            $requestToken = $this->getState('requestToken');\n            if (!is_object($requestToken)) {\n                throw new InvalidParamException('Request token is required to build authorize URL!');\n            }\n        }\n        $params['oauth_token'] = $requestToken->getToken();\n\n        return $this->composeUrl($this->authUrl, $params);\n    }\n\n    /**\n     * Fetches OAuth access token.\n     * @param string $oauthToken OAuth token returned with redirection back to client.\n     * @param OAuthToken $requestToken OAuth request token.\n     * @param string $oauthVerifier OAuth verifier.\n     * @param array $params additional request params.\n     * @return OAuthToken OAuth access token.\n     * @throws InvalidParamException on failure.\n     * @throws HttpException in case oauth token miss-matches request token.\n     */\n    public function fetchAccessToken($oauthToken = null, OAuthToken $requestToken = null, $oauthVerifier = null, array $params = [])\n    {\n        $incomingRequest = Yii::$app->getRequest();\n\n        if ($oauthToken === null) {\n            $oauthToken = $incomingRequest->get('oauth_token', $incomingRequest->post('oauth_token', $oauthToken));\n        }\n\n        if (!is_object($requestToken)) {\n            $requestToken = $this->getState('requestToken');\n            if (!is_object($requestToken)) {\n                throw new InvalidParamException('Request token is required to fetch access token!');\n            }\n        }\n\n        if (strcmp($requestToken->getToken(), $oauthToken) !== 0) {\n            throw new HttpException(400, 'Invalid auth state parameter.');\n        }\n\n        $this->removeState('requestToken');\n\n        $defaultParams = [\n            'oauth_consumer_key' => $this->consumerKey,\n            'oauth_token' => $requestToken->getToken()\n        ];\n        if ($oauthVerifier === null) {\n            $oauthVerifier = $incomingRequest->get('oauth_verifier', $incomingRequest->post('oauth_verifier'));\n        }\n        if (!empty($oauthVerifier)) {\n            $defaultParams['oauth_verifier'] = $oauthVerifier;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod($this->accessTokenMethod)\n            ->setUrl($this->accessTokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->signRequest($request, $requestToken);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken([\n            'params' => $response\n        ]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function createRequest()\n    {\n        $request = parent::createRequest();\n        $request->on(Request::EVENT_BEFORE_SEND, [$this, 'beforeRequestSend']);\n        return $request;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function createApiRequest()\n    {\n        $request = parent::createApiRequest();\n\n        // ensure correct event handlers order :\n        $request->off(Request::EVENT_BEFORE_SEND, [$this, 'beforeRequestSend']);\n        $request->on(Request::EVENT_BEFORE_SEND, [$this, 'beforeRequestSend']);\n\n        return $request;\n    }\n\n    /**\n     * Handles [[Request::EVENT_BEFORE_SEND]] event.\n     * Ensures every request has been signed up before sending.\n     * @param \\yii\\httpclient\\RequestEvent $event event instance.\n     * @since 2.1\n     */\n    public function beforeRequestSend($event)\n    {\n        $this->signRequest($event->request);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function applyAccessTokenToRequest($request, $accessToken)\n    {\n        $data = $request->getData();\n        $data['oauth_consumer_key'] = $this->consumerKey;\n        $data['oauth_token'] = $accessToken->getToken();\n        $request->setData($data);\n    }\n\n    /**\n     * Gets new auth token to replace expired one.\n     * @param OAuthToken $token expired auth token.\n     * @return OAuthToken new auth token.\n     */\n    public function refreshAccessToken(OAuthToken $token)\n    {\n        // @todo\n        return null;\n    }\n\n    /**\n     * Generates nonce value.\n     * @return string nonce value.\n     */\n    protected function generateNonce()\n    {\n        return md5(microtime() . random_int(0, PHP_INT_MAX));\n    }\n\n    /**\n     * Generates timestamp.\n     * @return int timestamp.\n     */\n    protected function generateTimestamp()\n    {\n        return time();\n    }\n\n    /**\n     * Generate common request params like version, timestamp etc.\n     * @return array common request params.\n     */\n    protected function generateCommonRequestParams()\n    {\n        $params = [\n            'oauth_version' => $this->version,\n            'oauth_nonce' => $this->generateNonce(),\n            'oauth_timestamp' => $this->generateTimestamp(),\n        ];\n\n        return $params;\n    }\n\n    /**\n     * Sign given request with [[signatureMethod]].\n     * @param \\yii\\httpclient\\Request $request request instance.\n     * @param OAuthToken|null $token OAuth token to be used for signature, if not set [[accessToken]] will be used.\n     * @since 2.1 this method is public.\n     */\n    public function signRequest($request, $token = null)\n    {\n        $params = $request->getData();\n\n        if (isset($params['oauth_signature_method']) || $request->hasHeaders() && $request->getHeaders()->has('authorization')) {\n            // avoid double sign of request\n            return;\n        }\n\n        if (empty($params)) {\n            $params = $this->generateCommonRequestParams();\n        } else {\n            $params = array_merge($this->generateCommonRequestParams(), $params);\n        }\n\n        $url = $request->getFullUrl();\n\n        $signatureMethod = $this->getSignatureMethod();\n\n        $params['oauth_signature_method'] = $signatureMethod->getName();\n        $signatureBaseString = $this->composeSignatureBaseString($request->getMethod(), $url, $params);\n        $signatureKey = $this->composeSignatureKey($token);\n        $params['oauth_signature'] = $signatureMethod->generateSignature($signatureBaseString, $signatureKey);\n\n        if ($this->authorizationHeaderMethods === null || in_array(strtoupper($request->getMethod()), array_map('strtoupper', $this->authorizationHeaderMethods), true)) {\n            $authorizationHeader = $this->composeAuthorizationHeader($params);\n            if (!empty($authorizationHeader)) {\n                $request->addHeaders($authorizationHeader);\n\n                // removing authorization header params, avoiding duplicate param server error :\n                foreach ($params as $key => $value) {\n                    if (substr_compare($key, 'oauth', 0, 5) === 0) {\n                        unset($params[$key]);\n                    }\n                }\n            }\n        }\n\n        $request->setData($params);\n    }\n\n    /**\n     * Creates signature base string, which will be signed by [[signatureMethod]].\n     * @param string $method request method.\n     * @param string $url request URL.\n     * @param array $params request params.\n     * @return string base signature string.\n     */\n    protected function composeSignatureBaseString($method, $url, array $params)\n    {\n        if (strpos($url, '?') !== false) {\n            list($url, $queryString) = explode('?', $url, 2);\n            parse_str($queryString, $urlParams);\n            $params = array_merge($urlParams, $params);\n        }\n        unset($params['oauth_signature']);\n        uksort($params, 'strcmp'); // Parameters are sorted by name, using lexicographical byte value ordering. Ref: Spec: 9.1.1\n        $parts = [\n            strtoupper($method),\n            $url,\n            http_build_query($params, '', '&', PHP_QUERY_RFC3986)\n        ];\n        $parts = array_map('rawurlencode', $parts);\n\n        return implode('&', $parts);\n    }\n\n    /**\n     * Composes request signature key.\n     * @param OAuthToken|null $token OAuth token to be used for signature key.\n     * @return string signature key.\n     */\n    protected function composeSignatureKey($token = null)\n    {\n        $signatureKeyParts = [\n            $this->consumerSecret\n        ];\n\n        if ($token === null) {\n            $token = $this->getAccessToken();\n        }\n        if (is_object($token)) {\n            $signatureKeyParts[] = $token->getTokenSecret();\n        } else {\n            $signatureKeyParts[] = '';\n        }\n\n        $signatureKeyParts = array_map('rawurlencode', $signatureKeyParts);\n\n        return implode('&', $signatureKeyParts);\n    }\n\n    /**\n     * Composes authorization header.\n     * @param array $params request params.\n     * @param string $realm authorization realm.\n     * @return array authorization header in format: [name => content].\n     */\n    protected function composeAuthorizationHeader(array $params, $realm = '')\n    {\n        $header = 'OAuth';\n        $headerParams = [];\n        if (!empty($realm)) {\n            $headerParams[] = 'realm=\"' . rawurlencode($realm) . '\"';\n        }\n        foreach ($params as $key => $value) {\n            if (substr_compare($key, 'oauth', 0, 5)) {\n                continue;\n            }\n            $headerParams[] = rawurlencode($key) . '=\"' . rawurlencode($value) . '\"';\n        }\n        if (!empty($headerParams)) {\n            $header .= ' ' . implode(', ', $headerParams);\n        }\n\n        return ['Authorization' => $header];\n    }\n}\n", "<?php\n/**\n * @link https://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license https://www.yiiframework.com/license/\n */\n\nnamespace yii\\authclient;\n\nuse Yii;\nuse yii\\helpers\\Json;\nuse yii\\helpers\\Url;\nuse yii\\web\\HttpException;\n\n/**\n * OAuth2 serves as a client for the OAuth 2 flow.\n *\n * In oder to acquire access token perform following sequence:\n *\n * ```php\n * use yii\\authclient\\OAuth2;\n *\n * // assuming class MyAuthClient extends OAuth2\n * $oauthClient = new MyAuthClient();\n * $url = $oauthClient->buildAuthUrl(); // Build authorization URL\n * Yii::$app->getResponse()->redirect($url); // Redirect to authorization URL.\n * // After user returns at our site:\n * $code = Yii::$app->getRequest()->get('code');\n * $accessToken = $oauthClient->fetchAccessToken($code); // Get access token\n * ```\n *\n * @see https://oauth.net/2/\n * @see https://tools.ietf.org/html/rfc6749\n *\n * @author Paul Klimov <klimov.paul@gmail.com>\n * @since 2.0\n */\nabstract class OAuth2 extends BaseOAuth\n{\n    /**\n     * @var string protocol version.\n     */\n    public $version = '2.0';\n    /**\n     * @var string OAuth client ID.\n     */\n    public $clientId;\n    /**\n     * @var string OAuth client secret.\n     */\n    public $clientSecret;\n    /**\n     * @var string token request URL endpoint.\n     */\n    public $tokenUrl;\n    /**\n     * @var bool whether to use and validate auth 'state' parameter in authentication flow.\n     * If enabled - the opaque value will be generated and applied to auth URL to maintain\n     * state between the request and callback. The authorization server includes this value,\n     * when redirecting the user-agent back to the client.\n     * The option is used for preventing cross-site request forgery.\n     * @since 2.1\n     */\n    public $validateAuthState = true;\n    /**\n     * @var bool Whether to enable proof key for code exchange (PKCE) support and add\n     * a `code_challenge` and `code_verifier` to the auth request.\n     * @since 2.2.10\n     *\n     * @see https://oauth.net/2/pkce/\n     */\n    public $enablePkce = false;\n\n\n    /**\n     * Composes user authorization URL.\n     * @param array $params additional auth GET params.\n     * @return string authorization URL.\n     */\n    public function buildAuthUrl(array $params = [])\n    {\n        $defaultParams = [\n            'client_id' => $this->clientId,\n            'response_type' => 'code',\n            'redirect_uri' => $this->getReturnUrl(),\n            'xoauth_displayname' => Yii::$app->name,\n        ];\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        if ($this->validateAuthState) {\n            $authState = $this->generateAuthState();\n            $this->setState('authState', $authState);\n            $defaultParams['state'] = $authState;\n        }\n\n        if ($this->enablePkce) {\n            $codeVerifier = bin2hex(Yii::$app->security->generateRandomKey(64));\n            $this->setState('authCodeVerifier', $codeVerifier);\n            $defaultParams['code_challenge'] = trim(strtr(base64_encode(hash('sha256', $codeVerifier, true)), '+/', '-_'), '=');\n            $defaultParams['code_challenge_method'] = 'S256';\n        }\n\n        return $this->composeUrl($this->authUrl, array_merge($defaultParams, $params));\n    }\n\n    /**\n     * Fetches access token from authorization code.\n     * @param string $authCode authorization code, usually comes at GET parameter 'code'.\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @throws HttpException on invalid auth state in case [[enableStateValidation]] is enabled.\n     */\n    public function fetchAccessToken($authCode, array $params = [])\n    {\n        if ($this->validateAuthState) {\n            $authState = $this->getState('authState');\n            $incomingRequest = Yii::$app->getRequest();\n            $incomingState = $incomingRequest->get('state', $incomingRequest->post('state'));\n            if (!isset($incomingState) || empty($authState) || strcmp($incomingState, $authState) !== 0) {\n                throw new HttpException(400, 'Invalid auth state parameter.');\n            }\n            $this->removeState('authState');\n        }\n\n        $defaultParams = [\n            'code' => $authCode,\n            'grant_type' => 'authorization_code',\n            'redirect_uri' => $this->getReturnUrl(),\n        ];\n\n        if ($this->enablePkce) {\n            $authCodeVerifier = $this->getState('authCodeVerifier');\n            if (empty($authCodeVerifier)) {\n                // Prevent PKCE Downgrade Attack\n                // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#name-pkce-downgrade-attack\n                throw new HttpException(409, 'Invalid auth code verifier.');\n            }\n            $defaultParams['code_verifier'] = $authCodeVerifier;\n            $this->removeState('authCodeVerifier');\n        }\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n         // Azure AD will complain if there is no `Origin` header.\n        if ($this->enablePkce) {\n            $request->addHeaders(['Origin' => Url::to('/')]);\n        }\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function applyAccessTokenToRequest($request, $accessToken)\n    {\n        $data = $request->getData();\n        $data['access_token'] = $accessToken->getToken();\n        $request->setData($data);\n    }\n\n    /**\n     * Applies client credentials (e.g. [[clientId]] and [[clientSecret]]) to the HTTP request instance.\n     * This method should be invoked before sending any HTTP request, which requires client credentials.\n     * @param \\yii\\httpclient\\Request $request HTTP request instance.\n     * @since 2.1.3\n     */\n    protected function applyClientCredentialsToRequest($request)\n    {\n        $request->addData([\n            'client_id' => $this->clientId,\n            'client_secret' => $this->clientSecret,\n        ]);\n    }\n\n    /**\n     * Gets new auth token to replace expired one.\n     * @param OAuthToken $token expired auth token.\n     * @return OAuthToken new auth token.\n     */\n    public function refreshAccessToken(OAuthToken $token)\n    {\n        $params = [\n            'grant_type' => 'refresh_token'\n        ];\n        $params = array_merge($token->getParams(), $params);\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData($params);\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * Generates the auth state value.\n     * @return string auth state value.\n     * @since 2.1\n     */\n    protected function generateAuthState()\n    {\n        $baseString = get_class($this) . '-' . time();\n        if (Yii::$app->has('session')) {\n            $baseString .= '-' . Yii::$app->session->getId();\n        }\n        return hash('sha256', uniqid($baseString, true));\n    }\n\n    /**\n     * Creates token from its configuration.\n     * @param array $tokenConfig token configuration.\n     * @return OAuthToken token instance.\n     */\n    protected function createToken(array $tokenConfig = [])\n    {\n        $defaultTokenConfig = ['tokenParamKey' => 'access_token'];\n        $tokenConfig = array_merge($defaultTokenConfig, $tokenConfig);\n\n        return parent::createToken($tokenConfig);\n    }\n\n    /**\n     * Authenticate OAuth client directly at the provider without third party (user) involved,\n     * using 'client_credentials' grant type.\n     * @see https://tools.ietf.org/html/rfc6749#section-4.4\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @since 2.1.0\n     */\n    public function authenticateClient($params = [])\n    {\n        $defaultParams = [\n            'grant_type' => 'client_credentials',\n        ];\n\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * Authenticates user directly by 'username/password' pair, using 'password' grant type.\n     * @see https://tools.ietf.org/html/rfc6749#section-4.3\n     * @param string $username user name.\n     * @param string $password user password.\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @since 2.1.0\n     */\n    public function authenticateUser($username, $password, $params = [])\n    {\n        $defaultParams = [\n            'grant_type' => 'password',\n            'username' => $username,\n            'password' => $password,\n        ];\n\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * Authenticates user directly using JSON Web Token (JWT).\n     * @see https://tools.ietf.org/html/rfc7515\n     * @param string $username\n     * @param \\yii\\authclient\\signature\\BaseMethod|array $signature signature method or its array configuration.\n     * If empty - [[signatureMethod]] will be used.\n     * @param array $options additional options. Valid options are:\n     *\n     * - header: array, additional JWS header parameters.\n     * - payload: array, additional JWS payload (message or claim-set) parameters.\n     * - signatureKey: string, signature key to be used, if not set - [[clientSecret]] will be used.\n     *\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @since 2.1.3\n     */\n    public function authenticateUserJwt($username, $signature = null, $options = [], $params = [])\n    {\n        if (empty($signature)) {\n            $signatureMethod = $this->getSignatureMethod();\n        } elseif (is_object($signature)) {\n            $signatureMethod = $signature;\n        } else {\n            $signatureMethod = $this->createSignatureMethod($signature);\n        }\n\n        $header = isset($options['header']) ? $options['header'] : [];\n        $payload = isset($options['payload']) ? $options['payload'] : [];\n\n        $header = array_merge([\n            'typ' => 'JWT'\n        ], $header);\n        if (!isset($header['alg'])) {\n            $signatureName = $signatureMethod->getName();\n            if (preg_match('/^([a-z])[a-z]*\\-([a-z])[a-z]*([0-9]+)$/is', $signatureName, $matches)) {\n                // convert 'RSA-SHA256' to 'RS256' :\n                $signatureName = $matches[1] . $matches[2] . $matches[3];\n            }\n            $header['alg'] = $signatureName;\n        }\n\n        $payload = array_merge([\n            'iss' => $username,\n            'scope' => $this->scope,\n            'aud' => $this->tokenUrl,\n            'iat' => time(),\n        ], $payload);\n        if (!isset($payload['exp'])) {\n            $payload['exp'] = $payload['iat'] + 3600;\n        }\n\n        $signatureBaseString = base64_encode(Json::encode($header)) . '.' . base64_encode(Json::encode($payload));\n        $signatureKey = isset($options['signatureKey']) ? $options['signatureKey'] : $this->clientSecret;\n        $signature = $signatureMethod->generateSignature($signatureBaseString, $signatureKey);\n\n        $assertion = $signatureBaseString . '.' . $signature;\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge([\n                'grant_type' => 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                'assertion' => $assertion,\n            ], $params));\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n}\n", "<?php\n/**\n * @link https://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license https://www.yiiframework.com/license/\n */\n\nnamespace yii\\authclient;\n\nuse Jose\\Component\\Core\\AlgorithmManager;\nuse Jose\\Component\\Checker\\AlgorithmChecker;\nuse Jose\\Component\\Checker\\HeaderCheckerManager;\nuse Jose\\Component\\KeyManagement\\JWKFactory;\nuse Jose\\Component\\Signature\\JWSLoader;\nuse Jose\\Component\\Signature\\JWSTokenSupport;\nuse Jose\\Component\\Signature\\JWSVerifier;\nuse Jose\\Component\\Signature\\Serializer\\CompactSerializer;\nuse Jose\\Component\\Signature\\Serializer\\JWSSerializerManager;\nuse Yii;\nuse yii\\authclient\\signature\\HmacSha;\nuse yii\\base\\InvalidConfigException;\nuse yii\\caching\\Cache;\nuse yii\\di\\Instance;\nuse yii\\helpers\\Json;\nuse yii\\helpers\\StringHelper;\nuse yii\\web\\HttpException;\n\n/**\n * OpenIdConnect serves as a client for the OpenIdConnect flow.\n *\n * Application configuration example:\n *\n * ```php\n * 'components' => [\n *     'authClientCollection' => [\n *         'class' => 'yii\\authclient\\Collection',\n *         'clients' => [\n *             'google' => [\n *                 'class' => 'yii\\authclient\\OpenIdConnect',\n *                 'issuerUrl' => 'https://accounts.google.com',\n *                 'clientId' => 'google_client_id',\n *                 'clientSecret' => 'google_client_secret',\n *                 'name' => 'google',\n *                 'title' => 'Google OpenID Connect',\n *             ],\n *         ],\n *     ]\n *     // ...\n * ]\n * ```\n *\n * This class requires `web-token/jwt-checker`,`web-token/jwt-key-mgmt`, `web-token/jwt-signature`, `web-token/jwt-signature-algorithm-hmac`,\n * `web-token/jwt-signature-algorithm-ecdsa` and `web-token/jwt-signature-algorithm-rsa` libraries to be installed for\n * JWS verification. This can be done via composer:\n *\n * ```\n * composer require --prefer-dist \"web-token/jwt-checker:>=1.0 <3.0\" \"web-token/jwt-signature:>=1.0 <3.0\"\n * \"web-token/jwt-signature:>=1.0 <3.0\" \"web-token/jwt-signature-algorithm-hmac:>=1.0 <3.0\"\n * \"web-token/jwt-signature-algorithm-ecdsa:>=1.0 <3.0\" \"web-token/jwt-signature-algorithm-rsa:>=1.0 <3.0\"\n * ```\n *\n * Note: if you are using well-trusted OpenIdConnect provider, you may disable [[validateJws]], making installation of\n * `web-token` library redundant, however it is not recommended as it violates the protocol specification.\n *\n * @see https://openid.net/connect/\n * @see OAuth2\n *\n * @property Cache|null $cache The cache object, `null` - if not enabled. Note that the type of this property\n * differs in getter and setter. See [[getCache()]] and [[setCache()]] for details.\n * @property array $configParams OpenID provider configuration parameters.\n * @property bool $validateAuthNonce Whether to use and validate auth 'nonce' parameter in authentication\n * flow.\n *\n * @author Paul Klimov <klimov.paul@gmail.com>\n * @since 2.1.3\n */\nclass OpenIdConnect extends OAuth2\n{\n    /**\n     * @var array Predefined OpenID Connect Claims\n     * @see https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.2\n     * @since 2.2.12\n     */\n    public $defaultIdTokenClaims = [\n        'iss', // Issuer Identifier for the Issuer of the response.\n        'sub', // Subject Identifier.\n        'aud', // Audience(s) that this ID Token is intended for.\n        'exp', // Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n        'iat', // Time at which the JWT was issued.\n        'auth_time', // Time when the End-User authentication occurred.\n        'nonce', // String value used to associate a Client session with an ID Token, and to mitigate replay attacks.\n        'acr', // Authentication Context Class Reference.\n        'amr', // Authentication Methods References.\n        'azp', // Authorized party - the party to which the ID Token was issued.\n    ];\n    /**\n     * {@inheritdoc}\n     */\n    public $scope = 'openid';\n    /**\n     * @var string OpenID Issuer (provider) base URL, e.g. `https://example.com`.\n     */\n    public $issuerUrl;\n    /**\n     * @var bool whether to validate/decrypt JWS received with Auth token.\n     * Note: this functionality requires `web-token/jwt-checker`, `web-token/jwt-key-mgmt`, `web-token/jwt-signature`\n     * composer package to be installed. You can disable this option in case of usage of trusted OpenIDConnect provider,\n     * however this violates the protocol rules, so you are doing it on your own risk.\n     */\n    public $validateJws = true;\n    /**\n     * @var array JWS algorithms, which are allowed to be used.\n     * These are used by `web-token` library for JWS validation/decryption.\n     * Make sure to install `web-token/jwt-signature-algorithm-hmac`, `web-token/jwt-signature-algorithm-ecdsa`\n     * and `web-token/jwt-signature-algorithm-rsa` packages that support the particular algorithm before adding it here.\n     */\n    public $allowedJwsAlgorithms = [\n        'HS256', 'HS384', 'HS512',\n        'ES256', 'ES384', 'ES512',\n        'RS256', 'RS384', 'RS512',\n        'PS256', 'PS384', 'PS512'\n    ];\n    /**\n     * @var string the prefix for the key used to store [[configParams]] data in cache.\n     * Actual cache key will be formed addition [[id]] value to it.\n     * @see cache\n     */\n    public $configParamsCacheKeyPrefix = 'config-params-';\n\n    /**\n     * @var bool|null whether to use and validate auth 'nonce' parameter in authentication flow.\n     * The option is used for preventing replay attacks.\n     */\n    private $_validateAuthNonce;\n    /**\n     * @var array OpenID provider configuration parameters.\n     */\n    private $_configParams;\n    /**\n     * @var Cache|string the cache object or the ID of the cache application component that\n     * is used for caching. This can be one of the following:\n     *\n     * - an application component ID (e.g. `cache`)\n     * - a configuration array\n     * - a [[\\yii\\caching\\Cache]] object\n     *\n     * When this is not set, it means caching is not enabled.\n     */\n    private $_cache = 'cache';\n    /**\n     * @var JWSLoader JSON Web Signature\n     */\n    private $_jwsLoader;\n    /**\n     * @var JWKSet Key Set\n     */\n    private $_jwkSet;\n\n\n    /**\n     * @return bool whether to use and validate auth 'nonce' parameter in authentication flow.\n     */\n    public function getValidateAuthNonce()\n    {\n        if ($this->_validateAuthNonce === null) {\n            $this->_validateAuthNonce = $this->validateJws && in_array('nonce', $this->getConfigParam('claims_supported'));\n        }\n        return $this->_validateAuthNonce;\n    }\n\n    /**\n     * @param bool $validateAuthNonce whether to use and validate auth 'nonce' parameter in authentication flow.\n     */\n    public function setValidateAuthNonce($validateAuthNonce)\n    {\n        $this->_validateAuthNonce = $validateAuthNonce;\n    }\n\n    /**\n     * @return Cache|null the cache object, `null` - if not enabled.\n     */\n    public function getCache()\n    {\n        if ($this->_cache !== null && !is_object($this->_cache)) {\n            $this->_cache = Instance::ensure($this->_cache, Cache::className());\n        }\n        return $this->_cache;\n    }\n\n    /**\n     * Sets up a component to be used for caching.\n     * This can be one of the following:\n     *\n     * - an application component ID (e.g. `cache`)\n     * - a configuration array\n     * - a [[\\yii\\caching\\Cache]] object\n     *\n     * When `null` is passed, it means caching is not enabled.\n     * @param Cache|array|string|null $cache the cache object or the ID of the cache application component.\n     */\n    public function setCache($cache)\n    {\n        $this->_cache = $cache;\n    }\n\n    /**\n     * @return array OpenID provider configuration parameters.\n     */\n    public function getConfigParams()\n    {\n        if ($this->_configParams === null) {\n            $cache = $this->getCache();\n            $cacheKey = $this->configParamsCacheKeyPrefix . $this->getId();\n            if ($cache === null || ($configParams = $cache->get($cacheKey)) === false) {\n                $configParams = $this->discoverConfig();\n            }\n\n            $this->_configParams = $configParams;\n\n            if ($cache !== null) {\n                $cache->set($cacheKey, $configParams);\n            }\n        }\n        return $this->_configParams;\n    }\n\n    /**\n     * Returns particular configuration parameter value.\n     * @param string $name configuration parameter name.\n     * @param mixed $default value to be returned if the configuration parameter isn't set.\n     * @return mixed configuration parameter value.\n     */\n    public function getConfigParam($name, $default = null)\n    {\n        $params = $this->getConfigParams();\n        return array_key_exists($name, $params) ? $params[$name] : $default;\n    }\n\n    /**\n     * Discovers OpenID Provider configuration parameters.\n     * @return array OpenID Provider configuration parameters.\n     * @throws InvalidResponseException on failure.\n     */\n    protected function discoverConfig()\n    {\n        $request = $this->createRequest();\n        $configUrl = rtrim($this->issuerUrl, '/') . '/.well-known/openid-configuration';\n        $request->setMethod('GET')\n            ->setUrl($configUrl);\n        $response = $this->sendRequest($request);\n        return $response;\n    }\n\n    /**\n     * Set the OpenID provider configuration manually, this will bypass the automatic discovery via\n     * the /.well-known/openid-configuration endpoint.\n     * @param array $configParams OpenID provider configuration parameters.\n     * @since 2.2.12\n     */\n    public function setConfigParams($configParams)\n    {\n        $this->_configParams = $configParams;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function buildAuthUrl(array $params = [])\n    {\n        if ($this->authUrl === null) {\n            $this->authUrl = $this->getConfigParam('authorization_endpoint');\n        }\n\n        if (!isset($params['nonce']) && $this->getValidateAuthNonce()) {\n            $nonce = $this->generateAuthNonce();\n            $this->setState('authNonce', $nonce);\n            $params['nonce'] = $nonce;\n        }\n\n        return parent::buildAuthUrl($params);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function fetchAccessToken($authCode, array $params = [])\n    {\n        if ($this->tokenUrl === null) {\n            $this->tokenUrl = $this->getConfigParam('token_endpoint');\n        }\n\n        if (!isset($params['nonce']) && $this->getValidateAuthNonce()) {\n            $params['nonce'] = $this->getState('authNonce');\n        }\n\n        return parent::fetchAccessToken($authCode, $params);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function refreshAccessToken(OAuthToken $token)\n    {\n        if ($this->tokenUrl === null) {\n            $this->tokenUrl = $this->getConfigParam('token_endpoint');\n        }\n\n        if ($this->getValidateAuthNonce()) {\n            $nonce = $this->generateAuthNonce();\n            $this->setState('authNonce', $nonce);\n            $token->setParam('nonce', $nonce);\n        }\n\n        return parent::refreshAccessToken($token);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function initUserAttributes()\n    {\n        // Use 'userinfo_endpoint' config if available,\n        // try to extract user claims from access token's 'id_token' claim otherwise.\n\n        $userinfoEndpoint = $this->getConfigParam('userinfo_endpoint');\n        if (!empty($userinfoEndpoint)) {\n            $userInfo = $this->api($userinfoEndpoint, 'GET');\n            // The userinfo endpoint can return a JSON object (which will be converted to an array) or a JWT.\n            if (is_array($userInfo)) {\n                return $userInfo;\n            } else {\n                // Use the userInfo endpoint as id_token and parse it as JWT below\n                $idToken = $userInfo;\n            }\n        } else {\n            $accessToken = $this->accessToken;\n            $idToken = $accessToken->getParam('id_token');\n        }\n\n        $idTokenData = [];\n        if (!empty($idToken)) {\n            if ($this->validateJws) {\n                $idTokenClaims = $this->loadJws($idToken);\n            } else {\n                $idTokenClaims = Json::decode(StringHelper::base64UrlDecode(explode('.', $idToken)[1]));\n            }\n            $metaDataFields = array_flip($this->defaultIdTokenClaims);\n            unset($metaDataFields['sub']); // \"Subject Identifier\" is not meta data\n            $idTokenData = array_diff_key($idTokenClaims, $metaDataFields);\n        }\n\n        return $idTokenData;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function applyAccessTokenToRequest($request, $accessToken)\n    {\n        // OpenID Connect requires bearer token auth for the user info endpoint\n        $request->getHeaders()->set('Authorization', 'Bearer ' . $accessToken->getToken());\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function applyClientCredentialsToRequest($request)\n    {\n        $supportedAuthMethods = $this->getConfigParam('token_endpoint_auth_methods_supported', 'client_secret_basic');\n\n        if (in_array('client_secret_basic', $supportedAuthMethods)) {\n            $request->addHeaders([\n                'Authorization' => 'Basic ' . base64_encode($this->clientId . ':' . $this->clientSecret)\n            ]);\n        } elseif (in_array('client_secret_post', $supportedAuthMethods)) {\n            $request->addData([\n                'client_id' => $this->clientId,\n                'client_secret' => $this->clientSecret,\n            ]);\n        } elseif (in_array('client_secret_jwt', $supportedAuthMethods)) {\n            $header = [\n                'typ' => 'JWT',\n                'alg' => 'HS256',\n            ];\n            $payload = [\n                'iss' => $this->clientId,\n                'sub' => $this->clientId,\n                'aud' => $this->tokenUrl,\n                'jti' => $this->generateAuthNonce(),\n                'iat' => time(),\n                'exp' => time() + 3600,\n            ];\n\n            $signatureBaseString = base64_encode(Json::encode($header)) . '.' . base64_encode(Json::encode($payload));\n            $signatureMethod = new HmacSha(['algorithm' => 'sha256']);\n            $signature = $signatureMethod->generateSignature($signatureBaseString, $this->clientSecret);\n\n            $assertion = $signatureBaseString . '.' . $signature;\n\n            $request->addData([\n                'assertion' => $assertion,\n            ]);\n        } else {\n            throw new InvalidConfigException('Unable to authenticate request: none of following auth methods is suported: ' . implode(', ', $supportedAuthMethods));\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function createToken(array $tokenConfig = [])\n    {\n        if ($this->validateJws) {\n            $jwsData = $this->loadJws($tokenConfig['params']['id_token']);\n            $this->validateClaims($jwsData);\n            $tokenConfig['params'] = array_merge($tokenConfig['params'], $jwsData);\n\n            if ($this->getValidateAuthNonce()) {\n                $authNonce = $this->getState('authNonce');\n                if (!isset($jwsData['nonce']) || empty($authNonce) || strcmp($jwsData['nonce'], $authNonce) !== 0) {\n                    throw new HttpException(400, 'Invalid auth nonce');\n                } else {\n                    $this->removeState('authNonce');\n                }\n            }\n        }\n\n        return parent::createToken($tokenConfig);\n    }\n\n    /**\n     * Return JwkSet, returning related data.\n     * @return JWKSet object represents a key set.\n     * @throws InvalidResponseException on failure.\n     */\n    protected function getJwkSet()\n    {\n        if ($this->_jwkSet === null) {\n            $cache = $this->getCache();\n            $cacheKey = $this->configParamsCacheKeyPrefix . '_jwkSet';\n            if ($cache === null || ($jwkSet = $cache->get($cacheKey)) === false) {\n                $request = $this->createRequest()\n                    ->setMethod('GET')\n                    ->setUrl($this->getConfigParam('jwks_uri'));\n                $response = $this->sendRequest($request);\n                $jwkSet = JWKFactory::createFromValues($response);\n            }\n\n            $this->_jwkSet = $jwkSet;\n\n            if ($cache !== null) {\n                $cache->set($cacheKey, $jwkSet);\n            }\n        }\n        return $this->_jwkSet;\n    }\n\n    /**\n     * Return JWSLoader that validate the JWS token.\n     * @return JWSLoader to do token validation.\n     * @throws InvalidConfigException on invalid algorithm provide in configuration.\n     */\n    protected function getJwsLoader()\n    {\n        if ($this->_jwsLoader === null) {\n            $algorithms = [];\n            foreach ($this->allowedJwsAlgorithms as $algorithm)\n            {\n                $class = '\\Jose\\Component\\Signature\\Algorithm\\\\' . $algorithm;\n                if (!class_exists($class))\n                {\n                    throw new InvalidConfigException(\"Alogrithm class $class doesn't exist\");\n                }\n                $algorithms[] = new $class();\n            }\n            $this->_jwsLoader = new JWSLoader(\n                new JWSSerializerManager([ new CompactSerializer() ]),\n                new JWSVerifier(new AlgorithmManager($algorithms)),\n                new HeaderCheckerManager(\n                    [ new AlgorithmChecker($this->allowedJwsAlgorithms) ],\n                    [ new JWSTokenSupport() ]\n                )\n            );\n        }\n        return $this->_jwsLoader;\n    }\n\n    /**\n     * Decrypts/validates JWS, returning related data.\n     * @param string $jws raw JWS input.\n     * @return array JWS underlying data.\n     * @throws HttpException on invalid JWS signature.\n     */\n    protected function loadJws($jws)\n    {\n        try {\n            $jwsLoader = $this->getJwsLoader();\n            $signature = null;\n            $jwsVerified = $jwsLoader->loadAndVerifyWithKeySet($jws, $this->getJwkSet(), $signature);\n            return Json::decode($jwsVerified->getPayload());\n        } catch (\\Exception $e) {\n            $message = YII_DEBUG ? 'Unable to verify JWS: ' . $e->getMessage() : 'Invalid JWS';\n            throw new HttpException(400, $message, $e->getCode(), $e);\n        }\n    }\n\n    /**\n     * Validates the claims data received from OpenID provider.\n     * @param array $claims claims data.\n     * @throws HttpException on invalid claims.\n     * @since 2.2.3\n     */\n    protected function validateClaims(array $claims)\n    {\n        $expectedIssuer = $this->getConfigParam('issuer', $this->issuerUrl);\n        if (!isset($claims['iss']) || (strcmp(rtrim($claims['iss'], '/'), rtrim($expectedIssuer, '/')) !== 0)) {\n            throw new HttpException(400, 'Invalid \"iss\"');\n        }\n        if (!isset($claims['aud'])\n            || (!is_string($claims['aud']) && !is_array($claims['aud']))\n            || (is_string($claims['aud']) && strcmp($claims['aud'], $this->clientId) !== 0)\n            || (is_array($claims['aud']) && !in_array($this->clientId, $claims['aud']))\n        ) {\n            throw new HttpException(400, 'Invalid \"aud\"');\n        }\n    }\n\n    /**\n     * Generates the auth nonce value.\n     * @return string auth nonce value.\n     */\n    protected function generateAuthNonce()\n    {\n        return Yii::$app->security->generateRandomString();\n    }\n}\n"], "fixing_code": ["Yii Framework 2 authclient extension Change Log\n===============================================\n\n2.2.15 under development\n------------------------\n\n- Bug #364: Use issuer claim from OpenID Configuration (radwouters)\n- Enh #367: Throw more specific `ClientErrorResponseException` when the response code in `BaseOAuth::sendRequest()` is a 4xx (rhertogh)\n- Enh GHSA-w8vh-p74j-x9xp: Improved security for OAuth1, OAuth2 and OpenID Connect clients by using timing attack safe string comparsion (rhertogh)\n- Enh GHSA-rw54-6826-c8j5: Improved security for OAuth2 client by requiring an `authCodeVerifier` if PKCE is enabled and clearing it after usage (rhertogh)\n\n\n2.2.14 November 18, 2022\n------------------------\n\n- Bug #351: Unable to set TokenParamKey in OAuth2 config, gets hard overwritten in OAuth2::createToken() (DSTester)\n\n\n2.2.13 September 04, 2022\n-------------------------\n\n- Bug #354: Fix PHP 8.1 deprecated message in BaseOAuth `stripos(): Passing null to parameter #1 ($haystack) of type string is deprecated` (marty-macfly)\n\n\n2.2.12 December 03, 2021\n------------------------\n\n- Bug #330: OpenID Connect client now defaults to `'client_secret_basic'` in case `token_endpoint_auth_methods_supported` isn't specified (rhertogh)\n- Bug #331: OpenID Connect `aud` claim can either be a string or a list of strings (azmeuk)\n- Bug #332: OpenID Connect `aud` nonce is passed from the authentication request to the token request (azmeuk)\n- Bug #339: OpenID Connect client now regenerates a new `nonce` when refreshing the access token (rhertogh)\n- Bug #344: Fix Facebook OAuth 400 error when latin characters are used in App name (pawelkania)\n- Enh #279: Add `AuthAction::$defaultClientId` and `AuthAction::getClientId()` (ditibal)\n- Enh #341: OpenID Connect client now uses access token `'id_token'` claim for `getUserAttributes()` if `userinfo_endpoint` is not available (rhertogh)\n- Enh #342: OpenID Connect client support for JWT in `userinfo_endpoint` response (rhertogh)\n\n\n2.2.11 August 09, 2021\n----------------------\n\n- Enh #318: Add `statusCode` from response to init `InvalidResponseException` in `sendRequest` method of `yii\\authclient\\BaseOAuth` class (vleedev)\n- Enh #327: Use `random_int()` when generating OAuth1 nonce (samdark)\n\n\n2.2.10 May 05, 2021\n-------------------\n\n- Chg #315: Add proof key for code exchange PKCE support to oauth2 (AdeAttwood)\n\n\n2.2.9 November 13, 2020\n-----------------------\n\n- Bug #312: do not refresh access token if it is not expired (albertborsos)\n\n\n2.2.8 November 10, 2020\n-----------------------\n\n- Bug #309: Try to refresh token in `BaseOAuth->beforeApiRequestSend()` if `BaseOAuth->autoRefreshAccessToken = true` instead of throwing \"Invalid access token\" exception (marty-macfly)\n- Bug #311: Fix PHP 8 compatibility (samdark)\n\n\n2.2.7 February 12, 2020\n-----------------------\n\n- Bug #292: Updated GitHub token transfer method according to https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api/#authenticating-using-query-parameters (raidkon)\n\n\n2.2.6 November 19, 2019\n-----------------------\n\n- Bug #288: Default request option for turning off SSL peer verification was removed (Rutger, samdark)\n- Enh #205: Add alternative storage system based on cache component (marty-macfly, tunecino)\n\n\n2.2.5 November 05, 2019\n-----------------------\n\n- Enh #217: Replace spomky-labs/jose by JWT Framework (marty-macfly, smcyr)\n\n\n2.2.4 July 02, 2019\n-------------------\n\n- Enh #276: Bumped VK API version to 5.95, according to developers recommendation (EvgeniyRRU)\n- Enh #278: Keep only selected parameters in default return URLs of OAuth services (albertborsos)\n\n\n2.2.3 June 04, 2019\n-------------------\n\n- Chg #273: `OpenIdConnect::validateClaims()` is now protected (samdark)\n\n\n2.2.2 May 14, 2019\n------------------\n\n- Bug #270: Updated Facebook icon to match brand guidelines (ServerDotBiz)\n\n\n2.2.1 April 23, 2019\n--------------------\n\n- Bug #252: Fix bug when `OAuthToken` is incorrectly instantiated if configuration array has incorrect order (rob006)\n\n\n2.2.0 April 16, 2019\n--------------------\n\n- Bug #266: Updated Google client image (nurielmeni)\n- Bug #267: Upgrade LinkedIn client to v2 (machour)\n\n\n2.1.8 January 28, 2019\n----------------------\n\n- Bug #237: Fix redirect from LinkedIn if user refused to authorize permissions request (jakim)\n- Enh #218: Allow configuring user component in `AuthAction` (samdark, lab362)\n- Enh #258: Use Google Sign-in API instead of Google Plus in `yii\\authclient\\clients\\Google` as Google Plus is deprecated (alexeevdv)\n- Enh #259: Allow to pass buildAuthUrl params to OAuth flows in `AuthAction` (albertborsos)\n\n\n2.1.7 September 20, 2018\n------------------------\n\n- Bug #241: Unset parameter `scope` on `defaultReturnUrl` for `OAuth2` class since it was causing bad request response from Google provider (okiwan)\n\n\n2.1.6 September 07, 2018\n------------------------\n\n- Bug #211: `RsaSha` was not passing `$key` to `openssl_pkey_get_private()` in `generateSignature()` (cfhodges)\n- Bug #220: Make `OpenIdConnect` client send token as bearer auth instead of querystring parameter (lukos)\n- Bug #237: Fixed redirect if user cancels login in auth form (msvit1989)\n- Enh #203: Updated VKontakte client to use API version 5.0 (Shketkol)\n\n\n2.1.5 February 08, 2018\n-----------------------\n\n- Enh #187: URL endpoints for `authUrl` and `tokenUrl` for `yii\\authclient\\clients\\LinkedIn` updated (Felli)\n- Enh #195: `yii\\authclient\\AuthAction` refactored to use `yii\\web\\Application::$request` for request data access (klimov-paul)\n- Enh #196: Added `yii\\authclient\\AuthAction::$cancelCallback` allowing custom handling for authentication cancelation (terales, klimov-paul)\n\n\n2.1.4 November 03, 2017\n-----------------------\n\n- Bug #152: Fixed JavaScript callback generated by `\\yii\\authclient\\widgets\\GooglePlusButton` consider 'immediate_failed' as instant auth error (klimov-paul)\n- Bug: Usage of deprecated `yii\\base\\Object` changed to `yii\\base\\BaseObject` allowing compatibility with PHP 7.2 (klimov-paul)\n- Enh #178: Added `yii\\authclient\\clients\\TwitterOAuth2` supporting 'application-only authentication' workflow for Twitter (klimov-paul)\n- Enh #179: Added `apiVersion` at `yii\\authclient\\clients\\VKontakte` (isudakoff)\n- Enh #185: `yii\\authclient\\clients\\VKontakte::initUserAttributes()` now throws verbose exception on unexpected API response instead of PHP error (klimov-paul)\n\n\n2.1.3 June 23, 2017\n-------------------\n\n- Bug #152: Fixed `\\yii\\authclient\\OAuth1::fetchRequestToken()` skips formatting for `yii\\httpclient\\Request` (klimov-paul)\n- Bug #160: Fixed `\\yii\\authclient\\OAuth1::composeSignatureBaseString()` does not take URL query string into account (klimov-paul)\n- Enh #155: Added `\\yii\\authclient\\OpenIdConnect` supporting [OpenID Connect](https://openid.net/connect/) protocol (klimov-paul)\n- Enh #156: Added `\\yii\\authclient\\signature\\RsaSha` and `\\yii\\authclient\\signature\\HmacSha` supporting general 'SHAwithRSA' and 'HMAC SHA' signature methods (klimov-paul)\n- Enh #157: Added `\\yii\\authclient\\OAuth2::authenticateUserJwt()` supporting authentication via JSON Web Token (JWT) (klimov-paul)\n- Enh #163: Added support for exchanging access token at `yii\\authclient\\clients\\Facebook` (klimov-paul)\n- Enh #163: Added support for client-specific access tokens at `yii\\authclient\\clients\\Facebook` (klimov-paul)\n- Chg #163: `yii\\authclient\\clients\\Facebook::$autoRefreshAccessToken` is now disabled by default (klimov-paul)\n\n\n2.1.2 February 15, 2017\n-----------------------\n\n- Bug #135: Fixed `\\yii\\authclient\\OAuth1::fetchRequestToken()` duplicates auth params in the request body, which may cause error on some OAuth 1.0 providers (klimov-paul)\n- Bug #149: Changed `$` to `jQuery` to prevent global conflicts in widget JavaScript (Ariestattoo)\n- Enh #67: Added `appsecret_proof` generation for the API requests at `yii\\authclient\\clients\\Facebook` (blackhpro, SDKiller, klimov-paul)\n\n\n2.1.1 August 29, 2016\n---------------------\n\n- Bug #128: Fixed `\\yii\\authclient\\BaseClient::createRequest()` does not apply `defaultRequestOptions` and `requestOptions` (klimov-paul)\n- Bug #130: Fixed `\\yii\\authclient\\OAuth1::fetchRequestToken()` unable to unset current access token (klimov-paul)\n- Enh #27: Added `\\yii\\authclient\\OAuth1::authorizationHeaderMethods` option allowing to control request methods, which require authorization header (klimov-paul)\n- Enh #132: URL endpoints for `authUrl` and `tokenUrl` for `yii\\authclient\\clients\\VKontakte` updated (KhristenkoYura)\n\n\n2.1.0 August 04, 2016\n---------------------\n\n- Enh #27: This extension no longer require PHP 'cURL' extension to be installed (klimov-paul)\n- Enh #30: Added support for 'client_credentials' grant type via `\\yii\\authclient\\OAuth2::authenticateClient()` (klimov-paul)\n- Enh #33: Added ability to pass raw request content at `\\yii\\authclient\\BaseOAuth::api()` (klimov-paul)\n- Enh #41: Added support for signature generation from request token at `\\yii\\authclient\\OAuth1::fetchAccessToken()` (klimov-paul)\n- Enh #63: Markup for `\\yii\\authclient\\widgets\\AuthChoice` simplified (klimov-paul)\n- Enh #108: This extension now uses `yii2-httpclient` library for the HTTP requests (klimov-paul)\n- Enh #118: Added support for 'password' grant type via `\\yii\\authclient\\OAuth2::authenticateUser()` (klimov-paul)\n- Enh #121: Auth client 'State Storage' abstraction layer extracted (klimov-paul)\n- Enh #124: Methods `clientLink()` and `renderMainContent()` of `yii\\authclient\\widgets\\AuthChoice` reworked to return HTML instead of echo (klimov-paul)\n- Enh #127: Auth 'state' validation added to `OAuth2` for preventing cross-site request forgery (klimov-paul)\n\n\n2.0.6 July 08, 2016\n-------------------\n\n- Bug #37: Fixed `\\yii\\authclient\\widgets\\AuthChoice` overrides any `<a>` tag click behavior between `begin()` and `end()` methods (klimov-paul)\n- Enh #31: Allow to disable automatic 'refresh access token' requests (klimov-paul)\n- Enh #58: Added support for user attribute request params setup for Twitter (umanamente, klimov-paul)\n- Enh #111: `yii\\authclient\\clients\\GitHub` now retrieves user email even if it is set as 'private' at GitHub account (klimov-paul)\n\n\n2.0.5 September 23, 2015\n------------------------\n\n- Bug #25: `yii\\authclient\\BaseOAuth` now can be used without without `session` application component available (klimov-paul)\n- Enh #40: Added `attributeNames` field to `yii\\authclient\\clients\\Facebook`, which allows definition of attributes list fetched from API (samdark)\n- Chg: #47: Default popup size for `yii\\authclient\\clients\\Facebook` has been increased up to 860x480 (lame07, klimov-paul)\n\n\n2.0.4 May 10, 2015\n------------------\n\n- Bug #7224: Fixed incorrect POST fields composition at `yii\\authclient\\OAuth1` (klimov-paul)\n- Bug #7639: Automatic exception throw on 'error' key presence at `yii\\authclient\\BaseOAuth::processResponse()` removed (klimov-paul)\n- Enh #17: Added `attributeNames` field to `yii\\authclient\\clients\\VKontakte` and `yii\\authclient\\clients\\LinkedIn`, which allows definition of attributes list fetched from API (klimov-paul)\n- Enh #6743: Icon for Google at `yii\\authclient\\widgets\\AuthChoice` fixed to follow the Google Brand guidelines (klimov-paul)\n- Enh #7733: `yii\\authclient\\clients\\VKontakte` now gets attributes from access token also (klimov-paul)\n- Enh #7754: New client `yii\\authclient\\clients\\GooglePlus` added to support Google recommended auth flow (klimov-paul)\n- Chg: #7754: `yii\\authclient\\clients\\GoogleOpenId` is now deprecated because this auth method is no longer supported by Google as of April 20, 2015 (klimov-paul)\n\n\n2.0.3 March 01, 2015\n--------------------\n\n- Enh #6892: Default value of `yii\\authclient\\clients\\Twitter::$authUrl` changed to 'authenticate', allowing usage of previous logged user without request an access (kotchuprik)\n\n\n2.0.2 January 11, 2015\n----------------------\n\n- Bug #6502: Fixed `\\yii\\authclient\\OAuth2::refreshAccessToken()` does not save fetched token (sebathi)\n- Bug #6510: Fixed infinite redirect loop using default `\\yii\\authclient\\AuthAction::cancelUrl` (klimov-paul)\n\n\n2.0.1 December 07, 2014\n-----------------------\n\n- Bug #6000: Fixed CCS for `yii\\authclient\\widgets\\AuthChoice` does not loaded if `popupMode` disabled (klimov-paul)\n\n\n2.0.0 October 12, 2014\n----------------------\n\n- Enh #5135: Added ability to operate nested and complex attributes via `yii\\authclient\\BaseClient::normalizeUserAttributeMap` (zinzinday, klimov-paul)\n\n\n2.0.0-rc September 27, 2014\n---------------------------\n\n- Bug #3633: OpenId return URL comparison advanced to prevent url encode problem (klimov-paul)\n- Bug #4490: `yii\\authclient\\widgets\\AuthChoice` does not preserve initial settings while opening popup (klimov-paul)\n- Bug #5011: OAuth API Response with 20x status were not considered success (ychongsaytc)\n- Enh #3416: VKontakte OAuth support added (klimov-paul)\n- Enh #4076: Request HTTP headers argument added to `yii\\authclient\\BaseOAuth::api()` method (klimov-paul)\n- Enh #4134: `yii\\authclient\\InvalidResponseException` added for tracking invalid remote server response (klimov-paul)\n- Enh #4139: User attributes requesting at GoogleOAuth switched to Google+ API (klimov-paul)\n\n\n2.0.0-beta April 13, 2014\n-------------------------\n\n- Initial release.\n\n\n\n", "<?php\n/**\n * @link https://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license https://www.yiiframework.com/license/\n */\n\nnamespace yii\\authclient;\n\nuse Yii;\nuse yii\\base\\InvalidParamException;\nuse yii\\httpclient\\Request;\nuse yii\\web\\HttpException;\n\n/**\n * OAuth1 serves as a client for the OAuth 1/1.0a flow.\n *\n * In order to acquire access token perform following sequence:\n *\n * ```php\n * use yii\\authclient\\OAuth1;\n * use Yii;\n *\n * // assuming class MyAuthClient extends OAuth1\n * $oauthClient = new MyAuthClient();\n * $requestToken = $oauthClient->fetchRequestToken(); // Get request token\n * $url = $oauthClient->buildAuthUrl($requestToken); // Get authorization URL\n * return Yii::$app->getResponse()->redirect($url); // Redirect to authorization URL\n *\n * // After user returns at our site:\n * $accessToken = $oauthClient->fetchAccessToken(Yii::$app->request->get('oauth_token'), $requestToken); // Upgrade to access token\n * ```\n *\n * @see https://oauth.net/1/\n * https://tools.ietf.org/html/rfc5849\n *\n * @author Paul Klimov <klimov.paul@gmail.com>\n * @since 2.0\n */\nabstract class OAuth1 extends BaseOAuth\n{\n    /**\n     * @var string protocol version.\n     */\n    public $version = '1.0';\n    /**\n     * @var string OAuth consumer key.\n     */\n    public $consumerKey;\n    /**\n     * @var string OAuth consumer secret.\n     */\n    public $consumerSecret;\n    /**\n     * @var string OAuth request token URL.\n     */\n    public $requestTokenUrl;\n    /**\n     * @var string request token HTTP method.\n     */\n    public $requestTokenMethod = 'GET';\n    /**\n     * @var string OAuth access token URL.\n     */\n    public $accessTokenUrl;\n    /**\n     * @var string access token HTTP method.\n     */\n    public $accessTokenMethod = 'GET';\n    /**\n     * @var array|null list of the request methods, which require adding 'Authorization' header.\n     * By default only POST requests will have 'Authorization' header.\n     * You may set this option to `null` in order to make all requests to use 'Authorization' header.\n     * @since 2.1.1\n     */\n    public $authorizationHeaderMethods = ['POST'];\n\n\n    /**\n     * Fetches the OAuth request token.\n     * @param array $params additional request params.\n     * @return OAuthToken request token.\n     */\n    public function fetchRequestToken(array $params = [])\n    {\n        $this->setAccessToken(null);\n        $defaultParams = [\n            'oauth_consumer_key' => $this->consumerKey,\n            'oauth_callback' => $this->getReturnUrl(),\n            //'xoauth_displayname' => Yii::$app->name,\n        ];\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod($this->requestTokenMethod)\n            ->setUrl($this->requestTokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->signRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken([\n            'params' => $response\n        ]);\n        $this->setState('requestToken', $token);\n\n        return $token;\n    }\n\n    /**\n     * Composes user authorization URL.\n     * @param OAuthToken $requestToken OAuth request token.\n     * @param array $params additional request params.\n     * @return string authorize URL\n     * @throws InvalidParamException on failure.\n     */\n    public function buildAuthUrl(OAuthToken $requestToken = null, array $params = [])\n    {\n        if (!is_object($requestToken)) {\n            $requestToken = $this->getState('requestToken');\n            if (!is_object($requestToken)) {\n                throw new InvalidParamException('Request token is required to build authorize URL!');\n            }\n        }\n        $params['oauth_token'] = $requestToken->getToken();\n\n        return $this->composeUrl($this->authUrl, $params);\n    }\n\n    /**\n     * Fetches OAuth access token.\n     * @param string $oauthToken OAuth token returned with redirection back to client.\n     * @param OAuthToken $requestToken OAuth request token.\n     * @param string $oauthVerifier OAuth verifier.\n     * @param array $params additional request params.\n     * @return OAuthToken OAuth access token.\n     * @throws InvalidParamException on failure.\n     * @throws HttpException in case oauth token miss-matches request token.\n     */\n    public function fetchAccessToken($oauthToken = null, OAuthToken $requestToken = null, $oauthVerifier = null, array $params = [])\n    {\n        $incomingRequest = Yii::$app->getRequest();\n\n        if ($oauthToken === null) {\n            $oauthToken = $incomingRequest->get('oauth_token', $incomingRequest->post('oauth_token', $oauthToken));\n        }\n\n        if (!is_object($requestToken)) {\n            $requestToken = $this->getState('requestToken');\n            if (!is_object($requestToken)) {\n                throw new InvalidParamException('Request token is required to fetch access token!');\n            }\n        }\n\n        if (!Yii::$app->getSecurity()->compareString($requestToken->getToken(), $oauthToken)) {\n            throw new HttpException(400, 'Invalid auth state parameter.');\n        }\n\n        $this->removeState('requestToken');\n\n        $defaultParams = [\n            'oauth_consumer_key' => $this->consumerKey,\n            'oauth_token' => $requestToken->getToken()\n        ];\n        if ($oauthVerifier === null) {\n            $oauthVerifier = $incomingRequest->get('oauth_verifier', $incomingRequest->post('oauth_verifier'));\n        }\n        if (!empty($oauthVerifier)) {\n            $defaultParams['oauth_verifier'] = $oauthVerifier;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod($this->accessTokenMethod)\n            ->setUrl($this->accessTokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->signRequest($request, $requestToken);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken([\n            'params' => $response\n        ]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function createRequest()\n    {\n        $request = parent::createRequest();\n        $request->on(Request::EVENT_BEFORE_SEND, [$this, 'beforeRequestSend']);\n        return $request;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function createApiRequest()\n    {\n        $request = parent::createApiRequest();\n\n        // ensure correct event handlers order :\n        $request->off(Request::EVENT_BEFORE_SEND, [$this, 'beforeRequestSend']);\n        $request->on(Request::EVENT_BEFORE_SEND, [$this, 'beforeRequestSend']);\n\n        return $request;\n    }\n\n    /**\n     * Handles [[Request::EVENT_BEFORE_SEND]] event.\n     * Ensures every request has been signed up before sending.\n     * @param \\yii\\httpclient\\RequestEvent $event event instance.\n     * @since 2.1\n     */\n    public function beforeRequestSend($event)\n    {\n        $this->signRequest($event->request);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function applyAccessTokenToRequest($request, $accessToken)\n    {\n        $data = $request->getData();\n        $data['oauth_consumer_key'] = $this->consumerKey;\n        $data['oauth_token'] = $accessToken->getToken();\n        $request->setData($data);\n    }\n\n    /**\n     * Gets new auth token to replace expired one.\n     * @param OAuthToken $token expired auth token.\n     * @return OAuthToken new auth token.\n     */\n    public function refreshAccessToken(OAuthToken $token)\n    {\n        // @todo\n        return null;\n    }\n\n    /**\n     * Generates nonce value.\n     * @return string nonce value.\n     */\n    protected function generateNonce()\n    {\n        return md5(microtime() . random_int(0, PHP_INT_MAX));\n    }\n\n    /**\n     * Generates timestamp.\n     * @return int timestamp.\n     */\n    protected function generateTimestamp()\n    {\n        return time();\n    }\n\n    /**\n     * Generate common request params like version, timestamp etc.\n     * @return array common request params.\n     */\n    protected function generateCommonRequestParams()\n    {\n        $params = [\n            'oauth_version' => $this->version,\n            'oauth_nonce' => $this->generateNonce(),\n            'oauth_timestamp' => $this->generateTimestamp(),\n        ];\n\n        return $params;\n    }\n\n    /**\n     * Sign given request with [[signatureMethod]].\n     * @param \\yii\\httpclient\\Request $request request instance.\n     * @param OAuthToken|null $token OAuth token to be used for signature, if not set [[accessToken]] will be used.\n     * @since 2.1 this method is public.\n     */\n    public function signRequest($request, $token = null)\n    {\n        $params = $request->getData();\n\n        if (isset($params['oauth_signature_method']) || $request->hasHeaders() && $request->getHeaders()->has('authorization')) {\n            // avoid double sign of request\n            return;\n        }\n\n        if (empty($params)) {\n            $params = $this->generateCommonRequestParams();\n        } else {\n            $params = array_merge($this->generateCommonRequestParams(), $params);\n        }\n\n        $url = $request->getFullUrl();\n\n        $signatureMethod = $this->getSignatureMethod();\n\n        $params['oauth_signature_method'] = $signatureMethod->getName();\n        $signatureBaseString = $this->composeSignatureBaseString($request->getMethod(), $url, $params);\n        $signatureKey = $this->composeSignatureKey($token);\n        $params['oauth_signature'] = $signatureMethod->generateSignature($signatureBaseString, $signatureKey);\n\n        if ($this->authorizationHeaderMethods === null || in_array(strtoupper($request->getMethod()), array_map('strtoupper', $this->authorizationHeaderMethods), true)) {\n            $authorizationHeader = $this->composeAuthorizationHeader($params);\n            if (!empty($authorizationHeader)) {\n                $request->addHeaders($authorizationHeader);\n\n                // removing authorization header params, avoiding duplicate param server error :\n                foreach ($params as $key => $value) {\n                    if (substr_compare($key, 'oauth', 0, 5) === 0) {\n                        unset($params[$key]);\n                    }\n                }\n            }\n        }\n\n        $request->setData($params);\n    }\n\n    /**\n     * Creates signature base string, which will be signed by [[signatureMethod]].\n     * @param string $method request method.\n     * @param string $url request URL.\n     * @param array $params request params.\n     * @return string base signature string.\n     */\n    protected function composeSignatureBaseString($method, $url, array $params)\n    {\n        if (strpos($url, '?') !== false) {\n            list($url, $queryString) = explode('?', $url, 2);\n            parse_str($queryString, $urlParams);\n            $params = array_merge($urlParams, $params);\n        }\n        unset($params['oauth_signature']);\n        uksort($params, 'strcmp'); // Parameters are sorted by name, using lexicographical byte value ordering. Ref: Spec: 9.1.1\n        $parts = [\n            strtoupper($method),\n            $url,\n            http_build_query($params, '', '&', PHP_QUERY_RFC3986)\n        ];\n        $parts = array_map('rawurlencode', $parts);\n\n        return implode('&', $parts);\n    }\n\n    /**\n     * Composes request signature key.\n     * @param OAuthToken|null $token OAuth token to be used for signature key.\n     * @return string signature key.\n     */\n    protected function composeSignatureKey($token = null)\n    {\n        $signatureKeyParts = [\n            $this->consumerSecret\n        ];\n\n        if ($token === null) {\n            $token = $this->getAccessToken();\n        }\n        if (is_object($token)) {\n            $signatureKeyParts[] = $token->getTokenSecret();\n        } else {\n            $signatureKeyParts[] = '';\n        }\n\n        $signatureKeyParts = array_map('rawurlencode', $signatureKeyParts);\n\n        return implode('&', $signatureKeyParts);\n    }\n\n    /**\n     * Composes authorization header.\n     * @param array $params request params.\n     * @param string $realm authorization realm.\n     * @return array authorization header in format: [name => content].\n     */\n    protected function composeAuthorizationHeader(array $params, $realm = '')\n    {\n        $header = 'OAuth';\n        $headerParams = [];\n        if (!empty($realm)) {\n            $headerParams[] = 'realm=\"' . rawurlencode($realm) . '\"';\n        }\n        foreach ($params as $key => $value) {\n            if (substr_compare($key, 'oauth', 0, 5)) {\n                continue;\n            }\n            $headerParams[] = rawurlencode($key) . '=\"' . rawurlencode($value) . '\"';\n        }\n        if (!empty($headerParams)) {\n            $header .= ' ' . implode(', ', $headerParams);\n        }\n\n        return ['Authorization' => $header];\n    }\n}\n", "<?php\n/**\n * @link https://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license https://www.yiiframework.com/license/\n */\n\nnamespace yii\\authclient;\n\nuse Yii;\nuse yii\\helpers\\Json;\nuse yii\\helpers\\Url;\nuse yii\\web\\HttpException;\n\n/**\n * OAuth2 serves as a client for the OAuth 2 flow.\n *\n * In oder to acquire access token perform following sequence:\n *\n * ```php\n * use yii\\authclient\\OAuth2;\n *\n * // assuming class MyAuthClient extends OAuth2\n * $oauthClient = new MyAuthClient();\n * $url = $oauthClient->buildAuthUrl(); // Build authorization URL\n * Yii::$app->getResponse()->redirect($url); // Redirect to authorization URL.\n * // After user returns at our site:\n * $code = Yii::$app->getRequest()->get('code');\n * $accessToken = $oauthClient->fetchAccessToken($code); // Get access token\n * ```\n *\n * @see https://oauth.net/2/\n * @see https://tools.ietf.org/html/rfc6749\n *\n * @author Paul Klimov <klimov.paul@gmail.com>\n * @since 2.0\n */\nabstract class OAuth2 extends BaseOAuth\n{\n    /**\n     * @var string protocol version.\n     */\n    public $version = '2.0';\n    /**\n     * @var string OAuth client ID.\n     */\n    public $clientId;\n    /**\n     * @var string OAuth client secret.\n     */\n    public $clientSecret;\n    /**\n     * @var string token request URL endpoint.\n     */\n    public $tokenUrl;\n    /**\n     * @var bool whether to use and validate auth 'state' parameter in authentication flow.\n     * If enabled - the opaque value will be generated and applied to auth URL to maintain\n     * state between the request and callback. The authorization server includes this value,\n     * when redirecting the user-agent back to the client.\n     * The option is used for preventing cross-site request forgery.\n     * @since 2.1\n     */\n    public $validateAuthState = true;\n    /**\n     * @var bool Whether to enable proof key for code exchange (PKCE) support and add\n     * a `code_challenge` and `code_verifier` to the auth request.\n     * @since 2.2.10\n     *\n     * @see https://oauth.net/2/pkce/\n     */\n    public $enablePkce = false;\n\n\n    /**\n     * Composes user authorization URL.\n     * @param array $params additional auth GET params.\n     * @return string authorization URL.\n     */\n    public function buildAuthUrl(array $params = [])\n    {\n        $defaultParams = [\n            'client_id' => $this->clientId,\n            'response_type' => 'code',\n            'redirect_uri' => $this->getReturnUrl(),\n            'xoauth_displayname' => Yii::$app->name,\n        ];\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        if ($this->validateAuthState) {\n            $authState = $this->generateAuthState();\n            $this->setState('authState', $authState);\n            $defaultParams['state'] = $authState;\n        }\n\n        if ($this->enablePkce) {\n            $codeVerifier = bin2hex(Yii::$app->security->generateRandomKey(64));\n            $this->setState('authCodeVerifier', $codeVerifier);\n            $defaultParams['code_challenge'] = trim(strtr(base64_encode(hash('sha256', $codeVerifier, true)), '+/', '-_'), '=');\n            $defaultParams['code_challenge_method'] = 'S256';\n        }\n\n        return $this->composeUrl($this->authUrl, array_merge($defaultParams, $params));\n    }\n\n    /**\n     * Fetches access token from authorization code.\n     * @param string $authCode authorization code, usually comes at GET parameter 'code'.\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @throws HttpException on invalid auth state in case [[enableStateValidation]] is enabled.\n     */\n    public function fetchAccessToken($authCode, array $params = [])\n    {\n        if ($this->validateAuthState) {\n            $authState = $this->getState('authState');\n            $incomingRequest = Yii::$app->getRequest();\n            $incomingState = $incomingRequest->get('state', $incomingRequest->post('state'));\n            if (\n                !isset($incomingState)\n                || empty($authState)\n                || !Yii::$app->getSecurity()->compareString($incomingState, $authState)\n            ) {\n                throw new HttpException(400, 'Invalid auth state parameter.');\n            }\n            $this->removeState('authState');\n        }\n\n        $defaultParams = [\n            'code' => $authCode,\n            'grant_type' => 'authorization_code',\n            'redirect_uri' => $this->getReturnUrl(),\n        ];\n\n        if ($this->enablePkce) {\n            $authCodeVerifier = $this->getState('authCodeVerifier');\n            if (empty($authCodeVerifier)) {\n                // Prevent PKCE Downgrade Attack\n                // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#name-pkce-downgrade-attack\n                throw new HttpException(409, 'Invalid auth code verifier.');\n            }\n            $defaultParams['code_verifier'] = $authCodeVerifier;\n            $this->removeState('authCodeVerifier');\n        }\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n         // Azure AD will complain if there is no `Origin` header.\n        if ($this->enablePkce) {\n            $request->addHeaders(['Origin' => Url::to('/')]);\n        }\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function applyAccessTokenToRequest($request, $accessToken)\n    {\n        $data = $request->getData();\n        $data['access_token'] = $accessToken->getToken();\n        $request->setData($data);\n    }\n\n    /**\n     * Applies client credentials (e.g. [[clientId]] and [[clientSecret]]) to the HTTP request instance.\n     * This method should be invoked before sending any HTTP request, which requires client credentials.\n     * @param \\yii\\httpclient\\Request $request HTTP request instance.\n     * @since 2.1.3\n     */\n    protected function applyClientCredentialsToRequest($request)\n    {\n        $request->addData([\n            'client_id' => $this->clientId,\n            'client_secret' => $this->clientSecret,\n        ]);\n    }\n\n    /**\n     * Gets new auth token to replace expired one.\n     * @param OAuthToken $token expired auth token.\n     * @return OAuthToken new auth token.\n     */\n    public function refreshAccessToken(OAuthToken $token)\n    {\n        $params = [\n            'grant_type' => 'refresh_token'\n        ];\n        $params = array_merge($token->getParams(), $params);\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData($params);\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * Generates the auth state value.\n     * @return string auth state value.\n     * @since 2.1\n     */\n    protected function generateAuthState()\n    {\n        $baseString = get_class($this) . '-' . time();\n        if (Yii::$app->has('session')) {\n            $baseString .= '-' . Yii::$app->session->getId();\n        }\n        return hash('sha256', uniqid($baseString, true));\n    }\n\n    /**\n     * Creates token from its configuration.\n     * @param array $tokenConfig token configuration.\n     * @return OAuthToken token instance.\n     */\n    protected function createToken(array $tokenConfig = [])\n    {\n        $defaultTokenConfig = ['tokenParamKey' => 'access_token'];\n        $tokenConfig = array_merge($defaultTokenConfig, $tokenConfig);\n\n        return parent::createToken($tokenConfig);\n    }\n\n    /**\n     * Authenticate OAuth client directly at the provider without third party (user) involved,\n     * using 'client_credentials' grant type.\n     * @see https://tools.ietf.org/html/rfc6749#section-4.4\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @since 2.1.0\n     */\n    public function authenticateClient($params = [])\n    {\n        $defaultParams = [\n            'grant_type' => 'client_credentials',\n        ];\n\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * Authenticates user directly by 'username/password' pair, using 'password' grant type.\n     * @see https://tools.ietf.org/html/rfc6749#section-4.3\n     * @param string $username user name.\n     * @param string $password user password.\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @since 2.1.0\n     */\n    public function authenticateUser($username, $password, $params = [])\n    {\n        $defaultParams = [\n            'grant_type' => 'password',\n            'username' => $username,\n            'password' => $password,\n        ];\n\n        if (!empty($this->scope)) {\n            $defaultParams['scope'] = $this->scope;\n        }\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge($defaultParams, $params));\n\n        $this->applyClientCredentialsToRequest($request);\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n\n    /**\n     * Authenticates user directly using JSON Web Token (JWT).\n     * @see https://tools.ietf.org/html/rfc7515\n     * @param string $username\n     * @param \\yii\\authclient\\signature\\BaseMethod|array $signature signature method or its array configuration.\n     * If empty - [[signatureMethod]] will be used.\n     * @param array $options additional options. Valid options are:\n     *\n     * - header: array, additional JWS header parameters.\n     * - payload: array, additional JWS payload (message or claim-set) parameters.\n     * - signatureKey: string, signature key to be used, if not set - [[clientSecret]] will be used.\n     *\n     * @param array $params additional request params.\n     * @return OAuthToken access token.\n     * @since 2.1.3\n     */\n    public function authenticateUserJwt($username, $signature = null, $options = [], $params = [])\n    {\n        if (empty($signature)) {\n            $signatureMethod = $this->getSignatureMethod();\n        } elseif (is_object($signature)) {\n            $signatureMethod = $signature;\n        } else {\n            $signatureMethod = $this->createSignatureMethod($signature);\n        }\n\n        $header = isset($options['header']) ? $options['header'] : [];\n        $payload = isset($options['payload']) ? $options['payload'] : [];\n\n        $header = array_merge([\n            'typ' => 'JWT'\n        ], $header);\n        if (!isset($header['alg'])) {\n            $signatureName = $signatureMethod->getName();\n            if (preg_match('/^([a-z])[a-z]*\\-([a-z])[a-z]*([0-9]+)$/is', $signatureName, $matches)) {\n                // convert 'RSA-SHA256' to 'RS256' :\n                $signatureName = $matches[1] . $matches[2] . $matches[3];\n            }\n            $header['alg'] = $signatureName;\n        }\n\n        $payload = array_merge([\n            'iss' => $username,\n            'scope' => $this->scope,\n            'aud' => $this->tokenUrl,\n            'iat' => time(),\n        ], $payload);\n        if (!isset($payload['exp'])) {\n            $payload['exp'] = $payload['iat'] + 3600;\n        }\n\n        $signatureBaseString = base64_encode(Json::encode($header)) . '.' . base64_encode(Json::encode($payload));\n        $signatureKey = isset($options['signatureKey']) ? $options['signatureKey'] : $this->clientSecret;\n        $signature = $signatureMethod->generateSignature($signatureBaseString, $signatureKey);\n\n        $assertion = $signatureBaseString . '.' . $signature;\n\n        $request = $this->createRequest()\n            ->setMethod('POST')\n            ->setUrl($this->tokenUrl)\n            ->setData(array_merge([\n                'grant_type' => 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                'assertion' => $assertion,\n            ], $params));\n\n        $response = $this->sendRequest($request);\n\n        $token = $this->createToken(['params' => $response]);\n        $this->setAccessToken($token);\n\n        return $token;\n    }\n}\n", "<?php\n/**\n * @link https://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license https://www.yiiframework.com/license/\n */\n\nnamespace yii\\authclient;\n\nuse Jose\\Component\\Core\\AlgorithmManager;\nuse Jose\\Component\\Checker\\AlgorithmChecker;\nuse Jose\\Component\\Checker\\HeaderCheckerManager;\nuse Jose\\Component\\KeyManagement\\JWKFactory;\nuse Jose\\Component\\Signature\\JWSLoader;\nuse Jose\\Component\\Signature\\JWSTokenSupport;\nuse Jose\\Component\\Signature\\JWSVerifier;\nuse Jose\\Component\\Signature\\Serializer\\CompactSerializer;\nuse Jose\\Component\\Signature\\Serializer\\JWSSerializerManager;\nuse Yii;\nuse yii\\authclient\\signature\\HmacSha;\nuse yii\\base\\InvalidConfigException;\nuse yii\\caching\\Cache;\nuse yii\\di\\Instance;\nuse yii\\helpers\\Json;\nuse yii\\helpers\\StringHelper;\nuse yii\\web\\HttpException;\n\n/**\n * OpenIdConnect serves as a client for the OpenIdConnect flow.\n *\n * Application configuration example:\n *\n * ```php\n * 'components' => [\n *     'authClientCollection' => [\n *         'class' => 'yii\\authclient\\Collection',\n *         'clients' => [\n *             'google' => [\n *                 'class' => 'yii\\authclient\\OpenIdConnect',\n *                 'issuerUrl' => 'https://accounts.google.com',\n *                 'clientId' => 'google_client_id',\n *                 'clientSecret' => 'google_client_secret',\n *                 'name' => 'google',\n *                 'title' => 'Google OpenID Connect',\n *             ],\n *         ],\n *     ]\n *     // ...\n * ]\n * ```\n *\n * This class requires `web-token/jwt-checker`,`web-token/jwt-key-mgmt`, `web-token/jwt-signature`, `web-token/jwt-signature-algorithm-hmac`,\n * `web-token/jwt-signature-algorithm-ecdsa` and `web-token/jwt-signature-algorithm-rsa` libraries to be installed for\n * JWS verification. This can be done via composer:\n *\n * ```\n * composer require --prefer-dist \"web-token/jwt-checker:>=1.0 <3.0\" \"web-token/jwt-signature:>=1.0 <3.0\"\n * \"web-token/jwt-signature:>=1.0 <3.0\" \"web-token/jwt-signature-algorithm-hmac:>=1.0 <3.0\"\n * \"web-token/jwt-signature-algorithm-ecdsa:>=1.0 <3.0\" \"web-token/jwt-signature-algorithm-rsa:>=1.0 <3.0\"\n * ```\n *\n * Note: if you are using well-trusted OpenIdConnect provider, you may disable [[validateJws]], making installation of\n * `web-token` library redundant, however it is not recommended as it violates the protocol specification.\n *\n * @see https://openid.net/connect/\n * @see OAuth2\n *\n * @property Cache|null $cache The cache object, `null` - if not enabled. Note that the type of this property\n * differs in getter and setter. See [[getCache()]] and [[setCache()]] for details.\n * @property array $configParams OpenID provider configuration parameters.\n * @property bool $validateAuthNonce Whether to use and validate auth 'nonce' parameter in authentication\n * flow.\n *\n * @author Paul Klimov <klimov.paul@gmail.com>\n * @since 2.1.3\n */\nclass OpenIdConnect extends OAuth2\n{\n    /**\n     * @var array Predefined OpenID Connect Claims\n     * @see https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.2\n     * @since 2.2.12\n     */\n    public $defaultIdTokenClaims = [\n        'iss', // Issuer Identifier for the Issuer of the response.\n        'sub', // Subject Identifier.\n        'aud', // Audience(s) that this ID Token is intended for.\n        'exp', // Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n        'iat', // Time at which the JWT was issued.\n        'auth_time', // Time when the End-User authentication occurred.\n        'nonce', // String value used to associate a Client session with an ID Token, and to mitigate replay attacks.\n        'acr', // Authentication Context Class Reference.\n        'amr', // Authentication Methods References.\n        'azp', // Authorized party - the party to which the ID Token was issued.\n    ];\n    /**\n     * {@inheritdoc}\n     */\n    public $scope = 'openid';\n    /**\n     * @var string OpenID Issuer (provider) base URL, e.g. `https://example.com`.\n     */\n    public $issuerUrl;\n    /**\n     * @var bool whether to validate/decrypt JWS received with Auth token.\n     * Note: this functionality requires `web-token/jwt-checker`, `web-token/jwt-key-mgmt`, `web-token/jwt-signature`\n     * composer package to be installed. You can disable this option in case of usage of trusted OpenIDConnect provider,\n     * however this violates the protocol rules, so you are doing it on your own risk.\n     */\n    public $validateJws = true;\n    /**\n     * @var array JWS algorithms, which are allowed to be used.\n     * These are used by `web-token` library for JWS validation/decryption.\n     * Make sure to install `web-token/jwt-signature-algorithm-hmac`, `web-token/jwt-signature-algorithm-ecdsa`\n     * and `web-token/jwt-signature-algorithm-rsa` packages that support the particular algorithm before adding it here.\n     */\n    public $allowedJwsAlgorithms = [\n        'HS256', 'HS384', 'HS512',\n        'ES256', 'ES384', 'ES512',\n        'RS256', 'RS384', 'RS512',\n        'PS256', 'PS384', 'PS512'\n    ];\n    /**\n     * @var string the prefix for the key used to store [[configParams]] data in cache.\n     * Actual cache key will be formed addition [[id]] value to it.\n     * @see cache\n     */\n    public $configParamsCacheKeyPrefix = 'config-params-';\n\n    /**\n     * @var bool|null whether to use and validate auth 'nonce' parameter in authentication flow.\n     * The option is used for preventing replay attacks.\n     */\n    private $_validateAuthNonce;\n    /**\n     * @var array OpenID provider configuration parameters.\n     */\n    private $_configParams;\n    /**\n     * @var Cache|string the cache object or the ID of the cache application component that\n     * is used for caching. This can be one of the following:\n     *\n     * - an application component ID (e.g. `cache`)\n     * - a configuration array\n     * - a [[\\yii\\caching\\Cache]] object\n     *\n     * When this is not set, it means caching is not enabled.\n     */\n    private $_cache = 'cache';\n    /**\n     * @var JWSLoader JSON Web Signature\n     */\n    private $_jwsLoader;\n    /**\n     * @var JWKSet Key Set\n     */\n    private $_jwkSet;\n\n\n    /**\n     * @return bool whether to use and validate auth 'nonce' parameter in authentication flow.\n     */\n    public function getValidateAuthNonce()\n    {\n        if ($this->_validateAuthNonce === null) {\n            $this->_validateAuthNonce = $this->validateJws && in_array('nonce', $this->getConfigParam('claims_supported'));\n        }\n        return $this->_validateAuthNonce;\n    }\n\n    /**\n     * @param bool $validateAuthNonce whether to use and validate auth 'nonce' parameter in authentication flow.\n     */\n    public function setValidateAuthNonce($validateAuthNonce)\n    {\n        $this->_validateAuthNonce = $validateAuthNonce;\n    }\n\n    /**\n     * @return Cache|null the cache object, `null` - if not enabled.\n     */\n    public function getCache()\n    {\n        if ($this->_cache !== null && !is_object($this->_cache)) {\n            $this->_cache = Instance::ensure($this->_cache, Cache::className());\n        }\n        return $this->_cache;\n    }\n\n    /**\n     * Sets up a component to be used for caching.\n     * This can be one of the following:\n     *\n     * - an application component ID (e.g. `cache`)\n     * - a configuration array\n     * - a [[\\yii\\caching\\Cache]] object\n     *\n     * When `null` is passed, it means caching is not enabled.\n     * @param Cache|array|string|null $cache the cache object or the ID of the cache application component.\n     */\n    public function setCache($cache)\n    {\n        $this->_cache = $cache;\n    }\n\n    /**\n     * @return array OpenID provider configuration parameters.\n     */\n    public function getConfigParams()\n    {\n        if ($this->_configParams === null) {\n            $cache = $this->getCache();\n            $cacheKey = $this->configParamsCacheKeyPrefix . $this->getId();\n            if ($cache === null || ($configParams = $cache->get($cacheKey)) === false) {\n                $configParams = $this->discoverConfig();\n            }\n\n            $this->_configParams = $configParams;\n\n            if ($cache !== null) {\n                $cache->set($cacheKey, $configParams);\n            }\n        }\n        return $this->_configParams;\n    }\n\n    /**\n     * Returns particular configuration parameter value.\n     * @param string $name configuration parameter name.\n     * @param mixed $default value to be returned if the configuration parameter isn't set.\n     * @return mixed configuration parameter value.\n     */\n    public function getConfigParam($name, $default = null)\n    {\n        $params = $this->getConfigParams();\n        return array_key_exists($name, $params) ? $params[$name] : $default;\n    }\n\n    /**\n     * Discovers OpenID Provider configuration parameters.\n     * @return array OpenID Provider configuration parameters.\n     * @throws InvalidResponseException on failure.\n     */\n    protected function discoverConfig()\n    {\n        $request = $this->createRequest();\n        $configUrl = rtrim($this->issuerUrl, '/') . '/.well-known/openid-configuration';\n        $request->setMethod('GET')\n            ->setUrl($configUrl);\n        $response = $this->sendRequest($request);\n        return $response;\n    }\n\n    /**\n     * Set the OpenID provider configuration manually, this will bypass the automatic discovery via\n     * the /.well-known/openid-configuration endpoint.\n     * @param array $configParams OpenID provider configuration parameters.\n     * @since 2.2.12\n     */\n    public function setConfigParams($configParams)\n    {\n        $this->_configParams = $configParams;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function buildAuthUrl(array $params = [])\n    {\n        if ($this->authUrl === null) {\n            $this->authUrl = $this->getConfigParam('authorization_endpoint');\n        }\n\n        if (!isset($params['nonce']) && $this->getValidateAuthNonce()) {\n            $nonce = $this->generateAuthNonce();\n            $this->setState('authNonce', $nonce);\n            $params['nonce'] = $nonce;\n        }\n\n        return parent::buildAuthUrl($params);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function fetchAccessToken($authCode, array $params = [])\n    {\n        if ($this->tokenUrl === null) {\n            $this->tokenUrl = $this->getConfigParam('token_endpoint');\n        }\n\n        if (!isset($params['nonce']) && $this->getValidateAuthNonce()) {\n            $params['nonce'] = $this->getState('authNonce');\n        }\n\n        return parent::fetchAccessToken($authCode, $params);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function refreshAccessToken(OAuthToken $token)\n    {\n        if ($this->tokenUrl === null) {\n            $this->tokenUrl = $this->getConfigParam('token_endpoint');\n        }\n\n        if ($this->getValidateAuthNonce()) {\n            $nonce = $this->generateAuthNonce();\n            $this->setState('authNonce', $nonce);\n            $token->setParam('nonce', $nonce);\n        }\n\n        return parent::refreshAccessToken($token);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function initUserAttributes()\n    {\n        // Use 'userinfo_endpoint' config if available,\n        // try to extract user claims from access token's 'id_token' claim otherwise.\n\n        $userinfoEndpoint = $this->getConfigParam('userinfo_endpoint');\n        if (!empty($userinfoEndpoint)) {\n            $userInfo = $this->api($userinfoEndpoint, 'GET');\n            // The userinfo endpoint can return a JSON object (which will be converted to an array) or a JWT.\n            if (is_array($userInfo)) {\n                return $userInfo;\n            } else {\n                // Use the userInfo endpoint as id_token and parse it as JWT below\n                $idToken = $userInfo;\n            }\n        } else {\n            $accessToken = $this->accessToken;\n            $idToken = $accessToken->getParam('id_token');\n        }\n\n        $idTokenData = [];\n        if (!empty($idToken)) {\n            if ($this->validateJws) {\n                $idTokenClaims = $this->loadJws($idToken);\n            } else {\n                $idTokenClaims = Json::decode(StringHelper::base64UrlDecode(explode('.', $idToken)[1]));\n            }\n            $metaDataFields = array_flip($this->defaultIdTokenClaims);\n            unset($metaDataFields['sub']); // \"Subject Identifier\" is not meta data\n            $idTokenData = array_diff_key($idTokenClaims, $metaDataFields);\n        }\n\n        return $idTokenData;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function applyAccessTokenToRequest($request, $accessToken)\n    {\n        // OpenID Connect requires bearer token auth for the user info endpoint\n        $request->getHeaders()->set('Authorization', 'Bearer ' . $accessToken->getToken());\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function applyClientCredentialsToRequest($request)\n    {\n        $supportedAuthMethods = $this->getConfigParam('token_endpoint_auth_methods_supported', 'client_secret_basic');\n\n        if (in_array('client_secret_basic', $supportedAuthMethods)) {\n            $request->addHeaders([\n                'Authorization' => 'Basic ' . base64_encode($this->clientId . ':' . $this->clientSecret)\n            ]);\n        } elseif (in_array('client_secret_post', $supportedAuthMethods)) {\n            $request->addData([\n                'client_id' => $this->clientId,\n                'client_secret' => $this->clientSecret,\n            ]);\n        } elseif (in_array('client_secret_jwt', $supportedAuthMethods)) {\n            $header = [\n                'typ' => 'JWT',\n                'alg' => 'HS256',\n            ];\n            $payload = [\n                'iss' => $this->clientId,\n                'sub' => $this->clientId,\n                'aud' => $this->tokenUrl,\n                'jti' => $this->generateAuthNonce(),\n                'iat' => time(),\n                'exp' => time() + 3600,\n            ];\n\n            $signatureBaseString = base64_encode(Json::encode($header)) . '.' . base64_encode(Json::encode($payload));\n            $signatureMethod = new HmacSha(['algorithm' => 'sha256']);\n            $signature = $signatureMethod->generateSignature($signatureBaseString, $this->clientSecret);\n\n            $assertion = $signatureBaseString . '.' . $signature;\n\n            $request->addData([\n                'assertion' => $assertion,\n            ]);\n        } else {\n            throw new InvalidConfigException('Unable to authenticate request: none of following auth methods is suported: ' . implode(', ', $supportedAuthMethods));\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function createToken(array $tokenConfig = [])\n    {\n        if ($this->validateJws) {\n            $jwsData = $this->loadJws($tokenConfig['params']['id_token']);\n            $this->validateClaims($jwsData);\n            $tokenConfig['params'] = array_merge($tokenConfig['params'], $jwsData);\n\n            if ($this->getValidateAuthNonce()) {\n                $authNonce = $this->getState('authNonce');\n                if (\n                    !isset($jwsData['nonce'])\n                    || empty($authNonce)\n                    || !Yii::$app->getSecurity()->compareString($jwsData['nonce'], $authNonce)\n                ) {\n                    throw new HttpException(400, 'Invalid auth nonce');\n                } else {\n                    $this->removeState('authNonce');\n                }\n            }\n        }\n\n        return parent::createToken($tokenConfig);\n    }\n\n    /**\n     * Return JwkSet, returning related data.\n     * @return JWKSet object represents a key set.\n     * @throws InvalidResponseException on failure.\n     */\n    protected function getJwkSet()\n    {\n        if ($this->_jwkSet === null) {\n            $cache = $this->getCache();\n            $cacheKey = $this->configParamsCacheKeyPrefix . '_jwkSet';\n            if ($cache === null || ($jwkSet = $cache->get($cacheKey)) === false) {\n                $request = $this->createRequest()\n                    ->setMethod('GET')\n                    ->setUrl($this->getConfigParam('jwks_uri'));\n                $response = $this->sendRequest($request);\n                $jwkSet = JWKFactory::createFromValues($response);\n            }\n\n            $this->_jwkSet = $jwkSet;\n\n            if ($cache !== null) {\n                $cache->set($cacheKey, $jwkSet);\n            }\n        }\n        return $this->_jwkSet;\n    }\n\n    /**\n     * Return JWSLoader that validate the JWS token.\n     * @return JWSLoader to do token validation.\n     * @throws InvalidConfigException on invalid algorithm provide in configuration.\n     */\n    protected function getJwsLoader()\n    {\n        if ($this->_jwsLoader === null) {\n            $algorithms = [];\n            foreach ($this->allowedJwsAlgorithms as $algorithm)\n            {\n                $class = '\\Jose\\Component\\Signature\\Algorithm\\\\' . $algorithm;\n                if (!class_exists($class))\n                {\n                    throw new InvalidConfigException(\"Alogrithm class $class doesn't exist\");\n                }\n                $algorithms[] = new $class();\n            }\n            $this->_jwsLoader = new JWSLoader(\n                new JWSSerializerManager([ new CompactSerializer() ]),\n                new JWSVerifier(new AlgorithmManager($algorithms)),\n                new HeaderCheckerManager(\n                    [ new AlgorithmChecker($this->allowedJwsAlgorithms) ],\n                    [ new JWSTokenSupport() ]\n                )\n            );\n        }\n        return $this->_jwsLoader;\n    }\n\n    /**\n     * Decrypts/validates JWS, returning related data.\n     * @param string $jws raw JWS input.\n     * @return array JWS underlying data.\n     * @throws HttpException on invalid JWS signature.\n     */\n    protected function loadJws($jws)\n    {\n        try {\n            $jwsLoader = $this->getJwsLoader();\n            $signature = null;\n            $jwsVerified = $jwsLoader->loadAndVerifyWithKeySet($jws, $this->getJwkSet(), $signature);\n            return Json::decode($jwsVerified->getPayload());\n        } catch (\\Exception $e) {\n            $message = YII_DEBUG ? 'Unable to verify JWS: ' . $e->getMessage() : 'Invalid JWS';\n            throw new HttpException(400, $message, $e->getCode(), $e);\n        }\n    }\n\n    /**\n     * Validates the claims data received from OpenID provider.\n     * @param array $claims claims data.\n     * @throws HttpException on invalid claims.\n     * @since 2.2.3\n     */\n    protected function validateClaims(array $claims)\n    {\n        $expectedIssuer = $this->getConfigParam('issuer', $this->issuerUrl);\n        if (!isset($claims['iss']) || (strcmp(rtrim($claims['iss'], '/'), rtrim($expectedIssuer, '/')) !== 0)) {\n            throw new HttpException(400, 'Invalid \"iss\"');\n        }\n        if (!isset($claims['aud'])\n            || (!is_string($claims['aud']) && !is_array($claims['aud']))\n            || (is_string($claims['aud']) && strcmp($claims['aud'], $this->clientId) !== 0)\n            || (is_array($claims['aud']) && !in_array($this->clientId, $claims['aud']))\n        ) {\n            throw new HttpException(400, 'Invalid \"aud\"');\n        }\n    }\n\n    /**\n     * Generates the auth nonce value.\n     * @return string auth nonce value.\n     */\n    protected function generateAuthNonce()\n    {\n        return Yii::$app->security->generateRandomString();\n    }\n}\n"], "filenames": ["CHANGELOG.md", "src/OAuth1.php", "src/OAuth2.php", "src/OpenIdConnect.php"], "buggy_code_start_loc": [8, 158, 121, 420], "buggy_code_end_loc": [8, 159, 122, 421], "fixing_code_start_loc": [9, 158, 121, 420], "fixing_code_end_loc": [10, 159, 126, 425], "type": "NVD-CWE-Other", "message": "yii2-authclient is an extension that adds OpenID, OAuth, OAuth2 and OpenId Connect consumers for the Yii framework 2.0. In yii2-authclient prior to version 2.2.15, the Oauth1/2 `state` and OpenID Connect `nonce` is vulnerable for a `timing attack` since it is compared via regular string comparison (instead of `Yii::$app->getSecurity()->compareString()`). Version 2.2.15 contains a patch for the issue. No known workarounds are available.", "other": {"cve": {"id": "CVE-2023-50708", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-22T19:15:08.840", "lastModified": "2024-01-08T17:42:45.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "yii2-authclient is an extension that adds OpenID, OAuth, OAuth2 and OpenId Connect consumers for the Yii framework 2.0. In yii2-authclient prior to version 2.2.15, the Oauth1/2 `state` and OpenID Connect `nonce` is vulnerable for a `timing attack` since it is compared via regular string comparison (instead of `Yii::$app->getSecurity()->compareString()`). Version 2.2.15 contains a patch for the issue. No known workarounds are available."}, {"lang": "es", "value": "yii2-authclient es una extensi\u00f3n que agrega consumidores OpenID, OAuth, OAuth2 y OpenId Connect para el framework Yii 2.0. En yii2-authclient antes de la versi\u00f3n 2.2.15, el `state` de Oauth1/2 y el `nonce` de OpenID Connect son vulnerables a un `ataque de sincronizaci\u00f3n` ya que se compara mediante una comparaci\u00f3n de cadenas regular (en lugar de `Yii::$app- &gt;getSecurity()-&gt;compareString()`). La versi\u00f3n 2.2.15 contiene un parche para el problema. No hay workarounds disponibles."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yiiframework:yii2-authclient:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.15", "matchCriteriaId": "AA4F5AF6-EA08-40F8-9C22-EA09F0653F11"}]}]}], "references": [{"url": "https://github.com/yiisoft/yii2-authclient/blob/0d1c3880f4d79e20aa1d77c012650b54e69695ff/src/OAuth1.php#L158", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/yiisoft/yii2-authclient/blob/0d1c3880f4d79e20aa1d77c012650b54e69695ff/src/OAuth2.php#L121", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/yiisoft/yii2-authclient/blob/0d1c3880f4d79e20aa1d77c012650b54e69695ff/src/OpenIdConnect.php#L420", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/yiisoft/yii2-authclient/commit/dabddf2154ab7e7703740205a069202554089248", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/yiisoft/yii2-authclient/security/advisories/GHSA-w8vh-p74j-x9xp", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/yiisoft/yii2-authclient/commit/dabddf2154ab7e7703740205a069202554089248"}}