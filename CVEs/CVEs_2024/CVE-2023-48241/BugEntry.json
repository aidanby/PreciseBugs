{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.query.solr.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map.Entry;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrDocumentList;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryExecutor;\nimport org.xwiki.query.SecureQuery;\nimport org.xwiki.search.solr.internal.api.SolrInstance;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\n\n/**\n * Executes Solr queries.\n * <p>\n * For now, the result is the direct {@link QueryResponse}, in lack of a more expressive result type than the generic\n * List that the {@link #execute(Query)} method allows.\n * \n * @version $Id$\n * @since 4.3M2\n */\n@Component\n@Named(SolrQueryExecutor.SOLR)\n@Singleton\npublic class SolrQueryExecutor implements QueryExecutor\n{\n    /**\n     * Query language ID.\n     */\n    public static final String SOLR = \"solr\";\n\n    /**\n     * The parameter that specifies the list of supported locales. This is used to add generic (unlocalized) aliases for\n     * localized query fields (e.g. 'title' alias for 'title_en' query field).\n     */\n    private static final String PARAM_SUPPORTED_LOCALES = \"xwiki.supportedLocales\";\n\n    /**\n     * Logging framework.\n     */\n    @Inject\n    protected Logger logger;\n\n    @Inject\n    protected AuthorizationManager authorization;\n\n    /**\n     * Provider for the {@link SolrInstance} that allows communication with the Solr server.\n     */\n    @Inject\n    protected SolrInstance solrInstance;\n\n    /**\n     * Used to retrieve the configured supported locales.\n     */\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    /**\n     * Used to extract a {@link DocumentReference} from a {@link SolrDocument}.\n     */\n    @Inject\n    private DocumentReferenceResolver<SolrDocument> solrDocumentReferenceResolver;\n\n    @Inject\n    private JobProgressManager progress;\n\n    @Override\n    public <T> List<T> execute(Query query) throws QueryException\n    {\n        this.progress.startStep(query, \"query.solr.progress.execute\", \"Execute Solr query [{}]\", query);\n        this.progress.pushLevelProgress(3, query);\n\n        try {\n            this.progress.startStep(query, \"query.solr.progress.execute.prepare\", \"Prepare\");\n\n            SolrQuery solrQuery = createSolrQuery(query);\n\n            this.progress.startStep(query, \"query.solr.progress.execute.execute\", \"Execute\");\n\n            QueryResponse response = this.solrInstance.query(solrQuery);\n\n            this.progress.startStep(query, \"query.solr.progress.execute.filter\", \"Filter\");\n\n            // Check access rights need to be checked before returning the response.\n            // FIXME: this is not really the best way, mostly because at this point all grouping operations\n            // have already been performed and any change on the result will not ensure that the grouping\n            // information (facets, highlighting, maxScore, etc.) is still relevant.\n            // A better way would be using a PostFilter as described in this article:\n            // http://java.dzone.com/articles/custom-security-filtering-solr\n            // Basically, we would be asking\n            List<DocumentReference> usersToCheck = new ArrayList<>(2);\n            if (query instanceof SecureQuery) {\n                if (((SecureQuery) query).isCurrentUserChecked()) {\n                    usersToCheck.add(xcontextProvider.get().getUserReference());\n                }\n                if (((SecureQuery) query).isCurrentAuthorChecked()) {\n                    usersToCheck.add(xcontextProvider.get().getAuthorReference());\n                }\n            } else {\n                usersToCheck.add(xcontextProvider.get().getUserReference());\n                usersToCheck.add(xcontextProvider.get().getAuthorReference());\n            }\n            if (!usersToCheck.isEmpty()) {\n                filterResponse(response, usersToCheck);\n            }\n\n            return (List<T>) Arrays.asList(response);\n        } catch (Exception e) {\n            throw new QueryException(\"Exception while executing query\", query, e);\n        } finally {\n            this.progress.popLevelProgress(query);\n            this.progress.endStep(query);\n        }\n    }\n\n    private SolrQuery createSolrQuery(Query query)\n    {\n        SolrQuery solrQuery = new SolrQuery(query.getStatement());\n\n        // Overwrite offset and limit only if the query object explicitly says so, otherwise use whatever the query\n        // statement says or the defaults.\n        if (query.getOffset() > 0) {\n            solrQuery.setStart(query.getOffset());\n        }\n        if (query.getLimit() > 0) {\n            solrQuery.setRows(query.getLimit());\n        }\n\n        // TODO: good idea? Any confusion? Do we really needs something like this?\n        // Reuse the Query.getNamedParameters() map to get extra parameters.\n        for (Entry<String, Object> entry : query.getNamedParameters().entrySet()) {\n            Object value = entry.getValue();\n\n            if (value instanceof Iterable) {\n                solrQuery.set(entry.getKey(), toStringArray((Iterable) value));\n            } else if (value != null && value.getClass().isArray()) {\n                solrQuery.set(entry.getKey(), toStringArray(value));\n            } else {\n                solrQuery.set(entry.getKey(), String.valueOf(value));\n            }\n        }\n\n        // Make sure the list of supported locales is set so the names of the fields that are indexed in multiple\n        // languages are expanded in the search query. For instance, the query \"title:text\" will be expanded to\n        // \"title__:text OR title_en:text OR title_fr:text\" if the list of supported locales is [en, fr].\n        if (!solrQuery.getParameterNames().contains(PARAM_SUPPORTED_LOCALES)) {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            solrQuery.set(PARAM_SUPPORTED_LOCALES,\n                StringUtils.join(xcontext.getWiki().getAvailableLocales(xcontext), \",\"));\n        }\n\n        return solrQuery;\n    }\n\n    /**\n     * Converts an arbitrary array to an array containing its string representations.\n     * \n     * @param array an array of arbitrary type, must not be null\n     * @return an array with the string representations of the passed array's items\n     */\n    private String[] toStringArray(Object array)\n    {\n        int length = Array.getLength(array);\n        String[] args = new String[length];\n        for (int i = 0; i < length; i++) {\n            args[i] = String.valueOf(Array.get(array, i));\n        }\n\n        return args;\n    }\n\n    /**\n     * Converts the given iterable object to an array containing its string representations.\n     * \n     * @param iterable the iterable object, must not be null\n     * @return an array with the string representations of the passed iterable's items\n     */\n    private String[] toStringArray(Iterable iterable)\n    {\n        List<String> args = new ArrayList<String>();\n        for (Object obj : iterable) {\n            args.add(String.valueOf(obj));\n        }\n        return args.toArray(new String[args.size()]);\n    }\n\n    /**\n     * Filter out results from the response that the current user does not have access to view.\n     * \n     * @param response the Solr response to filter\n     */\n    protected void filterResponse(QueryResponse response, List<DocumentReference> usersToCheck)\n    {\n        SolrDocumentList results = response.getResults();\n        long numFound = results.getNumFound();\n\n        // Since we are modifying the results collection, we need to iterate over its copy.\n        for (SolrDocument result : new ArrayList<SolrDocument>(results)) {\n            try {\n                DocumentReference resultDocumentReference = this.solrDocumentReferenceResolver.resolve(result);\n\n                if (!isAllowed(resultDocumentReference, usersToCheck)) {\n\n                    // Remove the current incompatible result.\n                    results.remove(result);\n\n                    // Decrement the number of results.\n                    numFound--;\n\n                    // FIXME: We should update maxScore as well when removing the top scored item. How do we do that?\n                    // Sorting based on score might be a not so expensive option.\n\n                    // FIXME: What about highlighting, facets and all the other data inside the QueryResponse?\n                }\n            } catch (Exception e) {\n                this.logger.warn(\"Skipping bad result: {}\", result, e);\n            }\n        }\n\n        // Update the new number of results, excluding the filtered ones.\n        if (numFound < 0) {\n            // Lower bound guard for the total number of results.\n            numFound = 0;\n        }\n        results.setNumFound(numFound);\n    }\n\n    protected boolean isAllowed(DocumentReference resultDocumentReference, List<DocumentReference> usersToCheck)\n    {\n        for (DocumentReference user : usersToCheck) {\n            if (!this.authorization.hasAccess(Right.VIEW, user, resultDocumentReference)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.query.solr;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrDocumentList;\nimport org.apache.solr.common.params.SolrParams;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.xwiki.component.internal.ContextComponentManagerProvider;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.query.QueryExecutor;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.query.internal.DefaultQuery;\nimport org.xwiki.query.internal.DefaultQueryExecutorManager;\nimport org.xwiki.query.internal.DefaultQueryManager;\nimport org.xwiki.query.solr.internal.SolrQueryExecutor;\nimport org.xwiki.search.solr.internal.api.SolrInstance;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.mockito.MockitoComponentMockingRule;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.test.MockitoOldcoreRule;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Basic test for the {@link SolrQueryExecutor}.\n * \n * @version $Id$\n */\n@ComponentList({DefaultQueryManager.class, DefaultQueryExecutorManager.class, ContextComponentManagerProvider.class})\n@ReferenceComponentList\npublic class SolrQueryExecutorTest\n{\n    private static final String ITERABLE_PARAM_NAME = \"multiParam\";\n\n    private static final String[] ITERABLE_PARAM_EXPECTED = {\"value1\", \"value2\"};\n\n    private static final Iterable<String> ITERABLE_PARAM_VALUE = Arrays.asList(ITERABLE_PARAM_EXPECTED);\n\n    private static final String INT_ARR_PARAM_NAME = \"intArrayParam\";\n\n    private static final String[] INT_ARR_PARAM_EXPECTED = {\"-42\", \"4711\"};\n\n    private static final int[] INT_ARR_PARAM_VALUE = {-42, 4711};\n\n    private static final String STR_ARR_PARAM_NAME = \"stringArrayParam\";\n\n    private static final String[] STR_ARR_PARAM_EXPECTED = {\"valueA\", \"valueB\"};\n\n    private static final String[] STR_ARR_PARAM_VALUE = STR_ARR_PARAM_EXPECTED;\n\n    private static final String SINGLE_PARAM_NAME = \"singleParam\";\n\n    private static final Object SINGLE_PARAM_VALUE = new Object();\n\n    private static final Object SINGLE_PARAM_EXPECTED = SINGLE_PARAM_VALUE.toString();\n\n    public final MockitoComponentMockingRule<QueryExecutor> componentManager =\n        new MockitoComponentMockingRule<QueryExecutor>(SolrQueryExecutor.class);\n\n    @Rule\n    public final MockitoOldcoreRule oldCore = new MockitoOldcoreRule(this.componentManager);\n\n    private SolrInstance solr;\n\n    @Before\n    public void configure() throws Exception\n    {\n        this.solr = this.componentManager.registerMockComponent(SolrInstance.class);\n    }\n\n    @Test\n    public void testExecutorRegistration() throws Exception\n    {\n        QueryManager queryManager = this.componentManager.getInstance(QueryManager.class);\n\n        Assert.assertTrue(queryManager.getLanguages().contains(SolrQueryExecutor.SOLR));\n    }\n\n    @Test\n    public void testMultiValuedQueryArgs() throws Exception\n    {\n        when(solr.query(any(SolrQuery.class))).then(new Answer<Object>()\n        {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable\n            {\n                SolrQuery solrQuery = (SolrQuery) invocation.getArguments()[0];\n\n                Assert.assertArrayEquals(ITERABLE_PARAM_EXPECTED, solrQuery.getParams(ITERABLE_PARAM_NAME));\n                Assert.assertArrayEquals(INT_ARR_PARAM_EXPECTED, solrQuery.getParams(INT_ARR_PARAM_NAME));\n                Assert.assertArrayEquals(STR_ARR_PARAM_EXPECTED, solrQuery.getParams(STR_ARR_PARAM_NAME));\n                Assert.assertEquals(SINGLE_PARAM_EXPECTED, solrQuery.get(SINGLE_PARAM_NAME));\n\n                // Check that the default list of supported locales is taken from the wiki configuration.\n                Assert.assertEquals(\"en,fr,de\", solrQuery.get(\"xwiki.supportedLocales\"));\n\n                QueryResponse r = mock(QueryResponse.class);\n                when(r.getResults()).thenReturn(new SolrDocumentList());\n                return r;\n            }\n        });\n\n        DefaultQuery query = new DefaultQuery(\"TestQuery\", null);\n        query.bindValue(ITERABLE_PARAM_NAME, ITERABLE_PARAM_VALUE);\n        query.bindValue(INT_ARR_PARAM_NAME, INT_ARR_PARAM_VALUE);\n        query.bindValue(STR_ARR_PARAM_NAME, STR_ARR_PARAM_VALUE);\n        query.bindValue(SINGLE_PARAM_NAME, SINGLE_PARAM_VALUE);\n\n        // The default list of supported locales should be taken from the wiki configuration.\n        XWikiContext xcontext = this.oldCore.getXWikiContext();\n        doReturn(Arrays.asList(Locale.ENGLISH, Locale.FRENCH, Locale.GERMAN)).when(this.oldCore.getSpyXWiki())\n            .getAvailableLocales(xcontext);\n\n        this.componentManager.getComponentUnderTest().execute(query);\n    }\n\n    @Test\n    public void filterResponse() throws Exception\n    {\n        ParameterizedType resolverType =\n            new DefaultParameterizedType(null, DocumentReferenceResolver.class, SolrDocument.class);\n        DocumentReferenceResolver<SolrDocument> resolver = this.componentManager.getInstance(resolverType);\n\n        AuthorizationManager authorizationManager = this.componentManager.getInstance(AuthorizationManager.class);\n\n        DocumentReference currentUserReference = new DocumentReference(\"xwiki\", \"XWiki\", \"currentuser\");\n        this.oldCore.getXWikiContext().setUserReference(currentUserReference);\n\n        DocumentReference currentAuthorReference = new DocumentReference(\"xwiki\", \"XWiki\", \"currentauthor\");\n        XWikiDocument currentDocument = new XWikiDocument(currentAuthorReference);\n        currentDocument.setContentAuthorReference(currentAuthorReference);\n        this.oldCore.getXWikiContext().setDoc(currentDocument);\n\n        DocumentReference aliceReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n        when(authorizationManager.hasAccess(Right.VIEW, currentAuthorReference, aliceReference)).thenReturn(true);\n        SolrDocument alice = new SolrDocument();\n        when(resolver.resolve(alice)).thenReturn(aliceReference);\n\n        DocumentReference bobReference = new DocumentReference(\"wiki\", \"Users\", \"Bob\");\n        when(authorizationManager.hasAccess(Right.VIEW, currentUserReference, bobReference)).thenReturn(true);\n        when(authorizationManager.hasAccess(Right.VIEW, currentAuthorReference, bobReference)).thenReturn(true);\n        SolrDocument bob = new SolrDocument();\n        when(resolver.resolve(bob)).thenReturn(bobReference);\n\n        DocumentReference carolReference = new DocumentReference(\"wiki\", \"Users\", \"Carol\");\n        when(authorizationManager.hasAccess(Right.VIEW, currentUserReference, carolReference)).thenReturn(true);\n        SolrDocument carol = new SolrDocument();\n        when(resolver.resolve(carol)).thenReturn(carolReference);\n\n        SolrDocumentList sourceResults = new SolrDocumentList();\n        sourceResults.addAll(Arrays.asList(alice, bob, carol));\n        sourceResults.setNumFound(3);\n\n        QueryResponse response = mock(QueryResponse.class);\n        when(this.solr.query(any(SolrParams.class))).thenReturn(response);\n\n        DefaultQuery query = new DefaultQuery(\"\", null);\n\n        // No right check\n\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        SolrDocumentList results =\n            ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(alice, bob, carol), results);\n\n        // Check current user right\n\n        query.checkCurrentUser(true);\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(bob, carol), results);\n\n        // Check both current user and author rights\n\n        query.checkCurrentAuthor(true);\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(bob), results);\n\n        // Check current author right\n\n        query.checkCurrentUser(false);\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(alice, bob), results);\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.query.solr.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map.Entry;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrDocumentList;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryExecutor;\nimport org.xwiki.query.SecureQuery;\nimport org.xwiki.search.solr.internal.api.SolrInstance;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\n\n/**\n * Executes Solr queries.\n * <p>\n * For now, the result is the direct {@link QueryResponse}, in lack of a more expressive result type than the generic\n * List that the {@link #execute(Query)} method allows.\n * \n * @version $Id$\n * @since 4.3M2\n */\n@Component\n@Named(SolrQueryExecutor.SOLR)\n@Singleton\npublic class SolrQueryExecutor implements QueryExecutor\n{\n    /**\n     * Query language ID.\n     */\n    public static final String SOLR = \"solr\";\n\n    /**\n     * The parameter that specifies the list of supported locales. This is used to add generic (unlocalized) aliases for\n     * localized query fields (e.g. 'title' alias for 'title_en' query field).\n     */\n    private static final String PARAM_SUPPORTED_LOCALES = \"xwiki.supportedLocales\";\n\n    /**\n     * Logging framework.\n     */\n    @Inject\n    protected Logger logger;\n\n    @Inject\n    protected AuthorizationManager authorization;\n\n    /**\n     * Provider for the {@link SolrInstance} that allows communication with the Solr server.\n     */\n    @Inject\n    protected SolrInstance solrInstance;\n\n    /**\n     * Used to retrieve the configured supported locales.\n     */\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    /**\n     * Used to extract a {@link DocumentReference} from a {@link SolrDocument}.\n     */\n    @Inject\n    private DocumentReferenceResolver<SolrDocument> solrDocumentReferenceResolver;\n\n    @Inject\n    private JobProgressManager progress;\n\n    @Override\n    public <T> List<T> execute(Query query) throws QueryException\n    {\n        this.progress.startStep(query, \"query.solr.progress.execute\", \"Execute Solr query [{}]\", query);\n        this.progress.pushLevelProgress(3, query);\n\n        try {\n            this.progress.startStep(query, \"query.solr.progress.execute.prepare\", \"Prepare\");\n\n            SolrQuery solrQuery = createSolrQuery(query);\n\n            this.progress.startStep(query, \"query.solr.progress.execute.execute\", \"Execute\");\n\n            QueryResponse response = this.solrInstance.query(solrQuery);\n\n            this.progress.startStep(query, \"query.solr.progress.execute.filter\", \"Filter\");\n\n            // Check access rights need to be checked before returning the response.\n            // FIXME: this is not really the best way, mostly because at this point all grouping operations\n            // have already been performed and any change on the result will not ensure that the grouping\n            // information (facets, highlighting, maxScore, etc.) is still relevant.\n            // A better way would be using a PostFilter as described in this article:\n            // http://java.dzone.com/articles/custom-security-filtering-solr\n            // Basically, we would be asking\n            List<DocumentReference> usersToCheck = new ArrayList<>(2);\n            if (query instanceof SecureQuery) {\n                if (((SecureQuery) query).isCurrentUserChecked()) {\n                    usersToCheck.add(xcontextProvider.get().getUserReference());\n                }\n                if (((SecureQuery) query).isCurrentAuthorChecked()) {\n                    usersToCheck.add(xcontextProvider.get().getAuthorReference());\n                }\n            } else {\n                usersToCheck.add(xcontextProvider.get().getUserReference());\n                usersToCheck.add(xcontextProvider.get().getAuthorReference());\n            }\n            if (!usersToCheck.isEmpty()) {\n                filterResponse(response, usersToCheck);\n            }\n\n            return (List<T>) Arrays.asList(response);\n        } catch (Exception e) {\n            throw new QueryException(\"Exception while executing query\", query, e);\n        } finally {\n            this.progress.popLevelProgress(query);\n            this.progress.endStep(query);\n        }\n    }\n\n    private SolrQuery createSolrQuery(Query query)\n    {\n        SolrQuery solrQuery = new SolrQuery(query.getStatement());\n\n        // Overwrite offset and limit only if the query object explicitly says so, otherwise use whatever the query\n        // statement says or the defaults.\n        if (query.getOffset() > 0) {\n            solrQuery.setStart(query.getOffset());\n        }\n        if (query.getLimit() > 0) {\n            solrQuery.setRows(query.getLimit());\n        }\n\n        // TODO: good idea? Any confusion? Do we really needs something like this?\n        // Reuse the Query.getNamedParameters() map to get extra parameters.\n        for (Entry<String, Object> entry : query.getNamedParameters().entrySet()) {\n            Object value = entry.getValue();\n\n            if (value instanceof Iterable) {\n                solrQuery.set(entry.getKey(), toStringArray((Iterable) value));\n            } else if (value != null && value.getClass().isArray()) {\n                solrQuery.set(entry.getKey(), toStringArray(value));\n            } else {\n                solrQuery.set(entry.getKey(), String.valueOf(value));\n            }\n        }\n\n        // Make sure the list of supported locales is set so the names of the fields that are indexed in multiple\n        // languages are expanded in the search query. For instance, the query \"title:text\" will be expanded to\n        // \"title__:text OR title_en:text OR title_fr:text\" if the list of supported locales is [en, fr].\n        if (!solrQuery.getParameterNames().contains(PARAM_SUPPORTED_LOCALES)) {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            solrQuery.set(PARAM_SUPPORTED_LOCALES,\n                StringUtils.join(xcontext.getWiki().getAvailableLocales(xcontext), \",\"));\n        }\n\n        return solrQuery;\n    }\n\n    /**\n     * Converts an arbitrary array to an array containing its string representations.\n     * \n     * @param array an array of arbitrary type, must not be null\n     * @return an array with the string representations of the passed array's items\n     */\n    private String[] toStringArray(Object array)\n    {\n        int length = Array.getLength(array);\n        String[] args = new String[length];\n        for (int i = 0; i < length; i++) {\n            args[i] = String.valueOf(Array.get(array, i));\n        }\n\n        return args;\n    }\n\n    /**\n     * Converts the given iterable object to an array containing its string representations.\n     * \n     * @param iterable the iterable object, must not be null\n     * @return an array with the string representations of the passed iterable's items\n     */\n    private String[] toStringArray(Iterable iterable)\n    {\n        List<String> args = new ArrayList<String>();\n        for (Object obj : iterable) {\n            args.add(String.valueOf(obj));\n        }\n        return args.toArray(new String[args.size()]);\n    }\n\n    /**\n     * Filter out results from the response that the current user does not have access to view.\n     * \n     * @param response the Solr response to filter\n     */\n    protected void filterResponse(QueryResponse response, List<DocumentReference> usersToCheck)\n    {\n        SolrDocumentList results = response.getResults();\n        long numResults = results.size();\n\n        results.removeIf(result -> {\n            boolean keep = false;\n            try {\n                DocumentReference resultDocumentReference = this.solrDocumentReferenceResolver.resolve(result);\n\n                keep = isAllowed(resultDocumentReference, usersToCheck);\n            } catch (Exception e) {\n                // Don't take any risk of including a result for which we cannot determine the document reference and\n                // thus cannot determine if the given users have access to it or not.\n                this.logger.warn(\"Removing bad result: {}\", result, e);\n            }\n\n            // FIXME: We should update maxScore as well when removing the top scored item. How do we do that?\n            // Sorting based on score might be a not so expensive option.\n\n            // FIXME: What about highlighting, facets and all the other data inside the QueryResponse?\n\n            return !keep;\n        });\n\n        long numFilteredResults = numResults - results.size();\n\n        // Update the number of results, excluding the filtered ones.\n        // Lower bound guard for the total number of results.\n        long numFound = Math.max(0, response.getResults().getNumFound() - numFilteredResults);\n\n        results.setNumFound(numFound);\n    }\n\n    protected boolean isAllowed(DocumentReference resultDocumentReference, List<DocumentReference> usersToCheck)\n    {\n        for (DocumentReference user : usersToCheck) {\n            if (!this.authorization.hasAccess(Right.VIEW, user, resultDocumentReference)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.query.solr;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Locale;\n\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrDocumentList;\nimport org.apache.solr.common.params.SolrParams;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.xwiki.component.internal.ContextComponentManagerProvider;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.query.QueryExecutor;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.query.internal.DefaultQuery;\nimport org.xwiki.query.internal.DefaultQueryExecutorManager;\nimport org.xwiki.query.internal.DefaultQueryManager;\nimport org.xwiki.query.solr.internal.SolrQueryExecutor;\nimport org.xwiki.search.solr.internal.api.SolrInstance;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.mockito.MockitoComponentMockingRule;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.test.MockitoOldcoreRule;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Basic test for the {@link SolrQueryExecutor}.\n * \n * @version $Id$\n */\n@ComponentList({DefaultQueryManager.class, DefaultQueryExecutorManager.class, ContextComponentManagerProvider.class})\n@ReferenceComponentList\npublic class SolrQueryExecutorTest\n{\n    private static final String ITERABLE_PARAM_NAME = \"multiParam\";\n\n    private static final String[] ITERABLE_PARAM_EXPECTED = { \"value1\", \"value2\" };\n\n    private static final Iterable<String> ITERABLE_PARAM_VALUE = Arrays.asList(ITERABLE_PARAM_EXPECTED);\n\n    private static final String INT_ARR_PARAM_NAME = \"intArrayParam\";\n\n    private static final String[] INT_ARR_PARAM_EXPECTED = { \"-42\", \"4711\" };\n\n    private static final int[] INT_ARR_PARAM_VALUE = { -42, 4711 };\n\n    private static final String STR_ARR_PARAM_NAME = \"stringArrayParam\";\n\n    private static final String[] STR_ARR_PARAM_EXPECTED = { \"valueA\", \"valueB\" };\n\n    private static final String[] STR_ARR_PARAM_VALUE = STR_ARR_PARAM_EXPECTED;\n\n    private static final String SINGLE_PARAM_NAME = \"singleParam\";\n\n    private static final Object SINGLE_PARAM_VALUE = new Object();\n\n    private static final Object SINGLE_PARAM_EXPECTED = SINGLE_PARAM_VALUE.toString();\n\n    public final MockitoComponentMockingRule<QueryExecutor> componentManager =\n        new MockitoComponentMockingRule<QueryExecutor>(SolrQueryExecutor.class);\n\n    @Rule\n    public final MockitoOldcoreRule oldCore = new MockitoOldcoreRule(this.componentManager);\n\n    private SolrInstance solr;\n\n    @Before\n    public void configure() throws Exception\n    {\n        this.solr = this.componentManager.registerMockComponent(SolrInstance.class);\n    }\n\n    @Test\n    public void testExecutorRegistration() throws Exception\n    {\n        QueryManager queryManager = this.componentManager.getInstance(QueryManager.class);\n\n        Assert.assertTrue(queryManager.getLanguages().contains(SolrQueryExecutor.SOLR));\n    }\n\n    @Test\n    public void testMultiValuedQueryArgs() throws Exception\n    {\n        when(solr.query(any(SolrQuery.class))).then(new Answer<Object>()\n        {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable\n            {\n                SolrQuery solrQuery = (SolrQuery) invocation.getArguments()[0];\n\n                Assert.assertArrayEquals(ITERABLE_PARAM_EXPECTED, solrQuery.getParams(ITERABLE_PARAM_NAME));\n                Assert.assertArrayEquals(INT_ARR_PARAM_EXPECTED, solrQuery.getParams(INT_ARR_PARAM_NAME));\n                Assert.assertArrayEquals(STR_ARR_PARAM_EXPECTED, solrQuery.getParams(STR_ARR_PARAM_NAME));\n                Assert.assertEquals(SINGLE_PARAM_EXPECTED, solrQuery.get(SINGLE_PARAM_NAME));\n\n                // Check that the default list of supported locales is taken from the wiki configuration.\n                Assert.assertEquals(\"en,fr,de\", solrQuery.get(\"xwiki.supportedLocales\"));\n\n                QueryResponse r = mock(QueryResponse.class);\n                when(r.getResults()).thenReturn(new SolrDocumentList());\n                return r;\n            }\n        });\n\n        DefaultQuery query = new DefaultQuery(\"TestQuery\", null);\n        query.bindValue(ITERABLE_PARAM_NAME, ITERABLE_PARAM_VALUE);\n        query.bindValue(INT_ARR_PARAM_NAME, INT_ARR_PARAM_VALUE);\n        query.bindValue(STR_ARR_PARAM_NAME, STR_ARR_PARAM_VALUE);\n        query.bindValue(SINGLE_PARAM_NAME, SINGLE_PARAM_VALUE);\n\n        // The default list of supported locales should be taken from the wiki configuration.\n        XWikiContext xcontext = this.oldCore.getXWikiContext();\n        doReturn(Arrays.asList(Locale.ENGLISH, Locale.FRENCH, Locale.GERMAN)).when(this.oldCore.getSpyXWiki())\n            .getAvailableLocales(xcontext);\n\n        this.componentManager.getComponentUnderTest().execute(query);\n    }\n\n    @Test\n    public void filterResponse() throws Exception\n    {\n        ParameterizedType resolverType =\n            new DefaultParameterizedType(null, DocumentReferenceResolver.class, SolrDocument.class);\n        DocumentReferenceResolver<SolrDocument> resolver = this.componentManager.getInstance(resolverType);\n\n        AuthorizationManager authorizationManager = this.componentManager.getInstance(AuthorizationManager.class);\n\n        DocumentReference currentUserReference = new DocumentReference(\"xwiki\", \"XWiki\", \"currentuser\");\n        this.oldCore.getXWikiContext().setUserReference(currentUserReference);\n\n        DocumentReference currentAuthorReference = new DocumentReference(\"xwiki\", \"XWiki\", \"currentauthor\");\n        XWikiDocument currentDocument = new XWikiDocument(currentAuthorReference);\n        currentDocument.setContentAuthorReference(currentAuthorReference);\n        this.oldCore.getXWikiContext().setDoc(currentDocument);\n\n        DocumentReference aliceReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n        when(authorizationManager.hasAccess(Right.VIEW, currentAuthorReference, aliceReference)).thenReturn(true);\n        SolrDocument alice = new SolrDocument();\n        when(resolver.resolve(alice)).thenReturn(aliceReference);\n\n        DocumentReference bobReference = new DocumentReference(\"wiki\", \"Users\", \"Bob\");\n        when(authorizationManager.hasAccess(Right.VIEW, currentUserReference, bobReference)).thenReturn(true);\n        when(authorizationManager.hasAccess(Right.VIEW, currentAuthorReference, bobReference)).thenReturn(true);\n        SolrDocument bob = new SolrDocument();\n        when(resolver.resolve(bob)).thenReturn(bobReference);\n\n        DocumentReference carolReference = new DocumentReference(\"wiki\", \"Users\", \"Carol\");\n        when(authorizationManager.hasAccess(Right.VIEW, currentUserReference, carolReference)).thenReturn(true);\n        SolrDocument carol = new SolrDocument();\n        when(resolver.resolve(carol)).thenReturn(carolReference);\n\n        SolrDocumentList sourceResults = new SolrDocumentList();\n        sourceResults.addAll(Arrays.asList(alice, bob, carol));\n        sourceResults.setNumFound(3);\n\n        QueryResponse response = mock(QueryResponse.class);\n        when(this.solr.query(any(SolrParams.class))).thenReturn(response);\n\n        DefaultQuery query = new DefaultQuery(\"\", null);\n\n        // No right check\n\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        SolrDocumentList results =\n            ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(alice, bob, carol), results);\n\n        // Check current user right\n\n        query.checkCurrentUser(true);\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(bob, carol), results);\n\n        // Check both current user and author rights\n\n        query.checkCurrentAuthor(true);\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(bob), results);\n\n        // Check current author right\n\n        query.checkCurrentUser(false);\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(alice, bob), results);\n    }\n\n    @Test\n    public void filterResponseWithException() throws Exception\n    {\n        ParameterizedType resolverType =\n            new DefaultParameterizedType(null, DocumentReferenceResolver.class, SolrDocument.class);\n        DocumentReferenceResolver<SolrDocument> resolver = this.componentManager.getInstance(resolverType);\n\n        AuthorizationManager authorizationManager = this.componentManager.getInstance(AuthorizationManager.class);\n\n        DocumentReference currentUserReference = new DocumentReference(\"xwiki\", \"XWiki\", \"currentuser\");\n        this.oldCore.getXWikiContext().setUserReference(currentUserReference);\n\n        DocumentReference aliceReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n        SolrDocument alice = new SolrDocument();\n        when(resolver.resolve(alice)).thenReturn(aliceReference);\n\n        DocumentReference bobReference = new DocumentReference(\"wiki\", \"Users\", \"Bob\");\n        when(authorizationManager.hasAccess(Right.VIEW, currentUserReference, bobReference)).thenReturn(true);\n        SolrDocument bob = new SolrDocument();\n        when(resolver.resolve(bob)).thenReturn(bobReference);\n\n        SolrDocumentList sourceResults = new SolrDocumentList();\n        sourceResults.addAll(Arrays.asList(alice, bob));\n        sourceResults.setNumFound(2);\n\n        QueryResponse response = mock(QueryResponse.class);\n        when(this.solr.query(any(SolrParams.class))).thenReturn(response);\n\n        DefaultQuery query = new DefaultQuery(\"\", null);\n\n        // No right check, verify that the setup works.\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n        SolrDocumentList results =\n            ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Arrays.asList(alice, bob), results);\n        assertEquals(2, results.getNumFound());\n\n        // Check current user right\n        query.checkCurrentUser(true);\n\n        // Throw an exception when resolving Alice\n        when(resolver.resolve(alice)).thenThrow(new RuntimeException(\"Alice\"));\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Collections.singletonList(bob), results);\n        assertEquals(1, results.getNumFound());\n\n        // Throw also an exception when resolving Bob\n        when(resolver.resolve(bob)).thenThrow(new RuntimeException(\"Bob\"));\n        when(response.getResults()).thenReturn((SolrDocumentList) sourceResults.clone());\n\n        // Assert that the results are empty when both throw an exception\n        results = ((QueryResponse) this.componentManager.getComponentUnderTest().execute(query).get(0)).getResults();\n        assertEquals(Collections.emptyList(), results);\n        assertEquals(0, results.getNumFound());\n    }\n}"], "filenames": ["xwiki-platform-core/xwiki-platform-search/xwiki-platform-search-solr/xwiki-platform-search-solr-query/src/main/java/org/xwiki/query/solr/internal/SolrQueryExecutor.java", "xwiki-platform-core/xwiki-platform-search/xwiki-platform-search-solr/xwiki-platform-search-solr-query/src/test/java/org/xwiki/query/solr/SolrQueryExecutorTest.java"], "buggy_code_start_loc": [236, 23], "buggy_code_end_loc": [266, 232], "fixing_code_start_loc": [236, 24], "fixing_code_end_loc": [264, 291], "type": "NVD-CWE-noinfo", "message": "XWiki Platform is a generic wiki platform. Starting in version 6.3-milestone-2 and prior to versions 14.10.15, 15.5.1, and 15.6RC1, the Solr-based search suggestion provider that also duplicates as generic JavaScript API for search results in XWiki exposes the content of all documents of all wikis to anybody who has access to it, by default it is public. This exposes all information stored in the wiki (but not some protected information like password hashes). While there is a right check normally, the right check can be circumvented by explicitly requesting fields from Solr that don't include the data for the right check. This has been fixed in XWiki 15.6RC1, 15.5.1 and 14.10.15 by not listing documents whose rights cannot be checked. No known workarounds are available.", "other": {"cve": {"id": "CVE-2023-48241", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-20T18:15:07.440", "lastModified": "2023-11-29T20:49:19.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform. Starting in version 6.3-milestone-2 and prior to versions 14.10.15, 15.5.1, and 15.6RC1, the Solr-based search suggestion provider that also duplicates as generic JavaScript API for search results in XWiki exposes the content of all documents of all wikis to anybody who has access to it, by default it is public. This exposes all information stored in the wiki (but not some protected information like password hashes). While there is a right check normally, the right check can be circumvented by explicitly requesting fields from Solr that don't include the data for the right check. This has been fixed in XWiki 15.6RC1, 15.5.1 and 14.10.15 by not listing documents whose rights cannot be checked. No known workarounds are available."}, {"lang": "es", "value": "XWiki Platform es una plataforma wiki gen\u00e9rica. A partir de la versi\u00f3n 6.3-milestone-2 y antes de las versiones 14.10.15, 15.5.1 y 15.6RC1, el proveedor de sugerencias de b\u00fasqueda basado en Solr que tambi\u00e9n se duplica como API JavaScript gen\u00e9rica para los resultados de b\u00fasqueda en XWiki expone el contenido de todos los documentos de todos los wikis a cualquiera que tenga acceso a ellos, por defecto es p\u00fablico. Esto expone toda la informaci\u00f3n almacenada en el wiki (pero no parte de la informaci\u00f3n protegida como los hashes de contrase\u00f1as). Si bien normalmente existe una verificaci\u00f3n correcta, esta se puede eludir solicitando expl\u00edcitamente campos de Solr que no incluyan los datos para la verificaci\u00f3n correcta. Esto se solucion\u00f3 en XWiki 15.6RC1, 15.5.1 y 14.10.15 al no enumerar los documentos cuyos derechos no se pueden verificar. No hay workarounds conocidos disponibles."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.4", "versionEndExcluding": "14.10.5", "matchCriteriaId": "51077DBC-644F-4A90-97F4-7DD7E8059C98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0", "versionEndExcluding": "15.5.1", "matchCriteriaId": "C6697094-C3B7-4746-AC50-1C99C9DECAC9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:6.3:milestone2:*:*:*:*:*:*", "matchCriteriaId": "6387A0C9-03A5-43B5-81CB-034A745FF4A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:6.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "E603D197-FC4B-42C1-97EB-634021BB9C61"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/93b8ec702d7075f0f5794bb05dfb651382596764", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-7fqr-97j7-jgf4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-21138", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/93b8ec702d7075f0f5794bb05dfb651382596764"}}