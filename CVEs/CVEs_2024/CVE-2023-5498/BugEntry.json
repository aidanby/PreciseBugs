{"buggy_code": ["{% extends 'admin_base.html' %}\n{% load i18n %}\n{% load crispy_forms_tags %}\n{% block actions %}\n<a type=\"submit\" href=\"{% url 'admin_tasks:completed' object.id %}\" class=\"btn btn-primary\">\n  {% if object.completed %}\n    {% translate \"Reopen\" %}\n  {% else %}\n    {% translate \"Complete\" %}\n  {% endif %}\n</a>\n{% endblock %}\n\n{% block content %}\n<div class=\"row\">\n  <div class=\"col-4\">\n    <div class=\"card\">\n      <div class=\"card-body\">\n        {% include \"_table_user.html\" with user=object.new_hire %}\n        <form class=\"mt-3\" method=\"POST\">\n          {% csrf_token %}\n          {{ form|crispy }}\n          {% if not object.completed %}\n          <div class=\"form-footer\">\n            <button type=\"submit\" class=\"btn btn-primary\">{% translate \"Update\" %}</button>\n          </div>\n          {% endif %}\n        </form>\n      </div>\n    </div>\n  </div>\n  <div class=\"col-8\">\n    {% if not object.completed %}\n    <div class=\"card mb-3\">\n      <div class=\"card-header\">\n        <h3 class=\"card-title\">{% translate \"Add comment\" %}</h3>\n      </div>\n      <div class=\"card-body\">\n        <form method=\"POST\" action=\"{% url 'admin_tasks:comment' object.id %}\">\n          {% csrf_token %}\n          {{ comment_form|crispy }}\n          <div class=\"form-footer\">\n            <button type=\"submit\" class=\"btn btn-primary\">{% translate \"Submit\" %}</button>\n          </div>\n        </form>\n      </div>\n    </div>\n    {% endif %}\n    <div class=\"card\">\n      <div class=\"card-header\">\n        <h3 class=\"card-title\">{% translate \"Comments\" %}</h3>\n      </div>\n      <div class=\"card-body\">\n        {% if object.comment.all|length %}\n        <ul class=\"mt-3 list list-timeline\">\n          {% for comment in object.comment.all %}\n          <li>\n            <div class=\"list-timeline-icon {% if comment.comment_by == request.user %}bg-primary{% else %}bg-secondary{% endif %}\"></div>\n            <div class=\"list-timeline-content\">\n              <p class=\"mb-0 text-muted\">{{ comment.content }}</p>\n              <p><span class=\"list-timeline-title\">{{ comment.comment_by }}</span> - {{ comment.date }}</p>\n            </div>\n          </li>\n          {% endfor %}\n        </ul>\n        {% else %}\n        <p class=\"mt-3\">{% translate \"There are no comments yet\" %}</p>\n        {% endif %}\n      </div>\n    </div>\n  </div>\n</div>\n{% endblock %}\n", "import pytest\nfrom django.core.cache import cache\nfrom django.urls import reverse\n\nfrom admin.admin_tasks.models import AdminTask\n\n\n@pytest.mark.django_db\ndef test_all_tasks_view(client, admin_factory, admin_task_factory):\n    admin = admin_factory()\n    client.force_login(admin)\n\n    task1 = admin_task_factory(assigned_to=admin)\n    task2 = admin_task_factory()\n\n    url = reverse(\"admin_tasks:all\")\n    response = client.get(url)\n\n    assert task1.name in response.content.decode()\n    assert task2.name in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_my_tasks_view(client, admin_factory, admin_task_factory):\n    admin = admin_factory()\n    client.force_login(admin)\n\n    task1 = admin_task_factory(assigned_to=admin)\n    task2 = admin_task_factory()\n\n    url = reverse(\"admin_tasks:mine\")\n    response = client.get(url)\n\n    assert task1.name in response.content.decode()\n    assert task2.name not in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_create_admin_task(client, admin_factory, new_hire_factory):\n    admin1 = admin_factory()\n    new_hire1 = new_hire_factory()\n    admin2 = admin_factory(slack_user_id=\"slack_u_id\")\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    response = client.get(url)\n\n    # Check that the options are there\n    assert new_hire1.full_name in response.content.decode()\n    assert admin2.full_name in response.content.decode()\n\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    response = client.post(url, data=data, follow=True)\n\n    assert \"Task has been created\" in response.content.decode()\n    assert \"Set up a tour\" in response.content.decode()\n    assert AdminTask.objects.all().count() == 1\n\n\n@pytest.mark.django_db\ndef test_create_task_with_extra_email(\n    client, admin_factory, new_hire_factory, mailoutbox\n):\n    admin1 = admin_factory()\n    new_hire1 = new_hire_factory()\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 1,\n        \"email\": \"stan@chiefonboarding.com\",\n    }\n    client.post(url, data=data, follow=True)\n\n    assert AdminTask.objects.all().count() == 1\n    admin_task = AdminTask.objects.first()\n\n    assert len(mailoutbox) == 1\n    assert mailoutbox[0].subject == \"Can you please do this for me?\"\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == \"stan@chiefonboarding.com\"\n    assert admin_task.name in mailoutbox[0].alternatives[0][0]\n    assert new_hire1.full_name in mailoutbox[0].alternatives[0][0]\n    assert admin_task.comment.last().content in mailoutbox[0].alternatives[0][0]\n\n\n@pytest.mark.django_db\ndef test_create_task_with_extra_slack_message(\n    settings, client, admin_factory, new_hire_factory, mailoutbox\n):\n    settings.FAKE_SLACK_API = True\n\n    admin1 = admin_factory()\n    admin2 = admin_factory(slack_user_id=\"slackxx\")\n    new_hire1 = new_hire_factory()\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 2,\n        \"slack_user\": admin2.id,\n    }\n    client.post(url, data=data, follow=True)\n\n    assert AdminTask.objects.all().count() == 1\n\n    assert len(mailoutbox) == 0\n    assert cache.get(\"slack_channel\") == admin2.slack_user_id\n    assert cache.get(\"slack_blocks\") == [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": admin1.full_name\n                + \" needs your help with this task:\\n*Set up a tour*\\n_please do this_\",\n            },\n        },\n        {\n            \"type\": \"actions\",\n            \"elements\": [\n                {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"I have completed this\"},\n                    \"style\": \"primary\",\n                    \"value\": \"7\",\n                    \"action_id\": \"admin_task:complete\",\n                }\n            ],\n        },\n    ]\n\n\n@pytest.mark.django_db\ndef test_create_admin_task_for_different_user(\n    client, admin_factory, new_hire_factory, mailoutbox\n):\n    new_hire1 = new_hire_factory()\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin2.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    client.post(url, data=data, follow=True)\n\n    admin_task = AdminTask.objects.first()\n\n    assert len(mailoutbox) == 1\n    assert mailoutbox[0].subject == \"A task has been assigned to you!\"\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == admin2.email\n    assert admin_task.name in mailoutbox[0].alternatives[0][0]\n    assert admin_task.comment.last().content in mailoutbox[0].alternatives[0][0]\n\n\n@pytest.mark.django_db\ndef test_create_admin_task_for_different_user_slack_message(\n    settings, client, admin_factory, new_hire_factory, mailoutbox\n):\n    settings.FAKE_SLACK_API = True\n\n    new_hire1 = new_hire_factory()\n    admin1 = admin_factory()\n    admin2 = admin_factory(slack_user_id=\"slackx\")\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin2.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    client.post(url, data=data, follow=True)\n\n    assert len(mailoutbox) == 0\n    assert cache.get(\"slack_channel\") == admin2.slack_user_id\n    assert cache.get(\"slack_blocks\") == [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": \"You have just been assigned to *Set up a tour* for *\"\n                + new_hire1.full_name\n                + \"*\\n_please do this_\\n by _\"\n                + admin1.full_name\n                + \"_\",\n            },\n        },\n        {\n            \"type\": \"actions\",\n            \"elements\": [\n                {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"I have completed this\"},\n                    \"style\": \"primary\",\n                    \"value\": \"9\",\n                    \"action_id\": \"admin_task:complete\",\n                }\n            ],\n        },\n    ]\n\n\n@pytest.mark.django_db\ndef test_update_admin_task(client, admin_factory, admin_task_factory, mailoutbox):\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin1)\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": task1.new_hire.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    response = client.post(url, data=data, follow=True)\n\n    # No mail was sent. Only sent mail when assigned_to changes\n    assert len(mailoutbox) == 0\n    assert \"Task has been updated\" in response.content.decode()\n\n    # Assign it to a different user and then sent notification\n    data[\"assigned_to\"] = admin2.id\n    response = client.post(url, data=data, follow=True)\n\n    task1.refresh_from_db()\n    assert len(mailoutbox) == 1\n    assert \"Task has been updated\" in response.content.decode()\n    assert mailoutbox[0].subject == \"A task has been assigned to you!\"\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == admin2.email\n    assert task1.name in mailoutbox[0].alternatives[0][0]\n\n    # Assign it back to logged in user, no notification should be sent\n    data[\"assigned_to\"] = admin1.id\n    response = client.post(url, data=data, follow=True)\n\n    assert len(mailoutbox) == 1\n\n\n@pytest.mark.django_db\ndef test_complete_admin_task(client, admin_factory, admin_task_factory):\n    admin = admin_factory()\n    client.force_login(admin)\n\n    task1 = admin_task_factory(assigned_to=admin)\n    task2 = admin_task_factory(assigned_to=admin)\n\n    url = reverse(\"admin_tasks:mine\")\n    response = client.get(url)\n\n    assert task1.name in response.content.decode()\n    # Checked button is not visible because tasks are still open\n    assert \"btn-success\" not in response.content.decode()\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    response = client.get(url)\n\n    complete_url = reverse(\"admin_tasks:completed\", args=[task1.id])\n    assert \"Complete\" in response.content.decode()\n    assert complete_url in response.content.decode()\n\n    response = client.get(complete_url, follow=True)\n    task1.refresh_from_db()\n    task2.refresh_from_db()\n\n    assert \"Complete\" not in response.content.decode()\n    assert \"completed\" in response.content.decode()\n    assert \"disabled\" in response.content.decode()\n    # Cannot add new comment\n    assert \"div_id_content\" not in response.content.decode()\n    # Complete url is still there to make it open again\n    assert complete_url in response.content.decode()\n\n    assert task1.completed\n    assert not task2.completed\n\n    url = reverse(\"admin_tasks:mine\")\n    response = client.get(url)\n    # Check button is now visible\n    assert \"btn-success\" in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_admin_task_post_comment(client, admin_factory, admin_task_factory):\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin1)\n\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    response = client.post(url, {\"content\": \"Hi, this is a new comment\"}, follow=True)\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    response = client.get(url)\n\n    assert \"Hi, this is a new comment\" in response.content.decode()\n\n    # Create a second comment with a new admin user\n    client.force_login(admin2)\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    response = client.post(url, {\"content\": \"Hi, another comment\"}, follow=True)\n\n    assert \"Hi, another comment\" in response.content.decode()\n    # New admin shows up as \"by\" comment\n    assert admin2.full_name in response.content.decode()\n\n    # Try to post a comment after it's done\n    task1.completed = True\n    task1.save()\n\n    response = client.post(url, {\"content\": \"third comment\"}, follow=True)\n    assert response.status_code == 404\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    response = client.get(url)\n\n    # Comment is not shown or saved\n    assert \"third comment\" not in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_admin_task_comment_on_not_owned_task(\n    client, admin_factory, admin_task_factory, mailoutbox\n):\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin2)\n\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    client.post(url, {\"content\": \"Hi, this is a new comment\"}, follow=True)\n\n    assert len(mailoutbox) == 1\n    assert mailoutbox[0].subject == \"Someone added something to task: \" + task1.name\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == admin2.email\n    assert admin2.first_name in mailoutbox[0].alternatives[0][0]\n    assert admin1.full_name in mailoutbox[0].alternatives[0][0]\n    assert \"Hi, this is a new comment\" in mailoutbox[0].alternatives[0][0]\n\n\n@pytest.mark.django_db\ndef test_admin_task_comment_on_not_owned_task_slack_message(\n    settings, client, admin_factory, admin_task_factory, mailoutbox\n):\n    settings.FAKE_SLACK_API = True\n\n    admin1 = admin_factory()\n    admin2 = admin_factory(slack_user_id=\"slackx\")\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin2)\n\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    client.post(url, {\"content\": \"Hi, this is a new comment\"}, follow=True)\n\n    assert len(mailoutbox) == 0\n\n    assert cache.get(\"slack_channel\") == admin2.slack_user_id\n    assert cache.get(\"slack_blocks\") == [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": admin1.full_name\n                + \" added a message to your task:\\n*\"\n                + task1.name\n                + \"*\\n_Hi, this is a new comment_\",\n            },\n        },\n        {\n            \"type\": \"actions\",\n            \"elements\": [\n                {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"I have completed this\"},\n                    \"style\": \"primary\",\n                    \"value\": \"9\",\n                    \"action_id\": \"admin_task:complete\",\n                }\n            ],\n        },\n    ]\n", "from django.contrib.messages.views import SuccessMessageMixin\nfrom django.http import Http404\nfrom django.shortcuts import get_object_or_404\nfrom django.urls import reverse, reverse_lazy\nfrom django.utils.translation import gettext as _\nfrom django.views.generic.base import RedirectView\nfrom django.views.generic.edit import CreateView, UpdateView\nfrom django.views.generic.list import ListView\n\nfrom users.mixins import LoginRequiredMixin, ManagerPermMixin\n\nfrom .forms import AdminTaskCommentForm, AdminTaskCreateForm, AdminTaskUpdateForm\nfrom .models import AdminTask, AdminTaskComment\n\n\nclass MyAdminTasksListView(LoginRequiredMixin, ManagerPermMixin, ListView):\n    template_name = \"admin_tasks_yours.html\"\n    paginate_by = 10\n\n    def get_queryset(self):\n        return AdminTask.objects.filter(assigned_to=self.request.user).select_related(\n            \"new_hire\", \"assigned_to\"\n        )\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"title\"] = \"Your tasks\"\n        context[\"subtitle\"] = \"Tasks\"\n        context[\"add_action\"] = reverse_lazy(\"admin_tasks:create\")\n        return context\n\n\nclass AllAdminTasksListView(LoginRequiredMixin, ManagerPermMixin, ListView):\n    template_name = \"admin_tasks_all.html\"\n    paginate_by = 10\n\n    def get_queryset(self):\n        return AdminTask.objects.all().select_related(\"new_hire\", \"assigned_to\")\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"title\"] = \"All tasks\"\n        context[\"subtitle\"] = \"Tasks\"\n        context[\"add_action\"] = reverse_lazy(\"admin_tasks:create\")\n        return context\n\n\nclass AdminTaskToggleDoneView(LoginRequiredMixin, ManagerPermMixin, RedirectView):\n    permanent = False\n    pattern_name = \"admin_tasks:detail\"\n\n    def get(self, request, *args, **kwargs):\n        task_id = self.kwargs.get(\"pk\", -1)\n        admin_task = get_object_or_404(AdminTask, id=task_id)\n        admin_task.completed = not admin_task.completed\n        admin_task.save()\n        return super().get(request, *args, **kwargs)\n\n\nclass AdminTasksCreateView(\n    LoginRequiredMixin, ManagerPermMixin, SuccessMessageMixin, CreateView\n):\n    template_name = \"admin_tasks_create.html\"\n    form_class = AdminTaskCreateForm\n    model = AdminTask\n    success_message = _(\"Task has been created\")\n    success_url = reverse_lazy(\"admin_tasks:all\")\n\n    def form_valid(self, form):\n        self.object = form.save()\n        AdminTaskComment.objects.create(\n            admin_task=self.object,\n            content=form.cleaned_data[\"comment\"],\n            comment_by=self.request.user,\n        )\n        # Send message to person that got assigned to this\n        if self.request.user.id != form.cleaned_data[\"assigned_to\"].id:\n            self.object.send_notification_new_assigned()\n\n        # Send notification based on extra notification option\n        self.object.send_notification_third_party()\n        return super().form_valid(form)\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"title\"] = _(\"New task\")\n        context[\"subtitle\"] = _(\"Tasks\")\n        return context\n\n\nclass AdminTasksUpdateView(\n    LoginRequiredMixin, ManagerPermMixin, SuccessMessageMixin, UpdateView\n):\n    template_name = \"admin_tasks_detail.html\"\n    form_class = AdminTaskUpdateForm\n    model = AdminTask\n    success_message = _(\"Task has been updated\")\n\n    def get_success_url(self):\n        return self.request.path\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        task = get_object_or_404(AdminTask, pk=self.kwargs.get(\"pk\"))\n        context[\"object\"] = task\n        context[\"title\"] = _(\"Task: %(name)s\") % {\"name\": task.name}\n        context[\"subtitle\"] = _(\"Tasks\")\n        context[\"comment_form\"] = AdminTaskCommentForm\n        return context\n\n    def form_valid(self, form):\n        # send email/bot message to newly assigned person\n        initial_assigned_to = AdminTask.objects.get(id=form.instance.id).assigned_to\n        form.save()\n        if (\n            form.cleaned_data[\"assigned_to\"] != initial_assigned_to\n            and form.cleaned_data[\"assigned_to\"] != self.request.user\n        ):\n            form.instance.send_notification_new_assigned()\n        return super().form_valid(form)\n\n\nclass AdminTasksCommentCreateView(\n    LoginRequiredMixin, ManagerPermMixin, SuccessMessageMixin, CreateView\n):\n    template_name = \"admin_tasks_detail.html\"\n    model = AdminTaskComment\n    fields = [\n        \"content\",\n    ]\n    success_message = _(\"Comment has been posted\")\n\n    def get_success_url(self):\n        task = get_object_or_404(AdminTask, pk=self.kwargs.get(\"pk\"))\n        return reverse(\"admin_tasks:detail\", args=[task.id])\n\n    def form_valid(self, form):\n        task = get_object_or_404(AdminTask, pk=self.kwargs.get(\"pk\"))\n        # Can't post comments when item is completed\n        if task.completed:\n            raise Http404\n        form.instance.comment_by = self.request.user\n        form.instance.admin_task = task\n        item = form.save()\n        item.send_notification_new_message()\n        return super().form_valid(form)\n"], "fixing_code": ["{% extends 'admin_base.html' %}\n{% load i18n %}\n{% load crispy_forms_tags %}\n{% block actions %}\n<form method=\"post\" action=\"{% url 'admin_tasks:completed' object.id %}\">\n  {% csrf_token %}\n  <button type=\"submit\" class=\"btn btn-primary\">\n    {% if object.completed %}\n      {% translate \"Reopen\" %}\n    {% else %}\n      {% translate \"Complete\" %}\n    {% endif %}\n  </button>\n</form>\n{% endblock %}\n\n{% block content %}\n<div class=\"row\">\n  <div class=\"col-4\">\n    <div class=\"card\">\n      <div class=\"card-body\">\n        {% include \"_table_user.html\" with user=object.new_hire %}\n        <form class=\"mt-3\" method=\"POST\">\n          {% csrf_token %}\n          {{ form|crispy }}\n          {% if not object.completed %}\n          <div class=\"form-footer\">\n            <button type=\"submit\" class=\"btn btn-primary\">{% translate \"Update\" %}</button>\n          </div>\n          {% endif %}\n        </form>\n      </div>\n    </div>\n  </div>\n  <div class=\"col-8\">\n    {% if not object.completed %}\n    <div class=\"card mb-3\">\n      <div class=\"card-header\">\n        <h3 class=\"card-title\">{% translate \"Add comment\" %}</h3>\n      </div>\n      <div class=\"card-body\">\n        <form method=\"POST\" action=\"{% url 'admin_tasks:comment' object.id %}\">\n          {% csrf_token %}\n          {{ comment_form|crispy }}\n          <div class=\"form-footer\">\n            <button type=\"submit\" class=\"btn btn-primary\">{% translate \"Submit\" %}</button>\n          </div>\n        </form>\n      </div>\n    </div>\n    {% endif %}\n    <div class=\"card\">\n      <div class=\"card-header\">\n        <h3 class=\"card-title\">{% translate \"Comments\" %}</h3>\n      </div>\n      <div class=\"card-body\">\n        {% if object.comment.all|length %}\n        <ul class=\"mt-3 list list-timeline\">\n          {% for comment in object.comment.all %}\n          <li>\n            <div class=\"list-timeline-icon {% if comment.comment_by == request.user %}bg-primary{% else %}bg-secondary{% endif %}\"></div>\n            <div class=\"list-timeline-content\">\n              <p class=\"mb-0 text-muted\">{{ comment.content }}</p>\n              <p><span class=\"list-timeline-title\">{{ comment.comment_by }}</span> - {{ comment.date }}</p>\n            </div>\n          </li>\n          {% endfor %}\n        </ul>\n        {% else %}\n        <p class=\"mt-3\">{% translate \"There are no comments yet\" %}</p>\n        {% endif %}\n      </div>\n    </div>\n  </div>\n</div>\n{% endblock %}\n", "import pytest\nfrom django.core.cache import cache\nfrom django.urls import reverse\n\nfrom admin.admin_tasks.models import AdminTask\n\n\n@pytest.mark.django_db\ndef test_all_tasks_view(client, admin_factory, admin_task_factory):\n    admin = admin_factory()\n    client.force_login(admin)\n\n    task1 = admin_task_factory(assigned_to=admin)\n    task2 = admin_task_factory()\n\n    url = reverse(\"admin_tasks:all\")\n    response = client.get(url)\n\n    assert task1.name in response.content.decode()\n    assert task2.name in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_my_tasks_view(client, admin_factory, admin_task_factory):\n    admin = admin_factory()\n    client.force_login(admin)\n\n    task1 = admin_task_factory(assigned_to=admin)\n    task2 = admin_task_factory()\n\n    url = reverse(\"admin_tasks:mine\")\n    response = client.get(url)\n\n    assert task1.name in response.content.decode()\n    assert task2.name not in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_create_admin_task(client, admin_factory, new_hire_factory):\n    admin1 = admin_factory()\n    new_hire1 = new_hire_factory()\n    admin2 = admin_factory(slack_user_id=\"slack_u_id\")\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    response = client.get(url)\n\n    # Check that the options are there\n    assert new_hire1.full_name in response.content.decode()\n    assert admin2.full_name in response.content.decode()\n\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    response = client.post(url, data=data, follow=True)\n\n    assert \"Task has been created\" in response.content.decode()\n    assert \"Set up a tour\" in response.content.decode()\n    assert AdminTask.objects.all().count() == 1\n\n\n@pytest.mark.django_db\ndef test_create_task_with_extra_email(\n    client, admin_factory, new_hire_factory, mailoutbox\n):\n    admin1 = admin_factory()\n    new_hire1 = new_hire_factory()\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 1,\n        \"email\": \"stan@chiefonboarding.com\",\n    }\n    client.post(url, data=data, follow=True)\n\n    assert AdminTask.objects.all().count() == 1\n    admin_task = AdminTask.objects.first()\n\n    assert len(mailoutbox) == 1\n    assert mailoutbox[0].subject == \"Can you please do this for me?\"\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == \"stan@chiefonboarding.com\"\n    assert admin_task.name in mailoutbox[0].alternatives[0][0]\n    assert new_hire1.full_name in mailoutbox[0].alternatives[0][0]\n    assert admin_task.comment.last().content in mailoutbox[0].alternatives[0][0]\n\n\n@pytest.mark.django_db\ndef test_create_task_with_extra_slack_message(\n    settings, client, admin_factory, new_hire_factory, mailoutbox\n):\n    settings.FAKE_SLACK_API = True\n\n    admin1 = admin_factory()\n    admin2 = admin_factory(slack_user_id=\"slackxx\")\n    new_hire1 = new_hire_factory()\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 2,\n        \"slack_user\": admin2.id,\n    }\n    client.post(url, data=data, follow=True)\n\n    assert AdminTask.objects.all().count() == 1\n\n    assert len(mailoutbox) == 0\n    assert cache.get(\"slack_channel\") == admin2.slack_user_id\n    assert cache.get(\"slack_blocks\") == [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": admin1.full_name\n                + \" needs your help with this task:\\n*Set up a tour*\\n_please do this_\",\n            },\n        },\n        {\n            \"type\": \"actions\",\n            \"elements\": [\n                {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"I have completed this\"},\n                    \"style\": \"primary\",\n                    \"value\": \"7\",\n                    \"action_id\": \"admin_task:complete\",\n                }\n            ],\n        },\n    ]\n\n\n@pytest.mark.django_db\ndef test_create_admin_task_for_different_user(\n    client, admin_factory, new_hire_factory, mailoutbox\n):\n    new_hire1 = new_hire_factory()\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin2.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    client.post(url, data=data, follow=True)\n\n    admin_task = AdminTask.objects.first()\n\n    assert len(mailoutbox) == 1\n    assert mailoutbox[0].subject == \"A task has been assigned to you!\"\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == admin2.email\n    assert admin_task.name in mailoutbox[0].alternatives[0][0]\n    assert admin_task.comment.last().content in mailoutbox[0].alternatives[0][0]\n\n\n@pytest.mark.django_db\ndef test_create_admin_task_for_different_user_slack_message(\n    settings, client, admin_factory, new_hire_factory, mailoutbox\n):\n    settings.FAKE_SLACK_API = True\n\n    new_hire1 = new_hire_factory()\n    admin1 = admin_factory()\n    admin2 = admin_factory(slack_user_id=\"slackx\")\n    client.force_login(admin1)\n\n    url = reverse(\"admin_tasks:create\")\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": new_hire1.id,\n        \"assigned_to\": admin2.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    client.post(url, data=data, follow=True)\n\n    assert len(mailoutbox) == 0\n    assert cache.get(\"slack_channel\") == admin2.slack_user_id\n    assert cache.get(\"slack_blocks\") == [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": \"You have just been assigned to *Set up a tour* for *\"\n                + new_hire1.full_name\n                + \"*\\n_please do this_\\n by _\"\n                + admin1.full_name\n                + \"_\",\n            },\n        },\n        {\n            \"type\": \"actions\",\n            \"elements\": [\n                {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"I have completed this\"},\n                    \"style\": \"primary\",\n                    \"value\": \"9\",\n                    \"action_id\": \"admin_task:complete\",\n                }\n            ],\n        },\n    ]\n\n\n@pytest.mark.django_db\ndef test_update_admin_task(client, admin_factory, admin_task_factory, mailoutbox):\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin1)\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    data = {\n        \"name\": \"Set up a tour\",\n        \"priority\": 1,\n        \"new_hire\": task1.new_hire.id,\n        \"assigned_to\": admin1.id,\n        \"comment\": \"please do this\",\n        \"option\": 0,\n    }\n    response = client.post(url, data=data, follow=True)\n\n    # No mail was sent. Only sent mail when assigned_to changes\n    assert len(mailoutbox) == 0\n    assert \"Task has been updated\" in response.content.decode()\n\n    # Assign it to a different user and then sent notification\n    data[\"assigned_to\"] = admin2.id\n    response = client.post(url, data=data, follow=True)\n\n    task1.refresh_from_db()\n    assert len(mailoutbox) == 1\n    assert \"Task has been updated\" in response.content.decode()\n    assert mailoutbox[0].subject == \"A task has been assigned to you!\"\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == admin2.email\n    assert task1.name in mailoutbox[0].alternatives[0][0]\n\n    # Assign it back to logged in user, no notification should be sent\n    data[\"assigned_to\"] = admin1.id\n    response = client.post(url, data=data, follow=True)\n\n    assert len(mailoutbox) == 1\n\n\n@pytest.mark.django_db\ndef test_complete_admin_task(client, admin_factory, admin_task_factory):\n    admin = admin_factory()\n    client.force_login(admin)\n\n    task1 = admin_task_factory(assigned_to=admin)\n    task2 = admin_task_factory(assigned_to=admin)\n\n    url = reverse(\"admin_tasks:mine\")\n    response = client.get(url)\n\n    assert task1.name in response.content.decode()\n    # Checked button is not visible because tasks are still open\n    assert \"btn-success\" not in response.content.decode()\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    response = client.get(url)\n\n    complete_url = reverse(\"admin_tasks:completed\", args=[task1.id])\n    assert \"Complete\" in response.content.decode()\n    assert complete_url in response.content.decode()\n\n    response = client.post(complete_url, follow=True)\n    task1.refresh_from_db()\n    task2.refresh_from_db()\n\n    assert \"Complete\" not in response.content.decode()\n    assert \"completed\" in response.content.decode()\n    assert \"disabled\" in response.content.decode()\n    # Cannot add new comment\n    assert \"div_id_content\" not in response.content.decode()\n    # Complete url is still there to make it open again\n    assert complete_url in response.content.decode()\n\n    assert task1.completed\n    assert not task2.completed\n\n    url = reverse(\"admin_tasks:mine\")\n    response = client.get(url)\n    # Check button is now visible\n    assert \"btn-success\" in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_admin_task_post_comment(client, admin_factory, admin_task_factory):\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin1)\n\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    response = client.post(url, {\"content\": \"Hi, this is a new comment\"}, follow=True)\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    response = client.get(url)\n\n    assert \"Hi, this is a new comment\" in response.content.decode()\n\n    # Create a second comment with a new admin user\n    client.force_login(admin2)\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    response = client.post(url, {\"content\": \"Hi, another comment\"}, follow=True)\n\n    assert \"Hi, another comment\" in response.content.decode()\n    # New admin shows up as \"by\" comment\n    assert admin2.full_name in response.content.decode()\n\n    # Try to post a comment after it's done\n    task1.completed = True\n    task1.save()\n\n    response = client.post(url, {\"content\": \"third comment\"}, follow=True)\n    assert response.status_code == 404\n\n    url = reverse(\"admin_tasks:detail\", args=[task1.id])\n    response = client.get(url)\n\n    # Comment is not shown or saved\n    assert \"third comment\" not in response.content.decode()\n\n\n@pytest.mark.django_db\ndef test_admin_task_comment_on_not_owned_task(\n    client, admin_factory, admin_task_factory, mailoutbox\n):\n    admin1 = admin_factory()\n    admin2 = admin_factory()\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin2)\n\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    client.post(url, {\"content\": \"Hi, this is a new comment\"}, follow=True)\n\n    assert len(mailoutbox) == 1\n    assert mailoutbox[0].subject == \"Someone added something to task: \" + task1.name\n    assert len(mailoutbox[0].to) == 1\n    assert mailoutbox[0].to[0] == admin2.email\n    assert admin2.first_name in mailoutbox[0].alternatives[0][0]\n    assert admin1.full_name in mailoutbox[0].alternatives[0][0]\n    assert \"Hi, this is a new comment\" in mailoutbox[0].alternatives[0][0]\n\n\n@pytest.mark.django_db\ndef test_admin_task_comment_on_not_owned_task_slack_message(\n    settings, client, admin_factory, admin_task_factory, mailoutbox\n):\n    settings.FAKE_SLACK_API = True\n\n    admin1 = admin_factory()\n    admin2 = admin_factory(slack_user_id=\"slackx\")\n    client.force_login(admin1)\n\n    task1 = admin_task_factory(assigned_to=admin2)\n\n    url = reverse(\"admin_tasks:comment\", args=[task1.id])\n    client.post(url, {\"content\": \"Hi, this is a new comment\"}, follow=True)\n\n    assert len(mailoutbox) == 0\n\n    assert cache.get(\"slack_channel\") == admin2.slack_user_id\n    assert cache.get(\"slack_blocks\") == [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": admin1.full_name\n                + \" added a message to your task:\\n*\"\n                + task1.name\n                + \"*\\n_Hi, this is a new comment_\",\n            },\n        },\n        {\n            \"type\": \"actions\",\n            \"elements\": [\n                {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"I have completed this\"},\n                    \"style\": \"primary\",\n                    \"value\": \"9\",\n                    \"action_id\": \"admin_task:complete\",\n                }\n            ],\n        },\n    ]\n", "from django.contrib.messages.views import SuccessMessageMixin\nfrom django.http import Http404\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.urls import reverse, reverse_lazy\nfrom django.utils.translation import gettext as _\n\nfrom django.views.generic.detail import BaseDetailView\nfrom django.views.generic.edit import CreateView, UpdateView\nfrom django.views.generic.list import ListView\n\nfrom users.mixins import LoginRequiredMixin, ManagerPermMixin\n\nfrom .forms import AdminTaskCommentForm, AdminTaskCreateForm, AdminTaskUpdateForm\nfrom .models import AdminTask, AdminTaskComment\n\n\nclass MyAdminTasksListView(LoginRequiredMixin, ManagerPermMixin, ListView):\n    template_name = \"admin_tasks_yours.html\"\n    paginate_by = 10\n\n    def get_queryset(self):\n        return AdminTask.objects.filter(assigned_to=self.request.user).select_related(\n            \"new_hire\", \"assigned_to\"\n        )\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"title\"] = \"Your tasks\"\n        context[\"subtitle\"] = \"Tasks\"\n        context[\"add_action\"] = reverse_lazy(\"admin_tasks:create\")\n        return context\n\n\nclass AllAdminTasksListView(LoginRequiredMixin, ManagerPermMixin, ListView):\n    template_name = \"admin_tasks_all.html\"\n    paginate_by = 10\n\n    def get_queryset(self):\n        return AdminTask.objects.all().select_related(\"new_hire\", \"assigned_to\")\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"title\"] = \"All tasks\"\n        context[\"subtitle\"] = \"Tasks\"\n        context[\"add_action\"] = reverse_lazy(\"admin_tasks:create\")\n        return context\n\n\nclass AdminTaskToggleDoneView(LoginRequiredMixin, ManagerPermMixin, BaseDetailView):\n    model = AdminTask\n\n    def post(self, request, *args, **kwargs):\n        admin_task = self.get_object()\n        admin_task.completed = not admin_task.completed\n        admin_task.save()\n        return redirect(\"admin_tasks:detail\", pk=admin_task.id)\n\n\nclass AdminTasksCreateView(\n    LoginRequiredMixin, ManagerPermMixin, SuccessMessageMixin, CreateView\n):\n    template_name = \"admin_tasks_create.html\"\n    form_class = AdminTaskCreateForm\n    model = AdminTask\n    success_message = _(\"Task has been created\")\n    success_url = reverse_lazy(\"admin_tasks:all\")\n\n    def form_valid(self, form):\n        self.object = form.save()\n        AdminTaskComment.objects.create(\n            admin_task=self.object,\n            content=form.cleaned_data[\"comment\"],\n            comment_by=self.request.user,\n        )\n        # Send message to person that got assigned to this\n        if self.request.user.id != form.cleaned_data[\"assigned_to\"].id:\n            self.object.send_notification_new_assigned()\n\n        # Send notification based on extra notification option\n        self.object.send_notification_third_party()\n        return super().form_valid(form)\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context[\"title\"] = _(\"New task\")\n        context[\"subtitle\"] = _(\"Tasks\")\n        return context\n\n\nclass AdminTasksUpdateView(\n    LoginRequiredMixin, ManagerPermMixin, SuccessMessageMixin, UpdateView\n):\n    template_name = \"admin_tasks_detail.html\"\n    form_class = AdminTaskUpdateForm\n    model = AdminTask\n    success_message = _(\"Task has been updated\")\n\n    def get_success_url(self):\n        return self.request.path\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        task = get_object_or_404(AdminTask, pk=self.kwargs.get(\"pk\"))\n        context[\"object\"] = task\n        context[\"title\"] = _(\"Task: %(name)s\") % {\"name\": task.name}\n        context[\"subtitle\"] = _(\"Tasks\")\n        context[\"comment_form\"] = AdminTaskCommentForm\n        return context\n\n    def form_valid(self, form):\n        # send email/bot message to newly assigned person\n        initial_assigned_to = AdminTask.objects.get(id=form.instance.id).assigned_to\n        form.save()\n        if (\n            form.cleaned_data[\"assigned_to\"] != initial_assigned_to\n            and form.cleaned_data[\"assigned_to\"] != self.request.user\n        ):\n            form.instance.send_notification_new_assigned()\n        return super().form_valid(form)\n\n\nclass AdminTasksCommentCreateView(\n    LoginRequiredMixin, ManagerPermMixin, SuccessMessageMixin, CreateView\n):\n    template_name = \"admin_tasks_detail.html\"\n    model = AdminTaskComment\n    fields = [\n        \"content\",\n    ]\n    success_message = _(\"Comment has been posted\")\n\n    def get_success_url(self):\n        task = get_object_or_404(AdminTask, pk=self.kwargs.get(\"pk\"))\n        return reverse(\"admin_tasks:detail\", args=[task.id])\n\n    def form_valid(self, form):\n        task = get_object_or_404(AdminTask, pk=self.kwargs.get(\"pk\"))\n        # Can't post comments when item is completed\n        if task.completed:\n            raise Http404\n        form.instance.comment_by = self.request.user\n        form.instance.admin_task = task\n        item = form.save()\n        item.send_notification_new_message()\n        return super().form_valid(form)\n"], "filenames": ["back/admin/admin_tasks/templates/admin_tasks_detail.html", "back/admin/admin_tasks/tests.py", "back/admin/admin_tasks/views.py"], "buggy_code_start_loc": [5, 295, 3], "buggy_code_end_loc": [12, 296, 58], "fixing_code_start_loc": [5, 295, 3], "fixing_code_end_loc": [15, 296, 57], "type": "CWE-352", "message": "Cross-Site Request Forgery (CSRF) in GitHub repository chiefonboarding/chiefonboarding prior to v2.0.47.", "other": {"cve": {"id": "CVE-2023-5498", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-10T10:15:10.177", "lastModified": "2023-10-13T12:54:51.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-Site Request Forgery (CSRF) in GitHub repository chiefonboarding/chiefonboarding prior to v2.0.47."}, {"lang": "es", "value": "Cross-Site Request Forgery (CSRF) en el chiefonboarding/chiefonboarding del repositorio de GitHub antes de la versi\u00f3n 2.0.47."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chiefonboarding:chiefonboarding:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.47", "matchCriteriaId": "69013906-33F2-4136-AF56-92BA76EF825D"}]}]}], "references": [{"url": "https://github.com/chiefonboarding/chiefonboarding/commit/7de93f5fcc21e8f16fa0a64d38461c1b48ff3ee7", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/ec367b1d-5ec4-4ab2-881a-caf82e4877d9", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chiefonboarding/chiefonboarding/commit/7de93f5fcc21e8f16fa0a64d38461c1b48ff3ee7"}}