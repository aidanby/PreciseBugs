{"buggy_code": ["/*\n   Copyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com> \n   All rights reserved.\n\nThis file is part of x11vnc.\n\nx11vnc is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or (at\nyour option) any later version.\n\nx11vnc is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with x11vnc; if not, write to the Free Software\nFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA\nor see <http://www.gnu.org/licenses/>.\n\nIn addition, as a special exception, Karl J. Runge\ngives permission to link the code of its release of x11vnc with the\nOpenSSL project's \"OpenSSL\" library (or with modified versions of it\nthat use the same license as the \"OpenSSL\" library), and distribute\nthe linked executables.  You must obey the GNU General Public License\nin all respects for all of the code used other than \"OpenSSL\".  If you\nmodify this file, you may extend this exception to your version of the\nfile, but you are not obligated to do so.  If you do not wish to do\nso, delete this exception statement from your version.\n*/\n\n/* -- scan.c -- */\n\n#include \"x11vnc.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"win_utils.h\"\n#include \"8to24.h\"\n#include \"screen.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"userinput.h\"\n\n/*\n * routines for scanning and reading the X11 display for changes, and\n * for doing all the tile work (shm, etc).\n */\nvoid initialize_tiles(void);\nvoid free_tiles(void);\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nvoid initialize_polling_images(void);\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\nint copy_screen(void);\nint copy_snap(void);\nvoid nap_sleep(int ms, int split);\nvoid set_offset(void);\nint scan_for_updates(int count_only);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nstatic void set_fs_factor(int max);\nstatic char *flip_ximage_byte_order(XImage *xim);\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void save_hint(hint_t hint, int loc);\nstatic void hint_updates(void);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int copy_all_tiles(void);\nstatic int copy_all_tile_runs(void);\nstatic int copy_tiles_backward_pass(void);\nstatic int copy_tiles_additional_pass(void);\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x);\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\nstatic void blackout_regions(void);\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic int scan_display(int ystart, int rescan);\n\n\n/* array to hold the hints: */\nstatic hint_t *hint_list;\n\n/* nap state */\nint nap_ok = 0;\nstatic int nap_diff_count = 0;\n\nstatic int scan_count = 0;\t/* indicates which scan pattern we are on  */\nstatic int scan_in_progress = 0;\t\n\n\ntypedef struct tile_change_region {\n\t/* start and end lines, along y, of the changed area inside a tile. */\n\tunsigned short first_line, last_line;\n\tshort first_x, last_x;\n\t/* info about differences along edges. */\n\tunsigned short left_diff, right_diff;\n\tunsigned short top_diff,  bot_diff;\n} region_t;\n\n/* array to hold the tiles region_t-s. */\nstatic region_t *tile_region;\n\n\n\n\n/*\n * setup tile numbers and allocate the tile and hint arrays:\n */\nvoid initialize_tiles(void) {\n\n\tntiles_x = (dpy_x - 1)/tile_x + 1;\n\tntiles_y = (dpy_y - 1)/tile_y + 1;\n\tntiles = ntiles_x * ntiles_y;\n\n\ttile_has_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_row_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles_y * sizeof(unsigned char)), 1);\n\ttile_tried    = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_copied   = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_blackout    = (tile_blackout_t *)\n\t\tcalloc((size_t) (ntiles * sizeof(tile_blackout_t)), 1);\n\ttile_region = (region_t *) calloc((size_t) (ntiles * sizeof(region_t)), 1);\n\n\ttile_row = (XImage **)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XImage *)), 1);\n\ttile_row_shm = (XShmSegmentInfo *)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo)), 1);\n\n\t/* there will never be more hints than tiles: */\n\thint_list = (hint_t *) calloc((size_t) (ntiles * sizeof(hint_t)), 1);\n}\n\nvoid free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}\n\n/*\n * silly function to factor dpy_y until fullscreen shm is not bigger than max.\n * should always work unless dpy_y is a large prime or something... under\n * failure fs_factor remains 0 and no fullscreen updates will be tried.\n */\nstatic int fs_factor = 0;\n\nstatic void set_fs_factor(int max) {\n\tint f, fac = 1, n = dpy_y;\n\n\tfs_factor = 0;\n\tif ((bpp/8) * dpy_x * dpy_y <= max)  {\n\t\tfs_factor = 1;\n\t\treturn;\n\t}\n\tfor (f=2; f <= 101; f++) {\n\t\twhile (n % f == 0) {\n\t\t\tn = n / f;\n\t\t\tfac = fac * f;\n\t\t\tif ( (bpp/8) * dpy_x * (dpy_y/fac) <= max )  {\n\t\t\t\tfs_factor = fac;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \"MSBFirst\";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \"LSBFirst\";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}\n\n/*\n * set up an XShm image, or if not using shm just create the XImage.\n */\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}\n\nvoid shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"shm_clean: called:  %p\\n\", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \"shm_clean: XShmDetach_wr\\n\");\n\t\tXShmDetach_wr(dpy, shm);\n\t}\n#endif\n\tif (xim != NULL) {\n\t\tif (! raw_fb_back_to_X) {\t/* raw_fb hack */\n\t\t\tif (xim->bitmap_unit != -1) {\n\t\t\t\tif (db) fprintf(stderr, \"shm_clean: XDestroyImage  %p\\n\", (void *)xim);\n\t\t\t\tXDestroyImage(xim);\n\t\t\t} else {\n\t\t\t\tif (xim->data) {\n\t\t\t\t\tif (db) fprintf(stderr, \"shm_clean: free xim->data  %p %p\\n\", (void *)xim, (void *)(xim->data));\n\t\t\t\t\tfree(xim->data);\n\t\t\t\t\txim->data = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txim = NULL;\n\t}\n\tX_UNLOCK;\n\n\tshm_delete(shm);\n}\n\nvoid initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \"none\" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \"scanline\")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \"Linux\")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\"warning: fullscreen updates are disabled.\\n\");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \"fullscreen\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\"warning: disabling -snapfb mode.\\n\");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \"snaprect\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \"tile_row\")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\"shm: Error creating shared memory tile-row for\"\n\t\t\t    \" len=%d,\\n\", i);\n\t\t\trfbLog(\"shm: reverting to -onetile mode. If this\"\n\t\t\t    \" problem persists\\n\");\n\t\t\trfbLog(\"shm: try using the -onetile or -noshm options\"\n\t\t\t    \" to limit\\n\");\n\t\t\trfbLog(\"shm: shared memory usage, or run ipcrm(1)\"\n\t\t\t    \" to manually\\n\");\n\t\t\trfbLog(\"shm: delete unattached shm segments.\\n\");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\"created %d tile_row shm polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\"created %d tile_row polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}\n\n/*\n * A hint is a rectangular region built from 1 or more adjacent tiles\n * glued together.  Ultimately, this information in a single hint is sent\n * to libvncserver rather than sending each tile separately.\n */\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\thint->x = x;\n\thint->y = y;\n\thint->w = w;\n\thint->h = h;\n}\n\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\tif (hint->x > x) {\t\t\t/* extend to the left */\n\t\thint->w += hint->x - x;\n\t\thint->x = x;\n\t}\n\tif (hint->y > y) {\t\t\t/* extend upward */\n\t\thint->h += hint->y - y;\n\t\thint->y = y;\n\t}\n\n\tif (hint->x + hint->w < x + w) {\t/* extend to the right */\n\t\thint->w = x + w - hint->x;\n\t}\n\tif (hint->y + hint->h < y + h) {\t/* extend downward */\n\t\thint->h = y + h - hint->y;\n\t}\n}\n\nstatic void save_hint(hint_t hint, int loc) {\n\t/* simply copy it to the global array for later use. */\n\thint_list[loc].x = hint.x;\n\thint_list[loc].y = hint.y;\n\thint_list[loc].w = hint.w;\n\thint_list[loc].h = hint.h;\n}\n\n/*\n * Glue together horizontal \"runs\" of adjacent changed tiles into one big\n * rectangle change \"hint\" to be passed to the vnc machinery.\n */\nstatic void hint_updates(void) {\n\thint_t hint;\n\tint x, y, i, n, ty, th, tx, tw;\n\tint hint_count = 0, in_run = 0;\n\n\thint.x = hint.y = hint.w = hint.h = 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tty = tile_region[n].first_line;\n\t\t\t\tth = tile_region[n].last_line - ty + 1;\n\n\t\t\t\ttx = tile_region[n].first_x;\n\t\t\t\ttw = tile_region[n].last_x - tx + 1;\n\t\t\t\tif (tx < 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttw = tile_x;\n\t\t\t\t}\n\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tcreate_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t\tin_run = 1;\n\t\t\t\t} else {\n\t\t\t\t\textend_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (in_run) {\n\t\t\t\t\t/* end of a row run of altered tiles: */\n\t\t\t\t\tsave_hint(hint, hint_count++);\n\t\t\t\t\tin_run = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_run) {\t/* save the last row run */\n\t\t\tsave_hint(hint, hint_count++);\n\t\t\tin_run = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i < hint_count; i++) {\n\t\t/* pass update info to vnc: */\n\t\tmark_hint(hint_list[i]);\n\t}\n}\n\n/*\n * kludge, simple ceil+floor for non-negative doubles:\n */\n#define CEIL(x)  ( (double) ((int) (x)) == (x) ? \\\n\t(double) ((int) (x)) : (double) ((int) (x) + 1) )\n#define FLOOR(x) ( (double) ((int) (x)) )\n\n/*\n * Scaling:\n *\n * For shrinking, a destination (scaled) pixel will correspond to more\n * than one source (i.e. main fb) pixel.  Think of an x-y plane made with\n * graph paper.  Each unit square in the graph paper (i.e. collection of\n * points (x,y) such that N < x < N+1 and M < y < M+1, N and M integers)\n * corresponds to one pixel in the unscaled fb.  There is a solid\n * color filling the inside of such a square.  A scaled pixel has width\n * 1/scale_fac, e.g. for \"-scale 3/4\" the width of the scaled pixel\n * is 1.333.  The area of this scaled pixel is 1.333 * 1.333 (so it\n * obviously overlaps more than one source pixel, each which have area 1).\n *\n * We take the weight an unscaled pixel (source) contributes to a\n * scaled pixel (destination) as simply proportional to the overlap area\n * between the two pixels.  One can then think of the value of the scaled\n * pixel as an integral over the portion of the graph paper it covers.\n * The thing being integrated is the color value of the unscaled source.\n * That color value is constant over a graph paper square (source pixel),\n * and changes discontinuously from one unit square to the next.\n *\n\nHere is an example for -scale 3/4, the solid lines are the source pixels\n(graph paper unit squares), while the dotted lines denote the scaled\npixels (destination pixels):\n\n            0         1 4/3     2     8/3 3         4=12/3\n            |---------|--.------|------.--|---------|.                \n            |         |  .      |      .  |         |.                \n            |    A    |  . B    |      .  |         |.                \n            |         |  .      |      .  |         |.                \n            |         |  .      |      .  |         |.                \n          1 |---------|--.------|------.--|---------|.                \n         4/3|.........|.........|.........|.........|.                \n            |         |  .      |      .  |         |.                \n            |    C    |  . D    |      .  |         |.                \n            |         |  .      |      .  |         |.                \n          2 |---------|--.------|------.--|---------|.                \n            |         |  .      |      .  |         |.                \n            |         |  .      |      .  |         |.                \n         8/3|.........|.........|.........|.........|.                \n            |         |  .      |      .  |         |.                \n          3 |---------|--.------|------.--|---------|.                \n\nSo we see the first scaled pixel (0 < x < 4/3 and 0 < y < 4/3) mostly\noverlaps with unscaled source pixel \"A\".  The integration (averaging)\nweights for this scaled pixel are:\n\n\t\t\tA\t 1\n\t\t\tB\t1/3\n\t\t\tC\t1/3\n\t\t\tD\t1/9\n\n *\n * The Red, Green, and Blue color values must be averaged over separately\n * otherwise you can get a complete mess (except in solid regions),\n * because high order bits are averaged differently from the low order bits.\n *\n * So the algorithm is roughly:\n *\n *   - Given as input a rectangle in the unscaled source fb with changes,\n *     find the rectangle of pixels this affects in the scaled destination fb.\n *\n *   - For each of the affected scaled (dest) pixels, determine all of the\n *     unscaled (source) pixels it overlaps with.\n *  \n *   - Average those unscaled source values together, weighted by the area\n *     overlap with the destination pixel.  Average R, G, B separately.\n *\n *   - Take this average value and convert to a valid pixel value if\n *     necessary (e.g. rounding, shifting), and then insert it into the\n *     destination framebuffer as the pixel value.\n *\n *   - On to the next destination pixel...\n *\n * ========================================================================\n *\n * For expanding, e.g. -scale 1.1 (which we don't think people will do\n * very often... or at least so we hope, the framebuffer can become huge)\n * the situation is reversed and the destination pixel is smaller than a\n * \"graph paper\" unit square (source pixel).  Some destination pixels\n * will be completely within a single unscaled source pixel.\n *\n * What we do here is a simple 4 point interpolation scheme:\n * \n * Let P00 be the source pixel closest to the destination pixel but with\n * x and y values less than or equal to those of the destination pixel.\n * (for simplicity, think of the upper left corner of a pixel defining the\n * x,y location of the pixel, the center would work just as well).  So it\n * is the source pixel immediately to the upper left of the destination\n * pixel.  Let P10 be the source pixel one to the right of P00.  Let P01\n * be one down from P00.  And let P11 be one down and one to the right\n * of P00.  They form a 2x2 square we will interpolate inside of.\n * \n * Let V00, V10, V01, and V11 be the color values of those 4 source\n * pixels.  Let dx be the displacement along x the destination pixel is\n * from P00.  Note: 0 <= dx < 1 by definition of P00.  Similarly let\n * dy be the displacement along y.  The weighted average for the\n * interpolation is:\n * \n * \tV_ave = V00 * (1 - dx) * (1 - dy)\n * \t      + V10 *      dx  * (1 - dy)\n * \t      + V01 * (1 - dx) *      dy\n * \t      + V11 *      dx  *      dy\n * \n * Note that the weights (1-dx)*(1-dy) + dx*(1-dy) + (1-dx)*dy + dx*dy\n * automatically add up to 1.  It is also nice that all the weights are\n * positive (unsigned char stays unsigned char).  The above formula can\n * be motivated by doing two 1D interpolations along x:\n * \n * \tVA = V00 * (1 - dx) + V10 * dx\n * \tVB = V01 * (1 - dx) + V11 * dx\n * \n * and then interpolating VA and VB along y:\n * \n * \tV_ave = VA * (1 - dy) + VB * dy\n * \n *                      VA \n *           v   |<-dx->|\n *           -- V00 ------ V10\n *           dy  |          |  \n *           --  |      o...|...    \"o\" denotes the position of the desired\n *           ^   |      .   |  .    destination pixel relative to the P00\n *               |      .   |  .    source pixel.\n *              V10 ----.- V11 .\n *                      ........\n *                      |  \n *                      VB \n *\n * \n * Of course R, G, B averages are done separately as in the shrinking\n * case.  This gives reasonable results, and the implementation for\n * shrinking can simply be used with different choices for weights for\n * the loop over the 4 pixels.\n */\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}\n\n/*\n Framebuffers data flow:\n                                                                             \n General case:\n                --------       --------       --------        --------    \n    -----      |8to24_fb|     |main_fb |     |snap_fb |      | X      |    \n   |rfbfb| <== |        | <== |        | <== |        | <==  | Server |    \n    -----       --------       --------       --------        --------    \n   (to vnc)    (optional)    (usu = rfbfb)   (optional)      (read only)   \n\n 8to24_fb mode will create side fbs: poll24_fb and poll8_fb for\n bookkeepping the different regions (merged into 8to24_fb).\n\n Normal case:\n    --------        --------    \n   |main_fb |      | X      |    \n   |= rfb_fb| <==  | Server |    \n    --------        --------    \n                                                                             \n Scaling case:\n                --------        --------    \n    -----      |main_fb |      | X      |    \n   |rfbfb| <== |        | <==  | Server |    \n    -----       --------        --------    \n\n Webcam/video case:\n    --------        --------        --------    \n   |main_fb |      |snap_fb |      | Video  |    \n   |        | <==  |        | <==  | device |    \n    --------        --------        --------    \n\nIf we ever do a -rr rotation/reflection tran, it probably should \nbe done after any scaling (need a rr_fb for intermediate results)\n\n-rr option:\t\ttransformation:\n\n\tnone\t\tx -> x;\n\t\t\ty -> y;\n\n\tx\t\tx -> w - x - 1;\n\t\t\ty -> y;\n\n\ty\t\tx -> x;\n\t\t\tx -> h - y - 1;\n\n\txy\t\tx -> w - x - 1;\n\t\t\ty -> h - y - 1;\n\n\t+90\t\tx -> h - y - 1;\n\t\t\ty -> x;\n\n\t+90x\t\tx -> y;\n\t\t\ty -> x;\n\n\t+90y\t\tx -> h - y - 1;\n\t\t\ty -> w - x - 1;\n\n\t-90\t\tx -> y;\n\t\t\ty -> w - x - 1;\n\nsome aliases:\n\n\txy:\tyx, +180, -180, 180\n\t+90:\t90\n\t+90x:\t90x\n\t+90y:\t90y\n\t-90:\t+270, 270\n */\n\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\n\t/* ncache?? */\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t}\n}\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}\n\n\t/* unroll the Bpp loop to be used in each case: */\n#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}\n\nvoid rotate_fb(int x1, int y1, int x2, int y2) {\n\tint x, y, xn, yn, r_x1, r_y1, r_x2, r_y2, Bpp = bpp/8;\n\tint fbl = rfb_bytes_per_line;\n\tint rbl = rot_bytes_per_line;\n\tint Dx, Dy;\n\tchar *src, *dst;\n\tchar *src_0 = rfb_fb;\n\tchar *dst_0 = rot_fb;\n\n\tif (! rotating || ! rot_fb) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\n\tdst = rot_fb;\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mark_wrapper(int x1, int y1, int x2, int y2) {\n\tint t, r_x1 = x1, r_y1 = y1, r_x2 = x2, r_y2 = y2;\n\n\tif (rotating) {\n\t\t/* well we hope rot_fb will always be the last one... */\n\t\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\t\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\t\trotate_fb(x1, y1, x2, y2);\n\t\tif (r_x1 > r_x2) {\n\t\t\tt = r_x1;\n\t\t\tr_x1 = r_x2;\n\t\t\tr_x2 = t;\n\t\t}\n\t\tif (r_y1 > r_y2) {\n\t\t\tt = r_y1;\n\t\t\tr_y1 = r_y2;\n\t\t\tr_y2 = t;\n\t\t}\n\t\t/* painting errors  */\n\t\tr_x1--;\n\t\tr_x2++;\n\t\tr_y1--;\n\t\tr_y2++;\n\t}\n\trfbMarkRectAsModified(screen, r_x1, r_y1, r_x2, r_y2);\n}\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}\n\n/*\n * Notifies libvncserver of a changed hint rectangle.\n */\nstatic void mark_hint(hint_t hint) {\n\tint x = hint.x;\t\n\tint y = hint.y;\t\n\tint w = hint.w;\t\n\tint h = hint.h;\t\n\n\tmark_rect_as_modified(x, y, x + w, y + h, 0);\n}\n\n/*\n * copy_tiles() gives a slight improvement over copy_tile() since\n * adjacent runs of tiles are done all at once there is some savings\n * due to contiguous memory access.  Not a great speedup, but in some\n * cases it can be up to 2X.  Even more on a SunRay or ShadowFB where\n * no graphics hardware is involved in the read.  Generally, graphics\n * devices are optimized for write, not read, so we are limited by the\n * read bandwidth, sometimes only 5 MB/sec on otherwise fast hardware.\n */\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}\n\n/*\n * The copy_tile() call in the loop below copies the changed tile into\n * the rfb framebuffer.  Note that copy_tile() sets the tile_region\n * struct to have info about the y-range of the changed region and also\n * whether the tile edges contain diffs (within distance tile_fuzz).\n *\n * We use this tile_region info to try to guess if the downward and right\n * tiles will have diffs.  These tiles will be checked later in the loop\n * (since y+1 > y and x+1 > x).\n *\n * See copy_tiles_backward_pass() for analogous checking upward and\n * left tiles.\n */\nstatic int copy_all_tiles(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tct = copy_tiles(x, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\t/*\n\t\t\t\t * n.b. copy_tiles() may have detected\n\t\t\t\t * no change and reset tile_has_diff to 0.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiffs++;\n\n\t\t\t/* neighboring tile downward: */\n\t\t\tif ( (y+1) < ntiles_y && tile_region[n].bot_diff) {\n\t\t\t\tm = x + (y+1) * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* neighboring tile to right: */\n\t\t\tif ( (x+1) < ntiles_x && tile_region[n].right_diff) {\n\t\t\t\tm = (x+1) + y * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn diffs;\n}\n\n/*\n * Routine analogous to copy_all_tiles() above, but for horizontal runs\n * of adjacent changed tiles.\n */\nstatic int copy_all_tile_runs(void) {\n\tint x, y, n, m, i;\n\tint diffs = 0, ct;\n\tint in_run = 0, run = 0;\n\tint ntave = 0, ntcnt = 0;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x + 1; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (x != ntiles_x && tile_has_diff[n]) {\n\t\t\t\tin_run = 1;\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tct = copy_tiles(x - run, y, run);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\n\t\t\t\tntcnt++;\n\t\t\t\tntave += run;\n\t\t\t\tdiffs += run;\n\n\t\t\t\t/* neighboring tile downward: */\n\t\t\t\tfor (i=1; i <= run; i++) {\n\t\t\t\t\tif ((y+1) < ntiles_y\n\t\t\t\t\t    && tile_region[n-i].bot_diff) {\n\t\t\t\t\t\tm = (x-i) + (y+1) * ntiles_x;\n\t\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* neighboring tile to right: */\n\t\t\t\tif (((x-1)+1) < ntiles_x\n\t\t\t\t    && tile_region[n-1].right_diff) {\n\t\t\t\t\tm = ((x-1)+1) + y * ntiles_x;\n\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/* note that this starts a new run */\n\t\t\t\t\tin_run = 1;\n\t\t\t\t\trun = 1;\n\t\t\t\t} else {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Could some activity go here, to emulate threaded\n\t\t * behavior by servicing some libvncserver tasks?\n\t\t */\n\t}\n\treturn diffs;\n}\n\n/*\n * Here starts a bunch of heuristics to guess/detect changed tiles.\n * They are:\n *   copy_tiles_backward_pass, fill_tile_gaps/gap_try, grow_islands/island_try\n */\n\n/*\n * Try to predict whether the upward and/or leftward tile has been modified.\n * copy_all_tiles() has already done downward and rightward tiles.\n */\nstatic int copy_tiles_backward_pass(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y = ntiles_y - 1; y >= 0; y--) {\n\t    for (x = ntiles_x - 1; x >= 0; x--) {\n\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\tif (! tile_has_diff[n]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = x + (y-1) * ntiles_x;\t/* neighboring tile upward */\n\n\t\tif (y >= 1 && ! tile_has_diff[m] && tile_region[n].top_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x, y-1, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\n\t\tm = (x-1) + y * ntiles_x;\t/* neighboring tile to left */\n\n\t\tif (x >= 1 && ! tile_has_diff[m] && tile_region[n].left_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x-1, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\nstatic int copy_tiles_additional_pass(void) {\n\tint x, y, n;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_copied[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tct = copy_tiles(x, y, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x) {\n\tint n, m, i, xt, yt, ct;\n\n\tn = x + y * ntiles_x;\n\n\tif (! tile_has_diff[n]) {\n\t\tif (*saw) {\n\t\t\t(*run)++;\t/* extend the gap run. */\n\t\t}\n\t\treturn 0;\n\t}\n\tif (! *saw || *run == 0 || *run > gaps_fill) {\n\t\t*run = 0;\t\t/* unacceptable run. */\n\t\t*saw = 1;\n\t\treturn 0;\n\t}\n\n\tfor (i=1; i <= *run; i++) {\t/* iterate thru the run. */\n\t\tif (along_x) {\n\t\t\txt = x - i;\n\t\t\tyt = y;\n\t\t} else {\n\t\t\txt = x;\n\t\t\tyt = y - i;\n\t\t}\n\n\t\tm = xt + yt * ntiles_x;\n\t\tif (tile_tried[m]) {\t/* do not repeat tiles */\n\t\t\tcontinue;\n\t\t}\n\n\t\tct = copy_tiles(xt, yt, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\t*run = 0;\n\t*saw = 1;\n\treturn 1;\n}\n\n/*\n * Look for small gaps of unchanged tiles that may actually contain changes.\n * E.g. when paging up and down in a web broswer or terminal there can\n * be a distracting delayed filling in of such gaps.  gaps_fill is the\n * tweak parameter that sets the width of the gaps that are checked.\n *\n * BTW, grow_islands() is actually pretty successful at doing this too...\n */\nstatic int fill_tile_gaps(void) {\n\tint x, y, run, saw;\n\tint n, diffs = 0, ct;\n\n\t/* horizontal: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\t/* vertical: */\n\tfor (x=0; x < ntiles_x; x++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 0);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\nstatic int island_try(int x, int y, int u, int v, int *run) {\n\tint n, m, ct;\n\n\tn = x + y * ntiles_x;\n\tm = u + v * ntiles_x;\n\n\tif (tile_has_diff[n]) {\n\t\t(*run)++;\n\t} else {\n\t\t*run = 0;\n\t}\n\n\tif (tile_has_diff[n] && ! tile_has_diff[m]) {\n\t\t/* found a discontinuity */\n\n\t\tif (tile_tried[m]) {\n\t\t\treturn 0;\n\t\t} else if (*run < grow_fill) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tct = copy_tiles(u, v, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\treturn 1;\n}\n\n/*\n * Scan looking for discontinuities in tile_has_diff[].  Try to extend\n * the boundary of the discontinuity (i.e. make the island larger).\n * Vertical scans are skipped since they do not seem to yield much...\n */\nstatic int grow_islands(void) {\n\tint x, y, n, run;\n\tint diffs = 0, ct;\n\n\t/*\n\t * n.b. the way we scan here should keep an extension going,\n\t * and so also fill in gaps effectively...\n\t */\n\n\t/* left to right: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x=0; x <= ntiles_x - 2; x++) {\n\t\t\tct = island_try(x, y, x+1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\t/* right to left: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x = ntiles_x - 1; x >= 1; x--) {\n\t\t\tct = island_try(x, y, x-1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\n/*\n * Fill the framebuffer with zeros for each blackout region\n */\nstatic void blackout_regions(void) {\n\tint i;\n\tfor (i=0; i < blackouts; i++) {\n\t\tzero_fb(blackr[i].x1, blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t}\n}\n\n/*\n * copy the whole X screen to the rfb framebuffer.  For a large enough\n * number of changed tiles, this is faster than tiles scheme at retrieving\n * the info from the X server.  Bandwidth to client and compression time\n * are other issues...  use -fs 1.0 to disable.\n */\nint copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}\n\n#include <default8x16.h>\n\n/*\n * Color values from the vcsadump program.\n * void dumpcss(FILE *fp, char *attribs_used)\n * char *colormap[] = {\n *    \"#000000\", \"#0000AA\", \"#00AA00\", \"#00AAAA\", \"#AA0000\", \"#AA00AA\", \"#AA5500\", \"#AAAAAA\",\n *    \"#555555\", \"#5555AA\", \"#55FF55\", \"#55FFFF\", \"#FF5555\", \"#FF55FF\", \"#FFFF00\", \"#FFFFFF\" };\n */\n\nstatic unsigned char console_cmap[16*3]={\n/*  0 */\t0x00, 0x00, 0x00,\n/*  1 */\t0x00, 0x00, 0xAA,\n/*  2 */\t0x00, 0xAA, 0x00,\n/*  3 */\t0x00, 0xAA, 0xAA,\n/*  4 */\t0xAA, 0x00, 0x00,\n/*  5 */\t0xAA, 0x00, 0xAA,\n/*  6 */\t0xAA, 0x55, 0x00,\n/*  7 */\t0xAA, 0xAA, 0xAA,\n/*  8 */\t0x55, 0x55, 0x55,\n/*  9 */\t0x55, 0x55, 0xAA,\n/* 10 */\t0x55, 0xFF, 0x55,\n/* 11 */\t0x55, 0xFF, 0xFF,\n/* 12 */\t0xFF, 0x55, 0x55,\n/* 13 */\t0xFF, 0x55, 0xFF,\n/* 14 */\t0xFF, 0xFF, 0x00,\n/* 15 */\t0xFF, 0xFF, 0xFF\n};\n  \nstatic void snap_vcsa_rawfb(void) {\n\tint n;\n\tchar *dst;\n\tchar buf[32];\n\tint i, len, del;\n\tunsigned char rows, cols, xpos, ypos;\n\tstatic int prev_rows = -1, prev_cols = -1;\n\tstatic unsigned char prev_xpos = -1, prev_ypos = -1;\n\tstatic char *vcsabuf  = NULL;\n\tstatic char *vcsabuf0 = NULL;\n\tstatic unsigned int color_tab[16];\n\tstatic int Cw = 8, Ch = 16;\n\tstatic int db = -1, first = 1;\n\tint created = 0;\n\trfbScreenInfo s;\n\trfbScreenInfoPtr fake_screen = &s;\n\tint Bpp = raw_fb_native_bpp / 8;\n\n\tif (db < 0) {\n\t\tif (getenv(\"X11VNC_DEBUG_VCSA\")) {\n\t\t\tdb = atoi(getenv(\"X11VNC_DEBUG_VCSA\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (first) {\n\t\tunsigned int rm = raw_fb_native_red_mask;\n\t\tunsigned int gm = raw_fb_native_green_mask;\n\t\tunsigned int bm = raw_fb_native_blue_mask;\n\t\tunsigned int rs = raw_fb_native_red_shift;\n\t\tunsigned int gs = raw_fb_native_green_shift;\n\t\tunsigned int bs = raw_fb_native_blue_shift;\n\t\tunsigned int rx = raw_fb_native_red_max;\n\t\tunsigned int gx = raw_fb_native_green_max;\n\t\tunsigned int bx = raw_fb_native_blue_max;\n\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tint r = console_cmap[3*i+0];\n\t\t\tint g = console_cmap[3*i+1];\n\t\t\tint b = console_cmap[3*i+2];\n\t\t\tr = rx * r / 255;\n\t\t\tg = gx * g / 255;\n\t\t\tb = bx * b / 255;\n\t\t\tcolor_tab[i] = (r << rs) | (g << gs) | (b << bs);\n\t\t\tif (db) fprintf(stderr, \"cmap[%02d] 0x%08x  %04d %04d %04d\\n\", i, color_tab[i], r, g, b); \n\t\t\tif (i != 0 && getenv(\"RAWFB_VCSA_BW\")) {\n\t\t\t\tcolor_tab[i] = rm | gm | bm;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\tlseek(raw_fb_fd, 0, SEEK_SET);\n\tlen = 4;\n\tdel = 0;\n\tmemset(buf, 0, sizeof(buf));\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, buf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trows = (unsigned char) buf[0];\n\tcols = (unsigned char) buf[1];\n\txpos = (unsigned char) buf[2];\n\typos = (unsigned char) buf[3];\n\n\tif (db) fprintf(stderr, \"rows=%d cols=%d xpos=%d ypos=%d Bpp=%d\\n\", rows, cols, xpos, ypos, Bpp);\n\tif (rows == 0 || cols == 0) {\n\t\tusleep(100 * 1000);\n\t\treturn;\n\t}\n\n\tif (vcsabuf == NULL || prev_rows != rows || prev_cols != cols) {\n\t\tif (vcsabuf) {\n\t\t\tfree(vcsabuf);\n\t\t\tfree(vcsabuf0);\n\t\t}\n\t\tvcsabuf  = (char *) calloc(2 * rows * cols, 1);\n\t\tvcsabuf0 = (char *) calloc(2 * rows * cols, 1);\n\t\tcreated = 1;\n\n\t\tif (prev_rows != -1 && prev_cols != -1) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tprev_rows = rows;\n\t\tprev_cols = cols;\n\t}\n\n\tif (!rfbEndianTest) {\n\t\tunsigned char tc = rows;\n\t\trows = cols;\n\t\tcols = tc;\n\n\t\ttc = xpos;\n\t\txpos = ypos;\n\t\typos = tc;\n\t}\n\n\tlen = 2 * rows * cols;\n\tdel = 0;\n\tmemset(vcsabuf, 0, len);\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, vcsabuf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_screen->frameBuffer = snap->data;\n\tfake_screen->paddedWidthInBytes = snap->bytes_per_line;\n\tfake_screen->serverFormat.bitsPerPixel = raw_fb_native_bpp;\n\tfake_screen->width = snap->width;\n\tfake_screen->height = snap->height;\n\n\tfor (i=0; i < rows * cols; i++) {\n\t\tint ix, iy, x, y, w, h;\n\t\tunsigned char chr = 0;\n\t\tunsigned char attr;\n\t\tunsigned int fore, back;\n\t\tunsigned short *usp;\n\t\tunsigned int *uip;\n\t\tchr  = (unsigned char) vcsabuf[2*i];\n\t\tattr = vcsabuf[2*i+1];\n\n\t\tiy = i / cols;\n\t\tix = i - iy * cols;\n\n\t\tif (ix == prev_xpos && iy == prev_ypos) {\n\t\t\t;\n\t\t} else if (ix == xpos && iy == ypos) {\n\t\t\t;\n\t\t} else if (!created && chr == vcsabuf0[2*i] && attr == vcsabuf0[2*i+1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rfbEndianTest) {\n\t\t\tunsigned char tc = chr;\n\t\t\tchr = attr;\n\t\t\tattr = tc;\n\t\t}\n\n\t\ty = iy * Ch;\n\t\tx = ix * Cw;\n\t\tdst = snap->data + y * snap->bytes_per_line + x * Bpp;\n\n\t\tfore = color_tab[attr & 0xf];\n\t\tback = color_tab[(attr >> 4) & 0x7];\n\n\t\tif (ix == xpos && iy == ypos) {\n\t\t\tunsigned int ti = fore;\n\t\t\tfore = back;\n\t\t\tback = ti;\n\t\t}\n\n\t\tfor (h = 0; h < Ch; h++) {\n\t\t\tif (Bpp == 1) {\n\t\t\t\tmemset(dst, back, Cw);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tusp = (unsigned short *) (dst + w*Bpp); \n\t\t\t\t\t*usp = (unsigned short) back;\n\t\t\t\t}\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tuip = (unsigned int *) (dst + w*Bpp); \n\t\t\t\t\t*uip = (unsigned int) back;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t\trfbDrawChar(fake_screen, &default8x16Font, x, y + Ch, chr, fore);\n\t}\n\tmemcpy(vcsabuf0, vcsabuf, 2 * rows * cols); \n\tprev_xpos = xpos;\n\tprev_ypos = ypos;\n}\n\nstatic void snap_all_rawfb(void) {\n\tint pixelsize = bpp/8;\n\tint n, sz;\n\tchar *dst;\n\tstatic char *unclipped_dst = NULL;\n\tstatic int unclipped_len = 0;\n\n\tdst = snap->data;\n\n\tif (xform24to32 && bpp == 32) {\n\t\tpixelsize = 3;\n\t}\n\tsz = dpy_y * snap->bytes_per_line;\n\n\tif (wdpy_x > dpy_x || wdpy_y > dpy_y) {\n\t\tsz = wdpy_x * wdpy_y * pixelsize;\n\t\tif (sz > unclipped_len || unclipped_dst == NULL) {\n\t\t\tif (unclipped_dst) {\n\t\t\t\tfree(unclipped_dst);\n\t\t\t}\n\t\t\tunclipped_dst = (char *) malloc(sz+4);\n\t\t\tunclipped_len = sz;\n\t\t}\n\t\tdst = unclipped_dst;\n\t}\n\t\t\n\tif (! raw_fb_seek) {\n\t\tmemcpy(dst, raw_fb_addr + raw_fb_offset, sz);\n\n\t} else {\n\t\tint len = sz, del = 0;\n\t\toff_t off = (off_t) raw_fb_offset;\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\twhile (len > 0) {\n\t\t\tn = read(raw_fb_fd, dst + del, len);\n\t\t\tif (n > 0) {\n\t\t\t\tdel += n;\n\t\t\t\tlen -= n;\n\t\t\t} else if (n == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dst == unclipped_dst) {\n\t\tchar *src;\n\t\tint h;\n\t\tint x = off_x + coff_x;\n\t\tint y = off_y + coff_y;\n\n\t\tsrc = unclipped_dst + y * wdpy_x * pixelsize +\n\t\t    x * pixelsize;\n\t\tdst = snap->data;\n\n\t\tfor (h = 0; h < dpy_y; h++) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += wdpy_x * pixelsize;\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t}\n}\n\nint copy_snap(void) {\n\tint db = 1;\n\tchar *fbp;\n\tint i, y, block_size;\n\tdouble dt;\n\tstatic int first = 1, snapcnt = 0;\n\n\tif (raw_fb_str) {\n\t\tint read_all_at_once = 1;\n\t\tdouble start = dnow();\n\t\tif (rawfb_reset < 0) {\n\t\t\tif (getenv(\"SNAPFB_RAWFB_RESET\")) {\n\t\t\t\trawfb_reset = 1;\n\t\t\t} else {\n\t\t\t\trawfb_reset = 0;\n\t\t\t}\n\t\t}\n\t\tif (snap_fb == NULL || snap == NULL) {\n\t\t\trfbLog(\"copy_snap: rawfb mode and null snap fb\\n\"); \n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (rawfb_reset) {\n\t\t\tinitialize_raw_fb(1);\n\t\t}\n\t\tif (raw_fb_bytes_per_line != snap->bytes_per_line) {\n\t\t\tread_all_at_once = 0;\n\t\t}\n\t\tif (raw_fb_full_str && strstr(raw_fb_full_str, \"/dev/vcsa\")) {\n\t\t\tsnap_vcsa_rawfb();\n\t\t} else if (read_all_at_once) {\n\t\t\tsnap_all_rawfb();\n\t\t} else {\n\t\t\t/* this goes line by line, XXX not working for video */\n\t\t\tcopy_raw_fb(snap, 0, 0, dpy_x, dpy_y);\n\t\t}\nif (db && snapcnt++ < 5) rfbLog(\"rawfb copy_snap took: %.5f secs\\n\", dnow() - start);\n\n\t\treturn 0;\n\t}\n\t\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\n\n\tif (! snap_fb || ! snap || ! snaprect) {\n\t\treturn 0;\n\t}\n\tblock_size = ((dpy_y/fs_factor) * snap->bytes_per_line);\n\n\tfbp = snap_fb;\n\ty = 0;\n\n\n\tdtime0(&dt);\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_snap-set\");\n\t\tcopy_image(snaprect, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_snap-chk\");\n\n\t\tmemcpy(fbp, snaprect->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tdt = dtime(&dt);\n\tif (first) {\n\t\trfbLog(\"copy_snap: time for -snapfb snapshot: %.3f sec\\n\", dt);\n\t\tfirst = 0;\n\t}\n\n\treturn 0;\n}\n\n/* STFU: Only for debugging */\n#if 0\n/* \n * debugging: print out a picture of the tiles.\n */\nstatic void print_tiles(void) {\n\t/* hack for viewing tile diffs on the screen. */\n\tstatic char *prev = NULL;\n\tint n, x, y, ms = 1500;\n\n\tms = 1;\n\n\tif (! prev) {\n\t\tprev = (char *) malloc((size_t) ntiles);\n\t\tfor (n=0; n < ntiles; n++) {\n\t\t\tprev[n] = 0;\n\t\t}\n\t}\n\tfprintf(stderr, \"   \");\n\tfor (x=0; x < ntiles_x; x++) {\n\t\tfprintf(stderr, \"%1d\", x % 10);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tn = 0;\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfprintf(stderr, \"%2d \", y);\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tfprintf(stderr, \"X\");\n\t\t\t} else if (prev[n]) {\n\t\t\t\tfprintf(stderr, \"o\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tprev[n] = tile_has_diff[n];\n\t}\n\tusleep(ms * 1000);\n}\n#endif\n\n/*\n * Utilities for managing the \"naps\" to cut down on amount of polling.\n */\nstatic void nap_set(int tile_cnt) {\n\tint nap_in = nap_ok;\n\ttime_t now = time(NULL);\n\n\tif (scan_count == 0) {\n\t\t/* roll up check for all NSCAN scans */\n\t\tnap_ok = 0;\n\t\tif (naptile && nap_diff_count < 2 * NSCAN * naptile) {\n\t\t\t/* \"2\" is a fudge to permit a bit of bg drawing */\n\t\t\tnap_ok = 1;\n\t\t}\n\t\tnap_diff_count = 0;\n\t}\n\tif (nap_ok && ! nap_in && use_xdamage) {\n\t\tif (XD_skip > 0.8 * XD_tot) \t{\n\t\t\t/* X DAMAGE is keeping load low, so skip nap */\n\t\t\tnap_ok = 0;\n\t\t}\n\t}\n\tif (! nap_ok && client_count) {\n\t\tif(now > last_fb_bytes_sent + no_fbu_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_set: nap_ok=1: now: %d last: %d\\n\",\n\t\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t\t}\n\t\t\tnap_ok = 1;\n\t\t}\n\t}\n\n\tif (show_cursor) {\n\t\t/* kludge for the up to 4 tiles the mouse patch could occupy */\n\t\tif ( tile_cnt > 4) {\n\t\t\tlast_event = now;\n\t\t}\n\t} else if (tile_cnt != 0) {\n\t\tlast_event = now;\n\t}\n}\n\n/*\n * split up a long nap to improve the wakeup time\n */\nvoid nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic char *get_load(void) {\n\tstatic char tmp[64];\n\tstatic int count = 0;\n\n\tif (count++ % 5 == 0) {\n\t\tstruct stat sb;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tif (stat(\"/proc/loadavg\", &sb) == 0) {\n\t\t\tint d = open(\"/proc/loadavg\", O_RDONLY);\n\t\t\tif (d >= 0) {\n\t\t\t\tread(d, tmp, 60);\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t}\n\t\tif (tmp[0] == '\\0') {\n\t\t\tstrcat(tmp, \"unknown\");\n\t\t}\n\t}\n\treturn tmp;\n}\n\n/*\n * see if we should take a nap of some sort between polls\n */\nstatic void nap_check(int tile_cnt) {\n\ttime_t now;\n\n\tnap_diff_count += tile_cnt;\n\n\tif (! take_naps) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tif (screen_blank > 0) {\n\t\tint dt_ev, dt_fbu;\n\t\tstatic int ms = 0;\n\t\tif (ms == 0) {\n\t\t\tms = 2000;\n\t\t\tif (getenv(\"X11VNC_SB_FACTOR\")) {\n\t\t\t\tms = ms * atof(getenv(\"X11VNC_SB_FACTOR\"));\n\t\t\t}\n\t\t\tif (ms <= 0) {\n\t\t\t\tms = 2000;\n\t\t\t}\n\t\t}\n\n\t\t/* if no activity, pause here for a second or so. */\n\t\tdt_ev  = (int) (now - last_event);\n\t\tdt_fbu = (int) (now - last_fb_bytes_sent);\n\t\tif (dt_fbu > screen_blank) {\n\t\t\t/* sleep longer for no fb requests */\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep1: %d ms / 16, load: %s\\n\", 2 * ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(2 * ms, 16);\n\t\t\treturn;\n\t\t}\n\t\tif (dt_ev > screen_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep2: %d ms / 8, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (naptile && nap_ok && tile_cnt < naptile) {\n\t\tint ms = napfac * waitms;\n\t\tms = ms > napmax ? napmax : ms;\n\t\tif (now - last_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else if (now - last_local_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_check sleep: %d ms / 1, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 1);\n\t\t}\n\t}\n}\n\n/*\n * This is called to avoid a ~20 second timeout in libvncserver.\n * May no longer be needed.\n */\nstatic void ping_clients(int tile_cnt) {\n\tstatic time_t last_send = 0;\n\ttime_t now = time(NULL);\n\n\tif (rfbMaxClientWait < 20000) {\n\t\trfbMaxClientWait = 20000;\n\t\trfbLog(\"reset rfbMaxClientWait to %d msec.\\n\",\n\t\t    rfbMaxClientWait);\n\t}\n\tif (tile_cnt > 0) {\n\t\tlast_send = now;\n\t} else if (tile_cnt < 0) {\n\t\t/* negative tile_cnt is -ping case */\n\t\tif (now >= last_send - tile_cnt) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlast_send = now;\n\t\t}\n\t} else if (now - last_send > 5) {\n\t\t/* Send small heartbeat to client */\n\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\tlast_send = now;\n\t}\n}\n\n/*\n * scan_display() wants to know if this tile can be skipped due to\n * blackout regions: (no data compare is done, just a quick geometric test)\n */\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count) {\n\t\n\tif (tile_blackout[n].cover == 2) {\n\t\ttile_has_diff[n] = 0;\n\t\treturn 1;\t/* skip it */\n\n\t} else if (tile_blackout[n].cover == 1) {\n\t\tint w, x1, y1, x2, y2, b, hit = 0;\n\t\tif (x + NSCAN > dpy_x) {\n\t\t\tw = dpy_x - x;\n\t\t} else {\n\t\t\tw = NSCAN;\n\t\t}\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\t\n\t\t\t/* n.b. these coords are in full display space: */\n\t\t\tx1 = tile_blackout[n].bo[b].x1;\n\t\t\tx2 = tile_blackout[n].bo[b].x2;\n\t\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t\tif (x2 - x1 < w) {\n\t\t\t\t/* need to cover full width */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y1 <= y && y < y2) {\n\t\t\t\thit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hit) {\n\t\t\tif (! rescan) {\n\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t} else {\n\t\t\t\t*tile_count += tile_has_diff[n];\n\t\t\t}\n\t\t\treturn 1;\t/* skip */\n\t\t}\n\t}\n\treturn 0;\t/* do not skip */\n}\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize) {\n\n\tint i, x1, y1, x2, y2, b, hit = 0;\n\tint beg = -1, end = -1; \n\n\tif (tile_blackout[n].cover == 0) {\n\t\treturn 0;\t/* 0 means do not skip it. */\n\t} else if (tile_blackout[n].cover == 2) {\n\t\treturn 1;\t/* 1 means skip it. */\n\t}\n\n\t/* tile has partial coverage: */\n\n\tfor (i=0; i < w * pixelsize; i++)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tbeg = i/pixelsize;\t/* beginning difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = w * pixelsize - 1; i >= 0; i--)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tend = i/pixelsize;\t/* ending difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (beg < 0 || end < 0) {\n\t\t/* problem finding range... */\n\t\treturn 0;\n\t}\n\n\t/* loop over blackout rectangles: */\n\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\n\t\t/* y in full display space: */\n\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t/* x relative to tile origin: */\n\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\n\t\tif (y1 > y || y >= y2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 <= beg && end <= x2) {\n\t\t\thit = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (hit) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/*\n * For the subwin case follows the window if it is moved.\n */\nvoid set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}\n\nstatic int xd_samples = 0, xd_misses = 0, xd_do_check = 0;\n\n/*\n * Loop over 1-pixel tall horizontal scanlines looking for changes.  \n * Record the changes in tile_has_diff[].  Scanlines in the loop are\n * equally spaced along y by NSCAN pixels, but have a slightly random\n * starting offset ystart ( < NSCAN ) from scanlines[].\n */\n\nstatic int scan_display(int ystart, int rescan) {\n\tchar *src, *dst;\n\tint pixelsize = bpp/8;\n\tint x, y, w, n;\n\tint tile_count = 0;\n\tint nodiffs = 0, diff_hint;\n\tint xd_check = 0, xd_freq = 1;\n\tstatic int xd_tck = 0;\n\n\ty = ystart;\n\n\tg_now = dnow();\n\n\tif (! main_fb) {\n\t\trfbLog(\"scan_display: no main_fb!\\n\");\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\n\twhile (y < dpy_y) {\n\n\t\tif (use_xdamage) {\n\t\t\tXD_tot++;\n\t\t\txd_check = 0;\n\t\t\tif (xdamage_hint_skip(y)) {\n\t\t\t\tif (xd_do_check && dpy && use_xdamage == 1) {\n\t\t\t\t\txd_tck++;\n\t\t\t\t\txd_tck = xd_tck % xd_freq;\n\t\t\t\t\tif (xd_tck == 0) {\n\t\t\t\t\t\txd_check = 1;\n\t\t\t\t\t\txd_samples++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!xd_check) {\n\t\t\t\t\tXD_skip++;\n\t\t\t\t\ty += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xd_do_check && 0) {\n\t\t\t\t\tfprintf(stderr, \"ns y=%d\\n\", y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* grab the horizontal scanline from the display: */\n\n#ifndef NO_NCACHE\n/* XXX Y test */\nif (ncache > 0) {\n\tint gotone = 0;\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tgotone = 1;\n\t\t}\n\t} else {\n#if !NO_X11\n\t\tXEvent ev;\n\t\tif (raw_fb_str) {\n\t\t\t;\n\t\t} else if (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\t;\t/* XXX Y resp */\n\t\t} else if (XCheckTypedEvent(dpy, MapNotify, &ev)) {\n\t\t\tgotone = 1;\n\t\t} else if (XCheckTypedEvent(dpy, UnmapNotify, &ev)) {\n\t\t\tgotone = 2;\n\t\t} else if (XCheckTypedEvent(dpy, CreateNotify, &ev)) {\n\t\t\tgotone = 3;\n\t\t} else if (XCheckTypedEvent(dpy, ConfigureNotify, &ev)) {\n\t\t\tgotone = 4;\n\t\t} else if (XCheckTypedEvent(dpy, VisibilityNotify, &ev)) {\n\t\t\tgotone = 5;\n\t\t}\n\t\tif (gotone) {\n\t\t\tXPutBackEvent(dpy, &ev);\n\t\t}\n#endif\n\t}\n\tif (gotone) {\n\t\tstatic int nomsg = 1;\n\t\tif (nomsg) {\n\t\t\tif (dnowx() > 20) {\n\t\t\t\tnomsg = 0;\n\t\t\t}\n\t\t} else {\nif (ncdb) fprintf(stderr, \"\\n*** SCAN_DISPLAY CHECK_NCACHE/%d *** %d rescan=%d\\n\", gotone, y, rescan);\n\t\t}\n\t\tX_UNLOCK;\n\t\tcheck_ncache(0, 1);\n\t\tX_LOCK;\n\t}\n}\n#endif\n\n\t\tXRANDR_SET_TRAP_RET(-1, \"scan_display-set\");\n\t\tcopy_image(scanline, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"scan_display-chk\");\n\n\t\t/* for better memory i/o try the whole line at once */\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line;\n\n\t\tif (! memcmp(dst, src, main_bytes_per_line)) {\n\t\t\t/* no changes anywhere in scan line */\n\t\t\tnodiffs = 1;\n\t\t\tif (! rescan) {\n\t\t\t\ty += NSCAN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (xd_check) {\n\t\t\txd_misses++;\n\t\t}\n\n\t\tx = 0;\n\t\twhile (x < dpy_x) {\n\t\t\tn = (x/tile_x) + (y/tile_y) * ntiles_x;\n\t\t\tdiff_hint = 0;\n\n\t\t\tif (blackouts) {\n\t\t\t\tif (blackout_line_skip(n, x, y, rescan,\n\t\t\t\t    &tile_count)) {\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rescan) {\n\t\t\t\tif (nodiffs || tile_has_diff[n]) {\n\t\t\t\t\ttile_count += tile_has_diff[n];\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (xdamage_tile_count &&\n\t\t\t    tile_has_xdamage_diff[n]) {\n\t\t\t\ttile_has_xdamage_diff[n] = 2;\n\t\t\t\tdiff_hint = 1;\n\t\t\t}\n\n\t\t\t/* set ptrs to correspond to the x offset: */\n\t\t\tsrc = scanline->data + x * pixelsize;\n\t\t\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\t\t\t/* compute the width of data to be compared: */\n\t\t\tif (x + NSCAN > dpy_x) {\n\t\t\t\tw = dpy_x - x;\n\t\t\t} else {\n\t\t\t\tw = NSCAN;\n\t\t\t}\n\n\t\t\tif (diff_hint || memcmp(dst, src, w * pixelsize)) {\n\t\t\t\t/* found a difference, record it: */\n\t\t\t\tif (! blackouts) {\n\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (blackout_line_cmpskip(n, x, y,\n\t\t\t\t\t    dst, src, w, pixelsize)) {\n\t\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += NSCAN;\n\t\t}\n\t\ty += NSCAN;\n\t}\n\n\tX_UNLOCK;\n\n\treturn tile_count;\n}\n\n\nint scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};\n\n/*\n * toplevel for the scanning, rescanning, and applying the heuristics.\n * returns number of changed tiles.\n */\nint scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}\n\n\n"], "fixing_code": ["/*\n   Copyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com> \n   All rights reserved.\n\nThis file is part of x11vnc.\n\nx11vnc is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or (at\nyour option) any later version.\n\nx11vnc is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with x11vnc; if not, write to the Free Software\nFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA\nor see <http://www.gnu.org/licenses/>.\n\nIn addition, as a special exception, Karl J. Runge\ngives permission to link the code of its release of x11vnc with the\nOpenSSL project's \"OpenSSL\" library (or with modified versions of it\nthat use the same license as the \"OpenSSL\" library), and distribute\nthe linked executables.  You must obey the GNU General Public License\nin all respects for all of the code used other than \"OpenSSL\".  If you\nmodify this file, you may extend this exception to your version of the\nfile, but you are not obligated to do so.  If you do not wish to do\nso, delete this exception statement from your version.\n*/\n\n/* -- scan.c -- */\n\n#include \"x11vnc.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"win_utils.h\"\n#include \"8to24.h\"\n#include \"screen.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"userinput.h\"\n\n/*\n * routines for scanning and reading the X11 display for changes, and\n * for doing all the tile work (shm, etc).\n */\nvoid initialize_tiles(void);\nvoid free_tiles(void);\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nvoid initialize_polling_images(void);\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\nint copy_screen(void);\nint copy_snap(void);\nvoid nap_sleep(int ms, int split);\nvoid set_offset(void);\nint scan_for_updates(int count_only);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nstatic void set_fs_factor(int max);\nstatic char *flip_ximage_byte_order(XImage *xim);\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void save_hint(hint_t hint, int loc);\nstatic void hint_updates(void);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int copy_all_tiles(void);\nstatic int copy_all_tile_runs(void);\nstatic int copy_tiles_backward_pass(void);\nstatic int copy_tiles_additional_pass(void);\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x);\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\nstatic void blackout_regions(void);\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic int scan_display(int ystart, int rescan);\n\n\n/* array to hold the hints: */\nstatic hint_t *hint_list;\n\n/* nap state */\nint nap_ok = 0;\nstatic int nap_diff_count = 0;\n\nstatic int scan_count = 0;\t/* indicates which scan pattern we are on  */\nstatic int scan_in_progress = 0;\t\n\n\ntypedef struct tile_change_region {\n\t/* start and end lines, along y, of the changed area inside a tile. */\n\tunsigned short first_line, last_line;\n\tshort first_x, last_x;\n\t/* info about differences along edges. */\n\tunsigned short left_diff, right_diff;\n\tunsigned short top_diff,  bot_diff;\n} region_t;\n\n/* array to hold the tiles region_t-s. */\nstatic region_t *tile_region;\n\n\n\n\n/*\n * setup tile numbers and allocate the tile and hint arrays:\n */\nvoid initialize_tiles(void) {\n\n\tntiles_x = (dpy_x - 1)/tile_x + 1;\n\tntiles_y = (dpy_y - 1)/tile_y + 1;\n\tntiles = ntiles_x * ntiles_y;\n\n\ttile_has_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_row_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles_y * sizeof(unsigned char)), 1);\n\ttile_tried    = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_copied   = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_blackout    = (tile_blackout_t *)\n\t\tcalloc((size_t) (ntiles * sizeof(tile_blackout_t)), 1);\n\ttile_region = (region_t *) calloc((size_t) (ntiles * sizeof(region_t)), 1);\n\n\ttile_row = (XImage **)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XImage *)), 1);\n\ttile_row_shm = (XShmSegmentInfo *)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo)), 1);\n\n\t/* there will never be more hints than tiles: */\n\thint_list = (hint_t *) calloc((size_t) (ntiles * sizeof(hint_t)), 1);\n}\n\nvoid free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}\n\n/*\n * silly function to factor dpy_y until fullscreen shm is not bigger than max.\n * should always work unless dpy_y is a large prime or something... under\n * failure fs_factor remains 0 and no fullscreen updates will be tried.\n */\nstatic int fs_factor = 0;\n\nstatic void set_fs_factor(int max) {\n\tint f, fac = 1, n = dpy_y;\n\n\tfs_factor = 0;\n\tif ((bpp/8) * dpy_x * dpy_y <= max)  {\n\t\tfs_factor = 1;\n\t\treturn;\n\t}\n\tfor (f=2; f <= 101; f++) {\n\t\twhile (n % f == 0) {\n\t\t\tn = n / f;\n\t\t\tfac = fac * f;\n\t\t\tif ( (bpp/8) * dpy_x * (dpy_y/fac) <= max )  {\n\t\t\t\tfs_factor = fac;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \"MSBFirst\";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \"LSBFirst\";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}\n\n/*\n * set up an XShm image, or if not using shm just create the XImage.\n */\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0600);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}\n\nvoid shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"shm_clean: called:  %p\\n\", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \"shm_clean: XShmDetach_wr\\n\");\n\t\tXShmDetach_wr(dpy, shm);\n\t}\n#endif\n\tif (xim != NULL) {\n\t\tif (! raw_fb_back_to_X) {\t/* raw_fb hack */\n\t\t\tif (xim->bitmap_unit != -1) {\n\t\t\t\tif (db) fprintf(stderr, \"shm_clean: XDestroyImage  %p\\n\", (void *)xim);\n\t\t\t\tXDestroyImage(xim);\n\t\t\t} else {\n\t\t\t\tif (xim->data) {\n\t\t\t\t\tif (db) fprintf(stderr, \"shm_clean: free xim->data  %p %p\\n\", (void *)xim, (void *)(xim->data));\n\t\t\t\t\tfree(xim->data);\n\t\t\t\t\txim->data = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txim = NULL;\n\t}\n\tX_UNLOCK;\n\n\tshm_delete(shm);\n}\n\nvoid initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \"none\" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \"scanline\")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \"Linux\")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\"warning: fullscreen updates are disabled.\\n\");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \"fullscreen\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\"warning: disabling -snapfb mode.\\n\");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \"snaprect\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \"tile_row\")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\"shm: Error creating shared memory tile-row for\"\n\t\t\t    \" len=%d,\\n\", i);\n\t\t\trfbLog(\"shm: reverting to -onetile mode. If this\"\n\t\t\t    \" problem persists\\n\");\n\t\t\trfbLog(\"shm: try using the -onetile or -noshm options\"\n\t\t\t    \" to limit\\n\");\n\t\t\trfbLog(\"shm: shared memory usage, or run ipcrm(1)\"\n\t\t\t    \" to manually\\n\");\n\t\t\trfbLog(\"shm: delete unattached shm segments.\\n\");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\"created %d tile_row shm polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\"created %d tile_row polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}\n\n/*\n * A hint is a rectangular region built from 1 or more adjacent tiles\n * glued together.  Ultimately, this information in a single hint is sent\n * to libvncserver rather than sending each tile separately.\n */\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\thint->x = x;\n\thint->y = y;\n\thint->w = w;\n\thint->h = h;\n}\n\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\tif (hint->x > x) {\t\t\t/* extend to the left */\n\t\thint->w += hint->x - x;\n\t\thint->x = x;\n\t}\n\tif (hint->y > y) {\t\t\t/* extend upward */\n\t\thint->h += hint->y - y;\n\t\thint->y = y;\n\t}\n\n\tif (hint->x + hint->w < x + w) {\t/* extend to the right */\n\t\thint->w = x + w - hint->x;\n\t}\n\tif (hint->y + hint->h < y + h) {\t/* extend downward */\n\t\thint->h = y + h - hint->y;\n\t}\n}\n\nstatic void save_hint(hint_t hint, int loc) {\n\t/* simply copy it to the global array for later use. */\n\thint_list[loc].x = hint.x;\n\thint_list[loc].y = hint.y;\n\thint_list[loc].w = hint.w;\n\thint_list[loc].h = hint.h;\n}\n\n/*\n * Glue together horizontal \"runs\" of adjacent changed tiles into one big\n * rectangle change \"hint\" to be passed to the vnc machinery.\n */\nstatic void hint_updates(void) {\n\thint_t hint;\n\tint x, y, i, n, ty, th, tx, tw;\n\tint hint_count = 0, in_run = 0;\n\n\thint.x = hint.y = hint.w = hint.h = 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tty = tile_region[n].first_line;\n\t\t\t\tth = tile_region[n].last_line - ty + 1;\n\n\t\t\t\ttx = tile_region[n].first_x;\n\t\t\t\ttw = tile_region[n].last_x - tx + 1;\n\t\t\t\tif (tx < 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttw = tile_x;\n\t\t\t\t}\n\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tcreate_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t\tin_run = 1;\n\t\t\t\t} else {\n\t\t\t\t\textend_tile_hint( x * tile_x + tx,\n\t\t\t\t\t    y * tile_y + ty, tw, th, &hint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (in_run) {\n\t\t\t\t\t/* end of a row run of altered tiles: */\n\t\t\t\t\tsave_hint(hint, hint_count++);\n\t\t\t\t\tin_run = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_run) {\t/* save the last row run */\n\t\t\tsave_hint(hint, hint_count++);\n\t\t\tin_run = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i < hint_count; i++) {\n\t\t/* pass update info to vnc: */\n\t\tmark_hint(hint_list[i]);\n\t}\n}\n\n/*\n * kludge, simple ceil+floor for non-negative doubles:\n */\n#define CEIL(x)  ( (double) ((int) (x)) == (x) ? \\\n\t(double) ((int) (x)) : (double) ((int) (x) + 1) )\n#define FLOOR(x) ( (double) ((int) (x)) )\n\n/*\n * Scaling:\n *\n * For shrinking, a destination (scaled) pixel will correspond to more\n * than one source (i.e. main fb) pixel.  Think of an x-y plane made with\n * graph paper.  Each unit square in the graph paper (i.e. collection of\n * points (x,y) such that N < x < N+1 and M < y < M+1, N and M integers)\n * corresponds to one pixel in the unscaled fb.  There is a solid\n * color filling the inside of such a square.  A scaled pixel has width\n * 1/scale_fac, e.g. for \"-scale 3/4\" the width of the scaled pixel\n * is 1.333.  The area of this scaled pixel is 1.333 * 1.333 (so it\n * obviously overlaps more than one source pixel, each which have area 1).\n *\n * We take the weight an unscaled pixel (source) contributes to a\n * scaled pixel (destination) as simply proportional to the overlap area\n * between the two pixels.  One can then think of the value of the scaled\n * pixel as an integral over the portion of the graph paper it covers.\n * The thing being integrated is the color value of the unscaled source.\n * That color value is constant over a graph paper square (source pixel),\n * and changes discontinuously from one unit square to the next.\n *\n\nHere is an example for -scale 3/4, the solid lines are the source pixels\n(graph paper unit squares), while the dotted lines denote the scaled\npixels (destination pixels):\n\n            0         1 4/3     2     8/3 3         4=12/3\n            |---------|--.------|------.--|---------|.                \n            |         |  .      |      .  |         |.                \n            |    A    |  . B    |      .  |         |.                \n            |         |  .      |      .  |         |.                \n            |         |  .      |      .  |         |.                \n          1 |---------|--.------|------.--|---------|.                \n         4/3|.........|.........|.........|.........|.                \n            |         |  .      |      .  |         |.                \n            |    C    |  . D    |      .  |         |.                \n            |         |  .      |      .  |         |.                \n          2 |---------|--.------|------.--|---------|.                \n            |         |  .      |      .  |         |.                \n            |         |  .      |      .  |         |.                \n         8/3|.........|.........|.........|.........|.                \n            |         |  .      |      .  |         |.                \n          3 |---------|--.------|------.--|---------|.                \n\nSo we see the first scaled pixel (0 < x < 4/3 and 0 < y < 4/3) mostly\noverlaps with unscaled source pixel \"A\".  The integration (averaging)\nweights for this scaled pixel are:\n\n\t\t\tA\t 1\n\t\t\tB\t1/3\n\t\t\tC\t1/3\n\t\t\tD\t1/9\n\n *\n * The Red, Green, and Blue color values must be averaged over separately\n * otherwise you can get a complete mess (except in solid regions),\n * because high order bits are averaged differently from the low order bits.\n *\n * So the algorithm is roughly:\n *\n *   - Given as input a rectangle in the unscaled source fb with changes,\n *     find the rectangle of pixels this affects in the scaled destination fb.\n *\n *   - For each of the affected scaled (dest) pixels, determine all of the\n *     unscaled (source) pixels it overlaps with.\n *  \n *   - Average those unscaled source values together, weighted by the area\n *     overlap with the destination pixel.  Average R, G, B separately.\n *\n *   - Take this average value and convert to a valid pixel value if\n *     necessary (e.g. rounding, shifting), and then insert it into the\n *     destination framebuffer as the pixel value.\n *\n *   - On to the next destination pixel...\n *\n * ========================================================================\n *\n * For expanding, e.g. -scale 1.1 (which we don't think people will do\n * very often... or at least so we hope, the framebuffer can become huge)\n * the situation is reversed and the destination pixel is smaller than a\n * \"graph paper\" unit square (source pixel).  Some destination pixels\n * will be completely within a single unscaled source pixel.\n *\n * What we do here is a simple 4 point interpolation scheme:\n * \n * Let P00 be the source pixel closest to the destination pixel but with\n * x and y values less than or equal to those of the destination pixel.\n * (for simplicity, think of the upper left corner of a pixel defining the\n * x,y location of the pixel, the center would work just as well).  So it\n * is the source pixel immediately to the upper left of the destination\n * pixel.  Let P10 be the source pixel one to the right of P00.  Let P01\n * be one down from P00.  And let P11 be one down and one to the right\n * of P00.  They form a 2x2 square we will interpolate inside of.\n * \n * Let V00, V10, V01, and V11 be the color values of those 4 source\n * pixels.  Let dx be the displacement along x the destination pixel is\n * from P00.  Note: 0 <= dx < 1 by definition of P00.  Similarly let\n * dy be the displacement along y.  The weighted average for the\n * interpolation is:\n * \n * \tV_ave = V00 * (1 - dx) * (1 - dy)\n * \t      + V10 *      dx  * (1 - dy)\n * \t      + V01 * (1 - dx) *      dy\n * \t      + V11 *      dx  *      dy\n * \n * Note that the weights (1-dx)*(1-dy) + dx*(1-dy) + (1-dx)*dy + dx*dy\n * automatically add up to 1.  It is also nice that all the weights are\n * positive (unsigned char stays unsigned char).  The above formula can\n * be motivated by doing two 1D interpolations along x:\n * \n * \tVA = V00 * (1 - dx) + V10 * dx\n * \tVB = V01 * (1 - dx) + V11 * dx\n * \n * and then interpolating VA and VB along y:\n * \n * \tV_ave = VA * (1 - dy) + VB * dy\n * \n *                      VA \n *           v   |<-dx->|\n *           -- V00 ------ V10\n *           dy  |          |  \n *           --  |      o...|...    \"o\" denotes the position of the desired\n *           ^   |      .   |  .    destination pixel relative to the P00\n *               |      .   |  .    source pixel.\n *              V10 ----.- V11 .\n *                      ........\n *                      |  \n *                      VB \n *\n * \n * Of course R, G, B averages are done separately as in the shrinking\n * case.  This gives reasonable results, and the implementation for\n * shrinking can simply be used with different choices for weights for\n * the loop over the 4 pixels.\n */\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}\n\n/*\n Framebuffers data flow:\n                                                                             \n General case:\n                --------       --------       --------        --------    \n    -----      |8to24_fb|     |main_fb |     |snap_fb |      | X      |    \n   |rfbfb| <== |        | <== |        | <== |        | <==  | Server |    \n    -----       --------       --------       --------        --------    \n   (to vnc)    (optional)    (usu = rfbfb)   (optional)      (read only)   \n\n 8to24_fb mode will create side fbs: poll24_fb and poll8_fb for\n bookkeepping the different regions (merged into 8to24_fb).\n\n Normal case:\n    --------        --------    \n   |main_fb |      | X      |    \n   |= rfb_fb| <==  | Server |    \n    --------        --------    \n                                                                             \n Scaling case:\n                --------        --------    \n    -----      |main_fb |      | X      |    \n   |rfbfb| <== |        | <==  | Server |    \n    -----       --------        --------    \n\n Webcam/video case:\n    --------        --------        --------    \n   |main_fb |      |snap_fb |      | Video  |    \n   |        | <==  |        | <==  | device |    \n    --------        --------        --------    \n\nIf we ever do a -rr rotation/reflection tran, it probably should \nbe done after any scaling (need a rr_fb for intermediate results)\n\n-rr option:\t\ttransformation:\n\n\tnone\t\tx -> x;\n\t\t\ty -> y;\n\n\tx\t\tx -> w - x - 1;\n\t\t\ty -> y;\n\n\ty\t\tx -> x;\n\t\t\tx -> h - y - 1;\n\n\txy\t\tx -> w - x - 1;\n\t\t\ty -> h - y - 1;\n\n\t+90\t\tx -> h - y - 1;\n\t\t\ty -> x;\n\n\t+90x\t\tx -> y;\n\t\t\ty -> x;\n\n\t+90y\t\tx -> h - y - 1;\n\t\t\ty -> w - x - 1;\n\n\t-90\t\tx -> y;\n\t\t\ty -> w - x - 1;\n\nsome aliases:\n\n\txy:\tyx, +180, -180, 180\n\t+90:\t90\n\t+90x:\t90x\n\t+90y:\t90y\n\t-90:\t+270, 270\n */\n\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\n\t/* ncache?? */\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t}\n}\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}\n\n\t/* unroll the Bpp loop to be used in each case: */\n#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}\n\nvoid rotate_fb(int x1, int y1, int x2, int y2) {\n\tint x, y, xn, yn, r_x1, r_y1, r_x2, r_y2, Bpp = bpp/8;\n\tint fbl = rfb_bytes_per_line;\n\tint rbl = rot_bytes_per_line;\n\tint Dx, Dy;\n\tchar *src, *dst;\n\tchar *src_0 = rfb_fb;\n\tchar *dst_0 = rot_fb;\n\n\tif (! rotating || ! rot_fb) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\n\tdst = rot_fb;\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = y1; y < y2; y++)  {\n\t\t\tfor (x = x1; x < x2; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mark_wrapper(int x1, int y1, int x2, int y2) {\n\tint t, r_x1 = x1, r_y1 = y1, r_x2 = x2, r_y2 = y2;\n\n\tif (rotating) {\n\t\t/* well we hope rot_fb will always be the last one... */\n\t\trotate_coords(x1, y1, &r_x1, &r_y1, -1, -1);\n\t\trotate_coords(x2, y2, &r_x2, &r_y2, -1, -1);\n\t\trotate_fb(x1, y1, x2, y2);\n\t\tif (r_x1 > r_x2) {\n\t\t\tt = r_x1;\n\t\t\tr_x1 = r_x2;\n\t\t\tr_x2 = t;\n\t\t}\n\t\tif (r_y1 > r_y2) {\n\t\t\tt = r_y1;\n\t\t\tr_y1 = r_y2;\n\t\t\tr_y2 = t;\n\t\t}\n\t\t/* painting errors  */\n\t\tr_x1--;\n\t\tr_x2++;\n\t\tr_y1--;\n\t\tr_y2++;\n\t}\n\trfbMarkRectAsModified(screen, r_x1, r_y1, r_x2, r_y2);\n}\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}\n\n/*\n * Notifies libvncserver of a changed hint rectangle.\n */\nstatic void mark_hint(hint_t hint) {\n\tint x = hint.x;\t\n\tint y = hint.y;\t\n\tint w = hint.w;\t\n\tint h = hint.h;\t\n\n\tmark_rect_as_modified(x, y, x + w, y + h, 0);\n}\n\n/*\n * copy_tiles() gives a slight improvement over copy_tile() since\n * adjacent runs of tiles are done all at once there is some savings\n * due to contiguous memory access.  Not a great speedup, but in some\n * cases it can be up to 2X.  Even more on a SunRay or ShadowFB where\n * no graphics hardware is involved in the read.  Generally, graphics\n * devices are optimized for write, not read, so we are limited by the\n * read bandwidth, sometimes only 5 MB/sec on otherwise fast hardware.\n */\nstatic int *first_line = NULL, *last_line = NULL;\nstatic unsigned short *left_diff = NULL, *right_diff = NULL;\n\nstatic int copy_tiles(int tx, int ty, int nt) {\n\tint x, y, line;\n\tint size_x, size_y, width1, width2;\n\tint off, len, n, dw, dx, t;\n\tint w1, w2, dx1, dx2;\t/* tmps for normal and short tiles */\n\tint pixelsize = bpp/8;\n\tint first_min, last_max;\n\tint first_x = -1, last_x = -1;\n\tstatic int prev_ntiles_x = -1;\n\n\tchar *src, *dst, *s_src, *s_dst, *m_src, *m_dst;\n\tchar *h_src, *h_dst;\n\tif (unixpw_in_progress) return 0;\n\n\tif (ntiles_x != prev_ntiles_x && first_line != NULL) {\n\t\tfree(first_line);\tfirst_line = NULL;\n\t\tfree(last_line);\tlast_line = NULL;\n\t\tfree(left_diff);\tleft_diff = NULL;\n\t\tfree(right_diff);\tright_diff = NULL;\n\t}\n\n\tif (first_line == NULL) {\n\t\t/* allocate arrays first time in. */\n\t\tint n = ntiles_x + 1;\n\t\trfbLog(\"copy_tiles: allocating first_line at size %d\\n\", n);\n\t\tfirst_line = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tlast_line  = (int *) malloc((size_t) (n * sizeof(int)));\n\t\tleft_diff  = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t\tright_diff = (unsigned short *)\n\t\t\tmalloc((size_t) (n * sizeof(unsigned short)));\n\t}\n\tprev_ntiles_x = ntiles_x;\n\n\tx = tx * tile_x;\n\ty = ty * tile_y;\n\n\tsize_x = dpy_x - x;\n\tif ( size_x > tile_x * nt ) {\n\t\tsize_x = tile_x * nt;\n\t\twidth1 = tile_x;\n\t\twidth2 = tile_x;\n\t} else {\n\t\t/* short tile */\n\t\twidth1 = tile_x;\t/* internal tile */\n\t\twidth2 = size_x - (nt - 1) * tile_x;\t/* right hand tile */\n\t}\n\n\tsize_y = dpy_y - y;\n\tif ( size_y > tile_y ) {\n\t\tsize_y = tile_y;\n\t}\n\n\tn = tx + ty * ntiles_x;\t\t/* number of the first tile */\n\n\tif (blackouts && tile_blackout[n].cover == 2) {\n\t\t/*\n\t\t * If there are blackouts and this tile is completely covered\n\t\t * no need to poll screen or do anything else..\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\ttile_has_diff[n] = 0;\n\t\treturn(0);\n\t}\n\n\tX_LOCK;\n\tXRANDR_SET_TRAP_RET(-1, \"copy_tile-set\");\n\t/* read in the whole tile run at once: */\n\tcopy_image(tile_row[nt], x, y, size_x, size_y);\n\tXRANDR_CHK_TRAP_RET(-1, \"copy_tile-chk\");\n\n\n\tX_UNLOCK;\n\n\tif (blackouts && tile_blackout[n].cover == 1) {\n\t\t/*\n\t\t * If there are blackouts and this tile is partially covered\n\t\t * we should re-black-out the portion.\n\t\t * n.b. we are in single copy_tile mode: nt=1\n\t\t */\n\t\tint x1, x2, y1, y2, b;\n\t\tint w, s, fill = 0;\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\tchar *b_dst = tile_row[nt]->data;\n\t\t\t\n\t\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\t\ty1 = tile_blackout[n].bo[b].y1 - y;\n\t\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\t\t\ty2 = tile_blackout[n].bo[b].y2 - y;\n\n\t\t\tw = (x2 - x1) * pixelsize;\n\t\t\ts = x1 * pixelsize;\n\n\t\t\tfor (line = 0; line < size_y; line++) {\n\t\t\t\tif (y1 <= line && line < y2) {\n\t\t\t\t\tmemset(b_dst + s, fill, (size_t) w);\n\t\t\t\t}\n\t\t\t\tb_dst += tile_row[nt]->bytes_per_line;\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc = tile_row[nt]->data;\n\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\ts_src = src;\n\ts_dst = dst;\n\n\tfor (t=1; t <= nt; t++) {\n\t\tfirst_line[t] = -1;\n\t}\n\n\t/* find the first line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach horizontal tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\t\n\t\t\tif (memcmp(s_dst + off, s_src + off, len)) {\n\t\t\t\tfirst_line[t] = line;\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* see if there were any differences for any tile: */\n\tfirst_min = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\ttile_tried[n+(t-1)] = 1;\n\t\tif (first_line[t] != -1) {\n\t\t\tif (first_min == -1 || first_line[t] < first_min) {\n\t\t\t\tfirst_min = first_line[t];\n\t\t\t}\n\t\t}\n\t}\n\tif (first_min == -1) {\n\t\t/* no tile has a difference, note this and get out: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t}\n\t\treturn(0);\n\t} else {\n\t\t/*\n\t\t * at least one tile has a difference.  make sure info\n\t\t * is recorded (e.g. sometimes we guess tiles and they\n\t\t * came in with tile_has_diff 0)\n\t\t */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\ttile_has_diff[n+(t-1)] = 0;\n\t\t\t} else {\n\t\t\t\ttile_has_diff[n+(t-1)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tm_src = src + (tile_row[nt]->bytes_per_line * size_y);\n\tm_dst = dst + (main_bytes_per_line * size_y);\n\n\tfor (t=1; t <= nt; t++) {\n\t\tlast_line[t] = first_line[t];\n\t}\n\n\t/* find the last line with difference: */\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\t/* foreach line: */\n\tfor (line = size_y - 1; line > first_min; line--) {\n\n\t\tm_src -= tile_row[nt]->bytes_per_line;\n\t\tm_dst -= main_bytes_per_line;\n\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1\n\t\t\t    || last_line[t] != first_line[t]) {\n\t\t\t\t/* tile has no changes or already done */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tlen = w2;\t/* possible short tile */\n\t\t\t} else {\n\t\t\t\tlen = w1;\n\t\t\t}\n\t\t\tif (memcmp(m_dst + off, m_src + off, len)) {\n\t\t\t\tlast_line[t] = line;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * determine the farthest down last changed line\n\t * will be used below to limit our memcpy() to the framebuffer.\n\t */\n\tlast_max = -1;\n\tfor (t=1; t <= nt; t++) {\n\t\tif (first_line[t] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_max == -1 || last_line[t] > last_max) {\n\t\t\tlast_max = last_line[t];\n\t\t}\n\t}\n\n\t/* look for differences on left and right hand edges: */\n\tfor (t=1; t <= nt; t++) {\n\t\tleft_diff[t] = 0;\n\t\tright_diff[t] = 0;\n\t}\n\n\th_src = src;\n\th_dst = dst;\n\n\tw1 = width1 * pixelsize;\n\tw2 = width2 * pixelsize;\n\n\tdx1 = (width1 - tile_fuzz) * pixelsize;\n\tdx2 = (width2 - tile_fuzz) * pixelsize;\n\tdw = tile_fuzz * pixelsize; \n\n\t/* foreach line: */\n\tfor (line = 0; line < size_y; line++) {\n\t\t/* foreach tile: */\n\t\tfor (t=1; t <= nt; t++) {\n\t\t\tif (first_line[t] == -1) {\n\t\t\t\t/* tile has no changes at all */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toff = (t-1) * w1;\n\t\t\tif (t == nt) {\n\t\t\t\tdx = dx2;\t/* possible short tile */\n\t\t\t\tif (dx <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = dx1;\n\t\t\t}\n\n\t\t\tif (! left_diff[t] && memcmp(h_dst + off,\n\t\t\t    h_src + off, dw)) {\n\t\t\t\tleft_diff[t] = 1;\n\t\t\t}\n\t\t\tif (! right_diff[t] && memcmp(h_dst + off + dx,\n\t\t\t    h_src + off + dx, dw) ) {\n\t\t\t\tright_diff[t] = 1;\n\t\t\t}\n\t\t}\n\t\th_src += tile_row[nt]->bytes_per_line;\n\t\th_dst += main_bytes_per_line;\n\t}\n\n\t/* now finally copy the difference to the rfb framebuffer: */\n\ts_src = src + tile_row[nt]->bytes_per_line * first_min;\n\ts_dst = dst + main_bytes_per_line * first_min;\n\n\tfor (line = first_min; line <= last_max; line++) {\n\t\t/* for I/O speed we do not do this tile by tile */\n\t\tmemcpy(s_dst, s_src, size_x * pixelsize);\n\t\tif (nt == 1) {\n\t\t\t/*\n\t\t\t * optimization for tall skinny lines, e.g. wm\n\t\t\t * frame. try to find first_x and last_x to limit\n\t\t\t * the size of the hint.  could help for a slow\n\t\t\t * link.  Unfortunately we spent a lot of time\n\t\t\t * reading in the many tiles.\n\t\t\t *\n\t\t\t * BTW, we like to think the above memcpy leaves\n\t\t\t * the data we use below in the cache... (but\n\t\t\t * it could be two 128 byte segments at 32bpp)\n\t\t\t * so this inner loop is not as bad as it seems.\n\t\t\t */\n\t\t\tint k, kx;\n\t\t\tkx = pixelsize;\n\t\t\tfor (k=0; k<size_x; k++) {\n\t\t\t\tif (memcmp(s_dst + k*kx, s_src + k*kx, kx))  {\n\t\t\t\t\tif (first_x == -1 || k < first_x) {\n\t\t\t\t\t\tfirst_x = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (last_x == -1 || k > last_x) {\n\t\t\t\t\t\tlast_x = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts_src += tile_row[nt]->bytes_per_line;\n\t\ts_dst += main_bytes_per_line;\n\t}\n\n\t/* record all the info in the region array for this tile: */\n\tfor (t=1; t <= nt; t++) {\n\t\tint s = t - 1;\n\n\t\tif (first_line[t] == -1) {\n\t\t\t/* tile unchanged */\n\t\t\tcontinue;\n\t\t}\n\t\ttile_region[n+s].first_line = first_line[t];\n\t\ttile_region[n+s].last_line  = last_line[t];\n\n\t\ttile_region[n+s].first_x = first_x;\n\t\ttile_region[n+s].last_x  = last_x;\n\n\t\ttile_region[n+s].top_diff = 0;\n\t\ttile_region[n+s].bot_diff = 0;\n\t\tif ( first_line[t] < tile_fuzz ) {\n\t\t\ttile_region[n+s].top_diff = 1;\n\t\t}\n\t\tif ( last_line[t] > (size_y - 1) - tile_fuzz ) {\n\t\t\ttile_region[n+s].bot_diff = 1;\n\t\t}\n\n\t\ttile_region[n+s].left_diff  = left_diff[t];\n\t\ttile_region[n+s].right_diff = right_diff[t];\n\n\t\ttile_copied[n+s] = 1;\n\t}\n\n\treturn(1);\n}\n\n/*\n * The copy_tile() call in the loop below copies the changed tile into\n * the rfb framebuffer.  Note that copy_tile() sets the tile_region\n * struct to have info about the y-range of the changed region and also\n * whether the tile edges contain diffs (within distance tile_fuzz).\n *\n * We use this tile_region info to try to guess if the downward and right\n * tiles will have diffs.  These tiles will be checked later in the loop\n * (since y+1 > y and x+1 > x).\n *\n * See copy_tiles_backward_pass() for analogous checking upward and\n * left tiles.\n */\nstatic int copy_all_tiles(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tct = copy_tiles(x, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\t/*\n\t\t\t\t * n.b. copy_tiles() may have detected\n\t\t\t\t * no change and reset tile_has_diff to 0.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiffs++;\n\n\t\t\t/* neighboring tile downward: */\n\t\t\tif ( (y+1) < ntiles_y && tile_region[n].bot_diff) {\n\t\t\t\tm = x + (y+1) * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* neighboring tile to right: */\n\t\t\tif ( (x+1) < ntiles_x && tile_region[n].right_diff) {\n\t\t\t\tm = (x+1) + y * ntiles_x;\n\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn diffs;\n}\n\n/*\n * Routine analogous to copy_all_tiles() above, but for horizontal runs\n * of adjacent changed tiles.\n */\nstatic int copy_all_tile_runs(void) {\n\tint x, y, n, m, i;\n\tint diffs = 0, ct;\n\tint in_run = 0, run = 0;\n\tint ntave = 0, ntcnt = 0;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x + 1; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (x != ntiles_x && tile_has_diff[n]) {\n\t\t\t\tin_run = 1;\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tif (! in_run) {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tct = copy_tiles(x - run, y, run);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\n\t\t\t\tntcnt++;\n\t\t\t\tntave += run;\n\t\t\t\tdiffs += run;\n\n\t\t\t\t/* neighboring tile downward: */\n\t\t\t\tfor (i=1; i <= run; i++) {\n\t\t\t\t\tif ((y+1) < ntiles_y\n\t\t\t\t\t    && tile_region[n-i].bot_diff) {\n\t\t\t\t\t\tm = (x-i) + (y+1) * ntiles_x;\n\t\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* neighboring tile to right: */\n\t\t\t\tif (((x-1)+1) < ntiles_x\n\t\t\t\t    && tile_region[n-1].right_diff) {\n\t\t\t\t\tm = ((x-1)+1) + y * ntiles_x;\n\t\t\t\t\tif (! tile_has_diff[m]) {\n\t\t\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/* note that this starts a new run */\n\t\t\t\t\tin_run = 1;\n\t\t\t\t\trun = 1;\n\t\t\t\t} else {\n\t\t\t\t\tin_run = 0;\n\t\t\t\t\trun = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Could some activity go here, to emulate threaded\n\t\t * behavior by servicing some libvncserver tasks?\n\t\t */\n\t}\n\treturn diffs;\n}\n\n/*\n * Here starts a bunch of heuristics to guess/detect changed tiles.\n * They are:\n *   copy_tiles_backward_pass, fill_tile_gaps/gap_try, grow_islands/island_try\n */\n\n/*\n * Try to predict whether the upward and/or leftward tile has been modified.\n * copy_all_tiles() has already done downward and rightward tiles.\n */\nstatic int copy_tiles_backward_pass(void) {\n\tint x, y, n, m;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y = ntiles_y - 1; y >= 0; y--) {\n\t    for (x = ntiles_x - 1; x >= 0; x--) {\n\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\tif (! tile_has_diff[n]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = x + (y-1) * ntiles_x;\t/* neighboring tile upward */\n\n\t\tif (y >= 1 && ! tile_has_diff[m] && tile_region[n].top_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x, y-1, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\n\t\tm = (x-1) + y * ntiles_x;\t/* neighboring tile to left */\n\n\t\tif (x >= 1 && ! tile_has_diff[m] && tile_region[n].left_diff) {\n\t\t\tif (! tile_tried[m]) {\n\t\t\t\ttile_has_diff[m] = 2;\n\t\t\t\tct = copy_tiles(x-1, y, 1);\n\t\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\nstatic int copy_tiles_additional_pass(void) {\n\tint x, y, n;\n\tint diffs = 0, ct;\n\n\tif (unixpw_in_progress) return 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\t\t/* number of this tile */\n\n\t\t\tif (! tile_has_diff[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_copied[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tct = copy_tiles(x, y, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x) {\n\tint n, m, i, xt, yt, ct;\n\n\tn = x + y * ntiles_x;\n\n\tif (! tile_has_diff[n]) {\n\t\tif (*saw) {\n\t\t\t(*run)++;\t/* extend the gap run. */\n\t\t}\n\t\treturn 0;\n\t}\n\tif (! *saw || *run == 0 || *run > gaps_fill) {\n\t\t*run = 0;\t\t/* unacceptable run. */\n\t\t*saw = 1;\n\t\treturn 0;\n\t}\n\n\tfor (i=1; i <= *run; i++) {\t/* iterate thru the run. */\n\t\tif (along_x) {\n\t\t\txt = x - i;\n\t\t\tyt = y;\n\t\t} else {\n\t\t\txt = x;\n\t\t\tyt = y - i;\n\t\t}\n\n\t\tm = xt + yt * ntiles_x;\n\t\tif (tile_tried[m]) {\t/* do not repeat tiles */\n\t\t\tcontinue;\n\t\t}\n\n\t\tct = copy_tiles(xt, yt, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\t*run = 0;\n\t*saw = 1;\n\treturn 1;\n}\n\n/*\n * Look for small gaps of unchanged tiles that may actually contain changes.\n * E.g. when paging up and down in a web broswer or terminal there can\n * be a distracting delayed filling in of such gaps.  gaps_fill is the\n * tweak parameter that sets the width of the gaps that are checked.\n *\n * BTW, grow_islands() is actually pretty successful at doing this too...\n */\nstatic int fill_tile_gaps(void) {\n\tint x, y, run, saw;\n\tint n, diffs = 0, ct;\n\n\t/* horizontal: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 1);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\t/* vertical: */\n\tfor (x=0; x < ntiles_x; x++) {\n\t\trun = 0;\n\t\tsaw = 0;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tct = gap_try(x, y, &run, &saw, 0);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\nstatic int island_try(int x, int y, int u, int v, int *run) {\n\tint n, m, ct;\n\n\tn = x + y * ntiles_x;\n\tm = u + v * ntiles_x;\n\n\tif (tile_has_diff[n]) {\n\t\t(*run)++;\n\t} else {\n\t\t*run = 0;\n\t}\n\n\tif (tile_has_diff[n] && ! tile_has_diff[m]) {\n\t\t/* found a discontinuity */\n\n\t\tif (tile_tried[m]) {\n\t\t\treturn 0;\n\t\t} else if (*run < grow_fill) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tct = copy_tiles(u, v, 1);\n\t\tif (ct < 0) return ct;\t/* fatal */\n\t}\n\treturn 1;\n}\n\n/*\n * Scan looking for discontinuities in tile_has_diff[].  Try to extend\n * the boundary of the discontinuity (i.e. make the island larger).\n * Vertical scans are skipped since they do not seem to yield much...\n */\nstatic int grow_islands(void) {\n\tint x, y, n, run;\n\tint diffs = 0, ct;\n\n\t/*\n\t * n.b. the way we scan here should keep an extension going,\n\t * and so also fill in gaps effectively...\n\t */\n\n\t/* left to right: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x=0; x <= ntiles_x - 2; x++) {\n\t\t\tct = island_try(x, y, x+1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\t/* right to left: */\n\tfor (y=0; y < ntiles_y; y++) {\n\t\trun = 0;\n\t\tfor (x = ntiles_x - 1; x >= 1; x--) {\n\t\t\tct = island_try(x, y, x-1, y, &run);\n\t\t\tif (ct < 0) return ct;\t/* fatal */\n\t\t}\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tif (tile_has_diff[n]) {\n\t\t\tdiffs++;\n\t\t}\n\t}\n\treturn diffs;\n}\n\n/*\n * Fill the framebuffer with zeros for each blackout region\n */\nstatic void blackout_regions(void) {\n\tint i;\n\tfor (i=0; i < blackouts; i++) {\n\t\tzero_fb(blackr[i].x1, blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t}\n}\n\n/*\n * copy the whole X screen to the rfb framebuffer.  For a large enough\n * number of changed tiles, this is faster than tiles scheme at retrieving\n * the info from the X server.  Bandwidth to client and compression time\n * are other issues...  use -fs 1.0 to disable.\n */\nint copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}\n\n#include <default8x16.h>\n\n/*\n * Color values from the vcsadump program.\n * void dumpcss(FILE *fp, char *attribs_used)\n * char *colormap[] = {\n *    \"#000000\", \"#0000AA\", \"#00AA00\", \"#00AAAA\", \"#AA0000\", \"#AA00AA\", \"#AA5500\", \"#AAAAAA\",\n *    \"#555555\", \"#5555AA\", \"#55FF55\", \"#55FFFF\", \"#FF5555\", \"#FF55FF\", \"#FFFF00\", \"#FFFFFF\" };\n */\n\nstatic unsigned char console_cmap[16*3]={\n/*  0 */\t0x00, 0x00, 0x00,\n/*  1 */\t0x00, 0x00, 0xAA,\n/*  2 */\t0x00, 0xAA, 0x00,\n/*  3 */\t0x00, 0xAA, 0xAA,\n/*  4 */\t0xAA, 0x00, 0x00,\n/*  5 */\t0xAA, 0x00, 0xAA,\n/*  6 */\t0xAA, 0x55, 0x00,\n/*  7 */\t0xAA, 0xAA, 0xAA,\n/*  8 */\t0x55, 0x55, 0x55,\n/*  9 */\t0x55, 0x55, 0xAA,\n/* 10 */\t0x55, 0xFF, 0x55,\n/* 11 */\t0x55, 0xFF, 0xFF,\n/* 12 */\t0xFF, 0x55, 0x55,\n/* 13 */\t0xFF, 0x55, 0xFF,\n/* 14 */\t0xFF, 0xFF, 0x00,\n/* 15 */\t0xFF, 0xFF, 0xFF\n};\n  \nstatic void snap_vcsa_rawfb(void) {\n\tint n;\n\tchar *dst;\n\tchar buf[32];\n\tint i, len, del;\n\tunsigned char rows, cols, xpos, ypos;\n\tstatic int prev_rows = -1, prev_cols = -1;\n\tstatic unsigned char prev_xpos = -1, prev_ypos = -1;\n\tstatic char *vcsabuf  = NULL;\n\tstatic char *vcsabuf0 = NULL;\n\tstatic unsigned int color_tab[16];\n\tstatic int Cw = 8, Ch = 16;\n\tstatic int db = -1, first = 1;\n\tint created = 0;\n\trfbScreenInfo s;\n\trfbScreenInfoPtr fake_screen = &s;\n\tint Bpp = raw_fb_native_bpp / 8;\n\n\tif (db < 0) {\n\t\tif (getenv(\"X11VNC_DEBUG_VCSA\")) {\n\t\t\tdb = atoi(getenv(\"X11VNC_DEBUG_VCSA\"));\n\t\t} else {\n\t\t\tdb = 0;\n\t\t}\n\t}\n\n\tif (first) {\n\t\tunsigned int rm = raw_fb_native_red_mask;\n\t\tunsigned int gm = raw_fb_native_green_mask;\n\t\tunsigned int bm = raw_fb_native_blue_mask;\n\t\tunsigned int rs = raw_fb_native_red_shift;\n\t\tunsigned int gs = raw_fb_native_green_shift;\n\t\tunsigned int bs = raw_fb_native_blue_shift;\n\t\tunsigned int rx = raw_fb_native_red_max;\n\t\tunsigned int gx = raw_fb_native_green_max;\n\t\tunsigned int bx = raw_fb_native_blue_max;\n\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tint r = console_cmap[3*i+0];\n\t\t\tint g = console_cmap[3*i+1];\n\t\t\tint b = console_cmap[3*i+2];\n\t\t\tr = rx * r / 255;\n\t\t\tg = gx * g / 255;\n\t\t\tb = bx * b / 255;\n\t\t\tcolor_tab[i] = (r << rs) | (g << gs) | (b << bs);\n\t\t\tif (db) fprintf(stderr, \"cmap[%02d] 0x%08x  %04d %04d %04d\\n\", i, color_tab[i], r, g, b); \n\t\t\tif (i != 0 && getenv(\"RAWFB_VCSA_BW\")) {\n\t\t\t\tcolor_tab[i] = rm | gm | bm;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\tlseek(raw_fb_fd, 0, SEEK_SET);\n\tlen = 4;\n\tdel = 0;\n\tmemset(buf, 0, sizeof(buf));\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, buf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trows = (unsigned char) buf[0];\n\tcols = (unsigned char) buf[1];\n\txpos = (unsigned char) buf[2];\n\typos = (unsigned char) buf[3];\n\n\tif (db) fprintf(stderr, \"rows=%d cols=%d xpos=%d ypos=%d Bpp=%d\\n\", rows, cols, xpos, ypos, Bpp);\n\tif (rows == 0 || cols == 0) {\n\t\tusleep(100 * 1000);\n\t\treturn;\n\t}\n\n\tif (vcsabuf == NULL || prev_rows != rows || prev_cols != cols) {\n\t\tif (vcsabuf) {\n\t\t\tfree(vcsabuf);\n\t\t\tfree(vcsabuf0);\n\t\t}\n\t\tvcsabuf  = (char *) calloc(2 * rows * cols, 1);\n\t\tvcsabuf0 = (char *) calloc(2 * rows * cols, 1);\n\t\tcreated = 1;\n\n\t\tif (prev_rows != -1 && prev_cols != -1) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tprev_rows = rows;\n\t\tprev_cols = cols;\n\t}\n\n\tif (!rfbEndianTest) {\n\t\tunsigned char tc = rows;\n\t\trows = cols;\n\t\tcols = tc;\n\n\t\ttc = xpos;\n\t\txpos = ypos;\n\t\typos = tc;\n\t}\n\n\tlen = 2 * rows * cols;\n\tdel = 0;\n\tmemset(vcsabuf, 0, len);\n\twhile (len > 0) {\n\t\tn = read(raw_fb_fd, vcsabuf + del, len);\n\t\tif (n > 0) {\n\t\t\tdel += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tbreak;\n\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_screen->frameBuffer = snap->data;\n\tfake_screen->paddedWidthInBytes = snap->bytes_per_line;\n\tfake_screen->serverFormat.bitsPerPixel = raw_fb_native_bpp;\n\tfake_screen->width = snap->width;\n\tfake_screen->height = snap->height;\n\n\tfor (i=0; i < rows * cols; i++) {\n\t\tint ix, iy, x, y, w, h;\n\t\tunsigned char chr = 0;\n\t\tunsigned char attr;\n\t\tunsigned int fore, back;\n\t\tunsigned short *usp;\n\t\tunsigned int *uip;\n\t\tchr  = (unsigned char) vcsabuf[2*i];\n\t\tattr = vcsabuf[2*i+1];\n\n\t\tiy = i / cols;\n\t\tix = i - iy * cols;\n\n\t\tif (ix == prev_xpos && iy == prev_ypos) {\n\t\t\t;\n\t\t} else if (ix == xpos && iy == ypos) {\n\t\t\t;\n\t\t} else if (!created && chr == vcsabuf0[2*i] && attr == vcsabuf0[2*i+1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rfbEndianTest) {\n\t\t\tunsigned char tc = chr;\n\t\t\tchr = attr;\n\t\t\tattr = tc;\n\t\t}\n\n\t\ty = iy * Ch;\n\t\tx = ix * Cw;\n\t\tdst = snap->data + y * snap->bytes_per_line + x * Bpp;\n\n\t\tfore = color_tab[attr & 0xf];\n\t\tback = color_tab[(attr >> 4) & 0x7];\n\n\t\tif (ix == xpos && iy == ypos) {\n\t\t\tunsigned int ti = fore;\n\t\t\tfore = back;\n\t\t\tback = ti;\n\t\t}\n\n\t\tfor (h = 0; h < Ch; h++) {\n\t\t\tif (Bpp == 1) {\n\t\t\t\tmemset(dst, back, Cw);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tusp = (unsigned short *) (dst + w*Bpp); \n\t\t\t\t\t*usp = (unsigned short) back;\n\t\t\t\t}\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\tfor (w = 0; w < Cw; w++) {\n\t\t\t\t\tuip = (unsigned int *) (dst + w*Bpp); \n\t\t\t\t\t*uip = (unsigned int) back;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t\trfbDrawChar(fake_screen, &default8x16Font, x, y + Ch, chr, fore);\n\t}\n\tmemcpy(vcsabuf0, vcsabuf, 2 * rows * cols); \n\tprev_xpos = xpos;\n\tprev_ypos = ypos;\n}\n\nstatic void snap_all_rawfb(void) {\n\tint pixelsize = bpp/8;\n\tint n, sz;\n\tchar *dst;\n\tstatic char *unclipped_dst = NULL;\n\tstatic int unclipped_len = 0;\n\n\tdst = snap->data;\n\n\tif (xform24to32 && bpp == 32) {\n\t\tpixelsize = 3;\n\t}\n\tsz = dpy_y * snap->bytes_per_line;\n\n\tif (wdpy_x > dpy_x || wdpy_y > dpy_y) {\n\t\tsz = wdpy_x * wdpy_y * pixelsize;\n\t\tif (sz > unclipped_len || unclipped_dst == NULL) {\n\t\t\tif (unclipped_dst) {\n\t\t\t\tfree(unclipped_dst);\n\t\t\t}\n\t\t\tunclipped_dst = (char *) malloc(sz+4);\n\t\t\tunclipped_len = sz;\n\t\t}\n\t\tdst = unclipped_dst;\n\t}\n\t\t\n\tif (! raw_fb_seek) {\n\t\tmemcpy(dst, raw_fb_addr + raw_fb_offset, sz);\n\n\t} else {\n\t\tint len = sz, del = 0;\n\t\toff_t off = (off_t) raw_fb_offset;\n\n\t\tlseek(raw_fb_fd, off, SEEK_SET);\n\t\twhile (len > 0) {\n\t\t\tn = read(raw_fb_fd, dst + del, len);\n\t\t\tif (n > 0) {\n\t\t\t\tdel += n;\n\t\t\t\tlen -= n;\n\t\t\t} else if (n == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dst == unclipped_dst) {\n\t\tchar *src;\n\t\tint h;\n\t\tint x = off_x + coff_x;\n\t\tint y = off_y + coff_y;\n\n\t\tsrc = unclipped_dst + y * wdpy_x * pixelsize +\n\t\t    x * pixelsize;\n\t\tdst = snap->data;\n\n\t\tfor (h = 0; h < dpy_y; h++) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += wdpy_x * pixelsize;\n\t\t\tdst += snap->bytes_per_line;\n\t\t}\n\t}\n}\n\nint copy_snap(void) {\n\tint db = 1;\n\tchar *fbp;\n\tint i, y, block_size;\n\tdouble dt;\n\tstatic int first = 1, snapcnt = 0;\n\n\tif (raw_fb_str) {\n\t\tint read_all_at_once = 1;\n\t\tdouble start = dnow();\n\t\tif (rawfb_reset < 0) {\n\t\t\tif (getenv(\"SNAPFB_RAWFB_RESET\")) {\n\t\t\t\trawfb_reset = 1;\n\t\t\t} else {\n\t\t\t\trawfb_reset = 0;\n\t\t\t}\n\t\t}\n\t\tif (snap_fb == NULL || snap == NULL) {\n\t\t\trfbLog(\"copy_snap: rawfb mode and null snap fb\\n\"); \n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (rawfb_reset) {\n\t\t\tinitialize_raw_fb(1);\n\t\t}\n\t\tif (raw_fb_bytes_per_line != snap->bytes_per_line) {\n\t\t\tread_all_at_once = 0;\n\t\t}\n\t\tif (raw_fb_full_str && strstr(raw_fb_full_str, \"/dev/vcsa\")) {\n\t\t\tsnap_vcsa_rawfb();\n\t\t} else if (read_all_at_once) {\n\t\t\tsnap_all_rawfb();\n\t\t} else {\n\t\t\t/* this goes line by line, XXX not working for video */\n\t\t\tcopy_raw_fb(snap, 0, 0, dpy_x, dpy_y);\n\t\t}\nif (db && snapcnt++ < 5) rfbLog(\"rawfb copy_snap took: %.5f secs\\n\", dnow() - start);\n\n\t\treturn 0;\n\t}\n\t\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\n\n\tif (! snap_fb || ! snap || ! snaprect) {\n\t\treturn 0;\n\t}\n\tblock_size = ((dpy_y/fs_factor) * snap->bytes_per_line);\n\n\tfbp = snap_fb;\n\ty = 0;\n\n\n\tdtime0(&dt);\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_snap-set\");\n\t\tcopy_image(snaprect, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_snap-chk\");\n\n\t\tmemcpy(fbp, snaprect->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tdt = dtime(&dt);\n\tif (first) {\n\t\trfbLog(\"copy_snap: time for -snapfb snapshot: %.3f sec\\n\", dt);\n\t\tfirst = 0;\n\t}\n\n\treturn 0;\n}\n\n/* STFU: Only for debugging */\n#if 0\n/* \n * debugging: print out a picture of the tiles.\n */\nstatic void print_tiles(void) {\n\t/* hack for viewing tile diffs on the screen. */\n\tstatic char *prev = NULL;\n\tint n, x, y, ms = 1500;\n\n\tms = 1;\n\n\tif (! prev) {\n\t\tprev = (char *) malloc((size_t) ntiles);\n\t\tfor (n=0; n < ntiles; n++) {\n\t\t\tprev[n] = 0;\n\t\t}\n\t}\n\tfprintf(stderr, \"   \");\n\tfor (x=0; x < ntiles_x; x++) {\n\t\tfprintf(stderr, \"%1d\", x % 10);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tn = 0;\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfprintf(stderr, \"%2d \", y);\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tfprintf(stderr, \"X\");\n\t\t\t} else if (prev[n]) {\n\t\t\t\tfprintf(stderr, \"o\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tfor (n=0; n < ntiles; n++) {\n\t\tprev[n] = tile_has_diff[n];\n\t}\n\tusleep(ms * 1000);\n}\n#endif\n\n/*\n * Utilities for managing the \"naps\" to cut down on amount of polling.\n */\nstatic void nap_set(int tile_cnt) {\n\tint nap_in = nap_ok;\n\ttime_t now = time(NULL);\n\n\tif (scan_count == 0) {\n\t\t/* roll up check for all NSCAN scans */\n\t\tnap_ok = 0;\n\t\tif (naptile && nap_diff_count < 2 * NSCAN * naptile) {\n\t\t\t/* \"2\" is a fudge to permit a bit of bg drawing */\n\t\t\tnap_ok = 1;\n\t\t}\n\t\tnap_diff_count = 0;\n\t}\n\tif (nap_ok && ! nap_in && use_xdamage) {\n\t\tif (XD_skip > 0.8 * XD_tot) \t{\n\t\t\t/* X DAMAGE is keeping load low, so skip nap */\n\t\t\tnap_ok = 0;\n\t\t}\n\t}\n\tif (! nap_ok && client_count) {\n\t\tif(now > last_fb_bytes_sent + no_fbu_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_set: nap_ok=1: now: %d last: %d\\n\",\n\t\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t\t}\n\t\t\tnap_ok = 1;\n\t\t}\n\t}\n\n\tif (show_cursor) {\n\t\t/* kludge for the up to 4 tiles the mouse patch could occupy */\n\t\tif ( tile_cnt > 4) {\n\t\t\tlast_event = now;\n\t\t}\n\t} else if (tile_cnt != 0) {\n\t\tlast_event = now;\n\t}\n}\n\n/*\n * split up a long nap to improve the wakeup time\n */\nvoid nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic char *get_load(void) {\n\tstatic char tmp[64];\n\tstatic int count = 0;\n\n\tif (count++ % 5 == 0) {\n\t\tstruct stat sb;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tif (stat(\"/proc/loadavg\", &sb) == 0) {\n\t\t\tint d = open(\"/proc/loadavg\", O_RDONLY);\n\t\t\tif (d >= 0) {\n\t\t\t\tread(d, tmp, 60);\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t}\n\t\tif (tmp[0] == '\\0') {\n\t\t\tstrcat(tmp, \"unknown\");\n\t\t}\n\t}\n\treturn tmp;\n}\n\n/*\n * see if we should take a nap of some sort between polls\n */\nstatic void nap_check(int tile_cnt) {\n\ttime_t now;\n\n\tnap_diff_count += tile_cnt;\n\n\tif (! take_naps) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tif (screen_blank > 0) {\n\t\tint dt_ev, dt_fbu;\n\t\tstatic int ms = 0;\n\t\tif (ms == 0) {\n\t\t\tms = 2000;\n\t\t\tif (getenv(\"X11VNC_SB_FACTOR\")) {\n\t\t\t\tms = ms * atof(getenv(\"X11VNC_SB_FACTOR\"));\n\t\t\t}\n\t\t\tif (ms <= 0) {\n\t\t\t\tms = 2000;\n\t\t\t}\n\t\t}\n\n\t\t/* if no activity, pause here for a second or so. */\n\t\tdt_ev  = (int) (now - last_event);\n\t\tdt_fbu = (int) (now - last_fb_bytes_sent);\n\t\tif (dt_fbu > screen_blank) {\n\t\t\t/* sleep longer for no fb requests */\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep1: %d ms / 16, load: %s\\n\", 2 * ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(2 * ms, 16);\n\t\t\treturn;\n\t\t}\n\t\tif (dt_ev > screen_blank) {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"screen blank sleep2: %d ms / 8, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (naptile && nap_ok && tile_cnt < naptile) {\n\t\tint ms = napfac * waitms;\n\t\tms = ms > napmax ? napmax : ms;\n\t\tif (now - last_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else if (now - last_local_input <= 3) {\n\t\t\tnap_ok = 0;\n\t\t} else {\n\t\t\tif (debug_tiles > 1) {\n\t\t\t\tfprintf(stderr, \"nap_check sleep: %d ms / 1, load: %s\\n\", ms, get_load());\n\t\t\t}\n\t\t\tnap_sleep(ms, 1);\n\t\t}\n\t}\n}\n\n/*\n * This is called to avoid a ~20 second timeout in libvncserver.\n * May no longer be needed.\n */\nstatic void ping_clients(int tile_cnt) {\n\tstatic time_t last_send = 0;\n\ttime_t now = time(NULL);\n\n\tif (rfbMaxClientWait < 20000) {\n\t\trfbMaxClientWait = 20000;\n\t\trfbLog(\"reset rfbMaxClientWait to %d msec.\\n\",\n\t\t    rfbMaxClientWait);\n\t}\n\tif (tile_cnt > 0) {\n\t\tlast_send = now;\n\t} else if (tile_cnt < 0) {\n\t\t/* negative tile_cnt is -ping case */\n\t\tif (now >= last_send - tile_cnt) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlast_send = now;\n\t\t}\n\t} else if (now - last_send > 5) {\n\t\t/* Send small heartbeat to client */\n\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\tlast_send = now;\n\t}\n}\n\n/*\n * scan_display() wants to know if this tile can be skipped due to\n * blackout regions: (no data compare is done, just a quick geometric test)\n */\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count) {\n\t\n\tif (tile_blackout[n].cover == 2) {\n\t\ttile_has_diff[n] = 0;\n\t\treturn 1;\t/* skip it */\n\n\t} else if (tile_blackout[n].cover == 1) {\n\t\tint w, x1, y1, x2, y2, b, hit = 0;\n\t\tif (x + NSCAN > dpy_x) {\n\t\t\tw = dpy_x - x;\n\t\t} else {\n\t\t\tw = NSCAN;\n\t\t}\n\n\t\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\t\n\t\t\t/* n.b. these coords are in full display space: */\n\t\t\tx1 = tile_blackout[n].bo[b].x1;\n\t\t\tx2 = tile_blackout[n].bo[b].x2;\n\t\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t\tif (x2 - x1 < w) {\n\t\t\t\t/* need to cover full width */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y1 <= y && y < y2) {\n\t\t\t\thit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hit) {\n\t\t\tif (! rescan) {\n\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t} else {\n\t\t\t\t*tile_count += tile_has_diff[n];\n\t\t\t}\n\t\t\treturn 1;\t/* skip */\n\t\t}\n\t}\n\treturn 0;\t/* do not skip */\n}\n\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize) {\n\n\tint i, x1, y1, x2, y2, b, hit = 0;\n\tint beg = -1, end = -1; \n\n\tif (tile_blackout[n].cover == 0) {\n\t\treturn 0;\t/* 0 means do not skip it. */\n\t} else if (tile_blackout[n].cover == 2) {\n\t\treturn 1;\t/* 1 means skip it. */\n\t}\n\n\t/* tile has partial coverage: */\n\n\tfor (i=0; i < w * pixelsize; i++)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tbeg = i/pixelsize;\t/* beginning difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = w * pixelsize - 1; i >= 0; i--)  {\n\t\tif (*(dst+i) != *(src+i)) {\n\t\t\tend = i/pixelsize;\t/* ending difference */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (beg < 0 || end < 0) {\n\t\t/* problem finding range... */\n\t\treturn 0;\n\t}\n\n\t/* loop over blackout rectangles: */\n\tfor (b=0; b < tile_blackout[n].count; b++) {\n\t\t\n\t\t/* y in full display space: */\n\t\ty1 = tile_blackout[n].bo[b].y1;\n\t\ty2 = tile_blackout[n].bo[b].y2;\n\n\t\t/* x relative to tile origin: */\n\t\tx1 = tile_blackout[n].bo[b].x1 - x;\n\t\tx2 = tile_blackout[n].bo[b].x2 - x;\n\n\t\tif (y1 > y || y >= y2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 <= beg && end <= x2) {\n\t\t\thit = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (hit) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/*\n * For the subwin case follows the window if it is moved.\n */\nvoid set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}\n\nstatic int xd_samples = 0, xd_misses = 0, xd_do_check = 0;\n\n/*\n * Loop over 1-pixel tall horizontal scanlines looking for changes.  \n * Record the changes in tile_has_diff[].  Scanlines in the loop are\n * equally spaced along y by NSCAN pixels, but have a slightly random\n * starting offset ystart ( < NSCAN ) from scanlines[].\n */\n\nstatic int scan_display(int ystart, int rescan) {\n\tchar *src, *dst;\n\tint pixelsize = bpp/8;\n\tint x, y, w, n;\n\tint tile_count = 0;\n\tint nodiffs = 0, diff_hint;\n\tint xd_check = 0, xd_freq = 1;\n\tstatic int xd_tck = 0;\n\n\ty = ystart;\n\n\tg_now = dnow();\n\n\tif (! main_fb) {\n\t\trfbLog(\"scan_display: no main_fb!\\n\");\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\n\twhile (y < dpy_y) {\n\n\t\tif (use_xdamage) {\n\t\t\tXD_tot++;\n\t\t\txd_check = 0;\n\t\t\tif (xdamage_hint_skip(y)) {\n\t\t\t\tif (xd_do_check && dpy && use_xdamage == 1) {\n\t\t\t\t\txd_tck++;\n\t\t\t\t\txd_tck = xd_tck % xd_freq;\n\t\t\t\t\tif (xd_tck == 0) {\n\t\t\t\t\t\txd_check = 1;\n\t\t\t\t\t\txd_samples++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!xd_check) {\n\t\t\t\t\tXD_skip++;\n\t\t\t\t\ty += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xd_do_check && 0) {\n\t\t\t\t\tfprintf(stderr, \"ns y=%d\\n\", y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* grab the horizontal scanline from the display: */\n\n#ifndef NO_NCACHE\n/* XXX Y test */\nif (ncache > 0) {\n\tint gotone = 0;\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tgotone = 1;\n\t\t}\n\t} else {\n#if !NO_X11\n\t\tXEvent ev;\n\t\tif (raw_fb_str) {\n\t\t\t;\n\t\t} else if (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\t;\t/* XXX Y resp */\n\t\t} else if (XCheckTypedEvent(dpy, MapNotify, &ev)) {\n\t\t\tgotone = 1;\n\t\t} else if (XCheckTypedEvent(dpy, UnmapNotify, &ev)) {\n\t\t\tgotone = 2;\n\t\t} else if (XCheckTypedEvent(dpy, CreateNotify, &ev)) {\n\t\t\tgotone = 3;\n\t\t} else if (XCheckTypedEvent(dpy, ConfigureNotify, &ev)) {\n\t\t\tgotone = 4;\n\t\t} else if (XCheckTypedEvent(dpy, VisibilityNotify, &ev)) {\n\t\t\tgotone = 5;\n\t\t}\n\t\tif (gotone) {\n\t\t\tXPutBackEvent(dpy, &ev);\n\t\t}\n#endif\n\t}\n\tif (gotone) {\n\t\tstatic int nomsg = 1;\n\t\tif (nomsg) {\n\t\t\tif (dnowx() > 20) {\n\t\t\t\tnomsg = 0;\n\t\t\t}\n\t\t} else {\nif (ncdb) fprintf(stderr, \"\\n*** SCAN_DISPLAY CHECK_NCACHE/%d *** %d rescan=%d\\n\", gotone, y, rescan);\n\t\t}\n\t\tX_UNLOCK;\n\t\tcheck_ncache(0, 1);\n\t\tX_LOCK;\n\t}\n}\n#endif\n\n\t\tXRANDR_SET_TRAP_RET(-1, \"scan_display-set\");\n\t\tcopy_image(scanline, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"scan_display-chk\");\n\n\t\t/* for better memory i/o try the whole line at once */\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line;\n\n\t\tif (! memcmp(dst, src, main_bytes_per_line)) {\n\t\t\t/* no changes anywhere in scan line */\n\t\t\tnodiffs = 1;\n\t\t\tif (! rescan) {\n\t\t\t\ty += NSCAN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (xd_check) {\n\t\t\txd_misses++;\n\t\t}\n\n\t\tx = 0;\n\t\twhile (x < dpy_x) {\n\t\t\tn = (x/tile_x) + (y/tile_y) * ntiles_x;\n\t\t\tdiff_hint = 0;\n\n\t\t\tif (blackouts) {\n\t\t\t\tif (blackout_line_skip(n, x, y, rescan,\n\t\t\t\t    &tile_count)) {\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rescan) {\n\t\t\t\tif (nodiffs || tile_has_diff[n]) {\n\t\t\t\t\ttile_count += tile_has_diff[n];\n\t\t\t\t\tx += NSCAN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (xdamage_tile_count &&\n\t\t\t    tile_has_xdamage_diff[n]) {\n\t\t\t\ttile_has_xdamage_diff[n] = 2;\n\t\t\t\tdiff_hint = 1;\n\t\t\t}\n\n\t\t\t/* set ptrs to correspond to the x offset: */\n\t\t\tsrc = scanline->data + x * pixelsize;\n\t\t\tdst = main_fb + y * main_bytes_per_line + x * pixelsize;\n\n\t\t\t/* compute the width of data to be compared: */\n\t\t\tif (x + NSCAN > dpy_x) {\n\t\t\t\tw = dpy_x - x;\n\t\t\t} else {\n\t\t\t\tw = NSCAN;\n\t\t\t}\n\n\t\t\tif (diff_hint || memcmp(dst, src, w * pixelsize)) {\n\t\t\t\t/* found a difference, record it: */\n\t\t\t\tif (! blackouts) {\n\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (blackout_line_cmpskip(n, x, y,\n\t\t\t\t\t    dst, src, w, pixelsize)) {\n\t\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile_has_diff[n] = 1;\n\t\t\t\t\t\ttile_count++;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += NSCAN;\n\t\t}\n\t\ty += NSCAN;\n\t}\n\n\tX_UNLOCK;\n\n\treturn tile_count;\n}\n\n\nint scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};\n\n/*\n * toplevel for the scanning, rescanning, and applying the heuristics.\n * returns number of changed tiles.\n */\nint scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}\n\n\n"], "filenames": ["src/scan.c"], "buggy_code_start_loc": [323], "buggy_code_end_loc": [324], "fixing_code_start_loc": [323], "fixing_code_end_loc": [324], "type": "CWE-732", "message": "scan.c in x11vnc 0.9.16 uses IPC_CREAT|0777 in shmget calls, which allows access by actors other than the current user.", "other": {"cve": {"id": "CVE-2020-29074", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-25T23:15:11.300", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "scan.c in x11vnc 0.9.16 uses IPC_CREAT|0777 in shmget calls, which allows access by actors other than the current user."}, {"lang": "es", "value": "El archivo scan.c en x11vnc versi\u00f3n 0.9.16, usa IPC_CREAT|0777 en llamadas shmget, lo que permite el acceso de actores distintos al usuario actual"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:x11vnc_project:x11vnc:0.9.16:*:*:*:*:*:*:*", "matchCriteriaId": "11DF411F-96A9-4E1C-891E-3D5F272E3DE5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/LibVNC/x11vnc/commit/69eeb9f7baa14ca03b16c9de821f9876def7a36a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/H2FLWSVH32O6JXLRQBYDQLP7XRSTLUPQ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MHVXHZE3YIP4RTWGQ24IDBSW44XPRDOC/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PZL6NQTNK5PT63D2JX5YVV5OLUL76S5C/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4799", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/x11vnc/commit/69eeb9f7baa14ca03b16c9de821f9876def7a36a"}}