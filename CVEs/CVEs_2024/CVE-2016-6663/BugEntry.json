{"buggy_code": ["/* Copyright (c) 2000, 2013, Oracle and/or its affiliates.\n   Copyright (c) 2010, 2013, Monty Program Ab.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n#ifndef _my_sys_h\n#define _my_sys_h\n\n#include \"my_global.h\"                  /* C_MODE_START, C_MODE_END */\n\nC_MODE_START\n\n#ifdef HAVE_AIOWAIT\n#include <sys/asynch.h>\t\t\t/* Used by record-cache */\ntypedef struct my_aio_result {\n  aio_result_t result;\n  int\t       pending;\n} my_aio_result;\n#endif\n\n#include <my_valgrind.h>\n\n#include <my_pthread.h>\n\n#include <m_ctype.h>                    /* for CHARSET_INFO */\n#include <stdarg.h>\n#include <typelib.h>\n#ifdef _WIN32\n#include <malloc.h> /*for alloca*/\n#endif\n#include <mysql/plugin.h>\n\n#define MY_INIT(name)   { my_progname= name; my_init(); }\n\n/**\n  Max length of an error message generated by mysys utilities.\n  Some mysys functions produce error messages. These mostly go\n  to stderr.\n  This constant defines the size of the buffer used to format\n  the message. It should be kept in sync with MYSQL_ERRMSG_SIZE,\n  since sometimes mysys errors are stored in the server diagnostics\n  area, and we would like to avoid unexpected truncation.\n*/\n#define MYSYS_ERRMSG_SIZE   (512)\n\n#define MY_FILE_ERROR\t((size_t) -1)\n\n\t/* General bitmaps for my_func's */\n#define MY_FFNF\t\t1\t/* Fatal if file not found */\n#define MY_FNABP\t2\t/* Fatal if not all bytes read/writen */\n#define MY_NABP\t\t4\t/* Error if not all bytes read/writen */\n#define MY_FAE\t\t8\t/* Fatal if any error */\n#define MY_WME\t\t16\t/* Write message on error */\n#define MY_WAIT_IF_FULL 32\t/* Wait and try again if disk full error */\n#define MY_IGNORE_BADFD 32      /* my_sync: ignore 'bad descriptor' errors */\n#define MY_UNUSED       64      /* Unused (was support for RAID) */\n#define MY_FULL_IO     512      /* For my_read - loop intil I/O is complete */\n#define MY_DONT_CHECK_FILESIZE 128 /* Option to init_io_cache() */\n#define MY_LINK_WARNING 32\t/* my_redel() gives warning if links */\n#define MY_COPYTIME\t64\t/* my_redel() copys time */\n#define MY_DELETE_OLD\t256\t/* my_create_with_symlink() */\n#define MY_RESOLVE_LINK 128\t/* my_realpath(); Only resolve links */\n#define MY_HOLD_ORIGINAL_MODES 128  /* my_copy() holds to file modes */\n#define MY_REDEL_MAKE_BACKUP 256\n#define MY_SEEK_NOT_DONE 32\t/* my_lock may have to do a seek */\n#define MY_SHORT_WAIT\t64\t/* my_lock() don't wait if can't lock */\n#define MY_FORCE_LOCK   128     /* use my_lock() even if disable_locking */\n#define MY_NO_WAIT      256\t/* my_lock() don't wait at all */\n#define MY_ZEROFILL\t32\t/* my_malloc(), fill array with zero */\n#define MY_ALLOW_ZERO_PTR 64\t/* my_realloc() ; zero ptr -> malloc */\n#define MY_FREE_ON_ERROR 128\t/* my_realloc() ; Free old ptr on error */\n#define MY_HOLD_ON_ERROR 256\t/* my_realloc() ; Return old ptr on error */\n#define MY_DONT_OVERWRITE_FILE 2048 /* my_copy: Don't overwrite file */\n#define MY_THREADSAFE 2048      /* my_seek(): lock fd mutex */\n#define MY_SYNC       4096      /* my_copy(): sync dst file */\n#define MY_SYNC_DIR   32768     /* my_create/delete/rename: sync directory */\n#define MY_SYNC_FILESIZE 65536  /* my_sync(): safe sync when file is extended */\n\n#define MY_CHECK_ERROR\t1\t/* Params to my_end; Check open-close */\n#define MY_GIVE_INFO\t2\t/* Give time info about process*/\n#define MY_DONT_FREE_DBUG 4     /* Do not call DBUG_END() in my_end() */\n\n#define ME_HIGHBYTE\t8\t/* Shift for colours */\n#define ME_NOCUR\t1\t/* Don't use curses message */\n#define ME_OLDWIN\t2\t/* Use old window */\n#define ME_BELL\t\t4\t/* Ring bell then printing message */\n#define ME_HOLDTANG\t8\t/* Don't delete last keys */\n#define ME_WAITTOT\t16\t/* Wait for errtime secs of for a action */\n#define ME_WAITTANG\t32\t/* Wait for a user action  */\n#define ME_NOREFRESH\t64\t/* Write the error message to error log */\n#define ME_NOINPUT\t128\t/* Dont use the input libary */\n#define ME_COLOUR1\t((1 << ME_HIGHBYTE))\t/* Possibly error-colours */\n#define ME_COLOUR2\t((2 << ME_HIGHBYTE))\n#define ME_COLOUR3\t((3 << ME_HIGHBYTE))\n#define ME_JUST_INFO    1024    /**< not error but just info */\n#define ME_JUST_WARNING 2048    /**< not error but just warning */\n#define ME_FATALERROR   4096    /* Fatal statement error */\n\n\t/* Bits in last argument to fn_format */\n#define MY_REPLACE_DIR\t\t1\t/* replace dir in name with 'dir' */\n#define MY_REPLACE_EXT\t\t2\t/* replace extension with 'ext' */\n#define MY_UNPACK_FILENAME\t4\t/* Unpack name (~ -> home) */\n#define MY_PACK_FILENAME\t8\t/* Pack name (home -> ~) */\n#define MY_RESOLVE_SYMLINKS\t16\t/* Resolve all symbolic links */\n#define MY_RETURN_REAL_PATH\t32\t/* return full path for file */\n#define MY_SAFE_PATH\t\t64\t/* Return NULL if too long path */\n#define MY_RELATIVE_PATH\t128\t/* name is relative to 'dir' */\n#define MY_APPEND_EXT           256     /* add 'ext' as additional extension*/\n\n\n\t/* My seek flags */\n#define MY_SEEK_SET\t0\n#define MY_SEEK_CUR\t1\n#define MY_SEEK_END\t2\n\n\t/* Some constants */\n#define MY_WAIT_FOR_USER_TO_FIX_PANIC\t60\t/* in seconds */\n#define MY_WAIT_GIVE_USER_A_MESSAGE\t10\t/* Every 10 times of prev */\n#define MIN_COMPRESS_LENGTH\t\t50\t/* Don't compress small bl. */\n#define DFLT_INIT_HITS  3\n\n\t/* root_alloc flags */\n#define MY_KEEP_PREALLOC\t1\n#define MY_MARK_BLOCKS_FREE     2  /* move used to free list and reuse them */\n\n\t/* Internal error numbers (for assembler functions) */\n#define MY_ERRNO_EDOM\t\t33\n#define MY_ERRNO_ERANGE\t\t34\n\n\t/* Bits for get_date timeflag */\n#define GETDATE_DATE_TIME\t1\n#define GETDATE_SHORT_DATE\t2\n#define GETDATE_HHMMSSTIME\t4\n#define GETDATE_GMT\t\t8\n#define GETDATE_FIXEDLENGTH\t16\n\n/* Extra length needed for filename if one calls my_create_backup_name */\n#define MY_BACKUP_NAME_EXTRA_LENGTH 17\n\n\t/* defines when allocating data */\nextern void *my_malloc(size_t Size,myf MyFlags);\nextern void *my_multi_malloc(myf MyFlags, ...);\nextern void *my_realloc(void *oldpoint, size_t Size, myf MyFlags);\nextern void my_free(void *ptr);\nextern void *my_memdup(const void *from,size_t length,myf MyFlags);\nextern char *my_strdup(const char *from,myf MyFlags);\nextern char *my_strndup(const char *from, size_t length, myf MyFlags);\n\nextern int sf_leaking_memory; /* set to 1 to disable memleak detection */\n\n#ifdef HAVE_LARGE_PAGES\nextern uint my_get_large_page_size(void);\nextern uchar * my_large_malloc(size_t size, myf my_flags);\nextern void my_large_free(uchar *ptr);\n#else\n#define my_get_large_page_size() (0)\n#define my_large_malloc(A,B) my_malloc_lock((A),(B))\n#define my_large_free(A) my_free_lock((A))\n#endif /* HAVE_LARGE_PAGES */\n\n#if defined(HAVE_ALLOCA) && !defined(HAVE_valgrind)\n#if defined(_AIX) && !defined(__GNUC__) && !defined(_AIX43)\n#pragma alloca\n#endif /* _AIX */\n#if defined(__MWERKS__)\n#undef alloca\n#define alloca _alloca\n#endif /* __MWERKS__ */\n#if defined(__GNUC__) && !defined(HAVE_ALLOCA_H) && ! defined(alloca)\n#define alloca __builtin_alloca\n#endif /* GNUC */\n#define my_alloca(SZ) alloca((size_t) (SZ))\n#define my_afree(PTR) ((void)0)\n#else\n#define my_alloca(SZ) my_malloc(SZ,MYF(MY_FAE))\n#define my_afree(PTR) my_free(PTR)\n#endif /* HAVE_ALLOCA */\n\n#define my_safe_alloca(size, min_length) ((size <= min_length) ? my_alloca(size) : my_malloc(size,MYF(MY_FAE)))\n#define my_safe_afree(ptr, size, min_length) ((size <= min_length) ? my_afree(ptr) : my_free(ptr))\n\n#ifndef errno\t\t\t\t/* did we already get it? */\n#ifdef HAVE_ERRNO_AS_DEFINE\n#include <errno.h>\t\t\t/* errno is a define */\n#else\nextern int errno;\t\t\t/* declare errno */\n#endif\n#endif\t\t\t\t\t/* #ifndef errno */\nextern char *home_dir;\t\t\t/* Home directory for user */\nextern MYSQL_PLUGIN_IMPORT char  *mysql_data_home;\nextern const char *my_progname;\t\t/* program-name (printed in errors) */\nextern const char *my_progname_short;\t/* like above but without directory */\nextern char curr_dir[];\t\t/* Current directory for user */\nextern void (*error_handler_hook)(uint my_err, const char *str,myf MyFlags);\nextern void (*fatal_error_handler_hook)(uint my_err, const char *str,\n\t\t\t\t       myf MyFlags);\nextern uint my_file_limit;\nextern ulonglong my_thread_stack_size;\n\nextern const char *(*proc_info_hook)(MYSQL_THD, const char *, const char *,\n                                     const char *, const unsigned int);\n\n#ifdef HAVE_LARGE_PAGES\nextern my_bool my_use_large_pages;\nextern uint    my_large_page_size;\n#endif\n\n/* charsets */\n#define MY_ALL_CHARSETS_SIZE 2048\nextern MYSQL_PLUGIN_IMPORT CHARSET_INFO *default_charset_info;\nextern MYSQL_PLUGIN_IMPORT CHARSET_INFO *all_charsets[MY_ALL_CHARSETS_SIZE];\nextern struct charset_info_st compiled_charsets[];\n\n/* statistics */\nextern ulong\tmy_file_opened,my_stream_opened, my_tmp_file_created;\nextern ulong    my_file_total_opened;\nextern ulong    my_sync_count;\nextern uint\tmysys_usage_id;\nextern my_bool\tmy_init_done;\nextern my_bool  my_assert_on_error;\nextern myf      my_global_flags;        /* Set to MY_WME for more error messages */\n\t\t\t\t\t/* Point to current my_message() */\nextern void (*my_sigtstp_cleanup)(void),\n\t\t\t\t\t/* Executed before jump to shell */\n\t    (*my_sigtstp_restart)(void),\n\t    (*my_abort_hook)(int);\n\t\t\t\t\t/* Executed when comming from shell */\nextern MYSQL_PLUGIN_IMPORT int my_umask;\t\t/* Default creation mask  */\nextern int my_umask_dir,\n\t   my_recived_signals,\t/* Signals we have got */\n\t   my_safe_to_handle_signal, /* Set when allowed to SIGTSTP */\n\t   my_dont_interrupt;\t/* call remember_intr when set */\nextern my_bool my_use_symdir;\n\nextern ulong\tmy_default_record_cache_size;\nextern my_bool  my_disable_locking, my_disable_async_io,\n                my_disable_flush_key_blocks, my_disable_symlinks;\nextern my_bool my_disable_sync;\nextern char\twild_many,wild_one,wild_prefix;\nextern const char *charsets_dir;\n/* from default.c */\nextern const char *my_defaults_extra_file;\nextern const char *my_defaults_group_suffix;\nextern const char *my_defaults_file;\n\nextern my_bool timed_mutexes;\n\nenum loglevel {\n   ERROR_LEVEL,\n   WARNING_LEVEL,\n   INFORMATION_LEVEL\n};\n\nenum cache_type\n{\n  TYPE_NOT_SET= 0, READ_CACHE, WRITE_CACHE,\n  SEQ_READ_APPEND\t\t/* sequential read or append */,\n  READ_FIFO, READ_NET,WRITE_NET};\n\nenum flush_type\n{\n  FLUSH_KEEP,           /* flush block and keep it in the cache */\n  FLUSH_RELEASE,        /* flush block and remove it from the cache */\n  FLUSH_IGNORE_CHANGED, /* remove block from the cache */\n  /*\n    As my_disable_flush_pagecache_blocks is always 0, the following option\n    is strictly equivalent to FLUSH_KEEP\n  */\n  FLUSH_FORCE_WRITE,\n  /**\n     @brief like FLUSH_KEEP but return immediately if file is already being\n     flushed (even partially) by another thread; only for page cache,\n     forbidden for key cache.\n  */\n  FLUSH_KEEP_LAZY\n};\n\ntypedef struct st_record_cache\t/* Used when cacheing records */\n{\n  File file;\n  int\trc_seek,error,inited;\n  uint\trc_length,read_length,reclength;\n  my_off_t rc_record_pos,end_of_file;\n  uchar *rc_buff,*rc_buff2,*rc_pos,*rc_end,*rc_request_pos;\n#ifdef HAVE_AIOWAIT\n  int\tuse_async_io;\n  my_aio_result aio_result;\n#endif\n  enum cache_type type;\n} RECORD_CACHE;\n\nenum file_type\n{\n  UNOPEN = 0, FILE_BY_OPEN, FILE_BY_CREATE, STREAM_BY_FOPEN, STREAM_BY_FDOPEN,\n  FILE_BY_MKSTEMP, FILE_BY_DUP\n};\n\nstruct st_my_file_info\n{\n  char  *name;\n#ifdef _WIN32\n  HANDLE fhandle;   /* win32 file handle */\n  int    oflag;     /* open flags, e.g O_APPEND */\n#endif\n  enum   file_type\ttype;\n};\n\nextern struct st_my_file_info *my_file_info;\n\ntypedef struct st_dynamic_array\n{\n  uchar *buffer;\n  uint elements,max_element;\n  uint alloc_increment;\n  uint size_of_element;\n} DYNAMIC_ARRAY;\n\ntypedef struct st_my_tmpdir\n{\n  DYNAMIC_ARRAY full_list;\n  char **list;\n  uint cur, max;\n  mysql_mutex_t mutex;\n} MY_TMPDIR;\n\ntypedef struct st_dynamic_string\n{\n  char *str;\n  size_t length,max_length,alloc_increment;\n} DYNAMIC_STRING;\n\nstruct st_io_cache;\ntypedef int (*IO_CACHE_CALLBACK)(struct st_io_cache*);\n\ntypedef struct st_io_cache_share\n{\n  mysql_mutex_t       mutex;           /* To sync on reads into buffer. */\n  mysql_cond_t        cond;            /* To wait for signals. */\n  mysql_cond_t        cond_writer;     /* For a synchronized writer. */\n  /* Offset in file corresponding to the first byte of buffer. */\n  my_off_t              pos_in_file;\n  /* If a synchronized write cache is the source of the data. */\n  struct st_io_cache    *source_cache;\n  uchar                 *buffer;         /* The read buffer. */\n  uchar                 *read_end;       /* Behind last valid byte of buffer. */\n  int                   running_threads; /* threads not in lock. */\n  int                   total_threads;   /* threads sharing the cache. */\n  int                   error;           /* Last error. */\n#ifdef NOT_YET_IMPLEMENTED\n  /* whether the structure should be free'd */\n  my_bool alloced;\n#endif\n} IO_CACHE_SHARE;\n\ntypedef struct st_io_cache\t\t/* Used when cacheing files */\n{\n  /* Offset in file corresponding to the first byte of uchar* buffer. */\n  my_off_t pos_in_file;\n  /*\n    The offset of end of file for READ_CACHE and WRITE_CACHE.\n    For SEQ_READ_APPEND it the maximum of the actual end of file and\n    the position represented by read_end.\n  */\n  my_off_t end_of_file;\n  /* Points to current read position in the buffer */\n  uchar\t*read_pos;\n  /* the non-inclusive boundary in the buffer for the currently valid read */\n  uchar  *read_end;\n  uchar  *buffer;\t\t\t\t/* The read buffer */\n  /* Used in ASYNC_IO */\n  uchar  *request_pos;\n\n  /* Only used in WRITE caches and in SEQ_READ_APPEND to buffer writes */\n  uchar  *write_buffer;\n  /*\n    Only used in SEQ_READ_APPEND, and points to the current read position\n    in the write buffer. Note that reads in SEQ_READ_APPEND caches can\n    happen from both read buffer (uchar* buffer) and write buffer\n    (uchar* write_buffer).\n  */\n  uchar *append_read_pos;\n  /* Points to current write position in the write buffer */\n  uchar *write_pos;\n  /* The non-inclusive boundary of the valid write area */\n  uchar *write_end;\n\n  /*\n    Current_pos and current_end are convenience variables used by\n    my_b_tell() and other routines that need to know the current offset\n    current_pos points to &write_pos, and current_end to &write_end in a\n    WRITE_CACHE, and &read_pos and &read_end respectively otherwise\n  */\n  uchar  **current_pos, **current_end;\n\n  /*\n    The lock is for append buffer used in SEQ_READ_APPEND cache\n    need mutex copying from append buffer to read buffer.\n  */\n  mysql_mutex_t append_buffer_lock;\n  /*\n    The following is used when several threads are reading the\n    same file in parallel. They are synchronized on disk\n    accesses reading the cached part of the file asynchronously.\n    It should be set to NULL to disable the feature.  Only\n    READ_CACHE mode is supported.\n  */\n  IO_CACHE_SHARE *share;\n\n  /*\n    A caller will use my_b_read() macro to read from the cache\n    if the data is already in cache, it will be simply copied with\n    memcpy() and internal variables will be accordinging updated with\n    no functions invoked. However, if the data is not fully in the cache,\n    my_b_read() will call read_function to fetch the data. read_function\n    must never be invoked directly.\n  */\n  int (*read_function)(struct st_io_cache *,uchar *,size_t);\n  /*\n    Same idea as in the case of read_function, except my_b_write() needs to\n    be replaced with my_b_append() for a SEQ_READ_APPEND cache\n  */\n  int (*write_function)(struct st_io_cache *,const uchar *,size_t);\n  /*\n    Specifies the type of the cache. Depending on the type of the cache\n    certain operations might not be available and yield unpredicatable\n    results. Details to be documented later\n  */\n  enum cache_type type;\n  /*\n    Callbacks when the actual read I/O happens. These were added and\n    are currently used for binary logging of LOAD DATA INFILE - when a\n    block is read from the file, we create a block create/append event, and\n    when IO_CACHE is closed, we create an end event. These functions could,\n    of course be used for other things\n  */\n  IO_CACHE_CALLBACK pre_read;\n  IO_CACHE_CALLBACK post_read;\n  IO_CACHE_CALLBACK pre_close;\n  /*\n    Counts the number of times, when we were forced to use disk. We use it to\n    increase the binlog_cache_disk_use and binlog_stmt_cache_disk_use status\n    variables.\n  */\n  ulong disk_writes;\n  void* arg;\t\t\t\t/* for use by pre/post_read */\n  char *file_name;\t\t\t/* if used with 'open_cached_file' */\n  char *dir,*prefix;\n  File file; /* file descriptor */\n  /*\n    seek_not_done is set by my_b_seek() to inform the upcoming read/write\n    operation that a seek needs to be preformed prior to the actual I/O\n    error is 0 if the cache operation was successful, -1 if there was a\n    \"hard\" error, and the actual number of I/O-ed bytes if the read/write was\n    partial.\n  */\n  int\tseek_not_done,error;\n  /* buffer_length is memory size allocated for buffer or write_buffer */\n  size_t\tbuffer_length;\n  /* read_length is the same as buffer_length except when we use async io */\n  size_t  read_length;\n  myf\tmyflags;\t\t\t/* Flags used to my_read/my_write */\n  /*\n    alloced_buffer is 1 if the buffer was allocated by init_io_cache() and\n    0 if it was supplied by the user.\n    Currently READ_NET is the only one that will use a buffer allocated\n    somewhere else\n  */\n  my_bool alloced_buffer;\n#ifdef HAVE_AIOWAIT\n  /*\n    As inidicated by ifdef, this is for async I/O, which is not currently\n    used (because it's not reliable on all systems)\n  */\n  uint inited;\n  my_off_t aio_read_pos;\n  my_aio_result aio_result;\n#endif\n} IO_CACHE;\n\ntypedef int (*qsort2_cmp)(const void *, const void *, const void *);\n\n\t/* defines for mf_iocache */\n\n\t/* Test if buffer is inited */\n#define my_b_clear(info) (info)->buffer=0\n#define my_b_inited(info) (info)->buffer\n#define my_b_EOF INT_MIN\n\n#define my_b_read(info,Buffer,Count) \\\n  ((info)->read_pos + (Count) <= (info)->read_end ?\\\n   (memcpy(Buffer,(info)->read_pos,(size_t) (Count)), \\\n    ((info)->read_pos+=(Count)),0) :\\\n   (*(info)->read_function)((info),Buffer,Count))\n\n#define my_b_write(info,Buffer,Count) \\\n ((info)->write_pos + (Count) <=(info)->write_end ?\\\n  (memcpy((info)->write_pos, (Buffer), (size_t)(Count)),\\\n   ((info)->write_pos+=(Count)),0) : \\\n   (*(info)->write_function)((info),(uchar *)(Buffer),(Count)))\n\n#define my_b_get(info) \\\n  ((info)->read_pos != (info)->read_end ?\\\n   ((info)->read_pos++, (int) (uchar) (info)->read_pos[-1]) :\\\n   _my_b_get(info))\n\n\t/* my_b_write_byte dosn't have any err-check */\n#define my_b_write_byte(info,chr) \\\n  (((info)->write_pos < (info)->write_end) ?\\\n   ((*(info)->write_pos++)=(chr)) :\\\n   (_my_b_write(info,0,0) , ((*(info)->write_pos++)=(chr))))\n\n#define my_b_fill_cache(info) \\\n  (((info)->read_end=(info)->read_pos),(*(info)->read_function)(info,0,0))\n\n#define my_b_tell(info) ((info)->pos_in_file + \\\n\t\t\t (size_t) (*(info)->current_pos - (info)->request_pos))\n#define my_b_write_tell(info) ((info)->pos_in_file + \\\n\t\t\t ((info)->write_pos - (info)->write_buffer))\n\n#define my_b_get_buffer_start(info) (info)->request_pos \n#define my_b_get_bytes_in_buffer(info) (char*) (info)->read_end -   \\\n  (char*) my_b_get_buffer_start(info)\n#define my_b_get_pos_in_file(info) (info)->pos_in_file\n\n/* tell write offset in the SEQ_APPEND cache */\nint      my_b_copy_to_file(IO_CACHE *cache, FILE *file);\nmy_off_t my_b_append_tell(IO_CACHE* info);\nmy_off_t my_b_safe_tell(IO_CACHE* info); /* picks the correct tell() */\n\n#define my_b_bytes_in_cache(info) (size_t) (*(info)->current_end - \\\n\t\t\t\t\t  *(info)->current_pos)\n\ntypedef uint32 ha_checksum;\nextern ulong my_crc_dbug_check;\n\n/* Define the type of function to be passed to process_default_option_files */\ntypedef int (*Process_option_func)(void *ctx, const char *group_name,\n                                   const char *option);\n\n#include <my_alloc.h>\n\n\n\t/* Prototypes for mysys and my_func functions */\n\nextern int my_copy(const char *from,const char *to,myf MyFlags);\nextern int my_delete(const char *name,myf MyFlags);\nextern int my_getwd(char * buf,size_t size,myf MyFlags);\nextern int my_setwd(const char *dir,myf MyFlags);\nextern int my_lock(File fd,int op,my_off_t start, my_off_t length,myf MyFlags);\nextern void *my_once_alloc(size_t Size,myf MyFlags);\nextern void my_once_free(void);\nextern char *my_once_strdup(const char *src,myf myflags);\nextern void *my_once_memdup(const void *src, size_t len, myf myflags);\nextern File my_open(const char *FileName,int Flags,myf MyFlags);\nextern File my_register_filename(File fd, const char *FileName,\n\t\t\t\t enum file_type type_of_file,\n\t\t\t\t uint error_message_number, myf MyFlags);\nextern File my_create(const char *FileName,int CreateFlags,\n\t\t      int AccessFlags, myf MyFlags);\nextern int my_close(File Filedes,myf MyFlags);\nextern int my_mkdir(const char *dir, int Flags, myf MyFlags);\nextern int my_readlink(char *to, const char *filename, myf MyFlags);\nextern int my_is_symlink(const char *filename);\nextern int my_realpath(char *to, const char *filename, myf MyFlags);\nextern File my_create_with_symlink(const char *linkname, const char *filename,\n\t\t\t\t   int createflags, int access_flags,\n\t\t\t\t   myf MyFlags);\nextern int my_delete_with_symlink(const char *name, myf MyFlags);\nextern int my_rename_with_symlink(const char *from,const char *to,myf MyFlags);\nextern int my_symlink(const char *content, const char *linkname, myf MyFlags);\nextern size_t my_read(File Filedes,uchar *Buffer,size_t Count,myf MyFlags);\nextern size_t my_pread(File Filedes,uchar *Buffer,size_t Count,my_off_t offset,\n\t\t     myf MyFlags);\nextern int my_rename(const char *from,const char *to,myf MyFlags);\nextern my_off_t my_seek(File fd,my_off_t pos,int whence,myf MyFlags);\nextern my_off_t my_tell(File fd,myf MyFlags);\nextern size_t my_write(File Filedes,const uchar *Buffer,size_t Count,\n\t\t     myf MyFlags);\nextern size_t my_pwrite(File Filedes,const uchar *Buffer,size_t Count,\n\t\t      my_off_t offset,myf MyFlags);\nextern size_t my_fread(FILE *stream,uchar *Buffer,size_t Count,myf MyFlags);\nextern size_t my_fwrite(FILE *stream,const uchar *Buffer,size_t Count,\n\t\t      myf MyFlags);\nextern my_off_t my_fseek(FILE *stream,my_off_t pos,int whence,myf MyFlags);\nextern my_off_t my_ftell(FILE *stream,myf MyFlags);\n\n/* implemented in my_memmem.c */\nextern void *my_memmem(const void *haystack, size_t haystacklen,\n                       const void *needle, size_t needlelen);\n\n\n#ifdef _WIN32\nextern int      my_access(const char *path, int amode);\n#else\n#define my_access access\n#endif\n\nextern int check_if_legal_filename(const char *path);\nextern int check_if_legal_tablename(const char *path);\n\n#ifdef _WIN32\n/* Windows-only functions (CRT equivalents)*/\nextern HANDLE   my_get_osfhandle(File fd);\nextern void     my_osmaperr(unsigned long last_error);\n#endif\n\nextern void init_glob_errs(void);\nextern const char** get_global_errmsgs();\nextern void wait_for_free_space(const char *filename, int errors);\nextern FILE *my_fopen(const char *FileName,int Flags,myf MyFlags);\nextern FILE *my_fdopen(File Filedes,const char *name, int Flags,myf MyFlags);\nextern FILE *my_freopen(const char *path, const char *mode, FILE *stream);\nextern int my_fclose(FILE *fd,myf MyFlags);\nextern int my_vfprintf(FILE *stream, const char* format, va_list args);\nextern int my_fprintf(FILE *stream, const char* format, ...);\nextern File my_fileno(FILE *fd);\nextern int my_chsize(File fd,my_off_t newlength, int filler, myf MyFlags);\nextern int my_chmod(const char *name, mode_t mode, myf my_flags);\nextern const char *my_basename(const char *filename);\nextern void thr_set_sync_wait_callback(void (*before_sync)(void),\n                                       void (*after_sync)(void));\nextern int my_sync(File fd, myf my_flags);\nextern int my_sync_dir(const char *dir_name, myf my_flags);\nextern int my_sync_dir_by_file(const char *file_name, myf my_flags);\nextern void my_error(int nr,myf MyFlags, ...);\nextern void my_printf_error(uint my_err, const char *format,\n                            myf MyFlags, ...)\n                            ATTRIBUTE_FORMAT(printf, 2, 4);\nextern void my_printv_error(uint error, const char *format, myf MyFlags,\n                            va_list ap);\nextern int my_error_register(const char** (*get_errmsgs) (),\n                             int first, int last);\nextern const char **my_error_unregister(int first, int last);\nextern void my_message(uint my_err, const char *str,myf MyFlags);\nextern void my_message_stderr(uint my_err, const char *str, myf MyFlags);\nextern my_bool my_init(void);\nextern void my_end(int infoflag);\nextern int my_redel(const char *from, const char *to, time_t backup_time_stamp,\n                    myf MyFlags);\nvoid my_create_backup_name(char *to, const char *from,\n                           time_t backup_time_stamp);\nextern int my_copystat(const char *from, const char *to, int MyFlags);\nextern char * my_filename(File fd);\n\n#ifdef EXTRA_DEBUG\nvoid my_print_open_files(void);\n#else\n#define my_print_open_files()\n#endif\n\nextern my_bool init_tmpdir(MY_TMPDIR *tmpdir, const char *pathlist);\nextern char *my_tmpdir(MY_TMPDIR *tmpdir);\nextern void free_tmpdir(MY_TMPDIR *tmpdir);\n\nextern void my_remember_signal(int signal_number,sig_handler (*func)(int));\nextern size_t dirname_part(char * to,const char *name, size_t *to_res_length);\nextern size_t dirname_length(const char *name);\n#define base_name(A) (A+dirname_length(A))\nextern int test_if_hard_path(const char *dir_name);\nextern my_bool has_path(const char *name);\nextern char *convert_dirname(char *to, const char *from, const char *from_end);\nextern void to_unix_path(char * name);\nextern char * fn_ext(const char *name);\nextern char * fn_ext2(const char *name);\nextern char * fn_same(char * toname,const char *name,int flag);\nextern char * fn_format(char * to,const char *name,const char *dir,\n\t\t\t   const char *form, uint flag);\nextern size_t strlength(const char *str);\nextern void pack_dirname(char * to,const char *from);\nextern size_t normalize_dirname(char * to, const char *from);\nextern size_t unpack_dirname(char * to,const char *from);\nextern size_t cleanup_dirname(char * to,const char *from);\nextern size_t system_filename(char * to,const char *from);\nextern size_t unpack_filename(char * to,const char *from);\nextern char * intern_filename(char * to,const char *from);\nextern char * directory_file_name(char * dst, const char *src);\nextern int pack_filename(char * to, const char *name, size_t max_length);\nextern char * my_path(char * to,const char *progname,\n\t\t\t const char *own_pathname_part);\nextern char * my_load_path(char * to, const char *path,\n\t\t\t      const char *own_path_prefix);\nextern int wild_compare(const char *str,const char *wildstr,\n                        pbool str_is_pattern);\nextern my_bool array_append_string_unique(const char *str,\n                                          const char **array, size_t size);\nextern void get_date(char * to,int timeflag,time_t use_time);\nextern void soundex(CHARSET_INFO *, char * out_pntr, char * in_pntr,\n                    pbool remove_garbage);\nextern int init_record_cache(RECORD_CACHE *info,size_t cachesize,File file,\n\t\t\t     size_t reclength,enum cache_type type,\n\t\t\t     pbool use_async_io);\nextern int read_cache_record(RECORD_CACHE *info,uchar *to);\nextern int end_record_cache(RECORD_CACHE *info);\nextern int write_cache_record(RECORD_CACHE *info,my_off_t filepos,\n\t\t\t      const uchar *record,size_t length);\nextern int flush_write_cache(RECORD_CACHE *info);\nextern void handle_recived_signals(void);\n\nextern sig_handler my_set_alarm_variable(int signo);\nextern void my_string_ptr_sort(uchar *base,uint items,size_t size);\nextern void radixsort_for_str_ptr(uchar* base[], uint number_of_elements,\n\t\t\t\t  size_t size_of_element,uchar *buffer[]);\nextern qsort_t my_qsort(void *base_ptr, size_t total_elems, size_t size,\n                        qsort_cmp cmp);\nextern qsort_t my_qsort2(void *base_ptr, size_t total_elems, size_t size,\n                         qsort2_cmp cmp, void *cmp_argument);\nextern qsort2_cmp get_ptr_compare(size_t);\nvoid my_store_ptr(uchar *buff, size_t pack_length, my_off_t pos);\nmy_off_t my_get_ptr(uchar *ptr, size_t pack_length);\nextern int init_io_cache(IO_CACHE *info,File file,size_t cachesize,\n\t\t\t enum cache_type type,my_off_t seek_offset,\n\t\t\t pbool use_async_io, myf cache_myflags);\nextern my_bool reinit_io_cache(IO_CACHE *info,enum cache_type type,\n\t\t\t       my_off_t seek_offset,pbool use_async_io,\n\t\t\t       pbool clear_cache);\nextern void setup_io_cache(IO_CACHE* info);\nextern int _my_b_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_read_r(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern void init_io_cache_share(IO_CACHE *read_cache, IO_CACHE_SHARE *cshare,\n                                IO_CACHE *write_cache, uint num_threads);\nextern void remove_io_thread(IO_CACHE *info);\nextern int _my_b_seq_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_net_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_get(IO_CACHE *info);\nextern int _my_b_async_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_write(IO_CACHE *info,const uchar *Buffer,size_t Count);\nextern int my_b_append(IO_CACHE *info,const uchar *Buffer,size_t Count);\nextern int my_b_safe_write(IO_CACHE *info,const uchar *Buffer,size_t Count);\n\nextern int my_block_write(IO_CACHE *info, const uchar *Buffer,\n\t\t\t  size_t Count, my_off_t pos);\nextern int my_b_flush_io_cache(IO_CACHE *info, int need_append_buffer_lock);\n\n#define flush_io_cache(info) my_b_flush_io_cache((info),1)\n\nextern int end_io_cache(IO_CACHE *info);\nextern size_t my_b_fill(IO_CACHE *info);\nextern void my_b_seek(IO_CACHE *info,my_off_t pos);\nextern size_t my_b_gets(IO_CACHE *info, char *to, size_t max_length);\nextern my_off_t my_b_filelength(IO_CACHE *info);\nextern size_t my_b_write_backtick_quote(IO_CACHE *info, const char *str,\n                                        size_t len);\nextern size_t my_b_printf(IO_CACHE *info, const char* fmt, ...);\nextern size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list ap);\nextern my_bool open_cached_file(IO_CACHE *cache,const char *dir,\n\t\t\t\t const char *prefix, size_t cache_size,\n\t\t\t\t myf cache_myflags);\nextern my_bool real_open_cached_file(IO_CACHE *cache);\nextern void close_cached_file(IO_CACHE *cache);\nFile create_temp_file(char *to, const char *dir, const char *pfx,\n\t\t      int mode, myf MyFlags);\n#define my_init_dynamic_array(A,B,C,D) init_dynamic_array2(A,B,NULL,C,D)\n#define my_init_dynamic_array_ci(A,B,C,D) init_dynamic_array2(A,B,NULL,C,D)\n#define my_init_dynamic_array2(A,B,C,D,E) init_dynamic_array2(A,B,C,D,E)\n#define my_init_dynamic_array2_ci(A,B,C,D,E) init_dynamic_array2(A,B,C,D,E)\nextern my_bool init_dynamic_array2(DYNAMIC_ARRAY *array, uint element_size,\n                                   void *init_buffer, uint init_alloc,\n                                   uint alloc_increment);\n/* init_dynamic_array() function is deprecated */\nextern my_bool init_dynamic_array(DYNAMIC_ARRAY *array, uint element_size,\n                                  uint init_alloc, uint alloc_increment);\nextern my_bool insert_dynamic(DYNAMIC_ARRAY *array, const uchar * element);\nextern uchar *alloc_dynamic(DYNAMIC_ARRAY *array);\nextern uchar *pop_dynamic(DYNAMIC_ARRAY*);\nextern my_bool set_dynamic(DYNAMIC_ARRAY *array,uchar * element,uint array_index);\nextern my_bool allocate_dynamic(DYNAMIC_ARRAY *array, uint max_elements);\nextern void get_dynamic(DYNAMIC_ARRAY *array,uchar * element,uint array_index);\nextern void delete_dynamic(DYNAMIC_ARRAY *array);\nextern void delete_dynamic_element(DYNAMIC_ARRAY *array, uint array_index);\nextern void freeze_size(DYNAMIC_ARRAY *array);\nextern int  get_index_dynamic(DYNAMIC_ARRAY *array, uchar * element);\n#define dynamic_array_ptr(array,array_index) ((array)->buffer+(array_index)*(array)->size_of_element)\n#define dynamic_element(array,array_index,type) ((type)((array)->buffer) +(array_index))\n#define push_dynamic(A,B) insert_dynamic((A),(B))\n#define reset_dynamic(array) ((array)->elements= 0)\n#define sort_dynamic(A,cmp) my_qsort((A)->buffer, (A)->elements, (A)->size_of_element, (cmp))\n\nextern my_bool init_dynamic_string(DYNAMIC_STRING *str, const char *init_str,\n\t\t\t\t   size_t init_alloc,size_t alloc_increment);\nextern my_bool dynstr_append(DYNAMIC_STRING *str, const char *append);\nmy_bool dynstr_append_mem(DYNAMIC_STRING *str, const char *append,\n\t\t\t  size_t length);\nextern my_bool dynstr_append_os_quoted(DYNAMIC_STRING *str, const char *append,\n                                       ...);\nextern my_bool dynstr_set(DYNAMIC_STRING *str, const char *init_str);\nextern my_bool dynstr_realloc(DYNAMIC_STRING *str, size_t additional_size);\nextern my_bool dynstr_trunc(DYNAMIC_STRING *str, size_t n);\nextern void dynstr_free(DYNAMIC_STRING *str);\nextern void dynstr_reassociate(DYNAMIC_STRING *str, char **res, size_t *length,\n                               size_t *alloc_length);\n#ifdef HAVE_MLOCK\nextern void *my_malloc_lock(size_t length,myf flags);\nextern void my_free_lock(void *ptr);\n#else\n#define my_malloc_lock(A,B) my_malloc((A),(B))\n#define my_free_lock(A) my_free((A))\n#endif\n#define alloc_root_inited(A) ((A)->min_malloc != 0)\n#define ALLOC_ROOT_MIN_BLOCK_SIZE (MALLOC_OVERHEAD + sizeof(USED_MEM) + 8)\n#define clear_alloc_root(A) do { (A)->free= (A)->used= (A)->pre_alloc= 0; (A)->min_malloc=0;} while(0)\nextern void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,\n\t\t\t    size_t pre_alloc_size);\nextern void *alloc_root(MEM_ROOT *mem_root, size_t Size);\nextern void *multi_alloc_root(MEM_ROOT *mem_root, ...);\nextern void free_root(MEM_ROOT *root, myf MyFLAGS);\nextern void set_prealloc_root(MEM_ROOT *root, char *ptr);\nextern void reset_root_defaults(MEM_ROOT *mem_root, size_t block_size,\n                                size_t prealloc_size);\nextern char *strdup_root(MEM_ROOT *root,const char *str);\nstatic inline char *safe_strdup_root(MEM_ROOT *root, const char *str)\n{\n  return str ? strdup_root(root, str) : 0;\n}\nextern char *strmake_root(MEM_ROOT *root,const char *str,size_t len);\nextern void *memdup_root(MEM_ROOT *root,const void *str, size_t len);\nextern int get_defaults_options(int argc, char **argv,\n                                char **defaults, char **extra_defaults,\n                                char **group_suffix);\nextern my_bool my_getopt_use_args_separator;\nextern my_bool my_getopt_is_args_separator(const char* arg);\nextern int my_load_defaults(const char *conf_file, const char **groups,\n                            int *argc, char ***argv, const char ***);\nextern int load_defaults(const char *conf_file, const char **groups,\n                         int *argc, char ***argv);\nextern int my_search_option_files(const char *conf_file, int *argc,\n                                  char ***argv, uint *args_used,\n                                  Process_option_func func, void *func_ctx,\n                                  const char **default_directories);\nextern void free_defaults(char **argv);\nextern void my_print_default_files(const char *conf_file);\nextern void print_defaults(const char *conf_file, const char **groups);\nextern my_bool my_compress(uchar *, size_t *, size_t *);\nextern my_bool my_uncompress(uchar *, size_t , size_t *);\nextern uchar *my_compress_alloc(const uchar *packet, size_t *len,\n                                size_t *complen);\nextern void *my_az_allocator(void *dummy, unsigned int items, unsigned int size);\nextern void my_az_free(void *dummy, void *address);\nextern int my_compress_buffer(uchar *dest, size_t *destLen,\n                              const uchar *source, size_t sourceLen);\nextern int packfrm(uchar *, size_t, uchar **, size_t *);\nextern int unpackfrm(uchar **, size_t *, const uchar *);\n\nextern ha_checksum my_checksum(ha_checksum crc, const uchar *mem,\n                               size_t count);\n#ifndef DBUG_OFF\nextern void my_debug_put_break_here(void);\n#else\n#define my_debug_put_break_here() do {} while(0)\n#endif\n\nextern void my_sleep(ulong m_seconds);\nextern ulong crc32(ulong crc, const uchar *buf, uint len);\nextern uint my_set_max_open_files(uint files);\nvoid my_free_open_file_info(void);\n\nextern my_bool my_gethwaddr(uchar *to);\nextern int my_getncpus();\n\n#define HRTIME_RESOLUTION               1000000ULL  /* microseconds */\ntypedef struct {ulonglong val;} my_hrtime_t;\nvoid my_time_init();\nextern my_hrtime_t my_hrtime();\nextern ulonglong my_interval_timer(void);\nextern ulonglong my_getcputime(void);\n\n#define microsecond_interval_timer()    (my_interval_timer()/1000)\n#define hrtime_to_time(X)               ((X).val/HRTIME_RESOLUTION)\n#define hrtime_from_time(X)             ((ulonglong)((X)*HRTIME_RESOLUTION))\n#define hrtime_to_double(X)             ((X).val/(double)HRTIME_RESOLUTION)\n#define hrtime_sec_part(X)              ((ulong)((X).val % HRTIME_RESOLUTION))\n#define my_time(X)                      hrtime_to_time(my_hrtime())\n\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n\n#ifndef MAP_NOSYNC\n#define MAP_NOSYNC      0\n#endif\n#ifndef MAP_NORESERVE\n#define MAP_NORESERVE 0         /* For irix and AIX */\n#endif\n\n#ifdef HAVE_MMAP64\n#define my_mmap(a,b,c,d,e,f)    mmap64(a,b,c,d,e,f)\n#else\n#define my_mmap(a,b,c,d,e,f)    mmap(a,b,c,d,e,f)\n#endif\n#define my_munmap(a,b)          munmap((a),(b))\n\n#else\n/* not a complete set of mmap() flags, but only those that nesessary */\n#define PROT_READ        1\n#define PROT_WRITE       2\n#define MAP_NORESERVE    0\n#define MAP_SHARED       0x0001\n#define MAP_PRIVATE      0x0002\n#define MAP_NOSYNC       0x0800\n#define MAP_FAILED       ((void *)-1)\n#define MS_SYNC          0x0000\n\n#define HAVE_MMAP\nvoid *my_mmap(void *, size_t, int, int, int, my_off_t);\nint my_munmap(void *, size_t);\n#endif\n\n/* my_getpagesize */\n#ifdef HAVE_GETPAGESIZE\n#define my_getpagesize()        getpagesize()\n#else\nint my_getpagesize(void);\n#endif\n\nint my_msync(int, void *, size_t, int);\n\n#define MY_UUID_SIZE 16\n#define MY_UUID_STRING_LENGTH (8+1+4+1+4+1+4+1+12)\n\nvoid my_uuid_init(ulong seed1, ulong seed2);\nvoid my_uuid(uchar *guid);\nvoid my_uuid2str(const uchar *guid, char *s);\nvoid my_uuid_end();\n\nstruct my_rnd_struct {\n  unsigned long seed1,seed2,max_value;\n  double max_value_dbl;\n};\n\nvoid my_rnd_init(struct my_rnd_struct *rand_st, ulong seed1, ulong seed2);\ndouble my_rnd(struct my_rnd_struct *rand_st);\n\n/* character sets */\nextern uint get_charset_number(const char *cs_name, uint cs_flags);\nextern uint get_collation_number(const char *name);\nextern const char *get_charset_name(uint cs_number);\n\nextern CHARSET_INFO *get_charset(uint cs_number, myf flags);\nextern CHARSET_INFO *get_charset_by_name(const char *cs_name, myf flags);\nextern CHARSET_INFO *get_charset_by_csname(const char *cs_name,\n\t\t\t\t\t   uint cs_flags, myf my_flags);\n\nextern my_bool resolve_charset(const char *cs_name,\n                               CHARSET_INFO *default_cs,\n                               CHARSET_INFO **cs);\nextern my_bool resolve_collation(const char *cl_name,\n                                 CHARSET_INFO *default_cl,\n                                 CHARSET_INFO **cl);\nextern void free_charsets(void);\nextern char *get_charsets_dir(char *buf);\nextern my_bool my_charset_same(CHARSET_INFO *cs1, CHARSET_INFO *cs2);\nextern my_bool init_compiled_charsets(myf flags);\nextern void add_compiled_collation(struct charset_info_st *cs);\nextern size_t escape_string_for_mysql(CHARSET_INFO *charset_info,\n                                      char *to, size_t to_length,\n                                      const char *from, size_t length);\n#ifdef __WIN__\n#define BACKSLASH_MBTAIL\n/* File system character set */\nextern CHARSET_INFO *fs_character_set(void);\n#endif\nextern size_t escape_quotes_for_mysql(CHARSET_INFO *charset_info,\n                                      char *to, size_t to_length,\n                                      const char *from, size_t length);\n\nextern void thd_increment_bytes_sent(ulong length);\nextern void thd_increment_bytes_received(ulong length);\nextern void thd_increment_net_big_packet_count(ulong length);\n\n#ifdef __WIN__\nextern my_bool have_tcpip;\t\t/* Is set if tcpip is used */\n\n/* implemented in my_windac.c */\n\nint my_security_attr_create(SECURITY_ATTRIBUTES **psa, const char **perror,\n                            DWORD owner_rights, DWORD everybody_rights);\n\nvoid my_security_attr_free(SECURITY_ATTRIBUTES *sa);\n\n/* implemented in my_conio.c */\nchar* my_cgets(char *string, size_t clen, size_t* plen);\n\n#endif\n\n#include <mysql/psi/psi.h>\n\n#ifdef HAVE_PSI_INTERFACE\nextern MYSQL_PLUGIN_IMPORT struct PSI_bootstrap *PSI_hook;\nvoid my_init_mysys_psi_keys(void);\n#endif\n\nstruct st_mysql_file;\nextern struct st_mysql_file *mysql_stdin;\n\nC_MODE_END\n#endif /* _my_sys_h */\n", "/*\n   Copyright (c) 2000, 2010, Oracle and/or its affiliates\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include \"mysys_priv.h\"\n#include \"mysys_err.h\"\n#include <my_dir.h>\n#include <m_string.h>\n#include \"mysys_err.h\"\n#if defined(HAVE_UTIME_H)\n#include <utime.h>\n#elif defined(HAVE_SYS_UTIME_H)\n#include <sys/utime.h>\n#elif !defined(HPUX10)\nstruct utimbuf {\n  time_t actime;\n  time_t modtime;\n};\n#endif\n\n\t/*\n\t  Rename with copy stat form old file\n\t  Copy stats from old file to new file, deletes orginal and\n\t  changes new file name to old file name\n\n\t  if MY_REDEL_MAKE_COPY is given, then the orginal file\n\t  is renamed to org_name-'current_time'.BAK\n\t*/\n\n#define REDEL_EXT \".BAK\"\n\nint my_redel(const char *org_name, const char *tmp_name,\n             time_t backup_time_stamp, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH];    \n    my_create_backup_name(name_buff, org_name, backup_time_stamp);\n    if (my_rename(org_name, name_buff, MyFlags))\n      goto end;\n  }\n  else if (my_delete(org_name, MyFlags))\n      goto end;\n  if (my_rename(tmp_name,org_name,MyFlags))\n    goto end;\n\n  error=0;\nend:\n  DBUG_RETURN(error);\n} /* my_redel */\n\n\n/**\n   Copy stat from one file to another\n   @fn     my_copystat()\n   @param  from\t\tCopy stat from this file\n   @param  to           Copy stat to this file\n   @param  MyFlags      Flags:\n\t\t        MY_WME    Give error if something goes wrong\n\t\t        MY_FAE    Abort operation if something goes wrong\n                        If MY_FAE is not given, we don't return -1 for\n                        errors from chown (which normally require root\n                        privilege)\n\n  @return  0 ok\n          -1 if can't get stat,\n           1 if wrong type of file\n*/\n\nint my_copystat(const char *from, const char *to, int MyFlags)\n{\n  MY_STAT statbuf;\n\n  if (my_stat(from, &statbuf, MyFlags) == NULL)\n    return -1;\t\t\t\t/* Can't get stat on input file */\n\n  if ((statbuf.st_mode & S_IFMT) != S_IFREG)\n    return 1;\n\n  /* Copy modes */\n  if (chmod(to, statbuf.st_mode & 07777))\n  {\n    my_errno= errno;\n    if (MyFlags & (MY_FAE+MY_WME))\n      my_error(EE_CHANGE_PERMISSIONS, MYF(ME_BELL+ME_WAITTANG), from, errno);\n    return -1;\n  }\n\n#if !defined(__WIN__)\n  if (statbuf.st_nlink > 1 && MyFlags & MY_LINK_WARNING)\n  {\n    if (MyFlags & MY_LINK_WARNING)\n      my_error(EE_LINK_WARNING,MYF(ME_BELL+ME_WAITTANG),from,statbuf.st_nlink);\n  }\n  /* Copy ownership */\n  if (chown(to, statbuf.st_uid, statbuf.st_gid))\n  {\n    my_errno= errno;\n    if (MyFlags & MY_WME)\n      my_error(EE_CHANGE_OWNERSHIP, MYF(ME_BELL+ME_WAITTANG), from, errno);\n    if (MyFlags & MY_FAE)\n      return -1;\n  }\n#endif /* !__WIN__ */\n\n  if (MyFlags & MY_COPYTIME)\n  {\n    struct utimbuf timep;\n    timep.actime  = statbuf.st_atime;\n    timep.modtime = statbuf.st_mtime;\n    (void) utime((char*) to, &timep);/* Update last accessed and modified times */\n  }\n\n  return 0;\n} /* my_copystat */\n\n\n/**\n   Create a backup file name.\n   @fn my_create_backup_name()\n   @param to\tStore new file name here\n   @param from  Original name\n\n   @info\n   The backup name is made by adding -YYMMDDHHMMSS.BAK to the file name\n*/\n\nvoid my_create_backup_name(char *to, const char *from, time_t backup_start)\n{\n  char ext[MY_BACKUP_NAME_EXTRA_LENGTH+1];\n  ext[0]='-';\n  get_date(ext+1, GETDATE_SHORT_DATE | GETDATE_HHMMSSTIME, backup_start);\n  strmov(strend(ext),REDEL_EXT);\n  strmov(strmov(to, from), ext);\n}\n", "/*\n   Copyright (c) 2000-2008 MySQL AB, 2009 Sun Microsystems, Inc.\n   Use is subject to license terms.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/*\n  Static variables for mysys library. All definied here for easy making of\n  a shared library\n*/\n\n#include \"mysys_priv.h\"\n#include \"my_static.h\"\n#include \"my_alarm.h\"\n\nmy_bool timed_mutexes= 0;\n\n\t/* from my_init */\nchar *\thome_dir=0;\nchar *mysql_data_home= (char*) \".\";\nconst char      *my_progname= NULL, *my_progname_short= NULL;\nchar\t\tcurr_dir[FN_REFLEN]= {0},\n\t\thome_dir_buff[FN_REFLEN]= {0};\nulong\t\tmy_stream_opened=0,my_file_opened=0, my_tmp_file_created=0;\nulong           my_file_total_opened= 0;\nint\t\tmy_umask=0664, my_umask_dir=0777;\n\nmyf             my_global_flags= 0;\nmy_bool         my_assert_on_error= 0;\nstruct st_my_file_info my_file_info_default[MY_NFILE];\nuint   my_file_limit= MY_NFILE;\nstruct st_my_file_info *my_file_info= my_file_info_default;\n\n\t/* From mf_brkhant */\nint\t\t\tmy_dont_interrupt=0;\nvolatile int\t\t_my_signals=0;\nstruct st_remember _my_sig_remember[MAX_SIGNALS]={{0,0}};\n\n\t/* from mf_reccache.c */\nulong my_default_record_cache_size=RECORD_CACHE_SIZE;\n\n\t/* from soundex.c */\n\t\t\t\t/* ABCDEFGHIJKLMNOPQRSTUVWXYZ */\n\t\t\t\t/* :::::::::::::::::::::::::: */\nconst char *soundex_map=\t  \"01230120022455012623010202\";\n\n\t/* from my_malloc */\nUSED_MEM* my_once_root_block=0;\t\t\t/* pointer to first block */\nuint\t  my_once_extra=ONCE_ALLOC_INIT;\t/* Memory to alloc / block */\n\n\t/* from my_largepage.c */\n#ifdef HAVE_LARGE_PAGES\nmy_bool my_use_large_pages= 0;\nuint    my_large_page_size= 0;\n#endif\n\n\t/* from my_alarm */\nint volatile my_have_got_alarm=0;\t/* declare variable to reset */\nulong my_time_to_wait_for_lock=2;\t/* In seconds */\n\n\t/* from errors.c */\n#ifdef SHARED_LIBRARY\nconst char *globerrs[GLOBERRS];\t\t/* my_error_messages is here */\n#endif\nvoid (*my_abort_hook)(int) = (void(*)(int)) exit;\nvoid (*error_handler_hook)(uint error, const char *str, myf MyFlags)=\n  my_message_stderr;\nvoid (*fatal_error_handler_hook)(uint error, const char *str, myf MyFlags)=\n  my_message_stderr;\n\nstatic const char *proc_info_dummy(void *a __attribute__((unused)),\n                                   const char *b __attribute__((unused)),\n                                   const char *c __attribute__((unused)),\n                                   const char *d __attribute__((unused)),\n                                   const unsigned int e __attribute__((unused)))\n{\n  return 0;\n}\n\n/* this is to be able to call set_thd_proc_info from the C code */\nconst char *(*proc_info_hook)(void *, const char *, const char *, const char *,\n                              const unsigned int)= proc_info_dummy;\nvoid (*debug_sync_C_callback_ptr)(MYSQL_THD, const char *, size_t)= 0;\n\n\t/* How to disable options */\nmy_bool my_disable_locking=0;\nmy_bool my_disable_sync=0;\nmy_bool my_disable_async_io=0;\nmy_bool my_disable_flush_key_blocks=0;\nmy_bool my_disable_symlinks=0;\n\n/*\n  Note that PSI_hook and PSI_server are unconditionally\n  (no ifdef HAVE_PSI_INTERFACE) defined.\n  This is to ensure binary compatibility between the server and plugins,\n  in the case when:\n  - the server is not compiled with HAVE_PSI_INTERFACE\n  - a plugin is compiled with HAVE_PSI_INTERFACE\n  See the doxygen documentation for the performance schema.\n*/\n\n/**\n  Hook for the instrumentation interface.\n  Code implementing the instrumentation interface should register here.\n*/\nstruct PSI_bootstrap *PSI_hook= NULL;\n\n/**\n  Instance of the instrumentation interface for the MySQL server.\n  @todo This is currently a global variable, which is handy when\n  compiling instrumented code that is bundled with the server.\n  When dynamic plugin are truly supported, this variable will need\n  to be replaced by a macro, so that each XYZ plugin can have it's own\n  xyz_psi_server variable, obtained from PSI_bootstrap::get_interface()\n  with the version used at compile time for plugin XYZ.\n*/\nPSI *PSI_server= NULL;\n\n", "/* Copyright (c) 2000, 2015, Oracle and/or its affiliates.\n   Copyright (c) 2008, 2015, SkySQL Ab.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n#include \"my_global.h\"                          /* NO_EMBEDDED_ACCESS_CHECKS */\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include <signal.h>\n#ifndef __WIN__\n#include <netdb.h>        // getservbyname, servent\n#endif\n#include \"sql_parse.h\"    // test_if_data_home_dir\n#include \"sql_cache.h\"    // query_cache, query_cache_*\n#include \"sql_locale.h\"   // MY_LOCALES, my_locales, my_locale_by_name\n#include \"sql_show.h\"     // free_status_vars, add_status_vars,\n                          // reset_status_vars\n#include \"strfunc.h\"      // find_set_from_flags\n#include \"parse_file.h\"   // File_parser_dummy_hook\n#include \"sql_db.h\"       // my_dboptions_cache_free\n                          // my_dboptions_cache_init\n#include \"sql_table.h\"    // release_ddl_log, execute_ddl_log_recovery\n#include \"sql_connect.h\"  // free_max_user_conn, init_max_user_conn,\n                          // handle_one_connection\n#include \"sql_time.h\"     // known_date_time_formats,\n                          // get_date_time_format_str,\n                          // date_time_format_make\n#include \"tztime.h\"       // my_tz_free, my_tz_init, my_tz_SYSTEM\n#include \"hostname.h\"     // hostname_cache_free, hostname_cache_init\n#include \"sql_acl.h\"      // acl_free, grant_free, acl_init,\n                          // grant_init\n#include \"sql_base.h\"     // table_def_free, table_def_init,\n                          // cached_open_tables,\n                          // cached_table_definitions\n#include \"sql_test.h\"     // mysql_print_status\n#include \"item_create.h\"  // item_create_cleanup, item_create_init\n#include \"sql_servers.h\"  // servers_free, servers_init\n#include \"init.h\"         // unireg_init\n#include \"derror.h\"       // init_errmessage\n#include \"derror.h\"       // init_errmessage\n#include \"des_key_file.h\" // load_des_key_file\n#include \"sql_manager.h\"  // stop_handle_manager, start_handle_manager\n#include \"sql_expression_cache.h\" // subquery_cache_miss, subquery_cache_hit\n\n#include <m_ctype.h>\n#include <my_dir.h>\n#include <my_bit.h>\n#include \"slave.h\"\n#include \"rpl_mi.h\"\n#include \"sql_repl.h\"\n#include \"rpl_filter.h\"\n#include \"client_settings.h\"\n#include \"repl_failsafe.h\"\n#include <sql_common.h>\n#include <my_stacktrace.h>\n#include \"mysqld_suffix.h\"\n#include \"mysys_err.h\"\n#include \"events.h\"\n#include \"sql_audit.h\"\n#include \"probes_mysql.h\"\n#include \"scheduler.h\"\n#include <waiting_threads.h>\n#include \"debug_sync.h\"\n#include \"sql_callback.h\"\n#include \"threadpool.h\"\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#include \"keycaches.h\"\n#include \"../storage/myisam/ha_myisam.h\"\n#include \"set_var.h\"\n\n#include \"rpl_injector.h\"\n\n#include \"rpl_handler.h\"\n\n#ifdef HAVE_SYS_PRCTL_H\n#include <sys/prctl.h>\n#endif\n\n#include <thr_alarm.h>\n#include <ft_global.h>\n#include <errmsg.h>\n#include \"sp_rcontext.h\"\n#include \"sp_cache.h\"\n#include \"sql_reload.h\"  // reload_acl_and_cache\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n\n#define mysqld_charset &my_charset_latin1\n\n/* We have HAVE_valgrind below as this speeds up the shutdown of MySQL */\n\n#if defined(SIGNALS_DONT_BREAK_READ) || defined(HAVE_valgrind) && defined(__linux__)\n#define HAVE_CLOSE_SERVER_SOCK 1\n#endif\n\nextern \"C\" {\t\t\t\t\t// Because of SCO 3.2V4.2\n#include <errno.h>\n#include <sys/stat.h>\n#ifndef __GNU_LIBRARY__\n#define __GNU_LIBRARY__\t\t\t\t// Skip warnings in getopt.h\n#endif\n#include <my_getopt.h>\n#ifdef HAVE_SYSENT_H\n#include <sysent.h>\n#endif\n#ifdef HAVE_PWD_H\n#include <pwd.h>\t\t\t\t// For getpwent\n#endif\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#include <my_net.h>\n\n#if !defined(__WIN__)\n#include <sys/resource.h>\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n#ifdef HAVE_SELECT_H\n#include <select.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <sys/utsname.h>\n#endif /* __WIN__ */\n\n#include <my_libwrap.h>\n\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n\n#ifdef __WIN__ \n#include <crtdbg.h>\n#endif\n\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#include <sys/mman.h>\n#if defined(__sun__) && defined(__GNUC__) && defined(__cplusplus) \\\n    && defined(_XOPEN_SOURCE)\nextern int getpagesizes(size_t *, int);\nextern int getpagesizes2(size_t *, int);\nextern int memcntl(caddr_t, size_t, int, caddr_t, int, int);\n#endif /* __sun__ ... */\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n#ifdef _AIX41\nint initgroups(const char *,unsigned int);\n#endif\n\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n#include <ieeefp.h>\n#ifdef HAVE_FP_EXCEPT\t\t\t\t// Fix type conflict\ntypedef fp_except fp_except_t;\n#endif\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n#ifdef HAVE_SYS_FPU_H\n/* for IRIX to use set_fpc_csr() */\n#include <sys/fpu.h>\n#endif\n#ifdef HAVE_FPU_CONTROL_H\n#include <fpu_control.h>\n#endif\n#if defined(__i386__) && !defined(HAVE_FPU_CONTROL_H)\n# define fpu_control_t unsigned int\n# define _FPU_EXTENDED 0x300\n# define _FPU_DOUBLE 0x200\n# if defined(__GNUC__) || (defined(__SUNPRO_CC) && __SUNPRO_CC >= 0x590)\n#  define _FPU_GETCW(cw) asm volatile (\"fnstcw %0\" : \"=m\" (*&cw))\n#  define _FPU_SETCW(cw) asm volatile (\"fldcw %0\" : : \"m\" (*&cw))\n# else\n#  define _FPU_GETCW(cw) (cw= 0)\n#  define _FPU_SETCW(cw)\n# endif\n#endif\n\n#ifndef HAVE_FCNTL\n#define fcntl(X,Y,Z) 0\n#endif\n\nextern \"C\" my_bool reopen_fstreams(const char *filename,\n                                   FILE *outstream, FILE *errstream);\n\ninline void setup_fpu()\n{\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n  /* We can't handle floating point exceptions with threads, so disable\n     this on freebsd\n     Don't fall for overflow, underflow,divide-by-zero or loss of precision.\n     fpsetmask() is deprecated in favor of fedisableexcept() in C99.\n  */\n#if defined(FP_X_DNML)\n  fpsetmask(~(FP_X_INV | FP_X_DNML | FP_X_OFL | FP_X_UFL | FP_X_DZ |\n\t      FP_X_IMP));\n#else\n  fpsetmask(~(FP_X_INV |             FP_X_OFL | FP_X_UFL | FP_X_DZ |\n              FP_X_IMP));\n#endif /* FP_X_DNML */\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n\n#ifdef HAVE_FEDISABLEEXCEPT\n  fedisableexcept(FE_ALL_EXCEPT);\n#endif\n\n#ifdef HAVE_FESETROUND\n    /* Set FPU rounding mode to \"round-to-nearest\" */\n  fesetround(FE_TONEAREST);\n#endif /* HAVE_FESETROUND */\n\n  /*\n    x86 (32-bit) requires FPU precision to be explicitly set to 64 bit\n    (double precision) for portable results of floating point operations.\n    However, there is no need to do so if compiler is using SSE2 for floating\n    point, double values will be stored and processed in 64 bits anyway.\n  */\n#if defined(__i386__) && !defined(__SSE2_MATH__)\n#if defined(_WIN32)\n#if !defined(_WIN64)\n  _control87(_PC_53, MCW_PC);\n#endif /* !_WIN64 */\n#else /* !_WIN32 */\n  fpu_control_t cw;\n  _FPU_GETCW(cw);\n  cw= (cw & ~_FPU_EXTENDED) | _FPU_DOUBLE;\n  _FPU_SETCW(cw);\n#endif /* _WIN32 && */\n#endif /* __i386__ */\n\n#if defined(__sgi) && defined(HAVE_SYS_FPU_H)\n  /* Enable denormalized DOUBLE values support for IRIX */\n  union fpc_csr n;\n  n.fc_word = get_fpc_csr();\n  n.fc_struct.flush = 0;\n  set_fpc_csr(n.fc_word);\n#endif\n}\n\n} /* cplusplus */\n\n#define MYSQL_KILL_SIGNAL SIGTERM\n\n#include <my_pthread.h>\t\t\t// For thr_setconcurency()\n\n#ifdef SOLARIS\nextern \"C\" int gethostname(char *name, int namelen);\n#endif\n\nextern \"C\" sig_handler handle_fatal_signal(int sig);\n\n#if defined(__linux__)\n#define ENABLE_TEMP_POOL 1\n#else\n#define ENABLE_TEMP_POOL 0\n#endif\n\n/* Constants */\n\n#include <welcome_copyright_notice.h> // ORACLE_WELCOME_COPYRIGHT_NOTICE\n\nconst char *show_comp_option_name[]= {\"YES\", \"NO\", \"DISABLED\"};\n\nstatic const char *tc_heuristic_recover_names[]=\n{\n  \"OFF\", \"COMMIT\", \"ROLLBACK\", NullS\n};\nstatic TYPELIB tc_heuristic_recover_typelib=\n{\n  array_elements(tc_heuristic_recover_names)-1,\"\",\n  tc_heuristic_recover_names, NULL\n};\n\nconst char *first_keyword= \"first\", *binary_keyword= \"BINARY\";\nconst char *my_localhost= \"localhost\", *delayed_user= \"DELAYED\";\n\nbool opt_large_files= sizeof(my_off_t) > 4;\nstatic my_bool opt_autocommit; ///< for --autocommit command-line option\n\n/*\n  Used with --help for detailed option\n*/\nstatic my_bool opt_verbose= 0;\n\narg_cmp_func Arg_comparator::comparator_matrix[6][2] =\n{{&Arg_comparator::compare_string,     &Arg_comparator::compare_e_string},\n {&Arg_comparator::compare_real,       &Arg_comparator::compare_e_real},\n {&Arg_comparator::compare_int_signed, &Arg_comparator::compare_e_int},\n {&Arg_comparator::compare_row,        &Arg_comparator::compare_e_row},\n {&Arg_comparator::compare_decimal,    &Arg_comparator::compare_e_decimal},\n {&Arg_comparator::compare_datetime,   &Arg_comparator::compare_e_datetime}};\n\n/* static variables */\n\n#ifdef HAVE_PSI_INTERFACE\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_namedpipes;\nstatic PSI_cond_key key_COND_handler_count;\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if defined(HAVE_SMEM) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_sharedmem;\n#endif /* HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_sockets;\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#ifdef __WIN__\nstatic PSI_thread_key key_thread_handle_shutdown;\n#endif /* __WIN__ */\n\n#if defined (HAVE_OPENSSL) && !defined(HAVE_YASSL)\nstatic PSI_rwlock_key key_rwlock_openssl;\n#endif\n#endif /* HAVE_PSI_INTERFACE */\n\n#ifdef HAVE_NPTL\nvolatile sig_atomic_t ld_assume_kernel_is_set= 0;\n#endif\n\n/* the default log output is log tables */\nstatic bool lower_case_table_names_used= 0;\nstatic bool max_long_data_size_used= false;\nstatic bool volatile select_thread_in_use, signal_thread_in_use;\nstatic volatile bool ready_to_exit;\nstatic my_bool opt_debugging= 0, opt_external_locking= 0, opt_console= 0;\nstatic my_bool opt_short_log_format= 0;\nstatic uint kill_cached_threads, wake_thread;\nulong max_used_connections;\nstatic volatile ulong cached_thread_count= 0;\nstatic char *mysqld_user, *mysqld_chroot;\nstatic char *default_character_set_name;\nstatic char *character_set_filesystem_name;\nstatic char *lc_messages;\nstatic char *lc_time_names_name;\nstatic char *my_bind_addr_str;\nstatic char *default_collation_name;\nchar *default_storage_engine;\nstatic char compiled_default_collation_name[]= MYSQL_DEFAULT_COLLATION_NAME;\nstatic I_List<THD> thread_cache;\nstatic bool binlog_format_used= false;\nLEX_STRING opt_init_connect, opt_init_slave;\nstatic mysql_cond_t COND_thread_cache, COND_flush_thread_cache;\nstatic DYNAMIC_ARRAY all_options;\n\n/* Global variables */\n\nbool opt_bin_log, opt_bin_log_used=0, opt_ignore_builtin_innodb= 0;\nmy_bool opt_log, opt_slow_log, debug_assert_if_crashed_table= 0, opt_help= 0;\nstatic my_bool opt_abort;\nulonglong log_output_options;\nmy_bool opt_userstat_running;\nmy_bool opt_log_queries_not_using_indexes= 0;\nbool opt_error_log= IF_WIN(1,0);\nbool opt_disable_networking=0, opt_skip_show_db=0;\nbool opt_skip_name_resolve=0;\nmy_bool opt_character_set_client_handshake= 1;\nbool server_id_supplied = 0;\nbool opt_endinfo, using_udf_functions;\nmy_bool locked_in_memory;\nbool opt_using_transactions;\nbool volatile abort_loop;\nbool volatile shutdown_in_progress;\nuint volatile global_disable_checkpoint;\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\nulong slow_start_timeout;\n#endif\n/*\n  True if the bootstrap thread is running. Protected by LOCK_thread_count,\n  just like thread_count.\n  Used in bootstrap() function to determine if the bootstrap thread\n  has completed. Note, that we can't use 'thread_count' instead,\n  since in 5.1, in presence of the Event Scheduler, there may be\n  event threads running in parallel, so it's impossible to know\n  what value of 'thread_count' is a sign of completion of the\n  bootstrap thread.\n\n  At the same time, we can't start the event scheduler after\n  bootstrap either, since we want to be able to process event-related\n  SQL commands in the init file and in --bootstrap mode.\n*/\nbool in_bootstrap= FALSE;\n/**\n   @brief 'grant_option' is used to indicate if privileges needs\n   to be checked, in which case the lock, LOCK_grant, is used\n   to protect access to the grant table.\n   @note This flag is dropped in 5.1\n   @see grant_init()\n */\nbool volatile grant_option;\n\nmy_bool opt_skip_slave_start = 0; ///< If set, slave is not autostarted\nmy_bool opt_reckless_slave = 0;\nmy_bool opt_enable_named_pipe= 0;\nmy_bool opt_local_infile, opt_slave_compressed_protocol;\nmy_bool opt_safe_user_create = 0;\nmy_bool opt_show_slave_auth_info;\nmy_bool opt_log_slave_updates= 0;\nmy_bool opt_replicate_annotate_row_events= 0;\nchar *opt_slave_skip_errors;\n\n/*\n  Legacy global handlerton. These will be removed (please do not add more).\n*/\nhandlerton *heap_hton;\nhandlerton *myisam_hton;\nhandlerton *partition_hton;\n\nmy_bool read_only= 0, opt_readonly= 0;\nmy_bool use_temp_pool, relay_log_purge;\nmy_bool relay_log_recovery;\nmy_bool opt_sync_frm, opt_allow_suspicious_udfs;\nmy_bool opt_secure_auth= 0;\nchar* opt_secure_file_priv;\nmy_bool opt_log_slow_admin_statements= 0;\nmy_bool opt_log_slow_slave_statements= 0;\nmy_bool lower_case_file_system= 0;\nmy_bool opt_large_pages= 0;\nmy_bool opt_super_large_pages= 0;\nmy_bool opt_myisam_use_mmap= 0;\nuint   opt_large_page_size= 0;\n#if defined(ENABLED_DEBUG_SYNC)\nMYSQL_PLUGIN_IMPORT uint    opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\nmy_bool opt_old_style_user_limits= 0, trust_function_creators= 0;\nulong opt_replicate_events_marked_for_skip;\n\n/*\n  True if there is at least one per-hour limit for some user, so we should\n  check them before each query (and possibly reset counters when hour is\n  changed). False otherwise.\n*/\nvolatile bool mqh_used = 0;\nmy_bool opt_noacl;\nmy_bool sp_automatic_privileges= 1;\n\nulong opt_binlog_rows_event_max_size;\nmy_bool opt_master_verify_checksum= 0;\nmy_bool opt_slave_sql_verify_checksum= 1;\nconst char *binlog_format_names[]= {\"MIXED\", \"STATEMENT\", \"ROW\", NullS};\n#ifdef HAVE_INITGROUPS\nvolatile sig_atomic_t calling_initgroups= 0; /**< Used in SIGSEGV handler. */\n#endif\nuint mysqld_port, test_flags, select_errors, dropping_tables, ha_open_options;\nuint mysqld_extra_port;\nuint mysqld_port_timeout;\nulong delay_key_write_options;\nuint protocol_version;\nuint lower_case_table_names;\nulong tc_heuristic_recover= 0;\nuint volatile thread_count;\nint32 thread_running;\nulong thread_created;\nulong back_log, connect_timeout, concurrency, server_id;\nulong table_cache_size, table_def_size;\nulong what_to_log;\nulong slow_launch_time, slave_open_temp_tables;\nulong open_files_limit, max_binlog_size, max_relay_log_size;\nulong slave_trans_retries;\nuint  slave_net_timeout;\nulong slave_exec_mode_options;\nulonglong slave_type_conversions_options;\nulong thread_cache_size=0;\nulonglong binlog_cache_size=0;\nulonglong max_binlog_cache_size=0;\nulong slave_max_allowed_packet= 0;\nulonglong binlog_stmt_cache_size=0;\nulonglong  max_binlog_stmt_cache_size=0;\nulonglong query_cache_size=0;\nulong refresh_version;  /* Increments on each reload */\nulong executed_events=0;\nquery_id_t global_query_id;\nmy_atomic_rwlock_t global_query_id_lock;\nmy_atomic_rwlock_t thread_running_lock;\nulong aborted_threads, aborted_connects;\nulong delayed_insert_timeout, delayed_insert_limit, delayed_queue_size;\nulong delayed_insert_threads, delayed_insert_writes, delayed_rows_in_use;\nulong delayed_insert_errors,flush_time;\nulong specialflag=0;\nulong binlog_cache_use= 0, binlog_cache_disk_use= 0;\nulong binlog_stmt_cache_use= 0, binlog_stmt_cache_disk_use= 0;\nulong max_connections, max_connect_errors;\nulong extra_max_connections;\nulonglong denied_connections;\nmy_decimal decimal_zero;\n\n/*\n  Maximum length of parameter value which can be set through\n  mysql_send_long_data() call.\n*/\nulong max_long_data_size;\n\n/* Limits for internal temporary tables (MyISAM or Aria) */\nuint internal_tmp_table_max_key_length;\nuint internal_tmp_table_max_key_segments;\n\nbool max_user_connections_checking=0;\n/**\n  Limit of the total number of prepared statements in the server.\n  Is necessary to protect the server against out-of-memory attacks.\n*/\nulong max_prepared_stmt_count;\n/**\n  Current total number of prepared statements in the server. This number\n  is exact, and therefore may not be equal to the difference between\n  `com_stmt_prepare' and `com_stmt_close' (global status variables), as\n  the latter ones account for all registered attempts to prepare\n  a statement (including unsuccessful ones).  Prepared statements are\n  currently connection-local: if the same SQL query text is prepared in\n  two different connections, this counts as two distinct prepared\n  statements.\n*/\nulong prepared_stmt_count=0;\nulong thread_id=1L,current_pid;\nulong slow_launch_threads = 0;\nuint sync_binlog_period= 0, sync_relaylog_period= 0,\n     sync_relayloginfo_period= 0, sync_masterinfo_period= 0;\nulong expire_logs_days = 0;\nulong rpl_recovery_rank=0;\n/**\n  Soft upper limit for number of sp_head objects that can be stored\n  in the sp_cache for one connection.\n*/\nulong stored_program_cache_size= 0;\n\nconst double log_10[] = {\n  1e000, 1e001, 1e002, 1e003, 1e004, 1e005, 1e006, 1e007, 1e008, 1e009,\n  1e010, 1e011, 1e012, 1e013, 1e014, 1e015, 1e016, 1e017, 1e018, 1e019,\n  1e020, 1e021, 1e022, 1e023, 1e024, 1e025, 1e026, 1e027, 1e028, 1e029,\n  1e030, 1e031, 1e032, 1e033, 1e034, 1e035, 1e036, 1e037, 1e038, 1e039,\n  1e040, 1e041, 1e042, 1e043, 1e044, 1e045, 1e046, 1e047, 1e048, 1e049,\n  1e050, 1e051, 1e052, 1e053, 1e054, 1e055, 1e056, 1e057, 1e058, 1e059,\n  1e060, 1e061, 1e062, 1e063, 1e064, 1e065, 1e066, 1e067, 1e068, 1e069,\n  1e070, 1e071, 1e072, 1e073, 1e074, 1e075, 1e076, 1e077, 1e078, 1e079,\n  1e080, 1e081, 1e082, 1e083, 1e084, 1e085, 1e086, 1e087, 1e088, 1e089,\n  1e090, 1e091, 1e092, 1e093, 1e094, 1e095, 1e096, 1e097, 1e098, 1e099,\n  1e100, 1e101, 1e102, 1e103, 1e104, 1e105, 1e106, 1e107, 1e108, 1e109,\n  1e110, 1e111, 1e112, 1e113, 1e114, 1e115, 1e116, 1e117, 1e118, 1e119,\n  1e120, 1e121, 1e122, 1e123, 1e124, 1e125, 1e126, 1e127, 1e128, 1e129,\n  1e130, 1e131, 1e132, 1e133, 1e134, 1e135, 1e136, 1e137, 1e138, 1e139,\n  1e140, 1e141, 1e142, 1e143, 1e144, 1e145, 1e146, 1e147, 1e148, 1e149,\n  1e150, 1e151, 1e152, 1e153, 1e154, 1e155, 1e156, 1e157, 1e158, 1e159,\n  1e160, 1e161, 1e162, 1e163, 1e164, 1e165, 1e166, 1e167, 1e168, 1e169,\n  1e170, 1e171, 1e172, 1e173, 1e174, 1e175, 1e176, 1e177, 1e178, 1e179,\n  1e180, 1e181, 1e182, 1e183, 1e184, 1e185, 1e186, 1e187, 1e188, 1e189,\n  1e190, 1e191, 1e192, 1e193, 1e194, 1e195, 1e196, 1e197, 1e198, 1e199,\n  1e200, 1e201, 1e202, 1e203, 1e204, 1e205, 1e206, 1e207, 1e208, 1e209,\n  1e210, 1e211, 1e212, 1e213, 1e214, 1e215, 1e216, 1e217, 1e218, 1e219,\n  1e220, 1e221, 1e222, 1e223, 1e224, 1e225, 1e226, 1e227, 1e228, 1e229,\n  1e230, 1e231, 1e232, 1e233, 1e234, 1e235, 1e236, 1e237, 1e238, 1e239,\n  1e240, 1e241, 1e242, 1e243, 1e244, 1e245, 1e246, 1e247, 1e248, 1e249,\n  1e250, 1e251, 1e252, 1e253, 1e254, 1e255, 1e256, 1e257, 1e258, 1e259,\n  1e260, 1e261, 1e262, 1e263, 1e264, 1e265, 1e266, 1e267, 1e268, 1e269,\n  1e270, 1e271, 1e272, 1e273, 1e274, 1e275, 1e276, 1e277, 1e278, 1e279,\n  1e280, 1e281, 1e282, 1e283, 1e284, 1e285, 1e286, 1e287, 1e288, 1e289,\n  1e290, 1e291, 1e292, 1e293, 1e294, 1e295, 1e296, 1e297, 1e298, 1e299,\n  1e300, 1e301, 1e302, 1e303, 1e304, 1e305, 1e306, 1e307, 1e308\n};\n\ntime_t server_start_time, flush_status_time;\n\nchar mysql_home[FN_REFLEN], pidfile_name[FN_REFLEN], system_time_zone[30];\nchar *default_tz_name;\nchar log_error_file[FN_REFLEN], glob_hostname[FN_REFLEN], *opt_log_basename;\nchar mysql_real_data_home[FN_REFLEN],\n     lc_messages_dir[FN_REFLEN], reg_ext[FN_EXTLEN],\n     mysql_charsets_dir[FN_REFLEN],\n     *opt_init_file, *opt_tc_log_file;\nchar *lc_messages_dir_ptr= lc_messages_dir, *log_error_file_ptr;\nchar mysql_unpacked_real_data_home[FN_REFLEN];\nint mysql_unpacked_real_data_home_len;\nuint mysql_real_data_home_len, mysql_data_home_len= 1;\nuint reg_ext_length;\nconst key_map key_map_empty(0);\nkey_map key_map_full(0);                        // Will be initialized later\n\nDATE_TIME_FORMAT global_date_format, global_datetime_format, global_time_format;\nTime_zone *default_tz;\n\nconst char *mysql_real_data_home_ptr= mysql_real_data_home;\nchar server_version[SERVER_VERSION_LENGTH];\nchar *mysqld_unix_port, *opt_mysql_tmpdir;\nulong thread_handling;\n\n/** name of reference on left expression in rewritten IN subquery */\nconst char *in_left_expr_name= \"<left expr>\";\n/** name of additional condition */\nconst char *in_additional_cond= \"<IN COND>\";\nconst char *in_having_cond= \"<IN HAVING>\";\n\n/* classes for comparation parsing/processing */\nEq_creator eq_creator;\nNe_creator ne_creator;\nGt_creator gt_creator;\nLt_creator lt_creator;\nGe_creator ge_creator;\nLe_creator le_creator;\n\nMYSQL_FILE *bootstrap_file;\nint bootstrap_error;\n\nI_List<THD> threads;\nRpl_filter* rpl_filter;\nRpl_filter* binlog_filter;\n\nTHD *first_global_thread()\n{\n  if (threads.is_empty())\n    return NULL;\n  return threads.head();\n}\n\nTHD *next_global_thread(THD *thd)\n{\n  if (threads.is_last(thd))\n    return NULL;\n  struct ilink *next= thd->next;\n  return static_cast<THD*>(next);\n}\n\nstruct system_variables global_system_variables;\nstruct system_variables max_system_variables;\nstruct system_status_var global_status_var;\n\nMY_TMPDIR mysql_tmpdir_list;\nMY_BITMAP temp_pool;\n\nCHARSET_INFO *system_charset_info, *files_charset_info ;\nCHARSET_INFO *national_charset_info, *table_alias_charset;\nCHARSET_INFO *character_set_filesystem;\nCHARSET_INFO *error_message_charset_info;\n\nMY_LOCALE *my_default_lc_messages;\nMY_LOCALE *my_default_lc_time_names;\n\nSHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen, have_query_cache;\nSHOW_COMP_OPTION have_geometry, have_rtree_keys;\nSHOW_COMP_OPTION have_crypt, have_compress;\nSHOW_COMP_OPTION have_profiling;\n\n/* Thread specific variables */\n\npthread_key(MEM_ROOT**,THR_MALLOC);\npthread_key(THD*, THR_THD);\nmysql_mutex_t LOCK_thread_count;\nmysql_mutex_t\n  LOCK_status, LOCK_error_log, LOCK_short_uuid_generator,\n  LOCK_delayed_insert, LOCK_delayed_status, LOCK_delayed_create,\n  LOCK_crypt,\n  LOCK_global_system_variables,\n  LOCK_user_conn, LOCK_slave_list, LOCK_active_mi,\n  LOCK_connection_count, LOCK_error_messages;\n\nmysql_mutex_t LOCK_stats, LOCK_global_user_client_stats,\n              LOCK_global_table_stats, LOCK_global_index_stats;\n\n/**\n  The below lock protects access to two global server variables:\n  max_prepared_stmt_count and prepared_stmt_count. These variables\n  set the limit and hold the current total number of prepared statements\n  in the server, respectively. As PREPARE/DEALLOCATE rate in a loaded\n  server may be fairly high, we need a dedicated lock.\n*/\nmysql_mutex_t LOCK_prepared_stmt_count;\n#ifdef HAVE_OPENSSL\nmysql_mutex_t LOCK_des_key_file;\n#endif\nmysql_rwlock_t LOCK_grant, LOCK_sys_init_connect, LOCK_sys_init_slave;\nmysql_rwlock_t LOCK_system_variables_hash;\nmysql_cond_t COND_thread_count;\npthread_t signal_thread;\npthread_attr_t connection_attrib;\nmysql_mutex_t LOCK_server_started;\nmysql_cond_t COND_server_started;\n\nint mysqld_server_started= 0;\n\nFile_parser_dummy_hook file_parser_dummy_hook;\n\n/* replication parameters, if master_host is not NULL, we are a slave */\nuint report_port= 0;\nulong master_retry_count=0;\nchar *master_info_file;\nchar *relay_log_info_file, *report_user, *report_password, *report_host;\nchar *opt_relay_logname = 0, *opt_relaylog_index_name=0;\nchar *opt_logname, *opt_slow_logname, *opt_bin_logname;\n\n/* Static variables */\n\nstatic volatile sig_atomic_t kill_in_progress;\nmy_bool opt_stack_trace;\nmy_bool opt_expect_abort= 0, opt_bootstrap= 0;\nstatic my_bool opt_myisam_log;\nstatic int cleanup_done;\nstatic ulong opt_specialflag;\nstatic char *opt_binlog_index_name;\nchar *mysql_home_ptr, *pidfile_name_ptr;\n/** Initial command line arguments (count), after load_defaults().*/\nstatic int defaults_argc;\n/**\n  Initial command line arguments (arguments), after load_defaults().\n  This memory is allocated by @c load_defaults() and should be freed\n  using @c free_defaults().\n  Do not modify defaults_argc / defaults_argv,\n  use remaining_argc / remaining_argv instead to parse the command\n  line arguments in multiple steps.\n*/\nstatic char **defaults_argv;\n/** Remaining command line arguments (count), filtered by handle_options().*/\nstatic int remaining_argc;\n/** Remaining command line arguments (arguments), filtered by handle_options().*/\nstatic char **remaining_argv;\n\nint orig_argc;\nchar **orig_argv;\n\n#ifdef HAVE_PSI_INTERFACE\n#ifdef HAVE_MMAP\nPSI_mutex_key key_PAGE_lock, key_LOCK_sync, key_LOCK_active, key_LOCK_pool;\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\nPSI_mutex_key key_LOCK_des_key_file;\n#endif /* HAVE_OPENSSL */\n\nPSI_mutex_key key_BINLOG_LOCK_index, key_BINLOG_LOCK_prep_xids,\n  key_delayed_insert_mutex, key_hash_filo_lock, key_LOCK_active_mi,\n  key_LOCK_connection_count, key_LOCK_crypt, key_LOCK_delayed_create,\n  key_LOCK_delayed_insert, key_LOCK_delayed_status, key_LOCK_error_log,\n  key_LOCK_gdl, key_LOCK_global_system_variables,\n  key_LOCK_manager,\n  key_LOCK_prepared_stmt_count,\n  key_LOCK_rpl_status, key_LOCK_server_started, key_LOCK_status,\n  key_LOCK_system_variables_hash, key_LOCK_table_share, key_LOCK_thd_data,\n  key_LOCK_user_conn, key_LOCK_uuid_short_generator, key_LOG_LOCK_log,\n  key_master_info_data_lock, key_master_info_run_lock,\n  key_master_info_sleep_lock,\n  key_mutex_slave_reporting_capability_err_lock, key_relay_log_info_data_lock,\n  key_relay_log_info_log_space_lock, key_relay_log_info_run_lock,\n  key_relay_log_info_sleep_lock,\n  key_structure_guard_mutex, key_TABLE_SHARE_LOCK_ha_data,\n  key_LOCK_error_messages, key_LOG_INFO_lock, key_LOCK_thread_count,\n  key_PARTITION_LOCK_auto_inc;\nPSI_mutex_key key_RELAYLOG_LOCK_index;\n\nPSI_mutex_key key_LOCK_stats,\n  key_LOCK_global_user_client_stats, key_LOCK_global_table_stats,\n  key_LOCK_global_index_stats,\n  key_LOCK_wakeup_ready;\n\nPSI_mutex_key key_LOCK_prepare_ordered, key_LOCK_commit_ordered;\n\nstatic PSI_mutex_info all_server_mutexes[]=\n{\n#ifdef HAVE_MMAP\n  { &key_PAGE_lock, \"PAGE::lock\", 0},\n  { &key_LOCK_sync, \"TC_LOG_MMAP::LOCK_sync\", 0},\n  { &key_LOCK_active, \"TC_LOG_MMAP::LOCK_active\", 0},\n  { &key_LOCK_pool, \"TC_LOG_MMAP::LOCK_pool\", 0},\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\n  { &key_LOCK_des_key_file, \"LOCK_des_key_file\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_OPENSSL */\n\n  { &key_BINLOG_LOCK_index, \"MYSQL_BIN_LOG::LOCK_index\", 0},\n  { &key_BINLOG_LOCK_prep_xids, \"MYSQL_BIN_LOG::LOCK_prep_xids\", 0},\n  { &key_RELAYLOG_LOCK_index, \"MYSQL_RELAY_LOG::LOCK_index\", 0},\n  { &key_delayed_insert_mutex, \"Delayed_insert::mutex\", 0},\n  { &key_hash_filo_lock, \"hash_filo::lock\", 0},\n  { &key_LOCK_active_mi, \"LOCK_active_mi\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_connection_count, \"LOCK_connection_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_crypt, \"LOCK_crypt\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_create, \"LOCK_delayed_create\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_insert, \"LOCK_delayed_insert\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_status, \"LOCK_delayed_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_error_log, \"LOCK_error_log\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_gdl, \"LOCK_gdl\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_system_variables, \"LOCK_global_system_variables\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_manager, \"LOCK_manager\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepared_stmt_count, \"LOCK_prepared_stmt_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_rpl_status, \"LOCK_rpl_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_server_started, \"LOCK_server_started\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_status, \"LOCK_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_table_share, \"LOCK_table_share\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_stats, \"LOCK_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_user_client_stats, \"LOCK_global_user_client_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_table_stats, \"LOCK_global_table_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_index_stats, \"LOCK_global_index_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_wakeup_ready, \"THD::LOCK_wakeup_ready\", 0},\n  { &key_LOCK_thd_data, \"THD::LOCK_thd_data\", 0},\n  { &key_LOCK_user_conn, \"LOCK_user_conn\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_uuid_short_generator, \"LOCK_uuid_short_generator\", PSI_FLAG_GLOBAL},\n  { &key_LOG_LOCK_log, \"LOG::LOCK_log\", 0},\n  { &key_master_info_data_lock, \"Master_info::data_lock\", 0},\n  { &key_master_info_run_lock, \"Master_info::run_lock\", 0},\n  { &key_master_info_sleep_lock, \"Master_info::sleep_lock\", 0},\n  { &key_mutex_slave_reporting_capability_err_lock, \"Slave_reporting_capability::err_lock\", 0},\n  { &key_relay_log_info_data_lock, \"Relay_log_info::data_lock\", 0},\n  { &key_relay_log_info_log_space_lock, \"Relay_log_info::log_space_lock\", 0},\n  { &key_relay_log_info_run_lock, \"Relay_log_info::run_lock\", 0},\n  { &key_relay_log_info_sleep_lock, \"Relay_log_info::sleep_lock\", 0},\n  { &key_structure_guard_mutex, \"Query_cache::structure_guard_mutex\", 0},\n  { &key_TABLE_SHARE_LOCK_ha_data, \"TABLE_SHARE::LOCK_ha_data\", 0},\n  { &key_LOCK_error_messages, \"LOCK_error_messages\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepare_ordered, \"LOCK_prepare_ordered\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_commit_ordered, \"LOCK_commit_ordered\", PSI_FLAG_GLOBAL},\n  { &key_LOG_INFO_lock, \"LOG_INFO::lock\", 0},\n  { &key_LOCK_thread_count, \"LOCK_thread_count\", PSI_FLAG_GLOBAL},\n  { &key_PARTITION_LOCK_auto_inc, \"HA_DATA_PARTITION::LOCK_auto_inc\", 0}\n};\n\nPSI_rwlock_key key_rwlock_LOCK_grant, key_rwlock_LOCK_logger,\n  key_rwlock_LOCK_sys_init_connect, key_rwlock_LOCK_sys_init_slave,\n  key_rwlock_LOCK_system_variables_hash, key_rwlock_query_cache_query_lock;\n\nstatic PSI_rwlock_info all_server_rwlocks[]=\n{\n#if defined (HAVE_OPENSSL) && !defined(HAVE_YASSL)\n  { &key_rwlock_openssl, \"CRYPTO_dynlock_value::lock\", 0},\n#endif\n  { &key_rwlock_LOCK_grant, \"LOCK_grant\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_logger, \"LOGGER::LOCK_logger\", 0},\n  { &key_rwlock_LOCK_sys_init_connect, \"LOCK_sys_init_connect\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_sys_init_slave, \"LOCK_sys_init_slave\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_query_cache_query_lock, \"Query_cache_query::lock\", 0}\n};\n\n#ifdef HAVE_MMAP\nPSI_cond_key key_PAGE_cond, key_COND_active, key_COND_pool;\n#endif /* HAVE_MMAP */\n\nPSI_cond_key key_BINLOG_COND_prep_xids, key_BINLOG_update_cond,\n  key_COND_cache_status_changed, key_COND_manager,\n  key_COND_rpl_status, key_COND_server_started,\n  key_delayed_insert_cond, key_delayed_insert_cond_client,\n  key_item_func_sleep_cond, key_master_info_data_cond,\n  key_master_info_start_cond, key_master_info_stop_cond,\n  key_master_info_sleep_cond,\n  key_relay_log_info_data_cond, key_relay_log_info_log_space_cond,\n  key_relay_log_info_start_cond, key_relay_log_info_stop_cond,\n  key_relay_log_info_sleep_cond,\n  key_TABLE_SHARE_cond, key_user_level_lock_cond,\n  key_COND_thread_count, key_COND_thread_cache, key_COND_flush_thread_cache,\n  key_BINLOG_COND_queue_busy;\nPSI_cond_key key_RELAYLOG_update_cond, key_COND_wakeup_ready;\nPSI_cond_key key_RELAYLOG_COND_queue_busy;\nPSI_cond_key key_TC_LOG_MMAP_COND_queue_busy;\n\nstatic PSI_cond_info all_server_conds[]=\n{\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_COND_handler_count, \"COND_handler_count\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n#ifdef HAVE_MMAP\n  { &key_PAGE_cond, \"PAGE::cond\", 0},\n  { &key_COND_active, \"TC_LOG_MMAP::COND_active\", 0},\n  { &key_COND_pool, \"TC_LOG_MMAP::COND_pool\", 0},\n  { &key_TC_LOG_MMAP_COND_queue_busy, \"TC_LOG_MMAP::COND_queue_busy\", 0},\n#endif /* HAVE_MMAP */\n  { &key_BINLOG_COND_prep_xids, \"MYSQL_BIN_LOG::COND_prep_xids\", 0},\n  { &key_BINLOG_update_cond, \"MYSQL_BIN_LOG::update_cond\", 0},\n  { &key_BINLOG_COND_queue_busy, \"MYSQL_BIN_LOG::COND_queue_busy\", 0},\n  { &key_RELAYLOG_update_cond, \"MYSQL_RELAY_LOG::update_cond\", 0},\n  { &key_RELAYLOG_COND_queue_busy, \"MYSQL_RELAY_LOG::COND_queue_busy\", 0},\n  { &key_COND_wakeup_ready, \"THD::COND_wakeup_ready\", 0},\n  { &key_COND_cache_status_changed, \"Query_cache::COND_cache_status_changed\", 0},\n  { &key_COND_manager, \"COND_manager\", PSI_FLAG_GLOBAL},\n  { &key_COND_rpl_status, \"COND_rpl_status\", PSI_FLAG_GLOBAL},\n  { &key_COND_server_started, \"COND_server_started\", PSI_FLAG_GLOBAL},\n  { &key_delayed_insert_cond, \"Delayed_insert::cond\", 0},\n  { &key_delayed_insert_cond_client, \"Delayed_insert::cond_client\", 0},\n  { &key_item_func_sleep_cond, \"Item_func_sleep::cond\", 0},\n  { &key_master_info_data_cond, \"Master_info::data_cond\", 0},\n  { &key_master_info_start_cond, \"Master_info::start_cond\", 0},\n  { &key_master_info_stop_cond, \"Master_info::stop_cond\", 0},\n  { &key_master_info_sleep_cond, \"Master_info::sleep_cond\", 0},\n  { &key_relay_log_info_data_cond, \"Relay_log_info::data_cond\", 0},\n  { &key_relay_log_info_log_space_cond, \"Relay_log_info::log_space_cond\", 0},\n  { &key_relay_log_info_start_cond, \"Relay_log_info::start_cond\", 0},\n  { &key_relay_log_info_stop_cond, \"Relay_log_info::stop_cond\", 0},\n  { &key_relay_log_info_sleep_cond, \"Relay_log_info::sleep_cond\", 0},\n  { &key_TABLE_SHARE_cond, \"TABLE_SHARE::cond\", 0},\n  { &key_user_level_lock_cond, \"User_level_lock::cond\", 0},\n  { &key_COND_thread_count, \"COND_thread_count\", PSI_FLAG_GLOBAL},\n  { &key_COND_thread_cache, \"COND_thread_cache\", PSI_FLAG_GLOBAL},\n  { &key_COND_flush_thread_cache, \"COND_flush_thread_cache\", PSI_FLAG_GLOBAL}\n};\n\nPSI_thread_key key_thread_bootstrap, key_thread_delayed_insert,\n  key_thread_handle_manager, key_thread_main,\n  key_thread_one_connection, key_thread_signal_hand;\n\nstatic PSI_thread_info all_server_threads[]=\n{\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_namedpipes, \"con_named_pipes\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if defined(HAVE_SMEM) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_sharedmem, \"con_shared_mem\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_sockets, \"con_sockets\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#ifdef __WIN__\n  { &key_thread_handle_shutdown, \"shutdown\", PSI_FLAG_GLOBAL},\n#endif /* __WIN__ */\n\n  { &key_thread_bootstrap, \"bootstrap\", PSI_FLAG_GLOBAL},\n  { &key_thread_delayed_insert, \"delayed_insert\", 0},\n  { &key_thread_handle_manager, \"manager\", PSI_FLAG_GLOBAL},\n  { &key_thread_main, \"main\", PSI_FLAG_GLOBAL},\n  { &key_thread_one_connection, \"one_connection\", 0},\n  { &key_thread_signal_hand, \"signal_handler\", PSI_FLAG_GLOBAL}\n};\n\nPSI_file_key key_file_binlog, key_file_binlog_index, key_file_casetest,\n  key_file_dbopt, key_file_des_key_file, key_file_ERRMSG, key_select_to_file,\n  key_file_fileparser, key_file_frm, key_file_global_ddl_log, key_file_load,\n  key_file_loadfile, key_file_log_event_data, key_file_log_event_info,\n  key_file_master_info, key_file_misc, key_file_partition,\n  key_file_pid, key_file_relay_log_info, key_file_send_file, key_file_tclog,\n  key_file_trg, key_file_trn, key_file_init;\nPSI_file_key key_file_query_log, key_file_slow_log;\nPSI_file_key key_file_relaylog, key_file_relaylog_index;\n\nstatic PSI_file_info all_server_files[]=\n{\n  { &key_file_binlog, \"binlog\", 0},\n  { &key_file_binlog_index, \"binlog_index\", 0},\n  { &key_file_relaylog, \"relaylog\", 0},\n  { &key_file_relaylog_index, \"relaylog_index\", 0},\n  { &key_file_casetest, \"casetest\", 0},\n  { &key_file_dbopt, \"dbopt\", 0},\n  { &key_file_des_key_file, \"des_key_file\", 0},\n  { &key_file_ERRMSG, \"ERRMSG\", 0},\n  { &key_select_to_file, \"select_to_file\", 0},\n  { &key_file_fileparser, \"file_parser\", 0},\n  { &key_file_frm, \"FRM\", 0},\n  { &key_file_global_ddl_log, \"global_ddl_log\", 0},\n  { &key_file_load, \"load\", 0},\n  { &key_file_loadfile, \"LOAD_FILE\", 0},\n  { &key_file_log_event_data, \"log_event_data\", 0},\n  { &key_file_log_event_info, \"log_event_info\", 0},\n  { &key_file_master_info, \"master_info\", 0},\n  { &key_file_misc, \"misc\", 0},\n  { &key_file_partition, \"partition\", 0},\n  { &key_file_pid, \"pid\", 0},\n  { &key_file_query_log, \"query_log\", 0},\n  { &key_file_relay_log_info, \"relay_log_info\", 0},\n  { &key_file_send_file, \"send_file\", 0},\n  { &key_file_slow_log, \"slow_log\", 0},\n  { &key_file_tclog, \"tclog\", 0},\n  { &key_file_trg, \"trigger_name\", 0},\n  { &key_file_trn, \"trigger\", 0},\n  { &key_file_init, \"init\", 0}\n};\n\n/**\n  Initialise all the performance schema instrumentation points\n  used by the server.\n*/\nvoid init_server_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_server_mutexes);\n  PSI_server->register_mutex(category, all_server_mutexes, count);\n\n  count= array_elements(all_server_rwlocks);\n  PSI_server->register_rwlock(category, all_server_rwlocks, count);\n\n  count= array_elements(all_server_conds);\n  PSI_server->register_cond(category, all_server_conds, count);\n\n  count= array_elements(all_server_threads);\n  PSI_server->register_thread(category, all_server_threads, count);\n\n  count= array_elements(all_server_files);\n  PSI_server->register_file(category, all_server_files, count);\n}\n\n#endif /* HAVE_PSI_INTERFACE */\n\n/*\n  Since buffered_option_error_reporter is only used currently\n  for parsing performance schema options, this code is not needed\n  when the performance schema is not compiled in.\n*/\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n/**\n  A log message for the error log, buffered in memory.\n  Log messages are temporarily buffered when generated before the error log\n  is initialized, and then printed once the error log is ready.\n*/\nclass Buffered_log : public Sql_alloc\n{\npublic:\n  Buffered_log(enum loglevel level, const char *message);\n\n  ~Buffered_log()\n  {}\n\n  void print(void);\n\nprivate:\n  /** Log message level. */\n  enum loglevel m_level;\n  /** Log message text. */\n  String m_message;\n};\n\n/**\n  Constructor.\n  @param level          the message log level\n  @param message        the message text\n*/\nBuffered_log::Buffered_log(enum loglevel level, const char *message)\n  : m_level(level), m_message()\n{\n  m_message.copy(message, strlen(message), &my_charset_latin1);\n}\n\n/**\n  Print a buffered log to the real log file.\n*/\nvoid Buffered_log::print()\n{\n  /*\n    Since messages are buffered, they can be printed out\n    of order with other entries in the log.\n    Add \"Buffered xxx\" to the message text to prevent confusion.\n  */\n  switch(m_level)\n  {\n  case ERROR_LEVEL:\n    sql_print_error(\"Buffered error: %s\\n\", m_message.c_ptr_safe());\n    break;\n  case WARNING_LEVEL:\n    sql_print_warning(\"Buffered warning: %s\\n\", m_message.c_ptr_safe());\n    break;\n  case INFORMATION_LEVEL:\n    /*\n      Messages printed as \"information\" still end up in the mysqld *error* log,\n      but with a [Note] tag instead of an [ERROR] tag.\n      While this is probably fine for a human reading the log,\n      it is upsetting existing automated scripts used to parse logs,\n      because such scripts are likely to not already handle [Note] properly.\n      INFORMATION_LEVEL messages are simply silenced, on purpose,\n      to avoid un needed verbosity.\n    */\n    break;\n  }\n}\n\n/**\n  Collection of all the buffered log messages.\n*/\nclass Buffered_logs\n{\npublic:\n  Buffered_logs()\n  {}\n\n  ~Buffered_logs()\n  {}\n\n  void init();\n  void cleanup();\n\n  void buffer(enum loglevel m_level, const char *msg);\n  void print();\nprivate:\n  /**\n    Memory root to use to store buffered logs.\n    This memory root lifespan is between init and cleanup.\n    Once the buffered logs are printed, they are not needed anymore,\n    and all the memory used is reclaimed.\n  */\n  MEM_ROOT m_root;\n  /** List of buffered log messages. */\n  List<Buffered_log> m_list;\n};\n\nvoid Buffered_logs::init()\n{\n  init_alloc_root(&m_root, 1024, 0);\n}\n\nvoid Buffered_logs::cleanup()\n{\n  m_list.delete_elements();\n  free_root(&m_root, MYF(0));\n}\n\n/**\n  Add a log message to the buffer.\n*/\nvoid Buffered_logs::buffer(enum loglevel level, const char *msg)\n{\n  /*\n    Do not let Sql_alloc::operator new(size_t) allocate memory,\n    there is no memory root associated with the main() thread.\n    Give explicitly the proper memory root to use to\n    Sql_alloc::operator new(size_t, MEM_ROOT *) instead.\n  */\n  Buffered_log *log= new (&m_root) Buffered_log(level, msg);\n  if (log)\n    m_list.push_back(log, &m_root);\n}\n\n/**\n  Print buffered log messages.\n*/\nvoid Buffered_logs::print()\n{\n  Buffered_log *log;\n  List_iterator_fast<Buffered_log> it(m_list);\n  while ((log= it++))\n    log->print();\n}\n\n/** Logs reported before a logger is available. */\nstatic Buffered_logs buffered_logs;\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  Error reporter that buffer log messages.\n  @param level          log message level\n  @param format         log message format string\n*/\nC_MODE_START\nstatic void buffered_option_error_reporter(enum loglevel level,\n                                           const char *format, ...)\n{\n  va_list args;\n  char buffer[1024];\n\n  va_start(args, format);\n  my_vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n  buffered_logs.buffer(level, buffer);\n}\nC_MODE_END\n#endif /* !EMBEDDED_LIBRARY */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nstatic my_socket unix_sock, base_ip_sock, extra_ip_sock;\nstruct my_rnd_struct sql_rand; ///< used by sql_class.cc:THD::THD()\n\n#ifndef EMBEDDED_LIBRARY\nstruct passwd *user_info;\nstatic pthread_t select_thread;\n#endif\n\n/* OS specific variables */\n\n#ifdef __WIN__\n#undef\t getpid\n#include <process.h>\n\nstatic mysql_cond_t COND_handler_count;\nstatic uint handler_count;\nstatic bool start_mode=0, use_opt_args;\nstatic int opt_argc;\nstatic char **opt_argv;\n\n#if !defined(EMBEDDED_LIBRARY)\nstatic HANDLE hEventShutdown;\nstatic char shutdown_event_name[40];\n#include \"nt_servc.h\"\nstatic\t NTService  Service;\t      ///< Service object for WinNT\n#endif /* EMBEDDED_LIBRARY */\n#endif /* __WIN__ */\n\n#ifdef _WIN32\nstatic char pipe_name[512];\nstatic SECURITY_ATTRIBUTES saPipeSecurity;\nstatic SECURITY_DESCRIPTOR sdPipeDescriptor;\nstatic HANDLE hPipe = INVALID_HANDLE_VALUE;\n#endif\n\n#ifndef EMBEDDED_LIBRARY\nbool mysqld_embedded=0;\n#else\nbool mysqld_embedded=1;\n#endif\n\nstatic my_bool plugins_are_initialized= FALSE;\n\n#ifndef DBUG_OFF\nstatic const char* default_dbug_option;\n#endif\nstatic const char *current_dbug_option=\"disabled\";\n#ifdef HAVE_LIBWRAP\nconst char *libwrapName= NULL;\nint allow_severity = LOG_INFO;\nint deny_severity = LOG_WARNING;\n#endif\n#ifdef HAVE_QUERY_CACHE\nulong query_cache_min_res_unit= QUERY_CACHE_MIN_RESULT_DATA_SIZE;\nQuery_cache query_cache;\n#endif\n#ifdef HAVE_SMEM\nchar *shared_memory_base_name= default_shared_memory_base_name;\nmy_bool opt_enable_shared_memory;\nHANDLE smem_event_connect_request= 0;\n#endif\n\nmy_bool opt_use_ssl  = 0;\nchar *opt_ssl_ca= NULL, *opt_ssl_capath= NULL, *opt_ssl_cert= NULL,\n     *opt_ssl_cipher= NULL, *opt_ssl_key= NULL;\n\nstatic scheduler_functions thread_scheduler_struct, extra_thread_scheduler_struct;\nscheduler_functions *thread_scheduler= &thread_scheduler_struct,\n                    *extra_thread_scheduler= &extra_thread_scheduler_struct;\n\n#ifdef HAVE_OPENSSL\n#include <openssl/crypto.h>\n#ifndef HAVE_YASSL\ntypedef struct CRYPTO_dynlock_value\n{\n  mysql_rwlock_t lock;\n} openssl_lock_t;\n\nstatic openssl_lock_t *openssl_stdlocks;\nstatic openssl_lock_t *openssl_dynlock_create(const char *, int);\nstatic void openssl_dynlock_destroy(openssl_lock_t *, const char *, int);\nstatic void openssl_lock_function(int, int, const char *, int);\nstatic void openssl_lock(int, openssl_lock_t *, const char *, int);\n#endif\nchar *des_key_file;\n#ifndef EMBEDDED_LIBRARY\nstruct st_VioSSLFd *ssl_acceptor_fd;\n#endif\n#endif /* HAVE_OPENSSL */\n\n/**\n  Number of currently active user connections. The variable is protected by\n  LOCK_connection_count.\n*/\nuint connection_count= 0, extra_connection_count= 0;\n\n/* Function declarations */\n\npthread_handler_t signal_hand(void *arg);\nstatic int mysql_init_variables(void);\nstatic int get_options(int *argc_ptr, char ***argv_ptr);\nstatic bool add_terminator(DYNAMIC_ARRAY *options);\nextern \"C\" my_bool mysqld_get_one_option(int, const struct my_option *, char *);\nstatic int init_thread_environment();\nstatic char *get_relative_path(const char *path);\nstatic int fix_paths(void);\nvoid handle_connections_sockets();\n#ifdef _WIN32\npthread_handler_t handle_connections_sockets_thread(void *arg);\n#endif\npthread_handler_t kill_server_thread(void *arg);\nstatic void bootstrap(MYSQL_FILE *file);\nstatic bool read_init_file(char *file_name);\n#ifdef _WIN32\npthread_handler_t handle_connections_namedpipes(void *arg);\n#endif\n#ifdef HAVE_SMEM\npthread_handler_t handle_connections_shared_memory(void *arg);\n#endif\npthread_handler_t handle_slave(void *arg);\nstatic void clean_up(bool print_message);\nstatic int test_if_case_insensitive(const char *dir_name);\n\n#ifndef EMBEDDED_LIBRARY\nstatic bool pid_file_created= false;\nstatic void usage(void);\nstatic void start_signal_handler(void);\nstatic void close_server_sock();\nstatic void clean_up_mutexes(void);\nstatic void wait_for_signal_thread_to_end(void);\nstatic void create_pid_file();\nstatic void mysqld_exit(int exit_code) __attribute__((noreturn));\n#endif\nstatic void delete_pid_file(myf flags);\nstatic void end_ssl();\n\n\n#ifndef EMBEDDED_LIBRARY\n/****************************************************************************\n** Code to end mysqld\n****************************************************************************/\n\nstatic void close_connections(void)\n{\n#ifdef EXTRA_DEBUG\n  int count=0;\n#endif\n  DBUG_ENTER(\"close_connections\");\n\n  /* Clear thread cache */\n  kill_cached_threads++;\n  flush_thread_cache();\n\n  /* kill connection thread */\n#if !defined(__WIN__)\n  DBUG_PRINT(\"quit\", (\"waiting for select thread: 0x%lx\",\n                      (ulong) select_thread));\n  mysql_mutex_lock(&LOCK_thread_count);\n\n  while (select_thread_in_use)\n  {\n    struct timespec abstime;\n    int error;\n    LINT_INIT(error);\n    DBUG_PRINT(\"info\",(\"Waiting for select thread\"));\n\n#ifndef DONT_USE_THR_ALARM\n    if (pthread_kill(select_thread, thr_client_alarm))\n      break;\t\t\t\t\t// allready dead\n#endif\n    set_timespec(abstime, 2);\n    for (uint tmp=0 ; tmp < 10 && select_thread_in_use; tmp++)\n    {\n      error= mysql_cond_timedwait(&COND_thread_count, &LOCK_thread_count,\n                                  &abstime);\n      if (error != EINTR)\n\tbreak;\n    }\n#ifdef EXTRA_DEBUG\n    if (error != 0 && error != ETIMEDOUT && !count++)\n      sql_print_error(\"Got error %d from mysql_cond_timedwait\", error);\n#endif\n    close_server_sock();\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n#endif /* __WIN__ */\n\n\n  /* Abort listening to new connections */\n  DBUG_PRINT(\"quit\",(\"Closing sockets\"));\n  if (!opt_disable_networking )\n  {\n    if (base_ip_sock != INVALID_SOCKET)\n    {\n      (void) mysql_socket_shutdown(base_ip_sock, SHUT_RDWR);\n      (void) closesocket(base_ip_sock);\n      base_ip_sock= INVALID_SOCKET;\n    }\n    if (extra_ip_sock != INVALID_SOCKET)\n    {\n      (void) mysql_socket_shutdown(extra_ip_sock, SHUT_RDWR);\n      (void) closesocket(extra_ip_sock);\n      extra_ip_sock= INVALID_SOCKET;\n    }\n  }\n#ifdef _WIN32\n  if (hPipe != INVALID_HANDLE_VALUE && opt_enable_named_pipe)\n  {\n    HANDLE temp;\n    DBUG_PRINT(\"quit\", (\"Closing named pipes\") );\n\n    /* Create connection to the handle named pipe handler to break the loop */\n    if ((temp = CreateFile(pipe_name,\n\t\t\t   GENERIC_READ | GENERIC_WRITE,\n\t\t\t   0,\n\t\t\t   NULL,\n\t\t\t   OPEN_EXISTING,\n\t\t\t   0,\n\t\t\t   NULL )) != INVALID_HANDLE_VALUE)\n    {\n      WaitNamedPipe(pipe_name, 1000);\n      DWORD dwMode = PIPE_READMODE_BYTE | PIPE_WAIT;\n      SetNamedPipeHandleState(temp, &dwMode, NULL, NULL);\n      CancelIo(temp);\n      DisconnectNamedPipe(temp);\n      CloseHandle(temp);\n    }\n  }\n#endif\n#ifdef HAVE_SYS_UN_H\n  if (unix_sock != INVALID_SOCKET)\n  {\n    (void) mysql_socket_shutdown(unix_sock, SHUT_RDWR);\n    (void) closesocket(unix_sock);\n    (void) unlink(mysqld_unix_port);\n    unix_sock= INVALID_SOCKET;\n  }\n#endif\n  end_thr_alarm(0);\t\t\t // Abort old alarms.\n\n  /*\n    First signal all threads that it's time to die\n    This will give the threads some time to gracefully abort their\n    statements and inform their clients that the server is about to die.\n  */\n\n  THD *tmp;\n  mysql_mutex_lock(&LOCK_thread_count); // For unlink from list\n\n  I_List_iterator<THD> it(threads);\n  while ((tmp=it++))\n  {\n    DBUG_PRINT(\"quit\",(\"Informing thread %ld that it's time to die\",\n\t\t       tmp->thread_id));\n    /* We skip slave threads & scheduler on this first loop through. */\n    if (tmp->slave_thread)\n      continue;\n\n    tmp->killed= KILL_SERVER_HARD;\n    MYSQL_CALLBACK(thread_scheduler, post_kill_notification, (tmp));\n    mysql_mutex_lock(&tmp->LOCK_thd_data);\n    if (tmp->mysys_var)\n    {\n      tmp->mysys_var->abort=1;\n      mysql_mutex_lock(&tmp->mysys_var->mutex);\n      if (tmp->mysys_var->current_cond)\n      {\n        uint i;\n        for (i=0; i < 2; i++)\n        {\n          int ret= mysql_mutex_trylock(tmp->mysys_var->current_mutex);\n          mysql_cond_broadcast(tmp->mysys_var->current_cond);\n          if (!ret)\n          {\n            /* Thread has surely got the signal, unlock and abort */\n            mysql_mutex_unlock(tmp->mysys_var->current_mutex);\n            break;\n          }\n          sleep(1);\n        }\n      }\n      mysql_mutex_unlock(&tmp->mysys_var->mutex);\n    }\n    mysql_mutex_unlock(&tmp->LOCK_thd_data);\n  }\n  mysql_mutex_unlock(&LOCK_thread_count); // For unlink from list\n\n  Events::deinit();\n  end_slave();\n\n  /* Give threads time to die. */\n  for (int i= 0; thread_count && i < 100; i++)\n    my_sleep(20000);\n\n  /*\n    Force remaining threads to die by closing the connection to the client\n    This will ensure that threads that are waiting for a command from the\n    client on a blocking read call are aborted.\n  */\n\n  for (;;)\n  {\n    DBUG_PRINT(\"quit\",(\"Locking LOCK_thread_count\"));\n    mysql_mutex_lock(&LOCK_thread_count); // For unlink from list\n    if (!(tmp=threads.get()))\n    {\n      DBUG_PRINT(\"quit\",(\"Unlocking LOCK_thread_count\"));\n      mysql_mutex_unlock(&LOCK_thread_count);\n      break;\n    }\n#ifndef __bsdi__\t\t\t\t// Bug in BSDI kernel\n    if (tmp->vio_ok())\n    {\n      if (global_system_variables.log_warnings)\n        sql_print_warning(ER_DEFAULT(ER_FORCING_CLOSE),my_progname,\n                          tmp->thread_id,\n                          (tmp->main_security_ctx.user ?\n                           tmp->main_security_ctx.user : \"\"));\n      close_connection(tmp,ER_SERVER_SHUTDOWN);\n    }\n#endif\n    DBUG_PRINT(\"quit\",(\"Unlocking LOCK_thread_count\"));\n    mysql_mutex_unlock(&LOCK_thread_count);\n  }\n  /* All threads has now been aborted */\n  DBUG_PRINT(\"quit\",(\"Waiting for threads to die (count=%u)\",thread_count));\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (thread_count)\n  {\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n    DBUG_PRINT(\"quit\",(\"One thread died (count=%u)\",thread_count));\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  DBUG_PRINT(\"quit\",(\"close_connections thread\"));\n  DBUG_VOID_RETURN;\n}\n\n\n#ifdef HAVE_CLOSE_SERVER_SOCK\nstatic void close_socket(my_socket sock, const char *info)\n{\n  DBUG_ENTER(\"close_socket\");\n\n  if (sock != INVALID_SOCKET)\n  {\n    DBUG_PRINT(\"info\", (\"calling shutdown on %s socket\", info));\n    (void) mysql_socket_shutdown(sock, SHUT_RDWR);\n#if defined(__NETWARE__)\n    /*\n      The following code is disabled for normal systems as it causes MySQL\n      to hang on AIX 4.3 during shutdown\n    */\n    DBUG_PRINT(\"info\", (\"calling closesocket on %s socket\", info));\n    (void) closesocket(tmp_sock);\n#endif\n  }\n  DBUG_VOID_RETURN;\n}\n#endif\n\n\nstatic void close_server_sock()\n{\n#ifdef HAVE_CLOSE_SERVER_SOCK\n  DBUG_ENTER(\"close_server_sock\");\n\n  close_socket(base_ip_sock, \"TCP/IP\");\n  close_socket(extra_ip_sock, \"TCP/IP\");\n  close_socket(unix_sock, \"unix/IP\");\n\n  if (unix_sock != INVALID_SOCKET)\n    (void) unlink(mysqld_unix_port);\n  base_ip_sock= extra_ip_sock= unix_sock= INVALID_SOCKET;\n\n  DBUG_VOID_RETURN;\n#endif\n}\n\n#endif /*EMBEDDED_LIBRARY*/\n\n\nvoid kill_mysql(void)\n{\n  DBUG_ENTER(\"kill_mysql\");\n\n#if defined(SIGNALS_DONT_BREAK_READ) && !defined(EMBEDDED_LIBRARY)\n  abort_loop=1;\t\t\t\t\t// Break connection loops\n  close_server_sock();\t\t\t\t// Force accept to wake up\n#endif\n\n#if defined(__WIN__)\n#if !defined(EMBEDDED_LIBRARY)\n  {\n    if (!SetEvent(hEventShutdown))\n    {\n      DBUG_PRINT(\"error\",(\"Got error: %ld from SetEvent\",GetLastError()));\n    }\n    /*\n      or:\n      HANDLE hEvent=OpenEvent(0, FALSE, \"MySqlShutdown\");\n      SetEvent(hEventShutdown);\n      CloseHandle(hEvent);\n    */\n  }\n#endif\n#elif defined(HAVE_PTHREAD_KILL)\n  if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL))\n  {\n    DBUG_PRINT(\"error\",(\"Got error %d from pthread_kill\",errno)); /* purecov: inspected */\n  }\n#elif !defined(SIGNALS_DONT_BREAK_READ)\n  kill(current_pid, MYSQL_KILL_SIGNAL);\n#endif\n  DBUG_PRINT(\"quit\",(\"After pthread_kill\"));\n  shutdown_in_progress=1;\t\t\t// Safety if kill didn't work\n#ifdef SIGNALS_DONT_BREAK_READ\n  if (!kill_in_progress)\n  {\n    pthread_t tmp;\n    int error;\n    abort_loop=1;\n    if ((error= mysql_thread_create(0, /* Not instrumented */\n                                    &tmp, &connection_attrib,\n                                    kill_server_thread, (void*) 0)))\n      sql_print_error(\"Can't create thread to kill server (errno= %d).\", error);\n  }\n#endif\n  DBUG_VOID_RETURN;\n}\n\n/**\n  Force server down. Kill all connections and threads and exit.\n\n  @param  sig_ptr       Signal number that caused kill_server to be called.\n\n  @note\n    A signal number of 0 mean that the function was not called\n    from a signal handler and there is thus no signal to block\n    or stop, we just want to kill the server.\n*/\n\n#if !defined(__WIN__)\nstatic void *kill_server(void *sig_ptr)\n#define RETURN_FROM_KILL_SERVER return 0\n#else\nstatic void __cdecl kill_server(int sig_ptr)\n#define RETURN_FROM_KILL_SERVER return\n#endif\n{\n  DBUG_ENTER(\"kill_server\");\n#ifndef EMBEDDED_LIBRARY\n  int sig=(int) (long) sig_ptr;\t\t\t// This is passed a int\n  // if there is a signal during the kill in progress, ignore the other\n  if (kill_in_progress)\t\t\t\t// Safety\n  {\n    DBUG_LEAVE;\n    RETURN_FROM_KILL_SERVER;\n  }\n  kill_in_progress=TRUE;\n  abort_loop=1;\t\t\t\t\t// This should be set\n  if (sig != 0) // 0 is not a valid signal number\n    my_sigset(sig, SIG_IGN);                    /* purify inspected */\n  if (sig == MYSQL_KILL_SIGNAL || sig == 0)\n    sql_print_information(ER_DEFAULT(ER_NORMAL_SHUTDOWN),my_progname);\n  else\n    sql_print_error(ER_DEFAULT(ER_GOT_SIGNAL),my_progname,sig); /* purecov: inspected */\n\n#ifdef HAVE_SMEM\n  /*\n    Send event to smem_event_connect_request for aborting\n  */\n  if (opt_enable_shared_memory)\n  {\n    if (!SetEvent(smem_event_connect_request))\n    {\n      DBUG_PRINT(\"error\",\n                 (\"Got error: %ld from SetEvent of smem_event_connect_request\",\n                  GetLastError()));\n    }\n  }\n#endif\n\n  close_connections();\n  if (sig != MYSQL_KILL_SIGNAL &&\n      sig != 0)\n    unireg_abort(1);\t\t\t\t/* purecov: inspected */\n  else\n    unireg_end();\n\n  /* purecov: begin deadcode */\n  DBUG_LEAVE;                                   // Must match DBUG_ENTER()\n  my_thread_end();\n  pthread_exit(0);\n  /* purecov: end */\n\n  RETURN_FROM_KILL_SERVER;                      // Avoid compiler warnings\n\n#else /* EMBEDDED_LIBRARY*/\n\n  DBUG_LEAVE;\n  RETURN_FROM_KILL_SERVER;\n\n#endif /* EMBEDDED_LIBRARY */\n}\n\n\n#if defined(USE_ONE_SIGNAL_HAND)\npthread_handler_t kill_server_thread(void *arg __attribute__((unused)))\n{\n  my_thread_init();\t\t\t\t// Initialize new thread\n  kill_server(0);\n  /* purecov: begin deadcode */\n  my_thread_end();\n  pthread_exit(0);\n  return 0;\n  /* purecov: end */\n}\n#endif\n\n\nextern \"C\" sig_handler print_signal_warning(int sig)\n{\n  if (global_system_variables.log_warnings)\n    sql_print_warning(\"Got signal %d from thread %ld\", sig,my_thread_id());\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  my_sigset(sig,print_signal_warning);\t\t/* int. thread system calls */\n#endif\n#if !defined(__WIN__)\n  if (sig == SIGALRM)\n    alarm(2);\t\t\t\t\t/* reschedule alarm */\n#endif\n}\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void init_error_log_mutex()\n{\n  mysql_mutex_init(key_LOCK_error_log, &LOCK_error_log, MY_MUTEX_INIT_FAST);\n}\n\n\nstatic void clean_up_error_log_mutex()\n{\n  mysql_mutex_destroy(&LOCK_error_log);\n}\n\n\n/**\n  cleanup all memory and end program nicely.\n\n    If SIGNALS_DONT_BREAK_READ is defined, this function is called\n    by the main thread. To get MySQL to shut down nicely in this case\n    (Mac OS X) we have to call exit() instead if pthread_exit().\n\n  @note\n    This function never returns.\n*/\nvoid unireg_end(void)\n{\n  clean_up(1);\n  my_thread_end();\n#if defined(SIGNALS_DONT_BREAK_READ)\n  exit(0);\n#else\n  pthread_exit(0);\t\t\t\t// Exit is in main thread\n#endif\n}\n\n\nextern \"C\" void unireg_abort(int exit_code)\n{\n  DBUG_ENTER(\"unireg_abort\");\n\n  if (opt_help)\n    usage();\n  if (exit_code)\n    sql_print_error(\"Aborting\\n\");\n  clean_up(!opt_abort && (exit_code || !opt_bootstrap)); /* purecov: inspected */\n  DBUG_PRINT(\"quit\",(\"done with cleanup in unireg_abort\"));\n  mysqld_exit(exit_code);\n}\n\nstatic void mysqld_exit(int exit_code)\n{\n  /*\n    Important note: we wait for the signal thread to end,\n    but if a kill -15 signal was sent, the signal thread did\n    spawn the kill_server_thread thread, which is running concurrently.\n  */\n  wait_for_signal_thread_to_end();\n  mysql_audit_finalize();\n  clean_up_mutexes();\n  clean_up_error_log_mutex();\n  my_end((opt_endinfo ? MY_CHECK_ERROR | MY_GIVE_INFO : 0));\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  shutdown_performance_schema();        // we do it as late as possible\n#endif\n  exit(exit_code); /* purecov: inspected */\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\nvoid clean_up(bool print_message)\n{\n  DBUG_PRINT(\"exit\",(\"clean_up\"));\n  if (cleanup_done++)\n    return; /* purecov: inspected */\n\n  close_active_mi();\n  stop_handle_manager();\n  release_ddl_log();\n\n  /*\n    make sure that handlers finish up\n    what they have that is dependent on the binlog\n  */\n  ha_binlog_end(current_thd);\n\n  logger.cleanup_base();\n\n  injector::free_instance();\n  mysql_bin_log.cleanup();\n\n#ifdef HAVE_REPLICATION\n  if (use_slave_mask)\n    bitmap_free(&slave_error_mask);\n#endif\n  my_tz_free();\n  my_dboptions_cache_free();\n  ignore_db_dirs_free();\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  servers_free(1);\n  acl_free(1);\n  grant_free();\n#endif\n  query_cache_destroy();\n  hostname_cache_free();\n  item_user_lock_free();\n  lex_free();\t\t\t\t/* Free some memory */\n  item_create_cleanup();\n  table_def_start_shutdown();\n  plugin_shutdown();\n  udf_free();\n  ha_end();\n  if (tc_log)\n    tc_log->close();\n  delegates_destroy();\n  xid_cache_free();\n  table_def_free();\n  mdl_destroy();\n  key_caches.delete_elements((void (*)(const char*, uchar*)) free_key_cache);\n  wt_end();\n  multi_keycache_free();\n  sp_cache_end();\n  free_status_vars();\n  end_thr_alarm(1);\t\t\t/* Free allocated memory */\n  my_free_open_file_info();\n  if (defaults_argv)\n    free_defaults(defaults_argv);\n  free_tmpdir(&mysql_tmpdir_list);\n  bitmap_free(&temp_pool);\n  free_max_user_conn();\n  free_global_user_stats();\n  free_global_client_stats();\n  free_global_table_stats();\n  free_global_index_stats();\n  delete_dynamic(&all_options);\n#ifdef HAVE_REPLICATION\n  end_slave_list();\n#endif\n  my_uuid_end();\n  delete binlog_filter;\n  delete rpl_filter;\n  end_ssl();\n#ifndef EMBEDDED_LIBRARY\n  vio_end();\n#endif /*!EMBEDDED_LIBRARY*/\n  my_regex_end();\n#if defined(ENABLED_DEBUG_SYNC)\n  /* End the debug sync facility. See debug_sync.cc. */\n  debug_sync_end();\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n  delete_pid_file(MYF(0));\n\n  if (print_message && my_default_lc_messages && server_start_time)\n    sql_print_information(ER_DEFAULT(ER_SHUTDOWN_COMPLETE),my_progname);\n  cleanup_errmsgs();\n  MYSQL_CALLBACK(thread_scheduler, end, ());\n  mysql_library_end();\n  finish_client_errs();\n  (void) my_error_unregister(ER_ERROR_FIRST, ER_ERROR_LAST); // finish server errs\n  DBUG_PRINT(\"quit\", (\"Error messages freed\"));\n  /* Tell main we are ready */\n  logger.cleanup_end();\n  sys_var_end();\n  my_atomic_rwlock_destroy(&global_query_id_lock);\n  my_atomic_rwlock_destroy(&thread_running_lock);\n  free_charsets();\n  mysql_mutex_lock(&LOCK_thread_count);\n  DBUG_PRINT(\"quit\", (\"got thread count lock\"));\n  ready_to_exit=1;\n  /* do the broadcast inside the lock to ensure that my_end() is not called */\n  mysql_cond_broadcast(&COND_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  /*\n    The following lines may never be executed as the main thread may have\n    killed us\n  */\n  DBUG_PRINT(\"quit\", (\"done with cleanup\"));\n} /* clean_up */\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  This is mainly needed when running with purify, but it's still nice to\n  know that all child threads have died when mysqld exits.\n*/\nstatic void wait_for_signal_thread_to_end()\n{\n  uint i;\n  /*\n    Wait up to 10 seconds for signal thread to die. We use this mainly to\n    avoid getting warnings that my_thread_end has not been called\n  */\n  for (i= 0 ; i < 100 && signal_thread_in_use; i++)\n  {\n    if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL) == ESRCH)\n      break;\n    my_sleep(100);\t\t\t\t// Give it time to die\n  }\n}\n#endif /*EMBEDDED_LIBRARY*/\n\nstatic void clean_up_mutexes()\n{\n  DBUG_ENTER(\"clean_up_mutexes\");\n  mysql_rwlock_destroy(&LOCK_grant);\n  mysql_mutex_destroy(&LOCK_thread_count);\n  mysql_mutex_destroy(&LOCK_status);\n  mysql_mutex_destroy(&LOCK_delayed_insert);\n  mysql_mutex_destroy(&LOCK_delayed_status);\n  mysql_mutex_destroy(&LOCK_delayed_create);\n  mysql_mutex_destroy(&LOCK_crypt);\n  mysql_mutex_destroy(&LOCK_user_conn);\n  mysql_mutex_destroy(&LOCK_connection_count);\n  mysql_mutex_destroy(&LOCK_stats);\n  mysql_mutex_destroy(&LOCK_global_user_client_stats);\n  mysql_mutex_destroy(&LOCK_global_table_stats);\n  mysql_mutex_destroy(&LOCK_global_index_stats);\n#ifdef HAVE_OPENSSL\n  mysql_mutex_destroy(&LOCK_des_key_file);\n#ifndef HAVE_YASSL\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_destroy(&openssl_stdlocks[i].lock);\n  OPENSSL_free(openssl_stdlocks);\n#endif /* HAVE_YASSL */\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_REPLICATION\n  mysql_mutex_destroy(&LOCK_rpl_status);\n  mysql_cond_destroy(&COND_rpl_status);\n#endif /* HAVE_REPLICATION */\n  mysql_mutex_destroy(&LOCK_active_mi);\n  mysql_rwlock_destroy(&LOCK_sys_init_connect);\n  mysql_rwlock_destroy(&LOCK_sys_init_slave);\n  mysql_mutex_destroy(&LOCK_global_system_variables);\n  mysql_rwlock_destroy(&LOCK_system_variables_hash);\n  mysql_mutex_destroy(&LOCK_short_uuid_generator);\n  mysql_mutex_destroy(&LOCK_prepared_stmt_count);\n  mysql_mutex_destroy(&LOCK_error_messages);\n  mysql_cond_destroy(&COND_thread_count);\n  mysql_cond_destroy(&COND_thread_cache);\n  mysql_cond_destroy(&COND_flush_thread_cache);\n  mysql_mutex_destroy(&LOCK_server_started);\n  mysql_cond_destroy(&COND_server_started);\n  mysql_mutex_destroy(&LOCK_prepare_ordered);\n  mysql_mutex_destroy(&LOCK_commit_ordered);\n  DBUG_VOID_RETURN;\n}\n\n\n/****************************************************************************\n** Init IP and UNIX socket\n****************************************************************************/\n\n#ifndef EMBEDDED_LIBRARY\nstatic void set_ports()\n{\n  char\t*env;\n  if (!mysqld_port && !opt_disable_networking)\n  {\t\t\t\t\t// Get port if not from commandline\n    mysqld_port= MYSQL_PORT;\n\n    /*\n      if builder specifically requested a default port, use that\n      (even if it coincides with our factory default).\n      only if they didn't do we check /etc/services (and, failing\n      on that, fall back to the factory default of 3306).\n      either default can be overridden by the environment variable\n      MYSQL_TCP_PORT, which in turn can be overridden with command\n      line options.\n    */\n\n#if MYSQL_PORT_DEFAULT == 0\n    struct  servent *serv_ptr;\n    if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n      mysqld_port= ntohs((u_short) serv_ptr->s_port); /* purecov: inspected */\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n      mysqld_port= (uint) atoi(env);\t\t/* purecov: inspected */\n  }\n  if (!mysqld_unix_port)\n  {\n#ifdef __WIN__\n    mysqld_unix_port= (char*) MYSQL_NAMEDPIPE;\n#else\n    mysqld_unix_port= (char*) MYSQL_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n      mysqld_unix_port= env;\t\t\t/* purecov: inspected */\n  }\n}\n\n/* Change to run as another user if started with --user */\n\nstatic struct passwd *check_user(const char *user)\n{\n#if !defined(__WIN__)\n  struct passwd *tmp_user_info;\n  uid_t user_id= geteuid();\n\n  // Don't bother if we aren't superuser\n  if (user_id)\n  {\n    if (user)\n    {\n      /* Don't give a warning, if real user is same as given with --user */\n      /* purecov: begin tested */\n      tmp_user_info= getpwnam(user);\n      if ((!tmp_user_info || user_id != tmp_user_info->pw_uid) &&\n\t  global_system_variables.log_warnings)\n        sql_print_warning(\n                    \"One can only use the --user switch if running as root\\n\");\n      /* purecov: end */\n    }\n    return NULL;\n  }\n  if (!user)\n  {\n    if (!opt_bootstrap && !opt_help)\n    {\n      sql_print_error(\"Fatal error: Please consult the Knowledge Base \"\n                      \"to find out how to run mysqld as root!\\n\");\n      unireg_abort(1);\n    }\n    return NULL;\n  }\n  /* purecov: begin tested */\n  if (!strcmp(user,\"root\"))\n    return NULL;                        // Avoid problem with dynamic libraries\n\n  if (!(tmp_user_info= getpwnam(user)))\n  {\n    // Allow a numeric uid to be used\n    const char *pos;\n    for (pos= user; my_isdigit(mysqld_charset,*pos); pos++) ;\n    if (*pos)                                   // Not numeric id\n      goto err;\n    if (!(tmp_user_info= getpwuid(atoi(user))))\n      goto err;\n  }\n\n  return tmp_user_info;\n  /* purecov: end */\n\nerr:\n  sql_print_error(\"Fatal error: Can't change to run as user '%s' ;  Please check that the user exists!\\n\",user);\n  unireg_abort(1);\n#endif\n  return NULL;\n}\n\nstatic inline void allow_coredumps()\n{\n#ifdef PR_SET_DUMPABLE\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* inform kernel that process is dumpable */\n    (void) prctl(PR_SET_DUMPABLE, 1);\n  }\n#endif\n}\n\n\nstatic void set_user(const char *user, struct passwd *user_info_arg)\n{\n  /* purecov: begin tested */\n#if !defined(__WIN__)\n  DBUG_ASSERT(user_info_arg != 0);\n#ifdef HAVE_INITGROUPS\n  /*\n    We can get a SIGSEGV when calling initgroups() on some systems when NSS\n    is configured to use LDAP and the server is statically linked.  We set\n    calling_initgroups as a flag to the SIGSEGV handler that is then used to\n    output a specific message to help the user resolve this problem.\n  */\n  calling_initgroups= 1;\n  initgroups((char*) user, user_info_arg->pw_gid);\n  calling_initgroups= 0;\n#endif\n  if (setgid(user_info_arg->pw_gid) == -1)\n  {\n    sql_perror(\"setgid\");\n    unireg_abort(1);\n  }\n  if (setuid(user_info_arg->pw_uid) == -1)\n  {\n    sql_perror(\"setuid\");\n    unireg_abort(1);\n  }\n  allow_coredumps();\n#endif\n  /* purecov: end */\n}\n\n\nstatic void set_effective_user(struct passwd *user_info_arg)\n{\n#if !defined(__WIN__)\n  DBUG_ASSERT(user_info_arg != 0);\n  if (setregid((gid_t)-1, user_info_arg->pw_gid) == -1)\n  {\n    sql_perror(\"setregid\");\n    unireg_abort(1);\n  }\n  if (setreuid((uid_t)-1, user_info_arg->pw_uid) == -1)\n  {\n    sql_perror(\"setreuid\");\n    unireg_abort(1);\n  }\n  allow_coredumps();\n#endif\n}\n\n\n/** Change root user if started with @c --chroot . */\nstatic void set_root(const char *path)\n{\n#if !defined(__WIN__)\n  if (chroot(path) == -1)\n  {\n    sql_perror(\"chroot\");\n    unireg_abort(1);\n  }\n  my_setwd(\"/\", MYF(0));\n#endif\n}\n\n/**\n   Activate usage of a tcp port\n*/\n\nstatic my_socket activate_tcp_port(uint port)\n{\n  struct addrinfo *ai, *a;\n  struct addrinfo hints;\n  int error;\n  int\targ;\n  char port_buf[NI_MAXSERV];\n  my_socket ip_sock= INVALID_SOCKET;\n  DBUG_ENTER(\"activate_tcp_port\");\n  DBUG_PRINT(\"general\",(\"IP Socket is %d\",port));\n\n  bzero(&hints, sizeof (hints));\n  hints.ai_flags= AI_PASSIVE;\n  hints.ai_socktype= SOCK_STREAM;\n  hints.ai_family= AF_UNSPEC;\n\n  my_snprintf(port_buf, NI_MAXSERV, \"%d\", port);\n  error= getaddrinfo(my_bind_addr_str, port_buf, &hints, &ai);\n  if (error != 0)\n  {\n    DBUG_PRINT(\"error\",(\"Got error: %d from getaddrinfo()\", error));\n    sql_perror(ER_DEFAULT(ER_IPSOCK_ERROR));  /* purecov: tested */\n    unireg_abort(1);\t\t\t\t/* purecov: tested */\n  }\n\n  for (a= ai; a != NULL; a= a->ai_next)\n  {\n    ip_sock= socket(a->ai_family, a->ai_socktype, a->ai_protocol);\n      \n    char ip_addr[INET6_ADDRSTRLEN];\n\n    if (vio_get_normalized_ip_string(a->ai_addr, a->ai_addrlen,\n                                     ip_addr, sizeof (ip_addr)))\n    {\n      ip_addr[0]= 0;\n    }\n\n    if (ip_sock == INVALID_SOCKET)\n    {\n      sql_print_error(\"Failed to create a socket for %s '%s': errno: %d.\",\n                      (a->ai_family == AF_INET) ? \"IPv4\" : \"IPv6\",\n                      (const char *) ip_addr,\n                      (int) socket_errno);\n    }\n    else \n    {\n      sql_print_information(\"Server socket created on IP: '%s'.\",\n                          (const char *) ip_addr);\n      break;\n    }\n  }\n\n  if (ip_sock == INVALID_SOCKET)\n  {\n    DBUG_PRINT(\"error\",(\"Got error: %d from socket()\",socket_errno));\n    sql_perror(ER_DEFAULT(ER_IPSOCK_ERROR));  /* purecov: tested */\n    unireg_abort(1);\t\t\t\t/* purecov: tested */\n  }\n\n#ifndef __WIN__\n  /*\n    We should not use SO_REUSEADDR on windows as this would enable a\n    user to open two mysqld servers with the same TCP/IP port.\n  */\n  arg= 1;\n  (void) setsockopt(ip_sock,SOL_SOCKET,SO_REUSEADDR,(char*)&arg,sizeof(arg));\n#endif /* __WIN__ */\n\n#ifdef IPV6_V6ONLY\n   /*\n     For interoperability with older clients, IPv6 socket should\n     listen on both IPv6 and IPv4 wildcard addresses.\n     Turn off IPV6_V6ONLY option.\n\n     NOTE: this will work starting from Windows Vista only.\n     On Windows XP dual stack is not available, so it will not\n     listen on the corresponding IPv4-address.\n   */\n  if (a->ai_family == AF_INET6)\n  {\n    arg= 0;\n    (void) setsockopt(ip_sock, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,\n              sizeof(arg));\n  }\n#endif\n  /*\n    Sometimes the port is not released fast enough when stopping and\n    restarting the server. This happens quite often with the test suite\n    on busy Linux systems. Retry to bind the address at these intervals:\n    Sleep intervals: 1, 2, 4,  6,  9, 13, 17, 22, ...\n    Retry at second: 1, 3, 7, 13, 22, 35, 52, 74, ...\n    Limit the sequence by mysqld_port_timeout (set --port-open-timeout=#).\n  */\n  int ret;\n  uint waited, retry, this_wait;\n  for (waited= 0, retry= 1; ; retry++, waited+= this_wait)\n  {\n    if (((ret= bind(ip_sock, a->ai_addr, a->ai_addrlen)) >= 0 ) ||\n        (socket_errno != SOCKET_EADDRINUSE) ||\n        (waited >= mysqld_port_timeout))\n      break;\n    sql_print_information(\"Retrying bind on TCP/IP port %u\", port);\n    this_wait= retry * retry / 3 + 1;\n    sleep(this_wait);\n  }\n  freeaddrinfo(ai);\n  if (ret < 0)\n  {\n    char buff[100];\n    sprintf(buff, \"Can't start server: Bind on TCP/IP port. Got error: %d\",\n            (int) socket_errno);\n    sql_perror(buff);\n    sql_print_error(\"Do you already have another mysqld server running on \"\n                    \"port: %u ?\", port);\n    unireg_abort(1);\n  }\n  if (listen(ip_sock,(int) back_log) < 0)\n  {\n    sql_perror(\"Can't start server: listen() on TCP/IP port\");\n    sql_print_error(\"listen() on TCP/IP failed with error %d\",\n                    socket_errno);\n    unireg_abort(1);\n  }\n  DBUG_RETURN(ip_sock);\n}\n\nstatic void network_init(void)\n{\n#ifdef HAVE_SYS_UN_H\n  struct sockaddr_un\tUNIXaddr;\n  int\targ;\n#endif\n  DBUG_ENTER(\"network_init\");\n\n  if (MYSQL_CALLBACK_ELSE(thread_scheduler, init, (), 0))\n    unireg_abort(1);\t\t\t/* purecov: inspected */\n\n  set_ports();\n\n  if (report_port == 0)\n  {\n    report_port= mysqld_port;\n  }\n#ifndef DBUG_OFF\n  if (!opt_disable_networking)\n    DBUG_ASSERT(report_port != 0);\n#endif\n  if (!opt_disable_networking && !opt_bootstrap)\n  {\n    if (mysqld_port)\n      base_ip_sock= activate_tcp_port(mysqld_port);\n    if (mysqld_extra_port)\n      extra_ip_sock= activate_tcp_port(mysqld_extra_port);\n  }\n\n#ifdef _WIN32\n  /* create named pipe */\n  if (Service.IsNT() && mysqld_unix_port[0] && !opt_bootstrap &&\n      opt_enable_named_pipe)\n  {\n\n    strxnmov(pipe_name, sizeof(pipe_name)-1, \"\\\\\\\\.\\\\pipe\\\\\",\n\t     mysqld_unix_port, NullS);\n    bzero((char*) &saPipeSecurity, sizeof(saPipeSecurity));\n    bzero((char*) &sdPipeDescriptor, sizeof(sdPipeDescriptor));\n    if (!InitializeSecurityDescriptor(&sdPipeDescriptor,\n\t\t\t\t      SECURITY_DESCRIPTOR_REVISION))\n    {\n      sql_perror(\"Can't start server : Initialize security descriptor\");\n      unireg_abort(1);\n    }\n    if (!SetSecurityDescriptorDacl(&sdPipeDescriptor, TRUE, NULL, FALSE))\n    {\n      sql_perror(\"Can't start server : Set security descriptor\");\n      unireg_abort(1);\n    }\n    saPipeSecurity.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saPipeSecurity.lpSecurityDescriptor = &sdPipeDescriptor;\n    saPipeSecurity.bInheritHandle = FALSE;\n    if ((hPipe= CreateNamedPipe(pipe_name,\n        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,\n        PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,\n        PIPE_UNLIMITED_INSTANCES,\n        (int) global_system_variables.net_buffer_length,\n        (int) global_system_variables.net_buffer_length,\n        NMPWAIT_USE_DEFAULT_WAIT,\n        &saPipeSecurity)) == INVALID_HANDLE_VALUE)\n    {\n      sql_perror(\"Create named pipe failed\");\n      unireg_abort(1);\n    }\n  }\n#endif\n\n#if defined(HAVE_SYS_UN_H)\n  /*\n  ** Create the UNIX socket\n  */\n  if (mysqld_unix_port[0] && !opt_bootstrap)\n  {\n    DBUG_PRINT(\"general\",(\"UNIX Socket is %s\",mysqld_unix_port));\n\n    if (strlen(mysqld_unix_port) > (sizeof(UNIXaddr.sun_path) - 1))\n    {\n      sql_print_error(\"The socket file path is too long (> %u): %s\",\n                      (uint) sizeof(UNIXaddr.sun_path) - 1, mysqld_unix_port);\n      unireg_abort(1);\n    }\n    if ((unix_sock= socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n    {\n      sql_perror(\"Can't start server : UNIX Socket \"); /* purecov: inspected */\n      unireg_abort(1);\t\t\t\t/* purecov: inspected */\n    }\n    bzero((char*) &UNIXaddr, sizeof(UNIXaddr));\n    UNIXaddr.sun_family = AF_UNIX;\n    strmov(UNIXaddr.sun_path, mysqld_unix_port);\n    (void) unlink(mysqld_unix_port);\n    arg= 1;\n    (void) setsockopt(unix_sock,SOL_SOCKET,SO_REUSEADDR,(char*)&arg,\n\t\t      sizeof(arg));\n    umask(0);\n    if (bind(unix_sock, reinterpret_cast<struct sockaddr *>(&UNIXaddr),\n\t     sizeof(UNIXaddr)) < 0)\n    {\n      sql_perror(\"Can't start server : Bind on unix socket\"); /* purecov: tested */\n      sql_print_error(\"Do you already have another mysqld server running on socket: %s ?\",mysqld_unix_port);\n      unireg_abort(1);\t\t\t\t\t/* purecov: tested */\n    }\n    umask(((~my_umask) & 0666));\n#if defined(S_IFSOCK) && defined(SECURE_SOCKETS)\n    (void) chmod(mysqld_unix_port,S_IFSOCK);\t/* Fix solaris 2.6 bug */\n#endif\n    if (listen(unix_sock,(int) back_log) < 0)\n      sql_print_warning(\"listen() on Unix socket failed with error %d\",\n\t\t      socket_errno);\n  }\n#endif\n  DBUG_PRINT(\"info\",(\"server started\"));\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Close a connection.\n\n  @param thd        Thread handle.\n  @param sql_errno  The error code to send before disconnect.\n\n  @note\n    For the connection that is doing shutdown, this is called twice\n*/\nvoid close_connection(THD *thd, uint sql_errno)\n{\n  DBUG_ENTER(\"close_connection\");\n\n  if (sql_errno)\n    net_send_error(thd, sql_errno, ER_DEFAULT(sql_errno), NULL);\n\n  thd->print_aborted_warning(3, sql_errno ? ER_DEFAULT(sql_errno)\n                                          : \"CLOSE_CONNECTION\");\n\n  thd->disconnect();\n\n  MYSQL_CONNECTION_DONE((int) sql_errno, thd->thread_id);\n\n  if (MYSQL_CONNECTION_DONE_ENABLED())\n  {\n    sleep(0); /* Workaround to avoid tailcall optimisation */\n  }\n  MYSQL_AUDIT_NOTIFY_CONNECTION_DISCONNECT(thd, sql_errno);\n  DBUG_VOID_RETURN;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/** Called when mysqld is aborted with ^C */\n/* ARGSUSED */\nextern \"C\" sig_handler end_mysqld_signal(int sig __attribute__((unused)))\n{\n  DBUG_ENTER(\"end_mysqld_signal\");\n  /* Don't call kill_mysql() if signal thread is not running */\n  if (signal_thread_in_use)\n    kill_mysql();                          // Take down mysqld nicely\n  DBUG_VOID_RETURN;\t\t\t\t/* purecov: deadcode */\n}\n\n\n/*\n  Cleanup THD object\n\n  SYNOPSIS\n    thd_cleanup()\n    thd\t\t Thread handler\n*/\n\nvoid thd_cleanup(THD *thd)\n{\n  thd->cleanup();\n}\n\n/*\n  Decrease number of connections\n\n  SYNOPSIS\n    dec_connection_count()\n*/\n\nvoid dec_connection_count(THD *thd)\n{\n  mysql_mutex_lock(&LOCK_connection_count);\n  (*thd->scheduler->connection_count)--;\n  mysql_mutex_unlock(&LOCK_connection_count);\n}\n\n\n/*\n  Unlink thd from global list of available connections and free thd\n\n  SYNOPSIS\n    unlink_thd()\n    thd\t\t Thread handler\n\n  NOTES\n    LOCK_thread_count is locked and left locked\n*/\n\nvoid unlink_thd(THD *thd)\n{\n  DBUG_ENTER(\"unlink_thd\");\n  DBUG_PRINT(\"enter\", (\"thd: 0x%lx\", (long) thd));\n\n  thd_cleanup(thd);\n  dec_connection_count(thd);\n\n  thd->add_status_to_global();\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  thd->unlink();\n  /*\n    Used by binlog_reset_master.  It would be cleaner to use\n    DEBUG_SYNC here, but that's not possible because the THD's debug\n    sync feature has been shut down at this point.\n  */\n  DBUG_EXECUTE_IF(\"sleep_after_lock_thread_count_before_delete_thd\", sleep(5););\n  if (unlikely(abort_loop))\n  {\n    /*\n      During shutdown, we have to delete thd inside the mutex\n      to not refer to mutexes that may be deleted during shutdown\n    */\n    delete thd;\n    thd= 0;\n  }\n  thread_count--;\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  delete thd;\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Store thread in cache for reuse by new connections\n\n  SYNOPSIS\n    cache_thread()\n\n  NOTES\n    LOCK_thread_count has to be locked\n\n  RETURN\n    0  Thread was not put in cache\n    1  Thread is to be reused by new connection.\n       (ie, caller should return, not abort with pthread_exit())\n*/\n\n\nstatic bool cache_thread()\n{\n  mysql_mutex_assert_owner(&LOCK_thread_count);\n  if (cached_thread_count < thread_cache_size &&\n      ! abort_loop && !kill_cached_threads)\n  {\n    /* Don't kill the thread, just put it in cache for reuse */\n    DBUG_PRINT(\"info\", (\"Adding thread to cache\"));\n    cached_thread_count++;\n\n#ifdef HAVE_PSI_INTERFACE\n    /*\n      Delete the instrumentation for the job that just completed,\n      before parking this pthread in the cache (blocked on COND_thread_cache).\n    */\n    if (likely(PSI_server != NULL))\n      PSI_server->delete_current_thread();\n#endif\n\n    while (!abort_loop && ! wake_thread && ! kill_cached_threads)\n      mysql_cond_wait(&COND_thread_cache, &LOCK_thread_count);\n    cached_thread_count--;\n    if (kill_cached_threads)\n      mysql_cond_signal(&COND_flush_thread_cache);\n    if (wake_thread)\n    {\n      THD *thd;\n      wake_thread--;\n      thd= thread_cache.get();\n      thd->thread_stack= (char*) &thd;          // For store_globals\n      (void) thd->store_globals();\n\n#ifdef HAVE_PSI_INTERFACE\n      /*\n        Create new instrumentation for the new THD job,\n        and attach it to this running pthread.\n      */\n      if (likely(PSI_server != NULL))\n      {\n        PSI_thread *psi= PSI_server->new_thread(key_thread_one_connection,\n                                                thd, thd->thread_id);\n        if (likely(psi != NULL))\n          PSI_server->set_thread(psi);\n      }\n#endif\n\n      /*\n        THD::mysys_var::abort is associated with physical thread rather\n        than with THD object. So we need to reset this flag before using\n        this thread for handling of new THD object/connection.\n      */\n      thd->mysys_var->abort= 0;\n      thd->thr_create_utime= microsecond_interval_timer();\n      thd->start_utime= thd->thr_create_utime;\n      threads.append(thd);\n      return(1);\n    }\n  }\n  return(0);\n}\n\n\n/*\n  End thread for the current connection\n\n  SYNOPSIS\n    one_thread_per_connection_end()\n    thd\t\t  Thread handler\n    put_in_cache  Store thread in cache, if there is room in it\n                  Normally this is true in all cases except when we got\n                  out of resources initializing the current thread\n\n  NOTES\n    If thread is cached, we will wait until thread is scheduled to be\n    reused and then we will return.\n    If thread is not cached, we end the thread.\n\n  RETURN\n    0    Signal to handle_one_connection to reuse connection\n*/\n\nbool one_thread_per_connection_end(THD *thd, bool put_in_cache)\n{\n  DBUG_ENTER(\"one_thread_per_connection_end\");\n  unlink_thd(thd);\n  /* Mark that current_thd is not valid anymore */\n  my_pthread_setspecific_ptr(THR_THD,  0);\n  if (put_in_cache)\n  {\n    mysql_mutex_lock(&LOCK_thread_count);\n    put_in_cache= cache_thread();\n    mysql_mutex_unlock(&LOCK_thread_count);\n    if (put_in_cache)\n      DBUG_RETURN(0);                             // Thread is reused\n  }\n\n  /* It's safe to broadcast outside a lock (COND... is not deleted here) */\n  DBUG_PRINT(\"signal\", (\"Broadcasting COND_thread_count\"));\n  DBUG_LEAVE;                                   // Must match DBUG_ENTER()\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  ERR_remove_state(0);\n#endif\n  my_thread_end();\n  mysql_cond_broadcast(&COND_thread_count);\n\n  pthread_exit(0);\n  return 0;                                     // Avoid compiler warnings\n}\n\n\nvoid flush_thread_cache()\n{\n  mysql_mutex_lock(&LOCK_thread_count);\n  kill_cached_threads++;\n  while (cached_thread_count)\n  {\n    mysql_cond_broadcast(&COND_thread_cache);\n    mysql_cond_wait(&COND_flush_thread_cache, &LOCK_thread_count);\n  }\n  kill_cached_threads--;\n  mysql_mutex_unlock(&LOCK_thread_count);\n}\n\n\n/******************************************************************************\n  Setup a signal thread with handles all signals.\n  Because Linux doesn't support schemas use a mutex to check that\n  the signal thread is ready before continuing\n******************************************************************************/\n\n#if defined(__WIN__)\n\n\n/*\n  On Windows, we use native SetConsoleCtrlHandler for handle events like Ctrl-C\n  with graceful shutdown.\n  Also, we do not use signal(), but SetUnhandledExceptionFilter instead - as it\n  provides possibility to pass the exception to just-in-time debugger, collect\n  dumps and potentially also the exception and thread context used to output\n  callstack.\n*/\n\nstatic BOOL WINAPI console_event_handler( DWORD type ) \n{\n  DBUG_ENTER(\"console_event_handler\");\n#ifndef EMBEDDED_LIBRARY\n  if(type == CTRL_C_EVENT)\n  {\n     /*\n       Do not shutdown before startup is finished and shutdown\n       thread is initialized. Otherwise there is a race condition \n       between main thread doing initialization and CTRL-C thread doing\n       cleanup, which can result into crash.\n     */\n#ifndef EMBEDDED_LIBRARY\n     if(hEventShutdown)\n       kill_mysql();\n     else\n#endif\n       sql_print_warning(\"CTRL-C ignored during startup\");\n     DBUG_RETURN(TRUE);\n  }\n#endif\n  DBUG_RETURN(FALSE);\n}\n\n\n\n\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n#define DEBUGGER_ATTACH_TIMEOUT 120\n/*\n  Wait for debugger to attach and break into debugger. If debugger is\n  not attached, resume after timeout.\n*/\nstatic void wait_for_debugger(int timeout_sec)\n{\n   if(!IsDebuggerPresent())\n   {\n     int i;\n     printf(\"Waiting for debugger to attach, pid=%u\\n\",GetCurrentProcessId());\n     fflush(stdout);\n     for(i= 0; i < timeout_sec; i++)\n     {\n       Sleep(1000);\n       if(IsDebuggerPresent())\n       {\n         /* Break into debugger */\n         __debugbreak();\n         return;\n       }\n     }\n     printf(\"pid=%u, debugger not attached after %d seconds, resuming\\n\",GetCurrentProcessId(),\n       timeout_sec);\n     fflush(stdout);\n   }\n}\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n\nLONG WINAPI my_unhandler_exception_filter(EXCEPTION_POINTERS *ex_pointers)\n{\n   static BOOL first_time= TRUE;\n   if(!first_time)\n   {\n     /*\n       This routine can be called twice, typically\n       when detaching in JIT debugger.\n       Return EXCEPTION_EXECUTE_HANDLER to terminate process.\n     */\n     return EXCEPTION_EXECUTE_HANDLER;\n   }\n   first_time= FALSE;\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n   /*\n    Unfortunately there is no clean way to debug unhandled exception filters,\n    as debugger does not stop there(also documented in MSDN) \n    To overcome, one could put a MessageBox, but this will not work in service.\n    Better solution is to print error message and sleep some minutes \n    until debugger is attached\n  */\n  wait_for_debugger(DEBUGGER_ATTACH_TIMEOUT);\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n  __try\n  {\n    my_set_exception_pointers(ex_pointers);\n    handle_fatal_signal(ex_pointers->ExceptionRecord->ExceptionCode);\n  }\n  __except(EXCEPTION_EXECUTE_HANDLER)\n  {\n    DWORD written;\n    const char msg[] = \"Got exception in exception handler!\\n\";\n    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),msg, sizeof(msg)-1, \n      &written,NULL);\n  }\n  /*\n    Return EXCEPTION_CONTINUE_SEARCH to give JIT debugger\n    (drwtsn32 or vsjitdebugger) possibility to attach,\n    if JIT debugger is configured.\n    Windows Error reporting might generate a dump here.\n  */\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\n\nstatic void init_signals(void)\n{\n  if(opt_console)\n    SetConsoleCtrlHandler(console_event_handler,TRUE);\n\n    /* Avoid MessageBox()es*/\n  _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\n   /*\n     Do not use SEM_NOGPFAULTERRORBOX in the following SetErrorMode (),\n     because it would prevent JIT debugger and Windows error reporting\n     from working. We need WER or JIT-debugging, since our own unhandled\n     exception filter is not guaranteed to work in all situation\n     (like heap corruption or stack overflow)\n   */\n  SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS\n                               | SEM_NOOPENFILEERRORBOX);\n  SetUnhandledExceptionFilter(my_unhandler_exception_filter);\n}\n\n\nstatic void start_signal_handler(void)\n{\n#ifndef EMBEDDED_LIBRARY\n  // Save vm id of this process\n  if (!opt_bootstrap)\n    create_pid_file();\n#endif /* EMBEDDED_LIBRARY */\n}\n\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /* __WIN__ */\n\n\n#if BACKTRACE_DEMANGLE\n#include <cxxabi.h>\nextern \"C\" char *my_demangle(const char *mangled_name, int *status)\n{\n  return abi::__cxa_demangle(mangled_name, NULL, NULL, status);\n}\n#endif\n\n\n/*\n  pthread_attr_setstacksize() without so much platform-dependency\n\n  Return: The actual stack size if possible.\n*/\n\n#ifndef EMBEDDED_LIBRARY\nstatic size_t my_setstacksize(pthread_attr_t *attr, size_t stacksize)\n{\n  size_t guard_size __attribute__((unused))= 0;\n\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    On IA64, half of the requested stack size is used for \"normal stack\"\n    and half for \"register stack\".  The space measured by check_stack_overrun\n    is the \"normal stack\", so double the request to make sure we have the\n    caller-expected amount of normal stack.\n\n    NOTE: there is no guarantee that the register stack can't grow faster\n    than normal stack, so it's very unclear that we won't dump core due to\n    stack overrun despite check_stack_overrun's efforts.  Experimentation\n    shows that in the execution_constants test, the register stack grows\n    less than half as fast as normal stack, but perhaps other scenarios are\n    less forgiving.  If it turns out that more space is needed for the\n    register stack, that could be forced (rather inefficiently) by using a\n    multiplier higher than 2 here.\n  */\n  stacksize *= 2;\n#endif\n\n  /*\n    On many machines, the \"guard space\" is subtracted from the requested\n    stack size, and that space is quite large on some platforms.  So add\n    it to our request, if we can find out what it is.\n  */\n#ifdef HAVE_PTHREAD_ATTR_GETGUARDSIZE\n  if (pthread_attr_getguardsize(attr, &guard_size))\n    guard_size = 0;\t\t/* if can't find it out, treat as 0 */\n#endif\n\n  pthread_attr_setstacksize(attr, stacksize + guard_size);\n\n  /* Retrieve actual stack size if possible */\n#ifdef HAVE_PTHREAD_ATTR_GETSTACKSIZE\n  {\n    size_t real_stack_size= 0;\n    /* We must ignore real_stack_size = 0 as Solaris 2.9 can return 0 here */\n    if (pthread_attr_getstacksize(attr, &real_stack_size) == 0 &&\n\treal_stack_size > guard_size)\n    {\n      real_stack_size -= guard_size;\n      if (real_stack_size < stacksize)\n      {\n\tif (global_system_variables.log_warnings)\n          sql_print_warning(\"Asked for %zu thread stack, but got %zu\",\n                            stacksize, real_stack_size);\n\tstacksize= real_stack_size;\n      }\n    }\n  }\n#endif /* !EMBEDDED_LIBRARY */\n\n#if defined(__ia64__) || defined(__ia64)\n  stacksize /= 2;\n#endif\n  return stacksize;\n}\n#endif\n\n\n#if !defined(__WIN__)\n#ifndef SA_RESETHAND\n#define SA_RESETHAND 0\n#endif /* SA_RESETHAND */\n#ifndef SA_NODEFER\n#define SA_NODEFER 0\n#endif /* SA_NODEFER */\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void init_signals(void)\n{\n  sigset_t set;\n  struct sigaction sa;\n  DBUG_ENTER(\"init_signals\");\n\n  my_sigset(THR_SERVER_ALARM,print_signal_warning); // Should never be called!\n\n  if (opt_stack_trace || (test_flags & TEST_CORE_ON_SIGNAL))\n  {\n    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n    sigemptyset(&sa.sa_mask);\n    sigprocmask(SIG_SETMASK,&sa.sa_mask,NULL);\n\n    my_init_stacktrace();\n#if defined(__amiga__)\n    sa.sa_handler=(void(*)())handle_fatal_signal;\n#else\n    sa.sa_handler=handle_fatal_signal;\n#endif\n    sigaction(SIGSEGV, &sa, NULL);\n    sigaction(SIGABRT, &sa, NULL);\n#ifdef SIGBUS\n    sigaction(SIGBUS, &sa, NULL);\n#endif\n    sigaction(SIGILL, &sa, NULL);\n    sigaction(SIGFPE, &sa, NULL);\n  }\n\n#ifdef HAVE_GETRLIMIT\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* Change limits so that we will get a core file */\n    STRUCT_RLIMIT rl;\n    rl.rlim_cur = rl.rlim_max = (rlim_t) RLIM_INFINITY;\n    if (setrlimit(RLIMIT_CORE, &rl) && global_system_variables.log_warnings)\n      sql_print_warning(\"setrlimit could not change the size of core files to 'infinity';  We may not be able to generate a core file on signals\");\n  }\n#endif\n  (void) sigemptyset(&set);\n  my_sigset(SIGPIPE,SIG_IGN);\n  sigaddset(&set,SIGPIPE);\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  sigaddset(&set,SIGQUIT);\n  sigaddset(&set,SIGHUP);\n#endif\n  sigaddset(&set,SIGTERM);\n\n  /* Fix signals if blocked by parents (can happen on Mac OS X) */\n  sigemptyset(&sa.sa_mask);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGTERM, &sa, (struct sigaction*) 0);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGHUP, &sa, (struct sigaction*) 0);\n  if (thd_lib_detected != THD_LIB_LT)\n    sigaddset(&set,THR_SERVER_ALARM);\n  if (test_flags & TEST_SIGINT)\n  {\n    /* Allow SIGINT to break mysqld. This is for debugging with --gdb */\n    my_sigset(SIGINT, end_mysqld_signal);\n    sigdelset(&set, SIGINT);\n  }\n  else\n  {\n    sigaddset(&set,SIGINT);\n#ifdef SIGTSTP\n    sigaddset(&set,SIGTSTP);\n#endif\n  }\n\n  sigprocmask(SIG_SETMASK,&set,NULL);\n  pthread_sigmask(SIG_SETMASK,&set,NULL);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void start_signal_handler(void)\n{\n  int error;\n  pthread_attr_t thr_attr;\n  DBUG_ENTER(\"start_signal_handler\");\n\n  (void) pthread_attr_init(&thr_attr);\n  pthread_attr_setscope(&thr_attr,PTHREAD_SCOPE_SYSTEM);\n  (void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED);\n  (void) my_setstacksize(&thr_attr,my_thread_stack_size);\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  if ((error= mysql_thread_create(key_thread_signal_hand,\n                                  &signal_thread, &thr_attr, signal_hand, 0)))\n  {\n    sql_print_error(\"Can't create interrupt-thread (error %d, errno: %d)\",\n\t\t    error,errno);\n    exit(1);\n  }\n  mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  (void) pthread_attr_destroy(&thr_attr);\n  DBUG_VOID_RETURN;\n}\n\n\n/** This threads handles all signals and alarms. */\n/* ARGSUSED */\npthread_handler_t signal_hand(void *arg __attribute__((unused)))\n{\n  sigset_t set;\n  int sig;\n  my_thread_init();\t\t\t\t// Init new thread\n  DBUG_ENTER(\"signal_hand\");\n  signal_thread_in_use= 1;\n\n  /*\n    Setup alarm handler\n    This should actually be '+ max_number_of_slaves' instead of +10,\n    but the +10 should be quite safe.\n  */\n  init_thr_alarm(thread_scheduler->max_threads + extra_max_connections +\n\t\t global_system_variables.max_insert_delayed_threads + 10);\n  if (test_flags & TEST_SIGINT)\n  {\n    /* Allow SIGINT to break mysqld. This is for debugging with --gdb */\n    (void) sigemptyset(&set);\n    (void) sigaddset(&set,SIGINT);\n    (void) pthread_sigmask(SIG_UNBLOCK,&set,NULL);\n  }\n  (void) sigemptyset(&set);\t\t\t// Setup up SIGINT for debug\n#ifdef USE_ONE_SIGNAL_HAND\n  (void) sigaddset(&set,THR_SERVER_ALARM);\t// For alarms\n#endif\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  (void) sigaddset(&set,SIGQUIT);\n  (void) sigaddset(&set,SIGHUP);\n#endif\n  (void) sigaddset(&set,SIGTERM);\n  (void) sigaddset(&set,SIGTSTP);\n\n  /* Save pid to this process (or thread on Linux) */\n  if (!opt_bootstrap)\n    create_pid_file();\n\n  /*\n    signal to start_signal_handler that we are ready\n    This works by waiting for start_signal_handler to free mutex,\n    after which we signal it that we are ready.\n    At this pointer there is no other threads running, so there\n    should not be any other mysql_cond_signal() calls.\n  */\n  mysql_mutex_lock(&LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  mysql_cond_broadcast(&COND_thread_count);\n\n  (void) pthread_sigmask(SIG_BLOCK,&set,NULL);\n  for (;;)\n  {\n    int error;\t\t\t\t\t// Used when debugging\n    if (shutdown_in_progress && !abort_loop)\n    {\n      sig= SIGTERM;\n      error=0;\n    }\n    else\n      while ((error=my_sigwait(&set,&sig)) == EINTR) ;\n    if (cleanup_done)\n    {\n      DBUG_PRINT(\"quit\",(\"signal_handler: calling my_thread_end()\"));\n      my_thread_end();\n      DBUG_LEAVE;                               // Must match DBUG_ENTER()\n      signal_thread_in_use= 0;\n      pthread_exit(0);\t\t\t\t// Safety\n      return 0;                                 // Avoid compiler warnings\n    }\n    switch (sig) {\n    case SIGTERM:\n    case SIGQUIT:\n    case SIGKILL:\n#ifdef EXTRA_DEBUG\n      sql_print_information(\"Got signal %d to shutdown mysqld\",sig);\n#endif\n      /* switch to the old log message processing */\n      logger.set_handlers(LOG_FILE, opt_slow_log ? LOG_FILE:LOG_NONE,\n                          opt_log ? LOG_FILE:LOG_NONE);\n      DBUG_PRINT(\"info\",(\"Got signal: %d  abort_loop: %d\",sig,abort_loop));\n      if (!abort_loop)\n      {\n\tabort_loop=1;\t\t\t\t// mark abort for threads\n#ifdef HAVE_PSI_INTERFACE\n        /* Delete the instrumentation for the signal thread */\n        if (likely(PSI_server != NULL))\n          PSI_server->delete_current_thread();\n#endif\n#ifdef USE_ONE_SIGNAL_HAND\n\tpthread_t tmp;\n        if ((error= mysql_thread_create(0, /* Not instrumented */\n                                        &tmp, &connection_attrib,\n                                        kill_server_thread,\n                                        (void*) &sig)))\n          sql_print_error(\"Can't create thread to kill server (errno= %d)\",\n                          error);\n#else\n\tkill_server((void*) sig);\t// MIT THREAD has a alarm thread\n#endif\n      }\n      break;\n    case SIGHUP:\n      if (!abort_loop)\n      {\n        int not_used;\n\tmysql_print_status();\t\t// Print some debug info\n\treload_acl_and_cache((THD*) 0,\n\t\t\t     (REFRESH_LOG | REFRESH_TABLES | REFRESH_FAST |\n\t\t\t      REFRESH_GRANT |\n\t\t\t      REFRESH_THREADS | REFRESH_HOSTS),\n\t\t\t     (TABLE_LIST*) 0, &not_used); // Flush logs\n      }\n      /* reenable logs after the options were reloaded */\n      if (log_output_options & LOG_NONE)\n      {\n        logger.set_handlers(LOG_FILE,\n                            opt_slow_log ? LOG_TABLE : LOG_NONE,\n                            opt_log ? LOG_TABLE : LOG_NONE);\n      }\n      else\n      {\n        logger.set_handlers(LOG_FILE,\n                            opt_slow_log ? log_output_options : LOG_NONE,\n                            opt_log ? log_output_options : LOG_NONE);\n      }\n      break;\n#ifdef USE_ONE_SIGNAL_HAND\n    case THR_SERVER_ALARM:\n      process_alarm(sig);\t\t\t// Trigger alarms.\n      break;\n#endif\n    default:\n#ifdef EXTRA_DEBUG\n      sql_print_warning(\"Got signal: %d  error: %d\",sig,error); /* purecov: tested */\n#endif\n      break;\t\t\t\t\t/* purecov: tested */\n    }\n  }\n  return(0);\t\t\t\t\t/* purecov: deadcode */\n}\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /*!EMBEDDED_LIBRARY*/\n#endif\t/* __WIN__*/\n\n\n/**\n  All global error messages are sent here where the first one is stored\n  for the client.\n*/\n/* ARGSUSED */\nextern \"C\" void my_message_sql(uint error, const char *str, myf MyFlags);\n\nvoid my_message_sql(uint error, const char *str, myf MyFlags)\n{\n  THD *thd= current_thd;\n  MYSQL_ERROR::enum_warning_level level;\n  sql_print_message_func func;\n\n  DBUG_ENTER(\"my_message_sql\");\n  DBUG_PRINT(\"error\", (\"error: %u  message: '%s'  Flag: %d\", error, str, MyFlags));\n\n  DBUG_ASSERT(str != NULL);\n  DBUG_ASSERT(error != 0);\n\n  if (MyFlags & ME_JUST_INFO)\n  {\n    level= MYSQL_ERROR::WARN_LEVEL_NOTE;\n    func= sql_print_information;\n  }\n  else if (MyFlags & ME_JUST_WARNING)\n  {\n    level= MYSQL_ERROR::WARN_LEVEL_WARN;\n    func= sql_print_warning;\n  }\n  else\n  {\n    level= MYSQL_ERROR::WARN_LEVEL_ERROR;\n    func= sql_print_error;\n  }\n\n  if (thd)\n  {\n    if (MyFlags & ME_FATALERROR)\n      thd->is_fatal_error= 1;\n    (void) thd->raise_condition(error, NULL, level, str);\n  }\n  else\n    mysql_audit_general(0, MYSQL_AUDIT_GENERAL_ERROR, error, str);\n\n  /* When simulating OOM, skip writing to error log to avoid mtr errors */\n  DBUG_EXECUTE_IF(\"simulate_out_of_memory\", DBUG_VOID_RETURN;);\n\n  if (!thd || thd->log_all_errors || (MyFlags & ME_NOREFRESH))\n    (*func)(\"%s: %s\", my_progname_short, str); /* purecov: inspected */\n  DBUG_VOID_RETURN;\n}\n\n\n#ifndef EMBEDDED_LIBRARY\nextern \"C\" void *my_str_malloc_mysqld(size_t size);\nextern \"C\" void my_str_free_mysqld(void *ptr);\n\nvoid *my_str_malloc_mysqld(size_t size)\n{\n  return my_malloc(size, MYF(MY_FAE));\n}\n\n\nvoid my_str_free_mysqld(void *ptr)\n{\n  my_free(ptr);\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n#ifdef __WIN__\n\npthread_handler_t handle_shutdown(void *arg)\n{\n  MSG msg;\n  my_thread_init();\n\n  /* this call should create the message queue for this thread */\n  PeekMessage(&msg, NULL, 1, 65534,PM_NOREMOVE);\n#if !defined(EMBEDDED_LIBRARY)\n  if (WaitForSingleObject(hEventShutdown,INFINITE)==WAIT_OBJECT_0)\n#endif /* EMBEDDED_LIBRARY */\n     kill_server(MYSQL_KILL_SIGNAL);\n  return 0;\n}\n#endif\n\n#include <mysqld_default_groups.h>\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nstatic const int load_default_groups_sz=\nsizeof(load_default_groups)/sizeof(load_default_groups[0]);\n#endif\n\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  This function is used to check for stack overrun for pathological\n  cases of  regular expressions and 'like' expressions.\n  The call to current_thd is  quite expensive, so we try to avoid it\n  for the normal cases.\n  The size of  each stack frame for the wildcmp() routines is ~128 bytes,\n  so checking  *every* recursive call is not necessary.\n */\nextern \"C\" int\ncheck_enough_stack_size(int recurse_level)\n{\n  uchar stack_top;\n  if (recurse_level % 16 != 0)\n    return 0;\n\n  THD *my_thd= current_thd;\n  if (my_thd != NULL)\n    return check_stack_overrun(my_thd, STACK_MIN_SIZE * 2, &stack_top);\n  return 0;\n}\n#endif\n\n\n/**\n  Initialize one of the global date/time format variables.\n\n  @param format_type\t\tWhat kind of format should be supported\n  @param var_ptr\t\tPointer to variable that should be updated\n\n  @retval\n    0 ok\n  @retval\n    1 error\n*/\n\nstatic bool init_global_datetime_format(timestamp_type format_type,\n                                        DATE_TIME_FORMAT *format)\n{\n  /*\n    Get command line option\n    format->format.str is already set by my_getopt\n  */\n  format->format.length= strlen(format->format.str);\n\n  if (parse_date_time_format(format_type, format))\n  {\n    fprintf(stderr, \"Wrong date/time format specifier: %s\\n\",\n            format->format.str);\n    return true;\n  }\n  return false;\n}\n\nSHOW_VAR com_status_vars[]= {\n  {\"admin_commands\",       (char*) offsetof(STATUS_VAR, com_other), SHOW_LONG_STATUS},\n  {\"alter_db\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB]), SHOW_LONG_STATUS},\n  {\"alter_db_upgrade\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB_UPGRADE]), SHOW_LONG_STATUS},\n  {\"alter_event\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_EVENT]), SHOW_LONG_STATUS},\n  {\"alter_function\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_FUNCTION]), SHOW_LONG_STATUS},\n  {\"alter_procedure\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"alter_server\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_SERVER]), SHOW_LONG_STATUS},\n  {\"alter_table\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLE]), SHOW_LONG_STATUS},\n  {\"alter_tablespace\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLESPACE]), SHOW_LONG_STATUS},\n  {\"analyze\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ANALYZE]), SHOW_LONG_STATUS},\n  {\"assign_to_keycache\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ASSIGN_TO_KEYCACHE]), SHOW_LONG_STATUS},\n  {\"begin\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BEGIN]), SHOW_LONG_STATUS},\n  {\"binlog\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BINLOG_BASE64_EVENT]), SHOW_LONG_STATUS},\n  {\"call_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CALL]), SHOW_LONG_STATUS},\n  {\"change_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_DB]), SHOW_LONG_STATUS},\n  {\"change_master\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_MASTER]), SHOW_LONG_STATUS},\n  {\"check\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECK]), SHOW_LONG_STATUS},\n  {\"checksum\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECKSUM]), SHOW_LONG_STATUS},\n  {\"commit\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_COMMIT]), SHOW_LONG_STATUS},\n  {\"create_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_DB]), SHOW_LONG_STATUS},\n  {\"create_event\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_EVENT]), SHOW_LONG_STATUS},\n  {\"create_function\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SPFUNCTION]), SHOW_LONG_STATUS},\n  {\"create_index\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_INDEX]), SHOW_LONG_STATUS},\n  {\"create_procedure\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"create_server\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SERVER]), SHOW_LONG_STATUS},\n  {\"create_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TABLE]), SHOW_LONG_STATUS},\n  {\"create_trigger\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TRIGGER]), SHOW_LONG_STATUS},\n  {\"create_udf\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_FUNCTION]), SHOW_LONG_STATUS},\n  {\"create_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_USER]), SHOW_LONG_STATUS},\n  {\"create_view\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_VIEW]), SHOW_LONG_STATUS},\n  {\"dealloc_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DEALLOCATE_PREPARE]), SHOW_LONG_STATUS},\n  {\"delete\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE]), SHOW_LONG_STATUS},\n  {\"delete_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE_MULTI]), SHOW_LONG_STATUS},\n  {\"do\",                   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DO]), SHOW_LONG_STATUS},\n  {\"drop_db\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_DB]), SHOW_LONG_STATUS},\n  {\"drop_event\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_EVENT]), SHOW_LONG_STATUS},\n  {\"drop_function\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_FUNCTION]), SHOW_LONG_STATUS},\n  {\"drop_index\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_INDEX]), SHOW_LONG_STATUS},\n  {\"drop_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"drop_server\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_SERVER]), SHOW_LONG_STATUS},\n  {\"drop_table\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TABLE]), SHOW_LONG_STATUS},\n  {\"drop_trigger\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TRIGGER]), SHOW_LONG_STATUS},\n  {\"drop_user\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_USER]), SHOW_LONG_STATUS},\n  {\"drop_view\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_VIEW]), SHOW_LONG_STATUS},\n  {\"empty_query\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EMPTY_QUERY]), SHOW_LONG_STATUS},\n  {\"execute_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EXECUTE]), SHOW_LONG_STATUS},\n  {\"flush\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_FLUSH]), SHOW_LONG_STATUS},\n  {\"grant\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_GRANT]), SHOW_LONG_STATUS},\n  {\"ha_close\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_CLOSE]), SHOW_LONG_STATUS},\n  {\"ha_open\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_OPEN]), SHOW_LONG_STATUS},\n  {\"ha_read\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_READ]), SHOW_LONG_STATUS},\n  {\"help\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HELP]), SHOW_LONG_STATUS},\n  {\"insert\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT]), SHOW_LONG_STATUS},\n  {\"insert_select\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT_SELECT]), SHOW_LONG_STATUS},\n  {\"install_plugin\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSTALL_PLUGIN]), SHOW_LONG_STATUS},\n  {\"kill\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_KILL]), SHOW_LONG_STATUS},\n  {\"load\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD]), SHOW_LONG_STATUS},\n  {\"lock_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOCK_TABLES]), SHOW_LONG_STATUS},\n  {\"optimize\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_OPTIMIZE]), SHOW_LONG_STATUS},\n  {\"preload_keys\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PRELOAD_KEYS]), SHOW_LONG_STATUS},\n  {\"prepare_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PREPARE]), SHOW_LONG_STATUS},\n  {\"purge\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE]), SHOW_LONG_STATUS},\n  {\"purge_before_date\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE_BEFORE]), SHOW_LONG_STATUS},\n  {\"release_savepoint\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RELEASE_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"rename_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_TABLE]), SHOW_LONG_STATUS},\n  {\"rename_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_USER]), SHOW_LONG_STATUS},\n  {\"repair\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPAIR]), SHOW_LONG_STATUS},\n  {\"replace\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE]), SHOW_LONG_STATUS},\n  {\"replace_select\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE_SELECT]), SHOW_LONG_STATUS},\n  {\"reset\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESET]), SHOW_LONG_STATUS},\n  {\"resignal\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESIGNAL]), SHOW_LONG_STATUS},\n  {\"revoke\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE]), SHOW_LONG_STATUS},\n  {\"revoke_all\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE_ALL]), SHOW_LONG_STATUS},\n  {\"rollback\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK]), SHOW_LONG_STATUS},\n  {\"rollback_to_savepoint\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK_TO_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"savepoint\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"select\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SELECT]), SHOW_LONG_STATUS},\n  {\"set_option\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SET_OPTION]), SHOW_LONG_STATUS},\n  {\"show_authors\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_AUTHORS]), SHOW_LONG_STATUS},\n  {\"show_binlog_events\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOG_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_binlogs\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOGS]), SHOW_LONG_STATUS},\n  {\"show_charsets\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CHARSETS]), SHOW_LONG_STATUS},\n  {\"show_client_statistics\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CLIENT_STATS]), SHOW_LONG_STATUS},\n  {\"show_collations\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_COLLATIONS]), SHOW_LONG_STATUS},\n  {\"show_contributors\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CONTRIBUTORS]), SHOW_LONG_STATUS},\n  {\"show_create_db\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_DB]), SHOW_LONG_STATUS},\n  {\"show_create_event\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_EVENT]), SHOW_LONG_STATUS},\n  {\"show_create_func\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_FUNC]), SHOW_LONG_STATUS},\n  {\"show_create_proc\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_PROC]), SHOW_LONG_STATUS},\n  {\"show_create_table\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE]), SHOW_LONG_STATUS},\n  {\"show_create_trigger\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_TRIGGER]), SHOW_LONG_STATUS},\n  {\"show_databases\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_DATABASES]), SHOW_LONG_STATUS},\n  {\"show_engine_logs\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_LOGS]), SHOW_LONG_STATUS},\n  {\"show_engine_mutex\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_MUTEX]), SHOW_LONG_STATUS},\n  {\"show_engine_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_STATUS]), SHOW_LONG_STATUS},\n  {\"show_errors\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ERRORS]), SHOW_LONG_STATUS},\n  {\"show_events\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_fields\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FIELDS]), SHOW_LONG_STATUS},\n#ifndef DBUG_OFF\n  {\"show_function_code\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FUNC_CODE]), SHOW_LONG_STATUS},\n#endif\n  {\"show_function_status\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_FUNC]), SHOW_LONG_STATUS},\n  {\"show_grants\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_GRANTS]), SHOW_LONG_STATUS},\n  {\"show_index_statistics\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_INDEX_STATS]), SHOW_LONG_STATUS},\n  {\"show_keys\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_KEYS]), SHOW_LONG_STATUS},\n  {\"show_master_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_MASTER_STAT]), SHOW_LONG_STATUS},\n  {\"show_open_tables\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_OPEN_TABLES]), SHOW_LONG_STATUS},\n  {\"show_plugins\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PLUGINS]), SHOW_LONG_STATUS},\n  {\"show_privileges\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PRIVILEGES]), SHOW_LONG_STATUS},\n#ifndef DBUG_OFF\n  {\"show_procedure_code\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROC_CODE]), SHOW_LONG_STATUS},\n#endif\n  {\"show_procedure_status\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_PROC]), SHOW_LONG_STATUS},\n  {\"show_processlist\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROCESSLIST]), SHOW_LONG_STATUS},\n  {\"show_profile\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILE]), SHOW_LONG_STATUS},\n  {\"show_profiles\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILES]), SHOW_LONG_STATUS},\n  {\"show_relaylog_events\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_RELAYLOG_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_slave_hosts\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_HOSTS]), SHOW_LONG_STATUS},\n  {\"show_slave_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_STAT]), SHOW_LONG_STATUS},\n  {\"show_status\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS]), SHOW_LONG_STATUS},\n  {\"show_storage_engines\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STORAGE_ENGINES]), SHOW_LONG_STATUS},\n  {\"show_table_statistics\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATS]), SHOW_LONG_STATUS},\n  {\"show_table_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATUS]), SHOW_LONG_STATUS},\n  {\"show_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLES]), SHOW_LONG_STATUS},\n  {\"show_triggers\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TRIGGERS]), SHOW_LONG_STATUS},\n  {\"show_user_statistics\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_USER_STATS]), SHOW_LONG_STATUS},\n  {\"show_variables\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_VARIABLES]), SHOW_LONG_STATUS},\n  {\"show_warnings\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_WARNS]), SHOW_LONG_STATUS},\n  {\"signal\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SIGNAL]), SHOW_LONG_STATUS},\n  {\"slave_start\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_START]), SHOW_LONG_STATUS},\n  {\"slave_stop\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_STOP]), SHOW_LONG_STATUS},\n  {\"stmt_close\",           (char*) offsetof(STATUS_VAR, com_stmt_close), SHOW_LONG_STATUS},\n  {\"stmt_execute\",         (char*) offsetof(STATUS_VAR, com_stmt_execute), SHOW_LONG_STATUS},\n  {\"stmt_fetch\",           (char*) offsetof(STATUS_VAR, com_stmt_fetch), SHOW_LONG_STATUS},\n  {\"stmt_prepare\",         (char*) offsetof(STATUS_VAR, com_stmt_prepare), SHOW_LONG_STATUS},\n  {\"stmt_reprepare\",       (char*) offsetof(STATUS_VAR, com_stmt_reprepare), SHOW_LONG_STATUS},\n  {\"stmt_reset\",           (char*) offsetof(STATUS_VAR, com_stmt_reset), SHOW_LONG_STATUS},\n  {\"stmt_send_long_data\",  (char*) offsetof(STATUS_VAR, com_stmt_send_long_data), SHOW_LONG_STATUS},\n  {\"truncate\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_TRUNCATE]), SHOW_LONG_STATUS},\n  {\"uninstall_plugin\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNINSTALL_PLUGIN]), SHOW_LONG_STATUS},\n  {\"unlock_tables\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNLOCK_TABLES]), SHOW_LONG_STATUS},\n  {\"update\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE]), SHOW_LONG_STATUS},\n  {\"update_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE_MULTI]), SHOW_LONG_STATUS},\n  {\"xa_commit\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_COMMIT]),SHOW_LONG_STATUS},\n  {\"xa_end\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_END]),SHOW_LONG_STATUS},\n  {\"xa_prepare\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_PREPARE]),SHOW_LONG_STATUS},\n  {\"xa_recover\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_RECOVER]),SHOW_LONG_STATUS},\n  {\"xa_rollback\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_ROLLBACK]),SHOW_LONG_STATUS},\n  {\"xa_start\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_START]),SHOW_LONG_STATUS},\n  {NullS, NullS, SHOW_LONG}\n};\n\nstatic int init_common_variables()\n{\n  umask(((~my_umask) & 0666));\n  my_decimal_set_zero(&decimal_zero); // set decimal_zero constant;\n\n  tzset();\t\t\t// Set tzname\n\n  sf_leaking_memory= 0; // no memory leaks from now on\n\n  max_system_variables.pseudo_thread_id= (ulong)~0;\n  server_start_time= flush_status_time= my_time(0);\n\n  rpl_filter= new Rpl_filter;\n  binlog_filter= new Rpl_filter;\n  if (!rpl_filter || !binlog_filter)\n  {\n    sql_perror(\"Could not allocate replication and binlog filters\");\n    return 1;\n  }\n\n  if (init_thread_environment() ||\n      mysql_init_variables())\n    return 1;\n\n  if (ignore_db_dirs_init())\n    return 1;\n\n#ifdef HAVE_TZNAME\n  struct tm tm_tmp;\n  localtime_r(&server_start_time,&tm_tmp);\n  const char *tz_name=  tzname[tm_tmp.tm_isdst != 0 ? 1 : 0];\n#ifdef _WIN32\n  /*\n    Time zone name may be localized and contain non-ASCII characters,\n    Convert from ANSI encoding to UTF8.\n  */\n  wchar_t wtz_name[sizeof(system_time_zone)];\n  mbstowcs(wtz_name, tz_name, sizeof(system_time_zone)-1);\n  WideCharToMultiByte(CP_UTF8,0, wtz_name, -1, system_time_zone, \n    sizeof(system_time_zone) - 1, NULL, NULL);\n#else\n  strmake_buf(system_time_zone, tz_name);\n#endif /* _WIN32 */\n#endif /* HAVE_TZNAME */\n\n  /*\n    We set SYSTEM time zone as reasonable default and\n    also for failure of my_tz_init() and bootstrap mode.\n    If user explicitly set time zone with --default-time-zone\n    option we will change this value in my_tz_init().\n  */\n  global_system_variables.time_zone= my_tz_SYSTEM;\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Complete the mysql_bin_log initialization.\n    Instrumentation keys are known only after the performance schema initialization,\n    and can not be set in the MYSQL_BIN_LOG constructor (called before main()).\n  */\n  mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,\n                             key_BINLOG_update_cond,\n                             key_file_binlog,\n                             key_file_binlog_index,\n                             key_BINLOG_COND_queue_busy);\n#endif\n\n  /*\n    Init mutexes for the global MYSQL_BIN_LOG objects.\n    As safe_mutex depends on what MY_INIT() does, we can't init the mutexes of\n    global MYSQL_BIN_LOGs in their constructors, because then they would be\n    inited before MY_INIT(). So we do it here.\n  */\n  mysql_bin_log.init_pthread_objects();\n\n  /* TODO: remove this when my_time_t is 64 bit compatible */\n  if (!IS_TIME_T_VALID_FOR_TIMESTAMP(server_start_time))\n  {\n    sql_print_error(\"This MySQL server doesn't support dates later then 2038\");\n    return 1;\n  }\n\n  if (gethostname(glob_hostname,sizeof(glob_hostname)) < 0)\n  {\n    /*\n      Get hostname of computer (used by 'show variables') and as default\n      basename for the pid file if --log-basename is not given.\n    */\n    strmake(glob_hostname, STRING_WITH_LEN(\"localhost\"));\n    sql_print_warning(\"gethostname failed, using '%s' as hostname\",\n                        glob_hostname);\n    opt_log_basename= const_cast<char *>(\"mysql\");\n  }\n  else\n    opt_log_basename= glob_hostname;\n\n  if (!*pidfile_name)\n  {\n    strmake(pidfile_name, opt_log_basename, sizeof(pidfile_name)-5);\n    strmov(fn_ext(pidfile_name),\".pid\");\t\t// Add proper extension\n  }\n\n  /*\n    The default-storage-engine entry in my_long_options should have a\n    non-null default value. It was earlier intialized as\n    (longlong)\"MyISAM\" in my_long_options but this triggered a\n    compiler error in the Sun Studio 12 compiler. As a work-around we\n    set the def_value member to 0 in my_long_options and initialize it\n    to the correct value here.\n\n    From MySQL 5.5 onwards, the default storage engine is InnoDB\n    (except in the embedded server, where the default continues to\n    be MyISAM)\n  */\n#if defined(WITH_INNOBASE_STORAGE_ENGINE) || defined(WITH_XTRADB_STORAGE_ENGINE)\n  default_storage_engine= const_cast<char *>(\"InnoDB\");\n#else\n  default_storage_engine= const_cast<char *>(\"MyISAM\");\n#endif\n\n  /*\n    Add server status variables to the dynamic list of\n    status variables that is shown by SHOW STATUS.\n    Later, in plugin_init, and mysql_install_plugin\n    new entries could be added to that list.\n  */\n  if (add_status_vars(status_vars))\n    return 1; // an error was already reported\n\n#ifndef DBUG_OFF\n  /*\n    We have few debug-only commands in com_status_vars, only visible in debug\n    builds. for simplicity we enable the assert only in debug builds\n\n    There are 8 Com_ variables which don't have corresponding SQLCOM_ values:\n    (TODO strictly speaking they shouldn't be here, should not have Com_ prefix\n    that is. Perhaps Stmt_ ? Comstmt_ ? Prepstmt_ ?)\n\n      Com_admin_commands       => com_other\n      Com_stmt_close           => com_stmt_close\n      Com_stmt_execute         => com_stmt_execute\n      Com_stmt_fetch           => com_stmt_fetch\n      Com_stmt_prepare         => com_stmt_prepare\n      Com_stmt_reprepare       => com_stmt_reprepare\n      Com_stmt_reset           => com_stmt_reset\n      Com_stmt_send_long_data  => com_stmt_send_long_data\n\n    With this correction the number of Com_ variables (number of elements in\n    the array, excluding the last element - terminator) must match the number\n    of SQLCOM_ constants.\n  */\n  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==\n                     SQLCOM_END + 8);\n#endif\n\n  if (get_options(&remaining_argc, &remaining_argv))\n    return 1;\n  set_server_version();\n\n  if (!opt_help)\n    sql_print_information(\"%s (mysqld %s) starting as process %lu ...\",\n                          my_progname, server_version, (ulong) getpid());\n\n#ifndef EMBEDDED_LIBRARY\n  if (opt_abort && !opt_verbose)\n    unireg_abort(0);\n#endif /*!EMBEDDED_LIBRARY*/\n\n  DBUG_PRINT(\"info\",(\"%s  Ver %s for %s on %s\\n\",my_progname,\n\t\t     server_version, SYSTEM_TYPE,MACHINE_TYPE));\n\n#ifdef HAVE_LARGE_PAGES\n  /* Initialize large page size */\n  if (opt_large_pages && (opt_large_page_size= my_get_large_page_size()))\n  {\n      DBUG_PRINT(\"info\", (\"Large page set, large_page_size = %d\",\n                 opt_large_page_size));\n      my_use_large_pages= 1;\n      my_large_page_size= opt_large_page_size;\n  }\n  else\n  {\n    opt_large_pages= 0;\n    /* \n       Either not configured to use large pages or Linux haven't\n       been compiled with large page support\n    */\n  }\n#endif /* HAVE_LARGE_PAGES */\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#define LARGE_PAGESIZE (4*1024*1024)  /* 4MB */\n#define SUPER_LARGE_PAGESIZE (256*1024*1024)  /* 256MB */\n  if (opt_large_pages)\n  {\n  /*\n    tell the kernel that we want to use 4/256MB page for heap storage\n    and also for the stack. We use 4 MByte as default and if the\n    super-large-page is set we increase it to 256 MByte. 256 MByte\n    is for server installations with GBytes of RAM memory where\n    the MySQL Server will have page caches and other memory regions\n    measured in a number of GBytes.\n    We use as big pages as possible which isn't bigger than the above\n    desired page sizes.\n  */\n   int nelem;\n   size_t max_desired_page_size;\n   if (opt_super_large_pages)\n     max_desired_page_size= SUPER_LARGE_PAGESIZE;\n   else\n     max_desired_page_size= LARGE_PAGESIZE;\n   nelem = getpagesizes(NULL, 0);\n   if (nelem > 0)\n   {\n     size_t *pagesize = (size_t *) malloc(sizeof(size_t) * nelem);\n     if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0)\n     {\n       size_t max_page_size= 0;\n       for (int i= 0; i < nelem; i++)\n       {\n         if (pagesize[i] > max_page_size &&\n             pagesize[i] <= max_desired_page_size)\n            max_page_size= pagesize[i];\n       }\n       free(pagesize);\n       if (max_page_size > 0)\n       {\n         struct memcntl_mha mpss;\n\n         mpss.mha_cmd= MHA_MAPSIZE_BSSBRK;\n         mpss.mha_pagesize= max_page_size;\n         mpss.mha_flags= 0;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n         mpss.mha_cmd= MHA_MAPSIZE_STACK;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n       }\n     }\n   }\n  }\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n  /* connections and databases needs lots of files */\n  {\n    uint files, wanted_files, max_open_files;\n\n    /* MyISAM requires two file handles per table. */\n    wanted_files= (10 + max_connections + extra_max_connections +\n                   table_cache_size*2);\n    /*\n      We are trying to allocate no less than max_connections*5 file\n      handles (i.e. we are trying to set the limit so that they will\n      be available).  In addition, we allocate no less than how much\n      was already allocated.  However below we report a warning and\n      recompute values only if we got less file handles than were\n      explicitly requested.  No warning and re-computation occur if we\n      can't get max_connections*5 but still got no less than was\n      requested (value of wanted_files).\n    */\n    max_open_files= max(max(wanted_files,\n                            (max_connections + extra_max_connections)*5),\n                        open_files_limit);\n    files= my_set_max_open_files(max_open_files);\n\n    if (files < wanted_files)\n    {\n      if (!open_files_limit)\n      {\n        /*\n          If we have requested too much file handles than we bring\n          max_connections in supported bounds.\n        */\n        max_connections= (ulong) min(files-10-TABLE_OPEN_CACHE_MIN*2,\n                                     max_connections);\n        /*\n          Decrease table_cache_size according to max_connections, but\n          not below TABLE_OPEN_CACHE_MIN.  Outer min() ensures that we\n          never increase table_cache_size automatically (that could\n          happen if max_connections is decreased above).\n        */\n        table_cache_size= (ulong) min(max((files-10-max_connections)/2,\n                                          TABLE_OPEN_CACHE_MIN),\n                                      table_cache_size);\n\tDBUG_PRINT(\"warning\",\n\t\t   (\"Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld\",\n\t\t    files, max_connections, table_cache_size));\n\tif (global_system_variables.log_warnings)\n\t  sql_print_warning(\"Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld\",\n\t\t\tfiles, max_connections, table_cache_size);\n      }\n      else if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Could not increase number of max_open_files to more than %u (request: %u)\", files, wanted_files);\n    }\n    open_files_limit= files;\n  }\n  unireg_init(opt_specialflag); /* Set up extern variabels */\n  if (!(my_default_lc_messages=\n        my_locale_by_name(lc_messages)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_messages);\n    return 1;\n  }\n  global_system_variables.lc_messages= my_default_lc_messages;\n  if (init_errmessage())\t/* Read error messages from file */\n    return 1;\n  init_client_errs();\n  mysql_library_init(unused,unused,unused); /* for replication */\n  lex_init();\n  if (item_create_init())\n    return 1;\n  item_init();\n#ifndef EMBEDDED_LIBRARY\n  my_regex_init(&my_charset_latin1, check_enough_stack_size);\n  my_string_stack_guard= check_enough_stack_size;\n#else\n  my_regex_init(&my_charset_latin1, NULL);\n#endif\n  /*\n    Process a comma-separated character set list and choose\n    the first available character set. This is mostly for\n    test purposes, to be able to start \"mysqld\" even if\n    the requested character set is not available (see bug#18743).\n  */\n  for (;;)\n  {\n    char *next_character_set_name= strchr(default_character_set_name, ',');\n    if (next_character_set_name)\n      *next_character_set_name++= '\\0';\n    if (!(default_charset_info=\n          get_charset_by_csname(default_character_set_name,\n                                MY_CS_PRIMARY, MYF(MY_WME))))\n    {\n      if (next_character_set_name)\n      {\n        default_character_set_name= next_character_set_name;\n        default_collation_name= 0;          // Ignore collation\n      }\n      else\n        return 1;                           // Eof of the list\n    }\n    else\n      break;\n  }\n\n  if (default_collation_name)\n  {\n    CHARSET_INFO *default_collation;\n    default_collation= get_charset_by_name(default_collation_name, MYF(0));\n    if (!default_collation)\n    {\n      sql_print_error(ER_DEFAULT(ER_UNKNOWN_COLLATION), default_collation_name);\n      return 1;\n    }\n    if (!my_charset_same(default_charset_info, default_collation))\n    {\n      sql_print_error(ER_DEFAULT(ER_COLLATION_CHARSET_MISMATCH),\n\t\t      default_collation_name,\n\t\t      default_charset_info->csname);\n      return 1;\n    }\n    default_charset_info= default_collation;\n  }\n  /* Set collactions that depends on the default collation */\n  global_system_variables.collation_server=\t default_charset_info;\n  global_system_variables.collation_database=\t default_charset_info;\n  global_system_variables.collation_connection=  default_charset_info;\n  global_system_variables.character_set_results= default_charset_info;\n  global_system_variables.character_set_client=  default_charset_info;\n\n  if (!(character_set_filesystem=\n        get_charset_by_csname(character_set_filesystem_name,\n                              MY_CS_PRIMARY, MYF(MY_WME))))\n    return 1;\n  global_system_variables.character_set_filesystem= character_set_filesystem;\n\n  if (!(my_default_lc_time_names=\n        my_locale_by_name(lc_time_names_name)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_time_names_name);\n    return 1;\n  }\n  global_system_variables.lc_time_names= my_default_lc_time_names;\n\n  /* check log options and issue warnings if needed */\n  if (opt_log && opt_logname && *opt_logname &&\n      !(log_output_options & (LOG_FILE | LOG_NONE)))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log option, log tables are used. \"\n                      \"To enable logging to files use the --log-output option.\");\n\n  if (opt_slow_log && opt_slow_logname && *opt_slow_logname &&\n      !(log_output_options & (LOG_FILE | LOG_NONE)))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log-slow-queries option, log tables are used. \"\n                      \"To enable logging to files use the --log-output=file option.\");\n\n  if (!opt_logname || !*opt_logname)\n    make_default_log_name(&opt_logname, \".log\", false);\n  if (!opt_slow_logname || !*opt_slow_logname)\n    make_default_log_name(&opt_slow_logname, \"-slow.log\", false);\n\n#if defined(ENABLED_DEBUG_SYNC)\n  /* Initialize the debug sync facility. See debug_sync.cc. */\n  if (debug_sync_init())\n    return 1; /* purecov: tested */\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n#if (ENABLE_TEMP_POOL)\n  if (use_temp_pool && bitmap_init(&temp_pool,0,1024,1))\n    return 1;\n#else\n  use_temp_pool= 0;\n#endif\n\n  if (my_dboptions_cache_init())\n    return 1;\n\n  /*\n    Ensure that lower_case_table_names is set on system where we have case\n    insensitive names.  If this is not done the users MyISAM tables will\n    get corrupted if accesses with names of different case.\n  */\n  DBUG_PRINT(\"info\", (\"lower_case_table_names: %d\", lower_case_table_names));\n  lower_case_file_system= test_if_case_insensitive(mysql_real_data_home);\n  if (!lower_case_table_names && lower_case_file_system == 1)\n  {\n    if (lower_case_table_names_used)\n    {\n#if MYSQL_VERSION_ID < 100100\n      if (global_system_variables.log_warnings)\n        sql_print_warning(\"You have forced lower_case_table_names to 0 through \"\n                          \"a command-line option, even though your file system \"\n                          \"'%s' is case insensitive.  This means that you can \"\n                          \"corrupt your tables if you access them using names \"\n                          \"with different letter case. You should consider \"\n                          \"changing lower_case_table_names to 1 or 2\",\n                          mysql_real_data_home);\n#else\n      sql_print_error(\"The server option 'lower_case_table_names' is \"\n                      \"configured to use case sensitive table names but the \"\n                      \"data directory resides on a case-insensitive file system. \"\n                      \"Please use a case sensitive file system for your data \"\n                      \"directory or switch to a case-insensitive table name \"\n                      \"mode.\");\n#endif\n      return 1;\n    }\n    else\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Setting lower_case_table_names=2 because file system for %s is case insensitive\", mysql_real_data_home);\n      lower_case_table_names= 2;\n    }\n  }\n  else if (lower_case_table_names == 2 &&\n           !(lower_case_file_system= (lower_case_file_system == 1)))\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_warning(\"lower_case_table_names was set to 2, even though your \"\n                        \"the file system '%s' is case sensitive.  Now setting \"\n                        \"lower_case_table_names to 0 to avoid future problems.\",\n\t\t\tmysql_real_data_home);\n    lower_case_table_names= 0;\n  }\n  else\n  {\n    lower_case_file_system= (lower_case_file_system == 1);\n  }\n\n  /* Reset table_alias_charset, now that lower_case_table_names is set. */\n  table_alias_charset= (lower_case_table_names ?\n\t\t\tfiles_charset_info :\n\t\t\t&my_charset_bin);\n\n  if (ignore_db_dirs_process_additions())\n  {\n    sql_print_error(\"An error occurred while storing ignore_db_dirs to a hash.\");\n    return 1;\n  }\n\n  return 0;\n}\n\n\nstatic int init_thread_environment()\n{\n  mysql_mutex_init(key_LOCK_thread_count, &LOCK_thread_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_status, &LOCK_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_insert,\n                   &LOCK_delayed_insert, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_status,\n                   &LOCK_delayed_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_create,\n                   &LOCK_delayed_create, MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_crypt, &LOCK_crypt, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_user_conn, &LOCK_user_conn, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_active_mi, &LOCK_active_mi, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_system_variables,\n                   &LOCK_global_system_variables, MY_MUTEX_INIT_FAST);\n  mysql_rwlock_init(key_rwlock_LOCK_system_variables_hash,\n                    &LOCK_system_variables_hash);\n  mysql_mutex_init(key_LOCK_prepared_stmt_count,\n                   &LOCK_prepared_stmt_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_error_messages,\n                   &LOCK_error_messages, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_uuid_short_generator,\n                   &LOCK_short_uuid_generator, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_connection_count,\n                   &LOCK_connection_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_stats, &LOCK_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_user_client_stats,\n                   &LOCK_global_user_client_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_table_stats,\n                   &LOCK_global_table_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_index_stats,\n                   &LOCK_global_index_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_prepare_ordered, &LOCK_prepare_ordered,\n                   MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_commit_ordered, &LOCK_commit_ordered,\n                   MY_MUTEX_INIT_SLOW);\n\n#ifdef HAVE_OPENSSL\n  mysql_mutex_init(key_LOCK_des_key_file,\n                   &LOCK_des_key_file, MY_MUTEX_INIT_FAST);\n#ifndef HAVE_YASSL\n  openssl_stdlocks= (openssl_lock_t*) OPENSSL_malloc(CRYPTO_num_locks() *\n                                                     sizeof(openssl_lock_t));\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_init(key_rwlock_openssl, &openssl_stdlocks[i].lock);\n  CRYPTO_set_dynlock_create_callback(openssl_dynlock_create);\n  CRYPTO_set_dynlock_destroy_callback(openssl_dynlock_destroy);\n  CRYPTO_set_dynlock_lock_callback(openssl_lock);\n  CRYPTO_set_locking_callback(openssl_lock_function);\n#endif\n#endif\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_connect, &LOCK_sys_init_connect);\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_slave, &LOCK_sys_init_slave);\n  mysql_rwlock_init(key_rwlock_LOCK_grant, &LOCK_grant);\n  mysql_cond_init(key_COND_thread_count, &COND_thread_count, NULL);\n  mysql_cond_init(key_COND_thread_cache, &COND_thread_cache, NULL);\n  mysql_cond_init(key_COND_flush_thread_cache, &COND_flush_thread_cache, NULL);\n#ifdef HAVE_REPLICATION\n  mysql_mutex_init(key_LOCK_rpl_status, &LOCK_rpl_status, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_rpl_status, &COND_rpl_status, NULL);\n#endif\n  mysql_mutex_init(key_LOCK_server_started,\n                   &LOCK_server_started, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_server_started, &COND_server_started, NULL);\n  sp_cache_init();\n#ifdef HAVE_EVENT_SCHEDULER\n  Events::init_mutexes();\n#endif\n  /* Parameter for threads created for connections */\n  (void) pthread_attr_init(&connection_attrib);\n  (void) pthread_attr_setdetachstate(&connection_attrib,\n\t\t\t\t     PTHREAD_CREATE_DETACHED);\n  pthread_attr_setscope(&connection_attrib, PTHREAD_SCOPE_SYSTEM);\n\n  if (pthread_key_create(&THR_THD,NULL) ||\n      pthread_key_create(&THR_MALLOC,NULL))\n  {\n    sql_print_error(\"Can't create thread-keys\");\n    return 1;\n  }\n  return 0;\n}\n\n\n#if defined(HAVE_OPENSSL) && !defined(HAVE_YASSL)\nstatic openssl_lock_t *openssl_dynlock_create(const char *file, int line)\n{\n  openssl_lock_t *lock= new openssl_lock_t;\n  mysql_rwlock_init(key_rwlock_openssl, &lock->lock);\n  return lock;\n}\n\n\nstatic void openssl_dynlock_destroy(openssl_lock_t *lock, const char *file,\n\t\t\t\t    int line)\n{\n  mysql_rwlock_destroy(&lock->lock);\n  delete lock;\n}\n\n\nstatic void openssl_lock_function(int mode, int n, const char *file, int line)\n{\n  if (n < 0 || n > CRYPTO_num_locks())\n  {\n    /* Lock number out of bounds. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (n = %d)\", n);\n    abort();\n  }\n  openssl_lock(mode, &openssl_stdlocks[n], file, line);\n}\n\n\nstatic void openssl_lock(int mode, openssl_lock_t *lock, const char *file,\n\t\t\t int line)\n{\n  int err;\n  char const *what;\n\n  switch (mode) {\n  case CRYPTO_LOCK|CRYPTO_READ:\n    what = \"read lock\";\n    err= mysql_rwlock_rdlock(&lock->lock);\n    break;\n  case CRYPTO_LOCK|CRYPTO_WRITE:\n    what = \"write lock\";\n    err= mysql_rwlock_wrlock(&lock->lock);\n    break;\n  case CRYPTO_UNLOCK|CRYPTO_READ:\n  case CRYPTO_UNLOCK|CRYPTO_WRITE:\n    what = \"unlock\";\n    err= mysql_rwlock_unlock(&lock->lock);\n    break;\n  default:\n    /* Unknown locking mode. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (mode=0x%x)\", mode);\n    abort();\n  }\n  if (err)\n  {\n    sql_print_error(\"Fatal: can't %s OpenSSL lock\", what);\n    abort();\n  }\n}\n#endif /* HAVE_OPENSSL */\n\n\nstatic void init_ssl()\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    enum enum_ssl_init_error error= SSL_INITERR_NOERROR;\n\n    /* having ssl_acceptor_fd != 0 signals the use of SSL */\n    ssl_acceptor_fd= new_VioSSLAcceptorFd(opt_ssl_key, opt_ssl_cert,\n\t\t\t\t\t  opt_ssl_ca, opt_ssl_capath,\n\t\t\t\t\t  opt_ssl_cipher, &error);\n    DBUG_PRINT(\"info\",(\"ssl_acceptor_fd: 0x%lx\", (long) ssl_acceptor_fd));\n    ERR_remove_state(0);\n    if (!ssl_acceptor_fd)\n    {\n      sql_print_warning(\"Failed to setup SSL\");\n      sql_print_warning(\"SSL error: %s\", sslGetErrString(error));\n      opt_use_ssl = 0;\n      have_ssl= SHOW_OPTION_DISABLED;\n    }\n  }\n  else\n  {\n    have_ssl= SHOW_OPTION_DISABLED;\n  }\n  if (des_key_file)\n    load_des_key_file(des_key_file);\n#endif /* HAVE_OPENSSL && ! EMBEDDED_LIBRARY */\n}\n\n\nstatic void end_ssl()\n{\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  if (ssl_acceptor_fd)\n  {\n    free_vio_ssl_acceptor_fd(ssl_acceptor_fd);\n    ssl_acceptor_fd= 0;\n  }\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n}\n\n#ifdef _WIN32\n/**\n  Registers a file to be collected when Windows Error Reporting creates a crash \n  report.\n\n  @note only works on Vista and later, since WerRegisterFile() is not available\n  on earlier Windows.\n*/\n#include <werapi.h>\nstatic void add_file_to_crash_report(char *file)\n{\n  /* Load WerRegisterFile function dynamically.*/\n  HRESULT (WINAPI *pWerRegisterFile)(PCWSTR, WER_REGISTER_FILE_TYPE, DWORD)\n    =(HRESULT (WINAPI *) (PCWSTR, WER_REGISTER_FILE_TYPE, DWORD))\n    GetProcAddress(GetModuleHandle(\"kernel32\"),\"WerRegisterFile\");\n\n  if (pWerRegisterFile)\n  {\n    wchar_t wfile[MAX_PATH+1]= {0};\n    if (mbstowcs(wfile, file, MAX_PATH) != (size_t)-1)\n    {\n      pWerRegisterFile(wfile, WerRegFileTypeOther, WER_FILE_ANONYMOUS_DATA);\n    }\n  }\n}\n#endif\n\nstatic int init_server_components()\n{\n  DBUG_ENTER(\"init_server_components\");\n  /*\n    We need to call each of these following functions to ensure that\n    all things are initialized so that unireg_abort() doesn't fail\n  */\n  mdl_init();\n  if (table_def_init() | hostname_cache_init())\n    unireg_abort(1);\n\n  query_cache_set_min_res_unit(query_cache_min_res_unit);\n  query_cache_init();\n  query_cache_resize(query_cache_size);\n  my_rnd_init(&sql_rand,(ulong) server_start_time,(ulong) server_start_time/2);\n  setup_fpu();\n  init_thr_lock();\n  my_uuid_init((ulong) (my_rnd(&sql_rand))*12345,12345);\n#ifdef HAVE_REPLICATION\n  init_slave_list();\n#endif\n  wt_init();\n\n  /* Setup logs */\n\n  /*\n    Enable old-fashioned error log, except when the user has requested\n    help information. Since the implementation of plugin server\n    variables the help output is now written much later.\n  */\n  if (opt_error_log && !opt_abort)\n  {\n    if (!log_error_file_ptr[0])\n      fn_format(log_error_file, pidfile_name, mysql_data_home, \".err\",\n                MY_REPLACE_EXT); /* replace '.<domain>' by '.err', bug#4997 */\n    else\n      fn_format(log_error_file, log_error_file_ptr, mysql_data_home, \".err\",\n                MY_UNPACK_FILENAME | MY_SAFE_PATH);\n    /*\n      _ptr may have been set to my_disabled_option or \"\" if no argument was\n      passed, but we need to show the real name in SHOW VARIABLES:\n    */\n    log_error_file_ptr= log_error_file;\n    if (!log_error_file[0])\n      opt_error_log= 0;                         // Too long file name\n    else\n    {\n      my_bool res;\n#ifndef EMBEDDED_LIBRARY\n      res= reopen_fstreams(log_error_file, stdout, stderr);\n#else\n      res= reopen_fstreams(log_error_file, NULL, stderr);\n#endif\n\n      if (!res)\n        setbuf(stderr, NULL);\n\n#ifdef _WIN32\n      /* Add error log to windows crash reporting. */\n      add_file_to_crash_report(log_error_file);\n#endif\n    }\n  }\n\n  /* set up the hook before initializing plugins which may use it */\n  error_handler_hook= my_message_sql;\n  proc_info_hook= set_thd_proc_info;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Parsing the performance schema command line option may have reported\n    warnings/information messages.\n    Now that the logger is finally available, and redirected\n    to the proper file when the --log--error option is used,\n    print the buffered messages to the log.\n  */\n  buffered_logs.print();\n  buffered_logs.cleanup();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  if (xid_cache_init())\n  {\n    sql_print_error(\"Out of memory\");\n    unireg_abort(1);\n  }\n\n  /*\n    initialize delegates for extension observers, errors have already\n    been reported in the function\n  */\n  if (delegates_init())\n    unireg_abort(1);\n\n  /* need to configure logging before initializing storage engines */\n  if (!opt_bin_log_used)\n  {\n    if (opt_log_slave_updates)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--log-slave-updates work.\");\n    if (binlog_format_used)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--binlog-format work.\");\n  }\n\n  /* Check that we have not let the format to unspecified at this point */\n  DBUG_ASSERT((uint)global_system_variables.binlog_format <=\n              array_elements(binlog_format_names)-1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_log_slave_updates && replicate_same_server_id)\n  {\n    if (opt_bin_log)\n    {\n      sql_print_error(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates is impossible, it would lead to infinite loops in this \\\nserver.\");\n      unireg_abort(1);\n    }\n    else\n      sql_print_warning(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates would lead to infinite loops in this server. However this \\\nwill be ignored as the --log-bin option is not defined.\");\n  }\n#endif\n\n  DBUG_ASSERT(!opt_bin_log || opt_bin_logname);\n\n  if (opt_bin_log)\n  {\n    /* Reports an error and aborts, if the --log-bin's path \n       is a directory.*/\n    if (opt_bin_logname[0] && \n        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin option\", opt_bin_logname);\n      unireg_abort(1);\n    }\n\n    /* Reports an error and aborts, if the --log-bin-index's path \n       is a directory.*/\n    if (opt_binlog_index_name && \n        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] \n        == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin-index option\", opt_binlog_index_name);\n      unireg_abort(1);\n    }\n\n    char buf[FN_REFLEN];\n    const char *ln;\n    ln= mysql_bin_log.generate_name(opt_bin_logname, \"-bin\", 1, buf);\n    if (!opt_bin_logname[0] && !opt_binlog_index_name)\n    {\n      /*\n        User didn't give us info to name the binlog index file.\n        Picking `hostname`-bin.index like did in 4.x, causes replication to\n        fail if the hostname is changed later. So, we would like to instead\n        require a name. But as we don't want to break many existing setups, we\n        only give warning, not error.\n      */\n      sql_print_warning(\"No argument was provided to --log-bin and \"\n                        \"neither --log-basename or --log-bin-index where \"\n                        \"used;  This may cause repliction to break when this \"\n                        \"server acts as a master and has its hostname \"\n                        \"changed! Please use '--log-basename=%s' or \"\n                        \"'--log-bin=%s' to avoid this problem.\",\n                        opt_log_basename, ln);\n    }\n    if (ln == buf)\n    {\n      opt_bin_logname= my_once_strdup(buf, MYF(MY_WME));\n    }\n    if (mysql_bin_log.open_index_file(opt_binlog_index_name, ln, TRUE))\n    {\n      unireg_abort(1);\n    }\n  }\n\n  /* call ha_init_key_cache() on all key caches to init them */\n  process_key_caches(&ha_init_key_cache, 0);\n\n  init_global_table_stats();\n  init_global_index_stats();\n\n  /* Allow storage engine to give real error messages */\n  if (ha_init_errors())\n    DBUG_RETURN(1);\n\n  tc_log= 0; // ha_initialize_handlerton() needs that\n\n  if (plugin_init(&remaining_argc, remaining_argv,\n                  (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : 0) |\n                  (opt_abort ? PLUGIN_INIT_SKIP_INITIALIZATION : 0)))\n  {\n    sql_print_error(\"Failed to initialize plugins.\");\n    unireg_abort(1);\n  }\n  plugins_are_initialized= TRUE;  /* Don't separate from init function */\n\n  have_csv= plugin_status(STRING_WITH_LEN(\"csv\"),\n                          MYSQL_STORAGE_ENGINE_PLUGIN);\n  have_ndbcluster= plugin_status(STRING_WITH_LEN(\"ndbcluster\"),\n                                 MYSQL_STORAGE_ENGINE_PLUGIN);\n  have_partitioning= plugin_status(STRING_WITH_LEN(\"partition\"),\n                                   MYSQL_STORAGE_ENGINE_PLUGIN);\n\n  /* we do want to exit if there are any other unknown options */\n  if (remaining_argc > 1)\n  {\n    int ho_error;\n    struct my_option no_opts[]=\n    {\n      {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n    };\n    /*\n      We need to eat any 'loose' arguments first before we conclude\n      that there are unprocessed options.\n    */\n    my_getopt_skip_unknown= 0;\n\n    if ((ho_error= handle_options(&remaining_argc, &remaining_argv, no_opts,\n                                  mysqld_get_one_option)))\n      unireg_abort(ho_error);\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    my_getopt_skip_unknown= TRUE;\n\n    if (remaining_argc > 1)\n    {\n      fprintf(stderr, \"%s: Too many arguments (first extra is '%s').\\n\",\n              my_progname, remaining_argv[1]);\n      unireg_abort(1);\n    }\n  }\n\n  if (opt_abort)\n    unireg_abort(0);\n\n  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */\n  if (!DEFAULT_ERRMSGS[0][0])\n    unireg_abort(1);  \n\n  /* We have to initialize the storage engines before CSV logging */\n  if (ha_init())\n  {\n    sql_print_error(\"Can't init databases\");\n    unireg_abort(1);\n  }\n\n  if (opt_bootstrap)\n    log_output_options= LOG_FILE;\n  else\n    logger.init_log_tables();\n\n  if (log_output_options & LOG_NONE)\n  {\n    /*\n      Issue a warining if there were specified additional options to the\n      log-output along with NONE. Probably this wasn't what user wanted.\n    */\n    if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))\n      sql_print_warning(\"There were other values specified to \"\n                        \"log-output besides NONE. Disabling slow \"\n                        \"and general logs anyway.\");\n    logger.set_handlers(LOG_FILE, LOG_NONE, LOG_NONE);\n  }\n  else\n  {\n    /* fall back to the log files if tables are not present */\n    LEX_STRING csv_name={C_STRING_WITH_LEN(\"csv\")};\n    if (!plugin_is_ready(&csv_name, MYSQL_STORAGE_ENGINE_PLUGIN))\n    {\n      /* purecov: begin inspected */\n      sql_print_error(\"CSV engine is not present, falling back to the \"\n                      \"log files\");\n      log_output_options= (log_output_options & ~LOG_TABLE) | LOG_FILE;\n      /* purecov: end */\n    }\n\n    logger.set_handlers(LOG_FILE, opt_slow_log ? log_output_options:LOG_NONE,\n                        opt_log ? log_output_options:LOG_NONE);\n  }\n\n  /*\n    Set the default storage engine\n  */\n  LEX_STRING name= { default_storage_engine, strlen(default_storage_engine) };\n  plugin_ref plugin;\n  handlerton *hton;\n  if ((plugin= ha_resolve_by_name(0, &name)))\n    hton= plugin_data(plugin, handlerton*);\n  else\n  {\n    sql_print_error(\"Unknown/unsupported storage engine: %s\",\n                    default_storage_engine);\n    unireg_abort(1);\n  }\n  if (!ha_storage_engine_is_enabled(hton))\n  {\n    if (!opt_bootstrap)\n    {\n      sql_print_error(\"Default storage engine (%s) is not available\",\n                      default_storage_engine);\n      unireg_abort(1);\n    }\n    DBUG_ASSERT(global_system_variables.table_plugin);\n  }\n  else\n  {\n    /*\n      Need to unlock as global_system_variables.table_plugin\n      was acquired during plugin_init()\n    */\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    plugin_unlock(0, global_system_variables.table_plugin);\n    global_system_variables.table_plugin= plugin;\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n  }\n#if defined(WITH_ARIA_STORAGE_ENGINE) && defined(USE_ARIA_FOR_TMP_TABLES)\n  if (!ha_storage_engine_is_enabled(maria_hton) && !opt_bootstrap)\n  {\n    sql_print_error(\"Aria engine is not enabled or did not start. The Aria engine must be enabled to continue as mysqld was configured with --with-aria-tmp-tables\");\n    unireg_abort(1);\n  }\n  internal_tmp_table_max_key_length=   maria_max_key_length();\n  internal_tmp_table_max_key_segments= maria_max_key_segments();\n#else\n  internal_tmp_table_max_key_length=   myisam_max_key_length();\n  internal_tmp_table_max_key_segments= myisam_max_key_segments();\n#endif\n\n  tc_log= get_tc_log_implementation();\n\n  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))\n  {\n    sql_print_error(\"Can't init tc log\");\n    unireg_abort(1);\n  }\n\n  if (ha_recover(0))\n  {\n    unireg_abort(1);\n  }\n\n  if (opt_bin_log && mysql_bin_log.open(opt_bin_logname, LOG_BIN, 0,\n                                        WRITE_CACHE, 0, max_binlog_size, 0, TRUE))\n    unireg_abort(1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_bin_log && expire_logs_days)\n  {\n    time_t purge_time= server_start_time - expire_logs_days*24*60*60;\n    if (purge_time >= 0)\n      mysql_bin_log.purge_logs_before_date(purge_time);\n  }\n#endif\n\n  if (opt_myisam_log)\n    (void) mi_log(1);\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT) && !defined(EMBEDDED_LIBRARY)\n  if (locked_in_memory && !getuid())\n  {\n    if (setreuid((uid_t)-1, 0) == -1)\n    {                        // this should never happen\n      sql_perror(\"setreuid\");\n      unireg_abort(1);\n    }\n    if (mlockall(MCL_CURRENT))\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Failed to lock memory. Errno: %d\\n\",errno);\n      locked_in_memory= 0;\n    }\n    if (user_info)\n      set_user(mysqld_user, user_info);\n  }\n  else\n#endif\n    locked_in_memory=0;\n\n  ft_init_stopwords();\n\n  init_max_user_conn();\n  init_update_queries();\n  init_global_user_stats();\n  init_global_client_stats();\n  DBUG_RETURN(0);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void create_shutdown_thread()\n{\n#ifdef __WIN__\n  hEventShutdown=CreateEvent(0, FALSE, FALSE, shutdown_event_name);\n  pthread_t hThread;\n  int error;\n  if ((error= mysql_thread_create(key_thread_handle_shutdown,\n                                  &hThread, &connection_attrib,\n                                  handle_shutdown, 0)))\n    sql_print_warning(\"Can't create thread to handle shutdown requests\"\n                      \" (errno= %d)\", error);\n\n  // On \"Stop Service\" we have to do regular shutdown\n  Service.SetShutdownEvent(hEventShutdown);\n#endif /* __WIN__ */\n}\n\n#endif /* EMBEDDED_LIBRARY */\n\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic void handle_connections_methods()\n{\n  pthread_t hThread;\n  int error;\n  DBUG_ENTER(\"handle_connections_methods\");\n  if (hPipe == INVALID_HANDLE_VALUE &&\n      (!have_tcpip || opt_disable_networking) &&\n      !opt_enable_shared_memory)\n  {\n    sql_print_error(\"TCP/IP, --shared-memory, or --named-pipe should be configured on NT OS\");\n    unireg_abort(1);\t\t\t\t// Will not return\n  }\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  mysql_cond_init(key_COND_handler_count, &COND_handler_count, NULL);\n  handler_count=0;\n  if (hPipe != INVALID_HANDLE_VALUE)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_namedpipes,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_namedpipes, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle named pipes\"\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n  if (have_tcpip && !opt_disable_networking)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_sockets,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_sockets_thread, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle TCP/IP\",\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n#ifdef HAVE_SMEM\n  if (opt_enable_shared_memory)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_sharedmem,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_shared_memory, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle shared memory\",\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n#endif\n\n  while (handler_count > 0)\n    mysql_cond_wait(&COND_handler_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  DBUG_VOID_RETURN;\n}\n\nvoid decrement_handler_count()\n{\n  mysql_mutex_lock(&LOCK_thread_count);\n  handler_count--;\n  mysql_cond_signal(&COND_handler_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  my_thread_end();\n}\n#else\n#define decrement_handler_count()\n#endif /* defined(_WIN32) || defined(HAVE_SMEM) */\n\n\n#ifndef EMBEDDED_LIBRARY\n\nLEX_STRING sql_statement_names[(uint) SQLCOM_END + 1];\n\nstatic void init_sql_statement_names()\n{\n  char *first_com= (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *last_com= (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_END]);\n  int record_size= (char*) offsetof(STATUS_VAR, com_stat[1])\n                   - (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *ptr;\n  uint i;\n  uint com_index;\n\n  for (i= 0; i < ((uint) SQLCOM_END + 1); i++)\n    sql_statement_names[i]= empty_lex_str;\n\n  SHOW_VAR *var= &com_status_vars[0];\n  while (var->name != NULL)\n  {\n    ptr= var->value;\n    if ((first_com <= ptr) && (ptr <= last_com))\n    {\n      com_index= ((int)(ptr - first_com))/record_size;\n      DBUG_ASSERT(com_index < (uint) SQLCOM_END);\n      sql_statement_names[com_index].str= const_cast<char *>(var->name);\n      sql_statement_names[com_index].length= strlen(var->name);\n    }\n    var++;\n  }\n\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SELECT].str, \"select\") == 0);\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SIGNAL].str, \"signal\") == 0);\n\n  sql_statement_names[(uint) SQLCOM_END].str= const_cast<char*>(\"error\");\n}\n\n#ifndef DBUG_OFF\n/*\n  Debugging helper function to keep the locale database\n  (see sql_locale.cc) and max_month_name_length and\n  max_day_name_length variable values in consistent state.\n*/\nstatic void test_lc_time_sz()\n{\n  DBUG_ENTER(\"test_lc_time_sz\");\n  for (MY_LOCALE **loc= my_locales; *loc; loc++)\n  {\n    uint max_month_len= 0;\n    uint max_day_len = 0;\n    for (const char **month= (*loc)->month_names->type_names; *month; month++)\n    {\n      set_if_bigger(max_month_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *month, *month + strlen(*month)));\n    }\n    for (const char **day= (*loc)->day_names->type_names; *day; day++)\n    {\n      set_if_bigger(max_day_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *day, *day + strlen(*day)));\n    }\n    if ((*loc)->max_month_name_length != max_month_len ||\n        (*loc)->max_day_name_length != max_day_len)\n    {\n      DBUG_PRINT(\"Wrong max day name(or month name) length for locale:\",\n                 (\"%s\", (*loc)->name));\n      DBUG_ASSERT(0);\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n#endif//DBUG_OFF\n\n#ifdef __WIN__\nint win_main(int argc, char **argv)\n#else\nint mysqld_main(int argc, char **argv)\n#endif\n{\n  /*\n    Perform basic thread library and malloc initialization,\n    to be able to read defaults files and parse options.\n  */\n  my_progname= argv[0];\n  sf_leaking_memory= 1; // no safemalloc memory leak reports if we exit early\n#ifdef HAVE_NPTL\n  ld_assume_kernel_is_set= (getenv(\"LD_ASSUME_KERNEL\") != 0);\n#endif\n#ifndef _WIN32\n  // For windows, my_init() is called from the win specific mysqld_main\n  if (my_init())                 // init my_sys library & pthreads\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n#endif\n\n  orig_argc= argc;\n  orig_argv= argv;\n  my_getopt_use_args_separator= TRUE;\n  if (load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv))\n    return 1;\n  my_getopt_use_args_separator= FALSE;\n  defaults_argc= argc;\n  defaults_argv= argv;\n  remaining_argc= argc;\n  remaining_argv= argv;\n\n  /* Must be initialized early for comparison of options name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  init_sql_statement_names();\n  sys_var_init();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    The performance schema needs to be initialized as early as possible,\n    before to-be-instrumented objects of the server are initialized.\n  */\n  int ho_error;\n  DYNAMIC_ARRAY all_early_options;\n\n  my_getopt_register_get_addr(NULL);\n  /* Skip unknown options so that they may be processed later */\n  my_getopt_skip_unknown= TRUE;\n\n  /* prepare all_early_options array */\n  my_init_dynamic_array(&all_early_options, sizeof(my_option), 100, 25);\n  sys_var_add_options(&all_early_options, sys_var::PARSE_EARLY);\n  add_terminator(&all_early_options);\n\n  /*\n    Logs generated while parsing the command line\n    options are buffered and printed later.\n  */\n  buffered_logs.init();\n  my_getopt_error_reporter= buffered_option_error_reporter;\n\n  ho_error= handle_options(&remaining_argc, &remaining_argv,\n                           (my_option*)(all_early_options.buffer), NULL);\n  delete_dynamic(&all_early_options);\n  if (ho_error == 0)\n  {\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    if (pfs_param.m_enabled)\n    {\n      PSI_hook= initialize_performance_schema(&pfs_param);\n      if (PSI_hook == NULL)\n      {\n        pfs_param.m_enabled= false;\n        buffered_logs.buffer(WARNING_LEVEL,\n                             \"Performance schema disabled (reason: init failed).\");\n      }\n    }\n  }\n#else\n  /*\n    Other provider of the instrumentation interface should\n    initialize PSI_hook here:\n    - HAVE_PSI_INTERFACE is for the instrumentation interface\n    - WITH_PERFSCHEMA_STORAGE_ENGINE is for one implementation\n      of the interface,\n    but there could be alternate implementations, which is why\n    these two defines are kept separate.\n  */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Obtain the current performance schema instrumentation interface,\n    if available.\n  */\n  if (PSI_hook)\n    PSI_server= (PSI*) PSI_hook->get_interface(PSI_CURRENT_VERSION);\n\n  if (PSI_server)\n  {\n    /*\n      Now that we have parsed the command line arguments, and have initialized\n      the performance schema itself, the next step is to register all the\n      server instruments.\n    */\n    init_server_psi_keys();\n    /* Instrument the main thread */\n    PSI_thread *psi= PSI_server->new_thread(key_thread_main, NULL, 0);\n    if (psi)\n      PSI_server->set_thread(psi);\n\n    /*\n      Now that some instrumentation is in place,\n      recreate objects which were initialised early,\n      so that they are instrumented as well.\n    */\n    my_thread_global_reinit();\n  }\n#endif /* HAVE_PSI_INTERFACE */\n\n  init_error_log_mutex();\n\n  /* Initialize audit interface globals. Audit plugins are inited later. */\n  mysql_audit_initialize();\n\n  /*\n    Perform basic logger initialization logger. Should be called after\n    MY_INIT, as it initializes mutexes. Log tables are inited later.\n  */\n  logger.init_base();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (ho_error)\n  {\n    /*\n      Parsing command line option failed,\n      Since we don't have a workable remaining_argc/remaining_argv\n      to continue the server initialization, this is as far as this\n      code can go.\n      This is the best effort to log meaningful messages:\n      - messages will be printed to stderr, which is not redirected yet,\n      - messages will be printed in the NT event log, for windows.\n    */\n    buffered_logs.print();\n    buffered_logs.cleanup();\n    /*\n      Not enough initializations for unireg_abort()\n      Using exit() for windows.\n    */\n    exit (ho_error);\n  }\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef _CUSTOMSTARTUPCONFIG_\n  if (_cust_check_startup())\n  {\n    / * _cust_check_startup will report startup failure error * /\n    exit(1);\n  }\n#endif\n\n  if (init_common_variables())\n    unireg_abort(1);\t\t\t\t// Will do exit\n\n  init_signals();\n\n  my_thread_stack_size= my_setstacksize(&connection_attrib,\n                                        my_thread_stack_size);\n\n  (void) thr_setconcurrency(concurrency);\t// 10 by default\n\n  select_thread=pthread_self();\n  select_thread_in_use=1;\n\n#ifdef HAVE_LIBWRAP\n  libwrapName= my_progname+dirname_length(my_progname);\n  openlog(libwrapName, LOG_PID, LOG_AUTH);\n#endif\n\n#ifndef DBUG_OFF\n  test_lc_time_sz();\n  srand((uint) time(NULL)); \n#endif\n\n  /*\n    We have enough space for fiddling with the argv, continue\n  */\n  check_data_home(mysql_real_data_home);\n  if (my_setwd(mysql_real_data_home, opt_abort ? 0 : MYF(MY_WME)) && !opt_abort)\n    unireg_abort(1);\t\t\t\t/* purecov: inspected */\n\n  if ((user_info= check_user(mysqld_user)))\n  {\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)\n    if (locked_in_memory) // getuid() == 0 here\n      set_effective_user(user_info);\n    else\n#endif\n      set_user(mysqld_user, user_info);\n  }\n\n  if (opt_bin_log && !server_id)\n  {\n    server_id= 1;\n#ifdef EXTRA_DEBUG\n    sql_print_warning(\"You have enabled the binary log, but you haven't set \"\n                      \"server-id to a non-zero value: we force server id to 1; \"\n                      \"updates will be logged to the binary log, but \"\n                      \"connections from slaves will not be accepted.\");\n#endif\n  }\n\n  /* \n   The subsequent calls may take a long time : e.g. innodb log read.\n   Thus set the long running service control manager timeout\n  */\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetSlowStarting(slow_start_timeout);\n#endif\n\n  if (init_server_components())\n    unireg_abort(1);\n\n  init_ssl();\n  network_init();\n\n#ifdef __WIN__\n  if (!opt_console)\n  {\n    if (reopen_fstreams(log_error_file, stdout, stderr))\n      unireg_abort(1);\n    setbuf(stderr, NULL);\n    FreeConsole();\t\t\t\t// Remove window\n  }\n#endif\n\n  /*\n   Initialize my_str_malloc() and my_str_free()\n  */\n  my_str_malloc= &my_str_malloc_mysqld;\n  my_str_free= &my_str_free_mysqld;\n\n  /*\n    init signals & alarm\n    After this we can't quit by a simple unireg_abort\n  */\n  start_signal_handler();\t\t\t\t// Creates pidfile\n\n  if (mysql_rm_tmp_tables() || acl_init(opt_noacl) ||\n      my_tz_init((THD *)0, default_tz_name, opt_bootstrap))\n  {\n    abort_loop=1;\n    select_thread_in_use=0;\n\n    (void) pthread_kill(signal_thread, MYSQL_KILL_SIGNAL);\n\n    delete_pid_file(MYF(MY_WME));\n\n    if (unix_sock != INVALID_SOCKET)\n      unlink(mysqld_unix_port);\n    exit(1);\n  }\n\n  if (!opt_noacl)\n    (void) grant_init();\n\n  if (!opt_bootstrap)\n    servers_init(0);\n\n  udf_init();\n\n  init_status_vars();\n  if (opt_bootstrap) /* If running with bootstrap, do not start replication. */\n    opt_skip_slave_start= 1;\n\n  binlog_unsafe_map_init();\n  /*\n    init_slave() must be called after the thread keys are created.\n    Some parts of the code (e.g. SHOW STATUS LIKE 'slave_running' and other\n    places) assume that active_mi != 0, so let's fail if it's 0 (out of\n    memory); a message has already been printed.\n  */\n  if (init_slave() && !active_mi)\n  {\n    unireg_abort(1);\n  }\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  initialize_performance_schema_acl(opt_bootstrap);\n  /*\n    Do not check the structure of the performance schema tables\n    during bootstrap:\n    - the tables are not supposed to exist yet, bootstrap will create them\n    - a check would print spurious error messages\n  */\n  if (! opt_bootstrap)\n    check_performance_schema();\n#endif\n\n  initialize_information_schema_acl();\n\n  execute_ddl_log_recovery();\n\n  if (Events::init(opt_noacl || opt_bootstrap))\n    unireg_abort(1);\n\n  if (opt_bootstrap)\n  {\n    select_thread_in_use= 0;                    // Allow 'kill' to work\n    bootstrap(mysql_stdin);\n    if (!kill_in_progress)\n      unireg_abort(bootstrap_error ? 1 : 0);\n    else\n    {\n      sleep(2);                                 // Wait for kill\n      exit(0);\n    }\n  }\n  if (opt_init_file && *opt_init_file)\n  {\n    if (read_init_file(opt_init_file))\n      unireg_abort(1);\n  }\n\n  create_shutdown_thread();\n  start_handle_manager();\n\n  sql_print_information(ER_DEFAULT(ER_STARTUP),my_progname,server_version,\n                        ((unix_sock == INVALID_SOCKET) ? (char*) \"\"\n                                                       : mysqld_unix_port),\n                         mysqld_port,\n                         MYSQL_COMPILATION_COMMENT);\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetRunning();\n#endif\n\n\n  /* Signal threads waiting for server to be started */\n  mysql_mutex_lock(&LOCK_server_started);\n  mysqld_server_started= 1;\n  mysql_cond_signal(&COND_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n\n#if defined(_WIN32) || defined(HAVE_SMEM)\n  handle_connections_methods();\n#else\n  handle_connections_sockets();\n#endif /* _WIN32 || HAVE_SMEM */\n\n  /* (void) pthread_attr_destroy(&connection_attrib); */\n\n  DBUG_PRINT(\"quit\",(\"Exiting main thread\"));\n\n#ifndef __WIN__\n#ifdef EXTRA_DEBUG2\n  sql_print_error(\"Before Lock_thread_count\");\n#endif\n  mysql_mutex_lock(&LOCK_thread_count);\n  DBUG_PRINT(\"quit\", (\"Got thread_count mutex\"));\n  select_thread_in_use=0;\t\t\t// For close_connections\n  mysql_mutex_unlock(&LOCK_thread_count);\n  mysql_cond_broadcast(&COND_thread_count);\n#ifdef EXTRA_DEBUG2\n  sql_print_error(\"After lock_thread_count\");\n#endif\n#endif /* __WIN__ */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Disable the main thread instrumentation,\n    to avoid recording events during the shutdown.\n  */\n  if (PSI_server)\n    PSI_server->delete_current_thread();\n#endif\n\n  /* Wait until cleanup is done */\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (!ready_to_exit)\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\n  if (Service.IsNT() && start_mode)\n    Service.Stop();\n  else\n  {\n    Service.SetShutdownEvent(0);\n    if (hEventShutdown)\n      CloseHandle(hEventShutdown);\n  }\n#endif\n  mysqld_exit(0);\n  return 0;\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Main and thread entry function for Win32\n  (all this is needed only to run mysqld as a service on WinNT)\n****************************************************************************/\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nint mysql_service(void *p)\n{\n  if (my_thread_init())\n    return 1;\n  \n  if (use_opt_args)\n    win_main(opt_argc, opt_argv);\n  else\n    win_main(Service.my_argc, Service.my_argv);\n\n  my_thread_end();\n  return 0;\n}\n\n\n/* Quote string if it contains space, else copy */\n\nstatic char *add_quoted_string(char *to, const char *from, char *to_end)\n{\n  uint length= (uint) (to_end-to);\n\n  if (!strchr(from, ' '))\n    return strmake(to, from, length-1);\n  return strxnmov(to, length-1, \"\\\"\", from, \"\\\"\", NullS);\n}\n\n\n/**\n  Handle basic handling of services, like installation and removal.\n\n  @param argv\t   \t        Pointer to argument list\n  @param servicename\t\tInternal name of service\n  @param displayname\t\tDisplay name of service (in taskbar ?)\n  @param file_path\t\tPath to this program\n  @param startup_option\tStartup option to mysqld\n\n  @retval 0\toption handled\n  @retval 1\tCould not handle option\n*/\n\nstatic bool\ndefault_service_handling(char **argv,\n\t\t\t const char *servicename,\n\t\t\t const char *displayname,\n\t\t\t const char *file_path,\n\t\t\t const char *extra_opt,\n\t\t\t const char *account_name)\n{\n  char path_and_service[FN_REFLEN+FN_REFLEN+32], *pos, *end;\n  const char *opt_delim;\n  end= path_and_service + sizeof(path_and_service)-3;\n\n  /* We have to quote filename if it contains spaces */\n  pos= add_quoted_string(path_and_service, file_path, end);\n  if (extra_opt && *extra_opt)\n  {\n    /* \n     Add option after file_path. There will be zero or one extra option.  It's \n     assumed to be --defaults-file=file but isn't checked.  The variable (not\n     the option name) should be quoted if it contains a string.  \n    */\n    *pos++= ' ';\n    if (opt_delim= strchr(extra_opt, '='))\n    {\n      size_t length= ++opt_delim - extra_opt;\n      pos= strnmov(pos, extra_opt, length);\n    }\n    else\n      opt_delim= extra_opt;\n    \n    pos= add_quoted_string(pos, opt_delim, end);\n  }\n  /* We must have servicename last */\n  *pos++= ' ';\n  (void) add_quoted_string(pos, servicename, end);\n\n  if (Service.got_service_option(argv, \"install\"))\n  {\n    Service.Install(1, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"install-manual\"))\n  {\n    Service.Install(0, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"remove\"))\n  {\n    Service.Remove(servicename);\n    return 0;\n  }\n  return 1;\n}\n\n\nint mysqld_main(int argc, char **argv)\n{\n  my_progname= argv[0];\n\n  /*\n    When several instances are running on the same machine, we\n    need to have an  unique  named  hEventShudown  through the\n    application PID e.g.: MySQLShutdown1890; MySQLShutdown2342\n  */\n  int10_to_str((int) GetCurrentProcessId(),strmov(shutdown_event_name,\n                                                  \"MySQLShutdown\"), 10);\n\n  /* Must be initialized early for comparison of service name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  if (my_init())\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n\n  if (Service.GetOS())\t/* true NT family */\n  {\n    char file_path[FN_REFLEN];\n    my_path(file_path, argv[0], \"\");\t\t      /* Find name in path */\n    fn_format(file_path,argv[0],file_path,\"\",\n\t      MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_RESOLVE_SYMLINKS);\n\n    if (argc == 2)\n    {\n      if (!default_service_handling(argv, MYSQL_SERVICENAME, MYSQL_SERVICENAME,\n\t\t\t\t   file_path, \"\", NULL))\n\treturn 0;\n      if (Service.IsService(argv[1]))        /* Start an optional service */\n      {\n\t/*\n\t  Only add the service name to the groups read from the config file\n\t  if it's not \"MySQL\". (The default service name should be 'mysqld'\n\t  but we started a bad tradition by calling it MySQL from the start\n\t  and we are now stuck with it.\n\t*/\n\tif (my_strcasecmp(system_charset_info, argv[1],\"mysql\"))\n\t  load_default_groups[load_default_groups_sz-2]= argv[1];\n        start_mode= 1;\n        Service.Init(argv[1], mysql_service);\n        return 0;\n      }\n    }\n    else if (argc == 3) /* install or remove any optional service */\n    {\n      if (!default_service_handling(argv, argv[2], argv[2], file_path, \"\",\n                                    NULL))\n\treturn 0;\n      if (Service.IsService(argv[2]))\n      {\n\t/*\n\t  mysqld was started as\n\t  mysqld --defaults-file=my_path\\my.ini service-name\n\t*/\n\tuse_opt_args=1;\n\topt_argc= 2;\t\t\t\t// Skip service-name\n\topt_argv=argv;\n\tstart_mode= 1;\n\tif (my_strcasecmp(system_charset_info, argv[2],\"mysql\"))\n\t  load_default_groups[load_default_groups_sz-2]= argv[2];\n\tService.Init(argv[2], mysql_service);\n\treturn 0;\n      }\n    }\n    else if (argc == 4 || argc == 5)\n    {\n      /*\n        This may seem strange, because we handle --local-service while\n        preserving 4.1's behavior of allowing any one other argument that is\n        passed to the service on startup. (The assumption is that this is\n        --defaults-file=file, but that was not enforced in 4.1, so we don't\n        enforce it here.)\n      */\n      const char *extra_opt= NullS;\n      const char *account_name = NullS;\n      int index;\n      for (index = 3; index < argc; index++)\n      {\n        if (!strcmp(argv[index], \"--local-service\"))\n          account_name= \"NT AUTHORITY\\\\LocalService\";\n        else\n          extra_opt= argv[index];\n      }\n\n      if (argc == 4 || account_name)\n        if (!default_service_handling(argv, argv[2], argv[2], file_path,\n                                      extra_opt, account_name))\n          return 0;\n    }\n    else if (argc == 1 && Service.IsService(MYSQL_SERVICENAME))\n    {\n      /* start the default service */\n      start_mode= 1;\n      Service.Init(MYSQL_SERVICENAME, mysql_service);\n      return 0;\n    }\n  }\n  /* Start as standalone server */\n  Service.my_argc=argc;\n  Service.my_argv=argv;\n  mysql_service(NULL);\n  return 0;\n}\n#endif\n\n\n/**\n  Execute all commands from a file. Used by the mysql_install_db script to\n  create MySQL privilege tables without having to start a full MySQL server.\n*/\n\nstatic void bootstrap(MYSQL_FILE *file)\n{\n  DBUG_ENTER(\"bootstrap\");\n\n  THD *thd= new THD;\n  thd->bootstrap=1;\n  my_net_init(&thd->net,(st_vio*) 0);\n  thd->max_client_packet_length= thd->net.max_packet;\n  thd->security_ctx->master_access= ~(ulong)0;\n  thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;\n  thread_count++;\n  in_bootstrap= TRUE;\n\n  bootstrap_file=file;\n#ifndef EMBEDDED_LIBRARY\t\t\t// TODO:  Enable this\n  int error;\n  if ((error= mysql_thread_create(key_thread_bootstrap,\n                                  &thd->real_id, &connection_attrib,\n                                  handle_bootstrap,\n                                  (void*) thd)))\n  {\n    sql_print_warning(\"Can't create thread to handle bootstrap (errno= %d)\",\n                      error);\n    bootstrap_error=-1;\n    DBUG_VOID_RETURN;\n  }\n  /* Wait for thread to die */\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (in_bootstrap)\n  {\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n    DBUG_PRINT(\"quit\",(\"One thread died (count=%u)\",thread_count));\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n#else\n  thd->mysql= 0;\n  do_handle_bootstrap(thd);\n#endif\n\n  DBUG_VOID_RETURN;\n}\n\n\nstatic bool read_init_file(char *file_name)\n{\n  MYSQL_FILE *file;\n  DBUG_ENTER(\"read_init_file\");\n  DBUG_PRINT(\"enter\",(\"name: %s\",file_name));\n  if (!(file= mysql_file_fopen(key_file_init, file_name,\n                               O_RDONLY, MYF(MY_WME))))\n    DBUG_RETURN(TRUE);\n  bootstrap(file);\n  mysql_file_fclose(file, MYF(MY_WME));\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Increment number of created threads\n*/\nvoid inc_thread_created(void)\n{\n  thread_created++;\n}\n\n#ifndef EMBEDDED_LIBRARY\n\n/*\n   Simple scheduler that use the main thread to handle the request\n\n   NOTES\n     This is only used for debugging, when starting mysqld with\n     --thread-handling=no-threads or --one-thread\n\n     When we enter this function, LOCK_thread_count is hold!\n*/\n\nvoid handle_connection_in_main_thread(THD *thd)\n{\n  mysql_mutex_assert_owner(&LOCK_thread_count);\n  thread_cache_size=0;\t\t\t// Safety\n  threads.append(thd);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  thd->start_utime= microsecond_interval_timer();\n  do_handle_one_connection(thd);\n}\n\n\n/*\n  Scheduler that uses one thread per connection\n*/\n\nvoid create_thread_to_handle_connection(THD *thd)\n{\n  if (cached_thread_count > wake_thread)\n  {\n    /* Get thread from cache */\n    thread_cache.push_back(thd);\n    wake_thread++;\n    mysql_cond_signal(&COND_thread_cache);\n  }\n  else\n  {\n    char error_message_buff[MYSQL_ERRMSG_SIZE];\n    /* Create new thread to handle connection */\n    int error;\n    thread_created++;\n    threads.append(thd);\n    DBUG_PRINT(\"info\",((\"creating thread %lu\"), thd->thread_id));\n    thd->prior_thr_create_utime= microsecond_interval_timer();\n    if ((error= mysql_thread_create(key_thread_one_connection,\n                                    &thd->real_id, &connection_attrib,\n                                    handle_one_connection,\n                                    (void*) thd)))\n    {\n      /* purecov: begin inspected */\n      DBUG_PRINT(\"error\",\n                 (\"Can't create thread to handle request (error %d)\",\n                  error));\n\n      thread_count--;\n      thd->killed= KILL_CONNECTION;             // Safety\n      mysql_mutex_unlock(&LOCK_thread_count);\n\n      mysql_mutex_lock(&LOCK_connection_count);\n      (*thd->scheduler->connection_count)--;\n      mysql_mutex_unlock(&LOCK_connection_count);\n\n      statistic_increment(aborted_connects,&LOCK_status);\n      /* Can't use my_error() since store_globals has not been called. */\n      my_snprintf(error_message_buff, sizeof(error_message_buff),\n                  ER_THD(thd, ER_CANT_CREATE_THREAD), error);\n      net_send_error(thd, ER_CANT_CREATE_THREAD, error_message_buff, NULL);\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      mysql_mutex_lock(&LOCK_thread_count);\n      delete thd;\n      mysql_mutex_unlock(&LOCK_thread_count);\n      return;\n      /* purecov: end */\n    }\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n  DBUG_PRINT(\"info\",(\"Thread created\"));\n}\n\n\n/**\n  Create new thread to handle incoming connection.\n\n    This function will create new thread to handle the incoming\n    connection.  If there are idle cached threads one will be used.\n    'thd' will be pushed into 'threads'.\n\n    In single-threaded mode (\\#define ONE_THREAD) connection will be\n    handled inside this function.\n\n  @param[in,out] thd    Thread handle of future thread.\n*/\n\nstatic void create_new_thread(THD *thd)\n{\n  DBUG_ENTER(\"create_new_thread\");\n\n  /*\n    Don't allow too many connections. We roughly check here that we allow\n    only (max_connections + 1) connections.\n  */\n\n  mysql_mutex_lock(&LOCK_connection_count);\n\n  if (*thd->scheduler->connection_count >=\n      *thd->scheduler->max_connections + 1|| abort_loop)\n  {\n    mysql_mutex_unlock(&LOCK_connection_count);\n\n    DBUG_PRINT(\"error\",(\"Too many connections\"));\n    close_connection(thd, ER_CON_COUNT_ERROR);\n    statistic_increment(denied_connections, &LOCK_status);\n    delete thd;\n    DBUG_VOID_RETURN;\n  }\n\n  ++*thd->scheduler->connection_count;\n\n  if (connection_count + extra_connection_count > max_used_connections)\n    max_used_connections= connection_count + extra_connection_count;\n\n  mysql_mutex_unlock(&LOCK_connection_count);\n\n  /* Start a new thread to handle connection. */\n\n  mysql_mutex_lock(&LOCK_thread_count);\n\n  /*\n    The initialization of thread_id is done in create_embedded_thd() for\n    the embedded library.\n    TODO: refactor this to avoid code duplication there\n  */\n  thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;\n\n  thread_count++;\n\n  MYSQL_CALLBACK(thd->scheduler, add_connection, (thd));\n\n  DBUG_VOID_RETURN;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n#ifdef SIGNALS_DONT_BREAK_READ\ninline void kill_broken_server()\n{\n  /* hack to get around signals ignored in syscalls for problem OS's */\n  if (unix_sock == INVALID_SOCKET ||\n      (!opt_disable_networking && base_ip_sock == INVALID_SOCKET))\n  {\n    select_thread_in_use = 0;\n    /* The following call will never return */\n    DBUG_PRINT(\"general\", (\"killing server because socket is closed\"));\n    kill_server((void*) MYSQL_KILL_SIGNAL);\n  }\n}\n#define MAYBE_BROKEN_SYSCALL kill_broken_server();\n#else\n#define MAYBE_BROKEN_SYSCALL\n#endif\n\n\t/* Handle new connections and spawn new process to handle them */\n\n#ifndef EMBEDDED_LIBRARY\n\nvoid handle_connections_sockets()\n{\n  my_socket UNINIT_VAR(sock), UNINIT_VAR(new_sock);\n  uint error_count=0;\n  THD *thd;\n  struct sockaddr_storage cAddr;\n  int ip_flags __attribute__((unused))=0;\n  int socket_flags __attribute__((unused))= 0;\n  int extra_ip_flags __attribute__((unused))=0;\n  int flags=0,retval;\n  st_vio *vio_tmp;\n#ifdef HAVE_POLL\n  int socket_count= 0;\n  struct pollfd fds[3]; // for ip_sock, unix_sock and extra_ip_sock\n#define setup_fds(X)                    \\\n    fds[socket_count].fd= X;            \\\n    fds[socket_count].events= POLLIN;   \\\n    socket_count++\n#else\n  fd_set readFDs,clientFDs;\n  uint max_used_connection= (uint)\n    max(max(base_ip_sock, unix_sock), extra_ip_sock) + 1;\n#define setup_fds(X)    FD_SET(X,&clientFDs)\n  FD_ZERO(&clientFDs);\n#endif\n\n  DBUG_ENTER(\"handle_connections_sockets\");\n\n  if (base_ip_sock != INVALID_SOCKET)\n  {\n    setup_fds(base_ip_sock);\n    ip_flags = fcntl(base_ip_sock, F_GETFL, 0);\n  }\n  if (extra_ip_sock != INVALID_SOCKET)\n  {\n    setup_fds(extra_ip_sock);\n    extra_ip_flags = fcntl(extra_ip_sock, F_GETFL, 0);\n  }\n#ifdef HAVE_SYS_UN_H\n  setup_fds(unix_sock);\n  socket_flags=fcntl(unix_sock, F_GETFL, 0);\n#endif\n\n  DBUG_PRINT(\"general\",(\"Waiting for connections.\"));\n  MAYBE_BROKEN_SYSCALL;\n  while (!abort_loop)\n  {\n#ifdef HAVE_POLL\n    retval= poll(fds, socket_count, -1);\n#else\n    readFDs=clientFDs;\n\n    retval= select((int) max_used_connection,&readFDs,0,0,0);\n#endif\n\n    if (retval < 0)\n    {\n      if (socket_errno != SOCKET_EINTR)\n      {\n\tif (!select_errors++ && !abort_loop)\t/* purecov: inspected */\n\t  sql_print_error(\"mysqld: Got error %d from select\",socket_errno); /* purecov: inspected */\n      }\n      MAYBE_BROKEN_SYSCALL\n      continue;\n    }\n\n    if (abort_loop)\n    {\n      MAYBE_BROKEN_SYSCALL;\n      break;\n    }\n\n    /* Is this a new connection request ? */\n#ifdef HAVE_POLL\n    for (int i= 0; i < socket_count; ++i) \n    {\n      if (fds[i].revents & POLLIN)\n      {\n        sock= fds[i].fd;\n        flags= fcntl(sock, F_GETFL, 0);\n        break;\n      }\n    }\n#else  // HAVE_POLL\n    if (FD_ISSET(base_ip_sock,&readFDs))\n    {\n      sock=  base_ip_sock;\n      flags= ip_flags;\n    }\n    else\n    if (FD_ISSET(extra_ip_sock,&readFDs))\n    {\n      sock=  extra_ip_sock;\n      flags= extra_ip_flags;\n    }\n    else\n    {\n      sock = unix_sock;\n      flags= socket_flags;\n    }\n#endif // HAVE_POLL\n\n#if !defined(NO_FCNTL_NONBLOCK)\n    if (!(test_flags & TEST_BLOCKING))\n    {\n#if defined(O_NONBLOCK)\n      fcntl(sock, F_SETFL, flags | O_NONBLOCK);\n#elif defined(O_NDELAY)\n      fcntl(sock, F_SETFL, flags | O_NDELAY);\n#endif\n    }\n#endif /* NO_FCNTL_NONBLOCK */\n    for (uint retry=0; retry < MAX_ACCEPT_RETRY; retry++)\n    {\n      size_socket length= sizeof(struct sockaddr_storage);\n      new_sock= accept(sock, (struct sockaddr *)(&cAddr),\n                       &length);\n      if (new_sock != INVALID_SOCKET ||\n\t  (socket_errno != SOCKET_EINTR && socket_errno != SOCKET_EAGAIN))\n\tbreak;\n      MAYBE_BROKEN_SYSCALL;\n#if !defined(NO_FCNTL_NONBLOCK)\n      if (!(test_flags & TEST_BLOCKING))\n      {\n\tif (retry == MAX_ACCEPT_RETRY - 1)\n\t  fcntl(sock, F_SETFL, flags);\t\t// Try without O_NONBLOCK\n      }\n#endif\n    }\n#if !defined(NO_FCNTL_NONBLOCK)\n    if (!(test_flags & TEST_BLOCKING))\n      fcntl(sock, F_SETFL, flags);\n#endif\n    if (new_sock == INVALID_SOCKET)\n    {\n      if ((error_count++ & 255) == 0)\t\t// This can happen often\n\tsql_perror(\"Error in accept\");\n      MAYBE_BROKEN_SYSCALL;\n      if (socket_errno == SOCKET_ENFILE || socket_errno == SOCKET_EMFILE)\n\tsleep(1);\t\t\t\t// Give other threads some time\n      continue;\n    }\n\n#ifdef HAVE_LIBWRAP\n    {\n      if (sock == base_ip_sock || sock == extra_ip_sock)\n      {\n\tstruct request_info req;\n\tsignal(SIGCHLD, SIG_DFL);\n\trequest_init(&req, RQ_DAEMON, libwrapName, RQ_FILE, new_sock, NULL);\n\tmy_fromhost(&req);\n\tif (!my_hosts_access(&req))\n\t{\n\t  /*\n\t    This may be stupid but refuse() includes an exit(0)\n\t    which we surely don't want...\n\t    clean_exit() - same stupid thing ...\n\t  */\n\t  syslog(deny_severity, \"refused connect from %s\",\n\t\t my_eval_client(&req));\n\n\t  /*\n\t    C++ sucks (the gibberish in front just translates the supplied\n\t    sink function pointer in the req structure from a void (*sink)();\n\t    to a void(*sink)(int) if you omit the cast, the C++ compiler\n\t    will cry...\n\t  */\n\t  if (req.sink)\n\t    ((void (*)(int))req.sink)(req.fd);\n\n\t  (void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t  (void) closesocket(new_sock);\n\t  continue;\n\t}\n      }\n    }\n#endif /* HAVE_LIBWRAP */\n\n    {\n      size_socket dummyLen;\n      struct sockaddr_storage dummy;\n      dummyLen = sizeof(dummy);\n      if (  getsockname(new_sock,(struct sockaddr *)&dummy, \n                  (SOCKET_SIZE_TYPE *)&dummyLen) < 0  )\n      {\n\tsql_perror(\"Error on new connection socket\");\n\t(void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t(void) closesocket(new_sock);\n\tcontinue;\n      }\n    }\n\n    /*\n    ** Don't allow too many connections\n    */\n\n    if (!(thd= new THD))\n    {\n      (void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n      (void) closesocket(new_sock);\n      continue;\n    }\n    if (!(vio_tmp=vio_new(new_sock,\n\t\t\t  sock == unix_sock ? VIO_TYPE_SOCKET :\n\t\t\t  VIO_TYPE_TCPIP,\n\t\t\t  sock == unix_sock ? VIO_LOCALHOST: 0)) ||\n\tmy_net_init(&thd->net,vio_tmp))\n    {\n      /*\n        Only delete the temporary vio if we didn't already attach it to the\n        NET object. The destructor in THD will delete any initialized net\n        structure.\n      */\n      if (vio_tmp && thd->net.vio != vio_tmp)\n        vio_delete(vio_tmp);\n      else\n      {\n\t(void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t(void) closesocket(new_sock);\n      }\n      delete thd;\n      continue;\n    }\n    if (sock == unix_sock)\n      thd->security_ctx->host=(char*) my_localhost;\n\n    if (sock == extra_ip_sock)\n    {\n      thd->extra_port= 1;\n      thd->scheduler= extra_thread_scheduler;\n    }\n    create_new_thread(thd);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\n#ifdef _WIN32\npthread_handler_t handle_connections_sockets_thread(void *arg)\n{\n  my_thread_init();\n  handle_connections_sockets();\n  decrement_handler_count();\n  return 0;\n}\n\npthread_handler_t handle_connections_namedpipes(void *arg)\n{\n  HANDLE hConnectedPipe;\n  OVERLAPPED connectOverlapped= {0};\n  THD *thd;\n  my_thread_init();\n  DBUG_ENTER(\"handle_connections_namedpipes\");\n  connectOverlapped.hEvent= CreateEvent(NULL, TRUE, FALSE, NULL);\n  if (!connectOverlapped.hEvent)\n  {\n    sql_print_error(\"Can't create event, last error=%u\", GetLastError());\n    unireg_abort(1);\n  }\n  DBUG_PRINT(\"general\",(\"Waiting for named pipe connections.\"));\n  while (!abort_loop)\n  {\n    /* wait for named pipe connection */\n    BOOL fConnected= ConnectNamedPipe(hPipe, &connectOverlapped);\n    if (!fConnected && (GetLastError() == ERROR_IO_PENDING))\n    {\n        /*\n          ERROR_IO_PENDING says async IO has started but not yet finished.\n          GetOverlappedResult will wait for completion.\n        */\n        DWORD bytes;\n        fConnected= GetOverlappedResult(hPipe, &connectOverlapped,&bytes, TRUE);\n    }\n    if (abort_loop)\n      break;\n    if (!fConnected)\n      fConnected = GetLastError() == ERROR_PIPE_CONNECTED;\n    if (!fConnected)\n    {\n      CloseHandle(hPipe);\n      if ((hPipe= CreateNamedPipe(pipe_name,\n                                  PIPE_ACCESS_DUPLEX |\n                                  FILE_FLAG_OVERLAPPED,\n                                  PIPE_TYPE_BYTE |\n                                  PIPE_READMODE_BYTE |\n                                  PIPE_WAIT,\n                                  PIPE_UNLIMITED_INSTANCES,\n                                  (int) global_system_variables.\n                                  net_buffer_length,\n                                  (int) global_system_variables.\n                                  net_buffer_length,\n                                  NMPWAIT_USE_DEFAULT_WAIT,\n                                  &saPipeSecurity)) ==\n\t  INVALID_HANDLE_VALUE)\n      {\n\tsql_perror(\"Can't create new named pipe!\");\n\tbreak;\t\t\t\t\t// Abort\n      }\n    }\n    hConnectedPipe = hPipe;\n    /* create new pipe for new connection */\n    if ((hPipe = CreateNamedPipe(pipe_name,\n                 PIPE_ACCESS_DUPLEX |\n                 FILE_FLAG_OVERLAPPED,\n\t\t\t\t PIPE_TYPE_BYTE |\n\t\t\t\t PIPE_READMODE_BYTE |\n\t\t\t\t PIPE_WAIT,\n\t\t\t\t PIPE_UNLIMITED_INSTANCES,\n\t\t\t\t (int) global_system_variables.net_buffer_length,\n\t\t\t\t (int) global_system_variables.net_buffer_length,\n\t\t\t\t NMPWAIT_USE_DEFAULT_WAIT,\n\t\t\t\t &saPipeSecurity)) ==\n\tINVALID_HANDLE_VALUE)\n    {\n      sql_perror(\"Can't create new named pipe!\");\n      hPipe=hConnectedPipe;\n      continue;\t\t\t\t\t// We have to try again\n    }\n\n    if (!(thd = new THD))\n    {\n      DisconnectNamedPipe(hConnectedPipe);\n      CloseHandle(hConnectedPipe);\n      continue;\n    }\n    if (!(thd->net.vio= vio_new_win32pipe(hConnectedPipe)) ||\n\tmy_net_init(&thd->net, thd->net.vio))\n    {\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      delete thd;\n      continue;\n    }\n    /* Host is unknown */\n    thd->security_ctx->host= my_strdup(my_localhost, MYF(0));\n    create_new_thread(thd);\n  }\n  CloseHandle(connectOverlapped.hEvent);\n  DBUG_LEAVE;\n  decrement_handler_count();\n  return 0;\n}\n#endif /* _WIN32 */\n\n\n#ifdef HAVE_SMEM\n\n/**\n  Thread of shared memory's service.\n\n  @param arg                              Arguments of thread\n*/\npthread_handler_t handle_connections_shared_memory(void *arg)\n{\n  /* file-mapping object, use for create shared memory */\n  HANDLE handle_connect_file_map= 0;\n  char  *handle_connect_map= 0;                 // pointer on shared memory\n  HANDLE event_connect_answer= 0;\n  ulong smem_buffer_length= shared_memory_buffer_length + 4;\n  ulong connect_number= 1;\n  char *tmp= NULL;\n  char *suffix_pos;\n  char connect_number_char[22], *p;\n  const char *errmsg= 0;\n  SECURITY_ATTRIBUTES *sa_event= 0, *sa_mapping= 0;\n  my_thread_init();\n  DBUG_ENTER(\"handle_connections_shared_memorys\");\n  DBUG_PRINT(\"general\",(\"Waiting for allocated shared memory.\"));\n\n  /*\n     get enough space base-name + '_' + longest suffix we might ever send\n   */\n  if (!(tmp= (char *)my_malloc(strlen(shared_memory_base_name) + 32L, MYF(MY_FAE))))\n    goto error;\n\n  if (my_security_attr_create(&sa_event, &errmsg,\n                              GENERIC_ALL, SYNCHRONIZE | EVENT_MODIFY_STATE))\n    goto error;\n\n  if (my_security_attr_create(&sa_mapping, &errmsg,\n                             GENERIC_ALL, FILE_MAP_READ | FILE_MAP_WRITE))\n    goto error;\n\n  /*\n    The name of event and file-mapping events create agree next rule:\n      shared_memory_base_name+unique_part\n    Where:\n      shared_memory_base_name is unique value for each server\n      unique_part is unique value for each object (events and file-mapping)\n  */\n  suffix_pos= strxmov(tmp,shared_memory_base_name,\"_\",NullS);\n  strmov(suffix_pos, \"CONNECT_REQUEST\");\n  if ((smem_event_connect_request= CreateEvent(sa_event,\n                                               FALSE, FALSE, tmp)) == 0)\n  {\n    errmsg= \"Could not create request event\";\n    goto error;\n  }\n  strmov(suffix_pos, \"CONNECT_ANSWER\");\n  if ((event_connect_answer= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n  {\n    errmsg=\"Could not create answer event\";\n    goto error;\n  }\n  strmov(suffix_pos, \"CONNECT_DATA\");\n  if ((handle_connect_file_map=\n       CreateFileMapping(INVALID_HANDLE_VALUE, sa_mapping,\n                         PAGE_READWRITE, 0, sizeof(connect_number), tmp)) == 0)\n  {\n    errmsg= \"Could not create file mapping\";\n    goto error;\n  }\n  if ((handle_connect_map= (char *)MapViewOfFile(handle_connect_file_map,\n\t\t\t\t\t\t  FILE_MAP_WRITE,0,0,\n\t\t\t\t\t\t  sizeof(DWORD))) == 0)\n  {\n    errmsg= \"Could not create shared memory service\";\n    goto error;\n  }\n\n  while (!abort_loop)\n  {\n    /* Wait a request from client */\n    WaitForSingleObject(smem_event_connect_request,INFINITE);\n\n    /*\n       it can be after shutdown command\n    */\n    if (abort_loop)\n      goto error;\n\n    HANDLE handle_client_file_map= 0;\n    char  *handle_client_map= 0;\n    HANDLE event_client_wrote= 0;\n    HANDLE event_client_read= 0;    // for transfer data server <-> client\n    HANDLE event_server_wrote= 0;\n    HANDLE event_server_read= 0;\n    HANDLE event_conn_closed= 0;\n    THD *thd= 0;\n\n    p= int10_to_str(connect_number, connect_number_char, 10);\n    /*\n      The name of event and file-mapping events create agree next rule:\n        shared_memory_base_name+unique_part+number_of_connection\n        Where:\n\t  shared_memory_base_name is uniquel value for each server\n\t  unique_part is unique value for each object (events and file-mapping)\n\t  number_of_connection is connection-number between server and client\n    */\n    suffix_pos= strxmov(tmp,shared_memory_base_name,\"_\",connect_number_char,\n\t\t\t \"_\",NullS);\n    strmov(suffix_pos, \"DATA\");\n    if ((handle_client_file_map=\n         CreateFileMapping(INVALID_HANDLE_VALUE, sa_mapping,\n                           PAGE_READWRITE, 0, smem_buffer_length, tmp)) == 0)\n    {\n      errmsg= \"Could not create file mapping\";\n      goto errorconn;\n    }\n    if ((handle_client_map= (char*)MapViewOfFile(handle_client_file_map,\n\t\t\t\t\t\t  FILE_MAP_WRITE,0,0,\n\t\t\t\t\t\t  smem_buffer_length)) == 0)\n    {\n      errmsg= \"Could not create memory map\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CLIENT_WROTE\");\n    if ((event_client_wrote= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create client write event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CLIENT_READ\");\n    if ((event_client_read= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create client read event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"SERVER_READ\");\n    if ((event_server_read= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create server read event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"SERVER_WROTE\");\n    if ((event_server_wrote= CreateEvent(sa_event,\n                                         FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create server write event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CONNECTION_CLOSED\");\n    if ((event_conn_closed= CreateEvent(sa_event,\n                                        TRUE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create closed connection event\";\n      goto errorconn;\n    }\n    if (abort_loop)\n      goto errorconn;\n    if (!(thd= new THD))\n      goto errorconn;\n    /* Send number of connection to client */\n    int4store(handle_connect_map, connect_number);\n    if (!SetEvent(event_connect_answer))\n    {\n      errmsg= \"Could not send answer event\";\n      goto errorconn;\n    }\n    /* Set event that client should receive data */\n    if (!SetEvent(event_client_read))\n    {\n      errmsg= \"Could not set client to read mode\";\n      goto errorconn;\n    }\n    if (!(thd->net.vio= vio_new_win32shared_memory(handle_client_file_map,\n                                                   handle_client_map,\n                                                   event_client_wrote,\n                                                   event_client_read,\n                                                   event_server_wrote,\n                                                   event_server_read,\n                                                   event_conn_closed)) ||\n                        my_net_init(&thd->net, thd->net.vio))\n    {\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      errmsg= 0;\n      goto errorconn;\n    }\n    thd->security_ctx->host= my_strdup(my_localhost, MYF(0)); /* Host is unknown */\n    create_new_thread(thd);\n    connect_number++;\n    continue;\n\nerrorconn:\n    /* Could not form connection;  Free used handlers/memort and retry */\n    if (errmsg)\n    {\n      char buff[180];\n      strxmov(buff, \"Can't create shared memory connection: \", errmsg, \".\",\n\t      NullS);\n      sql_perror(buff);\n    }\n    if (handle_client_file_map)\n      CloseHandle(handle_client_file_map);\n    if (handle_client_map)\n      UnmapViewOfFile(handle_client_map);\n    if (event_server_wrote)\n      CloseHandle(event_server_wrote);\n    if (event_server_read)\n      CloseHandle(event_server_read);\n    if (event_client_wrote)\n      CloseHandle(event_client_wrote);\n    if (event_client_read)\n      CloseHandle(event_client_read);\n    if (event_conn_closed)\n      CloseHandle(event_conn_closed);\n    delete thd;\n  }\n\n  /* End shared memory handling */\nerror:\n  if (tmp)\n    my_free(tmp);\n\n  if (errmsg)\n  {\n    char buff[180];\n    strxmov(buff, \"Can't create shared memory service: \", errmsg, \".\", NullS);\n    sql_perror(buff);\n  }\n  my_security_attr_free(sa_event);\n  my_security_attr_free(sa_mapping);\n  if (handle_connect_map)\tUnmapViewOfFile(handle_connect_map);\n  if (handle_connect_file_map)\tCloseHandle(handle_connect_file_map);\n  if (event_connect_answer)\tCloseHandle(event_connect_answer);\n  if (smem_event_connect_request) CloseHandle(smem_event_connect_request);\n  DBUG_LEAVE;\n  decrement_handler_count();\n  return 0;\n}\n#endif /* HAVE_SMEM */\n#endif /* EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Handle start options\n******************************************************************************/\n\n/**\n  System variables are automatically command-line options (few\n  exceptions are documented in sys_var.h), so don't need\n  to be listed here.\n*/\n\nstruct my_option my_long_options[]=\n{\n  {\"help\", '?', \"Display this help and exit.\", \n   &opt_help, &opt_help, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0,\n   0, 0},\n  {\"allow-suspicious-udfs\", 0,\n   \"Allows use of UDFs consisting of only one symbol xxx() \"\n   \"without corresponding xxx_init() or xxx_deinit(). That also means \"\n   \"that one can load any function from any library, for example exit() \"\n   \"from libc.so\",\n   &opt_allow_suspicious_udfs, &opt_allow_suspicious_udfs,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"ansi\", 'a', \"Use ANSI SQL syntax instead of MySQL syntax. This mode \"\n   \"will also set transaction isolation level 'serializable'.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /*\n    Because Sys_var_bit does not support command-line options, we need to\n    explicitely add one for --autocommit\n  */\n  {\"autocommit\", 0, \"Set default value for autocommit (0 or 1)\",\n   &opt_autocommit, &opt_autocommit, 0,\n   GET_BOOL, OPT_ARG, 1, 0, 0, 0, 0, NULL},\n  {\"bind-address\", OPT_BIND_ADDRESS, \"IP address to bind to.\",\n   &my_bind_addr_str, &my_bind_addr_str, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-do-db\", OPT_BINLOG_DO_DB,\n   \"Tells the master it should log updates for the specified database, \"\n   \"and exclude all others not explicitly mentioned.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-ignore-db\", OPT_BINLOG_IGNORE_DB,\n   \"Tells the master that updates to the given database should not be logged to the binary log.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-row-event-max-size\", 0,\n   \"The maximum size of a row-based binary log event in bytes. Rows will be \"\n   \"grouped into events smaller than this size if possible. \"\n   \"The value has to be a multiple of 256.\",\n   &opt_binlog_rows_event_max_size, &opt_binlog_rows_event_max_size,\n   0, GET_ULONG, REQUIRED_ARG,\n   /* def_value */ 1024, /* min_value */  256, /* max_value */ ULONG_MAX, \n   /* sub_size */     0, /* block_size */ 256, \n   /* app_type */ 0\n  },\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"bootstrap\", OPT_BOOTSTRAP, \"Used by mysql installation scripts.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"character-set-client-handshake\", 0,\n   \"Don't ignore client side character set value sent during handshake.\",\n   &opt_character_set_client_handshake,\n   &opt_character_set_client_handshake,\n    0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n  {\"character-set-filesystem\", 0,\n   \"Set the filesystem character set.\",\n   &character_set_filesystem_name,\n   &character_set_filesystem_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"character-set-server\", 'C', \"Set the default character set.\",\n   &default_character_set_name, &default_character_set_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"chroot\", 'r', \"Chroot mysqld daemon during startup.\",\n   &mysqld_chroot, &mysqld_chroot, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"collation-server\", 0, \"Set the default collation.\",\n   &default_collation_name, &default_collation_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"console\", OPT_CONSOLE, \"Write error output on screen; don't remove the console window on windows.\",\n   &opt_console, &opt_console, 0, GET_BOOL, NO_ARG, 0, 0, 0,\n   0, 0, 0},\n  {\"core-file\", OPT_WANT_CORE, \"Write core on errors.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* default-storage-engine should have \"MyISAM\" as def_value. Instead\n     of initializing it here it is done in init_common_variables() due\n     to a compiler bug in Sun Studio compiler. */\n#ifdef DBUG_OFF\n  {\"debug\", '#', \"Built in DBUG debugger. Disabled in this build.\",\n   &current_dbug_option, &current_dbug_option, 0, GET_STR, OPT_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"debug-abort-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &abort_slave_event_count,  &abort_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n#ifndef DBUG_OFF\n  {\"debug-assert-on-error\", 0,\n   \"Do an assert in various functions if we get a fatal error\",\n   &my_assert_on_error, &my_assert_on_error,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"debug-assert-if-crashed-table\", 0,\n   \"Do an assert in handler::print_error() if we get a crashed table\",\n   &debug_assert_if_crashed_table, &debug_assert_if_crashed_table,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"debug-disconnect-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &disconnect_slave_event_count, &disconnect_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"debug-exit-info\", 'T', \"Used for debugging. Use at your own risk.\",\n   0, 0, 0, GET_LONG, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"debug-gdb\", 0,\n   \"Set up signals usable for debugging.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"debug-max-binlog-dump-events\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &max_binlog_dump_events, &max_binlog_dump_events, 0,\n   GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n#ifdef SAFE_MUTEX\n  {\"debug-mutex-deadlock-detector\", 0,\n   \"Enable checking of wrong mutex usage.\",\n   &safe_mutex_deadlock_detector,\n   &safe_mutex_deadlock_detector,\n   0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n#endif\n  {\"debug-no-sync\", 0,\n   \"Disables system sync calls. Only for running tests or debugging!\",\n   &my_disable_sync, &my_disable_sync, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"debug-sporadic-binlog-dump-fail\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &opt_sporadic_binlog_dump_fail,\n   &opt_sporadic_binlog_dump_fail, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif /* HAVE_REPLICATION */\n  {\"default-storage-engine\", 0, \"The default storage engine for new tables\",\n   &default_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"default-time-zone\", 0, \"Set the default time zone.\",\n   &default_tz_name, &default_tz_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n#if defined(ENABLED_DEBUG_SYNC)\n  {\"debug-sync-timeout\", OPT_DEBUG_SYNC_TIMEOUT,\n   \"Enable the debug sync facility \"\n   \"and optionally specify a default wait timeout in seconds. \"\n   \"A zero value keeps the facility disabled.\",\n   &opt_debug_sync_timeout, 0,\n   0, GET_UINT, OPT_ARG, 0, 0, UINT_MAX, 0, 0, 0},\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n#ifdef HAVE_OPENSSL\n  {\"des-key-file\", 0,\n   \"Load keys for des_encrypt() and des_encrypt from given file.\",\n   &des_key_file, &des_key_file, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_STACKTRACE\n  {\"stack-trace\", 0 , \"Print a symbolic stack trace on failure\",\n   &opt_stack_trace, &opt_stack_trace, 0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n#endif /* HAVE_STACKTRACE */\n  {\"external-locking\", 0, \"Use system (external) locking (disabled by \"\n   \"default).  With this option enabled you can run myisamchk to test \"\n   \"(not repair) tables while the MySQL server is running. Disable with \"\n   \"--skip-external-locking.\", &opt_external_locking, &opt_external_locking,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* We must always support the next option to make scripts like mysqltest\n     easier to do */\n  {\"gdb\", 0,\n   \"Set up signals usable for debugging. Deprecated, use --debug-gdb instead.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_LARGE_PAGE_OPTION\n  {\"super-large-pages\", 0, \"Enable support for super large pages.\",\n   &opt_super_large_pages, &opt_super_large_pages, 0,\n   GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},\n#endif\n  {\"language\", 'L',\n   \"Client error messages in given language. May be given as a full path. \"\n   \"Deprecated. Use --lc-messages-dir instead.\",\n   0, 0, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"lc-messages\", 0,\n   \"Set the language used for the error messages.\",\n   &lc_messages, &lc_messages, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"lc-time-names\", 0,\n   \"Set the language used for the month names and the days of the week.\",\n   &lc_time_names_name, &lc_time_names_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"log\", 'l', \"Log connections and queries to file (deprecated option, use \"\n   \"--general-log/--general-log-file instead).\", &opt_logname, &opt_logname,\n   0, GET_STR_ALLOC, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-basename\", OPT_LOG_BASENAME,\n   \"Basename for all log files and the .pid file. This sets all log file \"\n   \"names at once (in 'datadir') and is normally the only option you need \"\n   \"for specifying log files. Sets names for --log-bin, --log-bin-index, \"\n   \"--relay-log, --relay-log-index, --general-log-file, \"\n   \"--log-slow-query-log-file, --log-error-file, and --pid-file\",\n   &opt_log_basename, &opt_log_basename, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"log-bin\", OPT_BIN_LOG,\n   \"Log update queries in binary format. Optional argument should be name for \"\n   \"binary log. If not given \"\n   \"'datadir'/'log-basename'-bin or 'datadir'/mysql-bin will be used (the later if \"\n   \"--log-basename is not specified). We strongly recommend to use either \"\n   \"--log-basename or specify a filename to ensure that replication doesn't \"\n   \"stop if the real hostname of the computer changes.\",\n   &opt_bin_logname, &opt_bin_logname, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-bin-index\", 0,\n   \"File that holds the names for last binary log files.\",\n   &opt_binlog_index_name, &opt_binlog_index_name, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-isam\", OPT_ISAM_LOG, \"Log all MyISAM changes to file.\",\n   &myisam_log_filename, &myisam_log_filename, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-short-format\", 0,\n   \"Don't log extra information to update and slow-query logs.\",\n   &opt_short_log_format, &opt_short_log_format,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-slow-admin-statements\", 0,\n   \"Log slow OPTIMIZE, ANALYZE, ALTER and other administrative statements to \"\n   \"the slow log if it is open.\", &opt_log_slow_admin_statements,\n   &opt_log_slow_admin_statements, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n {\"log-slow-slave-statements\", 0,\n  \"Log slow statements executed by slave thread to the slow log if it is open.\",\n  &opt_log_slow_slave_statements, &opt_log_slow_slave_statements,\n  0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-slow-queries\", OPT_SLOW_QUERY_LOG,\n   \"Enable logging of slow queries (longer than --long-query-time) to log file \"\n   \"or table. Optional argument is a file name for the slow log. If not given, \"\n   \"'log-basename'-slow.log will be used. Use --log-output=TABLE if you want \"\n   \"to have the log in the table mysql.slow_log. \"\n   \"Deprecated option, use --slow-query-log/--slow-query-log-file instead.\",\n   &opt_slow_logname, &opt_slow_logname, 0, GET_STR_ALLOC, OPT_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"log-tc\", 0,\n   \"Path to transaction coordinator log (used for transactions that affect \"\n   \"more than one storage engine, when binary log is disabled).\",\n   &opt_tc_log_file, &opt_tc_log_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_MMAP\n  {\"log-tc-size\", 0, \"Size of transaction coordinator log.\",\n   &opt_tc_log_size, &opt_tc_log_size, 0, GET_ULONG,\n   REQUIRED_ARG, TC_LOG_MIN_SIZE, TC_LOG_MIN_SIZE, (ulonglong) ULONG_MAX, 0,\n   TC_LOG_PAGE_SIZE, 0},\n#endif\n  {\"master-info-file\", 0,\n   \"The location and name of the file that remembers the master and where \"\n   \"the I/O replication thread is in the master's binlogs. Defaults to \"\n   \"master.info\",\n   &master_info_file, &master_info_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"master-retry-count\", 0,\n   \"The number of tries the slave will make to connect to the master before giving up.\",\n   &master_retry_count, &master_retry_count, 0, GET_ULONG,\n   REQUIRED_ARG, 3600*24, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"init-rpl-role\", 0, \"Set the replication role.\",\n   &rpl_status, &rpl_status, &rpl_role_typelib,\n   GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"memlock\", 0, \"Lock mysqld in memory.\", &locked_in_memory,\n   &locked_in_memory, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"one-thread\", OPT_ONE_THREAD,\n   \"(Deprecated): Only use one thread (for debugging under Linux). Use \"\n   \"thread-handling=no-threads instead.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"old-style-user-limits\", 0,\n   \"Enable old-style user limits (before 5.0.3, user resources were counted \"\n   \"per each user+host vs. per account).\",\n   &opt_old_style_user_limits, &opt_old_style_user_limits,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"port-open-timeout\", 0,\n   \"Maximum time in seconds to wait for the port to become free. \"\n   \"(Default: No wait).\", &mysqld_port_timeout, &mysqld_port_timeout, 0,\n   GET_UINT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-db\", OPT_REPLICATE_DO_DB,\n   \"Tells the slave thread to restrict replication to the specified database. \"\n   \"To specify more than one database, use the directive multiple times, \"\n   \"once for each database. Note that this will only work if you do not use \"\n   \"cross-database queries such as UPDATE some_db.some_table SET foo='bar' \"\n   \"while having selected a different or no database. If you need cross \"\n   \"database updates to work, make sure you have 3.23.28 or later, and use \"\n   \"replicate-wild-do-table=db_name.%.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-table\", OPT_REPLICATE_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the specified table. \"\n   \"To specify more than one table, use the directive multiple times, once \"\n   \"for each table. This will work for cross-database updates, in contrast \"\n   \"to replicate-do-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-db\", OPT_REPLICATE_IGNORE_DB,\n   \"Tells the slave thread to not replicate to the specified database. To \"\n   \"specify more than one database to ignore, use the directive multiple \"\n   \"times, once for each database. This option will not work if you use \"\n   \"cross database updates. If you need cross database updates to work, \"\n   \"make sure you have 3.23.28 or later, and use replicate-wild-ignore-\"\n   \"table=db_name.%. \", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-table\", OPT_REPLICATE_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the specified table. To specify \"\n   \"more than one table to ignore, use the directive multiple times, once for \"\n   \"each table. This will work for cross-database updates, in contrast to \"\n   \"replicate-ignore-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-rewrite-db\", OPT_REPLICATE_REWRITE_DB,\n   \"Updates to a database with a different name than the original. Example: \"\n   \"replicate-rewrite-db=master_db_name->slave_db_name.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"replicate-same-server-id\", 0,\n   \"In replication, if set to 1, do not skip events having our server id. \"\n   \"Default value is 0 (to break infinite loops in circular replication). \"\n   \"Can't be set to 1 if --log-slave-updates is used.\",\n   &replicate_same_server_id, &replicate_same_server_id,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"replicate-wild-do-table\", OPT_REPLICATE_WILD_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the tables that match \"\n   \"the specified wildcard pattern. To specify more than one table, use the \"\n   \"directive multiple times, once for each table. This will work for cross-\"\n   \"database updates. Example: replicate-wild-do-table=foo%.bar% will \"\n   \"replicate only updates to tables in all databases that start with foo \"\n   \"and whose table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-wild-ignore-table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the tables that match the \"\n   \"given wildcard pattern. To specify more than one table to ignore, use \"\n   \"the directive multiple times, once for each table. This will work for \"\n   \"cross-database updates. Example: replicate-wild-ignore-table=foo%.bar% \"\n   \"will not do updates to tables in databases that start with foo and whose \"\n   \"table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-mode\", OPT_SAFE, \"Skip some optimize stages (for testing). Deprecated.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-user-create\", 0,\n   \"Don't allow new user creation by the user who has no write privileges to the mysql.user table.\",\n   &opt_safe_user_create, &opt_safe_user_create, 0, GET_BOOL,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"show-slave-auth-info\", 0,\n   \"Show user and password in SHOW SLAVE HOSTS on this master.\",\n   &opt_show_slave_auth_info, &opt_show_slave_auth_info, 0,\n   GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-bdb\", OPT_DEPRECATED_OPTION,\n   \"Deprecated option; Exist only for compatiblity with old my.cnf files\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"skip-grant-tables\", 0,\n   \"Start without grant tables. This gives all users FULL ACCESS to all tables.\",\n   &opt_noacl, &opt_noacl, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif\n  {\"skip-host-cache\", OPT_SKIP_HOST_CACHE, \"Don't cache host names.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-slave-start\", 0,\n   \"If set, slave is not autostarted.\", &opt_skip_slave_start,\n   &opt_skip_slave_start, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-thread-priority\", OPT_SKIP_PRIOR,\n   \"Don't give threads different priorities. This option is deprecated \"\n   \"because it has no effect; the implied behavior is already the default.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  {\"slow-start-timeout\", 0,\n   \"Maximum number of milliseconds that the service control manager should wait \"\n   \"before trying to kill the windows service during startup\"\n   \"(Default: 15000).\", &slow_start_timeout, &slow_start_timeout, 0,\n   GET_ULONG, REQUIRED_ARG, 15000, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_OPENSSL\n  {\"ssl\", 0,\n   \"Enable SSL for connection (automatically enabled with other flags).\",\n   &opt_use_ssl, &opt_use_ssl, 0, GET_BOOL, OPT_ARG, 0, 0, 0,\n   0, 0, 0},\n#endif\n#ifdef __WIN__\n  {\"standalone\", 0,\n  \"Dummy option to start as a standalone program (NT).\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"symbolic-links\", 's', \"Enable symbolic link support.\",\n   &my_use_symdir, &my_use_symdir, 0, GET_BOOL, NO_ARG,\n   /*\n     The system call realpath() produces warnings under valgrind and\n     purify. These are not suppressed: instead we disable symlinks\n     option if compiled with valgrind support.\n     Also disable by default on Windows, due to high overhead for checking .sym \n     files.\n   */\n   IF_VALGRIND(0,IF_WIN(0,1)), 0, 0, 0, 0, 0},\n  {\"sysdate-is-now\", 0,\n   \"Non-default option to alias SYSDATE() to NOW() to make it safe-replicable. \"\n   \"Since 5.0, SYSDATE() returns a `dynamic' value different for different \"\n   \"invocations, even within the same statement.\",\n   &global_system_variables.sysdate_is_now,\n   0, 0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},\n  {\"tc-heuristic-recover\", 0,\n   \"Decision to use in heuristic recover process. Possible values are COMMIT \"\n   \"or ROLLBACK.\", &tc_heuristic_recover, &tc_heuristic_recover,\n   &tc_heuristic_recover_typelib, GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"temp-pool\", 0,\n#if (ENABLE_TEMP_POOL)\n   \"Using this option will cause most temporary files created to use a small \"\n   \"set of names, rather than a unique name for each new file.\",\n#else\n   \"This option is ignored on this OS.\",\n#endif\n   &use_temp_pool, &use_temp_pool, 0, GET_BOOL, NO_ARG, 1,\n   0, 0, 0, 0, 0},\n  {\"transaction-isolation\", 0,\n   \"Default transaction isolation level.\",\n   &global_system_variables.tx_isolation,\n   &global_system_variables.tx_isolation, &tx_isolation_typelib,\n   GET_ENUM, REQUIRED_ARG, ISO_REPEATABLE_READ, 0, 0, 0, 0, 0},\n  {\"user\", 'u', \"Run mysqld daemon as user.\", 0, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"verbose\", 'v', \"Used with --help option for detailed help.\",\n   &opt_verbose, &opt_verbose, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"version\", 'V', \"Output version information and exit.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"plugin-load\", 0,\n   \"Semicolon-separated list of plugins to load, where each plugin is \"\n   \"specified as ether a plugin_name=library_file pair or only a library_file. \"\n   \"If the latter case, all plugins from a given library_file will be loaded.\",\n   &opt_plugin_load, &opt_plugin_load, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"table_cache\", 0, \"Deprecated; use --table-open-cache instead.\",\n   &table_cache_size, &table_cache_size, 0, GET_ULONG,\n   REQUIRED_ARG, TABLE_OPEN_CACHE_DEFAULT, 1, 512*1024L, 0, 1, 0},\n  {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n};\n\n\nstatic int show_queries(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= (char *)&thd->query_id;\n  return 0;\n}\n\n\nstatic int show_net_compression(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= (char *)&thd->net.compress;\n  return 0;\n}\n\nstatic int show_starttime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - server_start_time);\n  return 0;\n}\n\n#ifdef ENABLED_PROFILING\nstatic int show_flushstatustime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - flush_status_time);\n  return 0;\n}\n#endif\n\n#ifdef HAVE_REPLICATION\nstatic int show_rpl_status(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  var->value= const_cast<char*>(rpl_status_type[(int)rpl_status]);\n  return 0;\n}\n\nstatic int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= buff;\n  *((my_bool *)buff)= (my_bool) (active_mi && \n                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&\n                                 active_mi->rli.slave_running);\n  return 0;\n}\n\nstatic int show_slave_retried_trans(THD *thd, SHOW_VAR *var, char *buff)\n{\n  /*\n    TODO: with multimaster, have one such counter per line in\n    SHOW SLAVE STATUS, and have the sum over all lines here.\n  */\n  if (active_mi)\n  {\n    var->type= SHOW_LONG;\n    var->value= buff;\n    *((long *)buff)= (long)active_mi->rli.retried_trans;\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\nstatic int show_slave_received_heartbeats(THD *thd, SHOW_VAR *var, char *buff)\n{\n  if (active_mi)\n  {\n    var->type= SHOW_LONGLONG;\n    var->value= buff;\n    *((longlong *)buff)= active_mi->received_heartbeats;\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\nstatic int show_heartbeat_period(THD *thd, SHOW_VAR *var, char *buff)\n{\n  if (active_mi)\n  {\n    var->type= SHOW_CHAR;\n    var->value= buff;\n    sprintf(buff, \"%.3f\", active_mi->heartbeat_period);\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\n\n#endif /* HAVE_REPLICATION */\n\nstatic int show_open_tables(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)cached_open_tables();\n  return 0;\n}\n\nstatic int show_prepared_stmt_count(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  mysql_mutex_lock(&LOCK_prepared_stmt_count);\n  *((long *)buff)= (long)prepared_stmt_count;\n  mysql_mutex_unlock(&LOCK_prepared_stmt_count);\n  return 0;\n}\n\nstatic int show_table_definitions(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)cached_table_definitions();\n  return 0;\n}\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n/* Functions relying on CTX */\nstatic int show_ssl_ctx_sess_accept(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cb_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cb_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cache_full(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cache_full(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_misses(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_misses(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_timeouts(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_timeouts(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_number(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_number(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_get_cache_size(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_get_cache_size(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_mode(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_depth(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_session_cache_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (!ssl_acceptor_fd)\n    var->value= const_cast<char*>(\"NONE\");\n  else\n    switch (SSL_CTX_get_session_cache_mode(ssl_acceptor_fd->ssl_context))\n    {\n    case SSL_SESS_CACHE_OFF:\n      var->value= const_cast<char*>(\"OFF\"); break;\n    case SSL_SESS_CACHE_CLIENT:\n      var->value= const_cast<char*>(\"CLIENT\"); break;\n    case SSL_SESS_CACHE_SERVER:\n      var->value= const_cast<char*>(\"SERVER\"); break;\n    case SSL_SESS_CACHE_BOTH:\n      var->value= const_cast<char*>(\"BOTH\"); break;\n    case SSL_SESS_CACHE_NO_AUTO_CLEAR:\n      var->value= const_cast<char*>(\"NO_AUTO_CLEAR\"); break;\n    case SSL_SESS_CACHE_NO_INTERNAL_LOOKUP:\n      var->value= const_cast<char*>(\"NO_INTERNAL_LOOKUP\"); break;\n    default:\n      var->value= const_cast<char*>(\"Unknown\"); break;\n    }\n  return 0;\n}\n\n/*\n   Functions relying on SSL\n   Note: In the show_ssl_* functions, we need to check if we have a\n         valid vio-object since this isn't always true, specifically\n         when session_status or global_status is requested from\n         inside an Event.\n */\nstatic int show_ssl_get_version(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_version((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_session_reused(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_session_reused((SSL*) thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_default_timeout(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_default_timeout((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->net.vio && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_mode((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_depth((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_cipher(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_cipher((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_get_cipher_list(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  var->value= buff;\n  if (thd->vio_ok() && thd->net.vio->ssl_arg)\n  {\n    int i;\n    const char *p;\n    char *end= buff + SHOW_VAR_FUNC_BUFF_SIZE;\n    for (i=0; (p= SSL_get_cipher_list((SSL*) thd->net.vio->ssl_arg,i)) &&\n               buff < end; i++)\n    {\n      buff= strnmov(buff, p, end-buff-1);\n      *buff++= ':';\n    }\n    if (i)\n      buff--;\n  }\n  *buff=0;\n  return 0;\n}\n\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY */\n\nstatic int show_default_keycache(THD *thd, SHOW_VAR *var, char *buff)\n{\n  struct st_data {\n    KEY_CACHE_STATISTICS stats;\n    SHOW_VAR var[8];\n  } *data;\n  SHOW_VAR *v;\n\n  data=(st_data *)buff;\n  v= data->var;\n\n  var->type= SHOW_ARRAY;\n  var->value= (char*)v;\n\n  get_key_cache_statistics(dflt_key_cache, 0, &data->stats);\n\n#define set_one_keycache_var(X,Y)       \\\n  v->name= X;                           \\\n  v->type= SHOW_LONGLONG;               \\\n  v->value= (char*)&data->stats.Y;      \\\n  v++;\n\n  set_one_keycache_var(\"blocks_not_flushed\", blocks_changed);\n  set_one_keycache_var(\"blocks_unused\",      blocks_unused);\n  set_one_keycache_var(\"blocks_used\",        blocks_used);\n  set_one_keycache_var(\"blocks_warm\",        blocks_warm);\n  set_one_keycache_var(\"read_requests\",      read_requests);\n  set_one_keycache_var(\"reads\",              reads);\n  set_one_keycache_var(\"write_requests\",     write_requests);\n  set_one_keycache_var(\"writes\",             writes);\n\n  v->name= 0;\n\n  DBUG_ASSERT((char*)(v+1) <= buff + SHOW_VAR_FUNC_BUFF_SIZE);\n\n#undef set_one_keycache_var\n\n  return 0;\n}\n\n#ifdef HAVE_POOL_OF_THREADS\nint show_threadpool_idle_threads(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_INT;\n  var->value= buff;\n  *(int *)buff= tp_get_idle_thread_count(); \n  return 0;\n}\n#endif\n\n/*\n  Variables shown by SHOW STATUS in alphabetical order\n*/\n\nSHOW_VAR status_vars[]= {\n  {\"Aborted_clients\",          (char*) &aborted_threads,        SHOW_LONG},\n  {\"Aborted_connects\",         (char*) &aborted_connects,       SHOW_LONG},\n  {\"Access_denied_errors\",     (char*) offsetof(STATUS_VAR, access_denied_errors), SHOW_LONG_STATUS},\n  {\"Binlog_bytes_written\",     (char*) offsetof(STATUS_VAR, binlog_bytes_written), SHOW_LONGLONG_STATUS},\n  {\"Binlog_cache_disk_use\",    (char*) &binlog_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_cache_use\",         (char*) &binlog_cache_use,       SHOW_LONG},\n  {\"Binlog_stmt_cache_disk_use\",(char*) &binlog_stmt_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_stmt_cache_use\",    (char*) &binlog_stmt_cache_use,       SHOW_LONG},\n  {\"Busy_time\",                (char*) offsetof(STATUS_VAR, busy_time), SHOW_DOUBLE_STATUS},\n  {\"Bytes_received\",           (char*) offsetof(STATUS_VAR, bytes_received), SHOW_LONGLONG_STATUS},\n  {\"Bytes_sent\",               (char*) offsetof(STATUS_VAR, bytes_sent), SHOW_LONGLONG_STATUS},\n  {\"Com\",                      (char*) com_status_vars, SHOW_ARRAY},\n  {\"Compression\",              (char*) &show_net_compression, SHOW_FUNC},\n  {\"Connections\",              (char*) &thread_id,              SHOW_LONG_NOFLUSH},\n  {\"Cpu_time\",                 (char*) offsetof(STATUS_VAR, cpu_time), SHOW_DOUBLE_STATUS},\n  {\"Created_tmp_disk_tables\",  (char*) offsetof(STATUS_VAR, created_tmp_disk_tables), SHOW_LONG_STATUS},\n  {\"Created_tmp_files\",\t       (char*) &my_tmp_file_created,\tSHOW_LONG},\n  {\"Created_tmp_tables\",       (char*) offsetof(STATUS_VAR, created_tmp_tables), SHOW_LONG_STATUS},\n  {\"Delayed_errors\",           (char*) &delayed_insert_errors,  SHOW_LONG},\n  {\"Delayed_insert_threads\",   (char*) &delayed_insert_threads, SHOW_LONG_NOFLUSH},\n  {\"Delayed_writes\",           (char*) &delayed_insert_writes,  SHOW_LONG},\n  {\"Empty_queries\",            (char*) offsetof(STATUS_VAR, empty_queries), SHOW_LONG_STATUS},\n  {\"Executed_events\",          (char*) &executed_events, SHOW_LONG_NOFLUSH },\n  {\"Executed_triggers\",        (char*) offsetof(STATUS_VAR, executed_triggers), SHOW_LONG_STATUS},\n  {\"Feature_dynamic_columns\",  (char*) offsetof(STATUS_VAR, feature_dynamic_columns), SHOW_LONG_STATUS},\n  {\"Feature_fulltext\",         (char*) offsetof(STATUS_VAR, feature_fulltext), SHOW_LONG_STATUS},\n  {\"Feature_gis\",              (char*) offsetof(STATUS_VAR, feature_gis), SHOW_LONG_STATUS},\n  {\"Feature_locale\",           (char*) offsetof(STATUS_VAR, feature_locale), SHOW_LONG_STATUS},\n  {\"Feature_subquery\",         (char*) offsetof(STATUS_VAR, feature_subquery), SHOW_LONG_STATUS},\n  {\"Feature_timezone\",         (char*) offsetof(STATUS_VAR, feature_timezone), SHOW_LONG_STATUS},\n  {\"Feature_trigger\",         (char*) offsetof(STATUS_VAR, feature_trigger), SHOW_LONG_STATUS},\n  {\"Feature_xml\",             (char*) offsetof(STATUS_VAR, feature_xml), SHOW_LONG_STATUS},\n  {\"Flush_commands\",           (char*) &refresh_version,        SHOW_LONG_NOFLUSH},\n  {\"Handler_commit\",           (char*) offsetof(STATUS_VAR, ha_commit_count), SHOW_LONG_STATUS},\n  {\"Handler_delete\",           (char*) offsetof(STATUS_VAR, ha_delete_count), SHOW_LONG_STATUS},\n  {\"Handler_discover\",         (char*) offsetof(STATUS_VAR, ha_discover_count), SHOW_LONG_STATUS},\n  {\"Handler_icp_attempts\",     (char*) offsetof(STATUS_VAR, ha_icp_attempts), SHOW_LONG_STATUS},\n  {\"Handler_icp_match\",        (char*) offsetof(STATUS_VAR, ha_icp_match), SHOW_LONG_STATUS},\n  {\"Handler_mrr_init\",         (char*) offsetof(STATUS_VAR, ha_mrr_init_count),  SHOW_LONG_STATUS},\n  {\"Handler_mrr_key_refills\",   (char*) offsetof(STATUS_VAR, ha_mrr_key_refills_count), SHOW_LONG_STATUS},\n  {\"Handler_mrr_rowid_refills\", (char*) offsetof(STATUS_VAR, ha_mrr_rowid_refills_count), SHOW_LONG_STATUS},\n  {\"Handler_prepare\",          (char*) offsetof(STATUS_VAR, ha_prepare_count),  SHOW_LONG_STATUS},\n  {\"Handler_read_first\",       (char*) offsetof(STATUS_VAR, ha_read_first_count), SHOW_LONG_STATUS},\n  {\"Handler_read_key\",         (char*) offsetof(STATUS_VAR, ha_read_key_count), SHOW_LONG_STATUS},\n  {\"Handler_read_last\",        (char*) offsetof(STATUS_VAR, ha_read_last_count), SHOW_LONG_STATUS},\n  {\"Handler_read_next\",        (char*) offsetof(STATUS_VAR, ha_read_next_count), SHOW_LONG_STATUS},\n  {\"Handler_read_prev\",        (char*) offsetof(STATUS_VAR, ha_read_prev_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd\",         (char*) offsetof(STATUS_VAR, ha_read_rnd_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd_deleted\", (char*) offsetof(STATUS_VAR, ha_read_rnd_deleted_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd_next\",    (char*) offsetof(STATUS_VAR, ha_read_rnd_next_count), SHOW_LONG_STATUS},\n  {\"Handler_rollback\",         (char*) offsetof(STATUS_VAR, ha_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint\",        (char*) offsetof(STATUS_VAR, ha_savepoint_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint_rollback\",(char*) offsetof(STATUS_VAR, ha_savepoint_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_tmp_update\",       (char*) offsetof(STATUS_VAR, ha_tmp_update_count), SHOW_LONG_STATUS},\n  {\"Handler_tmp_write\",        (char*) offsetof(STATUS_VAR, ha_tmp_write_count), SHOW_LONG_STATUS},\n  {\"Handler_update\",           (char*) offsetof(STATUS_VAR, ha_update_count), SHOW_LONG_STATUS},\n  {\"Handler_write\",            (char*) offsetof(STATUS_VAR, ha_write_count), SHOW_LONG_STATUS},\n  {\"Key\",                      (char*) &show_default_keycache, SHOW_FUNC},\n  {\"Last_query_cost\",          (char*) offsetof(STATUS_VAR, last_query_cost), SHOW_DOUBLE_STATUS},\n  {\"Max_used_connections\",     (char*) &max_used_connections,  SHOW_LONG},\n  {\"Not_flushed_delayed_rows\", (char*) &delayed_rows_in_use,    SHOW_LONG_NOFLUSH},\n  {\"Open_files\",               (char*) &my_file_opened,         SHOW_LONG_NOFLUSH},\n  {\"Open_streams\",             (char*) &my_stream_opened,       SHOW_LONG_NOFLUSH},\n  {\"Open_table_definitions\",   (char*) &show_table_definitions, SHOW_FUNC},\n  {\"Open_tables\",              (char*) &show_open_tables,       SHOW_FUNC},\n  {\"Opened_files\",             (char*) &my_file_total_opened, SHOW_LONG_NOFLUSH},\n  {\"Opened_table_definitions\", (char*) offsetof(STATUS_VAR, opened_shares), SHOW_LONG_STATUS},\n  {\"Opened_tables\",            (char*) offsetof(STATUS_VAR, opened_tables), SHOW_LONG_STATUS},\n  {\"Opened_views\",            (char*) offsetof(STATUS_VAR, opened_views), SHOW_LONG_STATUS},\n  {\"Prepared_stmt_count\",      (char*) &show_prepared_stmt_count, SHOW_FUNC},\n  {\"Rows_read\",                (char*) offsetof(STATUS_VAR, rows_read), SHOW_LONGLONG_STATUS},\n  {\"Rows_sent\",                (char*) offsetof(STATUS_VAR, rows_sent), SHOW_LONGLONG_STATUS},\n  {\"Rows_tmp_read\",            (char*) offsetof(STATUS_VAR, rows_tmp_read), SHOW_LONGLONG_STATUS},\n#ifdef HAVE_QUERY_CACHE\n  {\"Qcache_free_blocks\",       (char*) &query_cache.free_memory_blocks, SHOW_LONG_NOFLUSH},\n  {\"Qcache_free_memory\",       (char*) &query_cache.free_memory, SHOW_LONG_NOFLUSH},\n  {\"Qcache_hits\",              (char*) &query_cache.hits,       SHOW_LONG},\n  {\"Qcache_inserts\",           (char*) &query_cache.inserts,    SHOW_LONG},\n  {\"Qcache_lowmem_prunes\",     (char*) &query_cache.lowmem_prunes, SHOW_LONG},\n  {\"Qcache_not_cached\",        (char*) &query_cache.refused,    SHOW_LONG},\n  {\"Qcache_queries_in_cache\",  (char*) &query_cache.queries_in_cache, SHOW_LONG_NOFLUSH},\n  {\"Qcache_total_blocks\",      (char*) &query_cache.total_blocks, SHOW_LONG_NOFLUSH},\n#endif /*HAVE_QUERY_CACHE*/\n  {\"Queries\",                  (char*) &show_queries,            SHOW_FUNC},\n  {\"Questions\",                (char*) offsetof(STATUS_VAR, questions), SHOW_LONG_STATUS},\n#ifdef HAVE_REPLICATION\n  {\"Rpl_status\",               (char*) &show_rpl_status,          SHOW_FUNC},\n#endif\n  {\"Select_full_join\",         (char*) offsetof(STATUS_VAR, select_full_join_count), SHOW_LONG_STATUS},\n  {\"Select_full_range_join\",   (char*) offsetof(STATUS_VAR, select_full_range_join_count), SHOW_LONG_STATUS},\n  {\"Select_range\",             (char*) offsetof(STATUS_VAR, select_range_count), SHOW_LONG_STATUS},\n  {\"Select_range_check\",       (char*) offsetof(STATUS_VAR, select_range_check_count), SHOW_LONG_STATUS},\n  {\"Select_scan\",\t       (char*) offsetof(STATUS_VAR, select_scan_count), SHOW_LONG_STATUS},\n  {\"Slave_open_temp_tables\",   (char*) &slave_open_temp_tables, SHOW_LONG},\n#ifdef HAVE_REPLICATION\n  {\"Slave_heartbeat_period\",   (char*) &show_heartbeat_period, SHOW_FUNC},\n  {\"Slave_received_heartbeats\",(char*) &show_slave_received_heartbeats, SHOW_FUNC},\n  {\"Slave_retried_transactions\",(char*) &show_slave_retried_trans, SHOW_FUNC},\n  {\"Slave_running\",            (char*) &show_slave_running,     SHOW_FUNC},\n#endif\n  {\"Slow_launch_threads\",      (char*) &slow_launch_threads,    SHOW_LONG},\n  {\"Slow_queries\",             (char*) offsetof(STATUS_VAR, long_query_count), SHOW_LONG_STATUS},\n  {\"Sort_merge_passes\",\t       (char*) offsetof(STATUS_VAR, filesort_merge_passes), SHOW_LONG_STATUS},\n  {\"Sort_range\",\t       (char*) offsetof(STATUS_VAR, filesort_range_count), SHOW_LONG_STATUS},\n  {\"Sort_rows\",\t\t       (char*) offsetof(STATUS_VAR, filesort_rows), SHOW_LONG_STATUS},\n  {\"Sort_scan\",\t\t       (char*) offsetof(STATUS_VAR, filesort_scan_count), SHOW_LONG_STATUS},\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  {\"Ssl_accept_renegotiates\",  (char*) &show_ssl_ctx_sess_accept_renegotiate, SHOW_FUNC},\n  {\"Ssl_accepts\",              (char*) &show_ssl_ctx_sess_accept, SHOW_FUNC},\n  {\"Ssl_callback_cache_hits\",  (char*) &show_ssl_ctx_sess_cb_hits, SHOW_FUNC},\n  {\"Ssl_cipher\",               (char*) &show_ssl_get_cipher, SHOW_FUNC},\n  {\"Ssl_cipher_list\",          (char*) &show_ssl_get_cipher_list, SHOW_FUNC},\n  {\"Ssl_client_connects\",      (char*) &show_ssl_ctx_sess_connect, SHOW_FUNC},\n  {\"Ssl_connect_renegotiates\", (char*) &show_ssl_ctx_sess_connect_renegotiate, SHOW_FUNC},\n  {\"Ssl_ctx_verify_depth\",     (char*) &show_ssl_ctx_get_verify_depth, SHOW_FUNC},\n  {\"Ssl_ctx_verify_mode\",      (char*) &show_ssl_ctx_get_verify_mode, SHOW_FUNC},\n  {\"Ssl_default_timeout\",      (char*) &show_ssl_get_default_timeout, SHOW_FUNC},\n  {\"Ssl_finished_accepts\",     (char*) &show_ssl_ctx_sess_accept_good, SHOW_FUNC},\n  {\"Ssl_finished_connects\",    (char*) &show_ssl_ctx_sess_connect_good, SHOW_FUNC},\n  {\"Ssl_session_cache_hits\",   (char*) &show_ssl_ctx_sess_hits, SHOW_FUNC},\n  {\"Ssl_session_cache_misses\", (char*) &show_ssl_ctx_sess_misses, SHOW_FUNC},\n  {\"Ssl_session_cache_mode\",   (char*) &show_ssl_ctx_get_session_cache_mode, SHOW_FUNC},\n  {\"Ssl_session_cache_overflows\", (char*) &show_ssl_ctx_sess_cache_full, SHOW_FUNC},\n  {\"Ssl_session_cache_size\",   (char*) &show_ssl_ctx_sess_get_cache_size, SHOW_FUNC},\n  {\"Ssl_session_cache_timeouts\", (char*) &show_ssl_ctx_sess_timeouts, SHOW_FUNC},\n  {\"Ssl_sessions_reused\",      (char*) &show_ssl_session_reused, SHOW_FUNC},\n  {\"Ssl_used_session_cache_entries\",(char*) &show_ssl_ctx_sess_number, SHOW_FUNC},\n  {\"Ssl_verify_depth\",         (char*) &show_ssl_get_verify_depth, SHOW_FUNC},\n  {\"Ssl_verify_mode\",          (char*) &show_ssl_get_verify_mode, SHOW_FUNC},\n  {\"Ssl_version\",              (char*) &show_ssl_get_version, SHOW_FUNC},\n#endif\n#endif /* HAVE_OPENSSL */\n  {\"Syncs\",                    (char*) &my_sync_count,          SHOW_LONG_NOFLUSH},\n  /*\n    Expression cache used only for caching subqueries now, so its statistic\n    variables we call subquery_cache*.\n  */\n  {\"Subquery_cache_hit\",       (char*) &subquery_cache_hit,     SHOW_LONG},\n  {\"Subquery_cache_miss\",      (char*) &subquery_cache_miss,    SHOW_LONG},\n  {\"Table_locks_immediate\",    (char*) &locks_immediate,        SHOW_LONG},\n  {\"Table_locks_waited\",       (char*) &locks_waited,           SHOW_LONG},\n#ifdef HAVE_MMAP\n  {\"Tc_log_max_pages_used\",    (char*) &tc_log_max_pages_used,  SHOW_LONG},\n  {\"Tc_log_page_size\",         (char*) &tc_log_page_size,       SHOW_LONG_NOFLUSH},\n  {\"Tc_log_page_waits\",        (char*) &tc_log_page_waits,      SHOW_LONG},\n#endif\n#ifdef HAVE_POOL_OF_THREADS\n  {\"Threadpool_idle_threads\",  (char *) &show_threadpool_idle_threads, SHOW_FUNC},\n  {\"Threadpool_threads\",       (char *) &tp_stats.num_worker_threads, SHOW_INT},\n#endif\n  {\"Threads_cached\",           (char*) &cached_thread_count,    SHOW_LONG_NOFLUSH},\n  {\"Threads_connected\",        (char*) &connection_count,       SHOW_INT},\n  {\"Threads_created\",\t       (char*) &thread_created,\t\tSHOW_LONG_NOFLUSH},\n  {\"Threads_running\",          (char*) &thread_running,         SHOW_INT},\n  {\"Uptime\",                   (char*) &show_starttime,         SHOW_FUNC},\n#ifdef ENABLED_PROFILING\n  {\"Uptime_since_flush_status\",(char*) &show_flushstatustime,   SHOW_FUNC},\n#endif\n  {NullS, NullS, SHOW_LONG}\n};\n\nbool add_terminator(DYNAMIC_ARRAY *options)\n{\n  my_option empty_element= {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0};\n  return insert_dynamic(options, (uchar *)&empty_element);\n}\n\n#ifndef EMBEDDED_LIBRARY\nstatic void print_version(void)\n{\n  set_server_version();\n\n  printf(\"%s  Ver %s for %s on %s (%s)\\n\",my_progname,\n\t server_version,SYSTEM_TYPE,MACHINE_TYPE, MYSQL_COMPILATION_COMMENT);\n}\n\n/** Compares two options' names, treats - and _ the same */\nstatic int option_cmp(my_option *a, my_option *b)\n{\n  const char *sa= a->name;\n  const char *sb= b->name;\n  for (; *sa || *sb; sa++, sb++)\n  {\n    if (*sa < *sb)\n    {\n      if (*sa == '-' && *sb == '_')\n        continue;\n      else\n        return -1;\n    }\n    if (*sa > *sb)\n    {\n      if (*sa == '_' && *sb == '-')\n        continue;\n      else\n        return 1;\n    }\n  }\n  DBUG_ASSERT(a->name == b->name);\n  return 0;\n}\n\nstatic void print_help()\n{\n  MEM_ROOT mem_root;\n  init_alloc_root(&mem_root, 4096, 4096);\n\n  pop_dynamic(&all_options);\n  sys_var_add_options(&all_options, sys_var::PARSE_EARLY);\n  add_plugin_options(&all_options, &mem_root);\n  sort_dynamic(&all_options, (qsort_cmp) option_cmp);\n  add_terminator(&all_options);\n\n  my_print_help((my_option*) all_options.buffer);\n  my_print_variables((my_option*) all_options.buffer);\n\n  free_root(&mem_root, MYF(0));\n}\n\nstatic void usage(void)\n{\n  DBUG_ENTER(\"usage\");\n  if (!(default_charset_info= get_charset_by_csname(default_character_set_name,\n\t\t\t\t\t           MY_CS_PRIMARY,\n\t\t\t\t\t\t   MYF(MY_WME))))\n    exit(1);\n  if (!default_collation_name)\n    default_collation_name= (char*) default_charset_info->name;\n  print_version();\n  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n  puts(\"Starts the MariaDB database server.\\n\");\n  printf(\"Usage: %s [OPTIONS]\\n\", my_progname);\n  if (!opt_verbose)\n    puts(\"\\nFor more help options (several pages), use mysqld --verbose --help.\");\n  else\n  {\n#ifdef __WIN__\n  puts(\"NT and Win32 specific options:\\n\\\n  --install                     Install the default service (NT).\\n\\\n  --install-manual              Install the default service started manually (NT).\\n\\\n  --install service_name        Install an optional service (NT).\\n\\\n  --install-manual service_name Install an optional service started manually (NT).\\n\\\n  --remove                      Remove the default service from the service list (NT).\\n\\\n  --remove service_name         Remove the service_name from the service list (NT).\\n\\\n  --enable-named-pipe           Only to be used for the default server (NT).\\n\\\n  --standalone                  Dummy option to start as a standalone server (NT).\\\n\");\n  puts(\"\");\n#endif\n  print_defaults(MYSQL_CONFIG_NAME,load_default_groups);\n  puts(\"\");\n  set_ports();\n\n  /* Print out all the options including plugin supplied options */\n  print_help();\n\n  if (! plugins_are_initialized)\n  {\n    puts(\"\\n\\\nPlugins have parameters that are not reflected in this list\\n\\\nbecause execution stopped before plugins were initialized.\");\n  }\n\n  puts(\"\\n\\\nTo see what values a running MySQL server is using, type\\n\\\n'mysqladmin variables' instead of 'mysqld --verbose --help'.\");\n  }\n  DBUG_VOID_RETURN;\n}\n#endif /*!EMBEDDED_LIBRARY*/\n\n/**\n  Initialize MySQL global variables to default values.\n\n  @note\n    The reason to set a lot of global variables to zero is to allow one to\n    restart the embedded server with a clean environment\n    It's also needed on some exotic platforms where global variables are\n    not set to 0 when a program starts.\n\n    We don't need to set variables refered to in my_long_options\n    as these are initialized by my_getopt.\n*/\n\nstatic int mysql_init_variables(void)\n{\n  /* Things reset to zero */\n  opt_skip_slave_start= opt_reckless_slave = 0;\n  mysql_home[0]= pidfile_name[0]= log_error_file[0]= 0;\n#if defined(HAVE_REALPATH) && !defined(HAVE_valgrind) && !defined(HAVE_BROKEN_REALPATH)\n  /*  We can only test for sub paths if my_symlink.c is using realpath */\n  myisam_test_invalid_symlink= test_if_data_home_dir;\n#endif\n  opt_log= opt_slow_log= 0;\n  opt_bin_log= opt_bin_log_used= 0;\n  opt_disable_networking= opt_skip_show_db=0;\n  opt_skip_name_resolve= 0;\n  opt_ignore_builtin_innodb= 0;\n  opt_logname= opt_binlog_index_name= opt_slow_logname= 0;\n  opt_log_basename= 0;\n  opt_tc_log_file= (char *)\"tc.log\";      // no hostname in tc_log file name !\n  opt_secure_auth= 0;\n  opt_bootstrap= opt_myisam_log= 0;\n  mqh_used= 0;\n  kill_in_progress= 0;\n  cleanup_done= 0;\n  server_id_supplied= 0;\n  test_flags= select_errors= dropping_tables= ha_open_options=0;\n  thread_count= thread_running= kill_cached_threads= wake_thread=0;\n  slave_open_temp_tables= 0;\n  cached_thread_count= 0;\n  opt_endinfo= using_udf_functions= 0;\n  opt_using_transactions= 0;\n  abort_loop= select_thread_in_use= signal_thread_in_use= 0;\n  ready_to_exit= shutdown_in_progress= grant_option= 0;\n  aborted_threads= aborted_connects= 0;\n  subquery_cache_miss= subquery_cache_hit= 0;\n  delayed_insert_threads= delayed_insert_writes= delayed_rows_in_use= 0;\n  delayed_insert_errors= thread_created= 0;\n  specialflag= 0;\n  binlog_cache_use=  binlog_cache_disk_use= 0;\n  max_used_connections= slow_launch_threads = 0;\n  mysqld_user= mysqld_chroot= opt_init_file= opt_bin_logname = 0;\n  prepared_stmt_count= 0;\n  mysqld_unix_port= opt_mysql_tmpdir= my_bind_addr_str= NullS;\n  bzero((uchar*) &mysql_tmpdir_list, sizeof(mysql_tmpdir_list));\n  bzero((char *) &global_status_var, sizeof(global_status_var));\n  opt_large_pages= 0;\n  opt_super_large_pages= 0;\n#if defined(ENABLED_DEBUG_SYNC)\n  opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  key_map_full.set_all();\n\n  /* Character sets */\n  system_charset_info= &my_charset_utf8_general_ci;\n  files_charset_info= &my_charset_utf8_general_ci;\n  national_charset_info= &my_charset_utf8_general_ci;\n  table_alias_charset= &my_charset_bin;\n  character_set_filesystem= &my_charset_bin;\n\n  opt_specialflag= SPECIAL_ENGLISH;\n  unix_sock= base_ip_sock= extra_ip_sock= INVALID_SOCKET;\n  mysql_home_ptr= mysql_home;\n  pidfile_name_ptr= pidfile_name;\n  log_error_file_ptr= log_error_file;\n  protocol_version= PROTOCOL_VERSION;\n  what_to_log= ~ (1L << (uint) COM_TIME);\n  refresh_version= 2L;\t/* Increments on each reload. 0 and 1 are reserved */\n  executed_events= 0;\n  global_query_id= thread_id= 1L;\n  my_atomic_rwlock_init(&global_query_id_lock);\n  my_atomic_rwlock_init(&thread_running_lock);\n  strnmov(server_version, MYSQL_SERVER_VERSION, sizeof(server_version)-1);\n  threads.empty();\n  thread_cache.empty();\n  key_caches.empty();\n  if (!(dflt_key_cache= get_or_create_key_cache(default_key_cache_base.str,\n                                                default_key_cache_base.length)))\n  {\n    sql_print_error(\"Cannot allocate the keycache\");\n    return 1;\n  }\n\n  /* set key_cache_hash.default_value = dflt_key_cache */\n  multi_keycache_init();\n\n  /* Set directory paths */\n  mysql_real_data_home_len=\n    strmake_buf(mysql_real_data_home,\n                get_relative_path(MYSQL_DATADIR)) - mysql_real_data_home;\n  /* Replication parameters */\n  master_info_file= (char*) \"master.info\",\n    relay_log_info_file= (char*) \"relay-log.info\";\n  report_user= report_password = report_host= 0;\t/* TO BE DELETED */\n  opt_relay_logname= opt_relaylog_index_name= 0;\n\n  /* Variables in libraries */\n  charsets_dir= 0;\n  default_character_set_name= (char*) MYSQL_DEFAULT_CHARSET_NAME;\n  default_collation_name= compiled_default_collation_name;\n  character_set_filesystem_name= (char*) \"binary\";\n  lc_messages= (char*) \"en_US\";\n  lc_time_names_name= (char*) \"en_US\";\n  \n  /* Variables that depends on compile options */\n#ifndef DBUG_OFF\n  default_dbug_option=IF_WIN(\"d:t:i:O,\\\\mysqld.trace\",\n\t\t\t     \"d:t:i:o,/tmp/mysqld.trace\");\n  current_dbug_option= default_dbug_option;\n#endif\n  opt_error_log= IF_WIN(1,0);\n#ifdef ENABLED_PROFILING\n    have_profiling = SHOW_OPTION_YES;\n#else\n    have_profiling = SHOW_OPTION_NO;\n#endif\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  have_ssl=SHOW_OPTION_YES;\n#else\n  have_ssl=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_BROKEN_REALPATH\n  have_symlink=SHOW_OPTION_NO;\n#else\n  have_symlink=SHOW_OPTION_YES;\n#endif\n#ifdef HAVE_DLOPEN\n  have_dlopen=SHOW_OPTION_YES;\n#else\n  have_dlopen=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_QUERY_CACHE\n  have_query_cache=SHOW_OPTION_YES;\n#else\n  have_query_cache=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_SPATIAL\n  have_geometry=SHOW_OPTION_YES;\n#else\n  have_geometry=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_RTREE_KEYS\n  have_rtree_keys=SHOW_OPTION_YES;\n#else\n  have_rtree_keys=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_CRYPT\n  have_crypt=SHOW_OPTION_YES;\n#else\n  have_crypt=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_COMPRESS\n  have_compress= SHOW_OPTION_YES;\n#else\n  have_compress= SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_LIBWRAP\n  libwrapName= NullS;\n#endif\n#ifdef HAVE_OPENSSL\n  des_key_file = 0;\n#ifndef EMBEDDED_LIBRARY\n  ssl_acceptor_fd= 0;\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_SMEM\n  shared_memory_base_name= default_shared_memory_base_name;\n#endif\n\n#if defined(__WIN__)\n  /* Allow Win32 users to move MySQL anywhere */\n  {\n    char prg_dev[LIBLEN];\n    char executing_path_name[LIBLEN];\n    if (!test_if_hard_path(my_progname))\n    {\n      // we don't want to use GetModuleFileName inside of my_path since\n      // my_path is a generic path dereferencing function and here we care\n      // only about the executing binary.\n      GetModuleFileName(NULL, executing_path_name, sizeof(executing_path_name));\n      my_path(prg_dev, executing_path_name, NULL);\n    }\n    else\n      my_path(prg_dev, my_progname, \"mysql/bin\");\n    strcat(prg_dev,\"/../\");\t\t\t// Remove 'bin' to get base dir\n    cleanup_dirname(mysql_home,prg_dev);\n  }\n#else\n  const char *tmpenv;\n  if (!(tmpenv = getenv(\"MY_BASEDIR_VERSION\")))\n    tmpenv = DEFAULT_MYSQL_HOME;\n  strmake_buf(mysql_home, tmpenv);\n#endif\n  return 0;\n}\n\nmy_bool\nmysqld_get_one_option(int optid,\n                      const struct my_option *opt __attribute__((unused)),\n                      char *argument)\n{\n  switch(optid) {\n  case '#':\n#ifndef DBUG_OFF\n    if (!argument)\n      argument= (char*) default_dbug_option;\n    if (argument[0] == '0' && !argument[1])\n    {\n      DEBUGGER_OFF;\n      break;\n    }\n    DEBUGGER_ON;\n    if (argument[0] == '1' && !argument[1])\n      break;\n    DBUG_SET_INITIAL(argument);\n    opt_endinfo=1;\t\t\t\t/* unireg: memory allocation */\n#else\n    sql_print_warning(\"'%s' is disabled in this build\", opt->name);\n#endif\n    break;\n  case OPT_DEPRECATED_OPTION:\n    sql_print_warning(\"'%s' is deprecated. It does nothing and exists only \"\n                      \"for compatiblity with old my.cnf files.\",\n                      opt->name);\n    break;\n  case 'a':\n    global_system_variables.sql_mode= MODE_ANSI;\n    global_system_variables.tx_isolation= ISO_SERIALIZABLE;\n    break;\n  case 'b':\n    strmake_buf(mysql_home, argument);\n    break;\n  case 'C':\n    if (default_collation_name == compiled_default_collation_name)\n      default_collation_name= 0;\n    break;\n  case 'l':\n    WARN_DEPRECATED(NULL, 7, 0, \"--log\", \"'--general-log'/'--general-log-file'\");\n    opt_log=1;\n    break;\n  case 'h':\n    strmake_buf(mysql_real_data_home, argument);\n    /* Correct pointer set by my_getopt (for embedded library) */\n    mysql_real_data_home_ptr= mysql_real_data_home;\n    break;\n  case 'u':\n    if (!mysqld_user || !strcmp(mysqld_user, argument))\n      mysqld_user= argument;\n    else\n      sql_print_warning(\"Ignoring user change to '%s' because the user was set to '%s' earlier on the command line\\n\", argument, mysqld_user);\n    break;\n  case 'L':\n    strmake_buf(lc_messages_dir, argument);\n    break;\n  case OPT_BINLOG_FORMAT:\n    binlog_format_used= true;\n    break;\n#include <sslopt-case.h>\n#ifndef EMBEDDED_LIBRARY\n  case 'V':\n    print_version();\n    opt_abort= 1;                    // Abort after parsing all options\n    break;\n#endif /*EMBEDDED_LIBRARY*/\n  case 'W':\n    if (!argument)\n      global_system_variables.log_warnings++;\n    else if (argument == disabled_my_option)\n      global_system_variables.log_warnings= 0L;\n    else\n      global_system_variables.log_warnings= atoi(argument);\n    break;\n  case 'T':\n    test_flags= argument ? (uint) atoi(argument) : 0;\n    opt_endinfo=1;\n    break;\n  case OPT_THREAD_CONCURRENCY:\n    WARN_DEPRECATED_NO_REPLACEMENT(NULL, \"THREAD_CONCURRENCY\");\n    break;\n  case (int) OPT_ISAM_LOG:\n    opt_myisam_log=1;\n    break;\n  case (int) OPT_BIN_LOG:\n    opt_bin_log= test(argument != disabled_my_option);\n    opt_bin_log_used= 1;\n    break;\n  case (int) OPT_LOG_BASENAME:\n  {\n    if (opt_log_basename[0] == 0 || strchr(opt_log_basename, FN_EXTCHAR) ||\n        strchr(opt_log_basename,FN_LIBCHAR))\n    {\n      sql_print_error(\"Wrong argument for --log-basename. It can't be empty or contain '.' or '\" FN_DIRSEP \"'\");\n      return 1;\n    }\n    if (log_error_file_ptr != disabled_my_option)\n      log_error_file_ptr= opt_log_basename;\n\n    make_default_log_name(&opt_logname, \".log\", false);\n    make_default_log_name(&opt_slow_logname, \"-slow.log\", false);\n    make_default_log_name(&opt_bin_logname, \"-bin\", true);\n    make_default_log_name(&opt_binlog_index_name, \"-bin.index\", true);\n    make_default_log_name(&opt_relay_logname, \"-relay-bin\", true);\n    make_default_log_name(&opt_relaylog_index_name, \"-relay-bin.index\", true);\n\n    pidfile_name_ptr= pidfile_name;\n    strmake(pidfile_name, argument, sizeof(pidfile_name)-5);\n    strmov(fn_ext(pidfile_name),\".pid\");\n\n    /* check for errors */\n    if (!opt_bin_logname || !opt_relaylog_index_name || ! opt_logname ||\n        ! opt_slow_logname || !pidfile_name_ptr)\n      return 1;                                 // out of memory error\n    break;\n  }\n#ifdef HAVE_REPLICATION\n  case (int)OPT_REPLICATE_IGNORE_DB:\n  {\n    rpl_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_DB:\n  {\n    rpl_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_REWRITE_DB:\n  {\n    /* See also OPT_REWRITE_DB handling in client/mysqlbinlog.cc */\n    char* key = argument,*p, *val;\n\n    if (!(p= strstr(argument, \"->\")))\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - missing '->'!\\n\");\n      return 1;\n    }\n    val= p--;\n    while (my_isspace(mysqld_charset, *p) && p > argument)\n      *p-- = 0;\n    if (p == argument)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty FROM db!\\n\");\n      return 1;\n    }\n    *val= 0;\n    val+= 2;\n    while (*val && my_isspace(mysqld_charset, *val))\n      val++;\n    if (!*val)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty TO db!\\n\");\n      return 1;\n    }\n\n    rpl_filter->add_db_rewrite(key, val);\n    break;\n  }\n\n  case (int)OPT_BINLOG_IGNORE_DB:\n  {\n    binlog_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_BINLOG_DO_DB:\n  {\n    binlog_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_TABLE:\n  {\n    if (rpl_filter->add_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_DO_TABLE:\n  {\n    if (rpl_filter->add_wild_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_wild_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n#endif /* HAVE_REPLICATION */\n  case (int) OPT_SLOW_QUERY_LOG:\n    WARN_DEPRECATED(NULL, 7, 0, \"--log-slow-queries\", \"'--slow-query-log'/'--slow-query-log-file'\");\n    opt_slow_log= 1;\n    break;\n  case (int) OPT_SAFE:\n    opt_specialflag|= SPECIAL_SAFE_MODE | SPECIAL_NO_NEW_FUNC;\n    delay_key_write_options= (uint) DELAY_KEY_WRITE_NONE;\n    myisam_recover_options= HA_RECOVER_DEFAULT;\n    ha_open_options&= ~(HA_OPEN_DELAY_KEY_WRITE);\n#ifdef HAVE_QUERY_CACHE\n    query_cache_size=0;\n#endif\n    sql_print_warning(\"The syntax '--safe-mode' is deprecated and will be \"\n                      \"removed in a future release.\");\n    break;\n  case (int) OPT_SKIP_PRIOR:\n    opt_specialflag|= SPECIAL_NO_PRIOR;\n    sql_print_warning(\"The --skip-thread-priority startup option is deprecated \"\n                      \"and will be removed in MySQL 7.0. This option has no effect \"\n                      \"as the implied behavior is already the default.\");\n    break;\n  case (int) OPT_SKIP_HOST_CACHE:\n    opt_specialflag|= SPECIAL_NO_HOST_CACHE;\n    break;\n  case (int) OPT_SKIP_RESOLVE:\n    opt_skip_name_resolve= 1;\n    opt_specialflag|=SPECIAL_NO_RESOLVE;\n    break;\n  case (int) OPT_WANT_CORE:\n    test_flags |= TEST_CORE_ON_SIGNAL;\n    break;\n  case OPT_CONSOLE:\n    if (opt_console)\n      opt_error_log= 0;\t\t\t// Force logs to stdout\n    break;\n  case OPT_BOOTSTRAP:\n    opt_noacl=opt_bootstrap=1;\n    break;\n  case OPT_SERVER_ID:\n    server_id_supplied = 1;\n    break;\n  case OPT_ONE_THREAD:\n    thread_handling= SCHEDULER_NO_THREADS;\n    break;\n  case OPT_LOWER_CASE_TABLE_NAMES:\n    lower_case_table_names_used= 1;\n    break;\n#if defined(ENABLED_DEBUG_SYNC)\n  case OPT_DEBUG_SYNC_TIMEOUT:\n    /*\n      Debug Sync Facility. See debug_sync.cc.\n      Default timeout for WAIT_FOR action.\n      Default value is zero (facility disabled).\n      If option is given without an argument, supply a non-zero value.\n    */\n    if (!argument)\n    {\n      /* purecov: begin tested */\n      opt_debug_sync_timeout= DEBUG_SYNC_DEFAULT_WAIT_TIMEOUT;\n      /* purecov: end */\n    }\n    break;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  case OPT_ENGINE_CONDITION_PUSHDOWN:\n    /*\n      The last of --engine-condition-pushdown and --optimizer_switch on\n      command line wins (see get_options().\n    */\n    if (global_system_variables.engine_condition_pushdown)\n      global_system_variables.optimizer_switch|=\n        OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n    else\n      global_system_variables.optimizer_switch&=\n        ~OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n    break;\n  case OPT_LOG_ERROR:\n    /*\n      \"No --log-error\" == \"write errors to stderr\",\n      \"--log-error without argument\" == \"write errors to a file\".\n    */\n    if (argument == NULL) /* no argument */\n      log_error_file_ptr= const_cast<char*>(\"\");\n    break;\n  case OPT_MAX_LONG_DATA_SIZE:\n    max_long_data_size_used= true;\n    break;\n\n\n  case OPT_IGNORE_DB_DIRECTORY:\n    opt_ignore_db_dirs= NULL; // will be set in ignore_db_dirs_process_additions\n    if (*argument == 0)\n      ignore_db_dirs_reset();\n    else\n    {\n      if (push_ignored_db_dir(argument))\n      {\n        sql_print_error(\"Can't start server: \"\n                        \"cannot process --ignore-db-dir=%.*s\", \n                        FN_REFLEN, argument);\n        return 1;\n      }\n    }\n    break;\n  }\n  return 0;\n}\n\n\n/** Handle arguments for multiple key caches. */\n\nC_MODE_START\n\nstatic void*\nmysql_getopt_value(const char *keyname, uint key_length,\n\t\t   const struct my_option *option, int *error)\n{\n  if (error)\n    *error= 0;\n  switch (option->id) {\n  case OPT_KEY_BUFFER_SIZE:\n  case OPT_KEY_CACHE_BLOCK_SIZE:\n  case OPT_KEY_CACHE_DIVISION_LIMIT:\n  case OPT_KEY_CACHE_AGE_THRESHOLD:\n  case OPT_KEY_CACHE_PARTITIONS:\n  {\n    KEY_CACHE *key_cache;\n    if (!(key_cache= get_or_create_key_cache(keyname, key_length)))\n    {\n      if (error)\n        *error= EXIT_OUT_OF_MEMORY;\n      return 0;\n    }\n    switch (option->id) {\n    case OPT_KEY_BUFFER_SIZE:\n      return &key_cache->param_buff_size;\n    case OPT_KEY_CACHE_BLOCK_SIZE:\n      return &key_cache->param_block_size;\n    case OPT_KEY_CACHE_DIVISION_LIMIT:\n      return &key_cache->param_division_limit;\n    case OPT_KEY_CACHE_AGE_THRESHOLD:\n      return &key_cache->param_age_threshold;\n    case OPT_KEY_CACHE_PARTITIONS:\n      return (uchar**) &key_cache->param_partitions;\n    }\n  }\n  }\n  return option->value;\n}\n\nstatic void option_error_reporter(enum loglevel level, const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n\n  /* Don't print warnings for --loose options during bootstrap */\n  if (level == ERROR_LEVEL || !opt_bootstrap ||\n      global_system_variables.log_warnings)\n  {\n    vprint_msg_to_log(level, format, args);\n  }\n  va_end(args);\n}\n\nC_MODE_END\n\n/**\n  Get server options from the command line,\n  and perform related server initializations.\n  @param [in, out] argc_ptr       command line options (count)\n  @param [in, out] argv_ptr       command line options (values)\n  @return 0 on success\n\n  @todo\n  - FIXME add EXIT_TOO_MANY_ARGUMENTS to \"mysys_err.h\" and return that code?\n*/\nstatic int get_options(int *argc_ptr, char ***argv_ptr)\n{\n  int ho_error;\n\n  my_getopt_register_get_addr(mysql_getopt_value);\n  my_getopt_error_reporter= option_error_reporter;\n\n  /* prepare all_options array */\n  my_init_dynamic_array(&all_options, sizeof(my_option),\n                        array_elements(my_long_options),\n                        array_elements(my_long_options)/4);\n  for (my_option *opt= my_long_options;\n       opt < my_long_options + array_elements(my_long_options) - 1;\n       opt++)\n    insert_dynamic(&all_options, (uchar*) opt);\n  sys_var_add_options(&all_options, 0);\n  add_terminator(&all_options);\n\n  /* Skip unknown options so that they may be processed later by plugins */\n  my_getopt_skip_unknown= TRUE;\n\n  if ((ho_error= handle_options(argc_ptr, argv_ptr, (my_option*)(all_options.buffer),\n                                mysqld_get_one_option)))\n    return ho_error;\n\n  if (!opt_help)\n    delete_dynamic(&all_options);\n  else\n    opt_abort= 1;\n\n  /* Add back the program name handle_options removes */\n  (*argc_ptr)++;\n  (*argv_ptr)--;\n\n  /*\n    Options have been parsed. Now some of them need additional special\n    handling, like custom value checking, checking of incompatibilites\n    between options, setting of multiple variables, etc.\n    Do them here.\n  */\n\n  if ((opt_log_slow_admin_statements || opt_log_queries_not_using_indexes ||\n       opt_log_slow_slave_statements) &&\n      !opt_slow_log)\n    sql_print_warning(\"options --log-slow-admin-statements, --log-queries-not-using-indexes and --log-slow-slave-statements have no effect if --log_slow_queries is not set\");\n  if (global_system_variables.net_buffer_length > \n      global_system_variables.max_allowed_packet)\n  {\n    sql_print_warning(\"net_buffer_length (%lu) is set to be larger \"\n                      \"than max_allowed_packet (%lu). Please rectify.\",\n                      global_system_variables.net_buffer_length, \n                      global_system_variables.max_allowed_packet);\n  }\n\n  if (log_error_file_ptr != disabled_my_option)\n    opt_error_log= 1;\n  else\n    log_error_file_ptr= const_cast<char*>(\"\");\n\n  opt_init_connect.length=strlen(opt_init_connect.str);\n  opt_init_slave.length=strlen(opt_init_slave.str);\n\n  if (global_system_variables.low_priority_updates)\n    thr_upgraded_concurrent_insert_lock= TL_WRITE_LOW_PRIORITY;\n\n  if (ft_boolean_check_syntax_string((uchar*) ft_boolean_syntax))\n  {\n    sql_print_error(\"Invalid ft-boolean-syntax string: %s\\n\",\n                    ft_boolean_syntax);\n    return 1;\n  }\n\n  if (opt_disable_networking)\n    mysqld_port= mysqld_extra_port= 0;\n\n  if (opt_skip_show_db)\n    opt_specialflag|= SPECIAL_SKIP_SHOW_DB;\n\n  if (myisam_flush)\n    flush_time= 0;\n\n#ifdef HAVE_REPLICATION\n  if (opt_slave_skip_errors)\n    init_slave_skip_errors(opt_slave_skip_errors);\n#endif\n\n  if (global_system_variables.max_join_size == HA_POS_ERROR)\n    global_system_variables.option_bits|= OPTION_BIG_SELECTS;\n  else\n    global_system_variables.option_bits&= ~OPTION_BIG_SELECTS;\n\n  // Synchronize @@global.autocommit on --autocommit\n  const ulonglong turn_bit_on= opt_autocommit ?\n    OPTION_AUTOCOMMIT : OPTION_NOT_AUTOCOMMIT;\n  global_system_variables.option_bits=\n    (global_system_variables.option_bits &\n     ~(OPTION_NOT_AUTOCOMMIT | OPTION_AUTOCOMMIT)) | turn_bit_on;\n\n  global_system_variables.sql_mode=\n    expand_sql_mode(global_system_variables.sql_mode);\n#if defined(HAVE_BROKEN_REALPATH)\n  my_use_symdir=0;\n  my_disable_symlinks=1;\n  have_symlink=SHOW_OPTION_NO;\n#else\n  if (!my_use_symdir)\n  {\n    my_disable_symlinks=1;\n    have_symlink=SHOW_OPTION_DISABLED;\n  }\n#endif\n  if (opt_debugging)\n  {\n    /* Allow break with SIGINT, no core or stack trace */\n    test_flags|= TEST_SIGINT;\n    opt_stack_trace= 1;\n    test_flags&= ~TEST_CORE_ON_SIGNAL;\n  }\n  /* Set global MyISAM variables from delay_key_write_options */\n  fix_delay_key_write(0, 0, OPT_GLOBAL);\n\n#ifndef EMBEDDED_LIBRARY\n  if (mysqld_chroot)\n    set_root(mysqld_chroot);\n#else\n  thread_handling = SCHEDULER_NO_THREADS;\n  max_allowed_packet= global_system_variables.max_allowed_packet;\n  net_buffer_length= global_system_variables.net_buffer_length;\n#endif\n  if (fix_paths())\n    return 1;\n\n  /*\n    Set some global variables from the global_system_variables\n    In most cases the global variables will not be used\n  */\n  my_disable_locking= myisam_single_user= test(opt_external_locking == 0);\n  my_default_record_cache_size=global_system_variables.read_buff_size;\n\n  /*\n    Log mysys errors when we don't have a thd or thd->log_all_errors is set\n    (recovery) to the log.  This is mainly useful for debugging strange system\n    errors.\n  */\n  if (global_system_variables.log_warnings >= 10)\n    my_global_flags= MY_WME | ME_JUST_INFO;\n  /* Log all errors not handled by thd->handle_error() to my_message_sql() */\n  if (global_system_variables.log_warnings >= 11)\n    my_global_flags|= ME_NOREFRESH;\n  if (my_assert_on_error)\n    debug_assert_if_crashed_table= 1;\n\n  global_system_variables.long_query_time= (ulonglong)\n    (global_system_variables.long_query_time_double * 1e6);\n\n  if (opt_short_log_format)\n    opt_specialflag|= SPECIAL_SHORT_LOG_FORMAT;\n\n  if (init_global_datetime_format(MYSQL_TIMESTAMP_DATE,\n                                  &global_date_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_TIME,\n                                  &global_time_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_DATETIME,\n                                  &global_datetime_format))\n    return 1;\n\n#ifdef EMBEDDED_LIBRARY\n  one_thread_scheduler(thread_scheduler);\n  one_thread_scheduler(extra_thread_scheduler);\n#else\n\n#ifdef _WIN32\n  /* workaround: disable thread pool on XP */\n  if (GetProcAddress(GetModuleHandle(\"kernel32\"),\"CreateThreadpool\") == 0 &&\n      thread_handling > SCHEDULER_NO_THREADS)\n    thread_handling = SCHEDULER_ONE_THREAD_PER_CONNECTION;\n#endif\n\n  if (thread_handling <= SCHEDULER_ONE_THREAD_PER_CONNECTION)\n    one_thread_per_connection_scheduler(thread_scheduler, &max_connections,\n                                        &connection_count);\n  else if (thread_handling == SCHEDULER_NO_THREADS)\n    one_thread_scheduler(thread_scheduler);\n  else\n    pool_of_threads_scheduler(thread_scheduler,  &max_connections,\n                                        &connection_count); \n\n  one_thread_per_connection_scheduler(extra_thread_scheduler,\n                                      &extra_max_connections,\n                                      &extra_connection_count);\n#endif\n\n  global_system_variables.engine_condition_pushdown=\n    test(global_system_variables.optimizer_switch &\n         OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN);\n\n  opt_readonly= read_only;\n\n  /*\n    If max_long_data_size is not specified explicitly use\n    value of max_allowed_packet.\n  */\n  if (!max_long_data_size_used)\n    max_long_data_size= global_system_variables.max_allowed_packet;\n\n  /* Rember if max_user_connections was 0 at startup */\n  max_user_connections_checking= global_system_variables.max_user_connections != 0;\n  return 0;\n}\n\n\n/*\n  Create version name for running mysqld version\n  We automaticly add suffixes -debug, -embedded and -log to the version\n  name to make the version more descriptive.\n  (MYSQL_SERVER_SUFFIX is set by the compilation environment)\n*/\n\nvoid set_server_version(void)\n{\n  char *version_end= server_version+sizeof(server_version)-1;\n  char *end= strxnmov(server_version, sizeof(server_version)-1,\n                      MYSQL_SERVER_VERSION,\n                      MYSQL_SERVER_SUFFIX_STR, NullS);\n#ifdef EMBEDDED_LIBRARY\n  end= strnmov(end, \"-embedded\", (version_end-end));\n#endif\n#ifndef DBUG_OFF\n  if (!strstr(MYSQL_SERVER_SUFFIX_STR, \"-debug\"))\n    end= strnmov(end, \"-debug\", (version_end-end));\n#endif\n  if (opt_log || opt_slow_log || opt_bin_log)\n    strnmov(end, \"-log\", (version_end-end)); // This may slow down system\n  *end= 0;\n}\n\n\nstatic char *get_relative_path(const char *path)\n{\n  if (test_if_hard_path(path) &&\n      is_prefix(path,DEFAULT_MYSQL_HOME) &&\n      strcmp(DEFAULT_MYSQL_HOME,FN_ROOTDIR))\n  {\n    path+=(uint) strlen(DEFAULT_MYSQL_HOME);\n    while (*path == FN_LIBCHAR || *path == FN_LIBCHAR2)\n      path++;\n  }\n  return (char*) path;\n}\n\n\n/**\n  Fix filename and replace extension where 'dir' is relative to\n  mysql_real_data_home.\n  @return\n    1 if len(path) > FN_REFLEN\n*/\n\nbool\nfn_format_relative_to_data_home(char * to, const char *name,\n\t\t\t\tconst char *dir, const char *extension)\n{\n  char tmp_path[FN_REFLEN];\n  if (!test_if_hard_path(dir))\n  {\n    strxnmov(tmp_path,sizeof(tmp_path)-1, mysql_real_data_home,\n\t     dir, NullS);\n    dir=tmp_path;\n  }\n  return !fn_format(to, name, dir, extension,\n\t\t    MY_APPEND_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH);\n}\n\n\n/**\n  Test a file path to determine if the path is compatible with the secure file\n  path restriction.\n \n  @param path null terminated character string\n\n  @return\n    @retval TRUE The path is secure\n    @retval FALSE The path isn't secure\n*/\n\nbool is_secure_file_path(char *path)\n{\n  char buff1[FN_REFLEN], buff2[FN_REFLEN];\n  size_t opt_secure_file_priv_len;\n  /*\n    All paths are secure if opt_secure_file_path is 0\n  */\n  if (!opt_secure_file_priv)\n    return TRUE;\n\n  opt_secure_file_priv_len= strlen(opt_secure_file_priv);\n\n  if (strlen(path) >= FN_REFLEN)\n    return FALSE;\n\n  if (my_realpath(buff1, path, 0))\n  {\n    /*\n      The supplied file path might have been a file and not a directory.\n    */\n    size_t length= dirname_length(path);        // Guaranteed to be < FN_REFLEN\n    memcpy(buff2, path, length);\n    buff2[length]= '\\0';\n    if (length == 0 || my_realpath(buff1, buff2, 0))\n      return FALSE;\n  }\n  convert_dirname(buff2, buff1, NullS);\n  if (!lower_case_file_system)\n  {\n    if (strncmp(opt_secure_file_priv, buff2, opt_secure_file_priv_len))\n      return FALSE;\n  }\n  else\n  {\n    if (files_charset_info->coll->strnncoll(files_charset_info,\n                                            (uchar *) buff2, strlen(buff2),\n                                            (uchar *) opt_secure_file_priv,\n                                            opt_secure_file_priv_len,\n                                            TRUE))\n      return FALSE;\n  }\n  return TRUE;\n}\n\n\nstatic int fix_paths(void)\n{\n  char buff[FN_REFLEN],*pos;\n  DBUG_ENTER(\"fix_paths\");\n\n  convert_dirname(mysql_home,mysql_home,NullS);\n  /* Resolve symlinks to allow 'mysql_home' to be a relative symlink */\n  my_realpath(mysql_home,mysql_home,MYF(0));\n  /* Ensure that mysql_home ends in FN_LIBCHAR */\n  pos=strend(mysql_home);\n  if (pos[-1] != FN_LIBCHAR)\n  {\n    pos[0]= FN_LIBCHAR;\n    pos[1]= 0;\n  }\n  convert_dirname(lc_messages_dir, lc_messages_dir, NullS);\n  convert_dirname(mysql_real_data_home,mysql_real_data_home,NullS);\n  (void) my_load_path(mysql_home,mysql_home,\"\"); // Resolve current dir\n  (void) my_load_path(mysql_real_data_home,mysql_real_data_home,mysql_home);\n  (void) my_load_path(pidfile_name, pidfile_name_ptr, mysql_real_data_home);\n\n  convert_dirname(opt_plugin_dir, opt_plugin_dir_ptr ? opt_plugin_dir_ptr : \n                                  get_relative_path(PLUGINDIR), NullS);\n  (void) my_load_path(opt_plugin_dir, opt_plugin_dir, mysql_home);\n  opt_plugin_dir_ptr= opt_plugin_dir;\n  pidfile_name_ptr= pidfile_name;\n\n  my_realpath(mysql_unpacked_real_data_home, mysql_real_data_home, MYF(0));\n  mysql_unpacked_real_data_home_len= \n    (int) strlen(mysql_unpacked_real_data_home);\n  if (mysql_unpacked_real_data_home[mysql_unpacked_real_data_home_len-1] == FN_LIBCHAR)\n    --mysql_unpacked_real_data_home_len;\n\n  char *sharedir=get_relative_path(SHAREDIR);\n  if (test_if_hard_path(sharedir))\n    strmake_buf(buff, sharedir);\t\t/* purecov: tested */\n  else\n    strxnmov(buff,sizeof(buff)-1,mysql_home,sharedir,NullS);\n  convert_dirname(buff,buff,NullS);\n  (void) my_load_path(lc_messages_dir, lc_messages_dir, buff);\n\n  /* If --character-sets-dir isn't given, use shared library dir */\n  if (charsets_dir)\n    strmake_buf(mysql_charsets_dir, charsets_dir);\n  else\n    strxnmov(mysql_charsets_dir, sizeof(mysql_charsets_dir)-1, buff,\n\t     CHARSET_DIR, NullS);\n  (void) my_load_path(mysql_charsets_dir, mysql_charsets_dir, buff);\n  convert_dirname(mysql_charsets_dir, mysql_charsets_dir, NullS);\n  charsets_dir=mysql_charsets_dir;\n\n  if (init_tmpdir(&mysql_tmpdir_list, opt_mysql_tmpdir))\n    DBUG_RETURN(1);\n  if (!opt_mysql_tmpdir)\n    opt_mysql_tmpdir= mysql_tmpdir;\n#ifdef HAVE_REPLICATION\n  if (!slave_load_tmpdir)\n    slave_load_tmpdir= mysql_tmpdir;\n#endif /* HAVE_REPLICATION */\n  /*\n    Convert the secure-file-priv option to system format, allowing\n    a quick strcmp to check if read or write is in an allowed dir\n  */\n  if (opt_secure_file_priv)\n  {\n    if (*opt_secure_file_priv == 0)\n    {\n      my_free(opt_secure_file_priv);\n      opt_secure_file_priv= 0;\n    }\n    else\n    {\n      if (strlen(opt_secure_file_priv) >= FN_REFLEN)\n        opt_secure_file_priv[FN_REFLEN-1]= '\\0';\n      if (my_realpath(buff, opt_secure_file_priv, 0))\n      {\n        sql_print_warning(\"Failed to normalize the argument for --secure-file-priv.\");\n        DBUG_RETURN(1);\n      }\n      char *secure_file_real_path= (char *)my_malloc(FN_REFLEN, MYF(MY_FAE));\n      convert_dirname(secure_file_real_path, buff, NullS);\n      my_free(opt_secure_file_priv);\n      opt_secure_file_priv= secure_file_real_path;\n    }\n  }\n  DBUG_RETURN(0);\n}\n\n/**\n  Check if file system used for databases is case insensitive.\n\n  @param dir_name\t\t\tDirectory to test\n\n  @retval -1  Don't know (Test failed)\n  @retval  0   File system is case sensitive\n  @retval  1   File system is case insensitive\n*/\n\nstatic int test_if_case_insensitive(const char *dir_name)\n{\n  int result= 0;\n  File file;\n  char buff[FN_REFLEN], buff2[FN_REFLEN];\n  MY_STAT stat_info;\n  DBUG_ENTER(\"test_if_case_insensitive\");\n\n  fn_format(buff, glob_hostname, dir_name, \".lower-test\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  fn_format(buff2, glob_hostname, dir_name, \".LOWER-TEST\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  mysql_file_delete(key_file_casetest, buff2, MYF(0));\n  if ((file= mysql_file_create(key_file_casetest,\n                               buff, 0666, O_RDWR, MYF(0))) < 0)\n  {\n    if (!opt_abort)\n      sql_print_warning(\"Can't create test file %s\", buff);\n    DBUG_RETURN(-1);\n  }\n  mysql_file_close(file, MYF(0));\n  if (mysql_file_stat(key_file_casetest, buff2, &stat_info, MYF(0)))\n    result= 1;\t\t\t\t\t// Can access file\n  mysql_file_delete(key_file_casetest, buff, MYF(MY_WME));\n  DBUG_PRINT(\"exit\", (\"result: %d\", result));\n  DBUG_RETURN(result);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  Create file to store pid number.\n*/\nstatic void create_pid_file()\n{\n  File file;\n  if ((file= mysql_file_create(key_file_pid, pidfile_name, 0664,\n                               O_WRONLY | O_TRUNC, MYF(MY_WME))) >= 0)\n  {\n    char buff[MAX_BIGINT_WIDTH + 1], *end;\n    end= int10_to_str((long) getpid(), buff, 10);\n    *end++= '\\n';\n    if (!mysql_file_write(file, (uchar*) buff, (uint) (end-buff),\n                          MYF(MY_WME | MY_NABP)))\n    {\n      mysql_file_close(file, MYF(0));\n      pid_file_created= true;\n      return;\n    }\n    mysql_file_close(file, MYF(0));\n  }\n  sql_perror(\"Can't start server: can't create PID file\");\n  exit(1);\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/**\n  Remove the process' pid file.\n  \n  @param  flags  file operation flags\n*/\n\nstatic void delete_pid_file(myf flags)\n{\n#ifndef EMBEDDED_LIBRARY\n  if (pid_file_created)\n  {\n    mysql_file_delete(key_file_pid, pidfile_name, flags);\n    pid_file_created= false;\n  }\n#endif /* EMBEDDED_LIBRARY */\n  return;\n}\n\n\n/** Clear most status variables. */\nvoid refresh_status(THD *thd)\n{\n  mysql_mutex_lock(&LOCK_status);\n\n  /* Add thread's status variabes to global status */\n  add_to_status(&global_status_var, &thd->status_var);\n\n  /* Reset thread's status variables */\n  bzero((uchar*) &thd->status_var, sizeof(thd->status_var));\n  bzero((uchar*) &thd->org_status_var, sizeof(thd->org_status_var)); \n  thd->start_bytes_received= 0;\n\n  /* Reset some global variables */\n  reset_status_vars();\n\n  /* Reset the counters of all key caches (default and named). */\n  process_key_caches(reset_key_cache_counters, 0);\n  flush_status_time= time((time_t*) 0);\n  mysql_mutex_unlock(&LOCK_status);\n\n  /*\n    Set max_used_connections to the number of currently open\n    connections.  Lock LOCK_thread_count out of LOCK_status to avoid\n    deadlocks.  Status reset becomes not atomic, but status data is\n    not exact anyway.\n  */\n  mysql_mutex_lock(&LOCK_thread_count);\n  max_used_connections= thread_count-delayed_insert_threads;\n  mysql_mutex_unlock(&LOCK_thread_count);\n}\n\n\n/*****************************************************************************\n  Instantiate variables for missing storage engines\n  This section should go away soon\n*****************************************************************************/\n\n/*****************************************************************************\n  Instantiate templates\n*****************************************************************************/\n\n#ifdef HAVE_EXPLICIT_TEMPLATE_INSTANTIATION\n/* Used templates */\ntemplate class I_List<THD>;\ntemplate class I_List_iterator<THD>;\ntemplate class I_List<i_string>;\ntemplate class I_List<i_string_pair>;\ntemplate class I_List<Statement>;\ntemplate class I_List_iterator<Statement>;\n#endif\n\n"], "fixing_code": ["/* Copyright (c) 2000, 2013, Oracle and/or its affiliates.\n   Copyright (c) 2010, 2016, Monty Program Ab.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n#ifndef _my_sys_h\n#define _my_sys_h\n\n#include \"my_global.h\"                  /* C_MODE_START, C_MODE_END */\n\nC_MODE_START\n\n#ifdef HAVE_AIOWAIT\n#include <sys/asynch.h>\t\t\t/* Used by record-cache */\ntypedef struct my_aio_result {\n  aio_result_t result;\n  int\t       pending;\n} my_aio_result;\n#endif\n\n#include <my_valgrind.h>\n\n#include <my_pthread.h>\n\n#include <m_ctype.h>                    /* for CHARSET_INFO */\n#include <stdarg.h>\n#include <typelib.h>\n#ifdef _WIN32\n#include <malloc.h> /*for alloca*/\n#endif\n#include <mysql/plugin.h>\n\n#define MY_INIT(name)   { my_progname= name; my_init(); }\n\n/**\n  Max length of an error message generated by mysys utilities.\n  Some mysys functions produce error messages. These mostly go\n  to stderr.\n  This constant defines the size of the buffer used to format\n  the message. It should be kept in sync with MYSQL_ERRMSG_SIZE,\n  since sometimes mysys errors are stored in the server diagnostics\n  area, and we would like to avoid unexpected truncation.\n*/\n#define MYSYS_ERRMSG_SIZE   (512)\n\n#define MY_FILE_ERROR\t((size_t) -1)\n\n\t/* General bitmaps for my_func's */\n#define MY_FFNF\t\t1\t/* Fatal if file not found */\n#define MY_FNABP\t2\t/* Fatal if not all bytes read/writen */\n#define MY_NABP\t\t4\t/* Error if not all bytes read/writen */\n#define MY_FAE\t\t8\t/* Fatal if any error */\n#define MY_WME\t\t16\t/* Write message on error */\n#define MY_WAIT_IF_FULL 32\t/* Wait and try again if disk full error */\n#define MY_IGNORE_BADFD 32      /* my_sync: ignore 'bad descriptor' errors */\n#define MY_UNUSED       64      /* Unused (was support for RAID) */\n#define MY_FULL_IO     512      /* For my_read - loop intil I/O is complete */\n#define MY_DONT_CHECK_FILESIZE 128 /* Option to init_io_cache() */\n#define MY_LINK_WARNING 32\t/* my_redel() gives warning if links */\n#define MY_COPYTIME\t64\t/* my_redel() copys time */\n#define MY_DELETE_OLD\t256\t/* my_create_with_symlink() */\n#define MY_RESOLVE_LINK 128\t/* my_realpath(); Only resolve links */\n#define MY_HOLD_ORIGINAL_MODES 128  /* my_copy() holds to file modes */\n#define MY_REDEL_MAKE_BACKUP 256\n#define MY_SEEK_NOT_DONE 32\t/* my_lock may have to do a seek */\n#define MY_SHORT_WAIT\t64\t/* my_lock() don't wait if can't lock */\n#define MY_FORCE_LOCK   128     /* use my_lock() even if disable_locking */\n#define MY_NO_WAIT      256\t/* my_lock() don't wait at all */\n#define MY_ZEROFILL\t32\t/* my_malloc(), fill array with zero */\n#define MY_ALLOW_ZERO_PTR 64\t/* my_realloc() ; zero ptr -> malloc */\n#define MY_FREE_ON_ERROR 128\t/* my_realloc() ; Free old ptr on error */\n#define MY_HOLD_ON_ERROR 256\t/* my_realloc() ; Return old ptr on error */\n#define MY_DONT_OVERWRITE_FILE 2048 /* my_copy: Don't overwrite file */\n#define MY_THREADSAFE 2048      /* my_seek(): lock fd mutex */\n#define MY_SYNC       4096      /* my_copy(): sync dst file */\n#define MY_SYNC_DIR   32768     /* my_create/delete/rename: sync directory */\n#define MY_SYNC_FILESIZE 65536  /* my_sync(): safe sync when file is extended */\n\n#define MY_CHECK_ERROR\t1\t/* Params to my_end; Check open-close */\n#define MY_GIVE_INFO\t2\t/* Give time info about process*/\n#define MY_DONT_FREE_DBUG 4     /* Do not call DBUG_END() in my_end() */\n\n#define ME_HIGHBYTE\t8\t/* Shift for colours */\n#define ME_NOCUR\t1\t/* Don't use curses message */\n#define ME_OLDWIN\t2\t/* Use old window */\n#define ME_BELL\t\t4\t/* Ring bell then printing message */\n#define ME_HOLDTANG\t8\t/* Don't delete last keys */\n#define ME_WAITTOT\t16\t/* Wait for errtime secs of for a action */\n#define ME_WAITTANG\t32\t/* Wait for a user action  */\n#define ME_NOREFRESH\t64\t/* Write the error message to error log */\n#define ME_NOINPUT\t128\t/* Dont use the input libary */\n#define ME_COLOUR1\t((1 << ME_HIGHBYTE))\t/* Possibly error-colours */\n#define ME_COLOUR2\t((2 << ME_HIGHBYTE))\n#define ME_COLOUR3\t((3 << ME_HIGHBYTE))\n#define ME_JUST_INFO    1024    /**< not error but just info */\n#define ME_JUST_WARNING 2048    /**< not error but just warning */\n#define ME_FATALERROR   4096    /* Fatal statement error */\n\n\t/* Bits in last argument to fn_format */\n#define MY_REPLACE_DIR\t\t1\t/* replace dir in name with 'dir' */\n#define MY_REPLACE_EXT\t\t2\t/* replace extension with 'ext' */\n#define MY_UNPACK_FILENAME\t4\t/* Unpack name (~ -> home) */\n#define MY_PACK_FILENAME\t8\t/* Pack name (home -> ~) */\n#define MY_RESOLVE_SYMLINKS\t16\t/* Resolve all symbolic links */\n#define MY_RETURN_REAL_PATH\t32\t/* return full path for file */\n#define MY_SAFE_PATH\t\t64\t/* Return NULL if too long path */\n#define MY_RELATIVE_PATH\t128\t/* name is relative to 'dir' */\n#define MY_APPEND_EXT           256     /* add 'ext' as additional extension*/\n\n\n\t/* My seek flags */\n#define MY_SEEK_SET\t0\n#define MY_SEEK_CUR\t1\n#define MY_SEEK_END\t2\n\n\t/* Some constants */\n#define MY_WAIT_FOR_USER_TO_FIX_PANIC\t60\t/* in seconds */\n#define MY_WAIT_GIVE_USER_A_MESSAGE\t10\t/* Every 10 times of prev */\n#define MIN_COMPRESS_LENGTH\t\t50\t/* Don't compress small bl. */\n#define DFLT_INIT_HITS  3\n\n\t/* root_alloc flags */\n#define MY_KEEP_PREALLOC\t1\n#define MY_MARK_BLOCKS_FREE     2  /* move used to free list and reuse them */\n\n\t/* Internal error numbers (for assembler functions) */\n#define MY_ERRNO_EDOM\t\t33\n#define MY_ERRNO_ERANGE\t\t34\n\n\t/* Bits for get_date timeflag */\n#define GETDATE_DATE_TIME\t1\n#define GETDATE_SHORT_DATE\t2\n#define GETDATE_HHMMSSTIME\t4\n#define GETDATE_GMT\t\t8\n#define GETDATE_FIXEDLENGTH\t16\n\n/* Extra length needed for filename if one calls my_create_backup_name */\n#define MY_BACKUP_NAME_EXTRA_LENGTH 17\n\n\t/* defines when allocating data */\nextern void *my_malloc(size_t Size,myf MyFlags);\nextern void *my_multi_malloc(myf MyFlags, ...);\nextern void *my_realloc(void *oldpoint, size_t Size, myf MyFlags);\nextern void my_free(void *ptr);\nextern void *my_memdup(const void *from,size_t length,myf MyFlags);\nextern char *my_strdup(const char *from,myf MyFlags);\nextern char *my_strndup(const char *from, size_t length, myf MyFlags);\n\nextern int sf_leaking_memory; /* set to 1 to disable memleak detection */\n\n#ifdef HAVE_LARGE_PAGES\nextern uint my_get_large_page_size(void);\nextern uchar * my_large_malloc(size_t size, myf my_flags);\nextern void my_large_free(uchar *ptr);\n#else\n#define my_get_large_page_size() (0)\n#define my_large_malloc(A,B) my_malloc_lock((A),(B))\n#define my_large_free(A) my_free_lock((A))\n#endif /* HAVE_LARGE_PAGES */\n\n#if defined(HAVE_ALLOCA) && !defined(HAVE_valgrind)\n#if defined(_AIX) && !defined(__GNUC__) && !defined(_AIX43)\n#pragma alloca\n#endif /* _AIX */\n#if defined(__MWERKS__)\n#undef alloca\n#define alloca _alloca\n#endif /* __MWERKS__ */\n#if defined(__GNUC__) && !defined(HAVE_ALLOCA_H) && ! defined(alloca)\n#define alloca __builtin_alloca\n#endif /* GNUC */\n#define my_alloca(SZ) alloca((size_t) (SZ))\n#define my_afree(PTR) ((void)0)\n#else\n#define my_alloca(SZ) my_malloc(SZ,MYF(MY_FAE))\n#define my_afree(PTR) my_free(PTR)\n#endif /* HAVE_ALLOCA */\n\n#define my_safe_alloca(size, min_length) ((size <= min_length) ? my_alloca(size) : my_malloc(size,MYF(MY_FAE)))\n#define my_safe_afree(ptr, size, min_length) ((size <= min_length) ? my_afree(ptr) : my_free(ptr))\n\n#ifndef errno\t\t\t\t/* did we already get it? */\n#ifdef HAVE_ERRNO_AS_DEFINE\n#include <errno.h>\t\t\t/* errno is a define */\n#else\nextern int errno;\t\t\t/* declare errno */\n#endif\n#endif\t\t\t\t\t/* #ifndef errno */\nextern char *home_dir;\t\t\t/* Home directory for user */\nextern MYSQL_PLUGIN_IMPORT char  *mysql_data_home;\nextern const char *my_progname;\t\t/* program-name (printed in errors) */\nextern const char *my_progname_short;\t/* like above but without directory */\nextern char curr_dir[];\t\t/* Current directory for user */\nextern void (*error_handler_hook)(uint my_err, const char *str,myf MyFlags);\nextern void (*fatal_error_handler_hook)(uint my_err, const char *str,\n\t\t\t\t       myf MyFlags);\nextern uint my_file_limit;\nextern ulonglong my_thread_stack_size;\n\nextern const char *(*proc_info_hook)(MYSQL_THD, const char *, const char *,\n                                     const char *, const unsigned int);\n\n#ifdef HAVE_LARGE_PAGES\nextern my_bool my_use_large_pages;\nextern uint    my_large_page_size;\n#endif\n\n/* charsets */\n#define MY_ALL_CHARSETS_SIZE 2048\nextern MYSQL_PLUGIN_IMPORT CHARSET_INFO *default_charset_info;\nextern MYSQL_PLUGIN_IMPORT CHARSET_INFO *all_charsets[MY_ALL_CHARSETS_SIZE];\nextern struct charset_info_st compiled_charsets[];\n\n/* statistics */\nextern ulong\tmy_file_opened,my_stream_opened, my_tmp_file_created;\nextern ulong    my_file_total_opened;\nextern ulong    my_sync_count;\nextern uint\tmysys_usage_id;\nextern my_bool\tmy_init_done;\nextern my_bool  my_assert_on_error;\nextern myf      my_global_flags;        /* Set to MY_WME for more error messages */\n\t\t\t\t\t/* Point to current my_message() */\nextern void (*my_sigtstp_cleanup)(void),\n\t\t\t\t\t/* Executed before jump to shell */\n\t    (*my_sigtstp_restart)(void),\n\t    (*my_abort_hook)(int);\n\t\t\t\t\t/* Executed when comming from shell */\nextern MYSQL_PLUGIN_IMPORT int my_umask;\t\t/* Default creation mask  */\nextern int my_umask_dir,\n\t   my_recived_signals,\t/* Signals we have got */\n\t   my_safe_to_handle_signal, /* Set when allowed to SIGTSTP */\n\t   my_dont_interrupt;\t/* call remember_intr when set */\nextern my_bool my_use_symdir;\n\nextern ulong\tmy_default_record_cache_size;\nextern my_bool  my_disable_locking, my_disable_async_io,\n                my_disable_flush_key_blocks, my_disable_symlinks;\nextern my_bool my_disable_sync, my_disable_copystat_in_redel;\nextern char\twild_many,wild_one,wild_prefix;\nextern const char *charsets_dir;\n/* from default.c */\nextern const char *my_defaults_extra_file;\nextern const char *my_defaults_group_suffix;\nextern const char *my_defaults_file;\n\nextern my_bool timed_mutexes;\n\nenum loglevel {\n   ERROR_LEVEL,\n   WARNING_LEVEL,\n   INFORMATION_LEVEL\n};\n\nenum cache_type\n{\n  TYPE_NOT_SET= 0, READ_CACHE, WRITE_CACHE,\n  SEQ_READ_APPEND\t\t/* sequential read or append */,\n  READ_FIFO, READ_NET,WRITE_NET};\n\nenum flush_type\n{\n  FLUSH_KEEP,           /* flush block and keep it in the cache */\n  FLUSH_RELEASE,        /* flush block and remove it from the cache */\n  FLUSH_IGNORE_CHANGED, /* remove block from the cache */\n  /*\n    As my_disable_flush_pagecache_blocks is always 0, the following option\n    is strictly equivalent to FLUSH_KEEP\n  */\n  FLUSH_FORCE_WRITE,\n  /**\n     @brief like FLUSH_KEEP but return immediately if file is already being\n     flushed (even partially) by another thread; only for page cache,\n     forbidden for key cache.\n  */\n  FLUSH_KEEP_LAZY\n};\n\ntypedef struct st_record_cache\t/* Used when cacheing records */\n{\n  File file;\n  int\trc_seek,error,inited;\n  uint\trc_length,read_length,reclength;\n  my_off_t rc_record_pos,end_of_file;\n  uchar *rc_buff,*rc_buff2,*rc_pos,*rc_end,*rc_request_pos;\n#ifdef HAVE_AIOWAIT\n  int\tuse_async_io;\n  my_aio_result aio_result;\n#endif\n  enum cache_type type;\n} RECORD_CACHE;\n\nenum file_type\n{\n  UNOPEN = 0, FILE_BY_OPEN, FILE_BY_CREATE, STREAM_BY_FOPEN, STREAM_BY_FDOPEN,\n  FILE_BY_MKSTEMP, FILE_BY_DUP\n};\n\nstruct st_my_file_info\n{\n  char  *name;\n#ifdef _WIN32\n  HANDLE fhandle;   /* win32 file handle */\n  int    oflag;     /* open flags, e.g O_APPEND */\n#endif\n  enum   file_type\ttype;\n};\n\nextern struct st_my_file_info *my_file_info;\n\ntypedef struct st_dynamic_array\n{\n  uchar *buffer;\n  uint elements,max_element;\n  uint alloc_increment;\n  uint size_of_element;\n} DYNAMIC_ARRAY;\n\ntypedef struct st_my_tmpdir\n{\n  DYNAMIC_ARRAY full_list;\n  char **list;\n  uint cur, max;\n  mysql_mutex_t mutex;\n} MY_TMPDIR;\n\ntypedef struct st_dynamic_string\n{\n  char *str;\n  size_t length,max_length,alloc_increment;\n} DYNAMIC_STRING;\n\nstruct st_io_cache;\ntypedef int (*IO_CACHE_CALLBACK)(struct st_io_cache*);\n\ntypedef struct st_io_cache_share\n{\n  mysql_mutex_t       mutex;           /* To sync on reads into buffer. */\n  mysql_cond_t        cond;            /* To wait for signals. */\n  mysql_cond_t        cond_writer;     /* For a synchronized writer. */\n  /* Offset in file corresponding to the first byte of buffer. */\n  my_off_t              pos_in_file;\n  /* If a synchronized write cache is the source of the data. */\n  struct st_io_cache    *source_cache;\n  uchar                 *buffer;         /* The read buffer. */\n  uchar                 *read_end;       /* Behind last valid byte of buffer. */\n  int                   running_threads; /* threads not in lock. */\n  int                   total_threads;   /* threads sharing the cache. */\n  int                   error;           /* Last error. */\n#ifdef NOT_YET_IMPLEMENTED\n  /* whether the structure should be free'd */\n  my_bool alloced;\n#endif\n} IO_CACHE_SHARE;\n\ntypedef struct st_io_cache\t\t/* Used when cacheing files */\n{\n  /* Offset in file corresponding to the first byte of uchar* buffer. */\n  my_off_t pos_in_file;\n  /*\n    The offset of end of file for READ_CACHE and WRITE_CACHE.\n    For SEQ_READ_APPEND it the maximum of the actual end of file and\n    the position represented by read_end.\n  */\n  my_off_t end_of_file;\n  /* Points to current read position in the buffer */\n  uchar\t*read_pos;\n  /* the non-inclusive boundary in the buffer for the currently valid read */\n  uchar  *read_end;\n  uchar  *buffer;\t\t\t\t/* The read buffer */\n  /* Used in ASYNC_IO */\n  uchar  *request_pos;\n\n  /* Only used in WRITE caches and in SEQ_READ_APPEND to buffer writes */\n  uchar  *write_buffer;\n  /*\n    Only used in SEQ_READ_APPEND, and points to the current read position\n    in the write buffer. Note that reads in SEQ_READ_APPEND caches can\n    happen from both read buffer (uchar* buffer) and write buffer\n    (uchar* write_buffer).\n  */\n  uchar *append_read_pos;\n  /* Points to current write position in the write buffer */\n  uchar *write_pos;\n  /* The non-inclusive boundary of the valid write area */\n  uchar *write_end;\n\n  /*\n    Current_pos and current_end are convenience variables used by\n    my_b_tell() and other routines that need to know the current offset\n    current_pos points to &write_pos, and current_end to &write_end in a\n    WRITE_CACHE, and &read_pos and &read_end respectively otherwise\n  */\n  uchar  **current_pos, **current_end;\n\n  /*\n    The lock is for append buffer used in SEQ_READ_APPEND cache\n    need mutex copying from append buffer to read buffer.\n  */\n  mysql_mutex_t append_buffer_lock;\n  /*\n    The following is used when several threads are reading the\n    same file in parallel. They are synchronized on disk\n    accesses reading the cached part of the file asynchronously.\n    It should be set to NULL to disable the feature.  Only\n    READ_CACHE mode is supported.\n  */\n  IO_CACHE_SHARE *share;\n\n  /*\n    A caller will use my_b_read() macro to read from the cache\n    if the data is already in cache, it will be simply copied with\n    memcpy() and internal variables will be accordinging updated with\n    no functions invoked. However, if the data is not fully in the cache,\n    my_b_read() will call read_function to fetch the data. read_function\n    must never be invoked directly.\n  */\n  int (*read_function)(struct st_io_cache *,uchar *,size_t);\n  /*\n    Same idea as in the case of read_function, except my_b_write() needs to\n    be replaced with my_b_append() for a SEQ_READ_APPEND cache\n  */\n  int (*write_function)(struct st_io_cache *,const uchar *,size_t);\n  /*\n    Specifies the type of the cache. Depending on the type of the cache\n    certain operations might not be available and yield unpredicatable\n    results. Details to be documented later\n  */\n  enum cache_type type;\n  /*\n    Callbacks when the actual read I/O happens. These were added and\n    are currently used for binary logging of LOAD DATA INFILE - when a\n    block is read from the file, we create a block create/append event, and\n    when IO_CACHE is closed, we create an end event. These functions could,\n    of course be used for other things\n  */\n  IO_CACHE_CALLBACK pre_read;\n  IO_CACHE_CALLBACK post_read;\n  IO_CACHE_CALLBACK pre_close;\n  /*\n    Counts the number of times, when we were forced to use disk. We use it to\n    increase the binlog_cache_disk_use and binlog_stmt_cache_disk_use status\n    variables.\n  */\n  ulong disk_writes;\n  void* arg;\t\t\t\t/* for use by pre/post_read */\n  char *file_name;\t\t\t/* if used with 'open_cached_file' */\n  char *dir,*prefix;\n  File file; /* file descriptor */\n  /*\n    seek_not_done is set by my_b_seek() to inform the upcoming read/write\n    operation that a seek needs to be preformed prior to the actual I/O\n    error is 0 if the cache operation was successful, -1 if there was a\n    \"hard\" error, and the actual number of I/O-ed bytes if the read/write was\n    partial.\n  */\n  int\tseek_not_done,error;\n  /* buffer_length is memory size allocated for buffer or write_buffer */\n  size_t\tbuffer_length;\n  /* read_length is the same as buffer_length except when we use async io */\n  size_t  read_length;\n  myf\tmyflags;\t\t\t/* Flags used to my_read/my_write */\n  /*\n    alloced_buffer is 1 if the buffer was allocated by init_io_cache() and\n    0 if it was supplied by the user.\n    Currently READ_NET is the only one that will use a buffer allocated\n    somewhere else\n  */\n  my_bool alloced_buffer;\n#ifdef HAVE_AIOWAIT\n  /*\n    As inidicated by ifdef, this is for async I/O, which is not currently\n    used (because it's not reliable on all systems)\n  */\n  uint inited;\n  my_off_t aio_read_pos;\n  my_aio_result aio_result;\n#endif\n} IO_CACHE;\n\ntypedef int (*qsort2_cmp)(const void *, const void *, const void *);\n\n\t/* defines for mf_iocache */\n\n\t/* Test if buffer is inited */\n#define my_b_clear(info) (info)->buffer=0\n#define my_b_inited(info) (info)->buffer\n#define my_b_EOF INT_MIN\n\n#define my_b_read(info,Buffer,Count) \\\n  ((info)->read_pos + (Count) <= (info)->read_end ?\\\n   (memcpy(Buffer,(info)->read_pos,(size_t) (Count)), \\\n    ((info)->read_pos+=(Count)),0) :\\\n   (*(info)->read_function)((info),Buffer,Count))\n\n#define my_b_write(info,Buffer,Count) \\\n ((info)->write_pos + (Count) <=(info)->write_end ?\\\n  (memcpy((info)->write_pos, (Buffer), (size_t)(Count)),\\\n   ((info)->write_pos+=(Count)),0) : \\\n   (*(info)->write_function)((info),(uchar *)(Buffer),(Count)))\n\n#define my_b_get(info) \\\n  ((info)->read_pos != (info)->read_end ?\\\n   ((info)->read_pos++, (int) (uchar) (info)->read_pos[-1]) :\\\n   _my_b_get(info))\n\n\t/* my_b_write_byte dosn't have any err-check */\n#define my_b_write_byte(info,chr) \\\n  (((info)->write_pos < (info)->write_end) ?\\\n   ((*(info)->write_pos++)=(chr)) :\\\n   (_my_b_write(info,0,0) , ((*(info)->write_pos++)=(chr))))\n\n#define my_b_fill_cache(info) \\\n  (((info)->read_end=(info)->read_pos),(*(info)->read_function)(info,0,0))\n\n#define my_b_tell(info) ((info)->pos_in_file + \\\n\t\t\t (size_t) (*(info)->current_pos - (info)->request_pos))\n#define my_b_write_tell(info) ((info)->pos_in_file + \\\n\t\t\t ((info)->write_pos - (info)->write_buffer))\n\n#define my_b_get_buffer_start(info) (info)->request_pos \n#define my_b_get_bytes_in_buffer(info) (char*) (info)->read_end -   \\\n  (char*) my_b_get_buffer_start(info)\n#define my_b_get_pos_in_file(info) (info)->pos_in_file\n\n/* tell write offset in the SEQ_APPEND cache */\nint      my_b_copy_to_file(IO_CACHE *cache, FILE *file);\nmy_off_t my_b_append_tell(IO_CACHE* info);\nmy_off_t my_b_safe_tell(IO_CACHE* info); /* picks the correct tell() */\n\n#define my_b_bytes_in_cache(info) (size_t) (*(info)->current_end - \\\n\t\t\t\t\t  *(info)->current_pos)\n\ntypedef uint32 ha_checksum;\nextern ulong my_crc_dbug_check;\n\n/* Define the type of function to be passed to process_default_option_files */\ntypedef int (*Process_option_func)(void *ctx, const char *group_name,\n                                   const char *option);\n\n#include <my_alloc.h>\n\n\n\t/* Prototypes for mysys and my_func functions */\n\nextern int my_copy(const char *from,const char *to,myf MyFlags);\nextern int my_delete(const char *name,myf MyFlags);\nextern int my_getwd(char * buf,size_t size,myf MyFlags);\nextern int my_setwd(const char *dir,myf MyFlags);\nextern int my_lock(File fd,int op,my_off_t start, my_off_t length,myf MyFlags);\nextern void *my_once_alloc(size_t Size,myf MyFlags);\nextern void my_once_free(void);\nextern char *my_once_strdup(const char *src,myf myflags);\nextern void *my_once_memdup(const void *src, size_t len, myf myflags);\nextern File my_open(const char *FileName,int Flags,myf MyFlags);\nextern File my_register_filename(File fd, const char *FileName,\n\t\t\t\t enum file_type type_of_file,\n\t\t\t\t uint error_message_number, myf MyFlags);\nextern File my_create(const char *FileName,int CreateFlags,\n\t\t      int AccessFlags, myf MyFlags);\nextern int my_close(File Filedes,myf MyFlags);\nextern int my_mkdir(const char *dir, int Flags, myf MyFlags);\nextern int my_readlink(char *to, const char *filename, myf MyFlags);\nextern int my_is_symlink(const char *filename);\nextern int my_realpath(char *to, const char *filename, myf MyFlags);\nextern File my_create_with_symlink(const char *linkname, const char *filename,\n\t\t\t\t   int createflags, int access_flags,\n\t\t\t\t   myf MyFlags);\nextern int my_delete_with_symlink(const char *name, myf MyFlags);\nextern int my_rename_with_symlink(const char *from,const char *to,myf MyFlags);\nextern int my_symlink(const char *content, const char *linkname, myf MyFlags);\nextern size_t my_read(File Filedes,uchar *Buffer,size_t Count,myf MyFlags);\nextern size_t my_pread(File Filedes,uchar *Buffer,size_t Count,my_off_t offset,\n\t\t     myf MyFlags);\nextern int my_rename(const char *from,const char *to,myf MyFlags);\nextern my_off_t my_seek(File fd,my_off_t pos,int whence,myf MyFlags);\nextern my_off_t my_tell(File fd,myf MyFlags);\nextern size_t my_write(File Filedes,const uchar *Buffer,size_t Count,\n\t\t     myf MyFlags);\nextern size_t my_pwrite(File Filedes,const uchar *Buffer,size_t Count,\n\t\t      my_off_t offset,myf MyFlags);\nextern size_t my_fread(FILE *stream,uchar *Buffer,size_t Count,myf MyFlags);\nextern size_t my_fwrite(FILE *stream,const uchar *Buffer,size_t Count,\n\t\t      myf MyFlags);\nextern my_off_t my_fseek(FILE *stream,my_off_t pos,int whence,myf MyFlags);\nextern my_off_t my_ftell(FILE *stream,myf MyFlags);\n\n/* implemented in my_memmem.c */\nextern void *my_memmem(const void *haystack, size_t haystacklen,\n                       const void *needle, size_t needlelen);\n\n\n#ifdef _WIN32\nextern int      my_access(const char *path, int amode);\n#else\n#define my_access access\n#endif\n\nextern int check_if_legal_filename(const char *path);\nextern int check_if_legal_tablename(const char *path);\n\n#ifdef _WIN32\n/* Windows-only functions (CRT equivalents)*/\nextern HANDLE   my_get_osfhandle(File fd);\nextern void     my_osmaperr(unsigned long last_error);\n#endif\n\nextern void init_glob_errs(void);\nextern const char** get_global_errmsgs();\nextern void wait_for_free_space(const char *filename, int errors);\nextern FILE *my_fopen(const char *FileName,int Flags,myf MyFlags);\nextern FILE *my_fdopen(File Filedes,const char *name, int Flags,myf MyFlags);\nextern FILE *my_freopen(const char *path, const char *mode, FILE *stream);\nextern int my_fclose(FILE *fd,myf MyFlags);\nextern int my_vfprintf(FILE *stream, const char* format, va_list args);\nextern int my_fprintf(FILE *stream, const char* format, ...);\nextern File my_fileno(FILE *fd);\nextern int my_chsize(File fd,my_off_t newlength, int filler, myf MyFlags);\nextern int my_chmod(const char *name, mode_t mode, myf my_flags);\nextern const char *my_basename(const char *filename);\nextern void thr_set_sync_wait_callback(void (*before_sync)(void),\n                                       void (*after_sync)(void));\nextern int my_sync(File fd, myf my_flags);\nextern int my_sync_dir(const char *dir_name, myf my_flags);\nextern int my_sync_dir_by_file(const char *file_name, myf my_flags);\nextern void my_error(int nr,myf MyFlags, ...);\nextern void my_printf_error(uint my_err, const char *format,\n                            myf MyFlags, ...)\n                            ATTRIBUTE_FORMAT(printf, 2, 4);\nextern void my_printv_error(uint error, const char *format, myf MyFlags,\n                            va_list ap);\nextern int my_error_register(const char** (*get_errmsgs) (),\n                             int first, int last);\nextern const char **my_error_unregister(int first, int last);\nextern void my_message(uint my_err, const char *str,myf MyFlags);\nextern void my_message_stderr(uint my_err, const char *str, myf MyFlags);\nextern my_bool my_init(void);\nextern void my_end(int infoflag);\nextern int my_redel(const char *from, const char *to, time_t backup_time_stamp,\n                    myf MyFlags);\nvoid my_create_backup_name(char *to, const char *from,\n                           time_t backup_time_stamp);\nextern int my_copystat(const char *from, const char *to, int MyFlags);\nextern char * my_filename(File fd);\n\n#ifdef EXTRA_DEBUG\nvoid my_print_open_files(void);\n#else\n#define my_print_open_files()\n#endif\n\nextern my_bool init_tmpdir(MY_TMPDIR *tmpdir, const char *pathlist);\nextern char *my_tmpdir(MY_TMPDIR *tmpdir);\nextern void free_tmpdir(MY_TMPDIR *tmpdir);\n\nextern void my_remember_signal(int signal_number,sig_handler (*func)(int));\nextern size_t dirname_part(char * to,const char *name, size_t *to_res_length);\nextern size_t dirname_length(const char *name);\n#define base_name(A) (A+dirname_length(A))\nextern int test_if_hard_path(const char *dir_name);\nextern my_bool has_path(const char *name);\nextern char *convert_dirname(char *to, const char *from, const char *from_end);\nextern void to_unix_path(char * name);\nextern char * fn_ext(const char *name);\nextern char * fn_ext2(const char *name);\nextern char * fn_same(char * toname,const char *name,int flag);\nextern char * fn_format(char * to,const char *name,const char *dir,\n\t\t\t   const char *form, uint flag);\nextern size_t strlength(const char *str);\nextern void pack_dirname(char * to,const char *from);\nextern size_t normalize_dirname(char * to, const char *from);\nextern size_t unpack_dirname(char * to,const char *from);\nextern size_t cleanup_dirname(char * to,const char *from);\nextern size_t system_filename(char * to,const char *from);\nextern size_t unpack_filename(char * to,const char *from);\nextern char * intern_filename(char * to,const char *from);\nextern char * directory_file_name(char * dst, const char *src);\nextern int pack_filename(char * to, const char *name, size_t max_length);\nextern char * my_path(char * to,const char *progname,\n\t\t\t const char *own_pathname_part);\nextern char * my_load_path(char * to, const char *path,\n\t\t\t      const char *own_path_prefix);\nextern int wild_compare(const char *str,const char *wildstr,\n                        pbool str_is_pattern);\nextern my_bool array_append_string_unique(const char *str,\n                                          const char **array, size_t size);\nextern void get_date(char * to,int timeflag,time_t use_time);\nextern void soundex(CHARSET_INFO *, char * out_pntr, char * in_pntr,\n                    pbool remove_garbage);\nextern int init_record_cache(RECORD_CACHE *info,size_t cachesize,File file,\n\t\t\t     size_t reclength,enum cache_type type,\n\t\t\t     pbool use_async_io);\nextern int read_cache_record(RECORD_CACHE *info,uchar *to);\nextern int end_record_cache(RECORD_CACHE *info);\nextern int write_cache_record(RECORD_CACHE *info,my_off_t filepos,\n\t\t\t      const uchar *record,size_t length);\nextern int flush_write_cache(RECORD_CACHE *info);\nextern void handle_recived_signals(void);\n\nextern sig_handler my_set_alarm_variable(int signo);\nextern void my_string_ptr_sort(uchar *base,uint items,size_t size);\nextern void radixsort_for_str_ptr(uchar* base[], uint number_of_elements,\n\t\t\t\t  size_t size_of_element,uchar *buffer[]);\nextern qsort_t my_qsort(void *base_ptr, size_t total_elems, size_t size,\n                        qsort_cmp cmp);\nextern qsort_t my_qsort2(void *base_ptr, size_t total_elems, size_t size,\n                         qsort2_cmp cmp, void *cmp_argument);\nextern qsort2_cmp get_ptr_compare(size_t);\nvoid my_store_ptr(uchar *buff, size_t pack_length, my_off_t pos);\nmy_off_t my_get_ptr(uchar *ptr, size_t pack_length);\nextern int init_io_cache(IO_CACHE *info,File file,size_t cachesize,\n\t\t\t enum cache_type type,my_off_t seek_offset,\n\t\t\t pbool use_async_io, myf cache_myflags);\nextern my_bool reinit_io_cache(IO_CACHE *info,enum cache_type type,\n\t\t\t       my_off_t seek_offset,pbool use_async_io,\n\t\t\t       pbool clear_cache);\nextern void setup_io_cache(IO_CACHE* info);\nextern int _my_b_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_read_r(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern void init_io_cache_share(IO_CACHE *read_cache, IO_CACHE_SHARE *cshare,\n                                IO_CACHE *write_cache, uint num_threads);\nextern void remove_io_thread(IO_CACHE *info);\nextern int _my_b_seq_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_net_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_get(IO_CACHE *info);\nextern int _my_b_async_read(IO_CACHE *info,uchar *Buffer,size_t Count);\nextern int _my_b_write(IO_CACHE *info,const uchar *Buffer,size_t Count);\nextern int my_b_append(IO_CACHE *info,const uchar *Buffer,size_t Count);\nextern int my_b_safe_write(IO_CACHE *info,const uchar *Buffer,size_t Count);\n\nextern int my_block_write(IO_CACHE *info, const uchar *Buffer,\n\t\t\t  size_t Count, my_off_t pos);\nextern int my_b_flush_io_cache(IO_CACHE *info, int need_append_buffer_lock);\n\n#define flush_io_cache(info) my_b_flush_io_cache((info),1)\n\nextern int end_io_cache(IO_CACHE *info);\nextern size_t my_b_fill(IO_CACHE *info);\nextern void my_b_seek(IO_CACHE *info,my_off_t pos);\nextern size_t my_b_gets(IO_CACHE *info, char *to, size_t max_length);\nextern my_off_t my_b_filelength(IO_CACHE *info);\nextern size_t my_b_write_backtick_quote(IO_CACHE *info, const char *str,\n                                        size_t len);\nextern size_t my_b_printf(IO_CACHE *info, const char* fmt, ...);\nextern size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list ap);\nextern my_bool open_cached_file(IO_CACHE *cache,const char *dir,\n\t\t\t\t const char *prefix, size_t cache_size,\n\t\t\t\t myf cache_myflags);\nextern my_bool real_open_cached_file(IO_CACHE *cache);\nextern void close_cached_file(IO_CACHE *cache);\nFile create_temp_file(char *to, const char *dir, const char *pfx,\n\t\t      int mode, myf MyFlags);\n#define my_init_dynamic_array(A,B,C,D) init_dynamic_array2(A,B,NULL,C,D)\n#define my_init_dynamic_array_ci(A,B,C,D) init_dynamic_array2(A,B,NULL,C,D)\n#define my_init_dynamic_array2(A,B,C,D,E) init_dynamic_array2(A,B,C,D,E)\n#define my_init_dynamic_array2_ci(A,B,C,D,E) init_dynamic_array2(A,B,C,D,E)\nextern my_bool init_dynamic_array2(DYNAMIC_ARRAY *array, uint element_size,\n                                   void *init_buffer, uint init_alloc,\n                                   uint alloc_increment);\n/* init_dynamic_array() function is deprecated */\nextern my_bool init_dynamic_array(DYNAMIC_ARRAY *array, uint element_size,\n                                  uint init_alloc, uint alloc_increment);\nextern my_bool insert_dynamic(DYNAMIC_ARRAY *array, const uchar * element);\nextern uchar *alloc_dynamic(DYNAMIC_ARRAY *array);\nextern uchar *pop_dynamic(DYNAMIC_ARRAY*);\nextern my_bool set_dynamic(DYNAMIC_ARRAY *array,uchar * element,uint array_index);\nextern my_bool allocate_dynamic(DYNAMIC_ARRAY *array, uint max_elements);\nextern void get_dynamic(DYNAMIC_ARRAY *array,uchar * element,uint array_index);\nextern void delete_dynamic(DYNAMIC_ARRAY *array);\nextern void delete_dynamic_element(DYNAMIC_ARRAY *array, uint array_index);\nextern void freeze_size(DYNAMIC_ARRAY *array);\nextern int  get_index_dynamic(DYNAMIC_ARRAY *array, uchar * element);\n#define dynamic_array_ptr(array,array_index) ((array)->buffer+(array_index)*(array)->size_of_element)\n#define dynamic_element(array,array_index,type) ((type)((array)->buffer) +(array_index))\n#define push_dynamic(A,B) insert_dynamic((A),(B))\n#define reset_dynamic(array) ((array)->elements= 0)\n#define sort_dynamic(A,cmp) my_qsort((A)->buffer, (A)->elements, (A)->size_of_element, (cmp))\n\nextern my_bool init_dynamic_string(DYNAMIC_STRING *str, const char *init_str,\n\t\t\t\t   size_t init_alloc,size_t alloc_increment);\nextern my_bool dynstr_append(DYNAMIC_STRING *str, const char *append);\nmy_bool dynstr_append_mem(DYNAMIC_STRING *str, const char *append,\n\t\t\t  size_t length);\nextern my_bool dynstr_append_os_quoted(DYNAMIC_STRING *str, const char *append,\n                                       ...);\nextern my_bool dynstr_set(DYNAMIC_STRING *str, const char *init_str);\nextern my_bool dynstr_realloc(DYNAMIC_STRING *str, size_t additional_size);\nextern my_bool dynstr_trunc(DYNAMIC_STRING *str, size_t n);\nextern void dynstr_free(DYNAMIC_STRING *str);\nextern void dynstr_reassociate(DYNAMIC_STRING *str, char **res, size_t *length,\n                               size_t *alloc_length);\n#ifdef HAVE_MLOCK\nextern void *my_malloc_lock(size_t length,myf flags);\nextern void my_free_lock(void *ptr);\n#else\n#define my_malloc_lock(A,B) my_malloc((A),(B))\n#define my_free_lock(A) my_free((A))\n#endif\n#define alloc_root_inited(A) ((A)->min_malloc != 0)\n#define ALLOC_ROOT_MIN_BLOCK_SIZE (MALLOC_OVERHEAD + sizeof(USED_MEM) + 8)\n#define clear_alloc_root(A) do { (A)->free= (A)->used= (A)->pre_alloc= 0; (A)->min_malloc=0;} while(0)\nextern void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,\n\t\t\t    size_t pre_alloc_size);\nextern void *alloc_root(MEM_ROOT *mem_root, size_t Size);\nextern void *multi_alloc_root(MEM_ROOT *mem_root, ...);\nextern void free_root(MEM_ROOT *root, myf MyFLAGS);\nextern void set_prealloc_root(MEM_ROOT *root, char *ptr);\nextern void reset_root_defaults(MEM_ROOT *mem_root, size_t block_size,\n                                size_t prealloc_size);\nextern char *strdup_root(MEM_ROOT *root,const char *str);\nstatic inline char *safe_strdup_root(MEM_ROOT *root, const char *str)\n{\n  return str ? strdup_root(root, str) : 0;\n}\nextern char *strmake_root(MEM_ROOT *root,const char *str,size_t len);\nextern void *memdup_root(MEM_ROOT *root,const void *str, size_t len);\nextern int get_defaults_options(int argc, char **argv,\n                                char **defaults, char **extra_defaults,\n                                char **group_suffix);\nextern my_bool my_getopt_use_args_separator;\nextern my_bool my_getopt_is_args_separator(const char* arg);\nextern int my_load_defaults(const char *conf_file, const char **groups,\n                            int *argc, char ***argv, const char ***);\nextern int load_defaults(const char *conf_file, const char **groups,\n                         int *argc, char ***argv);\nextern int my_search_option_files(const char *conf_file, int *argc,\n                                  char ***argv, uint *args_used,\n                                  Process_option_func func, void *func_ctx,\n                                  const char **default_directories);\nextern void free_defaults(char **argv);\nextern void my_print_default_files(const char *conf_file);\nextern void print_defaults(const char *conf_file, const char **groups);\nextern my_bool my_compress(uchar *, size_t *, size_t *);\nextern my_bool my_uncompress(uchar *, size_t , size_t *);\nextern uchar *my_compress_alloc(const uchar *packet, size_t *len,\n                                size_t *complen);\nextern void *my_az_allocator(void *dummy, unsigned int items, unsigned int size);\nextern void my_az_free(void *dummy, void *address);\nextern int my_compress_buffer(uchar *dest, size_t *destLen,\n                              const uchar *source, size_t sourceLen);\nextern int packfrm(uchar *, size_t, uchar **, size_t *);\nextern int unpackfrm(uchar **, size_t *, const uchar *);\n\nextern ha_checksum my_checksum(ha_checksum crc, const uchar *mem,\n                               size_t count);\n#ifndef DBUG_OFF\nextern void my_debug_put_break_here(void);\n#else\n#define my_debug_put_break_here() do {} while(0)\n#endif\n\nextern void my_sleep(ulong m_seconds);\nextern ulong crc32(ulong crc, const uchar *buf, uint len);\nextern uint my_set_max_open_files(uint files);\nvoid my_free_open_file_info(void);\n\nextern my_bool my_gethwaddr(uchar *to);\nextern int my_getncpus();\n\n#define HRTIME_RESOLUTION               1000000ULL  /* microseconds */\ntypedef struct {ulonglong val;} my_hrtime_t;\nvoid my_time_init();\nextern my_hrtime_t my_hrtime();\nextern ulonglong my_interval_timer(void);\nextern ulonglong my_getcputime(void);\n\n#define microsecond_interval_timer()    (my_interval_timer()/1000)\n#define hrtime_to_time(X)               ((X).val/HRTIME_RESOLUTION)\n#define hrtime_from_time(X)             ((ulonglong)((X)*HRTIME_RESOLUTION))\n#define hrtime_to_double(X)             ((X).val/(double)HRTIME_RESOLUTION)\n#define hrtime_sec_part(X)              ((ulong)((X).val % HRTIME_RESOLUTION))\n#define my_time(X)                      hrtime_to_time(my_hrtime())\n\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n\n#ifndef MAP_NOSYNC\n#define MAP_NOSYNC      0\n#endif\n#ifndef MAP_NORESERVE\n#define MAP_NORESERVE 0         /* For irix and AIX */\n#endif\n\n#ifdef HAVE_MMAP64\n#define my_mmap(a,b,c,d,e,f)    mmap64(a,b,c,d,e,f)\n#else\n#define my_mmap(a,b,c,d,e,f)    mmap(a,b,c,d,e,f)\n#endif\n#define my_munmap(a,b)          munmap((a),(b))\n\n#else\n/* not a complete set of mmap() flags, but only those that nesessary */\n#define PROT_READ        1\n#define PROT_WRITE       2\n#define MAP_NORESERVE    0\n#define MAP_SHARED       0x0001\n#define MAP_PRIVATE      0x0002\n#define MAP_NOSYNC       0x0800\n#define MAP_FAILED       ((void *)-1)\n#define MS_SYNC          0x0000\n\n#define HAVE_MMAP\nvoid *my_mmap(void *, size_t, int, int, int, my_off_t);\nint my_munmap(void *, size_t);\n#endif\n\n/* my_getpagesize */\n#ifdef HAVE_GETPAGESIZE\n#define my_getpagesize()        getpagesize()\n#else\nint my_getpagesize(void);\n#endif\n\nint my_msync(int, void *, size_t, int);\n\n#define MY_UUID_SIZE 16\n#define MY_UUID_STRING_LENGTH (8+1+4+1+4+1+4+1+12)\n\nvoid my_uuid_init(ulong seed1, ulong seed2);\nvoid my_uuid(uchar *guid);\nvoid my_uuid2str(const uchar *guid, char *s);\nvoid my_uuid_end();\n\nstruct my_rnd_struct {\n  unsigned long seed1,seed2,max_value;\n  double max_value_dbl;\n};\n\nvoid my_rnd_init(struct my_rnd_struct *rand_st, ulong seed1, ulong seed2);\ndouble my_rnd(struct my_rnd_struct *rand_st);\n\n/* character sets */\nextern uint get_charset_number(const char *cs_name, uint cs_flags);\nextern uint get_collation_number(const char *name);\nextern const char *get_charset_name(uint cs_number);\n\nextern CHARSET_INFO *get_charset(uint cs_number, myf flags);\nextern CHARSET_INFO *get_charset_by_name(const char *cs_name, myf flags);\nextern CHARSET_INFO *get_charset_by_csname(const char *cs_name,\n\t\t\t\t\t   uint cs_flags, myf my_flags);\n\nextern my_bool resolve_charset(const char *cs_name,\n                               CHARSET_INFO *default_cs,\n                               CHARSET_INFO **cs);\nextern my_bool resolve_collation(const char *cl_name,\n                                 CHARSET_INFO *default_cl,\n                                 CHARSET_INFO **cl);\nextern void free_charsets(void);\nextern char *get_charsets_dir(char *buf);\nextern my_bool my_charset_same(CHARSET_INFO *cs1, CHARSET_INFO *cs2);\nextern my_bool init_compiled_charsets(myf flags);\nextern void add_compiled_collation(struct charset_info_st *cs);\nextern size_t escape_string_for_mysql(CHARSET_INFO *charset_info,\n                                      char *to, size_t to_length,\n                                      const char *from, size_t length);\n#ifdef __WIN__\n#define BACKSLASH_MBTAIL\n/* File system character set */\nextern CHARSET_INFO *fs_character_set(void);\n#endif\nextern size_t escape_quotes_for_mysql(CHARSET_INFO *charset_info,\n                                      char *to, size_t to_length,\n                                      const char *from, size_t length);\n\nextern void thd_increment_bytes_sent(ulong length);\nextern void thd_increment_bytes_received(ulong length);\nextern void thd_increment_net_big_packet_count(ulong length);\n\n#ifdef __WIN__\nextern my_bool have_tcpip;\t\t/* Is set if tcpip is used */\n\n/* implemented in my_windac.c */\n\nint my_security_attr_create(SECURITY_ATTRIBUTES **psa, const char **perror,\n                            DWORD owner_rights, DWORD everybody_rights);\n\nvoid my_security_attr_free(SECURITY_ATTRIBUTES *sa);\n\n/* implemented in my_conio.c */\nchar* my_cgets(char *string, size_t clen, size_t* plen);\n\n#endif\n\n#include <mysql/psi/psi.h>\n\n#ifdef HAVE_PSI_INTERFACE\nextern MYSQL_PLUGIN_IMPORT struct PSI_bootstrap *PSI_hook;\nvoid my_init_mysys_psi_keys(void);\n#endif\n\nstruct st_mysql_file;\nextern struct st_mysql_file *mysql_stdin;\n\nC_MODE_END\n#endif /* _my_sys_h */\n", "/* Copyright (c) 2000, 2010, Oracle and/or its affiliates\n   Copyright (c) 2009, 2016, MariaDB\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include \"mysys_priv.h\"\n#include \"mysys_err.h\"\n#include <my_dir.h>\n#include <m_string.h>\n#include \"mysys_err.h\"\n#if defined(HAVE_UTIME_H)\n#include <utime.h>\n#elif defined(HAVE_SYS_UTIME_H)\n#include <sys/utime.h>\n#elif !defined(HPUX10)\nstruct utimbuf {\n  time_t actime;\n  time_t modtime;\n};\n#endif\n\n\t/*\n\t  Rename with copy stat form old file\n\t  Copy stats from old file to new file, deletes orginal and\n\t  changes new file name to old file name\n\n\t  if MY_REDEL_MAKE_COPY is given, then the orginal file\n\t  is renamed to org_name-'current_time'.BAK\n\t*/\n\n#define REDEL_EXT \".BAK\"\n\nint my_redel(const char *org_name, const char *tmp_name,\n             time_t backup_time_stamp, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (!my_disable_copystat_in_redel &&\n      my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH];    \n    my_create_backup_name(name_buff, org_name, backup_time_stamp);\n    if (my_rename(org_name, name_buff, MyFlags))\n      goto end;\n  }\n  else if (my_delete(org_name, MyFlags))\n      goto end;\n  if (my_rename(tmp_name,org_name,MyFlags))\n    goto end;\n\n  error=0;\nend:\n  DBUG_RETURN(error);\n} /* my_redel */\n\n\n/**\n   Copy stat from one file to another\n   @fn     my_copystat()\n   @param  from\t\tCopy stat from this file\n   @param  to           Copy stat to this file\n   @param  MyFlags      Flags:\n\t\t        MY_WME    Give error if something goes wrong\n\t\t        MY_FAE    Abort operation if something goes wrong\n                        If MY_FAE is not given, we don't return -1 for\n                        errors from chown (which normally require root\n                        privilege)\n\n  @return  0 ok\n          -1 if can't get stat,\n           1 if wrong type of file\n*/\n\nint my_copystat(const char *from, const char *to, int MyFlags)\n{\n  MY_STAT statbuf;\n\n  if (my_stat(from, &statbuf, MyFlags) == NULL)\n    return -1;\t\t\t\t/* Can't get stat on input file */\n\n  if ((statbuf.st_mode & S_IFMT) != S_IFREG)\n    return 1;\n\n  /* Copy modes */\n  if (chmod(to, statbuf.st_mode & 07777))\n  {\n    my_errno= errno;\n    if (MyFlags & (MY_FAE+MY_WME))\n      my_error(EE_CHANGE_PERMISSIONS, MYF(ME_BELL+ME_WAITTANG), from, errno);\n    return -1;\n  }\n\n#if !defined(__WIN__)\n  if (statbuf.st_nlink > 1 && MyFlags & MY_LINK_WARNING)\n  {\n    if (MyFlags & MY_LINK_WARNING)\n      my_error(EE_LINK_WARNING,MYF(ME_BELL+ME_WAITTANG),from,statbuf.st_nlink);\n  }\n  /* Copy ownership */\n  if (chown(to, statbuf.st_uid, statbuf.st_gid))\n  {\n    my_errno= errno;\n    if (MyFlags & MY_WME)\n      my_error(EE_CHANGE_OWNERSHIP, MYF(ME_BELL+ME_WAITTANG), from, errno);\n    if (MyFlags & MY_FAE)\n      return -1;\n  }\n#endif /* !__WIN__ */\n\n  if (MyFlags & MY_COPYTIME)\n  {\n    struct utimbuf timep;\n    timep.actime  = statbuf.st_atime;\n    timep.modtime = statbuf.st_mtime;\n    (void) utime((char*) to, &timep);/* Update last accessed and modified times */\n  }\n\n  return 0;\n} /* my_copystat */\n\n\n/**\n   Create a backup file name.\n   @fn my_create_backup_name()\n   @param to\tStore new file name here\n   @param from  Original name\n\n   @info\n   The backup name is made by adding -YYMMDDHHMMSS.BAK to the file name\n*/\n\nvoid my_create_backup_name(char *to, const char *from, time_t backup_start)\n{\n  char ext[MY_BACKUP_NAME_EXTRA_LENGTH+1];\n  ext[0]='-';\n  get_date(ext+1, GETDATE_SHORT_DATE | GETDATE_HHMMSSTIME, backup_start);\n  strmov(strend(ext),REDEL_EXT);\n  strmov(strmov(to, from), ext);\n}\n", "/*\n   Copyright (c) 2000-2008 MySQL AB, 2009 Sun Microsystems, Inc.\n   Use is subject to license terms.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/*\n  Static variables for mysys library. All definied here for easy making of\n  a shared library\n*/\n\n#include \"mysys_priv.h\"\n#include \"my_static.h\"\n#include \"my_alarm.h\"\n\nmy_bool timed_mutexes= 0;\n\n\t/* from my_init */\nchar *\thome_dir=0;\nchar *mysql_data_home= (char*) \".\";\nconst char      *my_progname= NULL, *my_progname_short= NULL;\nchar\t\tcurr_dir[FN_REFLEN]= {0},\n\t\thome_dir_buff[FN_REFLEN]= {0};\nulong\t\tmy_stream_opened=0,my_file_opened=0, my_tmp_file_created=0;\nulong           my_file_total_opened= 0;\nint\t\tmy_umask=0664, my_umask_dir=0777;\n\nmyf             my_global_flags= 0;\nmy_bool         my_assert_on_error= 0;\nstruct st_my_file_info my_file_info_default[MY_NFILE];\nuint   my_file_limit= MY_NFILE;\nstruct st_my_file_info *my_file_info= my_file_info_default;\n\n\t/* From mf_brkhant */\nint\t\t\tmy_dont_interrupt=0;\nvolatile int\t\t_my_signals=0;\nstruct st_remember _my_sig_remember[MAX_SIGNALS]={{0,0}};\n\n\t/* from mf_reccache.c */\nulong my_default_record_cache_size=RECORD_CACHE_SIZE;\n\n\t/* from soundex.c */\n\t\t\t\t/* ABCDEFGHIJKLMNOPQRSTUVWXYZ */\n\t\t\t\t/* :::::::::::::::::::::::::: */\nconst char *soundex_map=\t  \"01230120022455012623010202\";\n\n\t/* from my_malloc */\nUSED_MEM* my_once_root_block=0;\t\t\t/* pointer to first block */\nuint\t  my_once_extra=ONCE_ALLOC_INIT;\t/* Memory to alloc / block */\n\n\t/* from my_largepage.c */\n#ifdef HAVE_LARGE_PAGES\nmy_bool my_use_large_pages= 0;\nuint    my_large_page_size= 0;\n#endif\n\n\t/* from my_alarm */\nint volatile my_have_got_alarm=0;\t/* declare variable to reset */\nulong my_time_to_wait_for_lock=2;\t/* In seconds */\n\n\t/* from errors.c */\n#ifdef SHARED_LIBRARY\nconst char *globerrs[GLOBERRS];\t\t/* my_error_messages is here */\n#endif\nvoid (*my_abort_hook)(int) = (void(*)(int)) exit;\nvoid (*error_handler_hook)(uint error, const char *str, myf MyFlags)=\n  my_message_stderr;\nvoid (*fatal_error_handler_hook)(uint error, const char *str, myf MyFlags)=\n  my_message_stderr;\n\nstatic const char *proc_info_dummy(void *a __attribute__((unused)),\n                                   const char *b __attribute__((unused)),\n                                   const char *c __attribute__((unused)),\n                                   const char *d __attribute__((unused)),\n                                   const unsigned int e __attribute__((unused)))\n{\n  return 0;\n}\n\n/* this is to be able to call set_thd_proc_info from the C code */\nconst char *(*proc_info_hook)(void *, const char *, const char *, const char *,\n                              const unsigned int)= proc_info_dummy;\nvoid (*debug_sync_C_callback_ptr)(MYSQL_THD, const char *, size_t)= 0;\n\n\t/* How to disable options */\nmy_bool my_disable_locking=0;\nmy_bool my_disable_sync=0;\nmy_bool my_disable_async_io=0;\nmy_bool my_disable_flush_key_blocks=0;\nmy_bool my_disable_symlinks=0;\nmy_bool my_disable_copystat_in_redel=0;\n\n/*\n  Note that PSI_hook and PSI_server are unconditionally\n  (no ifdef HAVE_PSI_INTERFACE) defined.\n  This is to ensure binary compatibility between the server and plugins,\n  in the case when:\n  - the server is not compiled with HAVE_PSI_INTERFACE\n  - a plugin is compiled with HAVE_PSI_INTERFACE\n  See the doxygen documentation for the performance schema.\n*/\n\n/**\n  Hook for the instrumentation interface.\n  Code implementing the instrumentation interface should register here.\n*/\nstruct PSI_bootstrap *PSI_hook= NULL;\n\n/**\n  Instance of the instrumentation interface for the MySQL server.\n  @todo This is currently a global variable, which is handy when\n  compiling instrumented code that is bundled with the server.\n  When dynamic plugin are truly supported, this variable will need\n  to be replaced by a macro, so that each XYZ plugin can have it's own\n  xyz_psi_server variable, obtained from PSI_bootstrap::get_interface()\n  with the version used at compile time for plugin XYZ.\n*/\nPSI *PSI_server= NULL;\n\n", "/* Copyright (c) 2000, 2015, Oracle and/or its affiliates.\n   Copyright (c) 2008, 2015, SkySQL Ab.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n#include \"my_global.h\"                          /* NO_EMBEDDED_ACCESS_CHECKS */\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include <signal.h>\n#ifndef __WIN__\n#include <netdb.h>        // getservbyname, servent\n#endif\n#include \"sql_parse.h\"    // test_if_data_home_dir\n#include \"sql_cache.h\"    // query_cache, query_cache_*\n#include \"sql_locale.h\"   // MY_LOCALES, my_locales, my_locale_by_name\n#include \"sql_show.h\"     // free_status_vars, add_status_vars,\n                          // reset_status_vars\n#include \"strfunc.h\"      // find_set_from_flags\n#include \"parse_file.h\"   // File_parser_dummy_hook\n#include \"sql_db.h\"       // my_dboptions_cache_free\n                          // my_dboptions_cache_init\n#include \"sql_table.h\"    // release_ddl_log, execute_ddl_log_recovery\n#include \"sql_connect.h\"  // free_max_user_conn, init_max_user_conn,\n                          // handle_one_connection\n#include \"sql_time.h\"     // known_date_time_formats,\n                          // get_date_time_format_str,\n                          // date_time_format_make\n#include \"tztime.h\"       // my_tz_free, my_tz_init, my_tz_SYSTEM\n#include \"hostname.h\"     // hostname_cache_free, hostname_cache_init\n#include \"sql_acl.h\"      // acl_free, grant_free, acl_init,\n                          // grant_init\n#include \"sql_base.h\"     // table_def_free, table_def_init,\n                          // cached_open_tables,\n                          // cached_table_definitions\n#include \"sql_test.h\"     // mysql_print_status\n#include \"item_create.h\"  // item_create_cleanup, item_create_init\n#include \"sql_servers.h\"  // servers_free, servers_init\n#include \"init.h\"         // unireg_init\n#include \"derror.h\"       // init_errmessage\n#include \"derror.h\"       // init_errmessage\n#include \"des_key_file.h\" // load_des_key_file\n#include \"sql_manager.h\"  // stop_handle_manager, start_handle_manager\n#include \"sql_expression_cache.h\" // subquery_cache_miss, subquery_cache_hit\n\n#include <m_ctype.h>\n#include <my_dir.h>\n#include <my_bit.h>\n#include \"slave.h\"\n#include \"rpl_mi.h\"\n#include \"sql_repl.h\"\n#include \"rpl_filter.h\"\n#include \"client_settings.h\"\n#include \"repl_failsafe.h\"\n#include <sql_common.h>\n#include <my_stacktrace.h>\n#include \"mysqld_suffix.h\"\n#include \"mysys_err.h\"\n#include \"events.h\"\n#include \"sql_audit.h\"\n#include \"probes_mysql.h\"\n#include \"scheduler.h\"\n#include <waiting_threads.h>\n#include \"debug_sync.h\"\n#include \"sql_callback.h\"\n#include \"threadpool.h\"\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#include \"keycaches.h\"\n#include \"../storage/myisam/ha_myisam.h\"\n#include \"set_var.h\"\n\n#include \"rpl_injector.h\"\n\n#include \"rpl_handler.h\"\n\n#ifdef HAVE_SYS_PRCTL_H\n#include <sys/prctl.h>\n#endif\n\n#include <thr_alarm.h>\n#include <ft_global.h>\n#include <errmsg.h>\n#include \"sp_rcontext.h\"\n#include \"sp_cache.h\"\n#include \"sql_reload.h\"  // reload_acl_and_cache\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n\n#define mysqld_charset &my_charset_latin1\n\n/* We have HAVE_valgrind below as this speeds up the shutdown of MySQL */\n\n#if defined(SIGNALS_DONT_BREAK_READ) || defined(HAVE_valgrind) && defined(__linux__)\n#define HAVE_CLOSE_SERVER_SOCK 1\n#endif\n\nextern \"C\" {\t\t\t\t\t// Because of SCO 3.2V4.2\n#include <errno.h>\n#include <sys/stat.h>\n#ifndef __GNU_LIBRARY__\n#define __GNU_LIBRARY__\t\t\t\t// Skip warnings in getopt.h\n#endif\n#include <my_getopt.h>\n#ifdef HAVE_SYSENT_H\n#include <sysent.h>\n#endif\n#ifdef HAVE_PWD_H\n#include <pwd.h>\t\t\t\t// For getpwent\n#endif\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#include <my_net.h>\n\n#if !defined(__WIN__)\n#include <sys/resource.h>\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n#ifdef HAVE_SELECT_H\n#include <select.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <sys/utsname.h>\n#endif /* __WIN__ */\n\n#include <my_libwrap.h>\n\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n\n#ifdef __WIN__ \n#include <crtdbg.h>\n#endif\n\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#include <sys/mman.h>\n#if defined(__sun__) && defined(__GNUC__) && defined(__cplusplus) \\\n    && defined(_XOPEN_SOURCE)\nextern int getpagesizes(size_t *, int);\nextern int getpagesizes2(size_t *, int);\nextern int memcntl(caddr_t, size_t, int, caddr_t, int, int);\n#endif /* __sun__ ... */\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n#ifdef _AIX41\nint initgroups(const char *,unsigned int);\n#endif\n\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n#include <ieeefp.h>\n#ifdef HAVE_FP_EXCEPT\t\t\t\t// Fix type conflict\ntypedef fp_except fp_except_t;\n#endif\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n#ifdef HAVE_SYS_FPU_H\n/* for IRIX to use set_fpc_csr() */\n#include <sys/fpu.h>\n#endif\n#ifdef HAVE_FPU_CONTROL_H\n#include <fpu_control.h>\n#endif\n#if defined(__i386__) && !defined(HAVE_FPU_CONTROL_H)\n# define fpu_control_t unsigned int\n# define _FPU_EXTENDED 0x300\n# define _FPU_DOUBLE 0x200\n# if defined(__GNUC__) || (defined(__SUNPRO_CC) && __SUNPRO_CC >= 0x590)\n#  define _FPU_GETCW(cw) asm volatile (\"fnstcw %0\" : \"=m\" (*&cw))\n#  define _FPU_SETCW(cw) asm volatile (\"fldcw %0\" : : \"m\" (*&cw))\n# else\n#  define _FPU_GETCW(cw) (cw= 0)\n#  define _FPU_SETCW(cw)\n# endif\n#endif\n\n#ifndef HAVE_FCNTL\n#define fcntl(X,Y,Z) 0\n#endif\n\nextern \"C\" my_bool reopen_fstreams(const char *filename,\n                                   FILE *outstream, FILE *errstream);\n\ninline void setup_fpu()\n{\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n  /* We can't handle floating point exceptions with threads, so disable\n     this on freebsd\n     Don't fall for overflow, underflow,divide-by-zero or loss of precision.\n     fpsetmask() is deprecated in favor of fedisableexcept() in C99.\n  */\n#if defined(FP_X_DNML)\n  fpsetmask(~(FP_X_INV | FP_X_DNML | FP_X_OFL | FP_X_UFL | FP_X_DZ |\n\t      FP_X_IMP));\n#else\n  fpsetmask(~(FP_X_INV |             FP_X_OFL | FP_X_UFL | FP_X_DZ |\n              FP_X_IMP));\n#endif /* FP_X_DNML */\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n\n#ifdef HAVE_FEDISABLEEXCEPT\n  fedisableexcept(FE_ALL_EXCEPT);\n#endif\n\n#ifdef HAVE_FESETROUND\n    /* Set FPU rounding mode to \"round-to-nearest\" */\n  fesetround(FE_TONEAREST);\n#endif /* HAVE_FESETROUND */\n\n  /*\n    x86 (32-bit) requires FPU precision to be explicitly set to 64 bit\n    (double precision) for portable results of floating point operations.\n    However, there is no need to do so if compiler is using SSE2 for floating\n    point, double values will be stored and processed in 64 bits anyway.\n  */\n#if defined(__i386__) && !defined(__SSE2_MATH__)\n#if defined(_WIN32)\n#if !defined(_WIN64)\n  _control87(_PC_53, MCW_PC);\n#endif /* !_WIN64 */\n#else /* !_WIN32 */\n  fpu_control_t cw;\n  _FPU_GETCW(cw);\n  cw= (cw & ~_FPU_EXTENDED) | _FPU_DOUBLE;\n  _FPU_SETCW(cw);\n#endif /* _WIN32 && */\n#endif /* __i386__ */\n\n#if defined(__sgi) && defined(HAVE_SYS_FPU_H)\n  /* Enable denormalized DOUBLE values support for IRIX */\n  union fpc_csr n;\n  n.fc_word = get_fpc_csr();\n  n.fc_struct.flush = 0;\n  set_fpc_csr(n.fc_word);\n#endif\n}\n\n} /* cplusplus */\n\n#define MYSQL_KILL_SIGNAL SIGTERM\n\n#include <my_pthread.h>\t\t\t// For thr_setconcurency()\n\n#ifdef SOLARIS\nextern \"C\" int gethostname(char *name, int namelen);\n#endif\n\nextern \"C\" sig_handler handle_fatal_signal(int sig);\n\n#if defined(__linux__)\n#define ENABLE_TEMP_POOL 1\n#else\n#define ENABLE_TEMP_POOL 0\n#endif\n\n/* Constants */\n\n#include <welcome_copyright_notice.h> // ORACLE_WELCOME_COPYRIGHT_NOTICE\n\nconst char *show_comp_option_name[]= {\"YES\", \"NO\", \"DISABLED\"};\n\nstatic const char *tc_heuristic_recover_names[]=\n{\n  \"OFF\", \"COMMIT\", \"ROLLBACK\", NullS\n};\nstatic TYPELIB tc_heuristic_recover_typelib=\n{\n  array_elements(tc_heuristic_recover_names)-1,\"\",\n  tc_heuristic_recover_names, NULL\n};\n\nconst char *first_keyword= \"first\", *binary_keyword= \"BINARY\";\nconst char *my_localhost= \"localhost\", *delayed_user= \"DELAYED\";\n\nbool opt_large_files= sizeof(my_off_t) > 4;\nstatic my_bool opt_autocommit; ///< for --autocommit command-line option\n\n/*\n  Used with --help for detailed option\n*/\nstatic my_bool opt_verbose= 0;\n\narg_cmp_func Arg_comparator::comparator_matrix[6][2] =\n{{&Arg_comparator::compare_string,     &Arg_comparator::compare_e_string},\n {&Arg_comparator::compare_real,       &Arg_comparator::compare_e_real},\n {&Arg_comparator::compare_int_signed, &Arg_comparator::compare_e_int},\n {&Arg_comparator::compare_row,        &Arg_comparator::compare_e_row},\n {&Arg_comparator::compare_decimal,    &Arg_comparator::compare_e_decimal},\n {&Arg_comparator::compare_datetime,   &Arg_comparator::compare_e_datetime}};\n\n/* static variables */\n\n#ifdef HAVE_PSI_INTERFACE\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_namedpipes;\nstatic PSI_cond_key key_COND_handler_count;\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if defined(HAVE_SMEM) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_sharedmem;\n#endif /* HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_sockets;\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#ifdef __WIN__\nstatic PSI_thread_key key_thread_handle_shutdown;\n#endif /* __WIN__ */\n\n#if defined (HAVE_OPENSSL) && !defined(HAVE_YASSL)\nstatic PSI_rwlock_key key_rwlock_openssl;\n#endif\n#endif /* HAVE_PSI_INTERFACE */\n\n#ifdef HAVE_NPTL\nvolatile sig_atomic_t ld_assume_kernel_is_set= 0;\n#endif\n\n/* the default log output is log tables */\nstatic bool lower_case_table_names_used= 0;\nstatic bool max_long_data_size_used= false;\nstatic bool volatile select_thread_in_use, signal_thread_in_use;\nstatic volatile bool ready_to_exit;\nstatic my_bool opt_debugging= 0, opt_external_locking= 0, opt_console= 0;\nstatic my_bool opt_short_log_format= 0;\nstatic uint kill_cached_threads, wake_thread;\nulong max_used_connections;\nstatic volatile ulong cached_thread_count= 0;\nstatic char *mysqld_user, *mysqld_chroot;\nstatic char *default_character_set_name;\nstatic char *character_set_filesystem_name;\nstatic char *lc_messages;\nstatic char *lc_time_names_name;\nstatic char *my_bind_addr_str;\nstatic char *default_collation_name;\nchar *default_storage_engine;\nstatic char compiled_default_collation_name[]= MYSQL_DEFAULT_COLLATION_NAME;\nstatic I_List<THD> thread_cache;\nstatic bool binlog_format_used= false;\nLEX_STRING opt_init_connect, opt_init_slave;\nstatic mysql_cond_t COND_thread_cache, COND_flush_thread_cache;\nstatic DYNAMIC_ARRAY all_options;\n\n/* Global variables */\n\nbool opt_bin_log, opt_bin_log_used=0, opt_ignore_builtin_innodb= 0;\nmy_bool opt_log, opt_slow_log, debug_assert_if_crashed_table= 0, opt_help= 0;\nstatic my_bool opt_abort;\nulonglong log_output_options;\nmy_bool opt_userstat_running;\nmy_bool opt_log_queries_not_using_indexes= 0;\nbool opt_error_log= IF_WIN(1,0);\nbool opt_disable_networking=0, opt_skip_show_db=0;\nbool opt_skip_name_resolve=0;\nmy_bool opt_character_set_client_handshake= 1;\nbool server_id_supplied = 0;\nbool opt_endinfo, using_udf_functions;\nmy_bool locked_in_memory;\nbool opt_using_transactions;\nbool volatile abort_loop;\nbool volatile shutdown_in_progress;\nuint volatile global_disable_checkpoint;\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\nulong slow_start_timeout;\n#endif\n/*\n  True if the bootstrap thread is running. Protected by LOCK_thread_count,\n  just like thread_count.\n  Used in bootstrap() function to determine if the bootstrap thread\n  has completed. Note, that we can't use 'thread_count' instead,\n  since in 5.1, in presence of the Event Scheduler, there may be\n  event threads running in parallel, so it's impossible to know\n  what value of 'thread_count' is a sign of completion of the\n  bootstrap thread.\n\n  At the same time, we can't start the event scheduler after\n  bootstrap either, since we want to be able to process event-related\n  SQL commands in the init file and in --bootstrap mode.\n*/\nbool in_bootstrap= FALSE;\n/**\n   @brief 'grant_option' is used to indicate if privileges needs\n   to be checked, in which case the lock, LOCK_grant, is used\n   to protect access to the grant table.\n   @note This flag is dropped in 5.1\n   @see grant_init()\n */\nbool volatile grant_option;\n\nmy_bool opt_skip_slave_start = 0; ///< If set, slave is not autostarted\nmy_bool opt_reckless_slave = 0;\nmy_bool opt_enable_named_pipe= 0;\nmy_bool opt_local_infile, opt_slave_compressed_protocol;\nmy_bool opt_safe_user_create = 0;\nmy_bool opt_show_slave_auth_info;\nmy_bool opt_log_slave_updates= 0;\nmy_bool opt_replicate_annotate_row_events= 0;\nchar *opt_slave_skip_errors;\n\n/*\n  Legacy global handlerton. These will be removed (please do not add more).\n*/\nhandlerton *heap_hton;\nhandlerton *myisam_hton;\nhandlerton *partition_hton;\n\nmy_bool read_only= 0, opt_readonly= 0;\nmy_bool use_temp_pool, relay_log_purge;\nmy_bool relay_log_recovery;\nmy_bool opt_sync_frm, opt_allow_suspicious_udfs;\nmy_bool opt_secure_auth= 0;\nchar* opt_secure_file_priv;\nmy_bool opt_log_slow_admin_statements= 0;\nmy_bool opt_log_slow_slave_statements= 0;\nmy_bool lower_case_file_system= 0;\nmy_bool opt_large_pages= 0;\nmy_bool opt_super_large_pages= 0;\nmy_bool opt_myisam_use_mmap= 0;\nuint   opt_large_page_size= 0;\n#if defined(ENABLED_DEBUG_SYNC)\nMYSQL_PLUGIN_IMPORT uint    opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\nmy_bool opt_old_style_user_limits= 0, trust_function_creators= 0;\nulong opt_replicate_events_marked_for_skip;\n\n/*\n  True if there is at least one per-hour limit for some user, so we should\n  check them before each query (and possibly reset counters when hour is\n  changed). False otherwise.\n*/\nvolatile bool mqh_used = 0;\nmy_bool opt_noacl;\nmy_bool sp_automatic_privileges= 1;\n\nulong opt_binlog_rows_event_max_size;\nmy_bool opt_master_verify_checksum= 0;\nmy_bool opt_slave_sql_verify_checksum= 1;\nconst char *binlog_format_names[]= {\"MIXED\", \"STATEMENT\", \"ROW\", NullS};\n#ifdef HAVE_INITGROUPS\nvolatile sig_atomic_t calling_initgroups= 0; /**< Used in SIGSEGV handler. */\n#endif\nuint mysqld_port, test_flags, select_errors, dropping_tables, ha_open_options;\nuint mysqld_extra_port;\nuint mysqld_port_timeout;\nulong delay_key_write_options;\nuint protocol_version;\nuint lower_case_table_names;\nulong tc_heuristic_recover= 0;\nuint volatile thread_count;\nint32 thread_running;\nulong thread_created;\nulong back_log, connect_timeout, concurrency, server_id;\nulong table_cache_size, table_def_size;\nulong what_to_log;\nulong slow_launch_time, slave_open_temp_tables;\nulong open_files_limit, max_binlog_size, max_relay_log_size;\nulong slave_trans_retries;\nuint  slave_net_timeout;\nulong slave_exec_mode_options;\nulonglong slave_type_conversions_options;\nulong thread_cache_size=0;\nulonglong binlog_cache_size=0;\nulonglong max_binlog_cache_size=0;\nulong slave_max_allowed_packet= 0;\nulonglong binlog_stmt_cache_size=0;\nulonglong  max_binlog_stmt_cache_size=0;\nulonglong query_cache_size=0;\nulong refresh_version;  /* Increments on each reload */\nulong executed_events=0;\nquery_id_t global_query_id;\nmy_atomic_rwlock_t global_query_id_lock;\nmy_atomic_rwlock_t thread_running_lock;\nulong aborted_threads, aborted_connects;\nulong delayed_insert_timeout, delayed_insert_limit, delayed_queue_size;\nulong delayed_insert_threads, delayed_insert_writes, delayed_rows_in_use;\nulong delayed_insert_errors,flush_time;\nulong specialflag=0;\nulong binlog_cache_use= 0, binlog_cache_disk_use= 0;\nulong binlog_stmt_cache_use= 0, binlog_stmt_cache_disk_use= 0;\nulong max_connections, max_connect_errors;\nulong extra_max_connections;\nulonglong denied_connections;\nmy_decimal decimal_zero;\n\n/*\n  Maximum length of parameter value which can be set through\n  mysql_send_long_data() call.\n*/\nulong max_long_data_size;\n\n/* Limits for internal temporary tables (MyISAM or Aria) */\nuint internal_tmp_table_max_key_length;\nuint internal_tmp_table_max_key_segments;\n\nbool max_user_connections_checking=0;\n/**\n  Limit of the total number of prepared statements in the server.\n  Is necessary to protect the server against out-of-memory attacks.\n*/\nulong max_prepared_stmt_count;\n/**\n  Current total number of prepared statements in the server. This number\n  is exact, and therefore may not be equal to the difference between\n  `com_stmt_prepare' and `com_stmt_close' (global status variables), as\n  the latter ones account for all registered attempts to prepare\n  a statement (including unsuccessful ones).  Prepared statements are\n  currently connection-local: if the same SQL query text is prepared in\n  two different connections, this counts as two distinct prepared\n  statements.\n*/\nulong prepared_stmt_count=0;\nulong thread_id=1L,current_pid;\nulong slow_launch_threads = 0;\nuint sync_binlog_period= 0, sync_relaylog_period= 0,\n     sync_relayloginfo_period= 0, sync_masterinfo_period= 0;\nulong expire_logs_days = 0;\nulong rpl_recovery_rank=0;\n/**\n  Soft upper limit for number of sp_head objects that can be stored\n  in the sp_cache for one connection.\n*/\nulong stored_program_cache_size= 0;\n\nconst double log_10[] = {\n  1e000, 1e001, 1e002, 1e003, 1e004, 1e005, 1e006, 1e007, 1e008, 1e009,\n  1e010, 1e011, 1e012, 1e013, 1e014, 1e015, 1e016, 1e017, 1e018, 1e019,\n  1e020, 1e021, 1e022, 1e023, 1e024, 1e025, 1e026, 1e027, 1e028, 1e029,\n  1e030, 1e031, 1e032, 1e033, 1e034, 1e035, 1e036, 1e037, 1e038, 1e039,\n  1e040, 1e041, 1e042, 1e043, 1e044, 1e045, 1e046, 1e047, 1e048, 1e049,\n  1e050, 1e051, 1e052, 1e053, 1e054, 1e055, 1e056, 1e057, 1e058, 1e059,\n  1e060, 1e061, 1e062, 1e063, 1e064, 1e065, 1e066, 1e067, 1e068, 1e069,\n  1e070, 1e071, 1e072, 1e073, 1e074, 1e075, 1e076, 1e077, 1e078, 1e079,\n  1e080, 1e081, 1e082, 1e083, 1e084, 1e085, 1e086, 1e087, 1e088, 1e089,\n  1e090, 1e091, 1e092, 1e093, 1e094, 1e095, 1e096, 1e097, 1e098, 1e099,\n  1e100, 1e101, 1e102, 1e103, 1e104, 1e105, 1e106, 1e107, 1e108, 1e109,\n  1e110, 1e111, 1e112, 1e113, 1e114, 1e115, 1e116, 1e117, 1e118, 1e119,\n  1e120, 1e121, 1e122, 1e123, 1e124, 1e125, 1e126, 1e127, 1e128, 1e129,\n  1e130, 1e131, 1e132, 1e133, 1e134, 1e135, 1e136, 1e137, 1e138, 1e139,\n  1e140, 1e141, 1e142, 1e143, 1e144, 1e145, 1e146, 1e147, 1e148, 1e149,\n  1e150, 1e151, 1e152, 1e153, 1e154, 1e155, 1e156, 1e157, 1e158, 1e159,\n  1e160, 1e161, 1e162, 1e163, 1e164, 1e165, 1e166, 1e167, 1e168, 1e169,\n  1e170, 1e171, 1e172, 1e173, 1e174, 1e175, 1e176, 1e177, 1e178, 1e179,\n  1e180, 1e181, 1e182, 1e183, 1e184, 1e185, 1e186, 1e187, 1e188, 1e189,\n  1e190, 1e191, 1e192, 1e193, 1e194, 1e195, 1e196, 1e197, 1e198, 1e199,\n  1e200, 1e201, 1e202, 1e203, 1e204, 1e205, 1e206, 1e207, 1e208, 1e209,\n  1e210, 1e211, 1e212, 1e213, 1e214, 1e215, 1e216, 1e217, 1e218, 1e219,\n  1e220, 1e221, 1e222, 1e223, 1e224, 1e225, 1e226, 1e227, 1e228, 1e229,\n  1e230, 1e231, 1e232, 1e233, 1e234, 1e235, 1e236, 1e237, 1e238, 1e239,\n  1e240, 1e241, 1e242, 1e243, 1e244, 1e245, 1e246, 1e247, 1e248, 1e249,\n  1e250, 1e251, 1e252, 1e253, 1e254, 1e255, 1e256, 1e257, 1e258, 1e259,\n  1e260, 1e261, 1e262, 1e263, 1e264, 1e265, 1e266, 1e267, 1e268, 1e269,\n  1e270, 1e271, 1e272, 1e273, 1e274, 1e275, 1e276, 1e277, 1e278, 1e279,\n  1e280, 1e281, 1e282, 1e283, 1e284, 1e285, 1e286, 1e287, 1e288, 1e289,\n  1e290, 1e291, 1e292, 1e293, 1e294, 1e295, 1e296, 1e297, 1e298, 1e299,\n  1e300, 1e301, 1e302, 1e303, 1e304, 1e305, 1e306, 1e307, 1e308\n};\n\ntime_t server_start_time, flush_status_time;\n\nchar mysql_home[FN_REFLEN], pidfile_name[FN_REFLEN], system_time_zone[30];\nchar *default_tz_name;\nchar log_error_file[FN_REFLEN], glob_hostname[FN_REFLEN], *opt_log_basename;\nchar mysql_real_data_home[FN_REFLEN],\n     lc_messages_dir[FN_REFLEN], reg_ext[FN_EXTLEN],\n     mysql_charsets_dir[FN_REFLEN],\n     *opt_init_file, *opt_tc_log_file;\nchar *lc_messages_dir_ptr= lc_messages_dir, *log_error_file_ptr;\nchar mysql_unpacked_real_data_home[FN_REFLEN];\nint mysql_unpacked_real_data_home_len;\nuint mysql_real_data_home_len, mysql_data_home_len= 1;\nuint reg_ext_length;\nconst key_map key_map_empty(0);\nkey_map key_map_full(0);                        // Will be initialized later\n\nDATE_TIME_FORMAT global_date_format, global_datetime_format, global_time_format;\nTime_zone *default_tz;\n\nconst char *mysql_real_data_home_ptr= mysql_real_data_home;\nchar server_version[SERVER_VERSION_LENGTH];\nchar *mysqld_unix_port, *opt_mysql_tmpdir;\nulong thread_handling;\n\n/** name of reference on left expression in rewritten IN subquery */\nconst char *in_left_expr_name= \"<left expr>\";\n/** name of additional condition */\nconst char *in_additional_cond= \"<IN COND>\";\nconst char *in_having_cond= \"<IN HAVING>\";\n\n/* classes for comparation parsing/processing */\nEq_creator eq_creator;\nNe_creator ne_creator;\nGt_creator gt_creator;\nLt_creator lt_creator;\nGe_creator ge_creator;\nLe_creator le_creator;\n\nMYSQL_FILE *bootstrap_file;\nint bootstrap_error;\n\nI_List<THD> threads;\nRpl_filter* rpl_filter;\nRpl_filter* binlog_filter;\n\nTHD *first_global_thread()\n{\n  if (threads.is_empty())\n    return NULL;\n  return threads.head();\n}\n\nTHD *next_global_thread(THD *thd)\n{\n  if (threads.is_last(thd))\n    return NULL;\n  struct ilink *next= thd->next;\n  return static_cast<THD*>(next);\n}\n\nstruct system_variables global_system_variables;\nstruct system_variables max_system_variables;\nstruct system_status_var global_status_var;\n\nMY_TMPDIR mysql_tmpdir_list;\nMY_BITMAP temp_pool;\n\nCHARSET_INFO *system_charset_info, *files_charset_info ;\nCHARSET_INFO *national_charset_info, *table_alias_charset;\nCHARSET_INFO *character_set_filesystem;\nCHARSET_INFO *error_message_charset_info;\n\nMY_LOCALE *my_default_lc_messages;\nMY_LOCALE *my_default_lc_time_names;\n\nSHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen, have_query_cache;\nSHOW_COMP_OPTION have_geometry, have_rtree_keys;\nSHOW_COMP_OPTION have_crypt, have_compress;\nSHOW_COMP_OPTION have_profiling;\n\n/* Thread specific variables */\n\npthread_key(MEM_ROOT**,THR_MALLOC);\npthread_key(THD*, THR_THD);\nmysql_mutex_t LOCK_thread_count;\nmysql_mutex_t\n  LOCK_status, LOCK_error_log, LOCK_short_uuid_generator,\n  LOCK_delayed_insert, LOCK_delayed_status, LOCK_delayed_create,\n  LOCK_crypt,\n  LOCK_global_system_variables,\n  LOCK_user_conn, LOCK_slave_list, LOCK_active_mi,\n  LOCK_connection_count, LOCK_error_messages;\n\nmysql_mutex_t LOCK_stats, LOCK_global_user_client_stats,\n              LOCK_global_table_stats, LOCK_global_index_stats;\n\n/**\n  The below lock protects access to two global server variables:\n  max_prepared_stmt_count and prepared_stmt_count. These variables\n  set the limit and hold the current total number of prepared statements\n  in the server, respectively. As PREPARE/DEALLOCATE rate in a loaded\n  server may be fairly high, we need a dedicated lock.\n*/\nmysql_mutex_t LOCK_prepared_stmt_count;\n#ifdef HAVE_OPENSSL\nmysql_mutex_t LOCK_des_key_file;\n#endif\nmysql_rwlock_t LOCK_grant, LOCK_sys_init_connect, LOCK_sys_init_slave;\nmysql_rwlock_t LOCK_system_variables_hash;\nmysql_cond_t COND_thread_count;\npthread_t signal_thread;\npthread_attr_t connection_attrib;\nmysql_mutex_t LOCK_server_started;\nmysql_cond_t COND_server_started;\n\nint mysqld_server_started= 0;\n\nFile_parser_dummy_hook file_parser_dummy_hook;\n\n/* replication parameters, if master_host is not NULL, we are a slave */\nuint report_port= 0;\nulong master_retry_count=0;\nchar *master_info_file;\nchar *relay_log_info_file, *report_user, *report_password, *report_host;\nchar *opt_relay_logname = 0, *opt_relaylog_index_name=0;\nchar *opt_logname, *opt_slow_logname, *opt_bin_logname;\n\n/* Static variables */\n\nstatic volatile sig_atomic_t kill_in_progress;\nmy_bool opt_stack_trace;\nmy_bool opt_expect_abort= 0, opt_bootstrap= 0;\nstatic my_bool opt_myisam_log;\nstatic int cleanup_done;\nstatic ulong opt_specialflag;\nstatic char *opt_binlog_index_name;\nchar *mysql_home_ptr, *pidfile_name_ptr;\n/** Initial command line arguments (count), after load_defaults().*/\nstatic int defaults_argc;\n/**\n  Initial command line arguments (arguments), after load_defaults().\n  This memory is allocated by @c load_defaults() and should be freed\n  using @c free_defaults().\n  Do not modify defaults_argc / defaults_argv,\n  use remaining_argc / remaining_argv instead to parse the command\n  line arguments in multiple steps.\n*/\nstatic char **defaults_argv;\n/** Remaining command line arguments (count), filtered by handle_options().*/\nstatic int remaining_argc;\n/** Remaining command line arguments (arguments), filtered by handle_options().*/\nstatic char **remaining_argv;\n\nint orig_argc;\nchar **orig_argv;\n\n#ifdef HAVE_PSI_INTERFACE\n#ifdef HAVE_MMAP\nPSI_mutex_key key_PAGE_lock, key_LOCK_sync, key_LOCK_active, key_LOCK_pool;\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\nPSI_mutex_key key_LOCK_des_key_file;\n#endif /* HAVE_OPENSSL */\n\nPSI_mutex_key key_BINLOG_LOCK_index, key_BINLOG_LOCK_prep_xids,\n  key_delayed_insert_mutex, key_hash_filo_lock, key_LOCK_active_mi,\n  key_LOCK_connection_count, key_LOCK_crypt, key_LOCK_delayed_create,\n  key_LOCK_delayed_insert, key_LOCK_delayed_status, key_LOCK_error_log,\n  key_LOCK_gdl, key_LOCK_global_system_variables,\n  key_LOCK_manager,\n  key_LOCK_prepared_stmt_count,\n  key_LOCK_rpl_status, key_LOCK_server_started, key_LOCK_status,\n  key_LOCK_system_variables_hash, key_LOCK_table_share, key_LOCK_thd_data,\n  key_LOCK_user_conn, key_LOCK_uuid_short_generator, key_LOG_LOCK_log,\n  key_master_info_data_lock, key_master_info_run_lock,\n  key_master_info_sleep_lock,\n  key_mutex_slave_reporting_capability_err_lock, key_relay_log_info_data_lock,\n  key_relay_log_info_log_space_lock, key_relay_log_info_run_lock,\n  key_relay_log_info_sleep_lock,\n  key_structure_guard_mutex, key_TABLE_SHARE_LOCK_ha_data,\n  key_LOCK_error_messages, key_LOG_INFO_lock, key_LOCK_thread_count,\n  key_PARTITION_LOCK_auto_inc;\nPSI_mutex_key key_RELAYLOG_LOCK_index;\n\nPSI_mutex_key key_LOCK_stats,\n  key_LOCK_global_user_client_stats, key_LOCK_global_table_stats,\n  key_LOCK_global_index_stats,\n  key_LOCK_wakeup_ready;\n\nPSI_mutex_key key_LOCK_prepare_ordered, key_LOCK_commit_ordered;\n\nstatic PSI_mutex_info all_server_mutexes[]=\n{\n#ifdef HAVE_MMAP\n  { &key_PAGE_lock, \"PAGE::lock\", 0},\n  { &key_LOCK_sync, \"TC_LOG_MMAP::LOCK_sync\", 0},\n  { &key_LOCK_active, \"TC_LOG_MMAP::LOCK_active\", 0},\n  { &key_LOCK_pool, \"TC_LOG_MMAP::LOCK_pool\", 0},\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\n  { &key_LOCK_des_key_file, \"LOCK_des_key_file\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_OPENSSL */\n\n  { &key_BINLOG_LOCK_index, \"MYSQL_BIN_LOG::LOCK_index\", 0},\n  { &key_BINLOG_LOCK_prep_xids, \"MYSQL_BIN_LOG::LOCK_prep_xids\", 0},\n  { &key_RELAYLOG_LOCK_index, \"MYSQL_RELAY_LOG::LOCK_index\", 0},\n  { &key_delayed_insert_mutex, \"Delayed_insert::mutex\", 0},\n  { &key_hash_filo_lock, \"hash_filo::lock\", 0},\n  { &key_LOCK_active_mi, \"LOCK_active_mi\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_connection_count, \"LOCK_connection_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_crypt, \"LOCK_crypt\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_create, \"LOCK_delayed_create\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_insert, \"LOCK_delayed_insert\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_status, \"LOCK_delayed_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_error_log, \"LOCK_error_log\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_gdl, \"LOCK_gdl\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_system_variables, \"LOCK_global_system_variables\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_manager, \"LOCK_manager\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepared_stmt_count, \"LOCK_prepared_stmt_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_rpl_status, \"LOCK_rpl_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_server_started, \"LOCK_server_started\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_status, \"LOCK_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_table_share, \"LOCK_table_share\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_stats, \"LOCK_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_user_client_stats, \"LOCK_global_user_client_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_table_stats, \"LOCK_global_table_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_index_stats, \"LOCK_global_index_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_wakeup_ready, \"THD::LOCK_wakeup_ready\", 0},\n  { &key_LOCK_thd_data, \"THD::LOCK_thd_data\", 0},\n  { &key_LOCK_user_conn, \"LOCK_user_conn\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_uuid_short_generator, \"LOCK_uuid_short_generator\", PSI_FLAG_GLOBAL},\n  { &key_LOG_LOCK_log, \"LOG::LOCK_log\", 0},\n  { &key_master_info_data_lock, \"Master_info::data_lock\", 0},\n  { &key_master_info_run_lock, \"Master_info::run_lock\", 0},\n  { &key_master_info_sleep_lock, \"Master_info::sleep_lock\", 0},\n  { &key_mutex_slave_reporting_capability_err_lock, \"Slave_reporting_capability::err_lock\", 0},\n  { &key_relay_log_info_data_lock, \"Relay_log_info::data_lock\", 0},\n  { &key_relay_log_info_log_space_lock, \"Relay_log_info::log_space_lock\", 0},\n  { &key_relay_log_info_run_lock, \"Relay_log_info::run_lock\", 0},\n  { &key_relay_log_info_sleep_lock, \"Relay_log_info::sleep_lock\", 0},\n  { &key_structure_guard_mutex, \"Query_cache::structure_guard_mutex\", 0},\n  { &key_TABLE_SHARE_LOCK_ha_data, \"TABLE_SHARE::LOCK_ha_data\", 0},\n  { &key_LOCK_error_messages, \"LOCK_error_messages\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepare_ordered, \"LOCK_prepare_ordered\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_commit_ordered, \"LOCK_commit_ordered\", PSI_FLAG_GLOBAL},\n  { &key_LOG_INFO_lock, \"LOG_INFO::lock\", 0},\n  { &key_LOCK_thread_count, \"LOCK_thread_count\", PSI_FLAG_GLOBAL},\n  { &key_PARTITION_LOCK_auto_inc, \"HA_DATA_PARTITION::LOCK_auto_inc\", 0}\n};\n\nPSI_rwlock_key key_rwlock_LOCK_grant, key_rwlock_LOCK_logger,\n  key_rwlock_LOCK_sys_init_connect, key_rwlock_LOCK_sys_init_slave,\n  key_rwlock_LOCK_system_variables_hash, key_rwlock_query_cache_query_lock;\n\nstatic PSI_rwlock_info all_server_rwlocks[]=\n{\n#if defined (HAVE_OPENSSL) && !defined(HAVE_YASSL)\n  { &key_rwlock_openssl, \"CRYPTO_dynlock_value::lock\", 0},\n#endif\n  { &key_rwlock_LOCK_grant, \"LOCK_grant\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_logger, \"LOGGER::LOCK_logger\", 0},\n  { &key_rwlock_LOCK_sys_init_connect, \"LOCK_sys_init_connect\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_sys_init_slave, \"LOCK_sys_init_slave\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_query_cache_query_lock, \"Query_cache_query::lock\", 0}\n};\n\n#ifdef HAVE_MMAP\nPSI_cond_key key_PAGE_cond, key_COND_active, key_COND_pool;\n#endif /* HAVE_MMAP */\n\nPSI_cond_key key_BINLOG_COND_prep_xids, key_BINLOG_update_cond,\n  key_COND_cache_status_changed, key_COND_manager,\n  key_COND_rpl_status, key_COND_server_started,\n  key_delayed_insert_cond, key_delayed_insert_cond_client,\n  key_item_func_sleep_cond, key_master_info_data_cond,\n  key_master_info_start_cond, key_master_info_stop_cond,\n  key_master_info_sleep_cond,\n  key_relay_log_info_data_cond, key_relay_log_info_log_space_cond,\n  key_relay_log_info_start_cond, key_relay_log_info_stop_cond,\n  key_relay_log_info_sleep_cond,\n  key_TABLE_SHARE_cond, key_user_level_lock_cond,\n  key_COND_thread_count, key_COND_thread_cache, key_COND_flush_thread_cache,\n  key_BINLOG_COND_queue_busy;\nPSI_cond_key key_RELAYLOG_update_cond, key_COND_wakeup_ready;\nPSI_cond_key key_RELAYLOG_COND_queue_busy;\nPSI_cond_key key_TC_LOG_MMAP_COND_queue_busy;\n\nstatic PSI_cond_info all_server_conds[]=\n{\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_COND_handler_count, \"COND_handler_count\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n#ifdef HAVE_MMAP\n  { &key_PAGE_cond, \"PAGE::cond\", 0},\n  { &key_COND_active, \"TC_LOG_MMAP::COND_active\", 0},\n  { &key_COND_pool, \"TC_LOG_MMAP::COND_pool\", 0},\n  { &key_TC_LOG_MMAP_COND_queue_busy, \"TC_LOG_MMAP::COND_queue_busy\", 0},\n#endif /* HAVE_MMAP */\n  { &key_BINLOG_COND_prep_xids, \"MYSQL_BIN_LOG::COND_prep_xids\", 0},\n  { &key_BINLOG_update_cond, \"MYSQL_BIN_LOG::update_cond\", 0},\n  { &key_BINLOG_COND_queue_busy, \"MYSQL_BIN_LOG::COND_queue_busy\", 0},\n  { &key_RELAYLOG_update_cond, \"MYSQL_RELAY_LOG::update_cond\", 0},\n  { &key_RELAYLOG_COND_queue_busy, \"MYSQL_RELAY_LOG::COND_queue_busy\", 0},\n  { &key_COND_wakeup_ready, \"THD::COND_wakeup_ready\", 0},\n  { &key_COND_cache_status_changed, \"Query_cache::COND_cache_status_changed\", 0},\n  { &key_COND_manager, \"COND_manager\", PSI_FLAG_GLOBAL},\n  { &key_COND_rpl_status, \"COND_rpl_status\", PSI_FLAG_GLOBAL},\n  { &key_COND_server_started, \"COND_server_started\", PSI_FLAG_GLOBAL},\n  { &key_delayed_insert_cond, \"Delayed_insert::cond\", 0},\n  { &key_delayed_insert_cond_client, \"Delayed_insert::cond_client\", 0},\n  { &key_item_func_sleep_cond, \"Item_func_sleep::cond\", 0},\n  { &key_master_info_data_cond, \"Master_info::data_cond\", 0},\n  { &key_master_info_start_cond, \"Master_info::start_cond\", 0},\n  { &key_master_info_stop_cond, \"Master_info::stop_cond\", 0},\n  { &key_master_info_sleep_cond, \"Master_info::sleep_cond\", 0},\n  { &key_relay_log_info_data_cond, \"Relay_log_info::data_cond\", 0},\n  { &key_relay_log_info_log_space_cond, \"Relay_log_info::log_space_cond\", 0},\n  { &key_relay_log_info_start_cond, \"Relay_log_info::start_cond\", 0},\n  { &key_relay_log_info_stop_cond, \"Relay_log_info::stop_cond\", 0},\n  { &key_relay_log_info_sleep_cond, \"Relay_log_info::sleep_cond\", 0},\n  { &key_TABLE_SHARE_cond, \"TABLE_SHARE::cond\", 0},\n  { &key_user_level_lock_cond, \"User_level_lock::cond\", 0},\n  { &key_COND_thread_count, \"COND_thread_count\", PSI_FLAG_GLOBAL},\n  { &key_COND_thread_cache, \"COND_thread_cache\", PSI_FLAG_GLOBAL},\n  { &key_COND_flush_thread_cache, \"COND_flush_thread_cache\", PSI_FLAG_GLOBAL}\n};\n\nPSI_thread_key key_thread_bootstrap, key_thread_delayed_insert,\n  key_thread_handle_manager, key_thread_main,\n  key_thread_one_connection, key_thread_signal_hand;\n\nstatic PSI_thread_info all_server_threads[]=\n{\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_namedpipes, \"con_named_pipes\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if defined(HAVE_SMEM) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_sharedmem, \"con_shared_mem\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_sockets, \"con_sockets\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#ifdef __WIN__\n  { &key_thread_handle_shutdown, \"shutdown\", PSI_FLAG_GLOBAL},\n#endif /* __WIN__ */\n\n  { &key_thread_bootstrap, \"bootstrap\", PSI_FLAG_GLOBAL},\n  { &key_thread_delayed_insert, \"delayed_insert\", 0},\n  { &key_thread_handle_manager, \"manager\", PSI_FLAG_GLOBAL},\n  { &key_thread_main, \"main\", PSI_FLAG_GLOBAL},\n  { &key_thread_one_connection, \"one_connection\", 0},\n  { &key_thread_signal_hand, \"signal_handler\", PSI_FLAG_GLOBAL}\n};\n\nPSI_file_key key_file_binlog, key_file_binlog_index, key_file_casetest,\n  key_file_dbopt, key_file_des_key_file, key_file_ERRMSG, key_select_to_file,\n  key_file_fileparser, key_file_frm, key_file_global_ddl_log, key_file_load,\n  key_file_loadfile, key_file_log_event_data, key_file_log_event_info,\n  key_file_master_info, key_file_misc, key_file_partition,\n  key_file_pid, key_file_relay_log_info, key_file_send_file, key_file_tclog,\n  key_file_trg, key_file_trn, key_file_init;\nPSI_file_key key_file_query_log, key_file_slow_log;\nPSI_file_key key_file_relaylog, key_file_relaylog_index;\n\nstatic PSI_file_info all_server_files[]=\n{\n  { &key_file_binlog, \"binlog\", 0},\n  { &key_file_binlog_index, \"binlog_index\", 0},\n  { &key_file_relaylog, \"relaylog\", 0},\n  { &key_file_relaylog_index, \"relaylog_index\", 0},\n  { &key_file_casetest, \"casetest\", 0},\n  { &key_file_dbopt, \"dbopt\", 0},\n  { &key_file_des_key_file, \"des_key_file\", 0},\n  { &key_file_ERRMSG, \"ERRMSG\", 0},\n  { &key_select_to_file, \"select_to_file\", 0},\n  { &key_file_fileparser, \"file_parser\", 0},\n  { &key_file_frm, \"FRM\", 0},\n  { &key_file_global_ddl_log, \"global_ddl_log\", 0},\n  { &key_file_load, \"load\", 0},\n  { &key_file_loadfile, \"LOAD_FILE\", 0},\n  { &key_file_log_event_data, \"log_event_data\", 0},\n  { &key_file_log_event_info, \"log_event_info\", 0},\n  { &key_file_master_info, \"master_info\", 0},\n  { &key_file_misc, \"misc\", 0},\n  { &key_file_partition, \"partition\", 0},\n  { &key_file_pid, \"pid\", 0},\n  { &key_file_query_log, \"query_log\", 0},\n  { &key_file_relay_log_info, \"relay_log_info\", 0},\n  { &key_file_send_file, \"send_file\", 0},\n  { &key_file_slow_log, \"slow_log\", 0},\n  { &key_file_tclog, \"tclog\", 0},\n  { &key_file_trg, \"trigger_name\", 0},\n  { &key_file_trn, \"trigger\", 0},\n  { &key_file_init, \"init\", 0}\n};\n\n/**\n  Initialise all the performance schema instrumentation points\n  used by the server.\n*/\nvoid init_server_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_server_mutexes);\n  PSI_server->register_mutex(category, all_server_mutexes, count);\n\n  count= array_elements(all_server_rwlocks);\n  PSI_server->register_rwlock(category, all_server_rwlocks, count);\n\n  count= array_elements(all_server_conds);\n  PSI_server->register_cond(category, all_server_conds, count);\n\n  count= array_elements(all_server_threads);\n  PSI_server->register_thread(category, all_server_threads, count);\n\n  count= array_elements(all_server_files);\n  PSI_server->register_file(category, all_server_files, count);\n}\n\n#endif /* HAVE_PSI_INTERFACE */\n\n/*\n  Since buffered_option_error_reporter is only used currently\n  for parsing performance schema options, this code is not needed\n  when the performance schema is not compiled in.\n*/\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n/**\n  A log message for the error log, buffered in memory.\n  Log messages are temporarily buffered when generated before the error log\n  is initialized, and then printed once the error log is ready.\n*/\nclass Buffered_log : public Sql_alloc\n{\npublic:\n  Buffered_log(enum loglevel level, const char *message);\n\n  ~Buffered_log()\n  {}\n\n  void print(void);\n\nprivate:\n  /** Log message level. */\n  enum loglevel m_level;\n  /** Log message text. */\n  String m_message;\n};\n\n/**\n  Constructor.\n  @param level          the message log level\n  @param message        the message text\n*/\nBuffered_log::Buffered_log(enum loglevel level, const char *message)\n  : m_level(level), m_message()\n{\n  m_message.copy(message, strlen(message), &my_charset_latin1);\n}\n\n/**\n  Print a buffered log to the real log file.\n*/\nvoid Buffered_log::print()\n{\n  /*\n    Since messages are buffered, they can be printed out\n    of order with other entries in the log.\n    Add \"Buffered xxx\" to the message text to prevent confusion.\n  */\n  switch(m_level)\n  {\n  case ERROR_LEVEL:\n    sql_print_error(\"Buffered error: %s\\n\", m_message.c_ptr_safe());\n    break;\n  case WARNING_LEVEL:\n    sql_print_warning(\"Buffered warning: %s\\n\", m_message.c_ptr_safe());\n    break;\n  case INFORMATION_LEVEL:\n    /*\n      Messages printed as \"information\" still end up in the mysqld *error* log,\n      but with a [Note] tag instead of an [ERROR] tag.\n      While this is probably fine for a human reading the log,\n      it is upsetting existing automated scripts used to parse logs,\n      because such scripts are likely to not already handle [Note] properly.\n      INFORMATION_LEVEL messages are simply silenced, on purpose,\n      to avoid un needed verbosity.\n    */\n    break;\n  }\n}\n\n/**\n  Collection of all the buffered log messages.\n*/\nclass Buffered_logs\n{\npublic:\n  Buffered_logs()\n  {}\n\n  ~Buffered_logs()\n  {}\n\n  void init();\n  void cleanup();\n\n  void buffer(enum loglevel m_level, const char *msg);\n  void print();\nprivate:\n  /**\n    Memory root to use to store buffered logs.\n    This memory root lifespan is between init and cleanup.\n    Once the buffered logs are printed, they are not needed anymore,\n    and all the memory used is reclaimed.\n  */\n  MEM_ROOT m_root;\n  /** List of buffered log messages. */\n  List<Buffered_log> m_list;\n};\n\nvoid Buffered_logs::init()\n{\n  init_alloc_root(&m_root, 1024, 0);\n}\n\nvoid Buffered_logs::cleanup()\n{\n  m_list.delete_elements();\n  free_root(&m_root, MYF(0));\n}\n\n/**\n  Add a log message to the buffer.\n*/\nvoid Buffered_logs::buffer(enum loglevel level, const char *msg)\n{\n  /*\n    Do not let Sql_alloc::operator new(size_t) allocate memory,\n    there is no memory root associated with the main() thread.\n    Give explicitly the proper memory root to use to\n    Sql_alloc::operator new(size_t, MEM_ROOT *) instead.\n  */\n  Buffered_log *log= new (&m_root) Buffered_log(level, msg);\n  if (log)\n    m_list.push_back(log, &m_root);\n}\n\n/**\n  Print buffered log messages.\n*/\nvoid Buffered_logs::print()\n{\n  Buffered_log *log;\n  List_iterator_fast<Buffered_log> it(m_list);\n  while ((log= it++))\n    log->print();\n}\n\n/** Logs reported before a logger is available. */\nstatic Buffered_logs buffered_logs;\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  Error reporter that buffer log messages.\n  @param level          log message level\n  @param format         log message format string\n*/\nC_MODE_START\nstatic void buffered_option_error_reporter(enum loglevel level,\n                                           const char *format, ...)\n{\n  va_list args;\n  char buffer[1024];\n\n  va_start(args, format);\n  my_vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n  buffered_logs.buffer(level, buffer);\n}\nC_MODE_END\n#endif /* !EMBEDDED_LIBRARY */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nstatic my_socket unix_sock, base_ip_sock, extra_ip_sock;\nstruct my_rnd_struct sql_rand; ///< used by sql_class.cc:THD::THD()\n\n#ifndef EMBEDDED_LIBRARY\nstruct passwd *user_info;\nstatic pthread_t select_thread;\n#endif\n\n/* OS specific variables */\n\n#ifdef __WIN__\n#undef\t getpid\n#include <process.h>\n\nstatic mysql_cond_t COND_handler_count;\nstatic uint handler_count;\nstatic bool start_mode=0, use_opt_args;\nstatic int opt_argc;\nstatic char **opt_argv;\n\n#if !defined(EMBEDDED_LIBRARY)\nstatic HANDLE hEventShutdown;\nstatic char shutdown_event_name[40];\n#include \"nt_servc.h\"\nstatic\t NTService  Service;\t      ///< Service object for WinNT\n#endif /* EMBEDDED_LIBRARY */\n#endif /* __WIN__ */\n\n#ifdef _WIN32\nstatic char pipe_name[512];\nstatic SECURITY_ATTRIBUTES saPipeSecurity;\nstatic SECURITY_DESCRIPTOR sdPipeDescriptor;\nstatic HANDLE hPipe = INVALID_HANDLE_VALUE;\n#endif\n\n#ifndef EMBEDDED_LIBRARY\nbool mysqld_embedded=0;\n#else\nbool mysqld_embedded=1;\n#endif\n\nstatic my_bool plugins_are_initialized= FALSE;\n\n#ifndef DBUG_OFF\nstatic const char* default_dbug_option;\n#endif\nstatic const char *current_dbug_option=\"disabled\";\n#ifdef HAVE_LIBWRAP\nconst char *libwrapName= NULL;\nint allow_severity = LOG_INFO;\nint deny_severity = LOG_WARNING;\n#endif\n#ifdef HAVE_QUERY_CACHE\nulong query_cache_min_res_unit= QUERY_CACHE_MIN_RESULT_DATA_SIZE;\nQuery_cache query_cache;\n#endif\n#ifdef HAVE_SMEM\nchar *shared_memory_base_name= default_shared_memory_base_name;\nmy_bool opt_enable_shared_memory;\nHANDLE smem_event_connect_request= 0;\n#endif\n\nmy_bool opt_use_ssl  = 0;\nchar *opt_ssl_ca= NULL, *opt_ssl_capath= NULL, *opt_ssl_cert= NULL,\n     *opt_ssl_cipher= NULL, *opt_ssl_key= NULL;\n\nstatic scheduler_functions thread_scheduler_struct, extra_thread_scheduler_struct;\nscheduler_functions *thread_scheduler= &thread_scheduler_struct,\n                    *extra_thread_scheduler= &extra_thread_scheduler_struct;\n\n#ifdef HAVE_OPENSSL\n#include <openssl/crypto.h>\n#ifndef HAVE_YASSL\ntypedef struct CRYPTO_dynlock_value\n{\n  mysql_rwlock_t lock;\n} openssl_lock_t;\n\nstatic openssl_lock_t *openssl_stdlocks;\nstatic openssl_lock_t *openssl_dynlock_create(const char *, int);\nstatic void openssl_dynlock_destroy(openssl_lock_t *, const char *, int);\nstatic void openssl_lock_function(int, int, const char *, int);\nstatic void openssl_lock(int, openssl_lock_t *, const char *, int);\n#endif\nchar *des_key_file;\n#ifndef EMBEDDED_LIBRARY\nstruct st_VioSSLFd *ssl_acceptor_fd;\n#endif\n#endif /* HAVE_OPENSSL */\n\n/**\n  Number of currently active user connections. The variable is protected by\n  LOCK_connection_count.\n*/\nuint connection_count= 0, extra_connection_count= 0;\n\n/* Function declarations */\n\npthread_handler_t signal_hand(void *arg);\nstatic int mysql_init_variables(void);\nstatic int get_options(int *argc_ptr, char ***argv_ptr);\nstatic bool add_terminator(DYNAMIC_ARRAY *options);\nextern \"C\" my_bool mysqld_get_one_option(int, const struct my_option *, char *);\nstatic int init_thread_environment();\nstatic char *get_relative_path(const char *path);\nstatic int fix_paths(void);\nvoid handle_connections_sockets();\n#ifdef _WIN32\npthread_handler_t handle_connections_sockets_thread(void *arg);\n#endif\npthread_handler_t kill_server_thread(void *arg);\nstatic void bootstrap(MYSQL_FILE *file);\nstatic bool read_init_file(char *file_name);\n#ifdef _WIN32\npthread_handler_t handle_connections_namedpipes(void *arg);\n#endif\n#ifdef HAVE_SMEM\npthread_handler_t handle_connections_shared_memory(void *arg);\n#endif\npthread_handler_t handle_slave(void *arg);\nstatic void clean_up(bool print_message);\nstatic int test_if_case_insensitive(const char *dir_name);\n\n#ifndef EMBEDDED_LIBRARY\nstatic bool pid_file_created= false;\nstatic void usage(void);\nstatic void start_signal_handler(void);\nstatic void close_server_sock();\nstatic void clean_up_mutexes(void);\nstatic void wait_for_signal_thread_to_end(void);\nstatic void create_pid_file();\nstatic void mysqld_exit(int exit_code) __attribute__((noreturn));\n#endif\nstatic void delete_pid_file(myf flags);\nstatic void end_ssl();\n\n\n#ifndef EMBEDDED_LIBRARY\n/****************************************************************************\n** Code to end mysqld\n****************************************************************************/\n\nstatic void close_connections(void)\n{\n#ifdef EXTRA_DEBUG\n  int count=0;\n#endif\n  DBUG_ENTER(\"close_connections\");\n\n  /* Clear thread cache */\n  kill_cached_threads++;\n  flush_thread_cache();\n\n  /* kill connection thread */\n#if !defined(__WIN__)\n  DBUG_PRINT(\"quit\", (\"waiting for select thread: 0x%lx\",\n                      (ulong) select_thread));\n  mysql_mutex_lock(&LOCK_thread_count);\n\n  while (select_thread_in_use)\n  {\n    struct timespec abstime;\n    int error;\n    LINT_INIT(error);\n    DBUG_PRINT(\"info\",(\"Waiting for select thread\"));\n\n#ifndef DONT_USE_THR_ALARM\n    if (pthread_kill(select_thread, thr_client_alarm))\n      break;\t\t\t\t\t// allready dead\n#endif\n    set_timespec(abstime, 2);\n    for (uint tmp=0 ; tmp < 10 && select_thread_in_use; tmp++)\n    {\n      error= mysql_cond_timedwait(&COND_thread_count, &LOCK_thread_count,\n                                  &abstime);\n      if (error != EINTR)\n\tbreak;\n    }\n#ifdef EXTRA_DEBUG\n    if (error != 0 && error != ETIMEDOUT && !count++)\n      sql_print_error(\"Got error %d from mysql_cond_timedwait\", error);\n#endif\n    close_server_sock();\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n#endif /* __WIN__ */\n\n\n  /* Abort listening to new connections */\n  DBUG_PRINT(\"quit\",(\"Closing sockets\"));\n  if (!opt_disable_networking )\n  {\n    if (base_ip_sock != INVALID_SOCKET)\n    {\n      (void) mysql_socket_shutdown(base_ip_sock, SHUT_RDWR);\n      (void) closesocket(base_ip_sock);\n      base_ip_sock= INVALID_SOCKET;\n    }\n    if (extra_ip_sock != INVALID_SOCKET)\n    {\n      (void) mysql_socket_shutdown(extra_ip_sock, SHUT_RDWR);\n      (void) closesocket(extra_ip_sock);\n      extra_ip_sock= INVALID_SOCKET;\n    }\n  }\n#ifdef _WIN32\n  if (hPipe != INVALID_HANDLE_VALUE && opt_enable_named_pipe)\n  {\n    HANDLE temp;\n    DBUG_PRINT(\"quit\", (\"Closing named pipes\") );\n\n    /* Create connection to the handle named pipe handler to break the loop */\n    if ((temp = CreateFile(pipe_name,\n\t\t\t   GENERIC_READ | GENERIC_WRITE,\n\t\t\t   0,\n\t\t\t   NULL,\n\t\t\t   OPEN_EXISTING,\n\t\t\t   0,\n\t\t\t   NULL )) != INVALID_HANDLE_VALUE)\n    {\n      WaitNamedPipe(pipe_name, 1000);\n      DWORD dwMode = PIPE_READMODE_BYTE | PIPE_WAIT;\n      SetNamedPipeHandleState(temp, &dwMode, NULL, NULL);\n      CancelIo(temp);\n      DisconnectNamedPipe(temp);\n      CloseHandle(temp);\n    }\n  }\n#endif\n#ifdef HAVE_SYS_UN_H\n  if (unix_sock != INVALID_SOCKET)\n  {\n    (void) mysql_socket_shutdown(unix_sock, SHUT_RDWR);\n    (void) closesocket(unix_sock);\n    (void) unlink(mysqld_unix_port);\n    unix_sock= INVALID_SOCKET;\n  }\n#endif\n  end_thr_alarm(0);\t\t\t // Abort old alarms.\n\n  /*\n    First signal all threads that it's time to die\n    This will give the threads some time to gracefully abort their\n    statements and inform their clients that the server is about to die.\n  */\n\n  THD *tmp;\n  mysql_mutex_lock(&LOCK_thread_count); // For unlink from list\n\n  I_List_iterator<THD> it(threads);\n  while ((tmp=it++))\n  {\n    DBUG_PRINT(\"quit\",(\"Informing thread %ld that it's time to die\",\n\t\t       tmp->thread_id));\n    /* We skip slave threads & scheduler on this first loop through. */\n    if (tmp->slave_thread)\n      continue;\n\n    tmp->killed= KILL_SERVER_HARD;\n    MYSQL_CALLBACK(thread_scheduler, post_kill_notification, (tmp));\n    mysql_mutex_lock(&tmp->LOCK_thd_data);\n    if (tmp->mysys_var)\n    {\n      tmp->mysys_var->abort=1;\n      mysql_mutex_lock(&tmp->mysys_var->mutex);\n      if (tmp->mysys_var->current_cond)\n      {\n        uint i;\n        for (i=0; i < 2; i++)\n        {\n          int ret= mysql_mutex_trylock(tmp->mysys_var->current_mutex);\n          mysql_cond_broadcast(tmp->mysys_var->current_cond);\n          if (!ret)\n          {\n            /* Thread has surely got the signal, unlock and abort */\n            mysql_mutex_unlock(tmp->mysys_var->current_mutex);\n            break;\n          }\n          sleep(1);\n        }\n      }\n      mysql_mutex_unlock(&tmp->mysys_var->mutex);\n    }\n    mysql_mutex_unlock(&tmp->LOCK_thd_data);\n  }\n  mysql_mutex_unlock(&LOCK_thread_count); // For unlink from list\n\n  Events::deinit();\n  end_slave();\n\n  /* Give threads time to die. */\n  for (int i= 0; thread_count && i < 100; i++)\n    my_sleep(20000);\n\n  /*\n    Force remaining threads to die by closing the connection to the client\n    This will ensure that threads that are waiting for a command from the\n    client on a blocking read call are aborted.\n  */\n\n  for (;;)\n  {\n    DBUG_PRINT(\"quit\",(\"Locking LOCK_thread_count\"));\n    mysql_mutex_lock(&LOCK_thread_count); // For unlink from list\n    if (!(tmp=threads.get()))\n    {\n      DBUG_PRINT(\"quit\",(\"Unlocking LOCK_thread_count\"));\n      mysql_mutex_unlock(&LOCK_thread_count);\n      break;\n    }\n#ifndef __bsdi__\t\t\t\t// Bug in BSDI kernel\n    if (tmp->vio_ok())\n    {\n      if (global_system_variables.log_warnings)\n        sql_print_warning(ER_DEFAULT(ER_FORCING_CLOSE),my_progname,\n                          tmp->thread_id,\n                          (tmp->main_security_ctx.user ?\n                           tmp->main_security_ctx.user : \"\"));\n      close_connection(tmp,ER_SERVER_SHUTDOWN);\n    }\n#endif\n    DBUG_PRINT(\"quit\",(\"Unlocking LOCK_thread_count\"));\n    mysql_mutex_unlock(&LOCK_thread_count);\n  }\n  /* All threads has now been aborted */\n  DBUG_PRINT(\"quit\",(\"Waiting for threads to die (count=%u)\",thread_count));\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (thread_count)\n  {\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n    DBUG_PRINT(\"quit\",(\"One thread died (count=%u)\",thread_count));\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  DBUG_PRINT(\"quit\",(\"close_connections thread\"));\n  DBUG_VOID_RETURN;\n}\n\n\n#ifdef HAVE_CLOSE_SERVER_SOCK\nstatic void close_socket(my_socket sock, const char *info)\n{\n  DBUG_ENTER(\"close_socket\");\n\n  if (sock != INVALID_SOCKET)\n  {\n    DBUG_PRINT(\"info\", (\"calling shutdown on %s socket\", info));\n    (void) mysql_socket_shutdown(sock, SHUT_RDWR);\n#if defined(__NETWARE__)\n    /*\n      The following code is disabled for normal systems as it causes MySQL\n      to hang on AIX 4.3 during shutdown\n    */\n    DBUG_PRINT(\"info\", (\"calling closesocket on %s socket\", info));\n    (void) closesocket(tmp_sock);\n#endif\n  }\n  DBUG_VOID_RETURN;\n}\n#endif\n\n\nstatic void close_server_sock()\n{\n#ifdef HAVE_CLOSE_SERVER_SOCK\n  DBUG_ENTER(\"close_server_sock\");\n\n  close_socket(base_ip_sock, \"TCP/IP\");\n  close_socket(extra_ip_sock, \"TCP/IP\");\n  close_socket(unix_sock, \"unix/IP\");\n\n  if (unix_sock != INVALID_SOCKET)\n    (void) unlink(mysqld_unix_port);\n  base_ip_sock= extra_ip_sock= unix_sock= INVALID_SOCKET;\n\n  DBUG_VOID_RETURN;\n#endif\n}\n\n#endif /*EMBEDDED_LIBRARY*/\n\n\nvoid kill_mysql(void)\n{\n  DBUG_ENTER(\"kill_mysql\");\n\n#if defined(SIGNALS_DONT_BREAK_READ) && !defined(EMBEDDED_LIBRARY)\n  abort_loop=1;\t\t\t\t\t// Break connection loops\n  close_server_sock();\t\t\t\t// Force accept to wake up\n#endif\n\n#if defined(__WIN__)\n#if !defined(EMBEDDED_LIBRARY)\n  {\n    if (!SetEvent(hEventShutdown))\n    {\n      DBUG_PRINT(\"error\",(\"Got error: %ld from SetEvent\",GetLastError()));\n    }\n    /*\n      or:\n      HANDLE hEvent=OpenEvent(0, FALSE, \"MySqlShutdown\");\n      SetEvent(hEventShutdown);\n      CloseHandle(hEvent);\n    */\n  }\n#endif\n#elif defined(HAVE_PTHREAD_KILL)\n  if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL))\n  {\n    DBUG_PRINT(\"error\",(\"Got error %d from pthread_kill\",errno)); /* purecov: inspected */\n  }\n#elif !defined(SIGNALS_DONT_BREAK_READ)\n  kill(current_pid, MYSQL_KILL_SIGNAL);\n#endif\n  DBUG_PRINT(\"quit\",(\"After pthread_kill\"));\n  shutdown_in_progress=1;\t\t\t// Safety if kill didn't work\n#ifdef SIGNALS_DONT_BREAK_READ\n  if (!kill_in_progress)\n  {\n    pthread_t tmp;\n    int error;\n    abort_loop=1;\n    if ((error= mysql_thread_create(0, /* Not instrumented */\n                                    &tmp, &connection_attrib,\n                                    kill_server_thread, (void*) 0)))\n      sql_print_error(\"Can't create thread to kill server (errno= %d).\", error);\n  }\n#endif\n  DBUG_VOID_RETURN;\n}\n\n/**\n  Force server down. Kill all connections and threads and exit.\n\n  @param  sig_ptr       Signal number that caused kill_server to be called.\n\n  @note\n    A signal number of 0 mean that the function was not called\n    from a signal handler and there is thus no signal to block\n    or stop, we just want to kill the server.\n*/\n\n#if !defined(__WIN__)\nstatic void *kill_server(void *sig_ptr)\n#define RETURN_FROM_KILL_SERVER return 0\n#else\nstatic void __cdecl kill_server(int sig_ptr)\n#define RETURN_FROM_KILL_SERVER return\n#endif\n{\n  DBUG_ENTER(\"kill_server\");\n#ifndef EMBEDDED_LIBRARY\n  int sig=(int) (long) sig_ptr;\t\t\t// This is passed a int\n  // if there is a signal during the kill in progress, ignore the other\n  if (kill_in_progress)\t\t\t\t// Safety\n  {\n    DBUG_LEAVE;\n    RETURN_FROM_KILL_SERVER;\n  }\n  kill_in_progress=TRUE;\n  abort_loop=1;\t\t\t\t\t// This should be set\n  if (sig != 0) // 0 is not a valid signal number\n    my_sigset(sig, SIG_IGN);                    /* purify inspected */\n  if (sig == MYSQL_KILL_SIGNAL || sig == 0)\n    sql_print_information(ER_DEFAULT(ER_NORMAL_SHUTDOWN),my_progname);\n  else\n    sql_print_error(ER_DEFAULT(ER_GOT_SIGNAL),my_progname,sig); /* purecov: inspected */\n\n#ifdef HAVE_SMEM\n  /*\n    Send event to smem_event_connect_request for aborting\n  */\n  if (opt_enable_shared_memory)\n  {\n    if (!SetEvent(smem_event_connect_request))\n    {\n      DBUG_PRINT(\"error\",\n                 (\"Got error: %ld from SetEvent of smem_event_connect_request\",\n                  GetLastError()));\n    }\n  }\n#endif\n\n  close_connections();\n  if (sig != MYSQL_KILL_SIGNAL &&\n      sig != 0)\n    unireg_abort(1);\t\t\t\t/* purecov: inspected */\n  else\n    unireg_end();\n\n  /* purecov: begin deadcode */\n  DBUG_LEAVE;                                   // Must match DBUG_ENTER()\n  my_thread_end();\n  pthread_exit(0);\n  /* purecov: end */\n\n  RETURN_FROM_KILL_SERVER;                      // Avoid compiler warnings\n\n#else /* EMBEDDED_LIBRARY*/\n\n  DBUG_LEAVE;\n  RETURN_FROM_KILL_SERVER;\n\n#endif /* EMBEDDED_LIBRARY */\n}\n\n\n#if defined(USE_ONE_SIGNAL_HAND)\npthread_handler_t kill_server_thread(void *arg __attribute__((unused)))\n{\n  my_thread_init();\t\t\t\t// Initialize new thread\n  kill_server(0);\n  /* purecov: begin deadcode */\n  my_thread_end();\n  pthread_exit(0);\n  return 0;\n  /* purecov: end */\n}\n#endif\n\n\nextern \"C\" sig_handler print_signal_warning(int sig)\n{\n  if (global_system_variables.log_warnings)\n    sql_print_warning(\"Got signal %d from thread %ld\", sig,my_thread_id());\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  my_sigset(sig,print_signal_warning);\t\t/* int. thread system calls */\n#endif\n#if !defined(__WIN__)\n  if (sig == SIGALRM)\n    alarm(2);\t\t\t\t\t/* reschedule alarm */\n#endif\n}\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void init_error_log_mutex()\n{\n  mysql_mutex_init(key_LOCK_error_log, &LOCK_error_log, MY_MUTEX_INIT_FAST);\n}\n\n\nstatic void clean_up_error_log_mutex()\n{\n  mysql_mutex_destroy(&LOCK_error_log);\n}\n\n\n/**\n  cleanup all memory and end program nicely.\n\n    If SIGNALS_DONT_BREAK_READ is defined, this function is called\n    by the main thread. To get MySQL to shut down nicely in this case\n    (Mac OS X) we have to call exit() instead if pthread_exit().\n\n  @note\n    This function never returns.\n*/\nvoid unireg_end(void)\n{\n  clean_up(1);\n  my_thread_end();\n#if defined(SIGNALS_DONT_BREAK_READ)\n  exit(0);\n#else\n  pthread_exit(0);\t\t\t\t// Exit is in main thread\n#endif\n}\n\n\nextern \"C\" void unireg_abort(int exit_code)\n{\n  DBUG_ENTER(\"unireg_abort\");\n\n  if (opt_help)\n    usage();\n  if (exit_code)\n    sql_print_error(\"Aborting\\n\");\n  clean_up(!opt_abort && (exit_code || !opt_bootstrap)); /* purecov: inspected */\n  DBUG_PRINT(\"quit\",(\"done with cleanup in unireg_abort\"));\n  mysqld_exit(exit_code);\n}\n\nstatic void mysqld_exit(int exit_code)\n{\n  /*\n    Important note: we wait for the signal thread to end,\n    but if a kill -15 signal was sent, the signal thread did\n    spawn the kill_server_thread thread, which is running concurrently.\n  */\n  wait_for_signal_thread_to_end();\n  mysql_audit_finalize();\n  clean_up_mutexes();\n  clean_up_error_log_mutex();\n  my_end((opt_endinfo ? MY_CHECK_ERROR | MY_GIVE_INFO : 0));\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  shutdown_performance_schema();        // we do it as late as possible\n#endif\n  exit(exit_code); /* purecov: inspected */\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\nvoid clean_up(bool print_message)\n{\n  DBUG_PRINT(\"exit\",(\"clean_up\"));\n  if (cleanup_done++)\n    return; /* purecov: inspected */\n\n  close_active_mi();\n  stop_handle_manager();\n  release_ddl_log();\n\n  /*\n    make sure that handlers finish up\n    what they have that is dependent on the binlog\n  */\n  ha_binlog_end(current_thd);\n\n  logger.cleanup_base();\n\n  injector::free_instance();\n  mysql_bin_log.cleanup();\n\n#ifdef HAVE_REPLICATION\n  if (use_slave_mask)\n    bitmap_free(&slave_error_mask);\n#endif\n  my_tz_free();\n  my_dboptions_cache_free();\n  ignore_db_dirs_free();\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  servers_free(1);\n  acl_free(1);\n  grant_free();\n#endif\n  query_cache_destroy();\n  hostname_cache_free();\n  item_user_lock_free();\n  lex_free();\t\t\t\t/* Free some memory */\n  item_create_cleanup();\n  table_def_start_shutdown();\n  plugin_shutdown();\n  udf_free();\n  ha_end();\n  if (tc_log)\n    tc_log->close();\n  delegates_destroy();\n  xid_cache_free();\n  table_def_free();\n  mdl_destroy();\n  key_caches.delete_elements((void (*)(const char*, uchar*)) free_key_cache);\n  wt_end();\n  multi_keycache_free();\n  sp_cache_end();\n  free_status_vars();\n  end_thr_alarm(1);\t\t\t/* Free allocated memory */\n  my_free_open_file_info();\n  if (defaults_argv)\n    free_defaults(defaults_argv);\n  free_tmpdir(&mysql_tmpdir_list);\n  bitmap_free(&temp_pool);\n  free_max_user_conn();\n  free_global_user_stats();\n  free_global_client_stats();\n  free_global_table_stats();\n  free_global_index_stats();\n  delete_dynamic(&all_options);\n#ifdef HAVE_REPLICATION\n  end_slave_list();\n#endif\n  my_uuid_end();\n  delete binlog_filter;\n  delete rpl_filter;\n  end_ssl();\n#ifndef EMBEDDED_LIBRARY\n  vio_end();\n#endif /*!EMBEDDED_LIBRARY*/\n  my_regex_end();\n#if defined(ENABLED_DEBUG_SYNC)\n  /* End the debug sync facility. See debug_sync.cc. */\n  debug_sync_end();\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n  delete_pid_file(MYF(0));\n\n  if (print_message && my_default_lc_messages && server_start_time)\n    sql_print_information(ER_DEFAULT(ER_SHUTDOWN_COMPLETE),my_progname);\n  cleanup_errmsgs();\n  MYSQL_CALLBACK(thread_scheduler, end, ());\n  mysql_library_end();\n  finish_client_errs();\n  (void) my_error_unregister(ER_ERROR_FIRST, ER_ERROR_LAST); // finish server errs\n  DBUG_PRINT(\"quit\", (\"Error messages freed\"));\n  /* Tell main we are ready */\n  logger.cleanup_end();\n  sys_var_end();\n  my_atomic_rwlock_destroy(&global_query_id_lock);\n  my_atomic_rwlock_destroy(&thread_running_lock);\n  free_charsets();\n  mysql_mutex_lock(&LOCK_thread_count);\n  DBUG_PRINT(\"quit\", (\"got thread count lock\"));\n  ready_to_exit=1;\n  /* do the broadcast inside the lock to ensure that my_end() is not called */\n  mysql_cond_broadcast(&COND_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  /*\n    The following lines may never be executed as the main thread may have\n    killed us\n  */\n  DBUG_PRINT(\"quit\", (\"done with cleanup\"));\n} /* clean_up */\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  This is mainly needed when running with purify, but it's still nice to\n  know that all child threads have died when mysqld exits.\n*/\nstatic void wait_for_signal_thread_to_end()\n{\n  uint i;\n  /*\n    Wait up to 10 seconds for signal thread to die. We use this mainly to\n    avoid getting warnings that my_thread_end has not been called\n  */\n  for (i= 0 ; i < 100 && signal_thread_in_use; i++)\n  {\n    if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL) == ESRCH)\n      break;\n    my_sleep(100);\t\t\t\t// Give it time to die\n  }\n}\n#endif /*EMBEDDED_LIBRARY*/\n\nstatic void clean_up_mutexes()\n{\n  DBUG_ENTER(\"clean_up_mutexes\");\n  mysql_rwlock_destroy(&LOCK_grant);\n  mysql_mutex_destroy(&LOCK_thread_count);\n  mysql_mutex_destroy(&LOCK_status);\n  mysql_mutex_destroy(&LOCK_delayed_insert);\n  mysql_mutex_destroy(&LOCK_delayed_status);\n  mysql_mutex_destroy(&LOCK_delayed_create);\n  mysql_mutex_destroy(&LOCK_crypt);\n  mysql_mutex_destroy(&LOCK_user_conn);\n  mysql_mutex_destroy(&LOCK_connection_count);\n  mysql_mutex_destroy(&LOCK_stats);\n  mysql_mutex_destroy(&LOCK_global_user_client_stats);\n  mysql_mutex_destroy(&LOCK_global_table_stats);\n  mysql_mutex_destroy(&LOCK_global_index_stats);\n#ifdef HAVE_OPENSSL\n  mysql_mutex_destroy(&LOCK_des_key_file);\n#ifndef HAVE_YASSL\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_destroy(&openssl_stdlocks[i].lock);\n  OPENSSL_free(openssl_stdlocks);\n#endif /* HAVE_YASSL */\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_REPLICATION\n  mysql_mutex_destroy(&LOCK_rpl_status);\n  mysql_cond_destroy(&COND_rpl_status);\n#endif /* HAVE_REPLICATION */\n  mysql_mutex_destroy(&LOCK_active_mi);\n  mysql_rwlock_destroy(&LOCK_sys_init_connect);\n  mysql_rwlock_destroy(&LOCK_sys_init_slave);\n  mysql_mutex_destroy(&LOCK_global_system_variables);\n  mysql_rwlock_destroy(&LOCK_system_variables_hash);\n  mysql_mutex_destroy(&LOCK_short_uuid_generator);\n  mysql_mutex_destroy(&LOCK_prepared_stmt_count);\n  mysql_mutex_destroy(&LOCK_error_messages);\n  mysql_cond_destroy(&COND_thread_count);\n  mysql_cond_destroy(&COND_thread_cache);\n  mysql_cond_destroy(&COND_flush_thread_cache);\n  mysql_mutex_destroy(&LOCK_server_started);\n  mysql_cond_destroy(&COND_server_started);\n  mysql_mutex_destroy(&LOCK_prepare_ordered);\n  mysql_mutex_destroy(&LOCK_commit_ordered);\n  DBUG_VOID_RETURN;\n}\n\n\n/****************************************************************************\n** Init IP and UNIX socket\n****************************************************************************/\n\n#ifndef EMBEDDED_LIBRARY\nstatic void set_ports()\n{\n  char\t*env;\n  if (!mysqld_port && !opt_disable_networking)\n  {\t\t\t\t\t// Get port if not from commandline\n    mysqld_port= MYSQL_PORT;\n\n    /*\n      if builder specifically requested a default port, use that\n      (even if it coincides with our factory default).\n      only if they didn't do we check /etc/services (and, failing\n      on that, fall back to the factory default of 3306).\n      either default can be overridden by the environment variable\n      MYSQL_TCP_PORT, which in turn can be overridden with command\n      line options.\n    */\n\n#if MYSQL_PORT_DEFAULT == 0\n    struct  servent *serv_ptr;\n    if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n      mysqld_port= ntohs((u_short) serv_ptr->s_port); /* purecov: inspected */\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n      mysqld_port= (uint) atoi(env);\t\t/* purecov: inspected */\n  }\n  if (!mysqld_unix_port)\n  {\n#ifdef __WIN__\n    mysqld_unix_port= (char*) MYSQL_NAMEDPIPE;\n#else\n    mysqld_unix_port= (char*) MYSQL_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n      mysqld_unix_port= env;\t\t\t/* purecov: inspected */\n  }\n}\n\n/* Change to run as another user if started with --user */\n\nstatic struct passwd *check_user(const char *user)\n{\n#if !defined(__WIN__)\n  struct passwd *tmp_user_info;\n  uid_t user_id= geteuid();\n\n  // Don't bother if we aren't superuser\n  if (user_id)\n  {\n    if (user)\n    {\n      /* Don't give a warning, if real user is same as given with --user */\n      /* purecov: begin tested */\n      tmp_user_info= getpwnam(user);\n      if ((!tmp_user_info || user_id != tmp_user_info->pw_uid) &&\n\t  global_system_variables.log_warnings)\n        sql_print_warning(\n                    \"One can only use the --user switch if running as root\\n\");\n      /* purecov: end */\n    }\n    return NULL;\n  }\n  if (!user)\n  {\n    if (!opt_bootstrap && !opt_help)\n    {\n      sql_print_error(\"Fatal error: Please consult the Knowledge Base \"\n                      \"to find out how to run mysqld as root!\\n\");\n      unireg_abort(1);\n    }\n    return NULL;\n  }\n  /* purecov: begin tested */\n  if (!strcmp(user,\"root\"))\n    return NULL;                        // Avoid problem with dynamic libraries\n\n  if (!(tmp_user_info= getpwnam(user)))\n  {\n    // Allow a numeric uid to be used\n    const char *pos;\n    for (pos= user; my_isdigit(mysqld_charset,*pos); pos++) ;\n    if (*pos)                                   // Not numeric id\n      goto err;\n    if (!(tmp_user_info= getpwuid(atoi(user))))\n      goto err;\n  }\n\n  return tmp_user_info;\n  /* purecov: end */\n\nerr:\n  sql_print_error(\"Fatal error: Can't change to run as user '%s' ;  Please check that the user exists!\\n\",user);\n  unireg_abort(1);\n#endif\n  return NULL;\n}\n\nstatic inline void allow_coredumps()\n{\n#ifdef PR_SET_DUMPABLE\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* inform kernel that process is dumpable */\n    (void) prctl(PR_SET_DUMPABLE, 1);\n  }\n#endif\n}\n\n\nstatic void set_user(const char *user, struct passwd *user_info_arg)\n{\n  /* purecov: begin tested */\n#if !defined(__WIN__)\n  DBUG_ASSERT(user_info_arg != 0);\n#ifdef HAVE_INITGROUPS\n  /*\n    We can get a SIGSEGV when calling initgroups() on some systems when NSS\n    is configured to use LDAP and the server is statically linked.  We set\n    calling_initgroups as a flag to the SIGSEGV handler that is then used to\n    output a specific message to help the user resolve this problem.\n  */\n  calling_initgroups= 1;\n  initgroups((char*) user, user_info_arg->pw_gid);\n  calling_initgroups= 0;\n#endif\n  if (setgid(user_info_arg->pw_gid) == -1)\n  {\n    sql_perror(\"setgid\");\n    unireg_abort(1);\n  }\n  if (setuid(user_info_arg->pw_uid) == -1)\n  {\n    sql_perror(\"setuid\");\n    unireg_abort(1);\n  }\n  allow_coredumps();\n#endif\n  /* purecov: end */\n}\n\n\nstatic void set_effective_user(struct passwd *user_info_arg)\n{\n#if !defined(__WIN__)\n  DBUG_ASSERT(user_info_arg != 0);\n  if (setregid((gid_t)-1, user_info_arg->pw_gid) == -1)\n  {\n    sql_perror(\"setregid\");\n    unireg_abort(1);\n  }\n  if (setreuid((uid_t)-1, user_info_arg->pw_uid) == -1)\n  {\n    sql_perror(\"setreuid\");\n    unireg_abort(1);\n  }\n  allow_coredumps();\n#endif\n}\n\n\n/** Change root user if started with @c --chroot . */\nstatic void set_root(const char *path)\n{\n#if !defined(__WIN__)\n  if (chroot(path) == -1)\n  {\n    sql_perror(\"chroot\");\n    unireg_abort(1);\n  }\n  my_setwd(\"/\", MYF(0));\n#endif\n}\n\n/**\n   Activate usage of a tcp port\n*/\n\nstatic my_socket activate_tcp_port(uint port)\n{\n  struct addrinfo *ai, *a;\n  struct addrinfo hints;\n  int error;\n  int\targ;\n  char port_buf[NI_MAXSERV];\n  my_socket ip_sock= INVALID_SOCKET;\n  DBUG_ENTER(\"activate_tcp_port\");\n  DBUG_PRINT(\"general\",(\"IP Socket is %d\",port));\n\n  bzero(&hints, sizeof (hints));\n  hints.ai_flags= AI_PASSIVE;\n  hints.ai_socktype= SOCK_STREAM;\n  hints.ai_family= AF_UNSPEC;\n\n  my_snprintf(port_buf, NI_MAXSERV, \"%d\", port);\n  error= getaddrinfo(my_bind_addr_str, port_buf, &hints, &ai);\n  if (error != 0)\n  {\n    DBUG_PRINT(\"error\",(\"Got error: %d from getaddrinfo()\", error));\n    sql_perror(ER_DEFAULT(ER_IPSOCK_ERROR));  /* purecov: tested */\n    unireg_abort(1);\t\t\t\t/* purecov: tested */\n  }\n\n  for (a= ai; a != NULL; a= a->ai_next)\n  {\n    ip_sock= socket(a->ai_family, a->ai_socktype, a->ai_protocol);\n      \n    char ip_addr[INET6_ADDRSTRLEN];\n\n    if (vio_get_normalized_ip_string(a->ai_addr, a->ai_addrlen,\n                                     ip_addr, sizeof (ip_addr)))\n    {\n      ip_addr[0]= 0;\n    }\n\n    if (ip_sock == INVALID_SOCKET)\n    {\n      sql_print_error(\"Failed to create a socket for %s '%s': errno: %d.\",\n                      (a->ai_family == AF_INET) ? \"IPv4\" : \"IPv6\",\n                      (const char *) ip_addr,\n                      (int) socket_errno);\n    }\n    else \n    {\n      sql_print_information(\"Server socket created on IP: '%s'.\",\n                          (const char *) ip_addr);\n      break;\n    }\n  }\n\n  if (ip_sock == INVALID_SOCKET)\n  {\n    DBUG_PRINT(\"error\",(\"Got error: %d from socket()\",socket_errno));\n    sql_perror(ER_DEFAULT(ER_IPSOCK_ERROR));  /* purecov: tested */\n    unireg_abort(1);\t\t\t\t/* purecov: tested */\n  }\n\n#ifndef __WIN__\n  /*\n    We should not use SO_REUSEADDR on windows as this would enable a\n    user to open two mysqld servers with the same TCP/IP port.\n  */\n  arg= 1;\n  (void) setsockopt(ip_sock,SOL_SOCKET,SO_REUSEADDR,(char*)&arg,sizeof(arg));\n#endif /* __WIN__ */\n\n#ifdef IPV6_V6ONLY\n   /*\n     For interoperability with older clients, IPv6 socket should\n     listen on both IPv6 and IPv4 wildcard addresses.\n     Turn off IPV6_V6ONLY option.\n\n     NOTE: this will work starting from Windows Vista only.\n     On Windows XP dual stack is not available, so it will not\n     listen on the corresponding IPv4-address.\n   */\n  if (a->ai_family == AF_INET6)\n  {\n    arg= 0;\n    (void) setsockopt(ip_sock, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,\n              sizeof(arg));\n  }\n#endif\n  /*\n    Sometimes the port is not released fast enough when stopping and\n    restarting the server. This happens quite often with the test suite\n    on busy Linux systems. Retry to bind the address at these intervals:\n    Sleep intervals: 1, 2, 4,  6,  9, 13, 17, 22, ...\n    Retry at second: 1, 3, 7, 13, 22, 35, 52, 74, ...\n    Limit the sequence by mysqld_port_timeout (set --port-open-timeout=#).\n  */\n  int ret;\n  uint waited, retry, this_wait;\n  for (waited= 0, retry= 1; ; retry++, waited+= this_wait)\n  {\n    if (((ret= bind(ip_sock, a->ai_addr, a->ai_addrlen)) >= 0 ) ||\n        (socket_errno != SOCKET_EADDRINUSE) ||\n        (waited >= mysqld_port_timeout))\n      break;\n    sql_print_information(\"Retrying bind on TCP/IP port %u\", port);\n    this_wait= retry * retry / 3 + 1;\n    sleep(this_wait);\n  }\n  freeaddrinfo(ai);\n  if (ret < 0)\n  {\n    char buff[100];\n    sprintf(buff, \"Can't start server: Bind on TCP/IP port. Got error: %d\",\n            (int) socket_errno);\n    sql_perror(buff);\n    sql_print_error(\"Do you already have another mysqld server running on \"\n                    \"port: %u ?\", port);\n    unireg_abort(1);\n  }\n  if (listen(ip_sock,(int) back_log) < 0)\n  {\n    sql_perror(\"Can't start server: listen() on TCP/IP port\");\n    sql_print_error(\"listen() on TCP/IP failed with error %d\",\n                    socket_errno);\n    unireg_abort(1);\n  }\n  DBUG_RETURN(ip_sock);\n}\n\nstatic void network_init(void)\n{\n#ifdef HAVE_SYS_UN_H\n  struct sockaddr_un\tUNIXaddr;\n  int\targ;\n#endif\n  DBUG_ENTER(\"network_init\");\n\n  if (MYSQL_CALLBACK_ELSE(thread_scheduler, init, (), 0))\n    unireg_abort(1);\t\t\t/* purecov: inspected */\n\n  set_ports();\n\n  if (report_port == 0)\n  {\n    report_port= mysqld_port;\n  }\n#ifndef DBUG_OFF\n  if (!opt_disable_networking)\n    DBUG_ASSERT(report_port != 0);\n#endif\n  if (!opt_disable_networking && !opt_bootstrap)\n  {\n    if (mysqld_port)\n      base_ip_sock= activate_tcp_port(mysqld_port);\n    if (mysqld_extra_port)\n      extra_ip_sock= activate_tcp_port(mysqld_extra_port);\n  }\n\n#ifdef _WIN32\n  /* create named pipe */\n  if (Service.IsNT() && mysqld_unix_port[0] && !opt_bootstrap &&\n      opt_enable_named_pipe)\n  {\n\n    strxnmov(pipe_name, sizeof(pipe_name)-1, \"\\\\\\\\.\\\\pipe\\\\\",\n\t     mysqld_unix_port, NullS);\n    bzero((char*) &saPipeSecurity, sizeof(saPipeSecurity));\n    bzero((char*) &sdPipeDescriptor, sizeof(sdPipeDescriptor));\n    if (!InitializeSecurityDescriptor(&sdPipeDescriptor,\n\t\t\t\t      SECURITY_DESCRIPTOR_REVISION))\n    {\n      sql_perror(\"Can't start server : Initialize security descriptor\");\n      unireg_abort(1);\n    }\n    if (!SetSecurityDescriptorDacl(&sdPipeDescriptor, TRUE, NULL, FALSE))\n    {\n      sql_perror(\"Can't start server : Set security descriptor\");\n      unireg_abort(1);\n    }\n    saPipeSecurity.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saPipeSecurity.lpSecurityDescriptor = &sdPipeDescriptor;\n    saPipeSecurity.bInheritHandle = FALSE;\n    if ((hPipe= CreateNamedPipe(pipe_name,\n        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,\n        PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,\n        PIPE_UNLIMITED_INSTANCES,\n        (int) global_system_variables.net_buffer_length,\n        (int) global_system_variables.net_buffer_length,\n        NMPWAIT_USE_DEFAULT_WAIT,\n        &saPipeSecurity)) == INVALID_HANDLE_VALUE)\n    {\n      sql_perror(\"Create named pipe failed\");\n      unireg_abort(1);\n    }\n  }\n#endif\n\n#if defined(HAVE_SYS_UN_H)\n  /*\n  ** Create the UNIX socket\n  */\n  if (mysqld_unix_port[0] && !opt_bootstrap)\n  {\n    DBUG_PRINT(\"general\",(\"UNIX Socket is %s\",mysqld_unix_port));\n\n    if (strlen(mysqld_unix_port) > (sizeof(UNIXaddr.sun_path) - 1))\n    {\n      sql_print_error(\"The socket file path is too long (> %u): %s\",\n                      (uint) sizeof(UNIXaddr.sun_path) - 1, mysqld_unix_port);\n      unireg_abort(1);\n    }\n    if ((unix_sock= socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n    {\n      sql_perror(\"Can't start server : UNIX Socket \"); /* purecov: inspected */\n      unireg_abort(1);\t\t\t\t/* purecov: inspected */\n    }\n    bzero((char*) &UNIXaddr, sizeof(UNIXaddr));\n    UNIXaddr.sun_family = AF_UNIX;\n    strmov(UNIXaddr.sun_path, mysqld_unix_port);\n    (void) unlink(mysqld_unix_port);\n    arg= 1;\n    (void) setsockopt(unix_sock,SOL_SOCKET,SO_REUSEADDR,(char*)&arg,\n\t\t      sizeof(arg));\n    umask(0);\n    if (bind(unix_sock, reinterpret_cast<struct sockaddr *>(&UNIXaddr),\n\t     sizeof(UNIXaddr)) < 0)\n    {\n      sql_perror(\"Can't start server : Bind on unix socket\"); /* purecov: tested */\n      sql_print_error(\"Do you already have another mysqld server running on socket: %s ?\",mysqld_unix_port);\n      unireg_abort(1);\t\t\t\t\t/* purecov: tested */\n    }\n    umask(((~my_umask) & 0666));\n#if defined(S_IFSOCK) && defined(SECURE_SOCKETS)\n    (void) chmod(mysqld_unix_port,S_IFSOCK);\t/* Fix solaris 2.6 bug */\n#endif\n    if (listen(unix_sock,(int) back_log) < 0)\n      sql_print_warning(\"listen() on Unix socket failed with error %d\",\n\t\t      socket_errno);\n  }\n#endif\n  DBUG_PRINT(\"info\",(\"server started\"));\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Close a connection.\n\n  @param thd        Thread handle.\n  @param sql_errno  The error code to send before disconnect.\n\n  @note\n    For the connection that is doing shutdown, this is called twice\n*/\nvoid close_connection(THD *thd, uint sql_errno)\n{\n  DBUG_ENTER(\"close_connection\");\n\n  if (sql_errno)\n    net_send_error(thd, sql_errno, ER_DEFAULT(sql_errno), NULL);\n\n  thd->print_aborted_warning(3, sql_errno ? ER_DEFAULT(sql_errno)\n                                          : \"CLOSE_CONNECTION\");\n\n  thd->disconnect();\n\n  MYSQL_CONNECTION_DONE((int) sql_errno, thd->thread_id);\n\n  if (MYSQL_CONNECTION_DONE_ENABLED())\n  {\n    sleep(0); /* Workaround to avoid tailcall optimisation */\n  }\n  MYSQL_AUDIT_NOTIFY_CONNECTION_DISCONNECT(thd, sql_errno);\n  DBUG_VOID_RETURN;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/** Called when mysqld is aborted with ^C */\n/* ARGSUSED */\nextern \"C\" sig_handler end_mysqld_signal(int sig __attribute__((unused)))\n{\n  DBUG_ENTER(\"end_mysqld_signal\");\n  /* Don't call kill_mysql() if signal thread is not running */\n  if (signal_thread_in_use)\n    kill_mysql();                          // Take down mysqld nicely\n  DBUG_VOID_RETURN;\t\t\t\t/* purecov: deadcode */\n}\n\n\n/*\n  Cleanup THD object\n\n  SYNOPSIS\n    thd_cleanup()\n    thd\t\t Thread handler\n*/\n\nvoid thd_cleanup(THD *thd)\n{\n  thd->cleanup();\n}\n\n/*\n  Decrease number of connections\n\n  SYNOPSIS\n    dec_connection_count()\n*/\n\nvoid dec_connection_count(THD *thd)\n{\n  mysql_mutex_lock(&LOCK_connection_count);\n  (*thd->scheduler->connection_count)--;\n  mysql_mutex_unlock(&LOCK_connection_count);\n}\n\n\n/*\n  Unlink thd from global list of available connections and free thd\n\n  SYNOPSIS\n    unlink_thd()\n    thd\t\t Thread handler\n\n  NOTES\n    LOCK_thread_count is locked and left locked\n*/\n\nvoid unlink_thd(THD *thd)\n{\n  DBUG_ENTER(\"unlink_thd\");\n  DBUG_PRINT(\"enter\", (\"thd: 0x%lx\", (long) thd));\n\n  thd_cleanup(thd);\n  dec_connection_count(thd);\n\n  thd->add_status_to_global();\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  thd->unlink();\n  /*\n    Used by binlog_reset_master.  It would be cleaner to use\n    DEBUG_SYNC here, but that's not possible because the THD's debug\n    sync feature has been shut down at this point.\n  */\n  DBUG_EXECUTE_IF(\"sleep_after_lock_thread_count_before_delete_thd\", sleep(5););\n  if (unlikely(abort_loop))\n  {\n    /*\n      During shutdown, we have to delete thd inside the mutex\n      to not refer to mutexes that may be deleted during shutdown\n    */\n    delete thd;\n    thd= 0;\n  }\n  thread_count--;\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  delete thd;\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Store thread in cache for reuse by new connections\n\n  SYNOPSIS\n    cache_thread()\n\n  NOTES\n    LOCK_thread_count has to be locked\n\n  RETURN\n    0  Thread was not put in cache\n    1  Thread is to be reused by new connection.\n       (ie, caller should return, not abort with pthread_exit())\n*/\n\n\nstatic bool cache_thread()\n{\n  mysql_mutex_assert_owner(&LOCK_thread_count);\n  if (cached_thread_count < thread_cache_size &&\n      ! abort_loop && !kill_cached_threads)\n  {\n    /* Don't kill the thread, just put it in cache for reuse */\n    DBUG_PRINT(\"info\", (\"Adding thread to cache\"));\n    cached_thread_count++;\n\n#ifdef HAVE_PSI_INTERFACE\n    /*\n      Delete the instrumentation for the job that just completed,\n      before parking this pthread in the cache (blocked on COND_thread_cache).\n    */\n    if (likely(PSI_server != NULL))\n      PSI_server->delete_current_thread();\n#endif\n\n    while (!abort_loop && ! wake_thread && ! kill_cached_threads)\n      mysql_cond_wait(&COND_thread_cache, &LOCK_thread_count);\n    cached_thread_count--;\n    if (kill_cached_threads)\n      mysql_cond_signal(&COND_flush_thread_cache);\n    if (wake_thread)\n    {\n      THD *thd;\n      wake_thread--;\n      thd= thread_cache.get();\n      thd->thread_stack= (char*) &thd;          // For store_globals\n      (void) thd->store_globals();\n\n#ifdef HAVE_PSI_INTERFACE\n      /*\n        Create new instrumentation for the new THD job,\n        and attach it to this running pthread.\n      */\n      if (likely(PSI_server != NULL))\n      {\n        PSI_thread *psi= PSI_server->new_thread(key_thread_one_connection,\n                                                thd, thd->thread_id);\n        if (likely(psi != NULL))\n          PSI_server->set_thread(psi);\n      }\n#endif\n\n      /*\n        THD::mysys_var::abort is associated with physical thread rather\n        than with THD object. So we need to reset this flag before using\n        this thread for handling of new THD object/connection.\n      */\n      thd->mysys_var->abort= 0;\n      thd->thr_create_utime= microsecond_interval_timer();\n      thd->start_utime= thd->thr_create_utime;\n      threads.append(thd);\n      return(1);\n    }\n  }\n  return(0);\n}\n\n\n/*\n  End thread for the current connection\n\n  SYNOPSIS\n    one_thread_per_connection_end()\n    thd\t\t  Thread handler\n    put_in_cache  Store thread in cache, if there is room in it\n                  Normally this is true in all cases except when we got\n                  out of resources initializing the current thread\n\n  NOTES\n    If thread is cached, we will wait until thread is scheduled to be\n    reused and then we will return.\n    If thread is not cached, we end the thread.\n\n  RETURN\n    0    Signal to handle_one_connection to reuse connection\n*/\n\nbool one_thread_per_connection_end(THD *thd, bool put_in_cache)\n{\n  DBUG_ENTER(\"one_thread_per_connection_end\");\n  unlink_thd(thd);\n  /* Mark that current_thd is not valid anymore */\n  my_pthread_setspecific_ptr(THR_THD,  0);\n  if (put_in_cache)\n  {\n    mysql_mutex_lock(&LOCK_thread_count);\n    put_in_cache= cache_thread();\n    mysql_mutex_unlock(&LOCK_thread_count);\n    if (put_in_cache)\n      DBUG_RETURN(0);                             // Thread is reused\n  }\n\n  /* It's safe to broadcast outside a lock (COND... is not deleted here) */\n  DBUG_PRINT(\"signal\", (\"Broadcasting COND_thread_count\"));\n  DBUG_LEAVE;                                   // Must match DBUG_ENTER()\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  ERR_remove_state(0);\n#endif\n  my_thread_end();\n  mysql_cond_broadcast(&COND_thread_count);\n\n  pthread_exit(0);\n  return 0;                                     // Avoid compiler warnings\n}\n\n\nvoid flush_thread_cache()\n{\n  mysql_mutex_lock(&LOCK_thread_count);\n  kill_cached_threads++;\n  while (cached_thread_count)\n  {\n    mysql_cond_broadcast(&COND_thread_cache);\n    mysql_cond_wait(&COND_flush_thread_cache, &LOCK_thread_count);\n  }\n  kill_cached_threads--;\n  mysql_mutex_unlock(&LOCK_thread_count);\n}\n\n\n/******************************************************************************\n  Setup a signal thread with handles all signals.\n  Because Linux doesn't support schemas use a mutex to check that\n  the signal thread is ready before continuing\n******************************************************************************/\n\n#if defined(__WIN__)\n\n\n/*\n  On Windows, we use native SetConsoleCtrlHandler for handle events like Ctrl-C\n  with graceful shutdown.\n  Also, we do not use signal(), but SetUnhandledExceptionFilter instead - as it\n  provides possibility to pass the exception to just-in-time debugger, collect\n  dumps and potentially also the exception and thread context used to output\n  callstack.\n*/\n\nstatic BOOL WINAPI console_event_handler( DWORD type ) \n{\n  DBUG_ENTER(\"console_event_handler\");\n#ifndef EMBEDDED_LIBRARY\n  if(type == CTRL_C_EVENT)\n  {\n     /*\n       Do not shutdown before startup is finished and shutdown\n       thread is initialized. Otherwise there is a race condition \n       between main thread doing initialization and CTRL-C thread doing\n       cleanup, which can result into crash.\n     */\n#ifndef EMBEDDED_LIBRARY\n     if(hEventShutdown)\n       kill_mysql();\n     else\n#endif\n       sql_print_warning(\"CTRL-C ignored during startup\");\n     DBUG_RETURN(TRUE);\n  }\n#endif\n  DBUG_RETURN(FALSE);\n}\n\n\n\n\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n#define DEBUGGER_ATTACH_TIMEOUT 120\n/*\n  Wait for debugger to attach and break into debugger. If debugger is\n  not attached, resume after timeout.\n*/\nstatic void wait_for_debugger(int timeout_sec)\n{\n   if(!IsDebuggerPresent())\n   {\n     int i;\n     printf(\"Waiting for debugger to attach, pid=%u\\n\",GetCurrentProcessId());\n     fflush(stdout);\n     for(i= 0; i < timeout_sec; i++)\n     {\n       Sleep(1000);\n       if(IsDebuggerPresent())\n       {\n         /* Break into debugger */\n         __debugbreak();\n         return;\n       }\n     }\n     printf(\"pid=%u, debugger not attached after %d seconds, resuming\\n\",GetCurrentProcessId(),\n       timeout_sec);\n     fflush(stdout);\n   }\n}\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n\nLONG WINAPI my_unhandler_exception_filter(EXCEPTION_POINTERS *ex_pointers)\n{\n   static BOOL first_time= TRUE;\n   if(!first_time)\n   {\n     /*\n       This routine can be called twice, typically\n       when detaching in JIT debugger.\n       Return EXCEPTION_EXECUTE_HANDLER to terminate process.\n     */\n     return EXCEPTION_EXECUTE_HANDLER;\n   }\n   first_time= FALSE;\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n   /*\n    Unfortunately there is no clean way to debug unhandled exception filters,\n    as debugger does not stop there(also documented in MSDN) \n    To overcome, one could put a MessageBox, but this will not work in service.\n    Better solution is to print error message and sleep some minutes \n    until debugger is attached\n  */\n  wait_for_debugger(DEBUGGER_ATTACH_TIMEOUT);\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n  __try\n  {\n    my_set_exception_pointers(ex_pointers);\n    handle_fatal_signal(ex_pointers->ExceptionRecord->ExceptionCode);\n  }\n  __except(EXCEPTION_EXECUTE_HANDLER)\n  {\n    DWORD written;\n    const char msg[] = \"Got exception in exception handler!\\n\";\n    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),msg, sizeof(msg)-1, \n      &written,NULL);\n  }\n  /*\n    Return EXCEPTION_CONTINUE_SEARCH to give JIT debugger\n    (drwtsn32 or vsjitdebugger) possibility to attach,\n    if JIT debugger is configured.\n    Windows Error reporting might generate a dump here.\n  */\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\n\nstatic void init_signals(void)\n{\n  if(opt_console)\n    SetConsoleCtrlHandler(console_event_handler,TRUE);\n\n    /* Avoid MessageBox()es*/\n  _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\n   /*\n     Do not use SEM_NOGPFAULTERRORBOX in the following SetErrorMode (),\n     because it would prevent JIT debugger and Windows error reporting\n     from working. We need WER or JIT-debugging, since our own unhandled\n     exception filter is not guaranteed to work in all situation\n     (like heap corruption or stack overflow)\n   */\n  SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS\n                               | SEM_NOOPENFILEERRORBOX);\n  SetUnhandledExceptionFilter(my_unhandler_exception_filter);\n}\n\n\nstatic void start_signal_handler(void)\n{\n#ifndef EMBEDDED_LIBRARY\n  // Save vm id of this process\n  if (!opt_bootstrap)\n    create_pid_file();\n#endif /* EMBEDDED_LIBRARY */\n}\n\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /* __WIN__ */\n\n\n#if BACKTRACE_DEMANGLE\n#include <cxxabi.h>\nextern \"C\" char *my_demangle(const char *mangled_name, int *status)\n{\n  return abi::__cxa_demangle(mangled_name, NULL, NULL, status);\n}\n#endif\n\n\n/*\n  pthread_attr_setstacksize() without so much platform-dependency\n\n  Return: The actual stack size if possible.\n*/\n\n#ifndef EMBEDDED_LIBRARY\nstatic size_t my_setstacksize(pthread_attr_t *attr, size_t stacksize)\n{\n  size_t guard_size __attribute__((unused))= 0;\n\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    On IA64, half of the requested stack size is used for \"normal stack\"\n    and half for \"register stack\".  The space measured by check_stack_overrun\n    is the \"normal stack\", so double the request to make sure we have the\n    caller-expected amount of normal stack.\n\n    NOTE: there is no guarantee that the register stack can't grow faster\n    than normal stack, so it's very unclear that we won't dump core due to\n    stack overrun despite check_stack_overrun's efforts.  Experimentation\n    shows that in the execution_constants test, the register stack grows\n    less than half as fast as normal stack, but perhaps other scenarios are\n    less forgiving.  If it turns out that more space is needed for the\n    register stack, that could be forced (rather inefficiently) by using a\n    multiplier higher than 2 here.\n  */\n  stacksize *= 2;\n#endif\n\n  /*\n    On many machines, the \"guard space\" is subtracted from the requested\n    stack size, and that space is quite large on some platforms.  So add\n    it to our request, if we can find out what it is.\n  */\n#ifdef HAVE_PTHREAD_ATTR_GETGUARDSIZE\n  if (pthread_attr_getguardsize(attr, &guard_size))\n    guard_size = 0;\t\t/* if can't find it out, treat as 0 */\n#endif\n\n  pthread_attr_setstacksize(attr, stacksize + guard_size);\n\n  /* Retrieve actual stack size if possible */\n#ifdef HAVE_PTHREAD_ATTR_GETSTACKSIZE\n  {\n    size_t real_stack_size= 0;\n    /* We must ignore real_stack_size = 0 as Solaris 2.9 can return 0 here */\n    if (pthread_attr_getstacksize(attr, &real_stack_size) == 0 &&\n\treal_stack_size > guard_size)\n    {\n      real_stack_size -= guard_size;\n      if (real_stack_size < stacksize)\n      {\n\tif (global_system_variables.log_warnings)\n          sql_print_warning(\"Asked for %zu thread stack, but got %zu\",\n                            stacksize, real_stack_size);\n\tstacksize= real_stack_size;\n      }\n    }\n  }\n#endif /* !EMBEDDED_LIBRARY */\n\n#if defined(__ia64__) || defined(__ia64)\n  stacksize /= 2;\n#endif\n  return stacksize;\n}\n#endif\n\n\n#if !defined(__WIN__)\n#ifndef SA_RESETHAND\n#define SA_RESETHAND 0\n#endif /* SA_RESETHAND */\n#ifndef SA_NODEFER\n#define SA_NODEFER 0\n#endif /* SA_NODEFER */\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void init_signals(void)\n{\n  sigset_t set;\n  struct sigaction sa;\n  DBUG_ENTER(\"init_signals\");\n\n  my_sigset(THR_SERVER_ALARM,print_signal_warning); // Should never be called!\n\n  if (opt_stack_trace || (test_flags & TEST_CORE_ON_SIGNAL))\n  {\n    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n    sigemptyset(&sa.sa_mask);\n    sigprocmask(SIG_SETMASK,&sa.sa_mask,NULL);\n\n    my_init_stacktrace();\n#if defined(__amiga__)\n    sa.sa_handler=(void(*)())handle_fatal_signal;\n#else\n    sa.sa_handler=handle_fatal_signal;\n#endif\n    sigaction(SIGSEGV, &sa, NULL);\n    sigaction(SIGABRT, &sa, NULL);\n#ifdef SIGBUS\n    sigaction(SIGBUS, &sa, NULL);\n#endif\n    sigaction(SIGILL, &sa, NULL);\n    sigaction(SIGFPE, &sa, NULL);\n  }\n\n#ifdef HAVE_GETRLIMIT\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* Change limits so that we will get a core file */\n    STRUCT_RLIMIT rl;\n    rl.rlim_cur = rl.rlim_max = (rlim_t) RLIM_INFINITY;\n    if (setrlimit(RLIMIT_CORE, &rl) && global_system_variables.log_warnings)\n      sql_print_warning(\"setrlimit could not change the size of core files to 'infinity';  We may not be able to generate a core file on signals\");\n  }\n#endif\n  (void) sigemptyset(&set);\n  my_sigset(SIGPIPE,SIG_IGN);\n  sigaddset(&set,SIGPIPE);\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  sigaddset(&set,SIGQUIT);\n  sigaddset(&set,SIGHUP);\n#endif\n  sigaddset(&set,SIGTERM);\n\n  /* Fix signals if blocked by parents (can happen on Mac OS X) */\n  sigemptyset(&sa.sa_mask);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGTERM, &sa, (struct sigaction*) 0);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGHUP, &sa, (struct sigaction*) 0);\n  if (thd_lib_detected != THD_LIB_LT)\n    sigaddset(&set,THR_SERVER_ALARM);\n  if (test_flags & TEST_SIGINT)\n  {\n    /* Allow SIGINT to break mysqld. This is for debugging with --gdb */\n    my_sigset(SIGINT, end_mysqld_signal);\n    sigdelset(&set, SIGINT);\n  }\n  else\n  {\n    sigaddset(&set,SIGINT);\n#ifdef SIGTSTP\n    sigaddset(&set,SIGTSTP);\n#endif\n  }\n\n  sigprocmask(SIG_SETMASK,&set,NULL);\n  pthread_sigmask(SIG_SETMASK,&set,NULL);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void start_signal_handler(void)\n{\n  int error;\n  pthread_attr_t thr_attr;\n  DBUG_ENTER(\"start_signal_handler\");\n\n  (void) pthread_attr_init(&thr_attr);\n  pthread_attr_setscope(&thr_attr,PTHREAD_SCOPE_SYSTEM);\n  (void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED);\n  (void) my_setstacksize(&thr_attr,my_thread_stack_size);\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  if ((error= mysql_thread_create(key_thread_signal_hand,\n                                  &signal_thread, &thr_attr, signal_hand, 0)))\n  {\n    sql_print_error(\"Can't create interrupt-thread (error %d, errno: %d)\",\n\t\t    error,errno);\n    exit(1);\n  }\n  mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  (void) pthread_attr_destroy(&thr_attr);\n  DBUG_VOID_RETURN;\n}\n\n\n/** This threads handles all signals and alarms. */\n/* ARGSUSED */\npthread_handler_t signal_hand(void *arg __attribute__((unused)))\n{\n  sigset_t set;\n  int sig;\n  my_thread_init();\t\t\t\t// Init new thread\n  DBUG_ENTER(\"signal_hand\");\n  signal_thread_in_use= 1;\n\n  /*\n    Setup alarm handler\n    This should actually be '+ max_number_of_slaves' instead of +10,\n    but the +10 should be quite safe.\n  */\n  init_thr_alarm(thread_scheduler->max_threads + extra_max_connections +\n\t\t global_system_variables.max_insert_delayed_threads + 10);\n  if (test_flags & TEST_SIGINT)\n  {\n    /* Allow SIGINT to break mysqld. This is for debugging with --gdb */\n    (void) sigemptyset(&set);\n    (void) sigaddset(&set,SIGINT);\n    (void) pthread_sigmask(SIG_UNBLOCK,&set,NULL);\n  }\n  (void) sigemptyset(&set);\t\t\t// Setup up SIGINT for debug\n#ifdef USE_ONE_SIGNAL_HAND\n  (void) sigaddset(&set,THR_SERVER_ALARM);\t// For alarms\n#endif\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  (void) sigaddset(&set,SIGQUIT);\n  (void) sigaddset(&set,SIGHUP);\n#endif\n  (void) sigaddset(&set,SIGTERM);\n  (void) sigaddset(&set,SIGTSTP);\n\n  /* Save pid to this process (or thread on Linux) */\n  if (!opt_bootstrap)\n    create_pid_file();\n\n  /*\n    signal to start_signal_handler that we are ready\n    This works by waiting for start_signal_handler to free mutex,\n    after which we signal it that we are ready.\n    At this pointer there is no other threads running, so there\n    should not be any other mysql_cond_signal() calls.\n  */\n  mysql_mutex_lock(&LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  mysql_cond_broadcast(&COND_thread_count);\n\n  (void) pthread_sigmask(SIG_BLOCK,&set,NULL);\n  for (;;)\n  {\n    int error;\t\t\t\t\t// Used when debugging\n    if (shutdown_in_progress && !abort_loop)\n    {\n      sig= SIGTERM;\n      error=0;\n    }\n    else\n      while ((error=my_sigwait(&set,&sig)) == EINTR) ;\n    if (cleanup_done)\n    {\n      DBUG_PRINT(\"quit\",(\"signal_handler: calling my_thread_end()\"));\n      my_thread_end();\n      DBUG_LEAVE;                               // Must match DBUG_ENTER()\n      signal_thread_in_use= 0;\n      pthread_exit(0);\t\t\t\t// Safety\n      return 0;                                 // Avoid compiler warnings\n    }\n    switch (sig) {\n    case SIGTERM:\n    case SIGQUIT:\n    case SIGKILL:\n#ifdef EXTRA_DEBUG\n      sql_print_information(\"Got signal %d to shutdown mysqld\",sig);\n#endif\n      /* switch to the old log message processing */\n      logger.set_handlers(LOG_FILE, opt_slow_log ? LOG_FILE:LOG_NONE,\n                          opt_log ? LOG_FILE:LOG_NONE);\n      DBUG_PRINT(\"info\",(\"Got signal: %d  abort_loop: %d\",sig,abort_loop));\n      if (!abort_loop)\n      {\n\tabort_loop=1;\t\t\t\t// mark abort for threads\n#ifdef HAVE_PSI_INTERFACE\n        /* Delete the instrumentation for the signal thread */\n        if (likely(PSI_server != NULL))\n          PSI_server->delete_current_thread();\n#endif\n#ifdef USE_ONE_SIGNAL_HAND\n\tpthread_t tmp;\n        if ((error= mysql_thread_create(0, /* Not instrumented */\n                                        &tmp, &connection_attrib,\n                                        kill_server_thread,\n                                        (void*) &sig)))\n          sql_print_error(\"Can't create thread to kill server (errno= %d)\",\n                          error);\n#else\n\tkill_server((void*) sig);\t// MIT THREAD has a alarm thread\n#endif\n      }\n      break;\n    case SIGHUP:\n      if (!abort_loop)\n      {\n        int not_used;\n\tmysql_print_status();\t\t// Print some debug info\n\treload_acl_and_cache((THD*) 0,\n\t\t\t     (REFRESH_LOG | REFRESH_TABLES | REFRESH_FAST |\n\t\t\t      REFRESH_GRANT |\n\t\t\t      REFRESH_THREADS | REFRESH_HOSTS),\n\t\t\t     (TABLE_LIST*) 0, &not_used); // Flush logs\n      }\n      /* reenable logs after the options were reloaded */\n      if (log_output_options & LOG_NONE)\n      {\n        logger.set_handlers(LOG_FILE,\n                            opt_slow_log ? LOG_TABLE : LOG_NONE,\n                            opt_log ? LOG_TABLE : LOG_NONE);\n      }\n      else\n      {\n        logger.set_handlers(LOG_FILE,\n                            opt_slow_log ? log_output_options : LOG_NONE,\n                            opt_log ? log_output_options : LOG_NONE);\n      }\n      break;\n#ifdef USE_ONE_SIGNAL_HAND\n    case THR_SERVER_ALARM:\n      process_alarm(sig);\t\t\t// Trigger alarms.\n      break;\n#endif\n    default:\n#ifdef EXTRA_DEBUG\n      sql_print_warning(\"Got signal: %d  error: %d\",sig,error); /* purecov: tested */\n#endif\n      break;\t\t\t\t\t/* purecov: tested */\n    }\n  }\n  return(0);\t\t\t\t\t/* purecov: deadcode */\n}\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /*!EMBEDDED_LIBRARY*/\n#endif\t/* __WIN__*/\n\n\n/**\n  All global error messages are sent here where the first one is stored\n  for the client.\n*/\n/* ARGSUSED */\nextern \"C\" void my_message_sql(uint error, const char *str, myf MyFlags);\n\nvoid my_message_sql(uint error, const char *str, myf MyFlags)\n{\n  THD *thd= current_thd;\n  MYSQL_ERROR::enum_warning_level level;\n  sql_print_message_func func;\n\n  DBUG_ENTER(\"my_message_sql\");\n  DBUG_PRINT(\"error\", (\"error: %u  message: '%s'  Flag: %d\", error, str, MyFlags));\n\n  DBUG_ASSERT(str != NULL);\n  DBUG_ASSERT(error != 0);\n\n  if (MyFlags & ME_JUST_INFO)\n  {\n    level= MYSQL_ERROR::WARN_LEVEL_NOTE;\n    func= sql_print_information;\n  }\n  else if (MyFlags & ME_JUST_WARNING)\n  {\n    level= MYSQL_ERROR::WARN_LEVEL_WARN;\n    func= sql_print_warning;\n  }\n  else\n  {\n    level= MYSQL_ERROR::WARN_LEVEL_ERROR;\n    func= sql_print_error;\n  }\n\n  if (thd)\n  {\n    if (MyFlags & ME_FATALERROR)\n      thd->is_fatal_error= 1;\n    (void) thd->raise_condition(error, NULL, level, str);\n  }\n  else\n    mysql_audit_general(0, MYSQL_AUDIT_GENERAL_ERROR, error, str);\n\n  /* When simulating OOM, skip writing to error log to avoid mtr errors */\n  DBUG_EXECUTE_IF(\"simulate_out_of_memory\", DBUG_VOID_RETURN;);\n\n  if (!thd || thd->log_all_errors || (MyFlags & ME_NOREFRESH))\n    (*func)(\"%s: %s\", my_progname_short, str); /* purecov: inspected */\n  DBUG_VOID_RETURN;\n}\n\n\n#ifndef EMBEDDED_LIBRARY\nextern \"C\" void *my_str_malloc_mysqld(size_t size);\nextern \"C\" void my_str_free_mysqld(void *ptr);\n\nvoid *my_str_malloc_mysqld(size_t size)\n{\n  return my_malloc(size, MYF(MY_FAE));\n}\n\n\nvoid my_str_free_mysqld(void *ptr)\n{\n  my_free(ptr);\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n#ifdef __WIN__\n\npthread_handler_t handle_shutdown(void *arg)\n{\n  MSG msg;\n  my_thread_init();\n\n  /* this call should create the message queue for this thread */\n  PeekMessage(&msg, NULL, 1, 65534,PM_NOREMOVE);\n#if !defined(EMBEDDED_LIBRARY)\n  if (WaitForSingleObject(hEventShutdown,INFINITE)==WAIT_OBJECT_0)\n#endif /* EMBEDDED_LIBRARY */\n     kill_server(MYSQL_KILL_SIGNAL);\n  return 0;\n}\n#endif\n\n#include <mysqld_default_groups.h>\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nstatic const int load_default_groups_sz=\nsizeof(load_default_groups)/sizeof(load_default_groups[0]);\n#endif\n\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  This function is used to check for stack overrun for pathological\n  cases of  regular expressions and 'like' expressions.\n  The call to current_thd is  quite expensive, so we try to avoid it\n  for the normal cases.\n  The size of  each stack frame for the wildcmp() routines is ~128 bytes,\n  so checking  *every* recursive call is not necessary.\n */\nextern \"C\" int\ncheck_enough_stack_size(int recurse_level)\n{\n  uchar stack_top;\n  if (recurse_level % 16 != 0)\n    return 0;\n\n  THD *my_thd= current_thd;\n  if (my_thd != NULL)\n    return check_stack_overrun(my_thd, STACK_MIN_SIZE * 2, &stack_top);\n  return 0;\n}\n#endif\n\n\n/**\n  Initialize one of the global date/time format variables.\n\n  @param format_type\t\tWhat kind of format should be supported\n  @param var_ptr\t\tPointer to variable that should be updated\n\n  @retval\n    0 ok\n  @retval\n    1 error\n*/\n\nstatic bool init_global_datetime_format(timestamp_type format_type,\n                                        DATE_TIME_FORMAT *format)\n{\n  /*\n    Get command line option\n    format->format.str is already set by my_getopt\n  */\n  format->format.length= strlen(format->format.str);\n\n  if (parse_date_time_format(format_type, format))\n  {\n    fprintf(stderr, \"Wrong date/time format specifier: %s\\n\",\n            format->format.str);\n    return true;\n  }\n  return false;\n}\n\nSHOW_VAR com_status_vars[]= {\n  {\"admin_commands\",       (char*) offsetof(STATUS_VAR, com_other), SHOW_LONG_STATUS},\n  {\"alter_db\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB]), SHOW_LONG_STATUS},\n  {\"alter_db_upgrade\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB_UPGRADE]), SHOW_LONG_STATUS},\n  {\"alter_event\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_EVENT]), SHOW_LONG_STATUS},\n  {\"alter_function\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_FUNCTION]), SHOW_LONG_STATUS},\n  {\"alter_procedure\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"alter_server\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_SERVER]), SHOW_LONG_STATUS},\n  {\"alter_table\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLE]), SHOW_LONG_STATUS},\n  {\"alter_tablespace\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLESPACE]), SHOW_LONG_STATUS},\n  {\"analyze\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ANALYZE]), SHOW_LONG_STATUS},\n  {\"assign_to_keycache\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ASSIGN_TO_KEYCACHE]), SHOW_LONG_STATUS},\n  {\"begin\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BEGIN]), SHOW_LONG_STATUS},\n  {\"binlog\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BINLOG_BASE64_EVENT]), SHOW_LONG_STATUS},\n  {\"call_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CALL]), SHOW_LONG_STATUS},\n  {\"change_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_DB]), SHOW_LONG_STATUS},\n  {\"change_master\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_MASTER]), SHOW_LONG_STATUS},\n  {\"check\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECK]), SHOW_LONG_STATUS},\n  {\"checksum\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECKSUM]), SHOW_LONG_STATUS},\n  {\"commit\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_COMMIT]), SHOW_LONG_STATUS},\n  {\"create_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_DB]), SHOW_LONG_STATUS},\n  {\"create_event\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_EVENT]), SHOW_LONG_STATUS},\n  {\"create_function\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SPFUNCTION]), SHOW_LONG_STATUS},\n  {\"create_index\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_INDEX]), SHOW_LONG_STATUS},\n  {\"create_procedure\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"create_server\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SERVER]), SHOW_LONG_STATUS},\n  {\"create_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TABLE]), SHOW_LONG_STATUS},\n  {\"create_trigger\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TRIGGER]), SHOW_LONG_STATUS},\n  {\"create_udf\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_FUNCTION]), SHOW_LONG_STATUS},\n  {\"create_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_USER]), SHOW_LONG_STATUS},\n  {\"create_view\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_VIEW]), SHOW_LONG_STATUS},\n  {\"dealloc_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DEALLOCATE_PREPARE]), SHOW_LONG_STATUS},\n  {\"delete\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE]), SHOW_LONG_STATUS},\n  {\"delete_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE_MULTI]), SHOW_LONG_STATUS},\n  {\"do\",                   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DO]), SHOW_LONG_STATUS},\n  {\"drop_db\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_DB]), SHOW_LONG_STATUS},\n  {\"drop_event\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_EVENT]), SHOW_LONG_STATUS},\n  {\"drop_function\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_FUNCTION]), SHOW_LONG_STATUS},\n  {\"drop_index\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_INDEX]), SHOW_LONG_STATUS},\n  {\"drop_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"drop_server\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_SERVER]), SHOW_LONG_STATUS},\n  {\"drop_table\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TABLE]), SHOW_LONG_STATUS},\n  {\"drop_trigger\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TRIGGER]), SHOW_LONG_STATUS},\n  {\"drop_user\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_USER]), SHOW_LONG_STATUS},\n  {\"drop_view\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_VIEW]), SHOW_LONG_STATUS},\n  {\"empty_query\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EMPTY_QUERY]), SHOW_LONG_STATUS},\n  {\"execute_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EXECUTE]), SHOW_LONG_STATUS},\n  {\"flush\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_FLUSH]), SHOW_LONG_STATUS},\n  {\"grant\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_GRANT]), SHOW_LONG_STATUS},\n  {\"ha_close\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_CLOSE]), SHOW_LONG_STATUS},\n  {\"ha_open\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_OPEN]), SHOW_LONG_STATUS},\n  {\"ha_read\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_READ]), SHOW_LONG_STATUS},\n  {\"help\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HELP]), SHOW_LONG_STATUS},\n  {\"insert\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT]), SHOW_LONG_STATUS},\n  {\"insert_select\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT_SELECT]), SHOW_LONG_STATUS},\n  {\"install_plugin\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSTALL_PLUGIN]), SHOW_LONG_STATUS},\n  {\"kill\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_KILL]), SHOW_LONG_STATUS},\n  {\"load\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD]), SHOW_LONG_STATUS},\n  {\"lock_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOCK_TABLES]), SHOW_LONG_STATUS},\n  {\"optimize\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_OPTIMIZE]), SHOW_LONG_STATUS},\n  {\"preload_keys\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PRELOAD_KEYS]), SHOW_LONG_STATUS},\n  {\"prepare_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PREPARE]), SHOW_LONG_STATUS},\n  {\"purge\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE]), SHOW_LONG_STATUS},\n  {\"purge_before_date\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE_BEFORE]), SHOW_LONG_STATUS},\n  {\"release_savepoint\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RELEASE_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"rename_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_TABLE]), SHOW_LONG_STATUS},\n  {\"rename_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_USER]), SHOW_LONG_STATUS},\n  {\"repair\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPAIR]), SHOW_LONG_STATUS},\n  {\"replace\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE]), SHOW_LONG_STATUS},\n  {\"replace_select\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE_SELECT]), SHOW_LONG_STATUS},\n  {\"reset\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESET]), SHOW_LONG_STATUS},\n  {\"resignal\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESIGNAL]), SHOW_LONG_STATUS},\n  {\"revoke\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE]), SHOW_LONG_STATUS},\n  {\"revoke_all\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE_ALL]), SHOW_LONG_STATUS},\n  {\"rollback\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK]), SHOW_LONG_STATUS},\n  {\"rollback_to_savepoint\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK_TO_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"savepoint\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"select\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SELECT]), SHOW_LONG_STATUS},\n  {\"set_option\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SET_OPTION]), SHOW_LONG_STATUS},\n  {\"show_authors\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_AUTHORS]), SHOW_LONG_STATUS},\n  {\"show_binlog_events\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOG_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_binlogs\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOGS]), SHOW_LONG_STATUS},\n  {\"show_charsets\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CHARSETS]), SHOW_LONG_STATUS},\n  {\"show_client_statistics\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CLIENT_STATS]), SHOW_LONG_STATUS},\n  {\"show_collations\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_COLLATIONS]), SHOW_LONG_STATUS},\n  {\"show_contributors\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CONTRIBUTORS]), SHOW_LONG_STATUS},\n  {\"show_create_db\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_DB]), SHOW_LONG_STATUS},\n  {\"show_create_event\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_EVENT]), SHOW_LONG_STATUS},\n  {\"show_create_func\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_FUNC]), SHOW_LONG_STATUS},\n  {\"show_create_proc\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_PROC]), SHOW_LONG_STATUS},\n  {\"show_create_table\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE]), SHOW_LONG_STATUS},\n  {\"show_create_trigger\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_TRIGGER]), SHOW_LONG_STATUS},\n  {\"show_databases\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_DATABASES]), SHOW_LONG_STATUS},\n  {\"show_engine_logs\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_LOGS]), SHOW_LONG_STATUS},\n  {\"show_engine_mutex\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_MUTEX]), SHOW_LONG_STATUS},\n  {\"show_engine_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_STATUS]), SHOW_LONG_STATUS},\n  {\"show_errors\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ERRORS]), SHOW_LONG_STATUS},\n  {\"show_events\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_fields\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FIELDS]), SHOW_LONG_STATUS},\n#ifndef DBUG_OFF\n  {\"show_function_code\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FUNC_CODE]), SHOW_LONG_STATUS},\n#endif\n  {\"show_function_status\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_FUNC]), SHOW_LONG_STATUS},\n  {\"show_grants\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_GRANTS]), SHOW_LONG_STATUS},\n  {\"show_index_statistics\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_INDEX_STATS]), SHOW_LONG_STATUS},\n  {\"show_keys\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_KEYS]), SHOW_LONG_STATUS},\n  {\"show_master_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_MASTER_STAT]), SHOW_LONG_STATUS},\n  {\"show_open_tables\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_OPEN_TABLES]), SHOW_LONG_STATUS},\n  {\"show_plugins\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PLUGINS]), SHOW_LONG_STATUS},\n  {\"show_privileges\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PRIVILEGES]), SHOW_LONG_STATUS},\n#ifndef DBUG_OFF\n  {\"show_procedure_code\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROC_CODE]), SHOW_LONG_STATUS},\n#endif\n  {\"show_procedure_status\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_PROC]), SHOW_LONG_STATUS},\n  {\"show_processlist\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROCESSLIST]), SHOW_LONG_STATUS},\n  {\"show_profile\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILE]), SHOW_LONG_STATUS},\n  {\"show_profiles\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILES]), SHOW_LONG_STATUS},\n  {\"show_relaylog_events\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_RELAYLOG_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_slave_hosts\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_HOSTS]), SHOW_LONG_STATUS},\n  {\"show_slave_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_STAT]), SHOW_LONG_STATUS},\n  {\"show_status\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS]), SHOW_LONG_STATUS},\n  {\"show_storage_engines\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STORAGE_ENGINES]), SHOW_LONG_STATUS},\n  {\"show_table_statistics\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATS]), SHOW_LONG_STATUS},\n  {\"show_table_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATUS]), SHOW_LONG_STATUS},\n  {\"show_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLES]), SHOW_LONG_STATUS},\n  {\"show_triggers\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TRIGGERS]), SHOW_LONG_STATUS},\n  {\"show_user_statistics\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_USER_STATS]), SHOW_LONG_STATUS},\n  {\"show_variables\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_VARIABLES]), SHOW_LONG_STATUS},\n  {\"show_warnings\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_WARNS]), SHOW_LONG_STATUS},\n  {\"signal\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SIGNAL]), SHOW_LONG_STATUS},\n  {\"slave_start\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_START]), SHOW_LONG_STATUS},\n  {\"slave_stop\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_STOP]), SHOW_LONG_STATUS},\n  {\"stmt_close\",           (char*) offsetof(STATUS_VAR, com_stmt_close), SHOW_LONG_STATUS},\n  {\"stmt_execute\",         (char*) offsetof(STATUS_VAR, com_stmt_execute), SHOW_LONG_STATUS},\n  {\"stmt_fetch\",           (char*) offsetof(STATUS_VAR, com_stmt_fetch), SHOW_LONG_STATUS},\n  {\"stmt_prepare\",         (char*) offsetof(STATUS_VAR, com_stmt_prepare), SHOW_LONG_STATUS},\n  {\"stmt_reprepare\",       (char*) offsetof(STATUS_VAR, com_stmt_reprepare), SHOW_LONG_STATUS},\n  {\"stmt_reset\",           (char*) offsetof(STATUS_VAR, com_stmt_reset), SHOW_LONG_STATUS},\n  {\"stmt_send_long_data\",  (char*) offsetof(STATUS_VAR, com_stmt_send_long_data), SHOW_LONG_STATUS},\n  {\"truncate\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_TRUNCATE]), SHOW_LONG_STATUS},\n  {\"uninstall_plugin\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNINSTALL_PLUGIN]), SHOW_LONG_STATUS},\n  {\"unlock_tables\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNLOCK_TABLES]), SHOW_LONG_STATUS},\n  {\"update\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE]), SHOW_LONG_STATUS},\n  {\"update_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE_MULTI]), SHOW_LONG_STATUS},\n  {\"xa_commit\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_COMMIT]),SHOW_LONG_STATUS},\n  {\"xa_end\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_END]),SHOW_LONG_STATUS},\n  {\"xa_prepare\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_PREPARE]),SHOW_LONG_STATUS},\n  {\"xa_recover\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_RECOVER]),SHOW_LONG_STATUS},\n  {\"xa_rollback\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_ROLLBACK]),SHOW_LONG_STATUS},\n  {\"xa_start\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_START]),SHOW_LONG_STATUS},\n  {NullS, NullS, SHOW_LONG}\n};\n\nstatic int init_common_variables()\n{\n  umask(((~my_umask) & 0666));\n  my_decimal_set_zero(&decimal_zero); // set decimal_zero constant;\n\n  tzset();\t\t\t// Set tzname\n\n  sf_leaking_memory= 0; // no memory leaks from now on\n\n  max_system_variables.pseudo_thread_id= (ulong)~0;\n  server_start_time= flush_status_time= my_time(0);\n  my_disable_copystat_in_redel= 1;\n\n  rpl_filter= new Rpl_filter;\n  binlog_filter= new Rpl_filter;\n  if (!rpl_filter || !binlog_filter)\n  {\n    sql_perror(\"Could not allocate replication and binlog filters\");\n    return 1;\n  }\n\n  if (init_thread_environment() ||\n      mysql_init_variables())\n    return 1;\n\n  if (ignore_db_dirs_init())\n    return 1;\n\n#ifdef HAVE_TZNAME\n  struct tm tm_tmp;\n  localtime_r(&server_start_time,&tm_tmp);\n  const char *tz_name=  tzname[tm_tmp.tm_isdst != 0 ? 1 : 0];\n#ifdef _WIN32\n  /*\n    Time zone name may be localized and contain non-ASCII characters,\n    Convert from ANSI encoding to UTF8.\n  */\n  wchar_t wtz_name[sizeof(system_time_zone)];\n  mbstowcs(wtz_name, tz_name, sizeof(system_time_zone)-1);\n  WideCharToMultiByte(CP_UTF8,0, wtz_name, -1, system_time_zone, \n    sizeof(system_time_zone) - 1, NULL, NULL);\n#else\n  strmake_buf(system_time_zone, tz_name);\n#endif /* _WIN32 */\n#endif /* HAVE_TZNAME */\n\n  /*\n    We set SYSTEM time zone as reasonable default and\n    also for failure of my_tz_init() and bootstrap mode.\n    If user explicitly set time zone with --default-time-zone\n    option we will change this value in my_tz_init().\n  */\n  global_system_variables.time_zone= my_tz_SYSTEM;\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Complete the mysql_bin_log initialization.\n    Instrumentation keys are known only after the performance schema initialization,\n    and can not be set in the MYSQL_BIN_LOG constructor (called before main()).\n  */\n  mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,\n                             key_BINLOG_update_cond,\n                             key_file_binlog,\n                             key_file_binlog_index,\n                             key_BINLOG_COND_queue_busy);\n#endif\n\n  /*\n    Init mutexes for the global MYSQL_BIN_LOG objects.\n    As safe_mutex depends on what MY_INIT() does, we can't init the mutexes of\n    global MYSQL_BIN_LOGs in their constructors, because then they would be\n    inited before MY_INIT(). So we do it here.\n  */\n  mysql_bin_log.init_pthread_objects();\n\n  /* TODO: remove this when my_time_t is 64 bit compatible */\n  if (!IS_TIME_T_VALID_FOR_TIMESTAMP(server_start_time))\n  {\n    sql_print_error(\"This MySQL server doesn't support dates later then 2038\");\n    return 1;\n  }\n\n  if (gethostname(glob_hostname,sizeof(glob_hostname)) < 0)\n  {\n    /*\n      Get hostname of computer (used by 'show variables') and as default\n      basename for the pid file if --log-basename is not given.\n    */\n    strmake(glob_hostname, STRING_WITH_LEN(\"localhost\"));\n    sql_print_warning(\"gethostname failed, using '%s' as hostname\",\n                        glob_hostname);\n    opt_log_basename= const_cast<char *>(\"mysql\");\n  }\n  else\n    opt_log_basename= glob_hostname;\n\n  if (!*pidfile_name)\n  {\n    strmake(pidfile_name, opt_log_basename, sizeof(pidfile_name)-5);\n    strmov(fn_ext(pidfile_name),\".pid\");\t\t// Add proper extension\n  }\n\n  /*\n    The default-storage-engine entry in my_long_options should have a\n    non-null default value. It was earlier intialized as\n    (longlong)\"MyISAM\" in my_long_options but this triggered a\n    compiler error in the Sun Studio 12 compiler. As a work-around we\n    set the def_value member to 0 in my_long_options and initialize it\n    to the correct value here.\n\n    From MySQL 5.5 onwards, the default storage engine is InnoDB\n    (except in the embedded server, where the default continues to\n    be MyISAM)\n  */\n#if defined(WITH_INNOBASE_STORAGE_ENGINE) || defined(WITH_XTRADB_STORAGE_ENGINE)\n  default_storage_engine= const_cast<char *>(\"InnoDB\");\n#else\n  default_storage_engine= const_cast<char *>(\"MyISAM\");\n#endif\n\n  /*\n    Add server status variables to the dynamic list of\n    status variables that is shown by SHOW STATUS.\n    Later, in plugin_init, and mysql_install_plugin\n    new entries could be added to that list.\n  */\n  if (add_status_vars(status_vars))\n    return 1; // an error was already reported\n\n#ifndef DBUG_OFF\n  /*\n    We have few debug-only commands in com_status_vars, only visible in debug\n    builds. for simplicity we enable the assert only in debug builds\n\n    There are 8 Com_ variables which don't have corresponding SQLCOM_ values:\n    (TODO strictly speaking they shouldn't be here, should not have Com_ prefix\n    that is. Perhaps Stmt_ ? Comstmt_ ? Prepstmt_ ?)\n\n      Com_admin_commands       => com_other\n      Com_stmt_close           => com_stmt_close\n      Com_stmt_execute         => com_stmt_execute\n      Com_stmt_fetch           => com_stmt_fetch\n      Com_stmt_prepare         => com_stmt_prepare\n      Com_stmt_reprepare       => com_stmt_reprepare\n      Com_stmt_reset           => com_stmt_reset\n      Com_stmt_send_long_data  => com_stmt_send_long_data\n\n    With this correction the number of Com_ variables (number of elements in\n    the array, excluding the last element - terminator) must match the number\n    of SQLCOM_ constants.\n  */\n  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==\n                     SQLCOM_END + 8);\n#endif\n\n  if (get_options(&remaining_argc, &remaining_argv))\n    return 1;\n  set_server_version();\n\n  if (!opt_help)\n    sql_print_information(\"%s (mysqld %s) starting as process %lu ...\",\n                          my_progname, server_version, (ulong) getpid());\n\n#ifndef EMBEDDED_LIBRARY\n  if (opt_abort && !opt_verbose)\n    unireg_abort(0);\n#endif /*!EMBEDDED_LIBRARY*/\n\n  DBUG_PRINT(\"info\",(\"%s  Ver %s for %s on %s\\n\",my_progname,\n\t\t     server_version, SYSTEM_TYPE,MACHINE_TYPE));\n\n#ifdef HAVE_LARGE_PAGES\n  /* Initialize large page size */\n  if (opt_large_pages && (opt_large_page_size= my_get_large_page_size()))\n  {\n      DBUG_PRINT(\"info\", (\"Large page set, large_page_size = %d\",\n                 opt_large_page_size));\n      my_use_large_pages= 1;\n      my_large_page_size= opt_large_page_size;\n  }\n  else\n  {\n    opt_large_pages= 0;\n    /* \n       Either not configured to use large pages or Linux haven't\n       been compiled with large page support\n    */\n  }\n#endif /* HAVE_LARGE_PAGES */\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#define LARGE_PAGESIZE (4*1024*1024)  /* 4MB */\n#define SUPER_LARGE_PAGESIZE (256*1024*1024)  /* 256MB */\n  if (opt_large_pages)\n  {\n  /*\n    tell the kernel that we want to use 4/256MB page for heap storage\n    and also for the stack. We use 4 MByte as default and if the\n    super-large-page is set we increase it to 256 MByte. 256 MByte\n    is for server installations with GBytes of RAM memory where\n    the MySQL Server will have page caches and other memory regions\n    measured in a number of GBytes.\n    We use as big pages as possible which isn't bigger than the above\n    desired page sizes.\n  */\n   int nelem;\n   size_t max_desired_page_size;\n   if (opt_super_large_pages)\n     max_desired_page_size= SUPER_LARGE_PAGESIZE;\n   else\n     max_desired_page_size= LARGE_PAGESIZE;\n   nelem = getpagesizes(NULL, 0);\n   if (nelem > 0)\n   {\n     size_t *pagesize = (size_t *) malloc(sizeof(size_t) * nelem);\n     if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0)\n     {\n       size_t max_page_size= 0;\n       for (int i= 0; i < nelem; i++)\n       {\n         if (pagesize[i] > max_page_size &&\n             pagesize[i] <= max_desired_page_size)\n            max_page_size= pagesize[i];\n       }\n       free(pagesize);\n       if (max_page_size > 0)\n       {\n         struct memcntl_mha mpss;\n\n         mpss.mha_cmd= MHA_MAPSIZE_BSSBRK;\n         mpss.mha_pagesize= max_page_size;\n         mpss.mha_flags= 0;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n         mpss.mha_cmd= MHA_MAPSIZE_STACK;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n       }\n     }\n   }\n  }\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n  /* connections and databases needs lots of files */\n  {\n    uint files, wanted_files, max_open_files;\n\n    /* MyISAM requires two file handles per table. */\n    wanted_files= (10 + max_connections + extra_max_connections +\n                   table_cache_size*2);\n    /*\n      We are trying to allocate no less than max_connections*5 file\n      handles (i.e. we are trying to set the limit so that they will\n      be available).  In addition, we allocate no less than how much\n      was already allocated.  However below we report a warning and\n      recompute values only if we got less file handles than were\n      explicitly requested.  No warning and re-computation occur if we\n      can't get max_connections*5 but still got no less than was\n      requested (value of wanted_files).\n    */\n    max_open_files= max(max(wanted_files,\n                            (max_connections + extra_max_connections)*5),\n                        open_files_limit);\n    files= my_set_max_open_files(max_open_files);\n\n    if (files < wanted_files)\n    {\n      if (!open_files_limit)\n      {\n        /*\n          If we have requested too much file handles than we bring\n          max_connections in supported bounds.\n        */\n        max_connections= (ulong) min(files-10-TABLE_OPEN_CACHE_MIN*2,\n                                     max_connections);\n        /*\n          Decrease table_cache_size according to max_connections, but\n          not below TABLE_OPEN_CACHE_MIN.  Outer min() ensures that we\n          never increase table_cache_size automatically (that could\n          happen if max_connections is decreased above).\n        */\n        table_cache_size= (ulong) min(max((files-10-max_connections)/2,\n                                          TABLE_OPEN_CACHE_MIN),\n                                      table_cache_size);\n\tDBUG_PRINT(\"warning\",\n\t\t   (\"Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld\",\n\t\t    files, max_connections, table_cache_size));\n\tif (global_system_variables.log_warnings)\n\t  sql_print_warning(\"Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld\",\n\t\t\tfiles, max_connections, table_cache_size);\n      }\n      else if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Could not increase number of max_open_files to more than %u (request: %u)\", files, wanted_files);\n    }\n    open_files_limit= files;\n  }\n  unireg_init(opt_specialflag); /* Set up extern variabels */\n  if (!(my_default_lc_messages=\n        my_locale_by_name(lc_messages)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_messages);\n    return 1;\n  }\n  global_system_variables.lc_messages= my_default_lc_messages;\n  if (init_errmessage())\t/* Read error messages from file */\n    return 1;\n  init_client_errs();\n  mysql_library_init(unused,unused,unused); /* for replication */\n  lex_init();\n  if (item_create_init())\n    return 1;\n  item_init();\n#ifndef EMBEDDED_LIBRARY\n  my_regex_init(&my_charset_latin1, check_enough_stack_size);\n  my_string_stack_guard= check_enough_stack_size;\n#else\n  my_regex_init(&my_charset_latin1, NULL);\n#endif\n  /*\n    Process a comma-separated character set list and choose\n    the first available character set. This is mostly for\n    test purposes, to be able to start \"mysqld\" even if\n    the requested character set is not available (see bug#18743).\n  */\n  for (;;)\n  {\n    char *next_character_set_name= strchr(default_character_set_name, ',');\n    if (next_character_set_name)\n      *next_character_set_name++= '\\0';\n    if (!(default_charset_info=\n          get_charset_by_csname(default_character_set_name,\n                                MY_CS_PRIMARY, MYF(MY_WME))))\n    {\n      if (next_character_set_name)\n      {\n        default_character_set_name= next_character_set_name;\n        default_collation_name= 0;          // Ignore collation\n      }\n      else\n        return 1;                           // Eof of the list\n    }\n    else\n      break;\n  }\n\n  if (default_collation_name)\n  {\n    CHARSET_INFO *default_collation;\n    default_collation= get_charset_by_name(default_collation_name, MYF(0));\n    if (!default_collation)\n    {\n      sql_print_error(ER_DEFAULT(ER_UNKNOWN_COLLATION), default_collation_name);\n      return 1;\n    }\n    if (!my_charset_same(default_charset_info, default_collation))\n    {\n      sql_print_error(ER_DEFAULT(ER_COLLATION_CHARSET_MISMATCH),\n\t\t      default_collation_name,\n\t\t      default_charset_info->csname);\n      return 1;\n    }\n    default_charset_info= default_collation;\n  }\n  /* Set collactions that depends on the default collation */\n  global_system_variables.collation_server=\t default_charset_info;\n  global_system_variables.collation_database=\t default_charset_info;\n  global_system_variables.collation_connection=  default_charset_info;\n  global_system_variables.character_set_results= default_charset_info;\n  global_system_variables.character_set_client=  default_charset_info;\n\n  if (!(character_set_filesystem=\n        get_charset_by_csname(character_set_filesystem_name,\n                              MY_CS_PRIMARY, MYF(MY_WME))))\n    return 1;\n  global_system_variables.character_set_filesystem= character_set_filesystem;\n\n  if (!(my_default_lc_time_names=\n        my_locale_by_name(lc_time_names_name)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_time_names_name);\n    return 1;\n  }\n  global_system_variables.lc_time_names= my_default_lc_time_names;\n\n  /* check log options and issue warnings if needed */\n  if (opt_log && opt_logname && *opt_logname &&\n      !(log_output_options & (LOG_FILE | LOG_NONE)))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log option, log tables are used. \"\n                      \"To enable logging to files use the --log-output option.\");\n\n  if (opt_slow_log && opt_slow_logname && *opt_slow_logname &&\n      !(log_output_options & (LOG_FILE | LOG_NONE)))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log-slow-queries option, log tables are used. \"\n                      \"To enable logging to files use the --log-output=file option.\");\n\n  if (!opt_logname || !*opt_logname)\n    make_default_log_name(&opt_logname, \".log\", false);\n  if (!opt_slow_logname || !*opt_slow_logname)\n    make_default_log_name(&opt_slow_logname, \"-slow.log\", false);\n\n#if defined(ENABLED_DEBUG_SYNC)\n  /* Initialize the debug sync facility. See debug_sync.cc. */\n  if (debug_sync_init())\n    return 1; /* purecov: tested */\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n#if (ENABLE_TEMP_POOL)\n  if (use_temp_pool && bitmap_init(&temp_pool,0,1024,1))\n    return 1;\n#else\n  use_temp_pool= 0;\n#endif\n\n  if (my_dboptions_cache_init())\n    return 1;\n\n  /*\n    Ensure that lower_case_table_names is set on system where we have case\n    insensitive names.  If this is not done the users MyISAM tables will\n    get corrupted if accesses with names of different case.\n  */\n  DBUG_PRINT(\"info\", (\"lower_case_table_names: %d\", lower_case_table_names));\n  lower_case_file_system= test_if_case_insensitive(mysql_real_data_home);\n  if (!lower_case_table_names && lower_case_file_system == 1)\n  {\n    if (lower_case_table_names_used)\n    {\n#if MYSQL_VERSION_ID < 100100\n      if (global_system_variables.log_warnings)\n        sql_print_warning(\"You have forced lower_case_table_names to 0 through \"\n                          \"a command-line option, even though your file system \"\n                          \"'%s' is case insensitive.  This means that you can \"\n                          \"corrupt your tables if you access them using names \"\n                          \"with different letter case. You should consider \"\n                          \"changing lower_case_table_names to 1 or 2\",\n                          mysql_real_data_home);\n#else\n      sql_print_error(\"The server option 'lower_case_table_names' is \"\n                      \"configured to use case sensitive table names but the \"\n                      \"data directory resides on a case-insensitive file system. \"\n                      \"Please use a case sensitive file system for your data \"\n                      \"directory or switch to a case-insensitive table name \"\n                      \"mode.\");\n#endif\n      return 1;\n    }\n    else\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Setting lower_case_table_names=2 because file system for %s is case insensitive\", mysql_real_data_home);\n      lower_case_table_names= 2;\n    }\n  }\n  else if (lower_case_table_names == 2 &&\n           !(lower_case_file_system= (lower_case_file_system == 1)))\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_warning(\"lower_case_table_names was set to 2, even though your \"\n                        \"the file system '%s' is case sensitive.  Now setting \"\n                        \"lower_case_table_names to 0 to avoid future problems.\",\n\t\t\tmysql_real_data_home);\n    lower_case_table_names= 0;\n  }\n  else\n  {\n    lower_case_file_system= (lower_case_file_system == 1);\n  }\n\n  /* Reset table_alias_charset, now that lower_case_table_names is set. */\n  table_alias_charset= (lower_case_table_names ?\n\t\t\tfiles_charset_info :\n\t\t\t&my_charset_bin);\n\n  if (ignore_db_dirs_process_additions())\n  {\n    sql_print_error(\"An error occurred while storing ignore_db_dirs to a hash.\");\n    return 1;\n  }\n\n  return 0;\n}\n\n\nstatic int init_thread_environment()\n{\n  mysql_mutex_init(key_LOCK_thread_count, &LOCK_thread_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_status, &LOCK_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_insert,\n                   &LOCK_delayed_insert, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_status,\n                   &LOCK_delayed_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_create,\n                   &LOCK_delayed_create, MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_crypt, &LOCK_crypt, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_user_conn, &LOCK_user_conn, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_active_mi, &LOCK_active_mi, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_system_variables,\n                   &LOCK_global_system_variables, MY_MUTEX_INIT_FAST);\n  mysql_rwlock_init(key_rwlock_LOCK_system_variables_hash,\n                    &LOCK_system_variables_hash);\n  mysql_mutex_init(key_LOCK_prepared_stmt_count,\n                   &LOCK_prepared_stmt_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_error_messages,\n                   &LOCK_error_messages, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_uuid_short_generator,\n                   &LOCK_short_uuid_generator, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_connection_count,\n                   &LOCK_connection_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_stats, &LOCK_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_user_client_stats,\n                   &LOCK_global_user_client_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_table_stats,\n                   &LOCK_global_table_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_index_stats,\n                   &LOCK_global_index_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_prepare_ordered, &LOCK_prepare_ordered,\n                   MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_commit_ordered, &LOCK_commit_ordered,\n                   MY_MUTEX_INIT_SLOW);\n\n#ifdef HAVE_OPENSSL\n  mysql_mutex_init(key_LOCK_des_key_file,\n                   &LOCK_des_key_file, MY_MUTEX_INIT_FAST);\n#ifndef HAVE_YASSL\n  openssl_stdlocks= (openssl_lock_t*) OPENSSL_malloc(CRYPTO_num_locks() *\n                                                     sizeof(openssl_lock_t));\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_init(key_rwlock_openssl, &openssl_stdlocks[i].lock);\n  CRYPTO_set_dynlock_create_callback(openssl_dynlock_create);\n  CRYPTO_set_dynlock_destroy_callback(openssl_dynlock_destroy);\n  CRYPTO_set_dynlock_lock_callback(openssl_lock);\n  CRYPTO_set_locking_callback(openssl_lock_function);\n#endif\n#endif\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_connect, &LOCK_sys_init_connect);\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_slave, &LOCK_sys_init_slave);\n  mysql_rwlock_init(key_rwlock_LOCK_grant, &LOCK_grant);\n  mysql_cond_init(key_COND_thread_count, &COND_thread_count, NULL);\n  mysql_cond_init(key_COND_thread_cache, &COND_thread_cache, NULL);\n  mysql_cond_init(key_COND_flush_thread_cache, &COND_flush_thread_cache, NULL);\n#ifdef HAVE_REPLICATION\n  mysql_mutex_init(key_LOCK_rpl_status, &LOCK_rpl_status, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_rpl_status, &COND_rpl_status, NULL);\n#endif\n  mysql_mutex_init(key_LOCK_server_started,\n                   &LOCK_server_started, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_server_started, &COND_server_started, NULL);\n  sp_cache_init();\n#ifdef HAVE_EVENT_SCHEDULER\n  Events::init_mutexes();\n#endif\n  /* Parameter for threads created for connections */\n  (void) pthread_attr_init(&connection_attrib);\n  (void) pthread_attr_setdetachstate(&connection_attrib,\n\t\t\t\t     PTHREAD_CREATE_DETACHED);\n  pthread_attr_setscope(&connection_attrib, PTHREAD_SCOPE_SYSTEM);\n\n  if (pthread_key_create(&THR_THD,NULL) ||\n      pthread_key_create(&THR_MALLOC,NULL))\n  {\n    sql_print_error(\"Can't create thread-keys\");\n    return 1;\n  }\n  return 0;\n}\n\n\n#if defined(HAVE_OPENSSL) && !defined(HAVE_YASSL)\nstatic openssl_lock_t *openssl_dynlock_create(const char *file, int line)\n{\n  openssl_lock_t *lock= new openssl_lock_t;\n  mysql_rwlock_init(key_rwlock_openssl, &lock->lock);\n  return lock;\n}\n\n\nstatic void openssl_dynlock_destroy(openssl_lock_t *lock, const char *file,\n\t\t\t\t    int line)\n{\n  mysql_rwlock_destroy(&lock->lock);\n  delete lock;\n}\n\n\nstatic void openssl_lock_function(int mode, int n, const char *file, int line)\n{\n  if (n < 0 || n > CRYPTO_num_locks())\n  {\n    /* Lock number out of bounds. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (n = %d)\", n);\n    abort();\n  }\n  openssl_lock(mode, &openssl_stdlocks[n], file, line);\n}\n\n\nstatic void openssl_lock(int mode, openssl_lock_t *lock, const char *file,\n\t\t\t int line)\n{\n  int err;\n  char const *what;\n\n  switch (mode) {\n  case CRYPTO_LOCK|CRYPTO_READ:\n    what = \"read lock\";\n    err= mysql_rwlock_rdlock(&lock->lock);\n    break;\n  case CRYPTO_LOCK|CRYPTO_WRITE:\n    what = \"write lock\";\n    err= mysql_rwlock_wrlock(&lock->lock);\n    break;\n  case CRYPTO_UNLOCK|CRYPTO_READ:\n  case CRYPTO_UNLOCK|CRYPTO_WRITE:\n    what = \"unlock\";\n    err= mysql_rwlock_unlock(&lock->lock);\n    break;\n  default:\n    /* Unknown locking mode. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (mode=0x%x)\", mode);\n    abort();\n  }\n  if (err)\n  {\n    sql_print_error(\"Fatal: can't %s OpenSSL lock\", what);\n    abort();\n  }\n}\n#endif /* HAVE_OPENSSL */\n\n\nstatic void init_ssl()\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    enum enum_ssl_init_error error= SSL_INITERR_NOERROR;\n\n    /* having ssl_acceptor_fd != 0 signals the use of SSL */\n    ssl_acceptor_fd= new_VioSSLAcceptorFd(opt_ssl_key, opt_ssl_cert,\n\t\t\t\t\t  opt_ssl_ca, opt_ssl_capath,\n\t\t\t\t\t  opt_ssl_cipher, &error);\n    DBUG_PRINT(\"info\",(\"ssl_acceptor_fd: 0x%lx\", (long) ssl_acceptor_fd));\n    ERR_remove_state(0);\n    if (!ssl_acceptor_fd)\n    {\n      sql_print_warning(\"Failed to setup SSL\");\n      sql_print_warning(\"SSL error: %s\", sslGetErrString(error));\n      opt_use_ssl = 0;\n      have_ssl= SHOW_OPTION_DISABLED;\n    }\n  }\n  else\n  {\n    have_ssl= SHOW_OPTION_DISABLED;\n  }\n  if (des_key_file)\n    load_des_key_file(des_key_file);\n#endif /* HAVE_OPENSSL && ! EMBEDDED_LIBRARY */\n}\n\n\nstatic void end_ssl()\n{\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  if (ssl_acceptor_fd)\n  {\n    free_vio_ssl_acceptor_fd(ssl_acceptor_fd);\n    ssl_acceptor_fd= 0;\n  }\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n}\n\n#ifdef _WIN32\n/**\n  Registers a file to be collected when Windows Error Reporting creates a crash \n  report.\n\n  @note only works on Vista and later, since WerRegisterFile() is not available\n  on earlier Windows.\n*/\n#include <werapi.h>\nstatic void add_file_to_crash_report(char *file)\n{\n  /* Load WerRegisterFile function dynamically.*/\n  HRESULT (WINAPI *pWerRegisterFile)(PCWSTR, WER_REGISTER_FILE_TYPE, DWORD)\n    =(HRESULT (WINAPI *) (PCWSTR, WER_REGISTER_FILE_TYPE, DWORD))\n    GetProcAddress(GetModuleHandle(\"kernel32\"),\"WerRegisterFile\");\n\n  if (pWerRegisterFile)\n  {\n    wchar_t wfile[MAX_PATH+1]= {0};\n    if (mbstowcs(wfile, file, MAX_PATH) != (size_t)-1)\n    {\n      pWerRegisterFile(wfile, WerRegFileTypeOther, WER_FILE_ANONYMOUS_DATA);\n    }\n  }\n}\n#endif\n\nstatic int init_server_components()\n{\n  DBUG_ENTER(\"init_server_components\");\n  /*\n    We need to call each of these following functions to ensure that\n    all things are initialized so that unireg_abort() doesn't fail\n  */\n  mdl_init();\n  if (table_def_init() | hostname_cache_init())\n    unireg_abort(1);\n\n  query_cache_set_min_res_unit(query_cache_min_res_unit);\n  query_cache_init();\n  query_cache_resize(query_cache_size);\n  my_rnd_init(&sql_rand,(ulong) server_start_time,(ulong) server_start_time/2);\n  setup_fpu();\n  init_thr_lock();\n  my_uuid_init((ulong) (my_rnd(&sql_rand))*12345,12345);\n#ifdef HAVE_REPLICATION\n  init_slave_list();\n#endif\n  wt_init();\n\n  /* Setup logs */\n\n  /*\n    Enable old-fashioned error log, except when the user has requested\n    help information. Since the implementation of plugin server\n    variables the help output is now written much later.\n  */\n  if (opt_error_log && !opt_abort)\n  {\n    if (!log_error_file_ptr[0])\n      fn_format(log_error_file, pidfile_name, mysql_data_home, \".err\",\n                MY_REPLACE_EXT); /* replace '.<domain>' by '.err', bug#4997 */\n    else\n      fn_format(log_error_file, log_error_file_ptr, mysql_data_home, \".err\",\n                MY_UNPACK_FILENAME | MY_SAFE_PATH);\n    /*\n      _ptr may have been set to my_disabled_option or \"\" if no argument was\n      passed, but we need to show the real name in SHOW VARIABLES:\n    */\n    log_error_file_ptr= log_error_file;\n    if (!log_error_file[0])\n      opt_error_log= 0;                         // Too long file name\n    else\n    {\n      my_bool res;\n#ifndef EMBEDDED_LIBRARY\n      res= reopen_fstreams(log_error_file, stdout, stderr);\n#else\n      res= reopen_fstreams(log_error_file, NULL, stderr);\n#endif\n\n      if (!res)\n        setbuf(stderr, NULL);\n\n#ifdef _WIN32\n      /* Add error log to windows crash reporting. */\n      add_file_to_crash_report(log_error_file);\n#endif\n    }\n  }\n\n  /* set up the hook before initializing plugins which may use it */\n  error_handler_hook= my_message_sql;\n  proc_info_hook= set_thd_proc_info;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Parsing the performance schema command line option may have reported\n    warnings/information messages.\n    Now that the logger is finally available, and redirected\n    to the proper file when the --log--error option is used,\n    print the buffered messages to the log.\n  */\n  buffered_logs.print();\n  buffered_logs.cleanup();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  if (xid_cache_init())\n  {\n    sql_print_error(\"Out of memory\");\n    unireg_abort(1);\n  }\n\n  /*\n    initialize delegates for extension observers, errors have already\n    been reported in the function\n  */\n  if (delegates_init())\n    unireg_abort(1);\n\n  /* need to configure logging before initializing storage engines */\n  if (!opt_bin_log_used)\n  {\n    if (opt_log_slave_updates)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--log-slave-updates work.\");\n    if (binlog_format_used)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--binlog-format work.\");\n  }\n\n  /* Check that we have not let the format to unspecified at this point */\n  DBUG_ASSERT((uint)global_system_variables.binlog_format <=\n              array_elements(binlog_format_names)-1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_log_slave_updates && replicate_same_server_id)\n  {\n    if (opt_bin_log)\n    {\n      sql_print_error(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates is impossible, it would lead to infinite loops in this \\\nserver.\");\n      unireg_abort(1);\n    }\n    else\n      sql_print_warning(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates would lead to infinite loops in this server. However this \\\nwill be ignored as the --log-bin option is not defined.\");\n  }\n#endif\n\n  DBUG_ASSERT(!opt_bin_log || opt_bin_logname);\n\n  if (opt_bin_log)\n  {\n    /* Reports an error and aborts, if the --log-bin's path \n       is a directory.*/\n    if (opt_bin_logname[0] && \n        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin option\", opt_bin_logname);\n      unireg_abort(1);\n    }\n\n    /* Reports an error and aborts, if the --log-bin-index's path \n       is a directory.*/\n    if (opt_binlog_index_name && \n        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] \n        == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin-index option\", opt_binlog_index_name);\n      unireg_abort(1);\n    }\n\n    char buf[FN_REFLEN];\n    const char *ln;\n    ln= mysql_bin_log.generate_name(opt_bin_logname, \"-bin\", 1, buf);\n    if (!opt_bin_logname[0] && !opt_binlog_index_name)\n    {\n      /*\n        User didn't give us info to name the binlog index file.\n        Picking `hostname`-bin.index like did in 4.x, causes replication to\n        fail if the hostname is changed later. So, we would like to instead\n        require a name. But as we don't want to break many existing setups, we\n        only give warning, not error.\n      */\n      sql_print_warning(\"No argument was provided to --log-bin and \"\n                        \"neither --log-basename or --log-bin-index where \"\n                        \"used;  This may cause repliction to break when this \"\n                        \"server acts as a master and has its hostname \"\n                        \"changed! Please use '--log-basename=%s' or \"\n                        \"'--log-bin=%s' to avoid this problem.\",\n                        opt_log_basename, ln);\n    }\n    if (ln == buf)\n    {\n      opt_bin_logname= my_once_strdup(buf, MYF(MY_WME));\n    }\n    if (mysql_bin_log.open_index_file(opt_binlog_index_name, ln, TRUE))\n    {\n      unireg_abort(1);\n    }\n  }\n\n  /* call ha_init_key_cache() on all key caches to init them */\n  process_key_caches(&ha_init_key_cache, 0);\n\n  init_global_table_stats();\n  init_global_index_stats();\n\n  /* Allow storage engine to give real error messages */\n  if (ha_init_errors())\n    DBUG_RETURN(1);\n\n  tc_log= 0; // ha_initialize_handlerton() needs that\n\n  if (plugin_init(&remaining_argc, remaining_argv,\n                  (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : 0) |\n                  (opt_abort ? PLUGIN_INIT_SKIP_INITIALIZATION : 0)))\n  {\n    sql_print_error(\"Failed to initialize plugins.\");\n    unireg_abort(1);\n  }\n  plugins_are_initialized= TRUE;  /* Don't separate from init function */\n\n  have_csv= plugin_status(STRING_WITH_LEN(\"csv\"),\n                          MYSQL_STORAGE_ENGINE_PLUGIN);\n  have_ndbcluster= plugin_status(STRING_WITH_LEN(\"ndbcluster\"),\n                                 MYSQL_STORAGE_ENGINE_PLUGIN);\n  have_partitioning= plugin_status(STRING_WITH_LEN(\"partition\"),\n                                   MYSQL_STORAGE_ENGINE_PLUGIN);\n\n  /* we do want to exit if there are any other unknown options */\n  if (remaining_argc > 1)\n  {\n    int ho_error;\n    struct my_option no_opts[]=\n    {\n      {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n    };\n    /*\n      We need to eat any 'loose' arguments first before we conclude\n      that there are unprocessed options.\n    */\n    my_getopt_skip_unknown= 0;\n\n    if ((ho_error= handle_options(&remaining_argc, &remaining_argv, no_opts,\n                                  mysqld_get_one_option)))\n      unireg_abort(ho_error);\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    my_getopt_skip_unknown= TRUE;\n\n    if (remaining_argc > 1)\n    {\n      fprintf(stderr, \"%s: Too many arguments (first extra is '%s').\\n\",\n              my_progname, remaining_argv[1]);\n      unireg_abort(1);\n    }\n  }\n\n  if (opt_abort)\n    unireg_abort(0);\n\n  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */\n  if (!DEFAULT_ERRMSGS[0][0])\n    unireg_abort(1);  \n\n  /* We have to initialize the storage engines before CSV logging */\n  if (ha_init())\n  {\n    sql_print_error(\"Can't init databases\");\n    unireg_abort(1);\n  }\n\n  if (opt_bootstrap)\n    log_output_options= LOG_FILE;\n  else\n    logger.init_log_tables();\n\n  if (log_output_options & LOG_NONE)\n  {\n    /*\n      Issue a warining if there were specified additional options to the\n      log-output along with NONE. Probably this wasn't what user wanted.\n    */\n    if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))\n      sql_print_warning(\"There were other values specified to \"\n                        \"log-output besides NONE. Disabling slow \"\n                        \"and general logs anyway.\");\n    logger.set_handlers(LOG_FILE, LOG_NONE, LOG_NONE);\n  }\n  else\n  {\n    /* fall back to the log files if tables are not present */\n    LEX_STRING csv_name={C_STRING_WITH_LEN(\"csv\")};\n    if (!plugin_is_ready(&csv_name, MYSQL_STORAGE_ENGINE_PLUGIN))\n    {\n      /* purecov: begin inspected */\n      sql_print_error(\"CSV engine is not present, falling back to the \"\n                      \"log files\");\n      log_output_options= (log_output_options & ~LOG_TABLE) | LOG_FILE;\n      /* purecov: end */\n    }\n\n    logger.set_handlers(LOG_FILE, opt_slow_log ? log_output_options:LOG_NONE,\n                        opt_log ? log_output_options:LOG_NONE);\n  }\n\n  /*\n    Set the default storage engine\n  */\n  LEX_STRING name= { default_storage_engine, strlen(default_storage_engine) };\n  plugin_ref plugin;\n  handlerton *hton;\n  if ((plugin= ha_resolve_by_name(0, &name)))\n    hton= plugin_data(plugin, handlerton*);\n  else\n  {\n    sql_print_error(\"Unknown/unsupported storage engine: %s\",\n                    default_storage_engine);\n    unireg_abort(1);\n  }\n  if (!ha_storage_engine_is_enabled(hton))\n  {\n    if (!opt_bootstrap)\n    {\n      sql_print_error(\"Default storage engine (%s) is not available\",\n                      default_storage_engine);\n      unireg_abort(1);\n    }\n    DBUG_ASSERT(global_system_variables.table_plugin);\n  }\n  else\n  {\n    /*\n      Need to unlock as global_system_variables.table_plugin\n      was acquired during plugin_init()\n    */\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    plugin_unlock(0, global_system_variables.table_plugin);\n    global_system_variables.table_plugin= plugin;\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n  }\n#if defined(WITH_ARIA_STORAGE_ENGINE) && defined(USE_ARIA_FOR_TMP_TABLES)\n  if (!ha_storage_engine_is_enabled(maria_hton) && !opt_bootstrap)\n  {\n    sql_print_error(\"Aria engine is not enabled or did not start. The Aria engine must be enabled to continue as mysqld was configured with --with-aria-tmp-tables\");\n    unireg_abort(1);\n  }\n  internal_tmp_table_max_key_length=   maria_max_key_length();\n  internal_tmp_table_max_key_segments= maria_max_key_segments();\n#else\n  internal_tmp_table_max_key_length=   myisam_max_key_length();\n  internal_tmp_table_max_key_segments= myisam_max_key_segments();\n#endif\n\n  tc_log= get_tc_log_implementation();\n\n  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))\n  {\n    sql_print_error(\"Can't init tc log\");\n    unireg_abort(1);\n  }\n\n  if (ha_recover(0))\n  {\n    unireg_abort(1);\n  }\n\n  if (opt_bin_log && mysql_bin_log.open(opt_bin_logname, LOG_BIN, 0,\n                                        WRITE_CACHE, 0, max_binlog_size, 0, TRUE))\n    unireg_abort(1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_bin_log && expire_logs_days)\n  {\n    time_t purge_time= server_start_time - expire_logs_days*24*60*60;\n    if (purge_time >= 0)\n      mysql_bin_log.purge_logs_before_date(purge_time);\n  }\n#endif\n\n  if (opt_myisam_log)\n    (void) mi_log(1);\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT) && !defined(EMBEDDED_LIBRARY)\n  if (locked_in_memory && !getuid())\n  {\n    if (setreuid((uid_t)-1, 0) == -1)\n    {                        // this should never happen\n      sql_perror(\"setreuid\");\n      unireg_abort(1);\n    }\n    if (mlockall(MCL_CURRENT))\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Failed to lock memory. Errno: %d\\n\",errno);\n      locked_in_memory= 0;\n    }\n    if (user_info)\n      set_user(mysqld_user, user_info);\n  }\n  else\n#endif\n    locked_in_memory=0;\n\n  ft_init_stopwords();\n\n  init_max_user_conn();\n  init_update_queries();\n  init_global_user_stats();\n  init_global_client_stats();\n  DBUG_RETURN(0);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void create_shutdown_thread()\n{\n#ifdef __WIN__\n  hEventShutdown=CreateEvent(0, FALSE, FALSE, shutdown_event_name);\n  pthread_t hThread;\n  int error;\n  if ((error= mysql_thread_create(key_thread_handle_shutdown,\n                                  &hThread, &connection_attrib,\n                                  handle_shutdown, 0)))\n    sql_print_warning(\"Can't create thread to handle shutdown requests\"\n                      \" (errno= %d)\", error);\n\n  // On \"Stop Service\" we have to do regular shutdown\n  Service.SetShutdownEvent(hEventShutdown);\n#endif /* __WIN__ */\n}\n\n#endif /* EMBEDDED_LIBRARY */\n\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic void handle_connections_methods()\n{\n  pthread_t hThread;\n  int error;\n  DBUG_ENTER(\"handle_connections_methods\");\n  if (hPipe == INVALID_HANDLE_VALUE &&\n      (!have_tcpip || opt_disable_networking) &&\n      !opt_enable_shared_memory)\n  {\n    sql_print_error(\"TCP/IP, --shared-memory, or --named-pipe should be configured on NT OS\");\n    unireg_abort(1);\t\t\t\t// Will not return\n  }\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  mysql_cond_init(key_COND_handler_count, &COND_handler_count, NULL);\n  handler_count=0;\n  if (hPipe != INVALID_HANDLE_VALUE)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_namedpipes,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_namedpipes, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle named pipes\"\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n  if (have_tcpip && !opt_disable_networking)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_sockets,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_sockets_thread, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle TCP/IP\",\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n#ifdef HAVE_SMEM\n  if (opt_enable_shared_memory)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_sharedmem,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_shared_memory, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle shared memory\",\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n#endif\n\n  while (handler_count > 0)\n    mysql_cond_wait(&COND_handler_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  DBUG_VOID_RETURN;\n}\n\nvoid decrement_handler_count()\n{\n  mysql_mutex_lock(&LOCK_thread_count);\n  handler_count--;\n  mysql_cond_signal(&COND_handler_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  my_thread_end();\n}\n#else\n#define decrement_handler_count()\n#endif /* defined(_WIN32) || defined(HAVE_SMEM) */\n\n\n#ifndef EMBEDDED_LIBRARY\n\nLEX_STRING sql_statement_names[(uint) SQLCOM_END + 1];\n\nstatic void init_sql_statement_names()\n{\n  char *first_com= (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *last_com= (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_END]);\n  int record_size= (char*) offsetof(STATUS_VAR, com_stat[1])\n                   - (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *ptr;\n  uint i;\n  uint com_index;\n\n  for (i= 0; i < ((uint) SQLCOM_END + 1); i++)\n    sql_statement_names[i]= empty_lex_str;\n\n  SHOW_VAR *var= &com_status_vars[0];\n  while (var->name != NULL)\n  {\n    ptr= var->value;\n    if ((first_com <= ptr) && (ptr <= last_com))\n    {\n      com_index= ((int)(ptr - first_com))/record_size;\n      DBUG_ASSERT(com_index < (uint) SQLCOM_END);\n      sql_statement_names[com_index].str= const_cast<char *>(var->name);\n      sql_statement_names[com_index].length= strlen(var->name);\n    }\n    var++;\n  }\n\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SELECT].str, \"select\") == 0);\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SIGNAL].str, \"signal\") == 0);\n\n  sql_statement_names[(uint) SQLCOM_END].str= const_cast<char*>(\"error\");\n}\n\n#ifndef DBUG_OFF\n/*\n  Debugging helper function to keep the locale database\n  (see sql_locale.cc) and max_month_name_length and\n  max_day_name_length variable values in consistent state.\n*/\nstatic void test_lc_time_sz()\n{\n  DBUG_ENTER(\"test_lc_time_sz\");\n  for (MY_LOCALE **loc= my_locales; *loc; loc++)\n  {\n    uint max_month_len= 0;\n    uint max_day_len = 0;\n    for (const char **month= (*loc)->month_names->type_names; *month; month++)\n    {\n      set_if_bigger(max_month_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *month, *month + strlen(*month)));\n    }\n    for (const char **day= (*loc)->day_names->type_names; *day; day++)\n    {\n      set_if_bigger(max_day_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *day, *day + strlen(*day)));\n    }\n    if ((*loc)->max_month_name_length != max_month_len ||\n        (*loc)->max_day_name_length != max_day_len)\n    {\n      DBUG_PRINT(\"Wrong max day name(or month name) length for locale:\",\n                 (\"%s\", (*loc)->name));\n      DBUG_ASSERT(0);\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n#endif//DBUG_OFF\n\n#ifdef __WIN__\nint win_main(int argc, char **argv)\n#else\nint mysqld_main(int argc, char **argv)\n#endif\n{\n  /*\n    Perform basic thread library and malloc initialization,\n    to be able to read defaults files and parse options.\n  */\n  my_progname= argv[0];\n  sf_leaking_memory= 1; // no safemalloc memory leak reports if we exit early\n#ifdef HAVE_NPTL\n  ld_assume_kernel_is_set= (getenv(\"LD_ASSUME_KERNEL\") != 0);\n#endif\n#ifndef _WIN32\n  // For windows, my_init() is called from the win specific mysqld_main\n  if (my_init())                 // init my_sys library & pthreads\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n#endif\n\n  orig_argc= argc;\n  orig_argv= argv;\n  my_getopt_use_args_separator= TRUE;\n  if (load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv))\n    return 1;\n  my_getopt_use_args_separator= FALSE;\n  defaults_argc= argc;\n  defaults_argv= argv;\n  remaining_argc= argc;\n  remaining_argv= argv;\n\n  /* Must be initialized early for comparison of options name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  init_sql_statement_names();\n  sys_var_init();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    The performance schema needs to be initialized as early as possible,\n    before to-be-instrumented objects of the server are initialized.\n  */\n  int ho_error;\n  DYNAMIC_ARRAY all_early_options;\n\n  my_getopt_register_get_addr(NULL);\n  /* Skip unknown options so that they may be processed later */\n  my_getopt_skip_unknown= TRUE;\n\n  /* prepare all_early_options array */\n  my_init_dynamic_array(&all_early_options, sizeof(my_option), 100, 25);\n  sys_var_add_options(&all_early_options, sys_var::PARSE_EARLY);\n  add_terminator(&all_early_options);\n\n  /*\n    Logs generated while parsing the command line\n    options are buffered and printed later.\n  */\n  buffered_logs.init();\n  my_getopt_error_reporter= buffered_option_error_reporter;\n\n  ho_error= handle_options(&remaining_argc, &remaining_argv,\n                           (my_option*)(all_early_options.buffer), NULL);\n  delete_dynamic(&all_early_options);\n  if (ho_error == 0)\n  {\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    if (pfs_param.m_enabled)\n    {\n      PSI_hook= initialize_performance_schema(&pfs_param);\n      if (PSI_hook == NULL)\n      {\n        pfs_param.m_enabled= false;\n        buffered_logs.buffer(WARNING_LEVEL,\n                             \"Performance schema disabled (reason: init failed).\");\n      }\n    }\n  }\n#else\n  /*\n    Other provider of the instrumentation interface should\n    initialize PSI_hook here:\n    - HAVE_PSI_INTERFACE is for the instrumentation interface\n    - WITH_PERFSCHEMA_STORAGE_ENGINE is for one implementation\n      of the interface,\n    but there could be alternate implementations, which is why\n    these two defines are kept separate.\n  */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Obtain the current performance schema instrumentation interface,\n    if available.\n  */\n  if (PSI_hook)\n    PSI_server= (PSI*) PSI_hook->get_interface(PSI_CURRENT_VERSION);\n\n  if (PSI_server)\n  {\n    /*\n      Now that we have parsed the command line arguments, and have initialized\n      the performance schema itself, the next step is to register all the\n      server instruments.\n    */\n    init_server_psi_keys();\n    /* Instrument the main thread */\n    PSI_thread *psi= PSI_server->new_thread(key_thread_main, NULL, 0);\n    if (psi)\n      PSI_server->set_thread(psi);\n\n    /*\n      Now that some instrumentation is in place,\n      recreate objects which were initialised early,\n      so that they are instrumented as well.\n    */\n    my_thread_global_reinit();\n  }\n#endif /* HAVE_PSI_INTERFACE */\n\n  init_error_log_mutex();\n\n  /* Initialize audit interface globals. Audit plugins are inited later. */\n  mysql_audit_initialize();\n\n  /*\n    Perform basic logger initialization logger. Should be called after\n    MY_INIT, as it initializes mutexes. Log tables are inited later.\n  */\n  logger.init_base();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (ho_error)\n  {\n    /*\n      Parsing command line option failed,\n      Since we don't have a workable remaining_argc/remaining_argv\n      to continue the server initialization, this is as far as this\n      code can go.\n      This is the best effort to log meaningful messages:\n      - messages will be printed to stderr, which is not redirected yet,\n      - messages will be printed in the NT event log, for windows.\n    */\n    buffered_logs.print();\n    buffered_logs.cleanup();\n    /*\n      Not enough initializations for unireg_abort()\n      Using exit() for windows.\n    */\n    exit (ho_error);\n  }\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef _CUSTOMSTARTUPCONFIG_\n  if (_cust_check_startup())\n  {\n    / * _cust_check_startup will report startup failure error * /\n    exit(1);\n  }\n#endif\n\n  if (init_common_variables())\n    unireg_abort(1);\t\t\t\t// Will do exit\n\n  init_signals();\n\n  my_thread_stack_size= my_setstacksize(&connection_attrib,\n                                        my_thread_stack_size);\n\n  (void) thr_setconcurrency(concurrency);\t// 10 by default\n\n  select_thread=pthread_self();\n  select_thread_in_use=1;\n\n#ifdef HAVE_LIBWRAP\n  libwrapName= my_progname+dirname_length(my_progname);\n  openlog(libwrapName, LOG_PID, LOG_AUTH);\n#endif\n\n#ifndef DBUG_OFF\n  test_lc_time_sz();\n  srand((uint) time(NULL)); \n#endif\n\n  /*\n    We have enough space for fiddling with the argv, continue\n  */\n  check_data_home(mysql_real_data_home);\n  if (my_setwd(mysql_real_data_home, opt_abort ? 0 : MYF(MY_WME)) && !opt_abort)\n    unireg_abort(1);\t\t\t\t/* purecov: inspected */\n\n  if ((user_info= check_user(mysqld_user)))\n  {\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)\n    if (locked_in_memory) // getuid() == 0 here\n      set_effective_user(user_info);\n    else\n#endif\n      set_user(mysqld_user, user_info);\n  }\n\n  if (opt_bin_log && !server_id)\n  {\n    server_id= 1;\n#ifdef EXTRA_DEBUG\n    sql_print_warning(\"You have enabled the binary log, but you haven't set \"\n                      \"server-id to a non-zero value: we force server id to 1; \"\n                      \"updates will be logged to the binary log, but \"\n                      \"connections from slaves will not be accepted.\");\n#endif\n  }\n\n  /* \n   The subsequent calls may take a long time : e.g. innodb log read.\n   Thus set the long running service control manager timeout\n  */\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetSlowStarting(slow_start_timeout);\n#endif\n\n  if (init_server_components())\n    unireg_abort(1);\n\n  init_ssl();\n  network_init();\n\n#ifdef __WIN__\n  if (!opt_console)\n  {\n    if (reopen_fstreams(log_error_file, stdout, stderr))\n      unireg_abort(1);\n    setbuf(stderr, NULL);\n    FreeConsole();\t\t\t\t// Remove window\n  }\n#endif\n\n  /*\n   Initialize my_str_malloc() and my_str_free()\n  */\n  my_str_malloc= &my_str_malloc_mysqld;\n  my_str_free= &my_str_free_mysqld;\n\n  /*\n    init signals & alarm\n    After this we can't quit by a simple unireg_abort\n  */\n  start_signal_handler();\t\t\t\t// Creates pidfile\n\n  if (mysql_rm_tmp_tables() || acl_init(opt_noacl) ||\n      my_tz_init((THD *)0, default_tz_name, opt_bootstrap))\n  {\n    abort_loop=1;\n    select_thread_in_use=0;\n\n    (void) pthread_kill(signal_thread, MYSQL_KILL_SIGNAL);\n\n    delete_pid_file(MYF(MY_WME));\n\n    if (unix_sock != INVALID_SOCKET)\n      unlink(mysqld_unix_port);\n    exit(1);\n  }\n\n  if (!opt_noacl)\n    (void) grant_init();\n\n  if (!opt_bootstrap)\n    servers_init(0);\n\n  udf_init();\n\n  init_status_vars();\n  if (opt_bootstrap) /* If running with bootstrap, do not start replication. */\n    opt_skip_slave_start= 1;\n\n  binlog_unsafe_map_init();\n  /*\n    init_slave() must be called after the thread keys are created.\n    Some parts of the code (e.g. SHOW STATUS LIKE 'slave_running' and other\n    places) assume that active_mi != 0, so let's fail if it's 0 (out of\n    memory); a message has already been printed.\n  */\n  if (init_slave() && !active_mi)\n  {\n    unireg_abort(1);\n  }\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  initialize_performance_schema_acl(opt_bootstrap);\n  /*\n    Do not check the structure of the performance schema tables\n    during bootstrap:\n    - the tables are not supposed to exist yet, bootstrap will create them\n    - a check would print spurious error messages\n  */\n  if (! opt_bootstrap)\n    check_performance_schema();\n#endif\n\n  initialize_information_schema_acl();\n\n  execute_ddl_log_recovery();\n\n  if (Events::init(opt_noacl || opt_bootstrap))\n    unireg_abort(1);\n\n  if (opt_bootstrap)\n  {\n    select_thread_in_use= 0;                    // Allow 'kill' to work\n    bootstrap(mysql_stdin);\n    if (!kill_in_progress)\n      unireg_abort(bootstrap_error ? 1 : 0);\n    else\n    {\n      sleep(2);                                 // Wait for kill\n      exit(0);\n    }\n  }\n  if (opt_init_file && *opt_init_file)\n  {\n    if (read_init_file(opt_init_file))\n      unireg_abort(1);\n  }\n\n  create_shutdown_thread();\n  start_handle_manager();\n\n  sql_print_information(ER_DEFAULT(ER_STARTUP),my_progname,server_version,\n                        ((unix_sock == INVALID_SOCKET) ? (char*) \"\"\n                                                       : mysqld_unix_port),\n                         mysqld_port,\n                         MYSQL_COMPILATION_COMMENT);\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetRunning();\n#endif\n\n\n  /* Signal threads waiting for server to be started */\n  mysql_mutex_lock(&LOCK_server_started);\n  mysqld_server_started= 1;\n  mysql_cond_signal(&COND_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n\n#if defined(_WIN32) || defined(HAVE_SMEM)\n  handle_connections_methods();\n#else\n  handle_connections_sockets();\n#endif /* _WIN32 || HAVE_SMEM */\n\n  /* (void) pthread_attr_destroy(&connection_attrib); */\n\n  DBUG_PRINT(\"quit\",(\"Exiting main thread\"));\n\n#ifndef __WIN__\n#ifdef EXTRA_DEBUG2\n  sql_print_error(\"Before Lock_thread_count\");\n#endif\n  mysql_mutex_lock(&LOCK_thread_count);\n  DBUG_PRINT(\"quit\", (\"Got thread_count mutex\"));\n  select_thread_in_use=0;\t\t\t// For close_connections\n  mysql_mutex_unlock(&LOCK_thread_count);\n  mysql_cond_broadcast(&COND_thread_count);\n#ifdef EXTRA_DEBUG2\n  sql_print_error(\"After lock_thread_count\");\n#endif\n#endif /* __WIN__ */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Disable the main thread instrumentation,\n    to avoid recording events during the shutdown.\n  */\n  if (PSI_server)\n    PSI_server->delete_current_thread();\n#endif\n\n  /* Wait until cleanup is done */\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (!ready_to_exit)\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\n  if (Service.IsNT() && start_mode)\n    Service.Stop();\n  else\n  {\n    Service.SetShutdownEvent(0);\n    if (hEventShutdown)\n      CloseHandle(hEventShutdown);\n  }\n#endif\n  mysqld_exit(0);\n  return 0;\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Main and thread entry function for Win32\n  (all this is needed only to run mysqld as a service on WinNT)\n****************************************************************************/\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nint mysql_service(void *p)\n{\n  if (my_thread_init())\n    return 1;\n  \n  if (use_opt_args)\n    win_main(opt_argc, opt_argv);\n  else\n    win_main(Service.my_argc, Service.my_argv);\n\n  my_thread_end();\n  return 0;\n}\n\n\n/* Quote string if it contains space, else copy */\n\nstatic char *add_quoted_string(char *to, const char *from, char *to_end)\n{\n  uint length= (uint) (to_end-to);\n\n  if (!strchr(from, ' '))\n    return strmake(to, from, length-1);\n  return strxnmov(to, length-1, \"\\\"\", from, \"\\\"\", NullS);\n}\n\n\n/**\n  Handle basic handling of services, like installation and removal.\n\n  @param argv\t   \t        Pointer to argument list\n  @param servicename\t\tInternal name of service\n  @param displayname\t\tDisplay name of service (in taskbar ?)\n  @param file_path\t\tPath to this program\n  @param startup_option\tStartup option to mysqld\n\n  @retval 0\toption handled\n  @retval 1\tCould not handle option\n*/\n\nstatic bool\ndefault_service_handling(char **argv,\n\t\t\t const char *servicename,\n\t\t\t const char *displayname,\n\t\t\t const char *file_path,\n\t\t\t const char *extra_opt,\n\t\t\t const char *account_name)\n{\n  char path_and_service[FN_REFLEN+FN_REFLEN+32], *pos, *end;\n  const char *opt_delim;\n  end= path_and_service + sizeof(path_and_service)-3;\n\n  /* We have to quote filename if it contains spaces */\n  pos= add_quoted_string(path_and_service, file_path, end);\n  if (extra_opt && *extra_opt)\n  {\n    /* \n     Add option after file_path. There will be zero or one extra option.  It's \n     assumed to be --defaults-file=file but isn't checked.  The variable (not\n     the option name) should be quoted if it contains a string.  \n    */\n    *pos++= ' ';\n    if (opt_delim= strchr(extra_opt, '='))\n    {\n      size_t length= ++opt_delim - extra_opt;\n      pos= strnmov(pos, extra_opt, length);\n    }\n    else\n      opt_delim= extra_opt;\n    \n    pos= add_quoted_string(pos, opt_delim, end);\n  }\n  /* We must have servicename last */\n  *pos++= ' ';\n  (void) add_quoted_string(pos, servicename, end);\n\n  if (Service.got_service_option(argv, \"install\"))\n  {\n    Service.Install(1, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"install-manual\"))\n  {\n    Service.Install(0, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"remove\"))\n  {\n    Service.Remove(servicename);\n    return 0;\n  }\n  return 1;\n}\n\n\nint mysqld_main(int argc, char **argv)\n{\n  my_progname= argv[0];\n\n  /*\n    When several instances are running on the same machine, we\n    need to have an  unique  named  hEventShudown  through the\n    application PID e.g.: MySQLShutdown1890; MySQLShutdown2342\n  */\n  int10_to_str((int) GetCurrentProcessId(),strmov(shutdown_event_name,\n                                                  \"MySQLShutdown\"), 10);\n\n  /* Must be initialized early for comparison of service name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  if (my_init())\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n\n  if (Service.GetOS())\t/* true NT family */\n  {\n    char file_path[FN_REFLEN];\n    my_path(file_path, argv[0], \"\");\t\t      /* Find name in path */\n    fn_format(file_path,argv[0],file_path,\"\",\n\t      MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_RESOLVE_SYMLINKS);\n\n    if (argc == 2)\n    {\n      if (!default_service_handling(argv, MYSQL_SERVICENAME, MYSQL_SERVICENAME,\n\t\t\t\t   file_path, \"\", NULL))\n\treturn 0;\n      if (Service.IsService(argv[1]))        /* Start an optional service */\n      {\n\t/*\n\t  Only add the service name to the groups read from the config file\n\t  if it's not \"MySQL\". (The default service name should be 'mysqld'\n\t  but we started a bad tradition by calling it MySQL from the start\n\t  and we are now stuck with it.\n\t*/\n\tif (my_strcasecmp(system_charset_info, argv[1],\"mysql\"))\n\t  load_default_groups[load_default_groups_sz-2]= argv[1];\n        start_mode= 1;\n        Service.Init(argv[1], mysql_service);\n        return 0;\n      }\n    }\n    else if (argc == 3) /* install or remove any optional service */\n    {\n      if (!default_service_handling(argv, argv[2], argv[2], file_path, \"\",\n                                    NULL))\n\treturn 0;\n      if (Service.IsService(argv[2]))\n      {\n\t/*\n\t  mysqld was started as\n\t  mysqld --defaults-file=my_path\\my.ini service-name\n\t*/\n\tuse_opt_args=1;\n\topt_argc= 2;\t\t\t\t// Skip service-name\n\topt_argv=argv;\n\tstart_mode= 1;\n\tif (my_strcasecmp(system_charset_info, argv[2],\"mysql\"))\n\t  load_default_groups[load_default_groups_sz-2]= argv[2];\n\tService.Init(argv[2], mysql_service);\n\treturn 0;\n      }\n    }\n    else if (argc == 4 || argc == 5)\n    {\n      /*\n        This may seem strange, because we handle --local-service while\n        preserving 4.1's behavior of allowing any one other argument that is\n        passed to the service on startup. (The assumption is that this is\n        --defaults-file=file, but that was not enforced in 4.1, so we don't\n        enforce it here.)\n      */\n      const char *extra_opt= NullS;\n      const char *account_name = NullS;\n      int index;\n      for (index = 3; index < argc; index++)\n      {\n        if (!strcmp(argv[index], \"--local-service\"))\n          account_name= \"NT AUTHORITY\\\\LocalService\";\n        else\n          extra_opt= argv[index];\n      }\n\n      if (argc == 4 || account_name)\n        if (!default_service_handling(argv, argv[2], argv[2], file_path,\n                                      extra_opt, account_name))\n          return 0;\n    }\n    else if (argc == 1 && Service.IsService(MYSQL_SERVICENAME))\n    {\n      /* start the default service */\n      start_mode= 1;\n      Service.Init(MYSQL_SERVICENAME, mysql_service);\n      return 0;\n    }\n  }\n  /* Start as standalone server */\n  Service.my_argc=argc;\n  Service.my_argv=argv;\n  mysql_service(NULL);\n  return 0;\n}\n#endif\n\n\n/**\n  Execute all commands from a file. Used by the mysql_install_db script to\n  create MySQL privilege tables without having to start a full MySQL server.\n*/\n\nstatic void bootstrap(MYSQL_FILE *file)\n{\n  DBUG_ENTER(\"bootstrap\");\n\n  THD *thd= new THD;\n  thd->bootstrap=1;\n  my_net_init(&thd->net,(st_vio*) 0);\n  thd->max_client_packet_length= thd->net.max_packet;\n  thd->security_ctx->master_access= ~(ulong)0;\n  thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;\n  thread_count++;\n  in_bootstrap= TRUE;\n\n  bootstrap_file=file;\n#ifndef EMBEDDED_LIBRARY\t\t\t// TODO:  Enable this\n  int error;\n  if ((error= mysql_thread_create(key_thread_bootstrap,\n                                  &thd->real_id, &connection_attrib,\n                                  handle_bootstrap,\n                                  (void*) thd)))\n  {\n    sql_print_warning(\"Can't create thread to handle bootstrap (errno= %d)\",\n                      error);\n    bootstrap_error=-1;\n    DBUG_VOID_RETURN;\n  }\n  /* Wait for thread to die */\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (in_bootstrap)\n  {\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n    DBUG_PRINT(\"quit\",(\"One thread died (count=%u)\",thread_count));\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n#else\n  thd->mysql= 0;\n  do_handle_bootstrap(thd);\n#endif\n\n  DBUG_VOID_RETURN;\n}\n\n\nstatic bool read_init_file(char *file_name)\n{\n  MYSQL_FILE *file;\n  DBUG_ENTER(\"read_init_file\");\n  DBUG_PRINT(\"enter\",(\"name: %s\",file_name));\n  if (!(file= mysql_file_fopen(key_file_init, file_name,\n                               O_RDONLY, MYF(MY_WME))))\n    DBUG_RETURN(TRUE);\n  bootstrap(file);\n  mysql_file_fclose(file, MYF(MY_WME));\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Increment number of created threads\n*/\nvoid inc_thread_created(void)\n{\n  thread_created++;\n}\n\n#ifndef EMBEDDED_LIBRARY\n\n/*\n   Simple scheduler that use the main thread to handle the request\n\n   NOTES\n     This is only used for debugging, when starting mysqld with\n     --thread-handling=no-threads or --one-thread\n\n     When we enter this function, LOCK_thread_count is hold!\n*/\n\nvoid handle_connection_in_main_thread(THD *thd)\n{\n  mysql_mutex_assert_owner(&LOCK_thread_count);\n  thread_cache_size=0;\t\t\t// Safety\n  threads.append(thd);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  thd->start_utime= microsecond_interval_timer();\n  do_handle_one_connection(thd);\n}\n\n\n/*\n  Scheduler that uses one thread per connection\n*/\n\nvoid create_thread_to_handle_connection(THD *thd)\n{\n  if (cached_thread_count > wake_thread)\n  {\n    /* Get thread from cache */\n    thread_cache.push_back(thd);\n    wake_thread++;\n    mysql_cond_signal(&COND_thread_cache);\n  }\n  else\n  {\n    char error_message_buff[MYSQL_ERRMSG_SIZE];\n    /* Create new thread to handle connection */\n    int error;\n    thread_created++;\n    threads.append(thd);\n    DBUG_PRINT(\"info\",((\"creating thread %lu\"), thd->thread_id));\n    thd->prior_thr_create_utime= microsecond_interval_timer();\n    if ((error= mysql_thread_create(key_thread_one_connection,\n                                    &thd->real_id, &connection_attrib,\n                                    handle_one_connection,\n                                    (void*) thd)))\n    {\n      /* purecov: begin inspected */\n      DBUG_PRINT(\"error\",\n                 (\"Can't create thread to handle request (error %d)\",\n                  error));\n\n      thread_count--;\n      thd->killed= KILL_CONNECTION;             // Safety\n      mysql_mutex_unlock(&LOCK_thread_count);\n\n      mysql_mutex_lock(&LOCK_connection_count);\n      (*thd->scheduler->connection_count)--;\n      mysql_mutex_unlock(&LOCK_connection_count);\n\n      statistic_increment(aborted_connects,&LOCK_status);\n      /* Can't use my_error() since store_globals has not been called. */\n      my_snprintf(error_message_buff, sizeof(error_message_buff),\n                  ER_THD(thd, ER_CANT_CREATE_THREAD), error);\n      net_send_error(thd, ER_CANT_CREATE_THREAD, error_message_buff, NULL);\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      mysql_mutex_lock(&LOCK_thread_count);\n      delete thd;\n      mysql_mutex_unlock(&LOCK_thread_count);\n      return;\n      /* purecov: end */\n    }\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n  DBUG_PRINT(\"info\",(\"Thread created\"));\n}\n\n\n/**\n  Create new thread to handle incoming connection.\n\n    This function will create new thread to handle the incoming\n    connection.  If there are idle cached threads one will be used.\n    'thd' will be pushed into 'threads'.\n\n    In single-threaded mode (\\#define ONE_THREAD) connection will be\n    handled inside this function.\n\n  @param[in,out] thd    Thread handle of future thread.\n*/\n\nstatic void create_new_thread(THD *thd)\n{\n  DBUG_ENTER(\"create_new_thread\");\n\n  /*\n    Don't allow too many connections. We roughly check here that we allow\n    only (max_connections + 1) connections.\n  */\n\n  mysql_mutex_lock(&LOCK_connection_count);\n\n  if (*thd->scheduler->connection_count >=\n      *thd->scheduler->max_connections + 1|| abort_loop)\n  {\n    mysql_mutex_unlock(&LOCK_connection_count);\n\n    DBUG_PRINT(\"error\",(\"Too many connections\"));\n    close_connection(thd, ER_CON_COUNT_ERROR);\n    statistic_increment(denied_connections, &LOCK_status);\n    delete thd;\n    DBUG_VOID_RETURN;\n  }\n\n  ++*thd->scheduler->connection_count;\n\n  if (connection_count + extra_connection_count > max_used_connections)\n    max_used_connections= connection_count + extra_connection_count;\n\n  mysql_mutex_unlock(&LOCK_connection_count);\n\n  /* Start a new thread to handle connection. */\n\n  mysql_mutex_lock(&LOCK_thread_count);\n\n  /*\n    The initialization of thread_id is done in create_embedded_thd() for\n    the embedded library.\n    TODO: refactor this to avoid code duplication there\n  */\n  thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;\n\n  thread_count++;\n\n  MYSQL_CALLBACK(thd->scheduler, add_connection, (thd));\n\n  DBUG_VOID_RETURN;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n#ifdef SIGNALS_DONT_BREAK_READ\ninline void kill_broken_server()\n{\n  /* hack to get around signals ignored in syscalls for problem OS's */\n  if (unix_sock == INVALID_SOCKET ||\n      (!opt_disable_networking && base_ip_sock == INVALID_SOCKET))\n  {\n    select_thread_in_use = 0;\n    /* The following call will never return */\n    DBUG_PRINT(\"general\", (\"killing server because socket is closed\"));\n    kill_server((void*) MYSQL_KILL_SIGNAL);\n  }\n}\n#define MAYBE_BROKEN_SYSCALL kill_broken_server();\n#else\n#define MAYBE_BROKEN_SYSCALL\n#endif\n\n\t/* Handle new connections and spawn new process to handle them */\n\n#ifndef EMBEDDED_LIBRARY\n\nvoid handle_connections_sockets()\n{\n  my_socket UNINIT_VAR(sock), UNINIT_VAR(new_sock);\n  uint error_count=0;\n  THD *thd;\n  struct sockaddr_storage cAddr;\n  int ip_flags __attribute__((unused))=0;\n  int socket_flags __attribute__((unused))= 0;\n  int extra_ip_flags __attribute__((unused))=0;\n  int flags=0,retval;\n  st_vio *vio_tmp;\n#ifdef HAVE_POLL\n  int socket_count= 0;\n  struct pollfd fds[3]; // for ip_sock, unix_sock and extra_ip_sock\n#define setup_fds(X)                    \\\n    fds[socket_count].fd= X;            \\\n    fds[socket_count].events= POLLIN;   \\\n    socket_count++\n#else\n  fd_set readFDs,clientFDs;\n  uint max_used_connection= (uint)\n    max(max(base_ip_sock, unix_sock), extra_ip_sock) + 1;\n#define setup_fds(X)    FD_SET(X,&clientFDs)\n  FD_ZERO(&clientFDs);\n#endif\n\n  DBUG_ENTER(\"handle_connections_sockets\");\n\n  if (base_ip_sock != INVALID_SOCKET)\n  {\n    setup_fds(base_ip_sock);\n    ip_flags = fcntl(base_ip_sock, F_GETFL, 0);\n  }\n  if (extra_ip_sock != INVALID_SOCKET)\n  {\n    setup_fds(extra_ip_sock);\n    extra_ip_flags = fcntl(extra_ip_sock, F_GETFL, 0);\n  }\n#ifdef HAVE_SYS_UN_H\n  setup_fds(unix_sock);\n  socket_flags=fcntl(unix_sock, F_GETFL, 0);\n#endif\n\n  DBUG_PRINT(\"general\",(\"Waiting for connections.\"));\n  MAYBE_BROKEN_SYSCALL;\n  while (!abort_loop)\n  {\n#ifdef HAVE_POLL\n    retval= poll(fds, socket_count, -1);\n#else\n    readFDs=clientFDs;\n\n    retval= select((int) max_used_connection,&readFDs,0,0,0);\n#endif\n\n    if (retval < 0)\n    {\n      if (socket_errno != SOCKET_EINTR)\n      {\n\tif (!select_errors++ && !abort_loop)\t/* purecov: inspected */\n\t  sql_print_error(\"mysqld: Got error %d from select\",socket_errno); /* purecov: inspected */\n      }\n      MAYBE_BROKEN_SYSCALL\n      continue;\n    }\n\n    if (abort_loop)\n    {\n      MAYBE_BROKEN_SYSCALL;\n      break;\n    }\n\n    /* Is this a new connection request ? */\n#ifdef HAVE_POLL\n    for (int i= 0; i < socket_count; ++i) \n    {\n      if (fds[i].revents & POLLIN)\n      {\n        sock= fds[i].fd;\n        flags= fcntl(sock, F_GETFL, 0);\n        break;\n      }\n    }\n#else  // HAVE_POLL\n    if (FD_ISSET(base_ip_sock,&readFDs))\n    {\n      sock=  base_ip_sock;\n      flags= ip_flags;\n    }\n    else\n    if (FD_ISSET(extra_ip_sock,&readFDs))\n    {\n      sock=  extra_ip_sock;\n      flags= extra_ip_flags;\n    }\n    else\n    {\n      sock = unix_sock;\n      flags= socket_flags;\n    }\n#endif // HAVE_POLL\n\n#if !defined(NO_FCNTL_NONBLOCK)\n    if (!(test_flags & TEST_BLOCKING))\n    {\n#if defined(O_NONBLOCK)\n      fcntl(sock, F_SETFL, flags | O_NONBLOCK);\n#elif defined(O_NDELAY)\n      fcntl(sock, F_SETFL, flags | O_NDELAY);\n#endif\n    }\n#endif /* NO_FCNTL_NONBLOCK */\n    for (uint retry=0; retry < MAX_ACCEPT_RETRY; retry++)\n    {\n      size_socket length= sizeof(struct sockaddr_storage);\n      new_sock= accept(sock, (struct sockaddr *)(&cAddr),\n                       &length);\n      if (new_sock != INVALID_SOCKET ||\n\t  (socket_errno != SOCKET_EINTR && socket_errno != SOCKET_EAGAIN))\n\tbreak;\n      MAYBE_BROKEN_SYSCALL;\n#if !defined(NO_FCNTL_NONBLOCK)\n      if (!(test_flags & TEST_BLOCKING))\n      {\n\tif (retry == MAX_ACCEPT_RETRY - 1)\n\t  fcntl(sock, F_SETFL, flags);\t\t// Try without O_NONBLOCK\n      }\n#endif\n    }\n#if !defined(NO_FCNTL_NONBLOCK)\n    if (!(test_flags & TEST_BLOCKING))\n      fcntl(sock, F_SETFL, flags);\n#endif\n    if (new_sock == INVALID_SOCKET)\n    {\n      if ((error_count++ & 255) == 0)\t\t// This can happen often\n\tsql_perror(\"Error in accept\");\n      MAYBE_BROKEN_SYSCALL;\n      if (socket_errno == SOCKET_ENFILE || socket_errno == SOCKET_EMFILE)\n\tsleep(1);\t\t\t\t// Give other threads some time\n      continue;\n    }\n\n#ifdef HAVE_LIBWRAP\n    {\n      if (sock == base_ip_sock || sock == extra_ip_sock)\n      {\n\tstruct request_info req;\n\tsignal(SIGCHLD, SIG_DFL);\n\trequest_init(&req, RQ_DAEMON, libwrapName, RQ_FILE, new_sock, NULL);\n\tmy_fromhost(&req);\n\tif (!my_hosts_access(&req))\n\t{\n\t  /*\n\t    This may be stupid but refuse() includes an exit(0)\n\t    which we surely don't want...\n\t    clean_exit() - same stupid thing ...\n\t  */\n\t  syslog(deny_severity, \"refused connect from %s\",\n\t\t my_eval_client(&req));\n\n\t  /*\n\t    C++ sucks (the gibberish in front just translates the supplied\n\t    sink function pointer in the req structure from a void (*sink)();\n\t    to a void(*sink)(int) if you omit the cast, the C++ compiler\n\t    will cry...\n\t  */\n\t  if (req.sink)\n\t    ((void (*)(int))req.sink)(req.fd);\n\n\t  (void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t  (void) closesocket(new_sock);\n\t  continue;\n\t}\n      }\n    }\n#endif /* HAVE_LIBWRAP */\n\n    {\n      size_socket dummyLen;\n      struct sockaddr_storage dummy;\n      dummyLen = sizeof(dummy);\n      if (  getsockname(new_sock,(struct sockaddr *)&dummy, \n                  (SOCKET_SIZE_TYPE *)&dummyLen) < 0  )\n      {\n\tsql_perror(\"Error on new connection socket\");\n\t(void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t(void) closesocket(new_sock);\n\tcontinue;\n      }\n    }\n\n    /*\n    ** Don't allow too many connections\n    */\n\n    if (!(thd= new THD))\n    {\n      (void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n      (void) closesocket(new_sock);\n      continue;\n    }\n    if (!(vio_tmp=vio_new(new_sock,\n\t\t\t  sock == unix_sock ? VIO_TYPE_SOCKET :\n\t\t\t  VIO_TYPE_TCPIP,\n\t\t\t  sock == unix_sock ? VIO_LOCALHOST: 0)) ||\n\tmy_net_init(&thd->net,vio_tmp))\n    {\n      /*\n        Only delete the temporary vio if we didn't already attach it to the\n        NET object. The destructor in THD will delete any initialized net\n        structure.\n      */\n      if (vio_tmp && thd->net.vio != vio_tmp)\n        vio_delete(vio_tmp);\n      else\n      {\n\t(void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t(void) closesocket(new_sock);\n      }\n      delete thd;\n      continue;\n    }\n    if (sock == unix_sock)\n      thd->security_ctx->host=(char*) my_localhost;\n\n    if (sock == extra_ip_sock)\n    {\n      thd->extra_port= 1;\n      thd->scheduler= extra_thread_scheduler;\n    }\n    create_new_thread(thd);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\n#ifdef _WIN32\npthread_handler_t handle_connections_sockets_thread(void *arg)\n{\n  my_thread_init();\n  handle_connections_sockets();\n  decrement_handler_count();\n  return 0;\n}\n\npthread_handler_t handle_connections_namedpipes(void *arg)\n{\n  HANDLE hConnectedPipe;\n  OVERLAPPED connectOverlapped= {0};\n  THD *thd;\n  my_thread_init();\n  DBUG_ENTER(\"handle_connections_namedpipes\");\n  connectOverlapped.hEvent= CreateEvent(NULL, TRUE, FALSE, NULL);\n  if (!connectOverlapped.hEvent)\n  {\n    sql_print_error(\"Can't create event, last error=%u\", GetLastError());\n    unireg_abort(1);\n  }\n  DBUG_PRINT(\"general\",(\"Waiting for named pipe connections.\"));\n  while (!abort_loop)\n  {\n    /* wait for named pipe connection */\n    BOOL fConnected= ConnectNamedPipe(hPipe, &connectOverlapped);\n    if (!fConnected && (GetLastError() == ERROR_IO_PENDING))\n    {\n        /*\n          ERROR_IO_PENDING says async IO has started but not yet finished.\n          GetOverlappedResult will wait for completion.\n        */\n        DWORD bytes;\n        fConnected= GetOverlappedResult(hPipe, &connectOverlapped,&bytes, TRUE);\n    }\n    if (abort_loop)\n      break;\n    if (!fConnected)\n      fConnected = GetLastError() == ERROR_PIPE_CONNECTED;\n    if (!fConnected)\n    {\n      CloseHandle(hPipe);\n      if ((hPipe= CreateNamedPipe(pipe_name,\n                                  PIPE_ACCESS_DUPLEX |\n                                  FILE_FLAG_OVERLAPPED,\n                                  PIPE_TYPE_BYTE |\n                                  PIPE_READMODE_BYTE |\n                                  PIPE_WAIT,\n                                  PIPE_UNLIMITED_INSTANCES,\n                                  (int) global_system_variables.\n                                  net_buffer_length,\n                                  (int) global_system_variables.\n                                  net_buffer_length,\n                                  NMPWAIT_USE_DEFAULT_WAIT,\n                                  &saPipeSecurity)) ==\n\t  INVALID_HANDLE_VALUE)\n      {\n\tsql_perror(\"Can't create new named pipe!\");\n\tbreak;\t\t\t\t\t// Abort\n      }\n    }\n    hConnectedPipe = hPipe;\n    /* create new pipe for new connection */\n    if ((hPipe = CreateNamedPipe(pipe_name,\n                 PIPE_ACCESS_DUPLEX |\n                 FILE_FLAG_OVERLAPPED,\n\t\t\t\t PIPE_TYPE_BYTE |\n\t\t\t\t PIPE_READMODE_BYTE |\n\t\t\t\t PIPE_WAIT,\n\t\t\t\t PIPE_UNLIMITED_INSTANCES,\n\t\t\t\t (int) global_system_variables.net_buffer_length,\n\t\t\t\t (int) global_system_variables.net_buffer_length,\n\t\t\t\t NMPWAIT_USE_DEFAULT_WAIT,\n\t\t\t\t &saPipeSecurity)) ==\n\tINVALID_HANDLE_VALUE)\n    {\n      sql_perror(\"Can't create new named pipe!\");\n      hPipe=hConnectedPipe;\n      continue;\t\t\t\t\t// We have to try again\n    }\n\n    if (!(thd = new THD))\n    {\n      DisconnectNamedPipe(hConnectedPipe);\n      CloseHandle(hConnectedPipe);\n      continue;\n    }\n    if (!(thd->net.vio= vio_new_win32pipe(hConnectedPipe)) ||\n\tmy_net_init(&thd->net, thd->net.vio))\n    {\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      delete thd;\n      continue;\n    }\n    /* Host is unknown */\n    thd->security_ctx->host= my_strdup(my_localhost, MYF(0));\n    create_new_thread(thd);\n  }\n  CloseHandle(connectOverlapped.hEvent);\n  DBUG_LEAVE;\n  decrement_handler_count();\n  return 0;\n}\n#endif /* _WIN32 */\n\n\n#ifdef HAVE_SMEM\n\n/**\n  Thread of shared memory's service.\n\n  @param arg                              Arguments of thread\n*/\npthread_handler_t handle_connections_shared_memory(void *arg)\n{\n  /* file-mapping object, use for create shared memory */\n  HANDLE handle_connect_file_map= 0;\n  char  *handle_connect_map= 0;                 // pointer on shared memory\n  HANDLE event_connect_answer= 0;\n  ulong smem_buffer_length= shared_memory_buffer_length + 4;\n  ulong connect_number= 1;\n  char *tmp= NULL;\n  char *suffix_pos;\n  char connect_number_char[22], *p;\n  const char *errmsg= 0;\n  SECURITY_ATTRIBUTES *sa_event= 0, *sa_mapping= 0;\n  my_thread_init();\n  DBUG_ENTER(\"handle_connections_shared_memorys\");\n  DBUG_PRINT(\"general\",(\"Waiting for allocated shared memory.\"));\n\n  /*\n     get enough space base-name + '_' + longest suffix we might ever send\n   */\n  if (!(tmp= (char *)my_malloc(strlen(shared_memory_base_name) + 32L, MYF(MY_FAE))))\n    goto error;\n\n  if (my_security_attr_create(&sa_event, &errmsg,\n                              GENERIC_ALL, SYNCHRONIZE | EVENT_MODIFY_STATE))\n    goto error;\n\n  if (my_security_attr_create(&sa_mapping, &errmsg,\n                             GENERIC_ALL, FILE_MAP_READ | FILE_MAP_WRITE))\n    goto error;\n\n  /*\n    The name of event and file-mapping events create agree next rule:\n      shared_memory_base_name+unique_part\n    Where:\n      shared_memory_base_name is unique value for each server\n      unique_part is unique value for each object (events and file-mapping)\n  */\n  suffix_pos= strxmov(tmp,shared_memory_base_name,\"_\",NullS);\n  strmov(suffix_pos, \"CONNECT_REQUEST\");\n  if ((smem_event_connect_request= CreateEvent(sa_event,\n                                               FALSE, FALSE, tmp)) == 0)\n  {\n    errmsg= \"Could not create request event\";\n    goto error;\n  }\n  strmov(suffix_pos, \"CONNECT_ANSWER\");\n  if ((event_connect_answer= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n  {\n    errmsg=\"Could not create answer event\";\n    goto error;\n  }\n  strmov(suffix_pos, \"CONNECT_DATA\");\n  if ((handle_connect_file_map=\n       CreateFileMapping(INVALID_HANDLE_VALUE, sa_mapping,\n                         PAGE_READWRITE, 0, sizeof(connect_number), tmp)) == 0)\n  {\n    errmsg= \"Could not create file mapping\";\n    goto error;\n  }\n  if ((handle_connect_map= (char *)MapViewOfFile(handle_connect_file_map,\n\t\t\t\t\t\t  FILE_MAP_WRITE,0,0,\n\t\t\t\t\t\t  sizeof(DWORD))) == 0)\n  {\n    errmsg= \"Could not create shared memory service\";\n    goto error;\n  }\n\n  while (!abort_loop)\n  {\n    /* Wait a request from client */\n    WaitForSingleObject(smem_event_connect_request,INFINITE);\n\n    /*\n       it can be after shutdown command\n    */\n    if (abort_loop)\n      goto error;\n\n    HANDLE handle_client_file_map= 0;\n    char  *handle_client_map= 0;\n    HANDLE event_client_wrote= 0;\n    HANDLE event_client_read= 0;    // for transfer data server <-> client\n    HANDLE event_server_wrote= 0;\n    HANDLE event_server_read= 0;\n    HANDLE event_conn_closed= 0;\n    THD *thd= 0;\n\n    p= int10_to_str(connect_number, connect_number_char, 10);\n    /*\n      The name of event and file-mapping events create agree next rule:\n        shared_memory_base_name+unique_part+number_of_connection\n        Where:\n\t  shared_memory_base_name is uniquel value for each server\n\t  unique_part is unique value for each object (events and file-mapping)\n\t  number_of_connection is connection-number between server and client\n    */\n    suffix_pos= strxmov(tmp,shared_memory_base_name,\"_\",connect_number_char,\n\t\t\t \"_\",NullS);\n    strmov(suffix_pos, \"DATA\");\n    if ((handle_client_file_map=\n         CreateFileMapping(INVALID_HANDLE_VALUE, sa_mapping,\n                           PAGE_READWRITE, 0, smem_buffer_length, tmp)) == 0)\n    {\n      errmsg= \"Could not create file mapping\";\n      goto errorconn;\n    }\n    if ((handle_client_map= (char*)MapViewOfFile(handle_client_file_map,\n\t\t\t\t\t\t  FILE_MAP_WRITE,0,0,\n\t\t\t\t\t\t  smem_buffer_length)) == 0)\n    {\n      errmsg= \"Could not create memory map\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CLIENT_WROTE\");\n    if ((event_client_wrote= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create client write event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CLIENT_READ\");\n    if ((event_client_read= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create client read event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"SERVER_READ\");\n    if ((event_server_read= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create server read event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"SERVER_WROTE\");\n    if ((event_server_wrote= CreateEvent(sa_event,\n                                         FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create server write event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CONNECTION_CLOSED\");\n    if ((event_conn_closed= CreateEvent(sa_event,\n                                        TRUE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create closed connection event\";\n      goto errorconn;\n    }\n    if (abort_loop)\n      goto errorconn;\n    if (!(thd= new THD))\n      goto errorconn;\n    /* Send number of connection to client */\n    int4store(handle_connect_map, connect_number);\n    if (!SetEvent(event_connect_answer))\n    {\n      errmsg= \"Could not send answer event\";\n      goto errorconn;\n    }\n    /* Set event that client should receive data */\n    if (!SetEvent(event_client_read))\n    {\n      errmsg= \"Could not set client to read mode\";\n      goto errorconn;\n    }\n    if (!(thd->net.vio= vio_new_win32shared_memory(handle_client_file_map,\n                                                   handle_client_map,\n                                                   event_client_wrote,\n                                                   event_client_read,\n                                                   event_server_wrote,\n                                                   event_server_read,\n                                                   event_conn_closed)) ||\n                        my_net_init(&thd->net, thd->net.vio))\n    {\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      errmsg= 0;\n      goto errorconn;\n    }\n    thd->security_ctx->host= my_strdup(my_localhost, MYF(0)); /* Host is unknown */\n    create_new_thread(thd);\n    connect_number++;\n    continue;\n\nerrorconn:\n    /* Could not form connection;  Free used handlers/memort and retry */\n    if (errmsg)\n    {\n      char buff[180];\n      strxmov(buff, \"Can't create shared memory connection: \", errmsg, \".\",\n\t      NullS);\n      sql_perror(buff);\n    }\n    if (handle_client_file_map)\n      CloseHandle(handle_client_file_map);\n    if (handle_client_map)\n      UnmapViewOfFile(handle_client_map);\n    if (event_server_wrote)\n      CloseHandle(event_server_wrote);\n    if (event_server_read)\n      CloseHandle(event_server_read);\n    if (event_client_wrote)\n      CloseHandle(event_client_wrote);\n    if (event_client_read)\n      CloseHandle(event_client_read);\n    if (event_conn_closed)\n      CloseHandle(event_conn_closed);\n    delete thd;\n  }\n\n  /* End shared memory handling */\nerror:\n  if (tmp)\n    my_free(tmp);\n\n  if (errmsg)\n  {\n    char buff[180];\n    strxmov(buff, \"Can't create shared memory service: \", errmsg, \".\", NullS);\n    sql_perror(buff);\n  }\n  my_security_attr_free(sa_event);\n  my_security_attr_free(sa_mapping);\n  if (handle_connect_map)\tUnmapViewOfFile(handle_connect_map);\n  if (handle_connect_file_map)\tCloseHandle(handle_connect_file_map);\n  if (event_connect_answer)\tCloseHandle(event_connect_answer);\n  if (smem_event_connect_request) CloseHandle(smem_event_connect_request);\n  DBUG_LEAVE;\n  decrement_handler_count();\n  return 0;\n}\n#endif /* HAVE_SMEM */\n#endif /* EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Handle start options\n******************************************************************************/\n\n/**\n  System variables are automatically command-line options (few\n  exceptions are documented in sys_var.h), so don't need\n  to be listed here.\n*/\n\nstruct my_option my_long_options[]=\n{\n  {\"help\", '?', \"Display this help and exit.\", \n   &opt_help, &opt_help, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0,\n   0, 0},\n  {\"allow-suspicious-udfs\", 0,\n   \"Allows use of UDFs consisting of only one symbol xxx() \"\n   \"without corresponding xxx_init() or xxx_deinit(). That also means \"\n   \"that one can load any function from any library, for example exit() \"\n   \"from libc.so\",\n   &opt_allow_suspicious_udfs, &opt_allow_suspicious_udfs,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"ansi\", 'a', \"Use ANSI SQL syntax instead of MySQL syntax. This mode \"\n   \"will also set transaction isolation level 'serializable'.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /*\n    Because Sys_var_bit does not support command-line options, we need to\n    explicitely add one for --autocommit\n  */\n  {\"autocommit\", 0, \"Set default value for autocommit (0 or 1)\",\n   &opt_autocommit, &opt_autocommit, 0,\n   GET_BOOL, OPT_ARG, 1, 0, 0, 0, 0, NULL},\n  {\"bind-address\", OPT_BIND_ADDRESS, \"IP address to bind to.\",\n   &my_bind_addr_str, &my_bind_addr_str, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-do-db\", OPT_BINLOG_DO_DB,\n   \"Tells the master it should log updates for the specified database, \"\n   \"and exclude all others not explicitly mentioned.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-ignore-db\", OPT_BINLOG_IGNORE_DB,\n   \"Tells the master that updates to the given database should not be logged to the binary log.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-row-event-max-size\", 0,\n   \"The maximum size of a row-based binary log event in bytes. Rows will be \"\n   \"grouped into events smaller than this size if possible. \"\n   \"The value has to be a multiple of 256.\",\n   &opt_binlog_rows_event_max_size, &opt_binlog_rows_event_max_size,\n   0, GET_ULONG, REQUIRED_ARG,\n   /* def_value */ 1024, /* min_value */  256, /* max_value */ ULONG_MAX, \n   /* sub_size */     0, /* block_size */ 256, \n   /* app_type */ 0\n  },\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"bootstrap\", OPT_BOOTSTRAP, \"Used by mysql installation scripts.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"character-set-client-handshake\", 0,\n   \"Don't ignore client side character set value sent during handshake.\",\n   &opt_character_set_client_handshake,\n   &opt_character_set_client_handshake,\n    0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n  {\"character-set-filesystem\", 0,\n   \"Set the filesystem character set.\",\n   &character_set_filesystem_name,\n   &character_set_filesystem_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"character-set-server\", 'C', \"Set the default character set.\",\n   &default_character_set_name, &default_character_set_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"chroot\", 'r', \"Chroot mysqld daemon during startup.\",\n   &mysqld_chroot, &mysqld_chroot, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"collation-server\", 0, \"Set the default collation.\",\n   &default_collation_name, &default_collation_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"console\", OPT_CONSOLE, \"Write error output on screen; don't remove the console window on windows.\",\n   &opt_console, &opt_console, 0, GET_BOOL, NO_ARG, 0, 0, 0,\n   0, 0, 0},\n  {\"core-file\", OPT_WANT_CORE, \"Write core on errors.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* default-storage-engine should have \"MyISAM\" as def_value. Instead\n     of initializing it here it is done in init_common_variables() due\n     to a compiler bug in Sun Studio compiler. */\n#ifdef DBUG_OFF\n  {\"debug\", '#', \"Built in DBUG debugger. Disabled in this build.\",\n   &current_dbug_option, &current_dbug_option, 0, GET_STR, OPT_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"debug-abort-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &abort_slave_event_count,  &abort_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n#ifndef DBUG_OFF\n  {\"debug-assert-on-error\", 0,\n   \"Do an assert in various functions if we get a fatal error\",\n   &my_assert_on_error, &my_assert_on_error,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"debug-assert-if-crashed-table\", 0,\n   \"Do an assert in handler::print_error() if we get a crashed table\",\n   &debug_assert_if_crashed_table, &debug_assert_if_crashed_table,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"debug-disconnect-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &disconnect_slave_event_count, &disconnect_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"debug-exit-info\", 'T', \"Used for debugging. Use at your own risk.\",\n   0, 0, 0, GET_LONG, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"debug-gdb\", 0,\n   \"Set up signals usable for debugging.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"debug-max-binlog-dump-events\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &max_binlog_dump_events, &max_binlog_dump_events, 0,\n   GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n#ifdef SAFE_MUTEX\n  {\"debug-mutex-deadlock-detector\", 0,\n   \"Enable checking of wrong mutex usage.\",\n   &safe_mutex_deadlock_detector,\n   &safe_mutex_deadlock_detector,\n   0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n#endif\n  {\"debug-no-sync\", 0,\n   \"Disables system sync calls. Only for running tests or debugging!\",\n   &my_disable_sync, &my_disable_sync, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"debug-sporadic-binlog-dump-fail\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &opt_sporadic_binlog_dump_fail,\n   &opt_sporadic_binlog_dump_fail, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif /* HAVE_REPLICATION */\n  {\"default-storage-engine\", 0, \"The default storage engine for new tables\",\n   &default_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"default-time-zone\", 0, \"Set the default time zone.\",\n   &default_tz_name, &default_tz_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n#if defined(ENABLED_DEBUG_SYNC)\n  {\"debug-sync-timeout\", OPT_DEBUG_SYNC_TIMEOUT,\n   \"Enable the debug sync facility \"\n   \"and optionally specify a default wait timeout in seconds. \"\n   \"A zero value keeps the facility disabled.\",\n   &opt_debug_sync_timeout, 0,\n   0, GET_UINT, OPT_ARG, 0, 0, UINT_MAX, 0, 0, 0},\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n#ifdef HAVE_OPENSSL\n  {\"des-key-file\", 0,\n   \"Load keys for des_encrypt() and des_encrypt from given file.\",\n   &des_key_file, &des_key_file, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_STACKTRACE\n  {\"stack-trace\", 0 , \"Print a symbolic stack trace on failure\",\n   &opt_stack_trace, &opt_stack_trace, 0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n#endif /* HAVE_STACKTRACE */\n  {\"external-locking\", 0, \"Use system (external) locking (disabled by \"\n   \"default).  With this option enabled you can run myisamchk to test \"\n   \"(not repair) tables while the MySQL server is running. Disable with \"\n   \"--skip-external-locking.\", &opt_external_locking, &opt_external_locking,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* We must always support the next option to make scripts like mysqltest\n     easier to do */\n  {\"gdb\", 0,\n   \"Set up signals usable for debugging. Deprecated, use --debug-gdb instead.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_LARGE_PAGE_OPTION\n  {\"super-large-pages\", 0, \"Enable support for super large pages.\",\n   &opt_super_large_pages, &opt_super_large_pages, 0,\n   GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},\n#endif\n  {\"language\", 'L',\n   \"Client error messages in given language. May be given as a full path. \"\n   \"Deprecated. Use --lc-messages-dir instead.\",\n   0, 0, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"lc-messages\", 0,\n   \"Set the language used for the error messages.\",\n   &lc_messages, &lc_messages, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"lc-time-names\", 0,\n   \"Set the language used for the month names and the days of the week.\",\n   &lc_time_names_name, &lc_time_names_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"log\", 'l', \"Log connections and queries to file (deprecated option, use \"\n   \"--general-log/--general-log-file instead).\", &opt_logname, &opt_logname,\n   0, GET_STR_ALLOC, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-basename\", OPT_LOG_BASENAME,\n   \"Basename for all log files and the .pid file. This sets all log file \"\n   \"names at once (in 'datadir') and is normally the only option you need \"\n   \"for specifying log files. Sets names for --log-bin, --log-bin-index, \"\n   \"--relay-log, --relay-log-index, --general-log-file, \"\n   \"--log-slow-query-log-file, --log-error-file, and --pid-file\",\n   &opt_log_basename, &opt_log_basename, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"log-bin\", OPT_BIN_LOG,\n   \"Log update queries in binary format. Optional argument should be name for \"\n   \"binary log. If not given \"\n   \"'datadir'/'log-basename'-bin or 'datadir'/mysql-bin will be used (the later if \"\n   \"--log-basename is not specified). We strongly recommend to use either \"\n   \"--log-basename or specify a filename to ensure that replication doesn't \"\n   \"stop if the real hostname of the computer changes.\",\n   &opt_bin_logname, &opt_bin_logname, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-bin-index\", 0,\n   \"File that holds the names for last binary log files.\",\n   &opt_binlog_index_name, &opt_binlog_index_name, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-isam\", OPT_ISAM_LOG, \"Log all MyISAM changes to file.\",\n   &myisam_log_filename, &myisam_log_filename, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-short-format\", 0,\n   \"Don't log extra information to update and slow-query logs.\",\n   &opt_short_log_format, &opt_short_log_format,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-slow-admin-statements\", 0,\n   \"Log slow OPTIMIZE, ANALYZE, ALTER and other administrative statements to \"\n   \"the slow log if it is open.\", &opt_log_slow_admin_statements,\n   &opt_log_slow_admin_statements, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n {\"log-slow-slave-statements\", 0,\n  \"Log slow statements executed by slave thread to the slow log if it is open.\",\n  &opt_log_slow_slave_statements, &opt_log_slow_slave_statements,\n  0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-slow-queries\", OPT_SLOW_QUERY_LOG,\n   \"Enable logging of slow queries (longer than --long-query-time) to log file \"\n   \"or table. Optional argument is a file name for the slow log. If not given, \"\n   \"'log-basename'-slow.log will be used. Use --log-output=TABLE if you want \"\n   \"to have the log in the table mysql.slow_log. \"\n   \"Deprecated option, use --slow-query-log/--slow-query-log-file instead.\",\n   &opt_slow_logname, &opt_slow_logname, 0, GET_STR_ALLOC, OPT_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"log-tc\", 0,\n   \"Path to transaction coordinator log (used for transactions that affect \"\n   \"more than one storage engine, when binary log is disabled).\",\n   &opt_tc_log_file, &opt_tc_log_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_MMAP\n  {\"log-tc-size\", 0, \"Size of transaction coordinator log.\",\n   &opt_tc_log_size, &opt_tc_log_size, 0, GET_ULONG,\n   REQUIRED_ARG, TC_LOG_MIN_SIZE, TC_LOG_MIN_SIZE, (ulonglong) ULONG_MAX, 0,\n   TC_LOG_PAGE_SIZE, 0},\n#endif\n  {\"master-info-file\", 0,\n   \"The location and name of the file that remembers the master and where \"\n   \"the I/O replication thread is in the master's binlogs. Defaults to \"\n   \"master.info\",\n   &master_info_file, &master_info_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"master-retry-count\", 0,\n   \"The number of tries the slave will make to connect to the master before giving up.\",\n   &master_retry_count, &master_retry_count, 0, GET_ULONG,\n   REQUIRED_ARG, 3600*24, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"init-rpl-role\", 0, \"Set the replication role.\",\n   &rpl_status, &rpl_status, &rpl_role_typelib,\n   GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"memlock\", 0, \"Lock mysqld in memory.\", &locked_in_memory,\n   &locked_in_memory, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"one-thread\", OPT_ONE_THREAD,\n   \"(Deprecated): Only use one thread (for debugging under Linux). Use \"\n   \"thread-handling=no-threads instead.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"old-style-user-limits\", 0,\n   \"Enable old-style user limits (before 5.0.3, user resources were counted \"\n   \"per each user+host vs. per account).\",\n   &opt_old_style_user_limits, &opt_old_style_user_limits,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"port-open-timeout\", 0,\n   \"Maximum time in seconds to wait for the port to become free. \"\n   \"(Default: No wait).\", &mysqld_port_timeout, &mysqld_port_timeout, 0,\n   GET_UINT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-db\", OPT_REPLICATE_DO_DB,\n   \"Tells the slave thread to restrict replication to the specified database. \"\n   \"To specify more than one database, use the directive multiple times, \"\n   \"once for each database. Note that this will only work if you do not use \"\n   \"cross-database queries such as UPDATE some_db.some_table SET foo='bar' \"\n   \"while having selected a different or no database. If you need cross \"\n   \"database updates to work, make sure you have 3.23.28 or later, and use \"\n   \"replicate-wild-do-table=db_name.%.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-table\", OPT_REPLICATE_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the specified table. \"\n   \"To specify more than one table, use the directive multiple times, once \"\n   \"for each table. This will work for cross-database updates, in contrast \"\n   \"to replicate-do-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-db\", OPT_REPLICATE_IGNORE_DB,\n   \"Tells the slave thread to not replicate to the specified database. To \"\n   \"specify more than one database to ignore, use the directive multiple \"\n   \"times, once for each database. This option will not work if you use \"\n   \"cross database updates. If you need cross database updates to work, \"\n   \"make sure you have 3.23.28 or later, and use replicate-wild-ignore-\"\n   \"table=db_name.%. \", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-table\", OPT_REPLICATE_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the specified table. To specify \"\n   \"more than one table to ignore, use the directive multiple times, once for \"\n   \"each table. This will work for cross-database updates, in contrast to \"\n   \"replicate-ignore-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-rewrite-db\", OPT_REPLICATE_REWRITE_DB,\n   \"Updates to a database with a different name than the original. Example: \"\n   \"replicate-rewrite-db=master_db_name->slave_db_name.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"replicate-same-server-id\", 0,\n   \"In replication, if set to 1, do not skip events having our server id. \"\n   \"Default value is 0 (to break infinite loops in circular replication). \"\n   \"Can't be set to 1 if --log-slave-updates is used.\",\n   &replicate_same_server_id, &replicate_same_server_id,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"replicate-wild-do-table\", OPT_REPLICATE_WILD_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the tables that match \"\n   \"the specified wildcard pattern. To specify more than one table, use the \"\n   \"directive multiple times, once for each table. This will work for cross-\"\n   \"database updates. Example: replicate-wild-do-table=foo%.bar% will \"\n   \"replicate only updates to tables in all databases that start with foo \"\n   \"and whose table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-wild-ignore-table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the tables that match the \"\n   \"given wildcard pattern. To specify more than one table to ignore, use \"\n   \"the directive multiple times, once for each table. This will work for \"\n   \"cross-database updates. Example: replicate-wild-ignore-table=foo%.bar% \"\n   \"will not do updates to tables in databases that start with foo and whose \"\n   \"table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-mode\", OPT_SAFE, \"Skip some optimize stages (for testing). Deprecated.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-user-create\", 0,\n   \"Don't allow new user creation by the user who has no write privileges to the mysql.user table.\",\n   &opt_safe_user_create, &opt_safe_user_create, 0, GET_BOOL,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"show-slave-auth-info\", 0,\n   \"Show user and password in SHOW SLAVE HOSTS on this master.\",\n   &opt_show_slave_auth_info, &opt_show_slave_auth_info, 0,\n   GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-bdb\", OPT_DEPRECATED_OPTION,\n   \"Deprecated option; Exist only for compatiblity with old my.cnf files\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"skip-grant-tables\", 0,\n   \"Start without grant tables. This gives all users FULL ACCESS to all tables.\",\n   &opt_noacl, &opt_noacl, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif\n  {\"skip-host-cache\", OPT_SKIP_HOST_CACHE, \"Don't cache host names.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-slave-start\", 0,\n   \"If set, slave is not autostarted.\", &opt_skip_slave_start,\n   &opt_skip_slave_start, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-thread-priority\", OPT_SKIP_PRIOR,\n   \"Don't give threads different priorities. This option is deprecated \"\n   \"because it has no effect; the implied behavior is already the default.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  {\"slow-start-timeout\", 0,\n   \"Maximum number of milliseconds that the service control manager should wait \"\n   \"before trying to kill the windows service during startup\"\n   \"(Default: 15000).\", &slow_start_timeout, &slow_start_timeout, 0,\n   GET_ULONG, REQUIRED_ARG, 15000, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_OPENSSL\n  {\"ssl\", 0,\n   \"Enable SSL for connection (automatically enabled with other flags).\",\n   &opt_use_ssl, &opt_use_ssl, 0, GET_BOOL, OPT_ARG, 0, 0, 0,\n   0, 0, 0},\n#endif\n#ifdef __WIN__\n  {\"standalone\", 0,\n  \"Dummy option to start as a standalone program (NT).\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"symbolic-links\", 's', \"Enable symbolic link support.\",\n   &my_use_symdir, &my_use_symdir, 0, GET_BOOL, NO_ARG,\n   /*\n     The system call realpath() produces warnings under valgrind and\n     purify. These are not suppressed: instead we disable symlinks\n     option if compiled with valgrind support.\n     Also disable by default on Windows, due to high overhead for checking .sym \n     files.\n   */\n   IF_VALGRIND(0,IF_WIN(0,1)), 0, 0, 0, 0, 0},\n  {\"sysdate-is-now\", 0,\n   \"Non-default option to alias SYSDATE() to NOW() to make it safe-replicable. \"\n   \"Since 5.0, SYSDATE() returns a `dynamic' value different for different \"\n   \"invocations, even within the same statement.\",\n   &global_system_variables.sysdate_is_now,\n   0, 0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},\n  {\"tc-heuristic-recover\", 0,\n   \"Decision to use in heuristic recover process. Possible values are COMMIT \"\n   \"or ROLLBACK.\", &tc_heuristic_recover, &tc_heuristic_recover,\n   &tc_heuristic_recover_typelib, GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"temp-pool\", 0,\n#if (ENABLE_TEMP_POOL)\n   \"Using this option will cause most temporary files created to use a small \"\n   \"set of names, rather than a unique name for each new file.\",\n#else\n   \"This option is ignored on this OS.\",\n#endif\n   &use_temp_pool, &use_temp_pool, 0, GET_BOOL, NO_ARG, 1,\n   0, 0, 0, 0, 0},\n  {\"transaction-isolation\", 0,\n   \"Default transaction isolation level.\",\n   &global_system_variables.tx_isolation,\n   &global_system_variables.tx_isolation, &tx_isolation_typelib,\n   GET_ENUM, REQUIRED_ARG, ISO_REPEATABLE_READ, 0, 0, 0, 0, 0},\n  {\"user\", 'u', \"Run mysqld daemon as user.\", 0, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"verbose\", 'v', \"Used with --help option for detailed help.\",\n   &opt_verbose, &opt_verbose, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"version\", 'V', \"Output version information and exit.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"plugin-load\", 0,\n   \"Semicolon-separated list of plugins to load, where each plugin is \"\n   \"specified as ether a plugin_name=library_file pair or only a library_file. \"\n   \"If the latter case, all plugins from a given library_file will be loaded.\",\n   &opt_plugin_load, &opt_plugin_load, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"table_cache\", 0, \"Deprecated; use --table-open-cache instead.\",\n   &table_cache_size, &table_cache_size, 0, GET_ULONG,\n   REQUIRED_ARG, TABLE_OPEN_CACHE_DEFAULT, 1, 512*1024L, 0, 1, 0},\n  {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n};\n\n\nstatic int show_queries(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= (char *)&thd->query_id;\n  return 0;\n}\n\n\nstatic int show_net_compression(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= (char *)&thd->net.compress;\n  return 0;\n}\n\nstatic int show_starttime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - server_start_time);\n  return 0;\n}\n\n#ifdef ENABLED_PROFILING\nstatic int show_flushstatustime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - flush_status_time);\n  return 0;\n}\n#endif\n\n#ifdef HAVE_REPLICATION\nstatic int show_rpl_status(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  var->value= const_cast<char*>(rpl_status_type[(int)rpl_status]);\n  return 0;\n}\n\nstatic int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= buff;\n  *((my_bool *)buff)= (my_bool) (active_mi && \n                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&\n                                 active_mi->rli.slave_running);\n  return 0;\n}\n\nstatic int show_slave_retried_trans(THD *thd, SHOW_VAR *var, char *buff)\n{\n  /*\n    TODO: with multimaster, have one such counter per line in\n    SHOW SLAVE STATUS, and have the sum over all lines here.\n  */\n  if (active_mi)\n  {\n    var->type= SHOW_LONG;\n    var->value= buff;\n    *((long *)buff)= (long)active_mi->rli.retried_trans;\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\nstatic int show_slave_received_heartbeats(THD *thd, SHOW_VAR *var, char *buff)\n{\n  if (active_mi)\n  {\n    var->type= SHOW_LONGLONG;\n    var->value= buff;\n    *((longlong *)buff)= active_mi->received_heartbeats;\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\nstatic int show_heartbeat_period(THD *thd, SHOW_VAR *var, char *buff)\n{\n  if (active_mi)\n  {\n    var->type= SHOW_CHAR;\n    var->value= buff;\n    sprintf(buff, \"%.3f\", active_mi->heartbeat_period);\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\n\n#endif /* HAVE_REPLICATION */\n\nstatic int show_open_tables(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)cached_open_tables();\n  return 0;\n}\n\nstatic int show_prepared_stmt_count(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  mysql_mutex_lock(&LOCK_prepared_stmt_count);\n  *((long *)buff)= (long)prepared_stmt_count;\n  mysql_mutex_unlock(&LOCK_prepared_stmt_count);\n  return 0;\n}\n\nstatic int show_table_definitions(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)cached_table_definitions();\n  return 0;\n}\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n/* Functions relying on CTX */\nstatic int show_ssl_ctx_sess_accept(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cb_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cb_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cache_full(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cache_full(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_misses(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_misses(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_timeouts(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_timeouts(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_number(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_number(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_get_cache_size(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_get_cache_size(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_mode(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_depth(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_session_cache_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (!ssl_acceptor_fd)\n    var->value= const_cast<char*>(\"NONE\");\n  else\n    switch (SSL_CTX_get_session_cache_mode(ssl_acceptor_fd->ssl_context))\n    {\n    case SSL_SESS_CACHE_OFF:\n      var->value= const_cast<char*>(\"OFF\"); break;\n    case SSL_SESS_CACHE_CLIENT:\n      var->value= const_cast<char*>(\"CLIENT\"); break;\n    case SSL_SESS_CACHE_SERVER:\n      var->value= const_cast<char*>(\"SERVER\"); break;\n    case SSL_SESS_CACHE_BOTH:\n      var->value= const_cast<char*>(\"BOTH\"); break;\n    case SSL_SESS_CACHE_NO_AUTO_CLEAR:\n      var->value= const_cast<char*>(\"NO_AUTO_CLEAR\"); break;\n    case SSL_SESS_CACHE_NO_INTERNAL_LOOKUP:\n      var->value= const_cast<char*>(\"NO_INTERNAL_LOOKUP\"); break;\n    default:\n      var->value= const_cast<char*>(\"Unknown\"); break;\n    }\n  return 0;\n}\n\n/*\n   Functions relying on SSL\n   Note: In the show_ssl_* functions, we need to check if we have a\n         valid vio-object since this isn't always true, specifically\n         when session_status or global_status is requested from\n         inside an Event.\n */\nstatic int show_ssl_get_version(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_version((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_session_reused(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_session_reused((SSL*) thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_default_timeout(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_default_timeout((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->net.vio && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_mode((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_depth((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_cipher(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_cipher((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_get_cipher_list(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  var->value= buff;\n  if (thd->vio_ok() && thd->net.vio->ssl_arg)\n  {\n    int i;\n    const char *p;\n    char *end= buff + SHOW_VAR_FUNC_BUFF_SIZE;\n    for (i=0; (p= SSL_get_cipher_list((SSL*) thd->net.vio->ssl_arg,i)) &&\n               buff < end; i++)\n    {\n      buff= strnmov(buff, p, end-buff-1);\n      *buff++= ':';\n    }\n    if (i)\n      buff--;\n  }\n  *buff=0;\n  return 0;\n}\n\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY */\n\nstatic int show_default_keycache(THD *thd, SHOW_VAR *var, char *buff)\n{\n  struct st_data {\n    KEY_CACHE_STATISTICS stats;\n    SHOW_VAR var[8];\n  } *data;\n  SHOW_VAR *v;\n\n  data=(st_data *)buff;\n  v= data->var;\n\n  var->type= SHOW_ARRAY;\n  var->value= (char*)v;\n\n  get_key_cache_statistics(dflt_key_cache, 0, &data->stats);\n\n#define set_one_keycache_var(X,Y)       \\\n  v->name= X;                           \\\n  v->type= SHOW_LONGLONG;               \\\n  v->value= (char*)&data->stats.Y;      \\\n  v++;\n\n  set_one_keycache_var(\"blocks_not_flushed\", blocks_changed);\n  set_one_keycache_var(\"blocks_unused\",      blocks_unused);\n  set_one_keycache_var(\"blocks_used\",        blocks_used);\n  set_one_keycache_var(\"blocks_warm\",        blocks_warm);\n  set_one_keycache_var(\"read_requests\",      read_requests);\n  set_one_keycache_var(\"reads\",              reads);\n  set_one_keycache_var(\"write_requests\",     write_requests);\n  set_one_keycache_var(\"writes\",             writes);\n\n  v->name= 0;\n\n  DBUG_ASSERT((char*)(v+1) <= buff + SHOW_VAR_FUNC_BUFF_SIZE);\n\n#undef set_one_keycache_var\n\n  return 0;\n}\n\n#ifdef HAVE_POOL_OF_THREADS\nint show_threadpool_idle_threads(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_INT;\n  var->value= buff;\n  *(int *)buff= tp_get_idle_thread_count(); \n  return 0;\n}\n#endif\n\n/*\n  Variables shown by SHOW STATUS in alphabetical order\n*/\n\nSHOW_VAR status_vars[]= {\n  {\"Aborted_clients\",          (char*) &aborted_threads,        SHOW_LONG},\n  {\"Aborted_connects\",         (char*) &aborted_connects,       SHOW_LONG},\n  {\"Access_denied_errors\",     (char*) offsetof(STATUS_VAR, access_denied_errors), SHOW_LONG_STATUS},\n  {\"Binlog_bytes_written\",     (char*) offsetof(STATUS_VAR, binlog_bytes_written), SHOW_LONGLONG_STATUS},\n  {\"Binlog_cache_disk_use\",    (char*) &binlog_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_cache_use\",         (char*) &binlog_cache_use,       SHOW_LONG},\n  {\"Binlog_stmt_cache_disk_use\",(char*) &binlog_stmt_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_stmt_cache_use\",    (char*) &binlog_stmt_cache_use,       SHOW_LONG},\n  {\"Busy_time\",                (char*) offsetof(STATUS_VAR, busy_time), SHOW_DOUBLE_STATUS},\n  {\"Bytes_received\",           (char*) offsetof(STATUS_VAR, bytes_received), SHOW_LONGLONG_STATUS},\n  {\"Bytes_sent\",               (char*) offsetof(STATUS_VAR, bytes_sent), SHOW_LONGLONG_STATUS},\n  {\"Com\",                      (char*) com_status_vars, SHOW_ARRAY},\n  {\"Compression\",              (char*) &show_net_compression, SHOW_FUNC},\n  {\"Connections\",              (char*) &thread_id,              SHOW_LONG_NOFLUSH},\n  {\"Cpu_time\",                 (char*) offsetof(STATUS_VAR, cpu_time), SHOW_DOUBLE_STATUS},\n  {\"Created_tmp_disk_tables\",  (char*) offsetof(STATUS_VAR, created_tmp_disk_tables), SHOW_LONG_STATUS},\n  {\"Created_tmp_files\",\t       (char*) &my_tmp_file_created,\tSHOW_LONG},\n  {\"Created_tmp_tables\",       (char*) offsetof(STATUS_VAR, created_tmp_tables), SHOW_LONG_STATUS},\n  {\"Delayed_errors\",           (char*) &delayed_insert_errors,  SHOW_LONG},\n  {\"Delayed_insert_threads\",   (char*) &delayed_insert_threads, SHOW_LONG_NOFLUSH},\n  {\"Delayed_writes\",           (char*) &delayed_insert_writes,  SHOW_LONG},\n  {\"Empty_queries\",            (char*) offsetof(STATUS_VAR, empty_queries), SHOW_LONG_STATUS},\n  {\"Executed_events\",          (char*) &executed_events, SHOW_LONG_NOFLUSH },\n  {\"Executed_triggers\",        (char*) offsetof(STATUS_VAR, executed_triggers), SHOW_LONG_STATUS},\n  {\"Feature_dynamic_columns\",  (char*) offsetof(STATUS_VAR, feature_dynamic_columns), SHOW_LONG_STATUS},\n  {\"Feature_fulltext\",         (char*) offsetof(STATUS_VAR, feature_fulltext), SHOW_LONG_STATUS},\n  {\"Feature_gis\",              (char*) offsetof(STATUS_VAR, feature_gis), SHOW_LONG_STATUS},\n  {\"Feature_locale\",           (char*) offsetof(STATUS_VAR, feature_locale), SHOW_LONG_STATUS},\n  {\"Feature_subquery\",         (char*) offsetof(STATUS_VAR, feature_subquery), SHOW_LONG_STATUS},\n  {\"Feature_timezone\",         (char*) offsetof(STATUS_VAR, feature_timezone), SHOW_LONG_STATUS},\n  {\"Feature_trigger\",         (char*) offsetof(STATUS_VAR, feature_trigger), SHOW_LONG_STATUS},\n  {\"Feature_xml\",             (char*) offsetof(STATUS_VAR, feature_xml), SHOW_LONG_STATUS},\n  {\"Flush_commands\",           (char*) &refresh_version,        SHOW_LONG_NOFLUSH},\n  {\"Handler_commit\",           (char*) offsetof(STATUS_VAR, ha_commit_count), SHOW_LONG_STATUS},\n  {\"Handler_delete\",           (char*) offsetof(STATUS_VAR, ha_delete_count), SHOW_LONG_STATUS},\n  {\"Handler_discover\",         (char*) offsetof(STATUS_VAR, ha_discover_count), SHOW_LONG_STATUS},\n  {\"Handler_icp_attempts\",     (char*) offsetof(STATUS_VAR, ha_icp_attempts), SHOW_LONG_STATUS},\n  {\"Handler_icp_match\",        (char*) offsetof(STATUS_VAR, ha_icp_match), SHOW_LONG_STATUS},\n  {\"Handler_mrr_init\",         (char*) offsetof(STATUS_VAR, ha_mrr_init_count),  SHOW_LONG_STATUS},\n  {\"Handler_mrr_key_refills\",   (char*) offsetof(STATUS_VAR, ha_mrr_key_refills_count), SHOW_LONG_STATUS},\n  {\"Handler_mrr_rowid_refills\", (char*) offsetof(STATUS_VAR, ha_mrr_rowid_refills_count), SHOW_LONG_STATUS},\n  {\"Handler_prepare\",          (char*) offsetof(STATUS_VAR, ha_prepare_count),  SHOW_LONG_STATUS},\n  {\"Handler_read_first\",       (char*) offsetof(STATUS_VAR, ha_read_first_count), SHOW_LONG_STATUS},\n  {\"Handler_read_key\",         (char*) offsetof(STATUS_VAR, ha_read_key_count), SHOW_LONG_STATUS},\n  {\"Handler_read_last\",        (char*) offsetof(STATUS_VAR, ha_read_last_count), SHOW_LONG_STATUS},\n  {\"Handler_read_next\",        (char*) offsetof(STATUS_VAR, ha_read_next_count), SHOW_LONG_STATUS},\n  {\"Handler_read_prev\",        (char*) offsetof(STATUS_VAR, ha_read_prev_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd\",         (char*) offsetof(STATUS_VAR, ha_read_rnd_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd_deleted\", (char*) offsetof(STATUS_VAR, ha_read_rnd_deleted_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd_next\",    (char*) offsetof(STATUS_VAR, ha_read_rnd_next_count), SHOW_LONG_STATUS},\n  {\"Handler_rollback\",         (char*) offsetof(STATUS_VAR, ha_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint\",        (char*) offsetof(STATUS_VAR, ha_savepoint_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint_rollback\",(char*) offsetof(STATUS_VAR, ha_savepoint_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_tmp_update\",       (char*) offsetof(STATUS_VAR, ha_tmp_update_count), SHOW_LONG_STATUS},\n  {\"Handler_tmp_write\",        (char*) offsetof(STATUS_VAR, ha_tmp_write_count), SHOW_LONG_STATUS},\n  {\"Handler_update\",           (char*) offsetof(STATUS_VAR, ha_update_count), SHOW_LONG_STATUS},\n  {\"Handler_write\",            (char*) offsetof(STATUS_VAR, ha_write_count), SHOW_LONG_STATUS},\n  {\"Key\",                      (char*) &show_default_keycache, SHOW_FUNC},\n  {\"Last_query_cost\",          (char*) offsetof(STATUS_VAR, last_query_cost), SHOW_DOUBLE_STATUS},\n  {\"Max_used_connections\",     (char*) &max_used_connections,  SHOW_LONG},\n  {\"Not_flushed_delayed_rows\", (char*) &delayed_rows_in_use,    SHOW_LONG_NOFLUSH},\n  {\"Open_files\",               (char*) &my_file_opened,         SHOW_LONG_NOFLUSH},\n  {\"Open_streams\",             (char*) &my_stream_opened,       SHOW_LONG_NOFLUSH},\n  {\"Open_table_definitions\",   (char*) &show_table_definitions, SHOW_FUNC},\n  {\"Open_tables\",              (char*) &show_open_tables,       SHOW_FUNC},\n  {\"Opened_files\",             (char*) &my_file_total_opened, SHOW_LONG_NOFLUSH},\n  {\"Opened_table_definitions\", (char*) offsetof(STATUS_VAR, opened_shares), SHOW_LONG_STATUS},\n  {\"Opened_tables\",            (char*) offsetof(STATUS_VAR, opened_tables), SHOW_LONG_STATUS},\n  {\"Opened_views\",            (char*) offsetof(STATUS_VAR, opened_views), SHOW_LONG_STATUS},\n  {\"Prepared_stmt_count\",      (char*) &show_prepared_stmt_count, SHOW_FUNC},\n  {\"Rows_read\",                (char*) offsetof(STATUS_VAR, rows_read), SHOW_LONGLONG_STATUS},\n  {\"Rows_sent\",                (char*) offsetof(STATUS_VAR, rows_sent), SHOW_LONGLONG_STATUS},\n  {\"Rows_tmp_read\",            (char*) offsetof(STATUS_VAR, rows_tmp_read), SHOW_LONGLONG_STATUS},\n#ifdef HAVE_QUERY_CACHE\n  {\"Qcache_free_blocks\",       (char*) &query_cache.free_memory_blocks, SHOW_LONG_NOFLUSH},\n  {\"Qcache_free_memory\",       (char*) &query_cache.free_memory, SHOW_LONG_NOFLUSH},\n  {\"Qcache_hits\",              (char*) &query_cache.hits,       SHOW_LONG},\n  {\"Qcache_inserts\",           (char*) &query_cache.inserts,    SHOW_LONG},\n  {\"Qcache_lowmem_prunes\",     (char*) &query_cache.lowmem_prunes, SHOW_LONG},\n  {\"Qcache_not_cached\",        (char*) &query_cache.refused,    SHOW_LONG},\n  {\"Qcache_queries_in_cache\",  (char*) &query_cache.queries_in_cache, SHOW_LONG_NOFLUSH},\n  {\"Qcache_total_blocks\",      (char*) &query_cache.total_blocks, SHOW_LONG_NOFLUSH},\n#endif /*HAVE_QUERY_CACHE*/\n  {\"Queries\",                  (char*) &show_queries,            SHOW_FUNC},\n  {\"Questions\",                (char*) offsetof(STATUS_VAR, questions), SHOW_LONG_STATUS},\n#ifdef HAVE_REPLICATION\n  {\"Rpl_status\",               (char*) &show_rpl_status,          SHOW_FUNC},\n#endif\n  {\"Select_full_join\",         (char*) offsetof(STATUS_VAR, select_full_join_count), SHOW_LONG_STATUS},\n  {\"Select_full_range_join\",   (char*) offsetof(STATUS_VAR, select_full_range_join_count), SHOW_LONG_STATUS},\n  {\"Select_range\",             (char*) offsetof(STATUS_VAR, select_range_count), SHOW_LONG_STATUS},\n  {\"Select_range_check\",       (char*) offsetof(STATUS_VAR, select_range_check_count), SHOW_LONG_STATUS},\n  {\"Select_scan\",\t       (char*) offsetof(STATUS_VAR, select_scan_count), SHOW_LONG_STATUS},\n  {\"Slave_open_temp_tables\",   (char*) &slave_open_temp_tables, SHOW_LONG},\n#ifdef HAVE_REPLICATION\n  {\"Slave_heartbeat_period\",   (char*) &show_heartbeat_period, SHOW_FUNC},\n  {\"Slave_received_heartbeats\",(char*) &show_slave_received_heartbeats, SHOW_FUNC},\n  {\"Slave_retried_transactions\",(char*) &show_slave_retried_trans, SHOW_FUNC},\n  {\"Slave_running\",            (char*) &show_slave_running,     SHOW_FUNC},\n#endif\n  {\"Slow_launch_threads\",      (char*) &slow_launch_threads,    SHOW_LONG},\n  {\"Slow_queries\",             (char*) offsetof(STATUS_VAR, long_query_count), SHOW_LONG_STATUS},\n  {\"Sort_merge_passes\",\t       (char*) offsetof(STATUS_VAR, filesort_merge_passes), SHOW_LONG_STATUS},\n  {\"Sort_range\",\t       (char*) offsetof(STATUS_VAR, filesort_range_count), SHOW_LONG_STATUS},\n  {\"Sort_rows\",\t\t       (char*) offsetof(STATUS_VAR, filesort_rows), SHOW_LONG_STATUS},\n  {\"Sort_scan\",\t\t       (char*) offsetof(STATUS_VAR, filesort_scan_count), SHOW_LONG_STATUS},\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  {\"Ssl_accept_renegotiates\",  (char*) &show_ssl_ctx_sess_accept_renegotiate, SHOW_FUNC},\n  {\"Ssl_accepts\",              (char*) &show_ssl_ctx_sess_accept, SHOW_FUNC},\n  {\"Ssl_callback_cache_hits\",  (char*) &show_ssl_ctx_sess_cb_hits, SHOW_FUNC},\n  {\"Ssl_cipher\",               (char*) &show_ssl_get_cipher, SHOW_FUNC},\n  {\"Ssl_cipher_list\",          (char*) &show_ssl_get_cipher_list, SHOW_FUNC},\n  {\"Ssl_client_connects\",      (char*) &show_ssl_ctx_sess_connect, SHOW_FUNC},\n  {\"Ssl_connect_renegotiates\", (char*) &show_ssl_ctx_sess_connect_renegotiate, SHOW_FUNC},\n  {\"Ssl_ctx_verify_depth\",     (char*) &show_ssl_ctx_get_verify_depth, SHOW_FUNC},\n  {\"Ssl_ctx_verify_mode\",      (char*) &show_ssl_ctx_get_verify_mode, SHOW_FUNC},\n  {\"Ssl_default_timeout\",      (char*) &show_ssl_get_default_timeout, SHOW_FUNC},\n  {\"Ssl_finished_accepts\",     (char*) &show_ssl_ctx_sess_accept_good, SHOW_FUNC},\n  {\"Ssl_finished_connects\",    (char*) &show_ssl_ctx_sess_connect_good, SHOW_FUNC},\n  {\"Ssl_session_cache_hits\",   (char*) &show_ssl_ctx_sess_hits, SHOW_FUNC},\n  {\"Ssl_session_cache_misses\", (char*) &show_ssl_ctx_sess_misses, SHOW_FUNC},\n  {\"Ssl_session_cache_mode\",   (char*) &show_ssl_ctx_get_session_cache_mode, SHOW_FUNC},\n  {\"Ssl_session_cache_overflows\", (char*) &show_ssl_ctx_sess_cache_full, SHOW_FUNC},\n  {\"Ssl_session_cache_size\",   (char*) &show_ssl_ctx_sess_get_cache_size, SHOW_FUNC},\n  {\"Ssl_session_cache_timeouts\", (char*) &show_ssl_ctx_sess_timeouts, SHOW_FUNC},\n  {\"Ssl_sessions_reused\",      (char*) &show_ssl_session_reused, SHOW_FUNC},\n  {\"Ssl_used_session_cache_entries\",(char*) &show_ssl_ctx_sess_number, SHOW_FUNC},\n  {\"Ssl_verify_depth\",         (char*) &show_ssl_get_verify_depth, SHOW_FUNC},\n  {\"Ssl_verify_mode\",          (char*) &show_ssl_get_verify_mode, SHOW_FUNC},\n  {\"Ssl_version\",              (char*) &show_ssl_get_version, SHOW_FUNC},\n#endif\n#endif /* HAVE_OPENSSL */\n  {\"Syncs\",                    (char*) &my_sync_count,          SHOW_LONG_NOFLUSH},\n  /*\n    Expression cache used only for caching subqueries now, so its statistic\n    variables we call subquery_cache*.\n  */\n  {\"Subquery_cache_hit\",       (char*) &subquery_cache_hit,     SHOW_LONG},\n  {\"Subquery_cache_miss\",      (char*) &subquery_cache_miss,    SHOW_LONG},\n  {\"Table_locks_immediate\",    (char*) &locks_immediate,        SHOW_LONG},\n  {\"Table_locks_waited\",       (char*) &locks_waited,           SHOW_LONG},\n#ifdef HAVE_MMAP\n  {\"Tc_log_max_pages_used\",    (char*) &tc_log_max_pages_used,  SHOW_LONG},\n  {\"Tc_log_page_size\",         (char*) &tc_log_page_size,       SHOW_LONG_NOFLUSH},\n  {\"Tc_log_page_waits\",        (char*) &tc_log_page_waits,      SHOW_LONG},\n#endif\n#ifdef HAVE_POOL_OF_THREADS\n  {\"Threadpool_idle_threads\",  (char *) &show_threadpool_idle_threads, SHOW_FUNC},\n  {\"Threadpool_threads\",       (char *) &tp_stats.num_worker_threads, SHOW_INT},\n#endif\n  {\"Threads_cached\",           (char*) &cached_thread_count,    SHOW_LONG_NOFLUSH},\n  {\"Threads_connected\",        (char*) &connection_count,       SHOW_INT},\n  {\"Threads_created\",\t       (char*) &thread_created,\t\tSHOW_LONG_NOFLUSH},\n  {\"Threads_running\",          (char*) &thread_running,         SHOW_INT},\n  {\"Uptime\",                   (char*) &show_starttime,         SHOW_FUNC},\n#ifdef ENABLED_PROFILING\n  {\"Uptime_since_flush_status\",(char*) &show_flushstatustime,   SHOW_FUNC},\n#endif\n  {NullS, NullS, SHOW_LONG}\n};\n\nbool add_terminator(DYNAMIC_ARRAY *options)\n{\n  my_option empty_element= {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0};\n  return insert_dynamic(options, (uchar *)&empty_element);\n}\n\n#ifndef EMBEDDED_LIBRARY\nstatic void print_version(void)\n{\n  set_server_version();\n\n  printf(\"%s  Ver %s for %s on %s (%s)\\n\",my_progname,\n\t server_version,SYSTEM_TYPE,MACHINE_TYPE, MYSQL_COMPILATION_COMMENT);\n}\n\n/** Compares two options' names, treats - and _ the same */\nstatic int option_cmp(my_option *a, my_option *b)\n{\n  const char *sa= a->name;\n  const char *sb= b->name;\n  for (; *sa || *sb; sa++, sb++)\n  {\n    if (*sa < *sb)\n    {\n      if (*sa == '-' && *sb == '_')\n        continue;\n      else\n        return -1;\n    }\n    if (*sa > *sb)\n    {\n      if (*sa == '_' && *sb == '-')\n        continue;\n      else\n        return 1;\n    }\n  }\n  DBUG_ASSERT(a->name == b->name);\n  return 0;\n}\n\nstatic void print_help()\n{\n  MEM_ROOT mem_root;\n  init_alloc_root(&mem_root, 4096, 4096);\n\n  pop_dynamic(&all_options);\n  sys_var_add_options(&all_options, sys_var::PARSE_EARLY);\n  add_plugin_options(&all_options, &mem_root);\n  sort_dynamic(&all_options, (qsort_cmp) option_cmp);\n  add_terminator(&all_options);\n\n  my_print_help((my_option*) all_options.buffer);\n  my_print_variables((my_option*) all_options.buffer);\n\n  free_root(&mem_root, MYF(0));\n}\n\nstatic void usage(void)\n{\n  DBUG_ENTER(\"usage\");\n  if (!(default_charset_info= get_charset_by_csname(default_character_set_name,\n\t\t\t\t\t           MY_CS_PRIMARY,\n\t\t\t\t\t\t   MYF(MY_WME))))\n    exit(1);\n  if (!default_collation_name)\n    default_collation_name= (char*) default_charset_info->name;\n  print_version();\n  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n  puts(\"Starts the MariaDB database server.\\n\");\n  printf(\"Usage: %s [OPTIONS]\\n\", my_progname);\n  if (!opt_verbose)\n    puts(\"\\nFor more help options (several pages), use mysqld --verbose --help.\");\n  else\n  {\n#ifdef __WIN__\n  puts(\"NT and Win32 specific options:\\n\\\n  --install                     Install the default service (NT).\\n\\\n  --install-manual              Install the default service started manually (NT).\\n\\\n  --install service_name        Install an optional service (NT).\\n\\\n  --install-manual service_name Install an optional service started manually (NT).\\n\\\n  --remove                      Remove the default service from the service list (NT).\\n\\\n  --remove service_name         Remove the service_name from the service list (NT).\\n\\\n  --enable-named-pipe           Only to be used for the default server (NT).\\n\\\n  --standalone                  Dummy option to start as a standalone server (NT).\\\n\");\n  puts(\"\");\n#endif\n  print_defaults(MYSQL_CONFIG_NAME,load_default_groups);\n  puts(\"\");\n  set_ports();\n\n  /* Print out all the options including plugin supplied options */\n  print_help();\n\n  if (! plugins_are_initialized)\n  {\n    puts(\"\\n\\\nPlugins have parameters that are not reflected in this list\\n\\\nbecause execution stopped before plugins were initialized.\");\n  }\n\n  puts(\"\\n\\\nTo see what values a running MySQL server is using, type\\n\\\n'mysqladmin variables' instead of 'mysqld --verbose --help'.\");\n  }\n  DBUG_VOID_RETURN;\n}\n#endif /*!EMBEDDED_LIBRARY*/\n\n/**\n  Initialize MySQL global variables to default values.\n\n  @note\n    The reason to set a lot of global variables to zero is to allow one to\n    restart the embedded server with a clean environment\n    It's also needed on some exotic platforms where global variables are\n    not set to 0 when a program starts.\n\n    We don't need to set variables refered to in my_long_options\n    as these are initialized by my_getopt.\n*/\n\nstatic int mysql_init_variables(void)\n{\n  /* Things reset to zero */\n  opt_skip_slave_start= opt_reckless_slave = 0;\n  mysql_home[0]= pidfile_name[0]= log_error_file[0]= 0;\n#if defined(HAVE_REALPATH) && !defined(HAVE_valgrind) && !defined(HAVE_BROKEN_REALPATH)\n  /*  We can only test for sub paths if my_symlink.c is using realpath */\n  myisam_test_invalid_symlink= test_if_data_home_dir;\n#endif\n  opt_log= opt_slow_log= 0;\n  opt_bin_log= opt_bin_log_used= 0;\n  opt_disable_networking= opt_skip_show_db=0;\n  opt_skip_name_resolve= 0;\n  opt_ignore_builtin_innodb= 0;\n  opt_logname= opt_binlog_index_name= opt_slow_logname= 0;\n  opt_log_basename= 0;\n  opt_tc_log_file= (char *)\"tc.log\";      // no hostname in tc_log file name !\n  opt_secure_auth= 0;\n  opt_bootstrap= opt_myisam_log= 0;\n  mqh_used= 0;\n  kill_in_progress= 0;\n  cleanup_done= 0;\n  server_id_supplied= 0;\n  test_flags= select_errors= dropping_tables= ha_open_options=0;\n  thread_count= thread_running= kill_cached_threads= wake_thread=0;\n  slave_open_temp_tables= 0;\n  cached_thread_count= 0;\n  opt_endinfo= using_udf_functions= 0;\n  opt_using_transactions= 0;\n  abort_loop= select_thread_in_use= signal_thread_in_use= 0;\n  ready_to_exit= shutdown_in_progress= grant_option= 0;\n  aborted_threads= aborted_connects= 0;\n  subquery_cache_miss= subquery_cache_hit= 0;\n  delayed_insert_threads= delayed_insert_writes= delayed_rows_in_use= 0;\n  delayed_insert_errors= thread_created= 0;\n  specialflag= 0;\n  binlog_cache_use=  binlog_cache_disk_use= 0;\n  max_used_connections= slow_launch_threads = 0;\n  mysqld_user= mysqld_chroot= opt_init_file= opt_bin_logname = 0;\n  prepared_stmt_count= 0;\n  mysqld_unix_port= opt_mysql_tmpdir= my_bind_addr_str= NullS;\n  bzero((uchar*) &mysql_tmpdir_list, sizeof(mysql_tmpdir_list));\n  bzero((char *) &global_status_var, sizeof(global_status_var));\n  opt_large_pages= 0;\n  opt_super_large_pages= 0;\n#if defined(ENABLED_DEBUG_SYNC)\n  opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  key_map_full.set_all();\n\n  /* Character sets */\n  system_charset_info= &my_charset_utf8_general_ci;\n  files_charset_info= &my_charset_utf8_general_ci;\n  national_charset_info= &my_charset_utf8_general_ci;\n  table_alias_charset= &my_charset_bin;\n  character_set_filesystem= &my_charset_bin;\n\n  opt_specialflag= SPECIAL_ENGLISH;\n  unix_sock= base_ip_sock= extra_ip_sock= INVALID_SOCKET;\n  mysql_home_ptr= mysql_home;\n  pidfile_name_ptr= pidfile_name;\n  log_error_file_ptr= log_error_file;\n  protocol_version= PROTOCOL_VERSION;\n  what_to_log= ~ (1L << (uint) COM_TIME);\n  refresh_version= 2L;\t/* Increments on each reload. 0 and 1 are reserved */\n  executed_events= 0;\n  global_query_id= thread_id= 1L;\n  my_atomic_rwlock_init(&global_query_id_lock);\n  my_atomic_rwlock_init(&thread_running_lock);\n  strnmov(server_version, MYSQL_SERVER_VERSION, sizeof(server_version)-1);\n  threads.empty();\n  thread_cache.empty();\n  key_caches.empty();\n  if (!(dflt_key_cache= get_or_create_key_cache(default_key_cache_base.str,\n                                                default_key_cache_base.length)))\n  {\n    sql_print_error(\"Cannot allocate the keycache\");\n    return 1;\n  }\n\n  /* set key_cache_hash.default_value = dflt_key_cache */\n  multi_keycache_init();\n\n  /* Set directory paths */\n  mysql_real_data_home_len=\n    strmake_buf(mysql_real_data_home,\n                get_relative_path(MYSQL_DATADIR)) - mysql_real_data_home;\n  /* Replication parameters */\n  master_info_file= (char*) \"master.info\",\n    relay_log_info_file= (char*) \"relay-log.info\";\n  report_user= report_password = report_host= 0;\t/* TO BE DELETED */\n  opt_relay_logname= opt_relaylog_index_name= 0;\n\n  /* Variables in libraries */\n  charsets_dir= 0;\n  default_character_set_name= (char*) MYSQL_DEFAULT_CHARSET_NAME;\n  default_collation_name= compiled_default_collation_name;\n  character_set_filesystem_name= (char*) \"binary\";\n  lc_messages= (char*) \"en_US\";\n  lc_time_names_name= (char*) \"en_US\";\n  \n  /* Variables that depends on compile options */\n#ifndef DBUG_OFF\n  default_dbug_option=IF_WIN(\"d:t:i:O,\\\\mysqld.trace\",\n\t\t\t     \"d:t:i:o,/tmp/mysqld.trace\");\n  current_dbug_option= default_dbug_option;\n#endif\n  opt_error_log= IF_WIN(1,0);\n#ifdef ENABLED_PROFILING\n    have_profiling = SHOW_OPTION_YES;\n#else\n    have_profiling = SHOW_OPTION_NO;\n#endif\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  have_ssl=SHOW_OPTION_YES;\n#else\n  have_ssl=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_BROKEN_REALPATH\n  have_symlink=SHOW_OPTION_NO;\n#else\n  have_symlink=SHOW_OPTION_YES;\n#endif\n#ifdef HAVE_DLOPEN\n  have_dlopen=SHOW_OPTION_YES;\n#else\n  have_dlopen=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_QUERY_CACHE\n  have_query_cache=SHOW_OPTION_YES;\n#else\n  have_query_cache=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_SPATIAL\n  have_geometry=SHOW_OPTION_YES;\n#else\n  have_geometry=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_RTREE_KEYS\n  have_rtree_keys=SHOW_OPTION_YES;\n#else\n  have_rtree_keys=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_CRYPT\n  have_crypt=SHOW_OPTION_YES;\n#else\n  have_crypt=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_COMPRESS\n  have_compress= SHOW_OPTION_YES;\n#else\n  have_compress= SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_LIBWRAP\n  libwrapName= NullS;\n#endif\n#ifdef HAVE_OPENSSL\n  des_key_file = 0;\n#ifndef EMBEDDED_LIBRARY\n  ssl_acceptor_fd= 0;\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_SMEM\n  shared_memory_base_name= default_shared_memory_base_name;\n#endif\n\n#if defined(__WIN__)\n  /* Allow Win32 users to move MySQL anywhere */\n  {\n    char prg_dev[LIBLEN];\n    char executing_path_name[LIBLEN];\n    if (!test_if_hard_path(my_progname))\n    {\n      // we don't want to use GetModuleFileName inside of my_path since\n      // my_path is a generic path dereferencing function and here we care\n      // only about the executing binary.\n      GetModuleFileName(NULL, executing_path_name, sizeof(executing_path_name));\n      my_path(prg_dev, executing_path_name, NULL);\n    }\n    else\n      my_path(prg_dev, my_progname, \"mysql/bin\");\n    strcat(prg_dev,\"/../\");\t\t\t// Remove 'bin' to get base dir\n    cleanup_dirname(mysql_home,prg_dev);\n  }\n#else\n  const char *tmpenv;\n  if (!(tmpenv = getenv(\"MY_BASEDIR_VERSION\")))\n    tmpenv = DEFAULT_MYSQL_HOME;\n  strmake_buf(mysql_home, tmpenv);\n#endif\n  return 0;\n}\n\nmy_bool\nmysqld_get_one_option(int optid,\n                      const struct my_option *opt __attribute__((unused)),\n                      char *argument)\n{\n  switch(optid) {\n  case '#':\n#ifndef DBUG_OFF\n    if (!argument)\n      argument= (char*) default_dbug_option;\n    if (argument[0] == '0' && !argument[1])\n    {\n      DEBUGGER_OFF;\n      break;\n    }\n    DEBUGGER_ON;\n    if (argument[0] == '1' && !argument[1])\n      break;\n    DBUG_SET_INITIAL(argument);\n    opt_endinfo=1;\t\t\t\t/* unireg: memory allocation */\n#else\n    sql_print_warning(\"'%s' is disabled in this build\", opt->name);\n#endif\n    break;\n  case OPT_DEPRECATED_OPTION:\n    sql_print_warning(\"'%s' is deprecated. It does nothing and exists only \"\n                      \"for compatiblity with old my.cnf files.\",\n                      opt->name);\n    break;\n  case 'a':\n    global_system_variables.sql_mode= MODE_ANSI;\n    global_system_variables.tx_isolation= ISO_SERIALIZABLE;\n    break;\n  case 'b':\n    strmake_buf(mysql_home, argument);\n    break;\n  case 'C':\n    if (default_collation_name == compiled_default_collation_name)\n      default_collation_name= 0;\n    break;\n  case 'l':\n    WARN_DEPRECATED(NULL, 7, 0, \"--log\", \"'--general-log'/'--general-log-file'\");\n    opt_log=1;\n    break;\n  case 'h':\n    strmake_buf(mysql_real_data_home, argument);\n    /* Correct pointer set by my_getopt (for embedded library) */\n    mysql_real_data_home_ptr= mysql_real_data_home;\n    break;\n  case 'u':\n    if (!mysqld_user || !strcmp(mysqld_user, argument))\n      mysqld_user= argument;\n    else\n      sql_print_warning(\"Ignoring user change to '%s' because the user was set to '%s' earlier on the command line\\n\", argument, mysqld_user);\n    break;\n  case 'L':\n    strmake_buf(lc_messages_dir, argument);\n    break;\n  case OPT_BINLOG_FORMAT:\n    binlog_format_used= true;\n    break;\n#include <sslopt-case.h>\n#ifndef EMBEDDED_LIBRARY\n  case 'V':\n    print_version();\n    opt_abort= 1;                    // Abort after parsing all options\n    break;\n#endif /*EMBEDDED_LIBRARY*/\n  case 'W':\n    if (!argument)\n      global_system_variables.log_warnings++;\n    else if (argument == disabled_my_option)\n      global_system_variables.log_warnings= 0L;\n    else\n      global_system_variables.log_warnings= atoi(argument);\n    break;\n  case 'T':\n    test_flags= argument ? (uint) atoi(argument) : 0;\n    opt_endinfo=1;\n    break;\n  case OPT_THREAD_CONCURRENCY:\n    WARN_DEPRECATED_NO_REPLACEMENT(NULL, \"THREAD_CONCURRENCY\");\n    break;\n  case (int) OPT_ISAM_LOG:\n    opt_myisam_log=1;\n    break;\n  case (int) OPT_BIN_LOG:\n    opt_bin_log= test(argument != disabled_my_option);\n    opt_bin_log_used= 1;\n    break;\n  case (int) OPT_LOG_BASENAME:\n  {\n    if (opt_log_basename[0] == 0 || strchr(opt_log_basename, FN_EXTCHAR) ||\n        strchr(opt_log_basename,FN_LIBCHAR))\n    {\n      sql_print_error(\"Wrong argument for --log-basename. It can't be empty or contain '.' or '\" FN_DIRSEP \"'\");\n      return 1;\n    }\n    if (log_error_file_ptr != disabled_my_option)\n      log_error_file_ptr= opt_log_basename;\n\n    make_default_log_name(&opt_logname, \".log\", false);\n    make_default_log_name(&opt_slow_logname, \"-slow.log\", false);\n    make_default_log_name(&opt_bin_logname, \"-bin\", true);\n    make_default_log_name(&opt_binlog_index_name, \"-bin.index\", true);\n    make_default_log_name(&opt_relay_logname, \"-relay-bin\", true);\n    make_default_log_name(&opt_relaylog_index_name, \"-relay-bin.index\", true);\n\n    pidfile_name_ptr= pidfile_name;\n    strmake(pidfile_name, argument, sizeof(pidfile_name)-5);\n    strmov(fn_ext(pidfile_name),\".pid\");\n\n    /* check for errors */\n    if (!opt_bin_logname || !opt_relaylog_index_name || ! opt_logname ||\n        ! opt_slow_logname || !pidfile_name_ptr)\n      return 1;                                 // out of memory error\n    break;\n  }\n#ifdef HAVE_REPLICATION\n  case (int)OPT_REPLICATE_IGNORE_DB:\n  {\n    rpl_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_DB:\n  {\n    rpl_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_REWRITE_DB:\n  {\n    /* See also OPT_REWRITE_DB handling in client/mysqlbinlog.cc */\n    char* key = argument,*p, *val;\n\n    if (!(p= strstr(argument, \"->\")))\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - missing '->'!\\n\");\n      return 1;\n    }\n    val= p--;\n    while (my_isspace(mysqld_charset, *p) && p > argument)\n      *p-- = 0;\n    if (p == argument)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty FROM db!\\n\");\n      return 1;\n    }\n    *val= 0;\n    val+= 2;\n    while (*val && my_isspace(mysqld_charset, *val))\n      val++;\n    if (!*val)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty TO db!\\n\");\n      return 1;\n    }\n\n    rpl_filter->add_db_rewrite(key, val);\n    break;\n  }\n\n  case (int)OPT_BINLOG_IGNORE_DB:\n  {\n    binlog_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_BINLOG_DO_DB:\n  {\n    binlog_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_TABLE:\n  {\n    if (rpl_filter->add_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_DO_TABLE:\n  {\n    if (rpl_filter->add_wild_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_wild_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n#endif /* HAVE_REPLICATION */\n  case (int) OPT_SLOW_QUERY_LOG:\n    WARN_DEPRECATED(NULL, 7, 0, \"--log-slow-queries\", \"'--slow-query-log'/'--slow-query-log-file'\");\n    opt_slow_log= 1;\n    break;\n  case (int) OPT_SAFE:\n    opt_specialflag|= SPECIAL_SAFE_MODE | SPECIAL_NO_NEW_FUNC;\n    delay_key_write_options= (uint) DELAY_KEY_WRITE_NONE;\n    myisam_recover_options= HA_RECOVER_DEFAULT;\n    ha_open_options&= ~(HA_OPEN_DELAY_KEY_WRITE);\n#ifdef HAVE_QUERY_CACHE\n    query_cache_size=0;\n#endif\n    sql_print_warning(\"The syntax '--safe-mode' is deprecated and will be \"\n                      \"removed in a future release.\");\n    break;\n  case (int) OPT_SKIP_PRIOR:\n    opt_specialflag|= SPECIAL_NO_PRIOR;\n    sql_print_warning(\"The --skip-thread-priority startup option is deprecated \"\n                      \"and will be removed in MySQL 7.0. This option has no effect \"\n                      \"as the implied behavior is already the default.\");\n    break;\n  case (int) OPT_SKIP_HOST_CACHE:\n    opt_specialflag|= SPECIAL_NO_HOST_CACHE;\n    break;\n  case (int) OPT_SKIP_RESOLVE:\n    opt_skip_name_resolve= 1;\n    opt_specialflag|=SPECIAL_NO_RESOLVE;\n    break;\n  case (int) OPT_WANT_CORE:\n    test_flags |= TEST_CORE_ON_SIGNAL;\n    break;\n  case OPT_CONSOLE:\n    if (opt_console)\n      opt_error_log= 0;\t\t\t// Force logs to stdout\n    break;\n  case OPT_BOOTSTRAP:\n    opt_noacl=opt_bootstrap=1;\n    break;\n  case OPT_SERVER_ID:\n    server_id_supplied = 1;\n    break;\n  case OPT_ONE_THREAD:\n    thread_handling= SCHEDULER_NO_THREADS;\n    break;\n  case OPT_LOWER_CASE_TABLE_NAMES:\n    lower_case_table_names_used= 1;\n    break;\n#if defined(ENABLED_DEBUG_SYNC)\n  case OPT_DEBUG_SYNC_TIMEOUT:\n    /*\n      Debug Sync Facility. See debug_sync.cc.\n      Default timeout for WAIT_FOR action.\n      Default value is zero (facility disabled).\n      If option is given without an argument, supply a non-zero value.\n    */\n    if (!argument)\n    {\n      /* purecov: begin tested */\n      opt_debug_sync_timeout= DEBUG_SYNC_DEFAULT_WAIT_TIMEOUT;\n      /* purecov: end */\n    }\n    break;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  case OPT_ENGINE_CONDITION_PUSHDOWN:\n    /*\n      The last of --engine-condition-pushdown and --optimizer_switch on\n      command line wins (see get_options().\n    */\n    if (global_system_variables.engine_condition_pushdown)\n      global_system_variables.optimizer_switch|=\n        OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n    else\n      global_system_variables.optimizer_switch&=\n        ~OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n    break;\n  case OPT_LOG_ERROR:\n    /*\n      \"No --log-error\" == \"write errors to stderr\",\n      \"--log-error without argument\" == \"write errors to a file\".\n    */\n    if (argument == NULL) /* no argument */\n      log_error_file_ptr= const_cast<char*>(\"\");\n    break;\n  case OPT_MAX_LONG_DATA_SIZE:\n    max_long_data_size_used= true;\n    break;\n\n\n  case OPT_IGNORE_DB_DIRECTORY:\n    opt_ignore_db_dirs= NULL; // will be set in ignore_db_dirs_process_additions\n    if (*argument == 0)\n      ignore_db_dirs_reset();\n    else\n    {\n      if (push_ignored_db_dir(argument))\n      {\n        sql_print_error(\"Can't start server: \"\n                        \"cannot process --ignore-db-dir=%.*s\", \n                        FN_REFLEN, argument);\n        return 1;\n      }\n    }\n    break;\n  }\n  return 0;\n}\n\n\n/** Handle arguments for multiple key caches. */\n\nC_MODE_START\n\nstatic void*\nmysql_getopt_value(const char *keyname, uint key_length,\n\t\t   const struct my_option *option, int *error)\n{\n  if (error)\n    *error= 0;\n  switch (option->id) {\n  case OPT_KEY_BUFFER_SIZE:\n  case OPT_KEY_CACHE_BLOCK_SIZE:\n  case OPT_KEY_CACHE_DIVISION_LIMIT:\n  case OPT_KEY_CACHE_AGE_THRESHOLD:\n  case OPT_KEY_CACHE_PARTITIONS:\n  {\n    KEY_CACHE *key_cache;\n    if (!(key_cache= get_or_create_key_cache(keyname, key_length)))\n    {\n      if (error)\n        *error= EXIT_OUT_OF_MEMORY;\n      return 0;\n    }\n    switch (option->id) {\n    case OPT_KEY_BUFFER_SIZE:\n      return &key_cache->param_buff_size;\n    case OPT_KEY_CACHE_BLOCK_SIZE:\n      return &key_cache->param_block_size;\n    case OPT_KEY_CACHE_DIVISION_LIMIT:\n      return &key_cache->param_division_limit;\n    case OPT_KEY_CACHE_AGE_THRESHOLD:\n      return &key_cache->param_age_threshold;\n    case OPT_KEY_CACHE_PARTITIONS:\n      return (uchar**) &key_cache->param_partitions;\n    }\n  }\n  }\n  return option->value;\n}\n\nstatic void option_error_reporter(enum loglevel level, const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n\n  /* Don't print warnings for --loose options during bootstrap */\n  if (level == ERROR_LEVEL || !opt_bootstrap ||\n      global_system_variables.log_warnings)\n  {\n    vprint_msg_to_log(level, format, args);\n  }\n  va_end(args);\n}\n\nC_MODE_END\n\n/**\n  Get server options from the command line,\n  and perform related server initializations.\n  @param [in, out] argc_ptr       command line options (count)\n  @param [in, out] argv_ptr       command line options (values)\n  @return 0 on success\n\n  @todo\n  - FIXME add EXIT_TOO_MANY_ARGUMENTS to \"mysys_err.h\" and return that code?\n*/\nstatic int get_options(int *argc_ptr, char ***argv_ptr)\n{\n  int ho_error;\n\n  my_getopt_register_get_addr(mysql_getopt_value);\n  my_getopt_error_reporter= option_error_reporter;\n\n  /* prepare all_options array */\n  my_init_dynamic_array(&all_options, sizeof(my_option),\n                        array_elements(my_long_options),\n                        array_elements(my_long_options)/4);\n  for (my_option *opt= my_long_options;\n       opt < my_long_options + array_elements(my_long_options) - 1;\n       opt++)\n    insert_dynamic(&all_options, (uchar*) opt);\n  sys_var_add_options(&all_options, 0);\n  add_terminator(&all_options);\n\n  /* Skip unknown options so that they may be processed later by plugins */\n  my_getopt_skip_unknown= TRUE;\n\n  if ((ho_error= handle_options(argc_ptr, argv_ptr, (my_option*)(all_options.buffer),\n                                mysqld_get_one_option)))\n    return ho_error;\n\n  if (!opt_help)\n    delete_dynamic(&all_options);\n  else\n    opt_abort= 1;\n\n  /* Add back the program name handle_options removes */\n  (*argc_ptr)++;\n  (*argv_ptr)--;\n\n  /*\n    Options have been parsed. Now some of them need additional special\n    handling, like custom value checking, checking of incompatibilites\n    between options, setting of multiple variables, etc.\n    Do them here.\n  */\n\n  if ((opt_log_slow_admin_statements || opt_log_queries_not_using_indexes ||\n       opt_log_slow_slave_statements) &&\n      !opt_slow_log)\n    sql_print_warning(\"options --log-slow-admin-statements, --log-queries-not-using-indexes and --log-slow-slave-statements have no effect if --log_slow_queries is not set\");\n  if (global_system_variables.net_buffer_length > \n      global_system_variables.max_allowed_packet)\n  {\n    sql_print_warning(\"net_buffer_length (%lu) is set to be larger \"\n                      \"than max_allowed_packet (%lu). Please rectify.\",\n                      global_system_variables.net_buffer_length, \n                      global_system_variables.max_allowed_packet);\n  }\n\n  if (log_error_file_ptr != disabled_my_option)\n    opt_error_log= 1;\n  else\n    log_error_file_ptr= const_cast<char*>(\"\");\n\n  opt_init_connect.length=strlen(opt_init_connect.str);\n  opt_init_slave.length=strlen(opt_init_slave.str);\n\n  if (global_system_variables.low_priority_updates)\n    thr_upgraded_concurrent_insert_lock= TL_WRITE_LOW_PRIORITY;\n\n  if (ft_boolean_check_syntax_string((uchar*) ft_boolean_syntax))\n  {\n    sql_print_error(\"Invalid ft-boolean-syntax string: %s\\n\",\n                    ft_boolean_syntax);\n    return 1;\n  }\n\n  if (opt_disable_networking)\n    mysqld_port= mysqld_extra_port= 0;\n\n  if (opt_skip_show_db)\n    opt_specialflag|= SPECIAL_SKIP_SHOW_DB;\n\n  if (myisam_flush)\n    flush_time= 0;\n\n#ifdef HAVE_REPLICATION\n  if (opt_slave_skip_errors)\n    init_slave_skip_errors(opt_slave_skip_errors);\n#endif\n\n  if (global_system_variables.max_join_size == HA_POS_ERROR)\n    global_system_variables.option_bits|= OPTION_BIG_SELECTS;\n  else\n    global_system_variables.option_bits&= ~OPTION_BIG_SELECTS;\n\n  // Synchronize @@global.autocommit on --autocommit\n  const ulonglong turn_bit_on= opt_autocommit ?\n    OPTION_AUTOCOMMIT : OPTION_NOT_AUTOCOMMIT;\n  global_system_variables.option_bits=\n    (global_system_variables.option_bits &\n     ~(OPTION_NOT_AUTOCOMMIT | OPTION_AUTOCOMMIT)) | turn_bit_on;\n\n  global_system_variables.sql_mode=\n    expand_sql_mode(global_system_variables.sql_mode);\n#if defined(HAVE_BROKEN_REALPATH)\n  my_use_symdir=0;\n  my_disable_symlinks=1;\n  have_symlink=SHOW_OPTION_NO;\n#else\n  if (!my_use_symdir)\n  {\n    my_disable_symlinks=1;\n    have_symlink=SHOW_OPTION_DISABLED;\n  }\n#endif\n  if (opt_debugging)\n  {\n    /* Allow break with SIGINT, no core or stack trace */\n    test_flags|= TEST_SIGINT;\n    opt_stack_trace= 1;\n    test_flags&= ~TEST_CORE_ON_SIGNAL;\n  }\n  /* Set global MyISAM variables from delay_key_write_options */\n  fix_delay_key_write(0, 0, OPT_GLOBAL);\n\n#ifndef EMBEDDED_LIBRARY\n  if (mysqld_chroot)\n    set_root(mysqld_chroot);\n#else\n  thread_handling = SCHEDULER_NO_THREADS;\n  max_allowed_packet= global_system_variables.max_allowed_packet;\n  net_buffer_length= global_system_variables.net_buffer_length;\n#endif\n  if (fix_paths())\n    return 1;\n\n  /*\n    Set some global variables from the global_system_variables\n    In most cases the global variables will not be used\n  */\n  my_disable_locking= myisam_single_user= test(opt_external_locking == 0);\n  my_default_record_cache_size=global_system_variables.read_buff_size;\n\n  /*\n    Log mysys errors when we don't have a thd or thd->log_all_errors is set\n    (recovery) to the log.  This is mainly useful for debugging strange system\n    errors.\n  */\n  if (global_system_variables.log_warnings >= 10)\n    my_global_flags= MY_WME | ME_JUST_INFO;\n  /* Log all errors not handled by thd->handle_error() to my_message_sql() */\n  if (global_system_variables.log_warnings >= 11)\n    my_global_flags|= ME_NOREFRESH;\n  if (my_assert_on_error)\n    debug_assert_if_crashed_table= 1;\n\n  global_system_variables.long_query_time= (ulonglong)\n    (global_system_variables.long_query_time_double * 1e6);\n\n  if (opt_short_log_format)\n    opt_specialflag|= SPECIAL_SHORT_LOG_FORMAT;\n\n  if (init_global_datetime_format(MYSQL_TIMESTAMP_DATE,\n                                  &global_date_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_TIME,\n                                  &global_time_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_DATETIME,\n                                  &global_datetime_format))\n    return 1;\n\n#ifdef EMBEDDED_LIBRARY\n  one_thread_scheduler(thread_scheduler);\n  one_thread_scheduler(extra_thread_scheduler);\n#else\n\n#ifdef _WIN32\n  /* workaround: disable thread pool on XP */\n  if (GetProcAddress(GetModuleHandle(\"kernel32\"),\"CreateThreadpool\") == 0 &&\n      thread_handling > SCHEDULER_NO_THREADS)\n    thread_handling = SCHEDULER_ONE_THREAD_PER_CONNECTION;\n#endif\n\n  if (thread_handling <= SCHEDULER_ONE_THREAD_PER_CONNECTION)\n    one_thread_per_connection_scheduler(thread_scheduler, &max_connections,\n                                        &connection_count);\n  else if (thread_handling == SCHEDULER_NO_THREADS)\n    one_thread_scheduler(thread_scheduler);\n  else\n    pool_of_threads_scheduler(thread_scheduler,  &max_connections,\n                                        &connection_count); \n\n  one_thread_per_connection_scheduler(extra_thread_scheduler,\n                                      &extra_max_connections,\n                                      &extra_connection_count);\n#endif\n\n  global_system_variables.engine_condition_pushdown=\n    test(global_system_variables.optimizer_switch &\n         OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN);\n\n  opt_readonly= read_only;\n\n  /*\n    If max_long_data_size is not specified explicitly use\n    value of max_allowed_packet.\n  */\n  if (!max_long_data_size_used)\n    max_long_data_size= global_system_variables.max_allowed_packet;\n\n  /* Rember if max_user_connections was 0 at startup */\n  max_user_connections_checking= global_system_variables.max_user_connections != 0;\n  return 0;\n}\n\n\n/*\n  Create version name for running mysqld version\n  We automaticly add suffixes -debug, -embedded and -log to the version\n  name to make the version more descriptive.\n  (MYSQL_SERVER_SUFFIX is set by the compilation environment)\n*/\n\nvoid set_server_version(void)\n{\n  char *version_end= server_version+sizeof(server_version)-1;\n  char *end= strxnmov(server_version, sizeof(server_version)-1,\n                      MYSQL_SERVER_VERSION,\n                      MYSQL_SERVER_SUFFIX_STR, NullS);\n#ifdef EMBEDDED_LIBRARY\n  end= strnmov(end, \"-embedded\", (version_end-end));\n#endif\n#ifndef DBUG_OFF\n  if (!strstr(MYSQL_SERVER_SUFFIX_STR, \"-debug\"))\n    end= strnmov(end, \"-debug\", (version_end-end));\n#endif\n  if (opt_log || opt_slow_log || opt_bin_log)\n    strnmov(end, \"-log\", (version_end-end)); // This may slow down system\n  *end= 0;\n}\n\n\nstatic char *get_relative_path(const char *path)\n{\n  if (test_if_hard_path(path) &&\n      is_prefix(path,DEFAULT_MYSQL_HOME) &&\n      strcmp(DEFAULT_MYSQL_HOME,FN_ROOTDIR))\n  {\n    path+=(uint) strlen(DEFAULT_MYSQL_HOME);\n    while (*path == FN_LIBCHAR || *path == FN_LIBCHAR2)\n      path++;\n  }\n  return (char*) path;\n}\n\n\n/**\n  Fix filename and replace extension where 'dir' is relative to\n  mysql_real_data_home.\n  @return\n    1 if len(path) > FN_REFLEN\n*/\n\nbool\nfn_format_relative_to_data_home(char * to, const char *name,\n\t\t\t\tconst char *dir, const char *extension)\n{\n  char tmp_path[FN_REFLEN];\n  if (!test_if_hard_path(dir))\n  {\n    strxnmov(tmp_path,sizeof(tmp_path)-1, mysql_real_data_home,\n\t     dir, NullS);\n    dir=tmp_path;\n  }\n  return !fn_format(to, name, dir, extension,\n\t\t    MY_APPEND_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH);\n}\n\n\n/**\n  Test a file path to determine if the path is compatible with the secure file\n  path restriction.\n \n  @param path null terminated character string\n\n  @return\n    @retval TRUE The path is secure\n    @retval FALSE The path isn't secure\n*/\n\nbool is_secure_file_path(char *path)\n{\n  char buff1[FN_REFLEN], buff2[FN_REFLEN];\n  size_t opt_secure_file_priv_len;\n  /*\n    All paths are secure if opt_secure_file_path is 0\n  */\n  if (!opt_secure_file_priv)\n    return TRUE;\n\n  opt_secure_file_priv_len= strlen(opt_secure_file_priv);\n\n  if (strlen(path) >= FN_REFLEN)\n    return FALSE;\n\n  if (my_realpath(buff1, path, 0))\n  {\n    /*\n      The supplied file path might have been a file and not a directory.\n    */\n    size_t length= dirname_length(path);        // Guaranteed to be < FN_REFLEN\n    memcpy(buff2, path, length);\n    buff2[length]= '\\0';\n    if (length == 0 || my_realpath(buff1, buff2, 0))\n      return FALSE;\n  }\n  convert_dirname(buff2, buff1, NullS);\n  if (!lower_case_file_system)\n  {\n    if (strncmp(opt_secure_file_priv, buff2, opt_secure_file_priv_len))\n      return FALSE;\n  }\n  else\n  {\n    if (files_charset_info->coll->strnncoll(files_charset_info,\n                                            (uchar *) buff2, strlen(buff2),\n                                            (uchar *) opt_secure_file_priv,\n                                            opt_secure_file_priv_len,\n                                            TRUE))\n      return FALSE;\n  }\n  return TRUE;\n}\n\n\nstatic int fix_paths(void)\n{\n  char buff[FN_REFLEN],*pos;\n  DBUG_ENTER(\"fix_paths\");\n\n  convert_dirname(mysql_home,mysql_home,NullS);\n  /* Resolve symlinks to allow 'mysql_home' to be a relative symlink */\n  my_realpath(mysql_home,mysql_home,MYF(0));\n  /* Ensure that mysql_home ends in FN_LIBCHAR */\n  pos=strend(mysql_home);\n  if (pos[-1] != FN_LIBCHAR)\n  {\n    pos[0]= FN_LIBCHAR;\n    pos[1]= 0;\n  }\n  convert_dirname(lc_messages_dir, lc_messages_dir, NullS);\n  convert_dirname(mysql_real_data_home,mysql_real_data_home,NullS);\n  (void) my_load_path(mysql_home,mysql_home,\"\"); // Resolve current dir\n  (void) my_load_path(mysql_real_data_home,mysql_real_data_home,mysql_home);\n  (void) my_load_path(pidfile_name, pidfile_name_ptr, mysql_real_data_home);\n\n  convert_dirname(opt_plugin_dir, opt_plugin_dir_ptr ? opt_plugin_dir_ptr : \n                                  get_relative_path(PLUGINDIR), NullS);\n  (void) my_load_path(opt_plugin_dir, opt_plugin_dir, mysql_home);\n  opt_plugin_dir_ptr= opt_plugin_dir;\n  pidfile_name_ptr= pidfile_name;\n\n  my_realpath(mysql_unpacked_real_data_home, mysql_real_data_home, MYF(0));\n  mysql_unpacked_real_data_home_len= \n    (int) strlen(mysql_unpacked_real_data_home);\n  if (mysql_unpacked_real_data_home[mysql_unpacked_real_data_home_len-1] == FN_LIBCHAR)\n    --mysql_unpacked_real_data_home_len;\n\n  char *sharedir=get_relative_path(SHAREDIR);\n  if (test_if_hard_path(sharedir))\n    strmake_buf(buff, sharedir);\t\t/* purecov: tested */\n  else\n    strxnmov(buff,sizeof(buff)-1,mysql_home,sharedir,NullS);\n  convert_dirname(buff,buff,NullS);\n  (void) my_load_path(lc_messages_dir, lc_messages_dir, buff);\n\n  /* If --character-sets-dir isn't given, use shared library dir */\n  if (charsets_dir)\n    strmake_buf(mysql_charsets_dir, charsets_dir);\n  else\n    strxnmov(mysql_charsets_dir, sizeof(mysql_charsets_dir)-1, buff,\n\t     CHARSET_DIR, NullS);\n  (void) my_load_path(mysql_charsets_dir, mysql_charsets_dir, buff);\n  convert_dirname(mysql_charsets_dir, mysql_charsets_dir, NullS);\n  charsets_dir=mysql_charsets_dir;\n\n  if (init_tmpdir(&mysql_tmpdir_list, opt_mysql_tmpdir))\n    DBUG_RETURN(1);\n  if (!opt_mysql_tmpdir)\n    opt_mysql_tmpdir= mysql_tmpdir;\n#ifdef HAVE_REPLICATION\n  if (!slave_load_tmpdir)\n    slave_load_tmpdir= mysql_tmpdir;\n#endif /* HAVE_REPLICATION */\n  /*\n    Convert the secure-file-priv option to system format, allowing\n    a quick strcmp to check if read or write is in an allowed dir\n  */\n  if (opt_secure_file_priv)\n  {\n    if (*opt_secure_file_priv == 0)\n    {\n      my_free(opt_secure_file_priv);\n      opt_secure_file_priv= 0;\n    }\n    else\n    {\n      if (strlen(opt_secure_file_priv) >= FN_REFLEN)\n        opt_secure_file_priv[FN_REFLEN-1]= '\\0';\n      if (my_realpath(buff, opt_secure_file_priv, 0))\n      {\n        sql_print_warning(\"Failed to normalize the argument for --secure-file-priv.\");\n        DBUG_RETURN(1);\n      }\n      char *secure_file_real_path= (char *)my_malloc(FN_REFLEN, MYF(MY_FAE));\n      convert_dirname(secure_file_real_path, buff, NullS);\n      my_free(opt_secure_file_priv);\n      opt_secure_file_priv= secure_file_real_path;\n    }\n  }\n  DBUG_RETURN(0);\n}\n\n/**\n  Check if file system used for databases is case insensitive.\n\n  @param dir_name\t\t\tDirectory to test\n\n  @retval -1  Don't know (Test failed)\n  @retval  0   File system is case sensitive\n  @retval  1   File system is case insensitive\n*/\n\nstatic int test_if_case_insensitive(const char *dir_name)\n{\n  int result= 0;\n  File file;\n  char buff[FN_REFLEN], buff2[FN_REFLEN];\n  MY_STAT stat_info;\n  DBUG_ENTER(\"test_if_case_insensitive\");\n\n  fn_format(buff, glob_hostname, dir_name, \".lower-test\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  fn_format(buff2, glob_hostname, dir_name, \".LOWER-TEST\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  mysql_file_delete(key_file_casetest, buff2, MYF(0));\n  if ((file= mysql_file_create(key_file_casetest,\n                               buff, 0666, O_RDWR, MYF(0))) < 0)\n  {\n    if (!opt_abort)\n      sql_print_warning(\"Can't create test file %s\", buff);\n    DBUG_RETURN(-1);\n  }\n  mysql_file_close(file, MYF(0));\n  if (mysql_file_stat(key_file_casetest, buff2, &stat_info, MYF(0)))\n    result= 1;\t\t\t\t\t// Can access file\n  mysql_file_delete(key_file_casetest, buff, MYF(MY_WME));\n  DBUG_PRINT(\"exit\", (\"result: %d\", result));\n  DBUG_RETURN(result);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  Create file to store pid number.\n*/\nstatic void create_pid_file()\n{\n  File file;\n  if ((file= mysql_file_create(key_file_pid, pidfile_name, 0664,\n                               O_WRONLY | O_TRUNC, MYF(MY_WME))) >= 0)\n  {\n    char buff[MAX_BIGINT_WIDTH + 1], *end;\n    end= int10_to_str((long) getpid(), buff, 10);\n    *end++= '\\n';\n    if (!mysql_file_write(file, (uchar*) buff, (uint) (end-buff),\n                          MYF(MY_WME | MY_NABP)))\n    {\n      mysql_file_close(file, MYF(0));\n      pid_file_created= true;\n      return;\n    }\n    mysql_file_close(file, MYF(0));\n  }\n  sql_perror(\"Can't start server: can't create PID file\");\n  exit(1);\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/**\n  Remove the process' pid file.\n  \n  @param  flags  file operation flags\n*/\n\nstatic void delete_pid_file(myf flags)\n{\n#ifndef EMBEDDED_LIBRARY\n  if (pid_file_created)\n  {\n    mysql_file_delete(key_file_pid, pidfile_name, flags);\n    pid_file_created= false;\n  }\n#endif /* EMBEDDED_LIBRARY */\n  return;\n}\n\n\n/** Clear most status variables. */\nvoid refresh_status(THD *thd)\n{\n  mysql_mutex_lock(&LOCK_status);\n\n  /* Add thread's status variabes to global status */\n  add_to_status(&global_status_var, &thd->status_var);\n\n  /* Reset thread's status variables */\n  bzero((uchar*) &thd->status_var, sizeof(thd->status_var));\n  bzero((uchar*) &thd->org_status_var, sizeof(thd->org_status_var)); \n  thd->start_bytes_received= 0;\n\n  /* Reset some global variables */\n  reset_status_vars();\n\n  /* Reset the counters of all key caches (default and named). */\n  process_key_caches(reset_key_cache_counters, 0);\n  flush_status_time= time((time_t*) 0);\n  mysql_mutex_unlock(&LOCK_status);\n\n  /*\n    Set max_used_connections to the number of currently open\n    connections.  Lock LOCK_thread_count out of LOCK_status to avoid\n    deadlocks.  Status reset becomes not atomic, but status data is\n    not exact anyway.\n  */\n  mysql_mutex_lock(&LOCK_thread_count);\n  max_used_connections= thread_count-delayed_insert_threads;\n  mysql_mutex_unlock(&LOCK_thread_count);\n}\n\n\n/*****************************************************************************\n  Instantiate variables for missing storage engines\n  This section should go away soon\n*****************************************************************************/\n\n/*****************************************************************************\n  Instantiate templates\n*****************************************************************************/\n\n#ifdef HAVE_EXPLICIT_TEMPLATE_INSTANTIATION\n/* Used templates */\ntemplate class I_List<THD>;\ntemplate class I_List_iterator<THD>;\ntemplate class I_List<i_string>;\ntemplate class I_List<i_string_pair>;\ntemplate class I_List<Statement>;\ntemplate class I_List_iterator<Statement>;\n#endif\n\n"], "filenames": ["include/my_sys.h", "mysys/my_redel.c", "mysys/my_static.c", "sql/mysqld.cc"], "buggy_code_start_loc": [2, 1, 101, 3457], "buggy_code_end_loc": [250, 53, 101, 3457], "fixing_code_start_loc": [2, 1, 102, 3458], "fixing_code_end_loc": [250, 54, 103, 3459], "type": "CWE-362", "message": "Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.", "other": {"cve": {"id": "CVE-2016-6663", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-13T21:59:00.160", "lastModified": "2019-03-05T18:23:02.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table."}, {"lang": "es", "value": "Condici\u00f3n de carrera en Oracle MySQL en versiones anteriores a 5.5.52, 5.6.x en versiones anteriores a 5.6.33, 5.7.x en versiones anteriores a 5.7.15 y 8.x en versiones anteriores a 8.0.1; MariaDB en versiones anteriores a 5.5.52, 10.0.x en versiones anteriores a 10.0.28 y 10.1.x en versiones anteriores a 10.1.18; Percona Server en versiones anteriores a 5.5.51-38.2, 5.6.x en versiones anteriores a 5.6.32-78-1 y 5.7.x en versiones anteriores a 5.7.14-8 y Percona XtraDB Cluster en versiones anteriores a 5.5.41-37.0, 5.6.x en versiones anteriores a 5.6.32-25.17 y 5.7.x en versiones anteriores a 5.7.14-26.17 permite a usuarios locales con ciertos permisos obtener privilegios aprovechando el uso de my_copystat por REPAIR TABLE para reparar una tabla MyISAM."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5.0", "versionEndIncluding": "5.5.52", "matchCriteriaId": "982457CB-92BD-4CC2-A377-8AE7C44AE939"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6.0", "versionEndIncluding": "5.6.33", "matchCriteriaId": "6663D88B-4649-4910-A5FB-C384BC4C8AA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.7.0", "versionEndIncluding": "5.7.15", "matchCriteriaId": "4D0BA40E-DDBD-4419-8DED-39FEF868B737"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:percona:percona_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5", "versionEndExcluding": "5.5.51-38.2", "matchCriteriaId": "60C8B060-E593-4D21-AB7D-DD5C287B315A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:percona:percona_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6", "versionEndExcluding": "5.6.32-78.1", "matchCriteriaId": "93C4414B-CF0F-483D-AC22-8CA91ADDD822"}, {"vulnerable": true, "criteria": "cpe:2.3:a:percona:percona_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.7", "versionEndExcluding": "5.7.14-8", "matchCriteriaId": "28204957-5E37-4E3A-B2BC-A01A9DD784C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:percona:xtradb_cluster:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5", "versionEndExcluding": "5.5.41-37.0", "matchCriteriaId": "84A27E79-2719-430A-8F24-1E39E59149A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:percona:xtradb_cluster:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6", "versionEndExcluding": "5.6.32-25.17", "matchCriteriaId": "61EA03ED-0F66-4C3F-967B-8B6288DB3F46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:percona:xtradb_cluster:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.7", "versionEndExcluding": "5.7.14-26.17", "matchCriteriaId": "F746563B-6F42-4539-8036-D740651AF959"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5.20", "versionEndExcluding": "5.5.52", "matchCriteriaId": "207E36F9-63DA-41F4-8C54-D69F286D9B87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0.0", "versionEndExcluding": "10.0.28", "matchCriteriaId": "B4C9A810-E03B-40D5-9B47-EFD7891283AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.1.0", "versionEndExcluding": "10.1.18", "matchCriteriaId": "B117F6E2-0BD3-4D6A-B69C-C26BF5BBA86D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4F99BB0-CB87-4CBA-86F0-D27F050F1FA2"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2016-2130.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2131.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2595.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2749.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2927.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2928.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0184.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2016/Nov/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/25/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2016-2881722.html", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/92911", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/93614", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://dev.mysql.com/doc/relnotes/mysql/5.5/en/news-5-5-52.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://dev.mysql.com/doc/relnotes/mysql/5.6/en/news-5-6-33.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-15.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://dev.mysql.com/doc/relnotes/mysql/8.0/en/news-8-0-1.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/MariaDB/server/commit/347eeefbfc658c8531878218487d729f4e020805", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://mariadb.com/kb/en/mariadb/mariadb-10028-release-notes/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://mariadb.com/kb/en/mariadb/mariadb-10118-release-notes/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://mariadb.com/kb/en/mariadb/mariadb-5552-release-notes/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.exploit-db.com/exploits/40678/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.percona.com/blog/2016/11/02/percona-responds-to-cve-2016-6663-and-cve-2016-6664/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/MariaDB/server/commit/347eeefbfc658c8531878218487d729f4e020805"}}