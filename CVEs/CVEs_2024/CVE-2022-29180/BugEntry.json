{"buggy_code": ["package server\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\tcharmfs \"github.com/charmbracelet/charm/fs\"\n\tcharm \"github.com/charmbracelet/charm/proto\"\n\t\"github.com/charmbracelet/charm/server/db\"\n\t\"github.com/charmbracelet/charm/server/storage\"\n\t\"github.com/meowgorithm/babylogger\"\n\t\"goji.io\"\n\t\"goji.io/pat\"\n\t\"goji.io/pattern\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"gopkg.in/square/go-jose.v2\"\n)\n\nconst resultsPerPage = 50\n\n// HTTPServer is the HTTP server for the Charm Cloud backend.\ntype HTTPServer struct {\n\tdb         db.DB\n\tfstore     storage.FileStore\n\tcfg        *Config\n\tserver     *http.Server\n\thealth     *http.Server\n\thttpScheme string\n}\n\ntype providerJSON struct {\n\tIssuer      string   `json:\"issuer\"`\n\tAuthURL     string   `json:\"authorization_endpoint\"`\n\tTokenURL    string   `json:\"token_endpoint\"`\n\tJWKSURL     string   `json:\"jwks_uri\"`\n\tUserInfoURL string   `json:\"userinfo_endpoint\"`\n\tAlgorithms  []string `json:\"id_token_signing_alg_values_supported\"`\n}\n\n// NewHTTPServer returns a new *HTTPServer with the specified Config.\nfunc NewHTTPServer(cfg *Config) (*HTTPServer, error) {\n\thealthMux := http.NewServeMux()\n\t// No auth health check endpoint\n\thealthMux.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"We live!\")\n\t}))\n\thealth := &http.Server{\n\t\tAddr:     fmt.Sprintf(\"%s:%d\", cfg.BindAddr, cfg.HealthPort),\n\t\tHandler:  healthMux,\n\t\tErrorLog: cfg.errorLog,\n\t}\n\tmux := goji.NewMux()\n\ts := &HTTPServer{\n\t\tcfg:        cfg,\n\t\thealth:     health,\n\t\thttpScheme: \"http\",\n\t}\n\ts.server = &http.Server{\n\t\tAddr:     fmt.Sprintf(\"%s:%d\", s.cfg.BindAddr, s.cfg.HTTPPort),\n\t\tHandler:  mux,\n\t\tErrorLog: s.cfg.errorLog,\n\t}\n\tif cfg.UseTLS {\n\t\ts.httpScheme = \"https\"\n\t\ts.health.TLSConfig = s.cfg.tlsConfig\n\t\ts.server.TLSConfig = s.cfg.tlsConfig\n\t}\n\n\tjwtMiddleware, err := JWTMiddleware(\n\t\tcfg.jwtKeyPair.JWK.Public(),\n\t\tcfg.httpURL().String(),\n\t\t[]string{\"charm\"},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmux.Use(babylogger.Middleware)\n\tmux.Use(PublicPrefixesMiddleware([]string{\"/v1/public/\", \"/.well-known/\"}))\n\tmux.Use(jwtMiddleware)\n\tmux.Use(CharmUserMiddleware(s))\n\tmux.Use(RequestLimitMiddleware())\n\tmux.HandleFunc(pat.Get(\"/v1/id/:id\"), s.handleGetUserByID)\n\tmux.HandleFunc(pat.Get(\"/v1/bio/:name\"), s.handleGetUser)\n\tmux.HandleFunc(pat.Post(\"/v1/bio\"), s.handlePostUser)\n\tmux.HandleFunc(pat.Post(\"/v1/encrypt-key\"), s.handlePostEncryptKey)\n\tmux.HandleFunc(pat.Get(\"/v1/fs/*\"), s.handleGetFile)\n\tmux.HandleFunc(pat.Post(\"/v1/fs/*\"), s.handlePostFile)\n\tmux.HandleFunc(pat.Delete(\"/v1/fs/*\"), s.handleDeleteFile)\n\tmux.HandleFunc(pat.Get(\"/v1/seq/:name\"), s.handleGetSeq)\n\tmux.HandleFunc(pat.Post(\"/v1/seq/:name\"), s.handlePostSeq)\n\tmux.HandleFunc(pat.Get(\"/v1/news\"), s.handleGetNewsList)\n\tmux.HandleFunc(pat.Get(\"/v1/news/:id\"), s.handleGetNews)\n\tmux.HandleFunc(pat.Get(\"/v1/public/jwks\"), s.handleJWKS)\n\tmux.HandleFunc(pat.Get(\"/.well-known/openid-configuration\"), s.handleOpenIDConfig)\n\ts.db = cfg.DB\n\ts.fstore = cfg.FileStore\n\treturn s, nil\n}\n\n// Start start the HTTP and health servers on the ports specified in the Config.\nfunc (s *HTTPServer) Start() error {\n\tscheme := strings.ToUpper(s.httpScheme)\n\terrg, _ := errgroup.WithContext(context.Background())\n\terrg.Go(func() error {\n\t\tlog.Printf(\"Starting %s health server on: %s\", scheme, s.health.Addr)\n\t\tif s.cfg.UseTLS {\n\t\t\terr := s.health.ListenAndServeTLS(s.cfg.TLSCertFile, s.cfg.TLSKeyFile)\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\terr := s.health.ListenAndServe()\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\terrg.Go(func() error {\n\t\tlog.Printf(\"Starting %s server on: %s\", scheme, s.server.Addr)\n\t\tif s.cfg.UseTLS {\n\t\t\terr := s.server.ListenAndServeTLS(s.cfg.TLSCertFile, s.cfg.TLSKeyFile)\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\terr := s.server.ListenAndServe()\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn errg.Wait()\n}\n\n// Shutdown gracefully shut down the HTTP and health servers.\nfunc (s *HTTPServer) Shutdown(ctx context.Context) error {\n\tscheme := strings.ToUpper(s.httpScheme)\n\tlog.Printf(\"Stopping %s server on %s\", scheme, s.server.Addr)\n\tlog.Printf(\"Stopping %s health server on %s\", scheme, s.health.Addr)\n\tif err := s.health.Shutdown(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn s.server.Shutdown(ctx)\n}\n\nfunc (s *HTTPServer) renderError(w http.ResponseWriter) {\n\ts.renderCustomError(w, \"internal error\", http.StatusInternalServerError)\n}\n\nfunc (s *HTTPServer) renderCustomError(w http.ResponseWriter, msg string, status int) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(status)\n\t_ = json.NewEncoder(w).Encode(charm.Message{Message: msg})\n}\n\nfunc (s *HTTPServer) handleJWKS(w http.ResponseWriter, r *http.Request) {\n\tjwks := jose.JSONWebKeySet{Keys: []jose.JSONWebKey{s.cfg.jwtKeyPair.JWK.Public()}}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t_ = json.NewEncoder(w).Encode(jwks)\n}\n\nfunc (s *HTTPServer) handleOpenIDConfig(w http.ResponseWriter, r *http.Request) {\n\tpj := providerJSON{JWKSURL: fmt.Sprintf(\"%s/v1/public/jwks\", s.cfg.httpURL())}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t_ = json.NewEncoder(w).Encode(pj)\n}\n\n// TODO do we need this since you can only get the authed user?\nfunc (s *HTTPServer) handleGetUserByID(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(u)\n\ts.cfg.Stats.GetUserByID()\n}\n\n// TODO do we need this since you can only get the authed user?\nfunc (s *HTTPServer) handleGetUser(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(u)\n\ts.cfg.Stats.GetUser()\n}\n\nfunc (s *HTTPServer) handlePostUser(w http.ResponseWriter, r *http.Request) {\n\tid, err := charmIDFromRequest(r)\n\tif err != nil {\n\t\tlog.Printf(\"cannot read request body: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tu := &charm.User{}\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Printf(\"cannot read request body: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\terr = json.Unmarshal(body, u)\n\tif err != nil {\n\t\tlog.Printf(\"cannot decode user json: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tnu, err := s.db.SetUserName(id, u.Name)\n\tif err == charm.ErrNameTaken {\n\t\ts.renderCustomError(w, fmt.Sprintf(\"username '%s' already taken\", u.Name), http.StatusConflict)\n\t} else if err != nil {\n\t\tlog.Printf(\"cannot set user name: %s\", err)\n\t\ts.renderError(w)\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(nu)\n\ts.cfg.Stats.SetUserName()\n}\n\nfunc (s *HTTPServer) handlePostEncryptKey(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tek := &charm.EncryptKey{}\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Printf(\"cannot read request body: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\terr = json.Unmarshal(body, ek)\n\tif err != nil {\n\t\tlog.Printf(\"cannot decode encrypt key json: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\terr = s.db.AddEncryptKeyForPublicKey(u, ek.PublicKey, ek.ID, ek.Key, ek.CreatedAt)\n\tif err != nil {\n\t\tlog.Printf(\"cannot add encrypt key: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\ts.cfg.Stats.SetUserName()\n}\n\nfunc (s *HTTPServer) handleGetSeq(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tname := pat.Param(r, \"name\")\n\tseq, err := s.db.GetSeq(u, name)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get seq: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(&charm.SeqMsg{Seq: seq})\n}\n\nfunc (s *HTTPServer) handlePostSeq(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tname := pat.Param(r, \"name\")\n\tseq, err := s.db.NextSeq(u, name)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get next seq: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(&charm.SeqMsg{Seq: seq})\n}\n\nfunc (s *HTTPServer) handlePostFile(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tpath := pattern.Path(r.Context())\n\tms := r.URL.Query().Get(\"mode\")\n\tm, err := strconv.ParseUint(ms, 10, 32)\n\tif err != nil {\n\t\tlog.Printf(\"file mode not a number: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tf, fh, err := r.FormFile(\"data\")\n\tif err != nil {\n\t\tlog.Printf(\"cannot parse form data: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tdefer f.Close() // nolint:errcheck\n\tif s.cfg.UserMaxStorage > 0 {\n\t\tstat, err := s.cfg.FileStore.Stat(u.CharmID, \"\")\n\t\tif err != nil {\n\t\t\tlog.Printf(\"cannot stat user storage: %s\", err)\n\t\t\ts.renderError(w)\n\t\t\treturn\n\t\t}\n\t\tif stat.Size()+fh.Size > s.cfg.UserMaxStorage {\n\t\t\ts.renderCustomError(w, \"user storage limit exceeded\", http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t}\n\terr = s.cfg.FileStore.Put(u.CharmID, path, f, fs.FileMode(m))\n\tif err != nil {\n\t\tlog.Printf(\"cannot post file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n}\n\nfunc (s *HTTPServer) handleGetFile(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tpath := pattern.Path(r.Context())\n\tf, err := s.cfg.FileStore.Get(u.CharmID, path)\n\tif errors.Is(err, fs.ErrNotExist) {\n\t\ts.renderCustomError(w, \"file not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tif err != nil {\n\t\tlog.Printf(\"cannot get file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tdefer f.Close() // nolint:errcheck\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tlog.Printf(\"cannot get file info: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\n\tswitch f.(type) {\n\tcase *charmfs.DirFile:\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tdefault:\n\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\tw.Header().Set(\"Last-Modified\", fi.ModTime().Format(http.TimeFormat))\n\t}\n\tw.Header().Set(\"X-File-Mode\", fmt.Sprintf(\"%d\", fi.Mode()))\n\t_, err = io.Copy(w, f)\n\tif err != nil {\n\t\tlog.Printf(\"cannot copy file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n}\n\nfunc (s *HTTPServer) handleDeleteFile(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tpath := pattern.Path(r.Context())\n\terr := s.cfg.FileStore.Delete(u.CharmID, path)\n\tif err != nil {\n\t\tlog.Printf(\"cannot delete file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n}\n\nfunc (s *HTTPServer) handleGetNewsList(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tp := r.FormValue(\"page\")\n\tif p == \"\" {\n\t\tp = \"1\"\n\t}\n\tpage, err := strconv.Atoi(p)\n\tif err != nil {\n\t\tlog.Printf(\"page not a number: %s\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\toffset := (page - 1) * resultsPerPage\n\ttag := r.FormValue(\"tag\")\n\tif tag == \"\" {\n\t\ttag = \"server\"\n\t}\n\tns, err := s.db.GetNewsList(tag, offset)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get news: %s\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\t_ = json.NewEncoder(w).Encode(ns)\n\ts.cfg.Stats.GetNews()\n}\n\nfunc (s *HTTPServer) handleGetNews(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tid := pat.Param(r, \"id\")\n\tnews, err := s.db.GetNews(id)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get news markdown: %s\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\t_ = json.NewEncoder(w).Encode(news)\n\ts.cfg.Stats.GetNews()\n}\n\nfunc (s *HTTPServer) charmUserFromRequest(w http.ResponseWriter, r *http.Request) *charm.User {\n\tu := r.Context().Value(ctxUserKey)\n\tif u == nil {\n\t\tlog.Printf(\"could not assign user to request context\")\n\t\ts.renderError(w)\n\t}\n\treturn u.(*charm.User)\n}\n"], "fixing_code": ["package server\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\tcharmfs \"github.com/charmbracelet/charm/fs\"\n\tcharm \"github.com/charmbracelet/charm/proto\"\n\t\"github.com/charmbracelet/charm/server/db\"\n\t\"github.com/charmbracelet/charm/server/storage\"\n\t\"github.com/meowgorithm/babylogger\"\n\t\"goji.io\"\n\t\"goji.io/pat\"\n\t\"goji.io/pattern\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"gopkg.in/square/go-jose.v2\"\n)\n\nconst resultsPerPage = 50\n\n// HTTPServer is the HTTP server for the Charm Cloud backend.\ntype HTTPServer struct {\n\tdb         db.DB\n\tfstore     storage.FileStore\n\tcfg        *Config\n\tserver     *http.Server\n\thealth     *http.Server\n\thttpScheme string\n}\n\ntype providerJSON struct {\n\tIssuer      string   `json:\"issuer\"`\n\tAuthURL     string   `json:\"authorization_endpoint\"`\n\tTokenURL    string   `json:\"token_endpoint\"`\n\tJWKSURL     string   `json:\"jwks_uri\"`\n\tUserInfoURL string   `json:\"userinfo_endpoint\"`\n\tAlgorithms  []string `json:\"id_token_signing_alg_values_supported\"`\n}\n\n// NewHTTPServer returns a new *HTTPServer with the specified Config.\nfunc NewHTTPServer(cfg *Config) (*HTTPServer, error) {\n\thealthMux := http.NewServeMux()\n\t// No auth health check endpoint\n\thealthMux.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"We live!\")\n\t}))\n\thealth := &http.Server{\n\t\tAddr:     fmt.Sprintf(\"%s:%d\", cfg.BindAddr, cfg.HealthPort),\n\t\tHandler:  healthMux,\n\t\tErrorLog: cfg.errorLog,\n\t}\n\tmux := goji.NewMux()\n\ts := &HTTPServer{\n\t\tcfg:        cfg,\n\t\thealth:     health,\n\t\thttpScheme: \"http\",\n\t}\n\ts.server = &http.Server{\n\t\tAddr:     fmt.Sprintf(\"%s:%d\", s.cfg.BindAddr, s.cfg.HTTPPort),\n\t\tHandler:  mux,\n\t\tErrorLog: s.cfg.errorLog,\n\t}\n\tif cfg.UseTLS {\n\t\ts.httpScheme = \"https\"\n\t\ts.health.TLSConfig = s.cfg.tlsConfig\n\t\ts.server.TLSConfig = s.cfg.tlsConfig\n\t}\n\n\tjwtMiddleware, err := JWTMiddleware(\n\t\tcfg.jwtKeyPair.JWK.Public(),\n\t\tcfg.httpURL().String(),\n\t\t[]string{\"charm\"},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmux.Use(babylogger.Middleware)\n\tmux.Use(PublicPrefixesMiddleware([]string{\"/v1/public/\", \"/.well-known/\"}))\n\tmux.Use(jwtMiddleware)\n\tmux.Use(CharmUserMiddleware(s))\n\tmux.Use(RequestLimitMiddleware())\n\tmux.HandleFunc(pat.Get(\"/v1/id/:id\"), s.handleGetUserByID)\n\tmux.HandleFunc(pat.Get(\"/v1/bio/:name\"), s.handleGetUser)\n\tmux.HandleFunc(pat.Post(\"/v1/bio\"), s.handlePostUser)\n\tmux.HandleFunc(pat.Post(\"/v1/encrypt-key\"), s.handlePostEncryptKey)\n\tmux.HandleFunc(pat.Get(\"/v1/fs/*\"), s.handleGetFile)\n\tmux.HandleFunc(pat.Post(\"/v1/fs/*\"), s.handlePostFile)\n\tmux.HandleFunc(pat.Delete(\"/v1/fs/*\"), s.handleDeleteFile)\n\tmux.HandleFunc(pat.Get(\"/v1/seq/:name\"), s.handleGetSeq)\n\tmux.HandleFunc(pat.Post(\"/v1/seq/:name\"), s.handlePostSeq)\n\tmux.HandleFunc(pat.Get(\"/v1/news\"), s.handleGetNewsList)\n\tmux.HandleFunc(pat.Get(\"/v1/news/:id\"), s.handleGetNews)\n\tmux.HandleFunc(pat.Get(\"/v1/public/jwks\"), s.handleJWKS)\n\tmux.HandleFunc(pat.Get(\"/.well-known/openid-configuration\"), s.handleOpenIDConfig)\n\ts.db = cfg.DB\n\ts.fstore = cfg.FileStore\n\treturn s, nil\n}\n\n// Start start the HTTP and health servers on the ports specified in the Config.\nfunc (s *HTTPServer) Start() error {\n\tscheme := strings.ToUpper(s.httpScheme)\n\terrg, _ := errgroup.WithContext(context.Background())\n\terrg.Go(func() error {\n\t\tlog.Printf(\"Starting %s health server on: %s\", scheme, s.health.Addr)\n\t\tif s.cfg.UseTLS {\n\t\t\terr := s.health.ListenAndServeTLS(s.cfg.TLSCertFile, s.cfg.TLSKeyFile)\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\terr := s.health.ListenAndServe()\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\terrg.Go(func() error {\n\t\tlog.Printf(\"Starting %s server on: %s\", scheme, s.server.Addr)\n\t\tif s.cfg.UseTLS {\n\t\t\terr := s.server.ListenAndServeTLS(s.cfg.TLSCertFile, s.cfg.TLSKeyFile)\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\terr := s.server.ListenAndServe()\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn errg.Wait()\n}\n\n// Shutdown gracefully shut down the HTTP and health servers.\nfunc (s *HTTPServer) Shutdown(ctx context.Context) error {\n\tscheme := strings.ToUpper(s.httpScheme)\n\tlog.Printf(\"Stopping %s server on %s\", scheme, s.server.Addr)\n\tlog.Printf(\"Stopping %s health server on %s\", scheme, s.health.Addr)\n\tif err := s.health.Shutdown(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn s.server.Shutdown(ctx)\n}\n\nfunc (s *HTTPServer) renderError(w http.ResponseWriter) {\n\ts.renderCustomError(w, \"internal error\", http.StatusInternalServerError)\n}\n\nfunc (s *HTTPServer) renderCustomError(w http.ResponseWriter, msg string, status int) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(status)\n\t_ = json.NewEncoder(w).Encode(charm.Message{Message: msg})\n}\n\nfunc (s *HTTPServer) handleJWKS(w http.ResponseWriter, r *http.Request) {\n\tjwks := jose.JSONWebKeySet{Keys: []jose.JSONWebKey{s.cfg.jwtKeyPair.JWK.Public()}}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t_ = json.NewEncoder(w).Encode(jwks)\n}\n\nfunc (s *HTTPServer) handleOpenIDConfig(w http.ResponseWriter, r *http.Request) {\n\tpj := providerJSON{JWKSURL: fmt.Sprintf(\"%s/v1/public/jwks\", s.cfg.httpURL())}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t_ = json.NewEncoder(w).Encode(pj)\n}\n\n// TODO do we need this since you can only get the authed user?\nfunc (s *HTTPServer) handleGetUserByID(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(u)\n\ts.cfg.Stats.GetUserByID()\n}\n\n// TODO do we need this since you can only get the authed user?\nfunc (s *HTTPServer) handleGetUser(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(u)\n\ts.cfg.Stats.GetUser()\n}\n\nfunc (s *HTTPServer) handlePostUser(w http.ResponseWriter, r *http.Request) {\n\tid, err := charmIDFromRequest(r)\n\tif err != nil {\n\t\tlog.Printf(\"cannot read request body: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tu := &charm.User{}\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Printf(\"cannot read request body: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\terr = json.Unmarshal(body, u)\n\tif err != nil {\n\t\tlog.Printf(\"cannot decode user json: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tnu, err := s.db.SetUserName(id, u.Name)\n\tif err == charm.ErrNameTaken {\n\t\ts.renderCustomError(w, fmt.Sprintf(\"username '%s' already taken\", u.Name), http.StatusConflict)\n\t} else if err != nil {\n\t\tlog.Printf(\"cannot set user name: %s\", err)\n\t\ts.renderError(w)\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(nu)\n\ts.cfg.Stats.SetUserName()\n}\n\nfunc (s *HTTPServer) handlePostEncryptKey(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tek := &charm.EncryptKey{}\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Printf(\"cannot read request body: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\terr = json.Unmarshal(body, ek)\n\tif err != nil {\n\t\tlog.Printf(\"cannot decode encrypt key json: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\terr = s.db.AddEncryptKeyForPublicKey(u, ek.PublicKey, ek.ID, ek.Key, ek.CreatedAt)\n\tif err != nil {\n\t\tlog.Printf(\"cannot add encrypt key: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\ts.cfg.Stats.SetUserName()\n}\n\nfunc (s *HTTPServer) handleGetSeq(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tname := pat.Param(r, \"name\")\n\tseq, err := s.db.GetSeq(u, name)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get seq: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(&charm.SeqMsg{Seq: seq})\n}\n\nfunc (s *HTTPServer) handlePostSeq(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tname := pat.Param(r, \"name\")\n\tseq, err := s.db.NextSeq(u, name)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get next seq: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(&charm.SeqMsg{Seq: seq})\n}\n\nfunc (s *HTTPServer) handlePostFile(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tpath := filepath.Clean(pattern.Path(r.Context()))\n\tms := r.URL.Query().Get(\"mode\")\n\tm, err := strconv.ParseUint(ms, 10, 32)\n\tif err != nil {\n\t\tlog.Printf(\"file mode not a number: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tf, fh, err := r.FormFile(\"data\")\n\tif err != nil {\n\t\tlog.Printf(\"cannot parse form data: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tdefer f.Close() // nolint:errcheck\n\tif s.cfg.UserMaxStorage > 0 {\n\t\tstat, err := s.cfg.FileStore.Stat(u.CharmID, \"\")\n\t\tif err != nil {\n\t\t\tlog.Printf(\"cannot stat user storage: %s\", err)\n\t\t\ts.renderError(w)\n\t\t\treturn\n\t\t}\n\t\tif stat.Size()+fh.Size > s.cfg.UserMaxStorage {\n\t\t\ts.renderCustomError(w, \"user storage limit exceeded\", http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t}\n\terr = s.cfg.FileStore.Put(u.CharmID, path, f, fs.FileMode(m))\n\tif err != nil {\n\t\tlog.Printf(\"cannot post file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n}\n\nfunc (s *HTTPServer) handleGetFile(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tpath := filepath.Clean(pattern.Path(r.Context()))\n\tf, err := s.cfg.FileStore.Get(u.CharmID, path)\n\tif errors.Is(err, fs.ErrNotExist) {\n\t\ts.renderCustomError(w, \"file not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tif err != nil {\n\t\tlog.Printf(\"cannot get file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\tdefer f.Close() // nolint:errcheck\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tlog.Printf(\"cannot get file info: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n\n\tswitch f.(type) {\n\tcase *charmfs.DirFile:\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tdefault:\n\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\tw.Header().Set(\"Last-Modified\", fi.ModTime().Format(http.TimeFormat))\n\t}\n\tw.Header().Set(\"X-File-Mode\", fmt.Sprintf(\"%d\", fi.Mode()))\n\t_, err = io.Copy(w, f)\n\tif err != nil {\n\t\tlog.Printf(\"cannot copy file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n}\n\nfunc (s *HTTPServer) handleDeleteFile(w http.ResponseWriter, r *http.Request) {\n\tu := s.charmUserFromRequest(w, r)\n\tpath := filepath.Clean(pattern.Path(r.Context()))\n\terr := s.cfg.FileStore.Delete(u.CharmID, path)\n\tif err != nil {\n\t\tlog.Printf(\"cannot delete file: %s\", err)\n\t\ts.renderError(w)\n\t\treturn\n\t}\n}\n\nfunc (s *HTTPServer) handleGetNewsList(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tp := r.FormValue(\"page\")\n\tif p == \"\" {\n\t\tp = \"1\"\n\t}\n\tpage, err := strconv.Atoi(p)\n\tif err != nil {\n\t\tlog.Printf(\"page not a number: %s\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\toffset := (page - 1) * resultsPerPage\n\ttag := r.FormValue(\"tag\")\n\tif tag == \"\" {\n\t\ttag = \"server\"\n\t}\n\tns, err := s.db.GetNewsList(tag, offset)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get news: %s\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\t_ = json.NewEncoder(w).Encode(ns)\n\ts.cfg.Stats.GetNews()\n}\n\nfunc (s *HTTPServer) handleGetNews(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tid := pat.Param(r, \"id\")\n\tnews, err := s.db.GetNews(id)\n\tif err != nil {\n\t\tlog.Printf(\"cannot get news markdown: %s\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\t_ = json.NewEncoder(w).Encode(news)\n\ts.cfg.Stats.GetNews()\n}\n\nfunc (s *HTTPServer) charmUserFromRequest(w http.ResponseWriter, r *http.Request) *charm.User {\n\tu := r.Context().Value(ctxUserKey)\n\tif u == nil {\n\t\tlog.Printf(\"could not assign user to request context\")\n\t\ts.renderError(w)\n\t}\n\treturn u.(*charm.User)\n}\n"], "filenames": ["server/http.go"], "buggy_code_start_loc": [12], "buggy_code_end_loc": [357], "fixing_code_start_loc": [13], "fixing_code_end_loc": [358], "type": "CWE-918", "message": "A vulnerability in which attackers could forge HTTP requests to manipulate the `charm` data directory to access or delete anything on the server. This has been patched and is available in release [v0.12.1](https://github.com/charmbracelet/charm/releases/tag/v0.12.1). We recommend that all users running self-hosted `charm` instances update immediately. This vulnerability was found in-house and we haven't been notified of any potential exploiters. ### Additional notes * Encrypted user data uploaded to the Charm server is safe as Charm servers cannot decrypt user data. This includes filenames, paths, and all key-value data. * Users running the official Charm [Docker images](https://github.com/charmbracelet/charm/blob/main/docker.md) are at minimal risk because the exploit is limited to the containerized filesystem.", "other": {"cve": {"id": "CVE-2022-29180", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-07T04:15:09.090", "lastModified": "2022-05-16T18:44:07.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability in which attackers could forge HTTP requests to manipulate the `charm` data directory to access or delete anything on the server. This has been patched and is available in release [v0.12.1](https://github.com/charmbracelet/charm/releases/tag/v0.12.1). We recommend that all users running self-hosted `charm` instances update immediately. This vulnerability was found in-house and we haven't been notified of any potential exploiters. ### Additional notes * Encrypted user data uploaded to the Charm server is safe as Charm servers cannot decrypt user data. This includes filenames, paths, and all key-value data. * Users running the official Charm [Docker images](https://github.com/charmbracelet/charm/blob/main/docker.md) are at minimal risk because the exploit is limited to the containerized filesystem."}, {"lang": "es", "value": "Una vulnerabilidad en la que los atacantes pod\u00edan falsificar peticiones HTTP para manipular el directorio de datos \"charm\" para acceder o eliminar cualquier cosa en el servidor. Esto ha sido parcheado y est\u00e1 disponible en versi\u00f3n [v0.12.1](https://github.com/charmbracelet/charm/releases/tag/v0.12.1). Recomendamos a todos los usuarios que ejecuten instancias de \"charm\" autoalojadas que actualicen inmediatamente. Esta vulnerabilidad fue encontrada internamente y no hemos sido notificados de ning\u00fan potencial explotador. ### Notas adicionales ### Los datos de usuario encriptados que son subidos al servidor de Charm son seguros, ya que los servidores de Charm no pueden desencriptar los datos del usuario. Esto incluye nombres de archivos, rutas y todos los datos de valor clave. * Los usuarios que ejecutan las [im\u00e1genes Docker] oficiales de Charm (https://github.com/charmbracelet/charm/blob/main/docker.md) corren un riesgo m\u00ednimo porque la explotaci\u00f3n es limitada al sistema de archivos en contenedores"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:charm:charm:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.0", "versionEndExcluding": "0.12.1", "matchCriteriaId": "781668FA-FDA0-40F9-BE79-9F6D3AD76AB4"}]}]}], "references": [{"url": "https://github.com/charmbracelet/charm/commit/3c90668f955c7ce5ef721e4fc9faee7053232fd3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/charmbracelet/charm/security/advisories/GHSA-4wpp-w5r4-7v5v", "source": "security-advisories@github.com", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/charmbracelet/charm/commit/3c90668f955c7ce5ef721e4fc9faee7053232fd3"}}