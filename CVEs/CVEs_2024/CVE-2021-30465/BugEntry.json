{"buggy_code": ["// +build linux\n\npackage libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\n\t\"github.com/checkpoint-restore/go-criu/v5\"\n\tcriurpc \"github.com/checkpoint-restore/go-criu/v5/rpc\"\n\terrorsf \"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nconst stdioFdCount = 3\n\ntype linuxContainer struct {\n\tid                   string\n\troot                 string\n\tconfig               *configs.Config\n\tcgroupManager        cgroups.Manager\n\tintelRdtManager      intelrdt.Manager\n\tinitPath             string\n\tinitArgs             []string\n\tinitProcess          parentProcess\n\tinitProcessStartTime uint64\n\tcriuPath             string\n\tnewuidmapPath        string\n\tnewgidmapPath        string\n\tm                    sync.Mutex\n\tcriuVersion          int\n\tstate                containerState\n\tcreated              time.Time\n\tfifo                 *os.File\n}\n\n// State represents a running container's state\ntype State struct {\n\tBaseState\n\n\t// Platform specific fields below here\n\n\t// Specified if the container was started under the rootless mode.\n\t// Set to true if BaseState.Config.RootlessEUID && BaseState.Config.RootlessCgroups\n\tRootless bool `json:\"rootless\"`\n\n\t// Paths to all the container's cgroups, as returned by (*cgroups.Manager).GetPaths\n\t//\n\t// For cgroup v1, a key is cgroup subsystem name, and the value is the path\n\t// to the cgroup for this subsystem.\n\t//\n\t// For cgroup v2 unified hierarchy, a key is \"\", and the value is the unified path.\n\tCgroupPaths map[string]string `json:\"cgroup_paths\"`\n\n\t// NamespacePaths are filepaths to the container's namespaces. Key is the namespace type\n\t// with the value as the path.\n\tNamespacePaths map[configs.NamespaceType]string `json:\"namespace_paths\"`\n\n\t// Container's standard descriptors (std{in,out,err}), needed for checkpoint and restore\n\tExternalDescriptors []string `json:\"external_descriptors,omitempty\"`\n\n\t// Intel RDT \"resource control\" filesystem path\n\tIntelRdtPath string `json:\"intel_rdt_path\"`\n}\n\n// Container is a libcontainer container object.\n//\n// Each container is thread-safe within the same process. Since a container can\n// be destroyed by a separate process, any function may return that the container\n// was not found.\ntype Container interface {\n\tBaseContainer\n\n\t// Methods below here are platform specific\n\n\t// Checkpoint checkpoints the running container's state to disk using the criu(8) utility.\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tCheckpoint(criuOpts *CriuOpts) error\n\n\t// Restore restores the checkpointed container to a running state using the criu(8) utility.\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tRestore(process *Process, criuOpts *CriuOpts) error\n\n\t// If the Container state is RUNNING or CREATED, sets the Container state to PAUSING and pauses\n\t// the execution of any user processes. Asynchronously, when the container finished being paused the\n\t// state is changed to PAUSED.\n\t// If the Container state is PAUSED, do nothing.\n\t//\n\t// errors:\n\t// ContainerNotExists - Container no longer exists,\n\t// ContainerNotRunning - Container not running or created,\n\t// Systemerror - System error.\n\tPause() error\n\n\t// If the Container state is PAUSED, resumes the execution of any user processes in the\n\t// Container before setting the Container state to RUNNING.\n\t// If the Container state is RUNNING, do nothing.\n\t//\n\t// errors:\n\t// ContainerNotExists - Container no longer exists,\n\t// ContainerNotPaused - Container is not paused,\n\t// Systemerror - System error.\n\tResume() error\n\n\t// NotifyOOM returns a read-only channel signaling when the container receives an OOM notification.\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tNotifyOOM() (<-chan struct{}, error)\n\n\t// NotifyMemoryPressure returns a read-only channel signaling when the container reaches a given pressure level\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tNotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error)\n}\n\n// ID returns the container's unique ID\nfunc (c *linuxContainer) ID() string {\n\treturn c.id\n}\n\n// Config returns the container's configuration\nfunc (c *linuxContainer) Config() configs.Config {\n\treturn *c.config\n}\n\nfunc (c *linuxContainer) Status() (Status, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentStatus()\n}\n\nfunc (c *linuxContainer) State() (*State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentState()\n}\n\nfunc (c *linuxContainer) OCIState() (*specs.State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentOCIState()\n}\n\nfunc (c *linuxContainer) Processes() ([]int, error) {\n\tvar pids []int\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn pids, err\n\t}\n\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\treturn pids, nil\n\t}\n\n\tpids, err = c.cgroupManager.GetAllPids()\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"getting all container pids from cgroups\")\n\t}\n\treturn pids, nil\n}\n\nfunc (c *linuxContainer) Stats() (*Stats, error) {\n\tvar (\n\t\terr   error\n\t\tstats = &Stats{}\n\t)\n\tif stats.CgroupStats, err = c.cgroupManager.GetStats(); err != nil {\n\t\treturn stats, newSystemErrorWithCause(err, \"getting container stats from cgroups\")\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif stats.IntelRdtStats, err = c.intelRdtManager.GetStats(); err != nil {\n\t\t\treturn stats, newSystemErrorWithCause(err, \"getting container's Intel RDT stats\")\n\t\t}\n\t}\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tistats, err := getNetworkInterfaceStats(iface.HostInterfaceName)\n\t\t\tif err != nil {\n\t\t\t\treturn stats, newSystemErrorWithCausef(err, \"getting network stats for interface %q\", iface.HostInterfaceName)\n\t\t\t}\n\t\t\tstats.Interfaces = append(stats.Interfaces, istats)\n\t\t}\n\t}\n\treturn stats, nil\n}\n\nfunc (c *linuxContainer) Set(config configs.Config) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status == Stopped {\n\t\treturn newGenericError(errors.New(\"container not running\"), ContainerNotRunning)\n\t}\n\tif err := c.cgroupManager.Set(config.Cgroups.Resources); err != nil {\n\t\t// Set configs back\n\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t}\n\t\treturn err\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif err := c.intelRdtManager.Set(&config); err != nil {\n\t\t\t// Set configs back\n\t\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\tif err2 := c.intelRdtManager.Set(c.config); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back intelrdt configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\t// After config setting succeed, update config and states\n\tc.config = &config\n\t_, err = c.updateState(nil)\n\treturn err\n}\n\nfunc (c *linuxContainer) Start(process *Process) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif c.config.Cgroups.Resources.SkipDevices {\n\t\treturn newGenericError(errors.New(\"can't start container with SkipDevices set\"), ConfigInvalid)\n\t}\n\tif process.Init {\n\t\tif err := c.createExecFifo(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := c.start(process); err != nil {\n\t\tif process.Init {\n\t\t\tc.deleteExecFifo()\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Run(process *Process) error {\n\tif err := c.Start(process); err != nil {\n\t\treturn err\n\t}\n\tif process.Init {\n\t\treturn c.exec()\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Exec() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.exec()\n}\n\nfunc (c *linuxContainer) exec() error {\n\tpath := filepath.Join(c.root, execFifoFilename)\n\tpid := c.initProcess.pid()\n\tblockingFifoOpenCh := awaitFifoOpen(path)\n\tfor {\n\t\tselect {\n\t\tcase result := <-blockingFifoOpenCh:\n\t\t\treturn handleFifoResult(result)\n\n\t\tcase <-time.After(time.Millisecond * 100):\n\t\t\tstat, err := system.Stat(pid)\n\t\t\tif err != nil || stat.State == system.Zombie {\n\t\t\t\t// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.\n\t\t\t\t// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).\n\t\t\t\tif err := handleFifoResult(fifoOpen(path, false)); err != nil {\n\t\t\t\t\treturn errors.New(\"container process is already dead\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc readFromExecFifo(execFifo io.Reader) error {\n\tdata, err := ioutil.ReadAll(execFifo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) <= 0 {\n\t\treturn errors.New(\"cannot start an already running container\")\n\t}\n\treturn nil\n}\n\nfunc awaitFifoOpen(path string) <-chan openResult {\n\tfifoOpened := make(chan openResult)\n\tgo func() {\n\t\tresult := fifoOpen(path, true)\n\t\tfifoOpened <- result\n\t}()\n\treturn fifoOpened\n}\n\nfunc fifoOpen(path string, block bool) openResult {\n\tflags := os.O_RDONLY\n\tif !block {\n\t\tflags |= unix.O_NONBLOCK\n\t}\n\tf, err := os.OpenFile(path, flags, 0)\n\tif err != nil {\n\t\treturn openResult{err: newSystemErrorWithCause(err, \"open exec fifo for reading\")}\n\t}\n\treturn openResult{file: f}\n}\n\nfunc handleFifoResult(result openResult) error {\n\tif result.err != nil {\n\t\treturn result.err\n\t}\n\tf := result.file\n\tdefer f.Close()\n\tif err := readFromExecFifo(f); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(f.Name())\n}\n\ntype openResult struct {\n\tfile *os.File\n\terr  error\n}\n\nfunc (c *linuxContainer) start(process *Process) (retErr error) {\n\tparent, err := c.newParentProcess(process)\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"creating new parent process\")\n\t}\n\n\tlogsDone := parent.forwardChildLogs()\n\tif logsDone != nil {\n\t\tdefer func() {\n\t\t\t// Wait for log forwarder to finish. This depends on\n\t\t\t// runc init closing the _LIBCONTAINER_LOGPIPE log fd.\n\t\t\terr := <-logsDone\n\t\t\tif err != nil && retErr == nil {\n\t\t\t\tretErr = newSystemErrorWithCause(err, \"forwarding init logs\")\n\t\t\t}\n\t\t}()\n\t}\n\n\tif err := parent.start(); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"starting container process\")\n\t}\n\n\tif process.Init {\n\t\tc.fifo.Close()\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := c.config.Hooks[configs.Poststart].RunHooks(s); err != nil {\n\t\t\t\tif err := ignoreTerminateErrors(parent.terminate()); err != nil {\n\t\t\t\t\tlogrus.Warn(errorsf.Wrapf(err, \"Running Poststart hook\"))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Signal(s os.Signal, all bool) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif all {\n\t\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\t\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\t\treturn nil\n\t\t}\n\t\treturn signalAllProcesses(c.cgroupManager, s)\n\t}\n\t// to avoid a PID reuse attack\n\tif status == Running || status == Created || status == Paused {\n\t\tif err := c.initProcess.signal(s); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"signaling init process\")\n\t\t}\n\t\treturn nil\n\t}\n\treturn newGenericError(errors.New(\"container not running\"), ContainerNotRunning)\n}\n\nfunc (c *linuxContainer) createExecFifo() error {\n\trootuid, err := c.Config().HostRootUID()\n\tif err != nil {\n\t\treturn err\n\t}\n\trootgid, err := c.Config().HostRootGID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tif _, err := os.Stat(fifoName); err == nil {\n\t\treturn fmt.Errorf(\"exec fifo %s already exists\", fifoName)\n\t}\n\toldMask := unix.Umask(0000)\n\tif err := unix.Mkfifo(fifoName, 0622); err != nil {\n\t\tunix.Umask(oldMask)\n\t\treturn err\n\t}\n\tunix.Umask(oldMask)\n\treturn os.Chown(fifoName, rootuid, rootgid)\n}\n\nfunc (c *linuxContainer) deleteExecFifo() {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tos.Remove(fifoName)\n}\n\n// includeExecFifo opens the container's execfifo as a pathfd, so that the\n// container cannot access the statedir (and the FIFO itself remains\n// un-opened). It then adds the FifoFd to the given exec.Cmd as an inherited\n// fd, with _LIBCONTAINER_FIFOFD set to its fd number.\nfunc (c *linuxContainer) includeExecFifo(cmd *exec.Cmd) error {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tfifo, err := os.OpenFile(fifoName, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fifo = fifo\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, fifo)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_FIFOFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\treturn nil\n}\n\nfunc (c *linuxContainer) newParentProcess(p *Process) (parentProcess, error) {\n\tparentInitPipe, childInitPipe, err := utils.NewSockPair(\"init\")\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"creating new init pipe\")\n\t}\n\tmessageSockPair := filePair{parentInitPipe, childInitPipe}\n\n\tparentLogPipe, childLogPipe, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Unable to create the log pipe:  %s\", err)\n\t}\n\tlogFilePair := filePair{parentLogPipe, childLogPipe}\n\n\tcmd := c.commandTemplate(p, childInitPipe, childLogPipe)\n\tif !p.Init {\n\t\treturn c.newSetnsProcess(p, cmd, messageSockPair, logFilePair)\n\t}\n\n\t// We only set up fifoFd if we're not doing a `runc exec`. The historic\n\t// reason for this is that previously we would pass a dirfd that allowed\n\t// for container rootfs escape (and not doing it in `runc exec` avoided\n\t// that problem), but we no longer do that. However, there's no need to do\n\t// this for `runc exec` so we just keep it this way to be safe.\n\tif err := c.includeExecFifo(cmd); err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"including execfifo in cmd.Exec setup\")\n\t}\n\treturn c.newInitProcess(p, cmd, messageSockPair, logFilePair)\n}\n\nfunc (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {\n\tcmd := exec.Command(c.initPath, c.initArgs[1:]...)\n\tcmd.Args[0] = c.initArgs[0]\n\tcmd.Stdin = p.Stdin\n\tcmd.Stdout = p.Stdout\n\tcmd.Stderr = p.Stderr\n\tcmd.Dir = c.config.Rootfs\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = &unix.SysProcAttr{}\n\t}\n\tcmd.Env = append(cmd.Env, \"GOMAXPROCS=\"+os.Getenv(\"GOMAXPROCS\"))\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n\tif p.ConsoleSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_CONSOLE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_INITPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_STATEDIR=\"+c.root,\n\t)\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_LOGPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_LOGLEVEL=\"+p.LogLevel,\n\t)\n\n\t// NOTE: when running a container with no PID namespace and the parent process spawning the container is\n\t// PID1 the pdeathsig is being delivered to the container's init process by the kernel for some reason\n\t// even with the parent still running.\n\tif c.config.ParentDeathSignal > 0 {\n\t\tcmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal)\n\t}\n\treturn cmd\n}\n\nfunc (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n\tnsMaps := make(map[configs.NamespaceType]string)\n\tfor _, ns := range c.config.Namespaces {\n\t\tif ns.Path != \"\" {\n\t\t\tnsMaps[ns.Type] = ns.Path\n\t\t}\n\t}\n\t_, sharePidns := nsMaps[configs.NEWPID]\n\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinit := &initProcess{\n\t\tcmd:             cmd,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tintelRdtManager: c.intelRdtManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tcontainer:       c,\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tsharePidns:      sharePidns,\n\t}\n\tc.initProcess = init\n\treturn init, nil\n}\n\nfunc (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*setnsProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initSetns))\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"getting container's current state\")\n\t}\n\t// for setns process, we don't have to set cloneflags as the process namespaces\n\t// will only be set via setns syscall\n\tdata, err := c.bootstrapData(0, state.NamespacePaths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &setnsProcess{\n\t\tcmd:             cmd,\n\t\tcgroupPaths:     state.CgroupPaths,\n\t\trootlessCgroups: c.config.RootlessCgroups,\n\t\tintelRdtPath:    state.IntelRdtPath,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tinitProcessPid:  state.InitProcessPid,\n\t}, nil\n}\n\nfunc (c *linuxContainer) newInitConfig(process *Process) *initConfig {\n\tcfg := &initConfig{\n\t\tConfig:           c.config,\n\t\tArgs:             process.Args,\n\t\tEnv:              process.Env,\n\t\tUser:             process.User,\n\t\tAdditionalGroups: process.AdditionalGroups,\n\t\tCwd:              process.Cwd,\n\t\tCapabilities:     process.Capabilities,\n\t\tPassedFilesCount: len(process.ExtraFiles),\n\t\tContainerId:      c.ID(),\n\t\tNoNewPrivileges:  c.config.NoNewPrivileges,\n\t\tRootlessEUID:     c.config.RootlessEUID,\n\t\tRootlessCgroups:  c.config.RootlessCgroups,\n\t\tAppArmorProfile:  c.config.AppArmorProfile,\n\t\tProcessLabel:     c.config.ProcessLabel,\n\t\tRlimits:          c.config.Rlimits,\n\t\tCreateConsole:    process.ConsoleSocket != nil,\n\t\tConsoleWidth:     process.ConsoleWidth,\n\t\tConsoleHeight:    process.ConsoleHeight,\n\t}\n\tif process.NoNewPrivileges != nil {\n\t\tcfg.NoNewPrivileges = *process.NoNewPrivileges\n\t}\n\tif process.AppArmorProfile != \"\" {\n\t\tcfg.AppArmorProfile = process.AppArmorProfile\n\t}\n\tif process.Label != \"\" {\n\t\tcfg.ProcessLabel = process.Label\n\t}\n\tif len(process.Rlimits) > 0 {\n\t\tcfg.Rlimits = process.Rlimits\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tcfg.Cgroup2Path = c.cgroupManager.Path(\"\")\n\t}\n\n\treturn cfg\n}\n\nfunc (c *linuxContainer) Destroy() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.state.destroy()\n}\n\nfunc (c *linuxContainer) Pause() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch status {\n\tcase Running, Created:\n\t\tif err := c.cgroupManager.Freeze(configs.Frozen); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.state.transition(&pausedState{\n\t\t\tc: c,\n\t\t})\n\t}\n\treturn newGenericError(fmt.Errorf(\"container not running or created: %s\", status), ContainerNotRunning)\n}\n\nfunc (c *linuxContainer) Resume() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status != Paused {\n\t\treturn newGenericError(fmt.Errorf(\"container not paused\"), ContainerNotPaused)\n\t}\n\tif err := c.cgroupManager.Freeze(configs.Thawed); err != nil {\n\t\treturn err\n\t}\n\treturn c.state.transition(&runningState{\n\t\tc: c,\n\t})\n}\n\nfunc (c *linuxContainer) NotifyOOM() (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting OOM notifications may fail if you don't have the full access to cgroups\")\n\t}\n\tpath := c.cgroupManager.Path(\"memory\")\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn notifyOnOOMV2(path)\n\t}\n\treturn notifyOnOOM(path)\n}\n\nfunc (c *linuxContainer) NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting memory pressure notifications may fail if you don't have the full access to cgroups\")\n\t}\n\treturn notifyMemoryPressure(c.cgroupManager.Path(\"memory\"), level)\n}\n\nvar criuFeatures *criurpc.CriuFeatures\n\nfunc (c *linuxContainer) checkCriuFeatures(criuOpts *CriuOpts, rpcOpts *criurpc.CriuOpts, criuFeat *criurpc.CriuFeatures) error {\n\n\tt := criurpc.CriuReqType_FEATURE_CHECK\n\n\t// make sure the features we are looking for are really not from\n\t// some previous check\n\tcriuFeatures = nil\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\t// Theoretically this should not be necessary but CRIU\n\t\t// segfaults if Opts is empty.\n\t\t// Fixed in CRIU  2.12\n\t\tOpts:     rpcOpts,\n\t\tFeatures: criuFeat,\n\t}\n\n\terr := c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\tlogrus.Debugf(\"%s\", err)\n\t\treturn errors.New(\"CRIU feature check failed\")\n\t}\n\n\tmissingFeatures := false\n\n\t// The outer if checks if the fields actually exist\n\tif (criuFeat.MemTrack != nil) &&\n\t\t(criuFeatures.MemTrack != nil) {\n\t\t// The inner if checks if they are set to true\n\t\tif *criuFeat.MemTrack && !*criuFeatures.MemTrack {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support MemTrack\")\n\t\t}\n\t}\n\n\t// This needs to be repeated for every new feature check.\n\t// Is there a way to put this in a function. Reflection?\n\tif (criuFeat.LazyPages != nil) &&\n\t\t(criuFeatures.LazyPages != nil) {\n\t\tif *criuFeat.LazyPages && !*criuFeatures.LazyPages {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support LazyPages\")\n\t\t}\n\t}\n\n\tif missingFeatures {\n\t\treturn errors.New(\"CRIU is missing features\")\n\t}\n\n\treturn nil\n}\n\nfunc compareCriuVersion(criuVersion int, minVersion int) error {\n\t// simple function to perform the actual version compare\n\tif criuVersion < minVersion {\n\t\treturn fmt.Errorf(\"CRIU version %d must be %d or higher\", criuVersion, minVersion)\n\t}\n\n\treturn nil\n}\n\n// checkCriuVersion checks Criu version greater than or equal to minVersion\nfunc (c *linuxContainer) checkCriuVersion(minVersion int) error {\n\n\t// If the version of criu has already been determined there is no need\n\t// to ask criu for the version again. Use the value from c.criuVersion.\n\tif c.criuVersion != 0 {\n\t\treturn compareCriuVersion(c.criuVersion, minVersion)\n\t}\n\n\tcriu := criu.MakeCriu()\n\tcriu.SetCriuPath(c.criuPath)\n\tvar err error\n\tc.criuVersion, err = criu.GetCriuVersion()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"CRIU version check failed: %s\", err)\n\t}\n\n\treturn compareCriuVersion(c.criuVersion, minVersion)\n}\n\nconst descriptorsFilename = \"descriptors.json\"\n\nfunc (c *linuxContainer) addCriuDumpMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(mountDest),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) addMaskPaths(req *criurpc.CriuReq) error {\n\tfor _, path := range c.config.MaskPaths {\n\t\tfi, err := os.Stat(fmt.Sprintf(\"/proc/%d/root/%s\", c.initProcess.pid(), path))\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\textMnt := &criurpc.ExtMountMap{\n\t\t\tKey: proto.String(path),\n\t\t\tVal: proto.String(\"/dev/null\"),\n\t\t}\n\t\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleCriuConfigurationFile(rpcOpts *criurpc.CriuOpts) {\n\t// CRIU will evaluate a configuration starting with release 3.11.\n\t// Settings in the configuration file will overwrite RPC settings.\n\t// Look for annotations. The annotation 'org.criu.config'\n\t// specifies if CRIU should use a different, container specific\n\t// configuration file.\n\t_, annotations := utils.Annotations(c.config.Labels)\n\tconfigFile, exists := annotations[\"org.criu.config\"]\n\tif exists {\n\t\t// If the annotation 'org.criu.config' exists and is set\n\t\t// to a non-empty string, tell CRIU to use that as a\n\t\t// configuration file. If the file does not exist, CRIU\n\t\t// will just ignore it.\n\t\tif configFile != \"\" {\n\t\t\trpcOpts.ConfigFile = proto.String(configFile)\n\t\t}\n\t\t// If 'org.criu.config' exists and is set to an empty\n\t\t// string, a runc specific CRIU configuration file will\n\t\t// be not set at all.\n\t} else {\n\t\t// If the mentioned annotation has not been found, specify\n\t\t// a default CRIU configuration file.\n\t\trpcOpts.ConfigFile = proto.String(\"/etc/criu/runc.conf\")\n\t}\n}\n\nfunc (c *linuxContainer) criuSupportsExtNS(t configs.NamespaceType) bool {\n\tvar minVersion int\n\tswitch t {\n\tcase configs.NEWNET:\n\t\t// CRIU supports different external namespace with different released CRIU versions.\n\t\t// For network namespaces to work we need at least criu 3.11.0 => 31100.\n\t\tminVersion = 31100\n\tcase configs.NEWPID:\n\t\t// For PID namespaces criu 31500 is needed.\n\t\tminVersion = 31500\n\tdefault:\n\t\treturn false\n\t}\n\treturn c.checkCriuVersion(minVersion) == nil\n}\n\nfunc criuNsToKey(t configs.NamespaceType) string {\n\treturn \"extRoot\" + strings.Title(configs.NsName(t)) + \"NS\"\n}\n\nfunc (c *linuxContainer) handleCheckpointingExternalNamespaces(rpcOpts *criurpc.CriuOpts, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU expects the information about an external namespace\n\t// like this: --external <TYPE>[<inode>]:<key>\n\t// This <key> is always 'extRoot<TYPE>NS'.\n\tvar ns unix.Stat_t\n\tif err := unix.Stat(nsPath, &ns); err != nil {\n\t\treturn err\n\t}\n\tcriuExternal := fmt.Sprintf(\"%s[%d]:%s\", configs.NsName(t), ns.Ino, criuNsToKey(t))\n\trpcOpts.External = append(rpcOpts.External, criuExternal)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File) error {\n\tfor _, ns := range c.config.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase configs.NEWNET, configs.NEWPID:\n\t\t\t// If the container is running in a network or PID namespace and has\n\t\t\t// a path to the network or PID namespace configured, we will dump\n\t\t\t// that network or PID namespace as an external namespace and we\n\t\t\t// will expect that the namespace exists during restore.\n\t\t\t// This basically means that CRIU will ignore the namespace\n\t\t\t// and expect it to be setup correctly.\n\t\t\tif err := c.handleRestoringExternalNamespaces(rpcOpts, extraFiles, ns.Type); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\t// For all other namespaces except NET and PID CRIU has\n\t\t\t// a simpler way of joining the existing namespace if set\n\t\t\tnsPath := c.config.Namespaces.PathOf(ns.Type)\n\t\t\tif nsPath == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ns.Type == configs.NEWCGROUP {\n\t\t\t\t// CRIU has no code to handle NEWCGROUP\n\t\t\t\treturn fmt.Errorf(\"Do not know how to handle namespace %v\", ns.Type)\n\t\t\t}\n\t\t\t// CRIU has code to handle NEWTIME, but it does not seem to be defined in runc\n\n\t\t\t// CRIU will issue a warning for NEWUSER:\n\t\t\t// criu/namespaces.c: 'join-ns with user-namespace is not fully tested and dangerous'\n\t\t\trpcOpts.JoinNs = append(rpcOpts.JoinNs, &criurpc.JoinNamespace{\n\t\t\t\tNs:     proto.String(configs.NsName(ns.Type)),\n\t\t\t\tNsFile: proto.String(nsPath),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringExternalNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU wants the information about an existing namespace\n\t// like this: --inherit-fd fd[<fd>]:<key>\n\t// The <key> needs to be the same as during checkpointing.\n\t// We are always using 'extRoot<TYPE>NS' as the key in this.\n\tnsFd, err := os.Open(nsPath)\n\tif err != nil {\n\t\tlogrus.Errorf(\"If a specific network namespace is defined it must exist: %s\", err)\n\t\treturn fmt.Errorf(\"Requested network namespace %v does not exist\", nsPath)\n\t}\n\tinheritFd := &criurpc.InheritFd{\n\t\tKey: proto.String(criuNsToKey(t)),\n\t\t// The offset of four is necessary because 0, 1, 2 and 3 are\n\t\t// already used by stdin, stdout, stderr, 'criu swrk' socket.\n\t\tFd: proto.Int32(int32(4 + len(*extraFiles))),\n\t}\n\trpcOpts.InheritFd = append(rpcOpts.InheritFd, inheritFd)\n\t// All open FDs need to be transferred to CRIU via extraFiles\n\t*extraFiles = append(*extraFiles, nsFd)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) Checkpoint(criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\t// Checkpoint is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU 2.0 has\n\t//               support for doing unprivileged dumps, but the setup of\n\t//               rootless containers might make this complicated.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to save checkpoint\")\n\t}\n\n\t// Since a container can be C/R'ed multiple times,\n\t// the checkpoint directory may already exist.\n\tif err := os.Mkdir(criuOpts.ImagesDirectory, 0700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\n\tif criuOpts.WorkDirectory == \"\" {\n\t\tcriuOpts.WorkDirectory = filepath.Join(c.root, \"criu.work\")\n\t}\n\n\tif err := os.Mkdir(criuOpts.WorkDirectory, 0700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\n\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer workDir.Close()\n\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\n\trpcOpts := criurpc.CriuOpts{\n\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\tWorkDirFd:       proto.Int32(int32(workDir.Fd())),\n\t\tLogLevel:        proto.Int32(4),\n\t\tLogFile:         proto.String(\"dump.log\"),\n\t\tRoot:            proto.String(c.config.Rootfs),\n\t\tManageCgroups:   proto.Bool(true),\n\t\tNotifyScripts:   proto.Bool(true),\n\t\tPid:             proto.Int32(int32(c.initProcess.pid())),\n\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\tLeaveRunning:    proto.Bool(criuOpts.LeaveRunning),\n\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\tOrphanPtsMaster: proto.Bool(true),\n\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t}\n\n\tc.handleCriuConfigurationFile(&rpcOpts)\n\n\t// If the container is running in a network namespace and has\n\t// a path to the network namespace configured, we will dump\n\t// that network namespace as an external namespace and we\n\t// will expect that the namespace exists during restore.\n\t// This basically means that CRIU will ignore the namespace\n\t// and expect to be setup correctly.\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWNET); err != nil {\n\t\treturn err\n\t}\n\n\t// Same for possible external PID namespaces\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWPID); err != nil {\n\t\treturn err\n\t}\n\n\t// CRIU can use cgroup freezer; when rpcOpts.FreezeCgroup\n\t// is not set, CRIU uses ptrace() to pause the processes.\n\t// Note cgroup v2 freezer is only supported since CRIU release 3.14.\n\tif !cgroups.IsCgroup2UnifiedMode() || c.checkCriuVersion(31400) == nil {\n\t\tif fcg := c.cgroupManager.Path(\"freezer\"); fcg != \"\" {\n\t\t\trpcOpts.FreezeCgroup = proto.String(fcg)\n\t\t}\n\t}\n\n\t// append optional criu opts, e.g., page-server and port\n\tif criuOpts.PageServer.Address != \"\" && criuOpts.PageServer.Port != 0 {\n\t\trpcOpts.Ps = &criurpc.CriuPageServerInfo{\n\t\t\tAddress: proto.String(criuOpts.PageServer.Address),\n\t\t\tPort:    proto.Int32(criuOpts.PageServer.Port),\n\t\t}\n\t}\n\n\t//pre-dump may need parentImage param to complete iterative migration\n\tif criuOpts.ParentImage != \"\" {\n\t\trpcOpts.ParentImg = proto.String(criuOpts.ParentImage)\n\t\trpcOpts.TrackMem = proto.Bool(true)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criurpc.CriuCgMode(criuOpts.ManageCgroupsMode)\n\t\trpcOpts.ManageCgroupsMode = &mode\n\t}\n\n\tvar t criurpc.CriuReqType\n\tif criuOpts.PreDump {\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tMemTrack: proto.Bool(true),\n\t\t}\n\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tt = criurpc.CriuReqType_PRE_DUMP\n\t} else {\n\t\tt = criurpc.CriuReqType_DUMP\n\t}\n\n\tif criuOpts.LazyPages {\n\t\t// lazy migration requested; check if criu supports it\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tLazyPages: proto.Bool(true),\n\t\t}\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif fd := criuOpts.StatusFd; fd != -1 {\n\t\t\t// check that the FD is valid\n\t\t\tflags, err := unix.FcntlInt(uintptr(fd), unix.F_GETFL, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: %w\", fd, err)\n\t\t\t}\n\t\t\t// and writable\n\t\t\tif flags&unix.O_WRONLY == 0 {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: not writable\", fd)\n\t\t\t}\n\n\t\t\tif c.checkCriuVersion(31500) != nil {\n\t\t\t\t// For criu 3.15+, use notifications (see case \"status-ready\"\n\t\t\t\t// in criuNotifications). Otherwise, rely on criu status fd.\n\t\t\t\trpcOpts.StatusFd = proto.Int32(int32(fd))\n\t\t\t}\n\t\t}\n\t}\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &rpcOpts,\n\t}\n\n\t// no need to dump all this in pre-dump\n\tif !criuOpts.PreDump {\n\t\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\t\tfor _, m := range c.config.Mounts {\n\t\t\tswitch m.Device {\n\t\t\tcase \"bind\":\n\t\t\t\tc.addCriuDumpMount(req, m)\n\t\t\tcase \"cgroup\":\n\t\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\t\t// real mount(s)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// a set of \"external\" bind mounts\n\t\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfor _, b := range binds {\n\t\t\t\t\tc.addCriuDumpMount(req, b)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err := c.addMaskPaths(req); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, node := range c.config.Devices {\n\t\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\t\tc.addCriuDumpMount(req, m)\n\t\t}\n\n\t\t// Write the FD info to a file in the image directory\n\t\tfdsJSON, err := json.Marshal(c.initProcess.externalDescriptors())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = ioutil.WriteFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename), fdsJSON, 0600)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) addCriuRestoreMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(m.Source),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) restoreNetwork(req *criurpc.CriuReq, criuOpts *CriuOpts) {\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tveth := new(criurpc.CriuVethPair)\n\t\t\tveth.IfOut = proto.String(iface.HostInterfaceName)\n\t\t\tveth.IfIn = proto.String(iface.Name)\n\t\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t\tcase \"loopback\":\n\t\t\t// Do nothing\n\t\t}\n\t}\n\tfor _, i := range criuOpts.VethPairs {\n\t\tveth := new(criurpc.CriuVethPair)\n\t\tveth.IfOut = proto.String(i.HostInterfaceName)\n\t\tveth.IfIn = proto.String(i.ContainerInterfaceName)\n\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t}\n}\n\n// makeCriuRestoreMountpoints makes the actual mountpoints for the\n// restore using CRIU. This function is inspired from the code in\n// rootfs_linux.go\nfunc (c *linuxContainer) makeCriuRestoreMountpoints(m *configs.Mount) error {\n\tswitch m.Device {\n\tcase \"cgroup\":\n\t\t// No mount point(s) need to be created:\n\t\t//\n\t\t// * for v1, mount points are saved by CRIU because\n\t\t//   /sys/fs/cgroup is a tmpfs mount\n\t\t//\n\t\t// * for v2, /sys/fs/cgroup is a real mount, but\n\t\t//   the mountpoint appears as soon as /sys is mounted\n\t\treturn nil\n\tcase \"bind\":\n\t\t// The prepareBindMount() function checks if source\n\t\t// exists. So it cannot be used for other filesystem types.\n\t\tif err := prepareBindMount(m, c.config.Rootfs); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\t// for all other filesystems just create the mountpoints\n\t\tdest, err := securejoin.SecureJoin(c.config.Rootfs, m.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := checkProcMount(c.config.Rootfs, dest, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.Destination = dest\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// isPathInPrefixList is a small function for CRIU restore to make sure\n// mountpoints, which are on a tmpfs, are not created in the roofs\nfunc isPathInPrefixList(path string, prefix []string) bool {\n\tfor _, p := range prefix {\n\t\tif strings.HasPrefix(path, p+\"/\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// prepareCriuRestoreMounts tries to set up the rootfs of the\n// container to be restored in the same way runc does it for\n// initial container creation. Even for a read-only rootfs container\n// runc modifies the rootfs to add mountpoints which do not exist.\n// This function also creates missing mountpoints as long as they\n// are not on top of a tmpfs, as CRIU will restore tmpfs content anyway.\nfunc (c *linuxContainer) prepareCriuRestoreMounts(mounts []*configs.Mount) error {\n\t// First get a list of a all tmpfs mounts\n\ttmpfs := []string{}\n\tfor _, m := range mounts {\n\t\tswitch m.Device {\n\t\tcase \"tmpfs\":\n\t\t\ttmpfs = append(tmpfs, m.Destination)\n\t\t}\n\t}\n\t// Now go through all mounts and create the mountpoints\n\t// if the mountpoints are not on a tmpfs, as CRIU will\n\t// restore the complete tmpfs content from its checkpoint.\n\tumounts := []string{}\n\tdefer func() {\n\t\tfor _, u := range umounts {\n\t\t\tif e := unix.Unmount(u, unix.MNT_DETACH); e != nil {\n\t\t\t\tif e != unix.EINVAL {\n\t\t\t\t\t// Ignore EINVAL as it means 'target is not a mount point.'\n\t\t\t\t\t// It probably has already been unmounted.\n\t\t\t\t\tlogrus.Warnf(\"Error during cleanup unmounting of %q (%v)\", u, e)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tfor _, m := range mounts {\n\t\tif !isPathInPrefixList(m.Destination, tmpfs) {\n\t\t\tif err := c.makeCriuRestoreMountpoints(m); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// If the mount point is a bind mount, we need to mount\n\t\t\t// it now so that runc can create the necessary mount\n\t\t\t// points for mounts in bind mounts.\n\t\t\t// This also happens during initial container creation.\n\t\t\t// Without this CRIU restore will fail\n\t\t\t// See: https://github.com/opencontainers/runc/issues/2748\n\t\t\t// It is also not necessary to order the mount points\n\t\t\t// because during initial container creation mounts are\n\t\t\t// set up in the order they are configured.\n\t\t\tif m.Device == \"bind\" {\n\t\t\t\tif err := unix.Mount(m.Source, m.Destination, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\t\t\t\treturn errorsf.Wrapf(err, \"unable to bind mount %q to %q\", m.Source, m.Destination)\n\t\t\t\t}\n\t\t\t\tumounts = append(umounts, m.Destination)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Restore(process *Process, criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tvar extraFiles []*os.File\n\n\t// Restore is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU doesn't have\n\t//               support for unprivileged restore at the moment.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\tif criuOpts.WorkDirectory == \"\" {\n\t\tcriuOpts.WorkDirectory = filepath.Join(c.root, \"criu.work\")\n\t}\n\t// Since a container can be C/R'ed multiple times,\n\t// the work directory may already exist.\n\tif err := os.Mkdir(criuOpts.WorkDirectory, 0700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer workDir.Close()\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to restore checkpoint\")\n\t}\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\t// CRIU has a few requirements for a root directory:\n\t// * it must be a mount point\n\t// * its parent must not be overmounted\n\t// c.config.Rootfs is bind-mounted to a temporary directory\n\t// to satisfy these requirements.\n\troot := filepath.Join(c.root, \"criu-root\")\n\tif err := os.Mkdir(root, 0755); err != nil {\n\t\treturn err\n\t}\n\tdefer os.Remove(root)\n\troot, err = filepath.EvalSymlinks(root)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = unix.Mount(c.config.Rootfs, root, \"\", unix.MS_BIND|unix.MS_REC, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Unmount(root, unix.MNT_DETACH)\n\tt := criurpc.CriuReqType_RESTORE\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &criurpc.CriuOpts{\n\t\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\t\tWorkDirFd:       proto.Int32(int32(workDir.Fd())),\n\t\t\tEvasiveDevices:  proto.Bool(true),\n\t\t\tLogLevel:        proto.Int32(4),\n\t\t\tLogFile:         proto.String(\"restore.log\"),\n\t\t\tRstSibling:      proto.Bool(true),\n\t\t\tRoot:            proto.String(root),\n\t\t\tManageCgroups:   proto.Bool(true),\n\t\t\tNotifyScripts:   proto.Bool(true),\n\t\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\t\tOrphanPtsMaster: proto.Bool(true),\n\t\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t\t},\n\t}\n\n\tc.handleCriuConfigurationFile(req.Opts)\n\n\tif err := c.handleRestoringNamespaces(req.Opts, &extraFiles); err != nil {\n\t\treturn err\n\t}\n\n\t// This will modify the rootfs of the container in the same way runc\n\t// modifies the container during initial creation.\n\tif err := c.prepareCriuRestoreMounts(c.config.Mounts); err != nil {\n\t\treturn err\n\t}\n\n\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\tfor _, m := range c.config.Mounts {\n\t\tswitch m.Device {\n\t\tcase \"bind\":\n\t\t\tc.addCriuRestoreMount(req, m)\n\t\tcase \"cgroup\":\n\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// cgroup v1 is a set of bind mounts, unless cgroupns is used\n\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, b := range binds {\n\t\t\t\tc.addCriuRestoreMount(req, b)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(c.config.MaskPaths) > 0 {\n\t\tm := &configs.Mount{Destination: \"/dev/null\", Source: \"/dev/null\"}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tfor _, node := range c.config.Devices {\n\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tif criuOpts.EmptyNs&unix.CLONE_NEWNET == 0 {\n\t\tc.restoreNetwork(req, criuOpts)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criurpc.CriuCgMode(criuOpts.ManageCgroupsMode)\n\t\treq.Opts.ManageCgroupsMode = &mode\n\t}\n\n\tvar (\n\t\tfds    []string\n\t\tfdJSON []byte\n\t)\n\tif fdJSON, err = ioutil.ReadFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal(fdJSON, &fds); err != nil {\n\t\treturn err\n\t}\n\tfor i := range fds {\n\t\tif s := fds[i]; strings.Contains(s, \"pipe:\") {\n\t\t\tinheritFd := new(criurpc.InheritFd)\n\t\t\tinheritFd.Key = proto.String(s)\n\t\t\tinheritFd.Fd = proto.Int32(int32(i))\n\t\t\treq.Opts.InheritFd = append(req.Opts.InheritFd, inheritFd)\n\t\t}\n\t}\n\terr = c.criuSwrk(process, req, criuOpts, extraFiles)\n\n\t// Now that CRIU is done let's close all opened FDs CRIU needed.\n\tfor _, fd := range extraFiles {\n\t\tfd.Close()\n\t}\n\n\treturn err\n}\n\nfunc (c *linuxContainer) criuApplyCgroups(pid int, req *criurpc.CriuReq) error {\n\t// need to apply cgroups only on restore\n\tif req.GetType() != criurpc.CriuReqType_RESTORE {\n\t\treturn nil\n\t}\n\n\t// XXX: Do we need to deal with this case? AFAIK criu still requires root.\n\tif err := c.cgroupManager.Apply(pid); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.cgroupManager.Set(c.config.Cgroups.Resources); err != nil {\n\t\treturn newSystemError(err)\n\t}\n\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn nil\n\t}\n\t// the stuff below is cgroupv1-specific\n\n\tpath := fmt.Sprintf(\"/proc/%d/cgroup\", pid)\n\tcgroupsPaths, err := cgroups.ParseCgroupFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor c, p := range cgroupsPaths {\n\t\tcgroupRoot := &criurpc.CgroupRoot{\n\t\t\tCtrl: proto.String(c),\n\t\t\tPath: proto.String(p),\n\t\t}\n\t\treq.Opts.CgRoot = append(req.Opts.CgRoot, cgroupRoot)\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuSwrk(process *Process, req *criurpc.CriuReq, opts *CriuOpts, extraFiles []*os.File) error {\n\tfds, err := unix.Socketpair(unix.AF_LOCAL, unix.SOCK_SEQPACKET|unix.SOCK_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar logPath string\n\tif opts != nil {\n\t\tlogPath = filepath.Join(opts.WorkDirectory, req.GetOpts().GetLogFile())\n\t} else {\n\t\t// For the VERSION RPC 'opts' is set to 'nil' and therefore\n\t\t// opts.WorkDirectory does not exist. Set logPath to \"\".\n\t\tlogPath = \"\"\n\t}\n\tcriuClient := os.NewFile(uintptr(fds[0]), \"criu-transport-client\")\n\tcriuClientFileCon, err := net.FileConn(criuClient)\n\tcriuClient.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcriuClientCon := criuClientFileCon.(*net.UnixConn)\n\tdefer criuClientCon.Close()\n\n\tcriuServer := os.NewFile(uintptr(fds[1]), \"criu-transport-server\")\n\tdefer criuServer.Close()\n\n\targs := []string{\"swrk\", \"3\"}\n\tif c.criuVersion != 0 {\n\t\t// If the CRIU Version is still '0' then this is probably\n\t\t// the initial CRIU run to detect the version. Skip it.\n\t\tlogrus.Debugf(\"Using CRIU %d at: %s\", c.criuVersion, c.criuPath)\n\t}\n\tcmd := exec.Command(c.criuPath, args...)\n\tif process != nil {\n\t\tcmd.Stdin = process.Stdin\n\t\tcmd.Stdout = process.Stdout\n\t\tcmd.Stderr = process.Stderr\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, criuServer)\n\tif extraFiles != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, extraFiles...)\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\t// we close criuServer so that even if CRIU crashes or unexpectedly exits, runc will not hang.\n\tcriuServer.Close()\n\t// cmd.Process will be replaced by a restored init.\n\tcriuProcess := cmd.Process\n\n\tvar criuProcessState *os.ProcessState\n\tdefer func() {\n\t\tif criuProcessState == nil {\n\t\t\tcriuClientCon.Close()\n\t\t\t_, err := criuProcess.Wait()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"wait on criuProcess returned %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif err := c.criuApplyCgroups(criuProcess.Pid, req); err != nil {\n\t\treturn err\n\t}\n\n\tvar extFds []string\n\tif process != nil {\n\t\textFds, err = getPipeFds(criuProcess.Pid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogrus.Debugf(\"Using CRIU in %s mode\", req.GetType().String())\n\t// In the case of criurpc.CriuReqType_FEATURE_CHECK req.GetOpts()\n\t// should be empty. For older CRIU versions it still will be\n\t// available but empty. criurpc.CriuReqType_VERSION actually\n\t// has no req.GetOpts().\n\tif logrus.GetLevel() >= logrus.DebugLevel &&\n\t\t!(req.GetType() == criurpc.CriuReqType_FEATURE_CHECK ||\n\t\t\treq.GetType() == criurpc.CriuReqType_VERSION) {\n\n\t\tval := reflect.ValueOf(req.GetOpts())\n\t\tv := reflect.Indirect(val)\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tst := v.Type()\n\t\t\tname := st.Field(i).Name\n\t\t\tif 'A' <= name[0] && name[0] <= 'Z' {\n\t\t\t\tvalue := val.MethodByName(\"Get\" + name).Call([]reflect.Value{})\n\t\t\t\tlogrus.Debugf(\"CRIU option %s with value %v\", name, value[0])\n\t\t\t}\n\t\t}\n\t}\n\tdata, err := proto.Marshal(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = criuClientCon.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, 10*4096)\n\toob := make([]byte, 4096)\n\tfor {\n\t\tn, oobn, _, _, err := criuClientCon.ReadMsgUnix(buf, oob)\n\t\tif req.Opts != nil && req.Opts.StatusFd != nil {\n\t\t\t// Close status_fd as soon as we got something back from criu,\n\t\t\t// assuming it has consumed (reopened) it by this time.\n\t\t\t// Otherwise it will might be left open forever and whoever\n\t\t\t// is waiting on it will wait forever.\n\t\t\tfd := int(*req.Opts.StatusFd)\n\t\t\t_ = unix.Close(fd)\n\t\t\treq.Opts.StatusFd = nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn errors.New(\"unexpected EOF\")\n\t\t}\n\t\tif n == len(buf) {\n\t\t\treturn errors.New(\"buffer is too small\")\n\t\t}\n\n\t\tresp := new(criurpc.CriuResp)\n\t\terr = proto.Unmarshal(buf[:n], resp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !resp.GetSuccess() {\n\t\t\ttypeString := req.GetType().String()\n\t\t\treturn fmt.Errorf(\"criu failed: type %s errno %d\\nlog file: %s\", typeString, resp.GetCrErrno(), logPath)\n\t\t}\n\n\t\tt := resp.GetType()\n\t\tswitch {\n\t\tcase t == criurpc.CriuReqType_FEATURE_CHECK:\n\t\t\tlogrus.Debugf(\"Feature check says: %s\", resp)\n\t\t\tcriuFeatures = resp.GetFeatures()\n\t\tcase t == criurpc.CriuReqType_NOTIFY:\n\t\t\tif err := c.criuNotifications(resp, process, cmd, opts, extFds, oob[:oobn]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tt = criurpc.CriuReqType_NOTIFY\n\t\t\treq = &criurpc.CriuReq{\n\t\t\t\tType:          &t,\n\t\t\t\tNotifySuccess: proto.Bool(true),\n\t\t\t}\n\t\t\tdata, err = proto.Marshal(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = criuClientCon.Write(data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\tcase t == criurpc.CriuReqType_RESTORE:\n\t\tcase t == criurpc.CriuReqType_DUMP:\n\t\tcase t == criurpc.CriuReqType_PRE_DUMP:\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unable to parse the response %s\", resp.String())\n\t\t}\n\n\t\tbreak\n\t}\n\n\tcriuClientCon.CloseWrite()\n\t// cmd.Wait() waits cmd.goroutines which are used for proxying file descriptors.\n\t// Here we want to wait only the CRIU process.\n\tcriuProcessState, err = criuProcess.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// In pre-dump mode CRIU is in a loop and waits for\n\t// the final DUMP command.\n\t// The current runc pre-dump approach, however, is\n\t// start criu in PRE_DUMP once for a single pre-dump\n\t// and not the whole series of pre-dump, pre-dump, ...m, dump\n\t// If we got the message CriuReqType_PRE_DUMP it means\n\t// CRIU was successful and we need to forcefully stop CRIU\n\tif !criuProcessState.Success() && *req.Type != criurpc.CriuReqType_PRE_DUMP {\n\t\treturn fmt.Errorf(\"criu failed: %s\\nlog file: %s\", criuProcessState.String(), logPath)\n\t}\n\treturn nil\n}\n\n// block any external network activity\nfunc lockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := strategy.detach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc unlockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = strategy.attach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuNotifications(resp *criurpc.CriuResp, process *Process, cmd *exec.Cmd, opts *CriuOpts, fds []string, oob []byte) error {\n\tnotify := resp.GetNotify()\n\tif notify == nil {\n\t\treturn fmt.Errorf(\"invalid response: %s\", resp.String())\n\t}\n\tscript := notify.GetScript()\n\tlogrus.Debugf(\"notify: %s\\n\", script)\n\tswitch script {\n\tcase \"post-dump\":\n\t\tf, err := os.Create(filepath.Join(c.root, \"checkpoint\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.Close()\n\tcase \"network-unlock\":\n\t\tif err := unlockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"network-lock\":\n\t\tif err := lockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"setup-namespaces\":\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\ts.Pid = int(notify.GetPid())\n\n\t\t\tif err := c.config.Hooks[configs.Prestart].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := c.config.Hooks[configs.CreateRuntime].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"post-restore\":\n\t\tpid := notify.GetPid()\n\n\t\tp, err := os.FindProcess(int(pid))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.Process = p\n\n\t\tr, err := newRestoredProcess(cmd, fds)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprocess.ops = r\n\t\tif err := c.state.transition(&restoredState{\n\t\t\timageDir: opts.ImagesDirectory,\n\t\t\tc:        c,\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// create a timestamp indicating when the restored checkpoint was started\n\t\tc.created = time.Now().UTC()\n\t\tif _, err := c.updateState(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.Remove(filepath.Join(c.root, \"checkpoint\")); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\tlogrus.Error(err)\n\t\t\t}\n\t\t}\n\tcase \"orphan-pts-master\":\n\t\tscm, err := unix.ParseSocketControlMessage(oob)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfds, err := unix.ParseUnixRights(&scm[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmaster := os.NewFile(uintptr(fds[0]), \"orphan-pts-master\")\n\t\tdefer master.Close()\n\n\t\t// While we can access console.master, using the API is a good idea.\n\t\tif err := utils.SendFd(process.ConsoleSocket, master.Name(), master.Fd()); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"status-ready\":\n\t\tif opts.StatusFd != -1 {\n\t\t\t// write \\0 to status fd to notify that lazy page server is ready\n\t\t\t_, err := unix.Write(opts.StatusFd, []byte{0})\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"can't write \\\\0 to status fd: %v\", err)\n\t\t\t}\n\t\t\t_ = unix.Close(opts.StatusFd)\n\t\t\topts.StatusFd = -1\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) updateState(process parentProcess) (*State, error) {\n\tif process != nil {\n\t\tc.initProcess = process\n\t}\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.saveState(state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) saveState(s *State) (retErr error) {\n\ttmpFile, err := ioutil.TempFile(c.root, \"state-\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\ttmpFile.Close()\n\t\t\tos.Remove(tmpFile.Name())\n\t\t}\n\t}()\n\n\terr = utils.WriteJSON(tmpFile, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tmpFile.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstateFilePath := filepath.Join(c.root, stateFilename)\n\treturn os.Rename(tmpFile.Name(), stateFilePath)\n}\n\nfunc (c *linuxContainer) currentStatus() (Status, error) {\n\tif err := c.refreshState(); err != nil {\n\t\treturn -1, err\n\t}\n\treturn c.state.status(), nil\n}\n\n// refreshState needs to be called to verify that the current state on the\n// container is what is true.  Because consumers of libcontainer can use it\n// out of process we need to verify the container's status based on runtime\n// information and not rely on our in process info.\nfunc (c *linuxContainer) refreshState() error {\n\tpaused, err := c.isPaused()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif paused {\n\t\treturn c.state.transition(&pausedState{c: c})\n\t}\n\tt := c.runType()\n\tswitch t {\n\tcase Created:\n\t\treturn c.state.transition(&createdState{c: c})\n\tcase Running:\n\t\treturn c.state.transition(&runningState{c: c})\n\t}\n\treturn c.state.transition(&stoppedState{c: c})\n}\n\nfunc (c *linuxContainer) runType() Status {\n\tif c.initProcess == nil {\n\t\treturn Stopped\n\t}\n\tpid := c.initProcess.pid()\n\tstat, err := system.Stat(pid)\n\tif err != nil {\n\t\treturn Stopped\n\t}\n\tif stat.StartTime != c.initProcessStartTime || stat.State == system.Zombie || stat.State == system.Dead {\n\t\treturn Stopped\n\t}\n\t// We'll create exec fifo and blocking on it after container is created,\n\t// and delete it after start container.\n\tif _, err := os.Stat(filepath.Join(c.root, execFifoFilename)); err == nil {\n\t\treturn Created\n\t}\n\treturn Running\n}\n\nfunc (c *linuxContainer) isPaused() (bool, error) {\n\tstate, err := c.cgroupManager.GetFreezerState()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn state == configs.Frozen, nil\n}\n\nfunc (c *linuxContainer) currentState() (*State, error) {\n\tvar (\n\t\tstartTime           uint64\n\t\texternalDescriptors []string\n\t\tpid                 = -1\n\t)\n\tif c.initProcess != nil {\n\t\tpid = c.initProcess.pid()\n\t\tstartTime, _ = c.initProcess.startTime()\n\t\texternalDescriptors = c.initProcess.externalDescriptors()\n\t}\n\tintelRdtPath, err := intelrdt.GetIntelRdtPath(c.ID())\n\tif err != nil {\n\t\tintelRdtPath = \"\"\n\t}\n\tstate := &State{\n\t\tBaseState: BaseState{\n\t\t\tID:                   c.ID(),\n\t\t\tConfig:               *c.config,\n\t\t\tInitProcessPid:       pid,\n\t\t\tInitProcessStartTime: startTime,\n\t\t\tCreated:              c.created,\n\t\t},\n\t\tRootless:            c.config.RootlessEUID && c.config.RootlessCgroups,\n\t\tCgroupPaths:         c.cgroupManager.GetPaths(),\n\t\tIntelRdtPath:        intelRdtPath,\n\t\tNamespacePaths:      make(map[configs.NamespaceType]string),\n\t\tExternalDescriptors: externalDescriptors,\n\t}\n\tif pid > 0 {\n\t\tfor _, ns := range c.config.Namespaces {\n\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t}\n\t\tfor _, nsType := range configs.NamespaceTypes() {\n\t\t\tif !configs.IsNamespaceSupported(nsType) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := state.NamespacePaths[nsType]; !ok {\n\t\t\t\tns := configs.Namespace{Type: nsType}\n\t\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) currentOCIState() (*specs.State, error) {\n\tbundle, annotations := utils.Annotations(c.config.Labels)\n\tstate := &specs.State{\n\t\tVersion:     specs.Version,\n\t\tID:          c.ID(),\n\t\tBundle:      bundle,\n\t\tAnnotations: annotations,\n\t}\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate.Status = specs.ContainerState(status.String())\n\tif status != Stopped {\n\t\tif c.initProcess != nil {\n\t\t\tstate.Pid = c.initProcess.pid()\n\t\t}\n\t}\n\treturn state, nil\n}\n\n// orderNamespacePaths sorts namespace paths into a list of paths that we\n// can setns in order.\nfunc (c *linuxContainer) orderNamespacePaths(namespaces map[configs.NamespaceType]string) ([]string, error) {\n\tpaths := []string{}\n\tfor _, ns := range configs.NamespaceTypes() {\n\n\t\t// Remove namespaces that we don't need to join.\n\t\tif !c.config.Namespaces.Contains(ns) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif p, ok := namespaces[ns]; ok && p != \"\" {\n\t\t\t// check if the requested namespace is supported\n\t\t\tif !configs.IsNamespaceSupported(ns) {\n\t\t\t\treturn nil, newSystemError(fmt.Errorf(\"namespace %s is not supported\", ns))\n\t\t\t}\n\t\t\t// only set to join this namespace if it exists\n\t\t\tif _, err := os.Lstat(p); err != nil {\n\t\t\t\treturn nil, newSystemErrorWithCausef(err, \"running lstat on namespace path %q\", p)\n\t\t\t}\n\t\t\t// do not allow namespace path with comma as we use it to separate\n\t\t\t// the namespace paths\n\t\t\tif strings.ContainsRune(p, ',') {\n\t\t\t\treturn nil, newSystemError(fmt.Errorf(\"invalid path %s\", p))\n\t\t\t}\n\t\t\tpaths = append(paths, fmt.Sprintf(\"%s:%s\", configs.NsName(ns), p))\n\t\t}\n\n\t}\n\n\treturn paths, nil\n}\n\nfunc encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n\tdata := bytes.NewBuffer(nil)\n\tfor _, im := range idMap {\n\t\tline := fmt.Sprintf(\"%d %d %d\\n\", im.ContainerID, im.HostID, im.Size)\n\t\tif _, err := data.WriteString(line); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn data.Bytes(), nil\n}\n\n// bootstrapData encodes the necessary data in netlink binary format\n// as a io.Reader.\n// Consumer can write the data to a bootstrap program\n// such as one that uses nsenter package to bootstrap the container's\n// init process correctly, i.e. with correct namespaces, uid/gid\n// mapping etc.\nfunc (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) {\n\t// create the netlink message\n\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n\n\t// write cloneFlags\n\tr.AddData(&Int32msg{\n\t\tType:  CloneFlagsAttr,\n\t\tValue: uint32(cloneFlags),\n\t})\n\n\t// write custom namespace paths\n\tif len(nsMaps) > 0 {\n\t\tnsPaths, err := c.orderNamespacePaths(nsMaps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  NsPathsAttr,\n\t\t\tValue: []byte(strings.Join(nsPaths, \",\")),\n\t\t})\n\t}\n\n\t// write namespace paths only when we are not joining an existing user ns\n\t_, joinExistingUser := nsMaps[configs.NEWUSER]\n\tif !joinExistingUser {\n\t\t// write uid mappings\n\t\tif len(c.config.UidMappings) > 0 {\n\t\t\tif c.config.RootlessEUID && c.newuidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  UidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newuidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tb, err := encodeIDMapping(c.config.UidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  UidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t}\n\n\t\t// write gid mappings\n\t\tif len(c.config.GidMappings) > 0 {\n\t\t\tb, err := encodeIDMapping(c.config.GidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  GidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t\tif c.config.RootlessEUID && c.newgidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  GidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newgidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tif requiresRootOrMappingTool(c.config) {\n\t\t\t\tr.AddData(&Boolmsg{\n\t\t\t\t\tType:  SetgroupAttr,\n\t\t\t\t\tValue: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.config.OomScoreAdj != nil {\n\t\t// write oom_score_adj\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  OomScoreAdjAttr,\n\t\t\tValue: []byte(strconv.Itoa(*c.config.OomScoreAdj)),\n\t\t})\n\t}\n\n\t// write rootless\n\tr.AddData(&Boolmsg{\n\t\tType:  RootlessEUIDAttr,\n\t\tValue: c.config.RootlessEUID,\n\t})\n\n\treturn bytes.NewReader(r.Serialize()), nil\n}\n\n// ignoreTerminateErrors returns nil if the given err matches an error known\n// to indicate that the terminate occurred successfully or err was nil, otherwise\n// err is returned unaltered.\nfunc ignoreTerminateErrors(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// terminate() might return an error from ether Kill or Wait.\n\t// The (*Cmd).Wait documentation says: \"If the command fails to run\n\t// or doesn't complete successfully, the error is of type *ExitError\".\n\t// Filter out such errors (like \"exit status 1\" or \"signal: killed\").\n\tvar exitErr *exec.ExitError\n\tif errors.As(err, &exitErr) {\n\t\treturn nil\n\t}\n\t// TODO: use errors.Is(err, os.ErrProcessDone) here and\n\t// remove \"process already finished\" string comparison below\n\t// once go 1.16 is minimally supported version.\n\n\ts := err.Error()\n\tif strings.Contains(s, \"process already finished\") ||\n\t\tstrings.Contains(s, \"Wait was already called\") {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc requiresRootOrMappingTool(c *configs.Config) bool {\n\tgidMap := []configs.IDMap{\n\t\t{ContainerID: 0, HostID: os.Getegid(), Size: 1},\n\t}\n\treturn !reflect.DeepEqual(c.GidMappings, gidMap)\n}\n", "// +build linux\n\npackage libcontainer\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"github.com/mrunalp/fileutils\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/fs2\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/userns\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\tlibcontainerUtils \"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype mountConfig struct {\n\troot            string\n\tlabel           string\n\tcgroup2Path     string\n\trootlessCgroups bool\n\tcgroupns        bool\n}\n\n// needsSetupDev returns true if /dev needs to be set up.\nfunc needsSetupDev(config *configs.Config) bool {\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"bind\" && libcontainerUtils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// prepareRootfs sets up the devices, mount points, and filesystems for use\n// inside a new mount namespace. It doesn't set anything as ro. You must call\n// finalizeRootfs after this function to finish setting up the rootfs.\nfunc prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {\n\tconfig := iConfig.Config\n\tif err := prepareRoot(config); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"preparing rootfs\")\n\t}\n\n\tmountConfig := &mountConfig{\n\t\troot:            config.Rootfs,\n\t\tlabel:           config.MountLabel,\n\t\tcgroup2Path:     iConfig.Cgroup2Path,\n\t\trootlessCgroups: iConfig.RootlessCgroups,\n\t\tcgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),\n\t}\n\tsetupDev := needsSetupDev(config)\n\tfor _, m := range config.Mounts {\n\t\tfor _, precmd := range m.PremountCmds {\n\t\t\tif err := mountCmd(precmd); err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"running premount command\")\n\t\t\t}\n\t\t}\n\t\tif err := mountToRootfs(m, mountConfig); err != nil {\n\t\t\treturn newSystemErrorWithCausef(err, \"mounting %q to rootfs at %q\", m.Source, m.Destination)\n\t\t}\n\n\t\tfor _, postcmd := range m.PostmountCmds {\n\t\t\tif err := mountCmd(postcmd); err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"running postmount command\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif setupDev {\n\t\tif err := createDevices(config); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"creating device nodes\")\n\t\t}\n\t\tif err := setupPtmx(config); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting up ptmx\")\n\t\t}\n\t\tif err := setupDevSymlinks(config.Rootfs); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting up /dev symlinks\")\n\t\t}\n\t}\n\n\t// Signal the parent to run the pre-start hooks.\n\t// The hooks are run after the mounts are setup, but before we switch to the new\n\t// root, so that the old root is still available in the hooks for any mount\n\t// manipulations.\n\t// Note that iConfig.Cwd is not guaranteed to exist here.\n\tif err := syncParentHooks(pipe); err != nil {\n\t\treturn err\n\t}\n\n\t// The reason these operations are done here rather than in finalizeRootfs\n\t// is because the console-handling code gets quite sticky if we have to set\n\t// up the console before doing the pivot_root(2). This is because the\n\t// Console API has to also work with the ExecIn case, which means that the\n\t// API must be able to deal with being inside as well as outside the\n\t// container. It's just cleaner to do this here (at the expense of the\n\t// operation not being perfectly split).\n\n\tif err := unix.Chdir(config.Rootfs); err != nil {\n\t\treturn newSystemErrorWithCausef(err, \"changing dir to %q\", config.Rootfs)\n\t}\n\n\ts := iConfig.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreating\n\tif err := iConfig.Config.Hooks[configs.CreateContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif config.NoPivotRoot {\n\t\terr = msMoveRoot(config.Rootfs)\n\t} else if config.Namespaces.Contains(configs.NEWNS) {\n\t\terr = pivotRoot(config.Rootfs)\n\t} else {\n\t\terr = chroot()\n\t}\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"jailing process inside rootfs\")\n\t}\n\n\tif setupDev {\n\t\tif err := reOpenDevNull(); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"reopening /dev/null inside container\")\n\t\t}\n\t}\n\n\tif cwd := iConfig.Cwd; cwd != \"\" {\n\t\t// Note that spec.Process.Cwd can contain unclean value like  \"../../../../foo/bar...\".\n\t\t// However, we are safe to call MkDirAll directly because we are in the jail here.\n\t\tif err := os.MkdirAll(cwd, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// finalizeRootfs sets anything to ro if necessary. You must call\n// prepareRootfs first.\nfunc finalizeRootfs(config *configs.Config) (err error) {\n\t// remount dev as ro if specified\n\tfor _, m := range config.Mounts {\n\t\tif libcontainerUtils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\tif m.Flags&unix.MS_RDONLY == unix.MS_RDONLY {\n\t\t\t\tif err := remountReadonly(m); err != nil {\n\t\t\t\t\treturn newSystemErrorWithCausef(err, \"remounting %q as readonly\", m.Destination)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// set rootfs ( / ) as readonly\n\tif config.Readonlyfs {\n\t\tif err := setReadonly(); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting rootfs as readonly\")\n\t\t}\n\t}\n\n\tif config.Umask != nil {\n\t\tunix.Umask(int(*config.Umask))\n\t} else {\n\t\tunix.Umask(0022)\n\t}\n\treturn nil\n}\n\n// /tmp has to be mounted as private to allow MS_MOVE to work in all situations\nfunc prepareTmp(topTmpDir string) (string, error) {\n\ttmpdir, err := ioutil.TempDir(topTmpDir, \"runctop\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := unix.Mount(tmpdir, tmpdir, \"bind\", unix.MS_BIND, \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := unix.Mount(\"\", tmpdir, \"\", uintptr(unix.MS_PRIVATE), \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tmpdir, nil\n}\n\nfunc cleanupTmp(tmpdir string) error {\n\tunix.Unmount(tmpdir, 0)\n\treturn os.RemoveAll(tmpdir)\n}\n\nfunc mountCmd(cmd configs.Command) error {\n\tcommand := exec.Command(cmd.Path, cmd.Args[:]...)\n\tcommand.Env = cmd.Env\n\tcommand.Dir = cmd.Dir\n\tif out, err := command.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"%#v failed: %s: %v\", cmd, string(out), err)\n\t}\n\treturn nil\n}\n\nfunc prepareBindMount(m *configs.Mount, rootfs string) error {\n\tstat, err := os.Stat(m.Source)\n\tif err != nil {\n\t\t// error out if the source of a bind mount does not exist as we will be\n\t\t// unable to bind anything to it.\n\t\treturn err\n\t}\n\t// ensure that the destination of the bind mount is resolved of symlinks at mount time because\n\t// any previous mounts can invalidate the next mount's destination.\n\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n\t// evil stuff to try to escape the container's rootfs.\n\tvar dest string\n\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n\t\treturn err\n\t}\n\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\treturn err\n\t}\n\t// update the mount with the correct dest after symlinks are resolved.\n\tm.Destination = dest\n\tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n\tbinds, err := getCgroupMounts(m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar merged []string\n\tfor _, b := range binds {\n\t\tss := filepath.Base(b.Destination)\n\t\tif strings.Contains(ss, \",\") {\n\t\t\tmerged = append(merged, ss)\n\t\t}\n\t}\n\ttmpfs := &configs.Mount{\n\t\tSource:           \"tmpfs\",\n\t\tDevice:           \"tmpfs\",\n\t\tDestination:      m.Destination,\n\t\tFlags:            defaultMountFlags,\n\t\tData:             \"mode=755\",\n\t\tPropagationFlags: m.PropagationFlags,\n\t}\n\tif err := mountToRootfs(tmpfs, c); err != nil {\n\t\treturn err\n\t}\n\tfor _, b := range binds {\n\t\tif c.cgroupns {\n\t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n\t\t\tif err := os.MkdirAll(subsystemPath, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tflags := defaultMountFlags\n\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\t\tflags = flags | unix.MS_RDONLY\n\t\t\t}\n\t\t\tcgroupmount := &configs.Mount{\n\t\t\t\tSource:      \"cgroup\",\n\t\t\t\tDevice:      \"cgroup\", // this is actually fstype\n\t\t\t\tDestination: subsystemPath,\n\t\t\t\tFlags:       flags,\n\t\t\t\tData:        filepath.Base(subsystemPath),\n\t\t\t}\n\t\t\tif err := mountNewCgroup(cgroupmount); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := mountToRootfs(b, c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor _, mc := range merged {\n\t\tfor _, ss := range strings.Split(mc, \",\") {\n\t\t\t// symlink(2) is very dumb, it will just shove the path into\n\t\t\t// the link and doesn't do any checks or relative path\n\t\t\t// conversion. Also, don't error out if the cgroup already exists.\n\t\t\tif err := os.Symlink(mc, filepath.Join(c.root, m.Destination, ss)); err != nil && !os.IsExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n\tdest, err := securejoin.SecureJoin(c.root, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Mount(m.Source, dest, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n\t\tif err == unix.EPERM || err == unix.EBUSY {\n\t\t\tsrc := fs2.UnifiedMountpoint\n\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n\t\t\t\t// Emulate cgroupns by bind-mounting\n\t\t\t\t// the container cgroup path rather than\n\t\t\t\t// the whole /sys/fs/cgroup.\n\t\t\t\tsrc = c.cgroup2Path\n\t\t\t}\n\t\t\terr = unix.Mount(src, dest, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n\t\t\tif err == unix.ENOENT && c.rootlessCgroups {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc mountToRootfs(m *configs.Mount, c *mountConfig) error {\n\trootfs := c.root\n\tmountLabel := c.label\n\tdest := m.Destination\n\tif !strings.HasPrefix(dest, rootfs) {\n\t\tdest = filepath.Join(rootfs, dest)\n\t}\n\n\tswitch m.Device {\n\tcase \"proc\", \"sysfs\":\n\t\t// If the destination already exists and is not a directory, we bail\n\t\t// out This is to avoid mounting through a symlink or similar -- which\n\t\t// has been a \"fun\" attack scenario in the past.\n\t\t// TODO: This won't be necessary once we switch to libpathrs and we can\n\t\t//       stop all of these symlink-exchange attacks.\n\t\tif fi, err := os.Lstat(dest); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if fi.Mode()&os.ModeDir == 0 {\n\t\t\treturn fmt.Errorf(\"filesystem %q must be mounted on ordinary directory\", m.Device)\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Selinux kernels do not support labeling of /proc or /sys\n\t\treturn mountPropagate(m, rootfs, \"\")\n\tcase \"mqueue\":\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn label.SetFileLabel(dest, mountLabel)\n\tcase \"tmpfs\":\n\t\tcopyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP\n\t\ttmpDir := \"\"\n\t\t// dest might be an absolute symlink, so it needs\n\t\t// to be resolved under rootfs.\n\t\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.Destination = dest\n\t\tstat, err := os.Stat(dest)\n\t\tif err != nil {\n\t\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif copyUp {\n\t\t\ttmpdir, err := prepareTmp(\"/tmp\")\n\t\t\tif err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to setup tmpdir\")\n\t\t\t}\n\t\t\tdefer cleanupTmp(tmpdir)\n\t\t\ttmpDir, err = ioutil.TempDir(tmpdir, \"runctmpdir\")\n\t\t\tif err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to create tmpdir\")\n\t\t\t}\n\t\t\tdefer os.RemoveAll(tmpDir)\n\t\t\tm.Destination = tmpDir\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, mountLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif copyUp {\n\t\t\tif err := fileutils.CopyDirectory(dest, tmpDir); err != nil {\n\t\t\t\terrMsg := fmt.Errorf(\"tmpcopyup: failed to copy %s to %s: %v\", dest, tmpDir, err)\n\t\t\t\tif err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {\n\t\t\t\t\treturn newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)\n\t\t\t\t}\n\t\t\t\treturn errMsg\n\t\t\t}\n\t\t\tif err := unix.Mount(tmpDir, dest, \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\t\t\terrMsg := fmt.Errorf(\"tmpcopyup: failed to move mount %s to %s: %v\", tmpDir, dest, err)\n\t\t\t\tif err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {\n\t\t\t\t\treturn newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)\n\t\t\t\t}\n\t\t\t\treturn errMsg\n\t\t\t}\n\t\t}\n\t\tif stat != nil {\n\t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// Initially mounted rw in mountPropagate, remount to ro if flag set.\n\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\tif err := remount(m, rootfs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\tcase \"bind\":\n\t\tif err := prepareBindMount(m, rootfs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, mountLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// bind mount won't change mount options, we need remount to make mount options effective.\n\t\t// first check that we have non-default options required before attempting a remount\n\t\tif m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {\n\t\t\t// only remount if unique mount options are set\n\t\t\tif err := remount(m, rootfs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Relabel != \"\" {\n\t\t\tif err := label.Validate(m.Relabel); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tshared := label.IsShared(m.Relabel)\n\t\t\tif err := label.Relabel(m.Source, mountLabel, shared); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"cgroup\":\n\t\tif cgroups.IsCgroup2UnifiedMode() {\n\t\t\treturn mountCgroupV2(m, c)\n\t\t}\n\t\treturn mountCgroupV1(m, c)\n\tdefault:\n\t\t// ensure that the destination of the mount is resolved of symlinks at mount time because\n\t\t// any previous mounts can invalidate the next mount's destination.\n\t\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n\t\t// evil stuff to try to escape the container's rootfs.\n\t\tvar err error\n\t\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// update the mount with the correct dest after symlinks are resolved.\n\t\tm.Destination = dest\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn mountPropagate(m, rootfs, mountLabel)\n\t}\n\treturn nil\n}\n\nfunc getCgroupMounts(m *configs.Mount) ([]*configs.Mount, error) {\n\tmounts, err := cgroups.GetCgroupMounts(false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcgroupPaths, err := cgroups.ParseCgroupFile(\"/proc/self/cgroup\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar binds []*configs.Mount\n\n\tfor _, mm := range mounts {\n\t\tdir, err := mm.GetOwnCgroup(cgroupPaths)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trelDir, err := filepath.Rel(mm.Root, dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbinds = append(binds, &configs.Mount{\n\t\t\tDevice:           \"bind\",\n\t\t\tSource:           filepath.Join(mm.Mountpoint, relDir),\n\t\t\tDestination:      filepath.Join(m.Destination, filepath.Base(mm.Mountpoint)),\n\t\t\tFlags:            unix.MS_BIND | unix.MS_REC | m.Flags,\n\t\t\tPropagationFlags: m.PropagationFlags,\n\t\t})\n\t}\n\n\treturn binds, nil\n}\n\n// checkProcMount checks to ensure that the mount destination is not over the top of /proc.\n// dest is required to be an abs path and have any symlinks resolved before calling this function.\n//\n// if source is nil, don't stat the filesystem.  This is used for restore of a checkpoint.\nfunc checkProcMount(rootfs, dest, source string) error {\n\tconst procPath = \"/proc\"\n\tpath, err := filepath.Rel(filepath.Join(rootfs, procPath), dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// pass if the mount path is located outside of /proc\n\tif strings.HasPrefix(path, \"..\") {\n\t\treturn nil\n\t}\n\tif path == \".\" {\n\t\t// an empty source is pasted on restore\n\t\tif source == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t// only allow a mount on-top of proc if it's source is \"proc\"\n\t\tisproc, err := isProc(source)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// pass if the mount is happening on top of /proc and the source of\n\t\t// the mount is a proc filesystem\n\t\tif isproc {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"%q cannot be mounted because it is not of type proc\", dest)\n\t}\n\n\t// Here dest is definitely under /proc. Do not allow those,\n\t// except for a few specific entries emulated by lxcfs.\n\tvalidProcMounts := []string{\n\t\t\"/proc/cpuinfo\",\n\t\t\"/proc/diskstats\",\n\t\t\"/proc/meminfo\",\n\t\t\"/proc/stat\",\n\t\t\"/proc/swaps\",\n\t\t\"/proc/uptime\",\n\t\t\"/proc/loadavg\",\n\t\t\"/proc/slabinfo\",\n\t\t\"/proc/net/dev\",\n\t}\n\tfor _, valid := range validProcMounts {\n\t\tpath, err := filepath.Rel(filepath.Join(rootfs, valid), dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path == \".\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%q cannot be mounted because it is inside /proc\", dest)\n}\n\nfunc isProc(path string) (bool, error) {\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn false, err\n\t}\n\treturn s.Type == unix.PROC_SUPER_MAGIC, nil\n}\n\nfunc setupDevSymlinks(rootfs string) error {\n\tvar links = [][2]string{\n\t\t{\"/proc/self/fd\", \"/dev/fd\"},\n\t\t{\"/proc/self/fd/0\", \"/dev/stdin\"},\n\t\t{\"/proc/self/fd/1\", \"/dev/stdout\"},\n\t\t{\"/proc/self/fd/2\", \"/dev/stderr\"},\n\t}\n\t// kcore support can be toggled with CONFIG_PROC_KCORE; only create a symlink\n\t// in /dev if it exists in /proc.\n\tif _, err := os.Stat(\"/proc/kcore\"); err == nil {\n\t\tlinks = append(links, [2]string{\"/proc/kcore\", \"/dev/core\"})\n\t}\n\tfor _, link := range links {\n\t\tvar (\n\t\t\tsrc = link[0]\n\t\t\tdst = filepath.Join(rootfs, link[1])\n\t\t)\n\t\tif err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {\n\t\t\treturn fmt.Errorf(\"symlink %s %s %s\", src, dst, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// If stdin, stdout, and/or stderr are pointing to `/dev/null` in the parent's rootfs\n// this method will make them point to `/dev/null` in this container's rootfs.  This\n// needs to be called after we chroot/pivot into the container's rootfs so that any\n// symlinks are resolved locally.\nfunc reOpenDevNull() error {\n\tvar stat, devNullStat unix.Stat_t\n\tfile, err := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to open /dev/null - %s\", err)\n\t}\n\tdefer file.Close()\n\tif err := unix.Fstat(int(file.Fd()), &devNullStat); err != nil {\n\t\treturn err\n\t}\n\tfor fd := 0; fd < 3; fd++ {\n\t\tif err := unix.Fstat(fd, &stat); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif stat.Rdev == devNullStat.Rdev {\n\t\t\t// Close and re-open the fd.\n\t\t\tif err := unix.Dup3(int(file.Fd()), fd, 0); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Create the device nodes in the container.\nfunc createDevices(config *configs.Config) error {\n\tuseBindMount := userns.RunningInUserNS() || config.Namespaces.Contains(configs.NEWUSER)\n\toldMask := unix.Umask(0000)\n\tfor _, node := range config.Devices {\n\n\t\t// The /dev/ptmx device is setup by setupPtmx()\n\t\tif utils.CleanPath(node.Path) == \"/dev/ptmx\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// containers running in a user namespace are not allowed to mknod\n\t\t// devices so we can just bind mount it from the host.\n\t\tif err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {\n\t\t\tunix.Umask(oldMask)\n\t\t\treturn err\n\t\t}\n\t}\n\tunix.Umask(oldMask)\n\treturn nil\n}\n\nfunc bindMountDeviceNode(dest string, node *devices.Device) error {\n\tf, err := os.Create(dest)\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tif f != nil {\n\t\tf.Close()\n\t}\n\treturn unix.Mount(node.Path, dest, \"bind\", unix.MS_BIND, \"\")\n}\n\n// Creates the device node in the rootfs of the container.\nfunc createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n\tif node.Path == \"\" {\n\t\t// The node only exists for cgroup reasons, ignore it here.\n\t\treturn nil\n\t}\n\tdest := filepath.Join(rootfs, node.Path)\n\tif err := os.MkdirAll(filepath.Dir(dest), 0755); err != nil {\n\t\treturn err\n\t}\n\tif bind {\n\t\treturn bindMountDeviceNode(dest, node)\n\t}\n\tif err := mknodDevice(dest, node); err != nil {\n\t\tif os.IsExist(err) {\n\t\t\treturn nil\n\t\t} else if os.IsPermission(err) {\n\t\t\treturn bindMountDeviceNode(dest, node)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc mknodDevice(dest string, node *devices.Device) error {\n\tfileMode := node.FileMode\n\tswitch node.Type {\n\tcase devices.BlockDevice:\n\t\tfileMode |= unix.S_IFBLK\n\tcase devices.CharDevice:\n\t\tfileMode |= unix.S_IFCHR\n\tcase devices.FifoDevice:\n\t\tfileMode |= unix.S_IFIFO\n\tdefault:\n\t\treturn fmt.Errorf(\"%c is not a valid device type for device %s\", node.Type, node.Path)\n\t}\n\tdev, err := node.Mkdev()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Mknod(dest, uint32(fileMode), int(dev)); err != nil {\n\t\treturn err\n\t}\n\treturn unix.Chown(dest, int(node.Uid), int(node.Gid))\n}\n\n// Get the parent mount point of directory passed in as argument. Also return\n// optional fields.\nfunc getParentMount(rootfs string) (string, string, error) {\n\tmi, err := mountinfo.GetMounts(mountinfo.ParentsFilter(rootfs))\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tif len(mi) < 1 {\n\t\treturn \"\", \"\", fmt.Errorf(\"could not find parent mount of %s\", rootfs)\n\t}\n\n\t// find the longest mount point\n\tvar idx, maxlen int\n\tfor i := range mi {\n\t\tif len(mi[i].Mountpoint) > maxlen {\n\t\t\tmaxlen = len(mi[i].Mountpoint)\n\t\t\tidx = i\n\t\t}\n\t}\n\treturn mi[idx].Mountpoint, mi[idx].Optional, nil\n}\n\n// Make parent mount private if it was shared\nfunc rootfsParentMountPrivate(rootfs string) error {\n\tsharedMount := false\n\n\tparentMount, optionalOpts, err := getParentMount(rootfs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toptsSplit := strings.Split(optionalOpts, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\tsharedMount = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Make parent mount PRIVATE if it was shared. It is needed for two\n\t// reasons. First of all pivot_root() will fail if parent mount is\n\t// shared. Secondly when we bind mount rootfs it will propagate to\n\t// parent namespace and we don't want that to happen.\n\tif sharedMount {\n\t\treturn unix.Mount(\"\", parentMount, \"\", unix.MS_PRIVATE, \"\")\n\t}\n\n\treturn nil\n}\n\nfunc prepareRoot(config *configs.Config) error {\n\tflag := unix.MS_SLAVE | unix.MS_REC\n\tif config.RootPropagation != 0 {\n\t\tflag = config.RootPropagation\n\t}\n\tif err := unix.Mount(\"\", \"/\", \"\", uintptr(flag), \"\"); err != nil {\n\t\treturn err\n\t}\n\n\t// Make parent mount private to make sure following bind mount does\n\t// not propagate in other namespaces. Also it will help with kernel\n\t// check pass in pivot_root. (IS_SHARED(new_mnt->mnt_parent))\n\tif err := rootfsParentMountPrivate(config.Rootfs); err != nil {\n\t\treturn err\n\t}\n\n\treturn unix.Mount(config.Rootfs, config.Rootfs, \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n}\n\nfunc setReadonly() error {\n\tflags := uintptr(unix.MS_BIND | unix.MS_REMOUNT | unix.MS_RDONLY)\n\n\terr := unix.Mount(\"\", \"/\", \"\", flags, \"\")\n\tif err == nil {\n\t\treturn nil\n\t}\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(\"/\", &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: \"/\", Err: err}\n\t}\n\tflags |= uintptr(s.Flags)\n\treturn unix.Mount(\"\", \"/\", \"\", flags, \"\")\n\n}\n\nfunc setupPtmx(config *configs.Config) error {\n\tptmx := filepath.Join(config.Rootfs, \"dev/ptmx\")\n\tif err := os.Remove(ptmx); err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\tif err := os.Symlink(\"pts/ptmx\", ptmx); err != nil {\n\t\treturn fmt.Errorf(\"symlink dev ptmx %s\", err)\n\t}\n\treturn nil\n}\n\n// pivotRoot will call pivot_root such that rootfs becomes the new root\n// filesystem, and everything else is cleaned up.\nfunc pivotRoot(rootfs string) error {\n\t// While the documentation may claim otherwise, pivot_root(\".\", \".\") is\n\t// actually valid. What this results in is / being the new root but\n\t// /proc/self/cwd being the old root. Since we can play around with the cwd\n\t// with pivot_root this allows us to pivot without creating directories in\n\t// the rootfs. Shout-outs to the LXC developers for giving us this idea.\n\n\toldroot, err := unix.Open(\"/\", unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Close(oldroot)\n\n\tnewroot, err := unix.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Close(newroot)\n\n\t// Change to the new root so that the pivot_root actually acts on it.\n\tif err := unix.Fchdir(newroot); err != nil {\n\t\treturn err\n\t}\n\n\tif err := unix.PivotRoot(\".\", \".\"); err != nil {\n\t\treturn fmt.Errorf(\"pivot_root %s\", err)\n\t}\n\n\t// Currently our \".\" is oldroot (according to the current kernel code).\n\t// However, purely for safety, we will fchdir(oldroot) since there isn't\n\t// really any guarantee from the kernel what /proc/self/cwd will be after a\n\t// pivot_root(2).\n\n\tif err := unix.Fchdir(oldroot); err != nil {\n\t\treturn err\n\t}\n\n\t// Make oldroot rslave to make sure our unmounts don't propagate to the\n\t// host (and thus bork the machine). We don't use rprivate because this is\n\t// known to cause issues due to races where we still have a reference to a\n\t// mount while a process in the host namespace are trying to operate on\n\t// something they think has no mounts (devicemapper in particular).\n\tif err := unix.Mount(\"\", \".\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\treturn err\n\t}\n\t// Preform the unmount. MNT_DETACH allows us to unmount /proc/self/cwd.\n\tif err := unix.Unmount(\".\", unix.MNT_DETACH); err != nil {\n\t\treturn err\n\t}\n\n\t// Switch back to our shiny new root.\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn fmt.Errorf(\"chdir / %s\", err)\n\t}\n\treturn nil\n}\n\nfunc msMoveRoot(rootfs string) error {\n\t// Before we move the root and chroot we have to mask all \"full\" sysfs and\n\t// procfs mounts which exist on the host. This is because while the kernel\n\t// has protections against mounting procfs if it has masks, when using\n\t// chroot(2) the *host* procfs mount is still reachable in the mount\n\t// namespace and the kernel permits procfs mounts inside --no-pivot\n\t// containers.\n\t//\n\t// Users shouldn't be using --no-pivot except in exceptional circumstances,\n\t// but to avoid such a trivial security flaw we apply a best-effort\n\t// protection here. The kernel only allows a mount of a pseudo-filesystem\n\t// like procfs or sysfs if there is a *full* mount (the root of the\n\t// filesystem is mounted) without any other locked mount points covering a\n\t// subtree of the mount.\n\t//\n\t// So we try to unmount (or mount tmpfs on top of) any mountpoint which is\n\t// a full mount of either sysfs or procfs (since those are the most\n\t// concerning filesystems to us).\n\tmountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {\n\t\t// Collect every sysfs and procfs filesystem, except for those which\n\t\t// are non-full mounts or are inside the rootfs of the container.\n\t\tif info.Root != \"/\" ||\n\t\t\t(info.FSType != \"proc\" && info.FSType != \"sysfs\") ||\n\t\t\tstrings.HasPrefix(info.Mountpoint, rootfs) {\n\t\t\tskip = true\n\t\t}\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, info := range mountinfos {\n\t\tp := info.Mountpoint\n\t\t// Be sure umount events are not propagated to the host.\n\t\tif err := unix.Mount(\"\", p, \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\t\tif err == unix.ENOENT {\n\t\t\t\t// If the mountpoint doesn't exist that means that we've\n\t\t\t\t// already blasted away some parent directory of the mountpoint\n\t\t\t\t// and so we don't care about this error.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif err := unix.Unmount(p, unix.MNT_DETACH); err != nil {\n\t\t\tif err != unix.EINVAL && err != unix.EPERM {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\t// If we have not privileges for umounting (e.g. rootless), then\n\t\t\t\t// cover the path.\n\t\t\t\tif err := unix.Mount(\"tmpfs\", p, \"tmpfs\", 0, \"\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move the rootfs on top of \"/\" in our mount namespace.\n\tif err := unix.Mount(rootfs, \"/\", \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn chroot()\n}\n\nfunc chroot() error {\n\tif err := unix.Chroot(\".\"); err != nil {\n\t\treturn err\n\t}\n\treturn unix.Chdir(\"/\")\n}\n\n// createIfNotExists creates a file or a directory only if it does not already exist.\nfunc createIfNotExists(path string, isDir bool) error {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif isDir {\n\t\t\t\treturn os.MkdirAll(path, 0755)\n\t\t\t}\n\t\t\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf, err := os.OpenFile(path, os.O_CREATE, 0755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf.Close()\n\t\t}\n\t}\n\treturn nil\n}\n\n// readonlyPath will make a path read only.\nfunc readonlyPath(path string) error {\n\tif err := unix.Mount(path, path, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn &os.PathError{Op: \"bind-mount\", Path: path, Err: err}\n\t}\n\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tflags := uintptr(s.Flags) & (unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC)\n\n\tif err := unix.Mount(path, path, \"\", flags|unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, \"\"); err != nil {\n\t\treturn &os.PathError{Op: \"bind-mount-ro\", Path: path, Err: err}\n\t}\n\n\treturn nil\n}\n\n// remountReadonly will remount an existing mount point and ensure that it is read-only.\nfunc remountReadonly(m *configs.Mount) error {\n\tvar (\n\t\tdest  = m.Destination\n\t\tflags = m.Flags\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\t// There is a special case in the kernel for\n\t\t// MS_REMOUNT | MS_BIND, which allows us to change only the\n\t\t// flags even as an unprivileged user (i.e. user namespace)\n\t\t// assuming we don't drop any security related flags (nodev,\n\t\t// nosuid, etc.). So, let's use that case so that we can do\n\t\t// this re-mount without failing in a userns.\n\t\tflags |= unix.MS_REMOUNT | unix.MS_BIND | unix.MS_RDONLY\n\t\tif err := unix.Mount(\"\", dest, \"\", uintptr(flags), \"\"); err != nil {\n\t\t\tswitch err {\n\t\t\tcase unix.EBUSY:\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unable to mount %s as readonly max retries reached\", dest)\n}\n\n// maskPath masks the top of the specified path inside a container to avoid\n// security issues from processes reading information from non-namespace aware\n// mounts ( proc/kcore ).\n// For files, maskPath bind mounts /dev/null over the top of the specified path.\n// For directories, maskPath mounts read-only tmpfs over the top of the specified path.\nfunc maskPath(path string, mountLabel string) error {\n\tif err := unix.Mount(\"/dev/null\", path, \"\", unix.MS_BIND, \"\"); err != nil && !os.IsNotExist(err) {\n\t\tif err == unix.ENOTDIR {\n\t\t\treturn unix.Mount(\"tmpfs\", path, \"tmpfs\", unix.MS_RDONLY, label.FormatMountLabel(\"\", mountLabel))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// writeSystemProperty writes the value to a path under /proc/sys as determined from the key.\n// For e.g. net.ipv4.ip_forward translated to /proc/sys/net/ipv4/ip_forward.\nfunc writeSystemProperty(key, value string) error {\n\tkeyPath := strings.Replace(key, \".\", \"/\", -1)\n\treturn ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0644)\n}\n\nfunc remount(m *configs.Mount, rootfs string) error {\n\tvar (\n\t\tdest = m.Destination\n\t)\n\tif !strings.HasPrefix(dest, rootfs) {\n\t\tdest = filepath.Join(rootfs, dest)\n\t}\n\treturn unix.Mount(m.Source, dest, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n}\n\n// Do the mount operation followed by additional mounts required to take care\n// of propagation flags.\nfunc mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {\n\tvar (\n\t\tdest  = m.Destination\n\t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n\t\tflags = m.Flags\n\t)\n\tif libcontainerUtils.CleanPath(dest) == \"/dev\" {\n\t\tflags &= ^unix.MS_RDONLY\n\t}\n\n\t// Mount it rw to allow chmod operation. A remount will be performed\n\t// later to make it ro if set.\n\tif m.Device == \"tmpfs\" {\n\t\tflags &= ^unix.MS_RDONLY\n\t}\n\n\tcopyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP\n\tif !(copyUp || strings.HasPrefix(dest, rootfs)) {\n\t\tdest = filepath.Join(rootfs, dest)\n\t}\n\n\tif err := unix.Mount(m.Source, dest, m.Device, uintptr(flags), data); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, pflag := range m.PropagationFlags {\n\t\tif err := unix.Mount(\"\", dest, \"\", uintptr(pflag), \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mountNewCgroup(m *configs.Mount) error {\n\tvar (\n\t\tdata   = m.Data\n\t\tsource = m.Source\n\t)\n\tif data == \"systemd\" {\n\t\tdata = cgroups.CgroupNamePrefix + data\n\t\tsource = \"systemd\"\n\t}\n\tif err := unix.Mount(source, m.Destination, m.Device, uintptr(m.Flags), data); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "package utils\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\texitSignalOffset = 128\n)\n\n// NativeEndian is the native byte order of the host system.\nvar NativeEndian binary.ByteOrder\n\nfunc init() {\n\t// Copied from <golang.org/x/net/internal/socket/sys.go>.\n\ti := uint32(1)\n\tb := (*[4]byte)(unsafe.Pointer(&i))\n\tif b[0] == 1 {\n\t\tNativeEndian = binary.LittleEndian\n\t} else {\n\t\tNativeEndian = binary.BigEndian\n\t}\n}\n\n// ResolveRootfs ensures that the current working directory is\n// not a symlink and returns the absolute path to the rootfs\nfunc ResolveRootfs(uncleanRootfs string) (string, error) {\n\trootfs, err := filepath.Abs(uncleanRootfs)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn filepath.EvalSymlinks(rootfs)\n}\n\n// ExitStatus returns the correct exit status for a process based on if it\n// was signaled or exited cleanly\nfunc ExitStatus(status unix.WaitStatus) int {\n\tif status.Signaled() {\n\t\treturn exitSignalOffset + int(status.Signal())\n\t}\n\treturn status.ExitStatus()\n}\n\n// WriteJSON writes the provided struct v to w using standard json marshaling\nfunc WriteJSON(w io.Writer, v interface{}) error {\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(data)\n\treturn err\n}\n\n// CleanPath makes a path safe for use with filepath.Join. This is done by not\n// only cleaning the path, but also (if the path is relative) adding a leading\n// '/' and cleaning it (then removing the leading '/'). This ensures that a\n// path resulting from prepending another path will always resolve to lexically\n// be a subdirectory of the prefixed path. This is all done lexically, so paths\n// that include symlinks won't be safe as a result of using CleanPath.\nfunc CleanPath(path string) string {\n\t// Deal with empty strings nicely.\n\tif path == \"\" {\n\t\treturn \"\"\n\t}\n\n\t// Ensure that all paths are cleaned (especially problematic ones like\n\t// \"/../../../../../\" which can cause lots of issues).\n\tpath = filepath.Clean(path)\n\n\t// If the path isn't absolute, we need to do more processing to fix paths\n\t// such as \"../../../../<etc>/some/path\". We also shouldn't convert absolute\n\t// paths to relative ones.\n\tif !filepath.IsAbs(path) {\n\t\tpath = filepath.Clean(string(os.PathSeparator) + path)\n\t\t// This can't fail, as (by definition) all paths are relative to root.\n\t\tpath, _ = filepath.Rel(string(os.PathSeparator), path)\n\t}\n\n\t// Clean the path again for good measure.\n\treturn filepath.Clean(path)\n}\n\n// SearchLabels searches a list of key-value pairs for the provided key and\n// returns the corresponding value. The pairs must be separated with '='.\nfunc SearchLabels(labels []string, query string) string {\n\tfor _, l := range labels {\n\t\tparts := strings.SplitN(l, \"=\", 2)\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif parts[0] == query {\n\t\t\treturn parts[1]\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// Annotations returns the bundle path and user defined annotations from the\n// libcontainer state.  We need to remove the bundle because that is a label\n// added by libcontainer.\nfunc Annotations(labels []string) (bundle string, userAnnotations map[string]string) {\n\tuserAnnotations = make(map[string]string)\n\tfor _, l := range labels {\n\t\tparts := strings.SplitN(l, \"=\", 2)\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif parts[0] == \"bundle\" {\n\t\t\tbundle = parts[1]\n\t\t} else {\n\t\t\tuserAnnotations[parts[0]] = parts[1]\n\t\t}\n\t}\n\treturn\n}\n", "package utils\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nvar labelTest = []struct {\n\tlabels        []string\n\tquery         string\n\texpectedValue string\n}{\n\t{[]string{\"bundle=/path/to/bundle\"}, \"bundle\", \"/path/to/bundle\"},\n\t{[]string{\"test=a\", \"test=b\"}, \"bundle\", \"\"},\n\t{[]string{\"bundle=a\", \"test=b\", \"bundle=c\"}, \"bundle\", \"a\"},\n\t{[]string{\"\", \"test=a\", \"bundle=b\"}, \"bundle\", \"b\"},\n\t{[]string{\"test\", \"bundle=a\"}, \"bundle\", \"a\"},\n\t{[]string{\"test=a\", \"bundle=\"}, \"bundle\", \"\"},\n}\n\nfunc TestSearchLabels(t *testing.T) {\n\tfor _, tt := range labelTest {\n\t\tif v := SearchLabels(tt.labels, tt.query); v != tt.expectedValue {\n\t\t\tt.Errorf(\"expected value '%s' for query '%s'; got '%s'\", tt.expectedValue, tt.query, v)\n\t\t}\n\t}\n}\n\nfunc TestResolveRootfs(t *testing.T) {\n\tdir := \"rootfs\"\n\tif err := os.Mkdir(dir, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(dir)\n\n\tpath, err := ResolveRootfs(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpwd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif path != pwd+\"/rootfs\" {\n\t\tt.Errorf(\"expected rootfs to be abs and was %s\", path)\n\t}\n}\n\nfunc TestResolveRootfsWithSymlink(t *testing.T) {\n\tdir := \"rootfs\"\n\ttmpDir, _ := filepath.EvalSymlinks(os.TempDir())\n\tif err := os.Symlink(tmpDir, dir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(dir)\n\n\tpath, err := ResolveRootfs(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif path != tmpDir {\n\t\tt.Errorf(\"expected rootfs to be the real path %s and was %s\", path, os.TempDir())\n\t}\n}\n\nfunc TestResolveRootfsWithNonExistingDir(t *testing.T) {\n\t_, err := ResolveRootfs(\"foo\")\n\tif err == nil {\n\t\tt.Error(\"expected error to happen but received nil\")\n\t}\n}\n\nfunc TestExitStatus(t *testing.T) {\n\tstatus := unix.WaitStatus(0)\n\tex := ExitStatus(status)\n\tif ex != 0 {\n\t\tt.Errorf(\"expected exit status to equal 0 and received %d\", ex)\n\t}\n}\n\nfunc TestExitStatusSignaled(t *testing.T) {\n\tstatus := unix.WaitStatus(2)\n\tex := ExitStatus(status)\n\tif ex != 130 {\n\t\tt.Errorf(\"expected exit status to equal 130 and received %d\", ex)\n\t}\n}\n\nfunc TestWriteJSON(t *testing.T) {\n\tperson := struct {\n\t\tName string\n\t\tAge  int\n\t}{\n\t\tName: \"Alice\",\n\t\tAge:  30,\n\t}\n\n\tvar b bytes.Buffer\n\terr := WriteJSON(&b, person)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := `{\"Name\":\"Alice\",\"Age\":30}`\n\tif b.String() != expected {\n\t\tt.Errorf(\"expected to write %s but was %s\", expected, b.String())\n\t}\n}\n\nfunc TestCleanPath(t *testing.T) {\n\tpath := CleanPath(\"\")\n\tif path != \"\" {\n\t\tt.Errorf(\"expected to receive empty string and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"rootfs\")\n\tif path != \"rootfs\" {\n\t\tt.Errorf(\"expected to receive 'rootfs' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"../../../var\")\n\tif path != \"var\" {\n\t\tt.Errorf(\"expected to receive 'var' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"/../../../var\")\n\tif path != \"/var\" {\n\t\tt.Errorf(\"expected to receive '/var' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"/foo/bar/\")\n\tif path != \"/foo/bar\" {\n\t\tt.Errorf(\"expected to receive '/foo/bar' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"/foo/bar/../\")\n\tif path != \"/foo\" {\n\t\tt.Errorf(\"expected to receive '/foo' and received %s\", path)\n\t}\n}\n"], "fixing_code": ["// +build linux\n\npackage libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\n\t\"github.com/checkpoint-restore/go-criu/v5\"\n\tcriurpc \"github.com/checkpoint-restore/go-criu/v5/rpc\"\n\terrorsf \"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nconst stdioFdCount = 3\n\ntype linuxContainer struct {\n\tid                   string\n\troot                 string\n\tconfig               *configs.Config\n\tcgroupManager        cgroups.Manager\n\tintelRdtManager      intelrdt.Manager\n\tinitPath             string\n\tinitArgs             []string\n\tinitProcess          parentProcess\n\tinitProcessStartTime uint64\n\tcriuPath             string\n\tnewuidmapPath        string\n\tnewgidmapPath        string\n\tm                    sync.Mutex\n\tcriuVersion          int\n\tstate                containerState\n\tcreated              time.Time\n\tfifo                 *os.File\n}\n\n// State represents a running container's state\ntype State struct {\n\tBaseState\n\n\t// Platform specific fields below here\n\n\t// Specified if the container was started under the rootless mode.\n\t// Set to true if BaseState.Config.RootlessEUID && BaseState.Config.RootlessCgroups\n\tRootless bool `json:\"rootless\"`\n\n\t// Paths to all the container's cgroups, as returned by (*cgroups.Manager).GetPaths\n\t//\n\t// For cgroup v1, a key is cgroup subsystem name, and the value is the path\n\t// to the cgroup for this subsystem.\n\t//\n\t// For cgroup v2 unified hierarchy, a key is \"\", and the value is the unified path.\n\tCgroupPaths map[string]string `json:\"cgroup_paths\"`\n\n\t// NamespacePaths are filepaths to the container's namespaces. Key is the namespace type\n\t// with the value as the path.\n\tNamespacePaths map[configs.NamespaceType]string `json:\"namespace_paths\"`\n\n\t// Container's standard descriptors (std{in,out,err}), needed for checkpoint and restore\n\tExternalDescriptors []string `json:\"external_descriptors,omitempty\"`\n\n\t// Intel RDT \"resource control\" filesystem path\n\tIntelRdtPath string `json:\"intel_rdt_path\"`\n}\n\n// Container is a libcontainer container object.\n//\n// Each container is thread-safe within the same process. Since a container can\n// be destroyed by a separate process, any function may return that the container\n// was not found.\ntype Container interface {\n\tBaseContainer\n\n\t// Methods below here are platform specific\n\n\t// Checkpoint checkpoints the running container's state to disk using the criu(8) utility.\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tCheckpoint(criuOpts *CriuOpts) error\n\n\t// Restore restores the checkpointed container to a running state using the criu(8) utility.\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tRestore(process *Process, criuOpts *CriuOpts) error\n\n\t// If the Container state is RUNNING or CREATED, sets the Container state to PAUSING and pauses\n\t// the execution of any user processes. Asynchronously, when the container finished being paused the\n\t// state is changed to PAUSED.\n\t// If the Container state is PAUSED, do nothing.\n\t//\n\t// errors:\n\t// ContainerNotExists - Container no longer exists,\n\t// ContainerNotRunning - Container not running or created,\n\t// Systemerror - System error.\n\tPause() error\n\n\t// If the Container state is PAUSED, resumes the execution of any user processes in the\n\t// Container before setting the Container state to RUNNING.\n\t// If the Container state is RUNNING, do nothing.\n\t//\n\t// errors:\n\t// ContainerNotExists - Container no longer exists,\n\t// ContainerNotPaused - Container is not paused,\n\t// Systemerror - System error.\n\tResume() error\n\n\t// NotifyOOM returns a read-only channel signaling when the container receives an OOM notification.\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tNotifyOOM() (<-chan struct{}, error)\n\n\t// NotifyMemoryPressure returns a read-only channel signaling when the container reaches a given pressure level\n\t//\n\t// errors:\n\t// Systemerror - System error.\n\tNotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error)\n}\n\n// ID returns the container's unique ID\nfunc (c *linuxContainer) ID() string {\n\treturn c.id\n}\n\n// Config returns the container's configuration\nfunc (c *linuxContainer) Config() configs.Config {\n\treturn *c.config\n}\n\nfunc (c *linuxContainer) Status() (Status, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentStatus()\n}\n\nfunc (c *linuxContainer) State() (*State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentState()\n}\n\nfunc (c *linuxContainer) OCIState() (*specs.State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentOCIState()\n}\n\nfunc (c *linuxContainer) Processes() ([]int, error) {\n\tvar pids []int\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn pids, err\n\t}\n\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\treturn pids, nil\n\t}\n\n\tpids, err = c.cgroupManager.GetAllPids()\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"getting all container pids from cgroups\")\n\t}\n\treturn pids, nil\n}\n\nfunc (c *linuxContainer) Stats() (*Stats, error) {\n\tvar (\n\t\terr   error\n\t\tstats = &Stats{}\n\t)\n\tif stats.CgroupStats, err = c.cgroupManager.GetStats(); err != nil {\n\t\treturn stats, newSystemErrorWithCause(err, \"getting container stats from cgroups\")\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif stats.IntelRdtStats, err = c.intelRdtManager.GetStats(); err != nil {\n\t\t\treturn stats, newSystemErrorWithCause(err, \"getting container's Intel RDT stats\")\n\t\t}\n\t}\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tistats, err := getNetworkInterfaceStats(iface.HostInterfaceName)\n\t\t\tif err != nil {\n\t\t\t\treturn stats, newSystemErrorWithCausef(err, \"getting network stats for interface %q\", iface.HostInterfaceName)\n\t\t\t}\n\t\t\tstats.Interfaces = append(stats.Interfaces, istats)\n\t\t}\n\t}\n\treturn stats, nil\n}\n\nfunc (c *linuxContainer) Set(config configs.Config) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status == Stopped {\n\t\treturn newGenericError(errors.New(\"container not running\"), ContainerNotRunning)\n\t}\n\tif err := c.cgroupManager.Set(config.Cgroups.Resources); err != nil {\n\t\t// Set configs back\n\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t}\n\t\treturn err\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif err := c.intelRdtManager.Set(&config); err != nil {\n\t\t\t// Set configs back\n\t\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\tif err2 := c.intelRdtManager.Set(c.config); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back intelrdt configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\t// After config setting succeed, update config and states\n\tc.config = &config\n\t_, err = c.updateState(nil)\n\treturn err\n}\n\nfunc (c *linuxContainer) Start(process *Process) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif c.config.Cgroups.Resources.SkipDevices {\n\t\treturn newGenericError(errors.New(\"can't start container with SkipDevices set\"), ConfigInvalid)\n\t}\n\tif process.Init {\n\t\tif err := c.createExecFifo(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := c.start(process); err != nil {\n\t\tif process.Init {\n\t\t\tc.deleteExecFifo()\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Run(process *Process) error {\n\tif err := c.Start(process); err != nil {\n\t\treturn err\n\t}\n\tif process.Init {\n\t\treturn c.exec()\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Exec() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.exec()\n}\n\nfunc (c *linuxContainer) exec() error {\n\tpath := filepath.Join(c.root, execFifoFilename)\n\tpid := c.initProcess.pid()\n\tblockingFifoOpenCh := awaitFifoOpen(path)\n\tfor {\n\t\tselect {\n\t\tcase result := <-blockingFifoOpenCh:\n\t\t\treturn handleFifoResult(result)\n\n\t\tcase <-time.After(time.Millisecond * 100):\n\t\t\tstat, err := system.Stat(pid)\n\t\t\tif err != nil || stat.State == system.Zombie {\n\t\t\t\t// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.\n\t\t\t\t// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).\n\t\t\t\tif err := handleFifoResult(fifoOpen(path, false)); err != nil {\n\t\t\t\t\treturn errors.New(\"container process is already dead\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc readFromExecFifo(execFifo io.Reader) error {\n\tdata, err := ioutil.ReadAll(execFifo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) <= 0 {\n\t\treturn errors.New(\"cannot start an already running container\")\n\t}\n\treturn nil\n}\n\nfunc awaitFifoOpen(path string) <-chan openResult {\n\tfifoOpened := make(chan openResult)\n\tgo func() {\n\t\tresult := fifoOpen(path, true)\n\t\tfifoOpened <- result\n\t}()\n\treturn fifoOpened\n}\n\nfunc fifoOpen(path string, block bool) openResult {\n\tflags := os.O_RDONLY\n\tif !block {\n\t\tflags |= unix.O_NONBLOCK\n\t}\n\tf, err := os.OpenFile(path, flags, 0)\n\tif err != nil {\n\t\treturn openResult{err: newSystemErrorWithCause(err, \"open exec fifo for reading\")}\n\t}\n\treturn openResult{file: f}\n}\n\nfunc handleFifoResult(result openResult) error {\n\tif result.err != nil {\n\t\treturn result.err\n\t}\n\tf := result.file\n\tdefer f.Close()\n\tif err := readFromExecFifo(f); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(f.Name())\n}\n\ntype openResult struct {\n\tfile *os.File\n\terr  error\n}\n\nfunc (c *linuxContainer) start(process *Process) (retErr error) {\n\tparent, err := c.newParentProcess(process)\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"creating new parent process\")\n\t}\n\n\tlogsDone := parent.forwardChildLogs()\n\tif logsDone != nil {\n\t\tdefer func() {\n\t\t\t// Wait for log forwarder to finish. This depends on\n\t\t\t// runc init closing the _LIBCONTAINER_LOGPIPE log fd.\n\t\t\terr := <-logsDone\n\t\t\tif err != nil && retErr == nil {\n\t\t\t\tretErr = newSystemErrorWithCause(err, \"forwarding init logs\")\n\t\t\t}\n\t\t}()\n\t}\n\n\tif err := parent.start(); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"starting container process\")\n\t}\n\n\tif process.Init {\n\t\tc.fifo.Close()\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := c.config.Hooks[configs.Poststart].RunHooks(s); err != nil {\n\t\t\t\tif err := ignoreTerminateErrors(parent.terminate()); err != nil {\n\t\t\t\t\tlogrus.Warn(errorsf.Wrapf(err, \"Running Poststart hook\"))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Signal(s os.Signal, all bool) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif all {\n\t\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\t\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\t\treturn nil\n\t\t}\n\t\treturn signalAllProcesses(c.cgroupManager, s)\n\t}\n\t// to avoid a PID reuse attack\n\tif status == Running || status == Created || status == Paused {\n\t\tif err := c.initProcess.signal(s); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"signaling init process\")\n\t\t}\n\t\treturn nil\n\t}\n\treturn newGenericError(errors.New(\"container not running\"), ContainerNotRunning)\n}\n\nfunc (c *linuxContainer) createExecFifo() error {\n\trootuid, err := c.Config().HostRootUID()\n\tif err != nil {\n\t\treturn err\n\t}\n\trootgid, err := c.Config().HostRootGID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tif _, err := os.Stat(fifoName); err == nil {\n\t\treturn fmt.Errorf(\"exec fifo %s already exists\", fifoName)\n\t}\n\toldMask := unix.Umask(0000)\n\tif err := unix.Mkfifo(fifoName, 0622); err != nil {\n\t\tunix.Umask(oldMask)\n\t\treturn err\n\t}\n\tunix.Umask(oldMask)\n\treturn os.Chown(fifoName, rootuid, rootgid)\n}\n\nfunc (c *linuxContainer) deleteExecFifo() {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tos.Remove(fifoName)\n}\n\n// includeExecFifo opens the container's execfifo as a pathfd, so that the\n// container cannot access the statedir (and the FIFO itself remains\n// un-opened). It then adds the FifoFd to the given exec.Cmd as an inherited\n// fd, with _LIBCONTAINER_FIFOFD set to its fd number.\nfunc (c *linuxContainer) includeExecFifo(cmd *exec.Cmd) error {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tfifo, err := os.OpenFile(fifoName, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fifo = fifo\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, fifo)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_FIFOFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\treturn nil\n}\n\nfunc (c *linuxContainer) newParentProcess(p *Process) (parentProcess, error) {\n\tparentInitPipe, childInitPipe, err := utils.NewSockPair(\"init\")\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"creating new init pipe\")\n\t}\n\tmessageSockPair := filePair{parentInitPipe, childInitPipe}\n\n\tparentLogPipe, childLogPipe, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Unable to create the log pipe:  %s\", err)\n\t}\n\tlogFilePair := filePair{parentLogPipe, childLogPipe}\n\n\tcmd := c.commandTemplate(p, childInitPipe, childLogPipe)\n\tif !p.Init {\n\t\treturn c.newSetnsProcess(p, cmd, messageSockPair, logFilePair)\n\t}\n\n\t// We only set up fifoFd if we're not doing a `runc exec`. The historic\n\t// reason for this is that previously we would pass a dirfd that allowed\n\t// for container rootfs escape (and not doing it in `runc exec` avoided\n\t// that problem), but we no longer do that. However, there's no need to do\n\t// this for `runc exec` so we just keep it this way to be safe.\n\tif err := c.includeExecFifo(cmd); err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"including execfifo in cmd.Exec setup\")\n\t}\n\treturn c.newInitProcess(p, cmd, messageSockPair, logFilePair)\n}\n\nfunc (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {\n\tcmd := exec.Command(c.initPath, c.initArgs[1:]...)\n\tcmd.Args[0] = c.initArgs[0]\n\tcmd.Stdin = p.Stdin\n\tcmd.Stdout = p.Stdout\n\tcmd.Stderr = p.Stderr\n\tcmd.Dir = c.config.Rootfs\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = &unix.SysProcAttr{}\n\t}\n\tcmd.Env = append(cmd.Env, \"GOMAXPROCS=\"+os.Getenv(\"GOMAXPROCS\"))\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n\tif p.ConsoleSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_CONSOLE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_INITPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_STATEDIR=\"+c.root,\n\t)\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_LOGPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_LOGLEVEL=\"+p.LogLevel,\n\t)\n\n\t// NOTE: when running a container with no PID namespace and the parent process spawning the container is\n\t// PID1 the pdeathsig is being delivered to the container's init process by the kernel for some reason\n\t// even with the parent still running.\n\tif c.config.ParentDeathSignal > 0 {\n\t\tcmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal)\n\t}\n\treturn cmd\n}\n\nfunc (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n\tnsMaps := make(map[configs.NamespaceType]string)\n\tfor _, ns := range c.config.Namespaces {\n\t\tif ns.Path != \"\" {\n\t\t\tnsMaps[ns.Type] = ns.Path\n\t\t}\n\t}\n\t_, sharePidns := nsMaps[configs.NEWPID]\n\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinit := &initProcess{\n\t\tcmd:             cmd,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tintelRdtManager: c.intelRdtManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tcontainer:       c,\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tsharePidns:      sharePidns,\n\t}\n\tc.initProcess = init\n\treturn init, nil\n}\n\nfunc (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*setnsProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initSetns))\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"getting container's current state\")\n\t}\n\t// for setns process, we don't have to set cloneflags as the process namespaces\n\t// will only be set via setns syscall\n\tdata, err := c.bootstrapData(0, state.NamespacePaths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &setnsProcess{\n\t\tcmd:             cmd,\n\t\tcgroupPaths:     state.CgroupPaths,\n\t\trootlessCgroups: c.config.RootlessCgroups,\n\t\tintelRdtPath:    state.IntelRdtPath,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tinitProcessPid:  state.InitProcessPid,\n\t}, nil\n}\n\nfunc (c *linuxContainer) newInitConfig(process *Process) *initConfig {\n\tcfg := &initConfig{\n\t\tConfig:           c.config,\n\t\tArgs:             process.Args,\n\t\tEnv:              process.Env,\n\t\tUser:             process.User,\n\t\tAdditionalGroups: process.AdditionalGroups,\n\t\tCwd:              process.Cwd,\n\t\tCapabilities:     process.Capabilities,\n\t\tPassedFilesCount: len(process.ExtraFiles),\n\t\tContainerId:      c.ID(),\n\t\tNoNewPrivileges:  c.config.NoNewPrivileges,\n\t\tRootlessEUID:     c.config.RootlessEUID,\n\t\tRootlessCgroups:  c.config.RootlessCgroups,\n\t\tAppArmorProfile:  c.config.AppArmorProfile,\n\t\tProcessLabel:     c.config.ProcessLabel,\n\t\tRlimits:          c.config.Rlimits,\n\t\tCreateConsole:    process.ConsoleSocket != nil,\n\t\tConsoleWidth:     process.ConsoleWidth,\n\t\tConsoleHeight:    process.ConsoleHeight,\n\t}\n\tif process.NoNewPrivileges != nil {\n\t\tcfg.NoNewPrivileges = *process.NoNewPrivileges\n\t}\n\tif process.AppArmorProfile != \"\" {\n\t\tcfg.AppArmorProfile = process.AppArmorProfile\n\t}\n\tif process.Label != \"\" {\n\t\tcfg.ProcessLabel = process.Label\n\t}\n\tif len(process.Rlimits) > 0 {\n\t\tcfg.Rlimits = process.Rlimits\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tcfg.Cgroup2Path = c.cgroupManager.Path(\"\")\n\t}\n\n\treturn cfg\n}\n\nfunc (c *linuxContainer) Destroy() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.state.destroy()\n}\n\nfunc (c *linuxContainer) Pause() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch status {\n\tcase Running, Created:\n\t\tif err := c.cgroupManager.Freeze(configs.Frozen); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.state.transition(&pausedState{\n\t\t\tc: c,\n\t\t})\n\t}\n\treturn newGenericError(fmt.Errorf(\"container not running or created: %s\", status), ContainerNotRunning)\n}\n\nfunc (c *linuxContainer) Resume() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status != Paused {\n\t\treturn newGenericError(fmt.Errorf(\"container not paused\"), ContainerNotPaused)\n\t}\n\tif err := c.cgroupManager.Freeze(configs.Thawed); err != nil {\n\t\treturn err\n\t}\n\treturn c.state.transition(&runningState{\n\t\tc: c,\n\t})\n}\n\nfunc (c *linuxContainer) NotifyOOM() (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting OOM notifications may fail if you don't have the full access to cgroups\")\n\t}\n\tpath := c.cgroupManager.Path(\"memory\")\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn notifyOnOOMV2(path)\n\t}\n\treturn notifyOnOOM(path)\n}\n\nfunc (c *linuxContainer) NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting memory pressure notifications may fail if you don't have the full access to cgroups\")\n\t}\n\treturn notifyMemoryPressure(c.cgroupManager.Path(\"memory\"), level)\n}\n\nvar criuFeatures *criurpc.CriuFeatures\n\nfunc (c *linuxContainer) checkCriuFeatures(criuOpts *CriuOpts, rpcOpts *criurpc.CriuOpts, criuFeat *criurpc.CriuFeatures) error {\n\n\tt := criurpc.CriuReqType_FEATURE_CHECK\n\n\t// make sure the features we are looking for are really not from\n\t// some previous check\n\tcriuFeatures = nil\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\t// Theoretically this should not be necessary but CRIU\n\t\t// segfaults if Opts is empty.\n\t\t// Fixed in CRIU  2.12\n\t\tOpts:     rpcOpts,\n\t\tFeatures: criuFeat,\n\t}\n\n\terr := c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\tlogrus.Debugf(\"%s\", err)\n\t\treturn errors.New(\"CRIU feature check failed\")\n\t}\n\n\tmissingFeatures := false\n\n\t// The outer if checks if the fields actually exist\n\tif (criuFeat.MemTrack != nil) &&\n\t\t(criuFeatures.MemTrack != nil) {\n\t\t// The inner if checks if they are set to true\n\t\tif *criuFeat.MemTrack && !*criuFeatures.MemTrack {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support MemTrack\")\n\t\t}\n\t}\n\n\t// This needs to be repeated for every new feature check.\n\t// Is there a way to put this in a function. Reflection?\n\tif (criuFeat.LazyPages != nil) &&\n\t\t(criuFeatures.LazyPages != nil) {\n\t\tif *criuFeat.LazyPages && !*criuFeatures.LazyPages {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support LazyPages\")\n\t\t}\n\t}\n\n\tif missingFeatures {\n\t\treturn errors.New(\"CRIU is missing features\")\n\t}\n\n\treturn nil\n}\n\nfunc compareCriuVersion(criuVersion int, minVersion int) error {\n\t// simple function to perform the actual version compare\n\tif criuVersion < minVersion {\n\t\treturn fmt.Errorf(\"CRIU version %d must be %d or higher\", criuVersion, minVersion)\n\t}\n\n\treturn nil\n}\n\n// checkCriuVersion checks Criu version greater than or equal to minVersion\nfunc (c *linuxContainer) checkCriuVersion(minVersion int) error {\n\n\t// If the version of criu has already been determined there is no need\n\t// to ask criu for the version again. Use the value from c.criuVersion.\n\tif c.criuVersion != 0 {\n\t\treturn compareCriuVersion(c.criuVersion, minVersion)\n\t}\n\n\tcriu := criu.MakeCriu()\n\tcriu.SetCriuPath(c.criuPath)\n\tvar err error\n\tc.criuVersion, err = criu.GetCriuVersion()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"CRIU version check failed: %s\", err)\n\t}\n\n\treturn compareCriuVersion(c.criuVersion, minVersion)\n}\n\nconst descriptorsFilename = \"descriptors.json\"\n\nfunc (c *linuxContainer) addCriuDumpMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(mountDest),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) addMaskPaths(req *criurpc.CriuReq) error {\n\tfor _, path := range c.config.MaskPaths {\n\t\tfi, err := os.Stat(fmt.Sprintf(\"/proc/%d/root/%s\", c.initProcess.pid(), path))\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\textMnt := &criurpc.ExtMountMap{\n\t\t\tKey: proto.String(path),\n\t\t\tVal: proto.String(\"/dev/null\"),\n\t\t}\n\t\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleCriuConfigurationFile(rpcOpts *criurpc.CriuOpts) {\n\t// CRIU will evaluate a configuration starting with release 3.11.\n\t// Settings in the configuration file will overwrite RPC settings.\n\t// Look for annotations. The annotation 'org.criu.config'\n\t// specifies if CRIU should use a different, container specific\n\t// configuration file.\n\t_, annotations := utils.Annotations(c.config.Labels)\n\tconfigFile, exists := annotations[\"org.criu.config\"]\n\tif exists {\n\t\t// If the annotation 'org.criu.config' exists and is set\n\t\t// to a non-empty string, tell CRIU to use that as a\n\t\t// configuration file. If the file does not exist, CRIU\n\t\t// will just ignore it.\n\t\tif configFile != \"\" {\n\t\t\trpcOpts.ConfigFile = proto.String(configFile)\n\t\t}\n\t\t// If 'org.criu.config' exists and is set to an empty\n\t\t// string, a runc specific CRIU configuration file will\n\t\t// be not set at all.\n\t} else {\n\t\t// If the mentioned annotation has not been found, specify\n\t\t// a default CRIU configuration file.\n\t\trpcOpts.ConfigFile = proto.String(\"/etc/criu/runc.conf\")\n\t}\n}\n\nfunc (c *linuxContainer) criuSupportsExtNS(t configs.NamespaceType) bool {\n\tvar minVersion int\n\tswitch t {\n\tcase configs.NEWNET:\n\t\t// CRIU supports different external namespace with different released CRIU versions.\n\t\t// For network namespaces to work we need at least criu 3.11.0 => 31100.\n\t\tminVersion = 31100\n\tcase configs.NEWPID:\n\t\t// For PID namespaces criu 31500 is needed.\n\t\tminVersion = 31500\n\tdefault:\n\t\treturn false\n\t}\n\treturn c.checkCriuVersion(minVersion) == nil\n}\n\nfunc criuNsToKey(t configs.NamespaceType) string {\n\treturn \"extRoot\" + strings.Title(configs.NsName(t)) + \"NS\"\n}\n\nfunc (c *linuxContainer) handleCheckpointingExternalNamespaces(rpcOpts *criurpc.CriuOpts, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU expects the information about an external namespace\n\t// like this: --external <TYPE>[<inode>]:<key>\n\t// This <key> is always 'extRoot<TYPE>NS'.\n\tvar ns unix.Stat_t\n\tif err := unix.Stat(nsPath, &ns); err != nil {\n\t\treturn err\n\t}\n\tcriuExternal := fmt.Sprintf(\"%s[%d]:%s\", configs.NsName(t), ns.Ino, criuNsToKey(t))\n\trpcOpts.External = append(rpcOpts.External, criuExternal)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File) error {\n\tfor _, ns := range c.config.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase configs.NEWNET, configs.NEWPID:\n\t\t\t// If the container is running in a network or PID namespace and has\n\t\t\t// a path to the network or PID namespace configured, we will dump\n\t\t\t// that network or PID namespace as an external namespace and we\n\t\t\t// will expect that the namespace exists during restore.\n\t\t\t// This basically means that CRIU will ignore the namespace\n\t\t\t// and expect it to be setup correctly.\n\t\t\tif err := c.handleRestoringExternalNamespaces(rpcOpts, extraFiles, ns.Type); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\t// For all other namespaces except NET and PID CRIU has\n\t\t\t// a simpler way of joining the existing namespace if set\n\t\t\tnsPath := c.config.Namespaces.PathOf(ns.Type)\n\t\t\tif nsPath == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ns.Type == configs.NEWCGROUP {\n\t\t\t\t// CRIU has no code to handle NEWCGROUP\n\t\t\t\treturn fmt.Errorf(\"Do not know how to handle namespace %v\", ns.Type)\n\t\t\t}\n\t\t\t// CRIU has code to handle NEWTIME, but it does not seem to be defined in runc\n\n\t\t\t// CRIU will issue a warning for NEWUSER:\n\t\t\t// criu/namespaces.c: 'join-ns with user-namespace is not fully tested and dangerous'\n\t\t\trpcOpts.JoinNs = append(rpcOpts.JoinNs, &criurpc.JoinNamespace{\n\t\t\t\tNs:     proto.String(configs.NsName(ns.Type)),\n\t\t\t\tNsFile: proto.String(nsPath),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringExternalNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU wants the information about an existing namespace\n\t// like this: --inherit-fd fd[<fd>]:<key>\n\t// The <key> needs to be the same as during checkpointing.\n\t// We are always using 'extRoot<TYPE>NS' as the key in this.\n\tnsFd, err := os.Open(nsPath)\n\tif err != nil {\n\t\tlogrus.Errorf(\"If a specific network namespace is defined it must exist: %s\", err)\n\t\treturn fmt.Errorf(\"Requested network namespace %v does not exist\", nsPath)\n\t}\n\tinheritFd := &criurpc.InheritFd{\n\t\tKey: proto.String(criuNsToKey(t)),\n\t\t// The offset of four is necessary because 0, 1, 2 and 3 are\n\t\t// already used by stdin, stdout, stderr, 'criu swrk' socket.\n\t\tFd: proto.Int32(int32(4 + len(*extraFiles))),\n\t}\n\trpcOpts.InheritFd = append(rpcOpts.InheritFd, inheritFd)\n\t// All open FDs need to be transferred to CRIU via extraFiles\n\t*extraFiles = append(*extraFiles, nsFd)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) Checkpoint(criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\t// Checkpoint is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU 2.0 has\n\t//               support for doing unprivileged dumps, but the setup of\n\t//               rootless containers might make this complicated.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to save checkpoint\")\n\t}\n\n\t// Since a container can be C/R'ed multiple times,\n\t// the checkpoint directory may already exist.\n\tif err := os.Mkdir(criuOpts.ImagesDirectory, 0700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\n\tif criuOpts.WorkDirectory == \"\" {\n\t\tcriuOpts.WorkDirectory = filepath.Join(c.root, \"criu.work\")\n\t}\n\n\tif err := os.Mkdir(criuOpts.WorkDirectory, 0700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\n\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer workDir.Close()\n\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\n\trpcOpts := criurpc.CriuOpts{\n\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\tWorkDirFd:       proto.Int32(int32(workDir.Fd())),\n\t\tLogLevel:        proto.Int32(4),\n\t\tLogFile:         proto.String(\"dump.log\"),\n\t\tRoot:            proto.String(c.config.Rootfs),\n\t\tManageCgroups:   proto.Bool(true),\n\t\tNotifyScripts:   proto.Bool(true),\n\t\tPid:             proto.Int32(int32(c.initProcess.pid())),\n\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\tLeaveRunning:    proto.Bool(criuOpts.LeaveRunning),\n\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\tOrphanPtsMaster: proto.Bool(true),\n\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t}\n\n\tc.handleCriuConfigurationFile(&rpcOpts)\n\n\t// If the container is running in a network namespace and has\n\t// a path to the network namespace configured, we will dump\n\t// that network namespace as an external namespace and we\n\t// will expect that the namespace exists during restore.\n\t// This basically means that CRIU will ignore the namespace\n\t// and expect to be setup correctly.\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWNET); err != nil {\n\t\treturn err\n\t}\n\n\t// Same for possible external PID namespaces\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWPID); err != nil {\n\t\treturn err\n\t}\n\n\t// CRIU can use cgroup freezer; when rpcOpts.FreezeCgroup\n\t// is not set, CRIU uses ptrace() to pause the processes.\n\t// Note cgroup v2 freezer is only supported since CRIU release 3.14.\n\tif !cgroups.IsCgroup2UnifiedMode() || c.checkCriuVersion(31400) == nil {\n\t\tif fcg := c.cgroupManager.Path(\"freezer\"); fcg != \"\" {\n\t\t\trpcOpts.FreezeCgroup = proto.String(fcg)\n\t\t}\n\t}\n\n\t// append optional criu opts, e.g., page-server and port\n\tif criuOpts.PageServer.Address != \"\" && criuOpts.PageServer.Port != 0 {\n\t\trpcOpts.Ps = &criurpc.CriuPageServerInfo{\n\t\t\tAddress: proto.String(criuOpts.PageServer.Address),\n\t\t\tPort:    proto.Int32(criuOpts.PageServer.Port),\n\t\t}\n\t}\n\n\t//pre-dump may need parentImage param to complete iterative migration\n\tif criuOpts.ParentImage != \"\" {\n\t\trpcOpts.ParentImg = proto.String(criuOpts.ParentImage)\n\t\trpcOpts.TrackMem = proto.Bool(true)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criurpc.CriuCgMode(criuOpts.ManageCgroupsMode)\n\t\trpcOpts.ManageCgroupsMode = &mode\n\t}\n\n\tvar t criurpc.CriuReqType\n\tif criuOpts.PreDump {\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tMemTrack: proto.Bool(true),\n\t\t}\n\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tt = criurpc.CriuReqType_PRE_DUMP\n\t} else {\n\t\tt = criurpc.CriuReqType_DUMP\n\t}\n\n\tif criuOpts.LazyPages {\n\t\t// lazy migration requested; check if criu supports it\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tLazyPages: proto.Bool(true),\n\t\t}\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif fd := criuOpts.StatusFd; fd != -1 {\n\t\t\t// check that the FD is valid\n\t\t\tflags, err := unix.FcntlInt(uintptr(fd), unix.F_GETFL, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: %w\", fd, err)\n\t\t\t}\n\t\t\t// and writable\n\t\t\tif flags&unix.O_WRONLY == 0 {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: not writable\", fd)\n\t\t\t}\n\n\t\t\tif c.checkCriuVersion(31500) != nil {\n\t\t\t\t// For criu 3.15+, use notifications (see case \"status-ready\"\n\t\t\t\t// in criuNotifications). Otherwise, rely on criu status fd.\n\t\t\t\trpcOpts.StatusFd = proto.Int32(int32(fd))\n\t\t\t}\n\t\t}\n\t}\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &rpcOpts,\n\t}\n\n\t// no need to dump all this in pre-dump\n\tif !criuOpts.PreDump {\n\t\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\t\tfor _, m := range c.config.Mounts {\n\t\t\tswitch m.Device {\n\t\t\tcase \"bind\":\n\t\t\t\tc.addCriuDumpMount(req, m)\n\t\t\tcase \"cgroup\":\n\t\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\t\t// real mount(s)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// a set of \"external\" bind mounts\n\t\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfor _, b := range binds {\n\t\t\t\t\tc.addCriuDumpMount(req, b)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err := c.addMaskPaths(req); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, node := range c.config.Devices {\n\t\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\t\tc.addCriuDumpMount(req, m)\n\t\t}\n\n\t\t// Write the FD info to a file in the image directory\n\t\tfdsJSON, err := json.Marshal(c.initProcess.externalDescriptors())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = ioutil.WriteFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename), fdsJSON, 0600)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) addCriuRestoreMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(m.Source),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) restoreNetwork(req *criurpc.CriuReq, criuOpts *CriuOpts) {\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tveth := new(criurpc.CriuVethPair)\n\t\t\tveth.IfOut = proto.String(iface.HostInterfaceName)\n\t\t\tveth.IfIn = proto.String(iface.Name)\n\t\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t\tcase \"loopback\":\n\t\t\t// Do nothing\n\t\t}\n\t}\n\tfor _, i := range criuOpts.VethPairs {\n\t\tveth := new(criurpc.CriuVethPair)\n\t\tveth.IfOut = proto.String(i.HostInterfaceName)\n\t\tveth.IfIn = proto.String(i.ContainerInterfaceName)\n\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t}\n}\n\n// makeCriuRestoreMountpoints makes the actual mountpoints for the\n// restore using CRIU. This function is inspired from the code in\n// rootfs_linux.go\nfunc (c *linuxContainer) makeCriuRestoreMountpoints(m *configs.Mount) error {\n\tswitch m.Device {\n\tcase \"cgroup\":\n\t\t// No mount point(s) need to be created:\n\t\t//\n\t\t// * for v1, mount points are saved by CRIU because\n\t\t//   /sys/fs/cgroup is a tmpfs mount\n\t\t//\n\t\t// * for v2, /sys/fs/cgroup is a real mount, but\n\t\t//   the mountpoint appears as soon as /sys is mounted\n\t\treturn nil\n\tcase \"bind\":\n\t\t// The prepareBindMount() function checks if source\n\t\t// exists. So it cannot be used for other filesystem types.\n\t\tif err := prepareBindMount(m, c.config.Rootfs); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\t// for all other filesystems just create the mountpoints\n\t\tdest, err := securejoin.SecureJoin(c.config.Rootfs, m.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := checkProcMount(c.config.Rootfs, dest, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// isPathInPrefixList is a small function for CRIU restore to make sure\n// mountpoints, which are on a tmpfs, are not created in the roofs\nfunc isPathInPrefixList(path string, prefix []string) bool {\n\tfor _, p := range prefix {\n\t\tif strings.HasPrefix(path, p+\"/\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// prepareCriuRestoreMounts tries to set up the rootfs of the\n// container to be restored in the same way runc does it for\n// initial container creation. Even for a read-only rootfs container\n// runc modifies the rootfs to add mountpoints which do not exist.\n// This function also creates missing mountpoints as long as they\n// are not on top of a tmpfs, as CRIU will restore tmpfs content anyway.\nfunc (c *linuxContainer) prepareCriuRestoreMounts(mounts []*configs.Mount) error {\n\t// First get a list of a all tmpfs mounts\n\ttmpfs := []string{}\n\tfor _, m := range mounts {\n\t\tswitch m.Device {\n\t\tcase \"tmpfs\":\n\t\t\ttmpfs = append(tmpfs, m.Destination)\n\t\t}\n\t}\n\t// Now go through all mounts and create the mountpoints\n\t// if the mountpoints are not on a tmpfs, as CRIU will\n\t// restore the complete tmpfs content from its checkpoint.\n\tumounts := []string{}\n\tdefer func() {\n\t\tfor _, u := range umounts {\n\t\t\t_ = utils.WithProcfd(c.config.Rootfs, u, func(procfd string) error {\n\t\t\t\tif e := unix.Unmount(procfd, unix.MNT_DETACH); e != nil {\n\t\t\t\t\tif e != unix.EINVAL {\n\t\t\t\t\t\t// Ignore EINVAL as it means 'target is not a mount point.'\n\t\t\t\t\t\t// It probably has already been unmounted.\n\t\t\t\t\t\tlogrus.Warnf(\"Error during cleanup unmounting of %s (%s): %v\", procfd, u, e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t}\n\t}()\n\tfor _, m := range mounts {\n\t\tif !isPathInPrefixList(m.Destination, tmpfs) {\n\t\t\tif err := c.makeCriuRestoreMountpoints(m); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// If the mount point is a bind mount, we need to mount\n\t\t\t// it now so that runc can create the necessary mount\n\t\t\t// points for mounts in bind mounts.\n\t\t\t// This also happens during initial container creation.\n\t\t\t// Without this CRIU restore will fail\n\t\t\t// See: https://github.com/opencontainers/runc/issues/2748\n\t\t\t// It is also not necessary to order the mount points\n\t\t\t// because during initial container creation mounts are\n\t\t\t// set up in the order they are configured.\n\t\t\tif m.Device == \"bind\" {\n\t\t\t\tif err := utils.WithProcfd(c.config.Rootfs, m.Destination, func(procfd string) error {\n\t\t\t\t\tif err := unix.Mount(m.Source, procfd, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\t\t\t\t\treturn errorsf.Wrapf(err, \"unable to bind mount %q to %q (through %q)\", m.Source, m.Destination, procfd)\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tumounts = append(umounts, m.Destination)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Restore(process *Process, criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tvar extraFiles []*os.File\n\n\t// Restore is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU doesn't have\n\t//               support for unprivileged restore at the moment.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\tif criuOpts.WorkDirectory == \"\" {\n\t\tcriuOpts.WorkDirectory = filepath.Join(c.root, \"criu.work\")\n\t}\n\t// Since a container can be C/R'ed multiple times,\n\t// the work directory may already exist.\n\tif err := os.Mkdir(criuOpts.WorkDirectory, 0700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer workDir.Close()\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to restore checkpoint\")\n\t}\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\t// CRIU has a few requirements for a root directory:\n\t// * it must be a mount point\n\t// * its parent must not be overmounted\n\t// c.config.Rootfs is bind-mounted to a temporary directory\n\t// to satisfy these requirements.\n\troot := filepath.Join(c.root, \"criu-root\")\n\tif err := os.Mkdir(root, 0755); err != nil {\n\t\treturn err\n\t}\n\tdefer os.Remove(root)\n\troot, err = filepath.EvalSymlinks(root)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = unix.Mount(c.config.Rootfs, root, \"\", unix.MS_BIND|unix.MS_REC, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Unmount(root, unix.MNT_DETACH)\n\tt := criurpc.CriuReqType_RESTORE\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &criurpc.CriuOpts{\n\t\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\t\tWorkDirFd:       proto.Int32(int32(workDir.Fd())),\n\t\t\tEvasiveDevices:  proto.Bool(true),\n\t\t\tLogLevel:        proto.Int32(4),\n\t\t\tLogFile:         proto.String(\"restore.log\"),\n\t\t\tRstSibling:      proto.Bool(true),\n\t\t\tRoot:            proto.String(root),\n\t\t\tManageCgroups:   proto.Bool(true),\n\t\t\tNotifyScripts:   proto.Bool(true),\n\t\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\t\tOrphanPtsMaster: proto.Bool(true),\n\t\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t\t},\n\t}\n\n\tc.handleCriuConfigurationFile(req.Opts)\n\n\tif err := c.handleRestoringNamespaces(req.Opts, &extraFiles); err != nil {\n\t\treturn err\n\t}\n\n\t// This will modify the rootfs of the container in the same way runc\n\t// modifies the container during initial creation.\n\tif err := c.prepareCriuRestoreMounts(c.config.Mounts); err != nil {\n\t\treturn err\n\t}\n\n\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\tfor _, m := range c.config.Mounts {\n\t\tswitch m.Device {\n\t\tcase \"bind\":\n\t\t\tc.addCriuRestoreMount(req, m)\n\t\tcase \"cgroup\":\n\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// cgroup v1 is a set of bind mounts, unless cgroupns is used\n\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, b := range binds {\n\t\t\t\tc.addCriuRestoreMount(req, b)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(c.config.MaskPaths) > 0 {\n\t\tm := &configs.Mount{Destination: \"/dev/null\", Source: \"/dev/null\"}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tfor _, node := range c.config.Devices {\n\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tif criuOpts.EmptyNs&unix.CLONE_NEWNET == 0 {\n\t\tc.restoreNetwork(req, criuOpts)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criurpc.CriuCgMode(criuOpts.ManageCgroupsMode)\n\t\treq.Opts.ManageCgroupsMode = &mode\n\t}\n\n\tvar (\n\t\tfds    []string\n\t\tfdJSON []byte\n\t)\n\tif fdJSON, err = ioutil.ReadFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal(fdJSON, &fds); err != nil {\n\t\treturn err\n\t}\n\tfor i := range fds {\n\t\tif s := fds[i]; strings.Contains(s, \"pipe:\") {\n\t\t\tinheritFd := new(criurpc.InheritFd)\n\t\t\tinheritFd.Key = proto.String(s)\n\t\t\tinheritFd.Fd = proto.Int32(int32(i))\n\t\t\treq.Opts.InheritFd = append(req.Opts.InheritFd, inheritFd)\n\t\t}\n\t}\n\terr = c.criuSwrk(process, req, criuOpts, extraFiles)\n\n\t// Now that CRIU is done let's close all opened FDs CRIU needed.\n\tfor _, fd := range extraFiles {\n\t\tfd.Close()\n\t}\n\n\treturn err\n}\n\nfunc (c *linuxContainer) criuApplyCgroups(pid int, req *criurpc.CriuReq) error {\n\t// need to apply cgroups only on restore\n\tif req.GetType() != criurpc.CriuReqType_RESTORE {\n\t\treturn nil\n\t}\n\n\t// XXX: Do we need to deal with this case? AFAIK criu still requires root.\n\tif err := c.cgroupManager.Apply(pid); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.cgroupManager.Set(c.config.Cgroups.Resources); err != nil {\n\t\treturn newSystemError(err)\n\t}\n\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn nil\n\t}\n\t// the stuff below is cgroupv1-specific\n\n\tpath := fmt.Sprintf(\"/proc/%d/cgroup\", pid)\n\tcgroupsPaths, err := cgroups.ParseCgroupFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor c, p := range cgroupsPaths {\n\t\tcgroupRoot := &criurpc.CgroupRoot{\n\t\t\tCtrl: proto.String(c),\n\t\t\tPath: proto.String(p),\n\t\t}\n\t\treq.Opts.CgRoot = append(req.Opts.CgRoot, cgroupRoot)\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuSwrk(process *Process, req *criurpc.CriuReq, opts *CriuOpts, extraFiles []*os.File) error {\n\tfds, err := unix.Socketpair(unix.AF_LOCAL, unix.SOCK_SEQPACKET|unix.SOCK_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar logPath string\n\tif opts != nil {\n\t\tlogPath = filepath.Join(opts.WorkDirectory, req.GetOpts().GetLogFile())\n\t} else {\n\t\t// For the VERSION RPC 'opts' is set to 'nil' and therefore\n\t\t// opts.WorkDirectory does not exist. Set logPath to \"\".\n\t\tlogPath = \"\"\n\t}\n\tcriuClient := os.NewFile(uintptr(fds[0]), \"criu-transport-client\")\n\tcriuClientFileCon, err := net.FileConn(criuClient)\n\tcriuClient.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcriuClientCon := criuClientFileCon.(*net.UnixConn)\n\tdefer criuClientCon.Close()\n\n\tcriuServer := os.NewFile(uintptr(fds[1]), \"criu-transport-server\")\n\tdefer criuServer.Close()\n\n\targs := []string{\"swrk\", \"3\"}\n\tif c.criuVersion != 0 {\n\t\t// If the CRIU Version is still '0' then this is probably\n\t\t// the initial CRIU run to detect the version. Skip it.\n\t\tlogrus.Debugf(\"Using CRIU %d at: %s\", c.criuVersion, c.criuPath)\n\t}\n\tcmd := exec.Command(c.criuPath, args...)\n\tif process != nil {\n\t\tcmd.Stdin = process.Stdin\n\t\tcmd.Stdout = process.Stdout\n\t\tcmd.Stderr = process.Stderr\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, criuServer)\n\tif extraFiles != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, extraFiles...)\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\t// we close criuServer so that even if CRIU crashes or unexpectedly exits, runc will not hang.\n\tcriuServer.Close()\n\t// cmd.Process will be replaced by a restored init.\n\tcriuProcess := cmd.Process\n\n\tvar criuProcessState *os.ProcessState\n\tdefer func() {\n\t\tif criuProcessState == nil {\n\t\t\tcriuClientCon.Close()\n\t\t\t_, err := criuProcess.Wait()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"wait on criuProcess returned %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif err := c.criuApplyCgroups(criuProcess.Pid, req); err != nil {\n\t\treturn err\n\t}\n\n\tvar extFds []string\n\tif process != nil {\n\t\textFds, err = getPipeFds(criuProcess.Pid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogrus.Debugf(\"Using CRIU in %s mode\", req.GetType().String())\n\t// In the case of criurpc.CriuReqType_FEATURE_CHECK req.GetOpts()\n\t// should be empty. For older CRIU versions it still will be\n\t// available but empty. criurpc.CriuReqType_VERSION actually\n\t// has no req.GetOpts().\n\tif logrus.GetLevel() >= logrus.DebugLevel &&\n\t\t!(req.GetType() == criurpc.CriuReqType_FEATURE_CHECK ||\n\t\t\treq.GetType() == criurpc.CriuReqType_VERSION) {\n\n\t\tval := reflect.ValueOf(req.GetOpts())\n\t\tv := reflect.Indirect(val)\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tst := v.Type()\n\t\t\tname := st.Field(i).Name\n\t\t\tif 'A' <= name[0] && name[0] <= 'Z' {\n\t\t\t\tvalue := val.MethodByName(\"Get\" + name).Call([]reflect.Value{})\n\t\t\t\tlogrus.Debugf(\"CRIU option %s with value %v\", name, value[0])\n\t\t\t}\n\t\t}\n\t}\n\tdata, err := proto.Marshal(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = criuClientCon.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, 10*4096)\n\toob := make([]byte, 4096)\n\tfor {\n\t\tn, oobn, _, _, err := criuClientCon.ReadMsgUnix(buf, oob)\n\t\tif req.Opts != nil && req.Opts.StatusFd != nil {\n\t\t\t// Close status_fd as soon as we got something back from criu,\n\t\t\t// assuming it has consumed (reopened) it by this time.\n\t\t\t// Otherwise it will might be left open forever and whoever\n\t\t\t// is waiting on it will wait forever.\n\t\t\tfd := int(*req.Opts.StatusFd)\n\t\t\t_ = unix.Close(fd)\n\t\t\treq.Opts.StatusFd = nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn errors.New(\"unexpected EOF\")\n\t\t}\n\t\tif n == len(buf) {\n\t\t\treturn errors.New(\"buffer is too small\")\n\t\t}\n\n\t\tresp := new(criurpc.CriuResp)\n\t\terr = proto.Unmarshal(buf[:n], resp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !resp.GetSuccess() {\n\t\t\ttypeString := req.GetType().String()\n\t\t\treturn fmt.Errorf(\"criu failed: type %s errno %d\\nlog file: %s\", typeString, resp.GetCrErrno(), logPath)\n\t\t}\n\n\t\tt := resp.GetType()\n\t\tswitch {\n\t\tcase t == criurpc.CriuReqType_FEATURE_CHECK:\n\t\t\tlogrus.Debugf(\"Feature check says: %s\", resp)\n\t\t\tcriuFeatures = resp.GetFeatures()\n\t\tcase t == criurpc.CriuReqType_NOTIFY:\n\t\t\tif err := c.criuNotifications(resp, process, cmd, opts, extFds, oob[:oobn]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tt = criurpc.CriuReqType_NOTIFY\n\t\t\treq = &criurpc.CriuReq{\n\t\t\t\tType:          &t,\n\t\t\t\tNotifySuccess: proto.Bool(true),\n\t\t\t}\n\t\t\tdata, err = proto.Marshal(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = criuClientCon.Write(data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\tcase t == criurpc.CriuReqType_RESTORE:\n\t\tcase t == criurpc.CriuReqType_DUMP:\n\t\tcase t == criurpc.CriuReqType_PRE_DUMP:\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unable to parse the response %s\", resp.String())\n\t\t}\n\n\t\tbreak\n\t}\n\n\tcriuClientCon.CloseWrite()\n\t// cmd.Wait() waits cmd.goroutines which are used for proxying file descriptors.\n\t// Here we want to wait only the CRIU process.\n\tcriuProcessState, err = criuProcess.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// In pre-dump mode CRIU is in a loop and waits for\n\t// the final DUMP command.\n\t// The current runc pre-dump approach, however, is\n\t// start criu in PRE_DUMP once for a single pre-dump\n\t// and not the whole series of pre-dump, pre-dump, ...m, dump\n\t// If we got the message CriuReqType_PRE_DUMP it means\n\t// CRIU was successful and we need to forcefully stop CRIU\n\tif !criuProcessState.Success() && *req.Type != criurpc.CriuReqType_PRE_DUMP {\n\t\treturn fmt.Errorf(\"criu failed: %s\\nlog file: %s\", criuProcessState.String(), logPath)\n\t}\n\treturn nil\n}\n\n// block any external network activity\nfunc lockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := strategy.detach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc unlockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = strategy.attach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuNotifications(resp *criurpc.CriuResp, process *Process, cmd *exec.Cmd, opts *CriuOpts, fds []string, oob []byte) error {\n\tnotify := resp.GetNotify()\n\tif notify == nil {\n\t\treturn fmt.Errorf(\"invalid response: %s\", resp.String())\n\t}\n\tscript := notify.GetScript()\n\tlogrus.Debugf(\"notify: %s\\n\", script)\n\tswitch script {\n\tcase \"post-dump\":\n\t\tf, err := os.Create(filepath.Join(c.root, \"checkpoint\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.Close()\n\tcase \"network-unlock\":\n\t\tif err := unlockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"network-lock\":\n\t\tif err := lockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"setup-namespaces\":\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\ts.Pid = int(notify.GetPid())\n\n\t\t\tif err := c.config.Hooks[configs.Prestart].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := c.config.Hooks[configs.CreateRuntime].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"post-restore\":\n\t\tpid := notify.GetPid()\n\n\t\tp, err := os.FindProcess(int(pid))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.Process = p\n\n\t\tr, err := newRestoredProcess(cmd, fds)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprocess.ops = r\n\t\tif err := c.state.transition(&restoredState{\n\t\t\timageDir: opts.ImagesDirectory,\n\t\t\tc:        c,\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// create a timestamp indicating when the restored checkpoint was started\n\t\tc.created = time.Now().UTC()\n\t\tif _, err := c.updateState(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.Remove(filepath.Join(c.root, \"checkpoint\")); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\tlogrus.Error(err)\n\t\t\t}\n\t\t}\n\tcase \"orphan-pts-master\":\n\t\tscm, err := unix.ParseSocketControlMessage(oob)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfds, err := unix.ParseUnixRights(&scm[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmaster := os.NewFile(uintptr(fds[0]), \"orphan-pts-master\")\n\t\tdefer master.Close()\n\n\t\t// While we can access console.master, using the API is a good idea.\n\t\tif err := utils.SendFd(process.ConsoleSocket, master.Name(), master.Fd()); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"status-ready\":\n\t\tif opts.StatusFd != -1 {\n\t\t\t// write \\0 to status fd to notify that lazy page server is ready\n\t\t\t_, err := unix.Write(opts.StatusFd, []byte{0})\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"can't write \\\\0 to status fd: %v\", err)\n\t\t\t}\n\t\t\t_ = unix.Close(opts.StatusFd)\n\t\t\topts.StatusFd = -1\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) updateState(process parentProcess) (*State, error) {\n\tif process != nil {\n\t\tc.initProcess = process\n\t}\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.saveState(state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) saveState(s *State) (retErr error) {\n\ttmpFile, err := ioutil.TempFile(c.root, \"state-\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\ttmpFile.Close()\n\t\t\tos.Remove(tmpFile.Name())\n\t\t}\n\t}()\n\n\terr = utils.WriteJSON(tmpFile, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tmpFile.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstateFilePath := filepath.Join(c.root, stateFilename)\n\treturn os.Rename(tmpFile.Name(), stateFilePath)\n}\n\nfunc (c *linuxContainer) currentStatus() (Status, error) {\n\tif err := c.refreshState(); err != nil {\n\t\treturn -1, err\n\t}\n\treturn c.state.status(), nil\n}\n\n// refreshState needs to be called to verify that the current state on the\n// container is what is true.  Because consumers of libcontainer can use it\n// out of process we need to verify the container's status based on runtime\n// information and not rely on our in process info.\nfunc (c *linuxContainer) refreshState() error {\n\tpaused, err := c.isPaused()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif paused {\n\t\treturn c.state.transition(&pausedState{c: c})\n\t}\n\tt := c.runType()\n\tswitch t {\n\tcase Created:\n\t\treturn c.state.transition(&createdState{c: c})\n\tcase Running:\n\t\treturn c.state.transition(&runningState{c: c})\n\t}\n\treturn c.state.transition(&stoppedState{c: c})\n}\n\nfunc (c *linuxContainer) runType() Status {\n\tif c.initProcess == nil {\n\t\treturn Stopped\n\t}\n\tpid := c.initProcess.pid()\n\tstat, err := system.Stat(pid)\n\tif err != nil {\n\t\treturn Stopped\n\t}\n\tif stat.StartTime != c.initProcessStartTime || stat.State == system.Zombie || stat.State == system.Dead {\n\t\treturn Stopped\n\t}\n\t// We'll create exec fifo and blocking on it after container is created,\n\t// and delete it after start container.\n\tif _, err := os.Stat(filepath.Join(c.root, execFifoFilename)); err == nil {\n\t\treturn Created\n\t}\n\treturn Running\n}\n\nfunc (c *linuxContainer) isPaused() (bool, error) {\n\tstate, err := c.cgroupManager.GetFreezerState()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn state == configs.Frozen, nil\n}\n\nfunc (c *linuxContainer) currentState() (*State, error) {\n\tvar (\n\t\tstartTime           uint64\n\t\texternalDescriptors []string\n\t\tpid                 = -1\n\t)\n\tif c.initProcess != nil {\n\t\tpid = c.initProcess.pid()\n\t\tstartTime, _ = c.initProcess.startTime()\n\t\texternalDescriptors = c.initProcess.externalDescriptors()\n\t}\n\tintelRdtPath, err := intelrdt.GetIntelRdtPath(c.ID())\n\tif err != nil {\n\t\tintelRdtPath = \"\"\n\t}\n\tstate := &State{\n\t\tBaseState: BaseState{\n\t\t\tID:                   c.ID(),\n\t\t\tConfig:               *c.config,\n\t\t\tInitProcessPid:       pid,\n\t\t\tInitProcessStartTime: startTime,\n\t\t\tCreated:              c.created,\n\t\t},\n\t\tRootless:            c.config.RootlessEUID && c.config.RootlessCgroups,\n\t\tCgroupPaths:         c.cgroupManager.GetPaths(),\n\t\tIntelRdtPath:        intelRdtPath,\n\t\tNamespacePaths:      make(map[configs.NamespaceType]string),\n\t\tExternalDescriptors: externalDescriptors,\n\t}\n\tif pid > 0 {\n\t\tfor _, ns := range c.config.Namespaces {\n\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t}\n\t\tfor _, nsType := range configs.NamespaceTypes() {\n\t\t\tif !configs.IsNamespaceSupported(nsType) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := state.NamespacePaths[nsType]; !ok {\n\t\t\t\tns := configs.Namespace{Type: nsType}\n\t\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) currentOCIState() (*specs.State, error) {\n\tbundle, annotations := utils.Annotations(c.config.Labels)\n\tstate := &specs.State{\n\t\tVersion:     specs.Version,\n\t\tID:          c.ID(),\n\t\tBundle:      bundle,\n\t\tAnnotations: annotations,\n\t}\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate.Status = specs.ContainerState(status.String())\n\tif status != Stopped {\n\t\tif c.initProcess != nil {\n\t\t\tstate.Pid = c.initProcess.pid()\n\t\t}\n\t}\n\treturn state, nil\n}\n\n// orderNamespacePaths sorts namespace paths into a list of paths that we\n// can setns in order.\nfunc (c *linuxContainer) orderNamespacePaths(namespaces map[configs.NamespaceType]string) ([]string, error) {\n\tpaths := []string{}\n\tfor _, ns := range configs.NamespaceTypes() {\n\n\t\t// Remove namespaces that we don't need to join.\n\t\tif !c.config.Namespaces.Contains(ns) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif p, ok := namespaces[ns]; ok && p != \"\" {\n\t\t\t// check if the requested namespace is supported\n\t\t\tif !configs.IsNamespaceSupported(ns) {\n\t\t\t\treturn nil, newSystemError(fmt.Errorf(\"namespace %s is not supported\", ns))\n\t\t\t}\n\t\t\t// only set to join this namespace if it exists\n\t\t\tif _, err := os.Lstat(p); err != nil {\n\t\t\t\treturn nil, newSystemErrorWithCausef(err, \"running lstat on namespace path %q\", p)\n\t\t\t}\n\t\t\t// do not allow namespace path with comma as we use it to separate\n\t\t\t// the namespace paths\n\t\t\tif strings.ContainsRune(p, ',') {\n\t\t\t\treturn nil, newSystemError(fmt.Errorf(\"invalid path %s\", p))\n\t\t\t}\n\t\t\tpaths = append(paths, fmt.Sprintf(\"%s:%s\", configs.NsName(ns), p))\n\t\t}\n\n\t}\n\n\treturn paths, nil\n}\n\nfunc encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n\tdata := bytes.NewBuffer(nil)\n\tfor _, im := range idMap {\n\t\tline := fmt.Sprintf(\"%d %d %d\\n\", im.ContainerID, im.HostID, im.Size)\n\t\tif _, err := data.WriteString(line); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn data.Bytes(), nil\n}\n\n// bootstrapData encodes the necessary data in netlink binary format\n// as a io.Reader.\n// Consumer can write the data to a bootstrap program\n// such as one that uses nsenter package to bootstrap the container's\n// init process correctly, i.e. with correct namespaces, uid/gid\n// mapping etc.\nfunc (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) {\n\t// create the netlink message\n\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n\n\t// write cloneFlags\n\tr.AddData(&Int32msg{\n\t\tType:  CloneFlagsAttr,\n\t\tValue: uint32(cloneFlags),\n\t})\n\n\t// write custom namespace paths\n\tif len(nsMaps) > 0 {\n\t\tnsPaths, err := c.orderNamespacePaths(nsMaps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  NsPathsAttr,\n\t\t\tValue: []byte(strings.Join(nsPaths, \",\")),\n\t\t})\n\t}\n\n\t// write namespace paths only when we are not joining an existing user ns\n\t_, joinExistingUser := nsMaps[configs.NEWUSER]\n\tif !joinExistingUser {\n\t\t// write uid mappings\n\t\tif len(c.config.UidMappings) > 0 {\n\t\t\tif c.config.RootlessEUID && c.newuidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  UidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newuidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tb, err := encodeIDMapping(c.config.UidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  UidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t}\n\n\t\t// write gid mappings\n\t\tif len(c.config.GidMappings) > 0 {\n\t\t\tb, err := encodeIDMapping(c.config.GidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  GidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t\tif c.config.RootlessEUID && c.newgidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  GidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newgidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tif requiresRootOrMappingTool(c.config) {\n\t\t\t\tr.AddData(&Boolmsg{\n\t\t\t\t\tType:  SetgroupAttr,\n\t\t\t\t\tValue: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.config.OomScoreAdj != nil {\n\t\t// write oom_score_adj\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  OomScoreAdjAttr,\n\t\t\tValue: []byte(strconv.Itoa(*c.config.OomScoreAdj)),\n\t\t})\n\t}\n\n\t// write rootless\n\tr.AddData(&Boolmsg{\n\t\tType:  RootlessEUIDAttr,\n\t\tValue: c.config.RootlessEUID,\n\t})\n\n\treturn bytes.NewReader(r.Serialize()), nil\n}\n\n// ignoreTerminateErrors returns nil if the given err matches an error known\n// to indicate that the terminate occurred successfully or err was nil, otherwise\n// err is returned unaltered.\nfunc ignoreTerminateErrors(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// terminate() might return an error from ether Kill or Wait.\n\t// The (*Cmd).Wait documentation says: \"If the command fails to run\n\t// or doesn't complete successfully, the error is of type *ExitError\".\n\t// Filter out such errors (like \"exit status 1\" or \"signal: killed\").\n\tvar exitErr *exec.ExitError\n\tif errors.As(err, &exitErr) {\n\t\treturn nil\n\t}\n\t// TODO: use errors.Is(err, os.ErrProcessDone) here and\n\t// remove \"process already finished\" string comparison below\n\t// once go 1.16 is minimally supported version.\n\n\ts := err.Error()\n\tif strings.Contains(s, \"process already finished\") ||\n\t\tstrings.Contains(s, \"Wait was already called\") {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc requiresRootOrMappingTool(c *configs.Config) bool {\n\tgidMap := []configs.IDMap{\n\t\t{ContainerID: 0, HostID: os.Getegid(), Size: 1},\n\t}\n\treturn !reflect.DeepEqual(c.GidMappings, gidMap)\n}\n", "// +build linux\n\npackage libcontainer\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"github.com/mrunalp/fileutils\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/fs2\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/userns\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\tlibcontainerUtils \"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype mountConfig struct {\n\troot            string\n\tlabel           string\n\tcgroup2Path     string\n\trootlessCgroups bool\n\tcgroupns        bool\n}\n\n// needsSetupDev returns true if /dev needs to be set up.\nfunc needsSetupDev(config *configs.Config) bool {\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"bind\" && libcontainerUtils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// prepareRootfs sets up the devices, mount points, and filesystems for use\n// inside a new mount namespace. It doesn't set anything as ro. You must call\n// finalizeRootfs after this function to finish setting up the rootfs.\nfunc prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {\n\tconfig := iConfig.Config\n\tif err := prepareRoot(config); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"preparing rootfs\")\n\t}\n\n\tmountConfig := &mountConfig{\n\t\troot:            config.Rootfs,\n\t\tlabel:           config.MountLabel,\n\t\tcgroup2Path:     iConfig.Cgroup2Path,\n\t\trootlessCgroups: iConfig.RootlessCgroups,\n\t\tcgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),\n\t}\n\tsetupDev := needsSetupDev(config)\n\tfor _, m := range config.Mounts {\n\t\tfor _, precmd := range m.PremountCmds {\n\t\t\tif err := mountCmd(precmd); err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"running premount command\")\n\t\t\t}\n\t\t}\n\t\tif err := mountToRootfs(m, mountConfig); err != nil {\n\t\t\treturn newSystemErrorWithCausef(err, \"mounting %q to rootfs at %q\", m.Source, m.Destination)\n\t\t}\n\n\t\tfor _, postcmd := range m.PostmountCmds {\n\t\t\tif err := mountCmd(postcmd); err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"running postmount command\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif setupDev {\n\t\tif err := createDevices(config); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"creating device nodes\")\n\t\t}\n\t\tif err := setupPtmx(config); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting up ptmx\")\n\t\t}\n\t\tif err := setupDevSymlinks(config.Rootfs); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting up /dev symlinks\")\n\t\t}\n\t}\n\n\t// Signal the parent to run the pre-start hooks.\n\t// The hooks are run after the mounts are setup, but before we switch to the new\n\t// root, so that the old root is still available in the hooks for any mount\n\t// manipulations.\n\t// Note that iConfig.Cwd is not guaranteed to exist here.\n\tif err := syncParentHooks(pipe); err != nil {\n\t\treturn err\n\t}\n\n\t// The reason these operations are done here rather than in finalizeRootfs\n\t// is because the console-handling code gets quite sticky if we have to set\n\t// up the console before doing the pivot_root(2). This is because the\n\t// Console API has to also work with the ExecIn case, which means that the\n\t// API must be able to deal with being inside as well as outside the\n\t// container. It's just cleaner to do this here (at the expense of the\n\t// operation not being perfectly split).\n\n\tif err := unix.Chdir(config.Rootfs); err != nil {\n\t\treturn newSystemErrorWithCausef(err, \"changing dir to %q\", config.Rootfs)\n\t}\n\n\ts := iConfig.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreating\n\tif err := iConfig.Config.Hooks[configs.CreateContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif config.NoPivotRoot {\n\t\terr = msMoveRoot(config.Rootfs)\n\t} else if config.Namespaces.Contains(configs.NEWNS) {\n\t\terr = pivotRoot(config.Rootfs)\n\t} else {\n\t\terr = chroot()\n\t}\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"jailing process inside rootfs\")\n\t}\n\n\tif setupDev {\n\t\tif err := reOpenDevNull(); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"reopening /dev/null inside container\")\n\t\t}\n\t}\n\n\tif cwd := iConfig.Cwd; cwd != \"\" {\n\t\t// Note that spec.Process.Cwd can contain unclean value like  \"../../../../foo/bar...\".\n\t\t// However, we are safe to call MkDirAll directly because we are in the jail here.\n\t\tif err := os.MkdirAll(cwd, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// finalizeRootfs sets anything to ro if necessary. You must call\n// prepareRootfs first.\nfunc finalizeRootfs(config *configs.Config) (err error) {\n\t// remount dev as ro if specified\n\tfor _, m := range config.Mounts {\n\t\tif libcontainerUtils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\tif m.Flags&unix.MS_RDONLY == unix.MS_RDONLY {\n\t\t\t\tif err := remountReadonly(m); err != nil {\n\t\t\t\t\treturn newSystemErrorWithCausef(err, \"remounting %q as readonly\", m.Destination)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// set rootfs ( / ) as readonly\n\tif config.Readonlyfs {\n\t\tif err := setReadonly(); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting rootfs as readonly\")\n\t\t}\n\t}\n\n\tif config.Umask != nil {\n\t\tunix.Umask(int(*config.Umask))\n\t} else {\n\t\tunix.Umask(0022)\n\t}\n\treturn nil\n}\n\n// /tmp has to be mounted as private to allow MS_MOVE to work in all situations\nfunc prepareTmp(topTmpDir string) (string, error) {\n\ttmpdir, err := ioutil.TempDir(topTmpDir, \"runctop\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := unix.Mount(tmpdir, tmpdir, \"bind\", unix.MS_BIND, \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := unix.Mount(\"\", tmpdir, \"\", uintptr(unix.MS_PRIVATE), \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tmpdir, nil\n}\n\nfunc cleanupTmp(tmpdir string) error {\n\tunix.Unmount(tmpdir, 0)\n\treturn os.RemoveAll(tmpdir)\n}\n\nfunc mountCmd(cmd configs.Command) error {\n\tcommand := exec.Command(cmd.Path, cmd.Args[:]...)\n\tcommand.Env = cmd.Env\n\tcommand.Dir = cmd.Dir\n\tif out, err := command.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"%#v failed: %s: %v\", cmd, string(out), err)\n\t}\n\treturn nil\n}\n\nfunc prepareBindMount(m *configs.Mount, rootfs string) error {\n\tstat, err := os.Stat(m.Source)\n\tif err != nil {\n\t\t// error out if the source of a bind mount does not exist as we will be\n\t\t// unable to bind anything to it.\n\t\treturn err\n\t}\n\t// ensure that the destination of the bind mount is resolved of symlinks at mount time because\n\t// any previous mounts can invalidate the next mount's destination.\n\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n\t// evil stuff to try to escape the container's rootfs.\n\tvar dest string\n\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n\t\treturn err\n\t}\n\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\treturn err\n\t}\n\tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n\tbinds, err := getCgroupMounts(m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar merged []string\n\tfor _, b := range binds {\n\t\tss := filepath.Base(b.Destination)\n\t\tif strings.Contains(ss, \",\") {\n\t\t\tmerged = append(merged, ss)\n\t\t}\n\t}\n\ttmpfs := &configs.Mount{\n\t\tSource:           \"tmpfs\",\n\t\tDevice:           \"tmpfs\",\n\t\tDestination:      m.Destination,\n\t\tFlags:            defaultMountFlags,\n\t\tData:             \"mode=755\",\n\t\tPropagationFlags: m.PropagationFlags,\n\t}\n\tif err := mountToRootfs(tmpfs, c); err != nil {\n\t\treturn err\n\t}\n\tfor _, b := range binds {\n\t\tif c.cgroupns {\n\t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n\t\t\tif err := os.MkdirAll(subsystemPath, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := utils.WithProcfd(c.root, b.Destination, func(procfd string) error {\n\t\t\t\tflags := defaultMountFlags\n\t\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\t\t\tflags = flags | unix.MS_RDONLY\n\t\t\t\t}\n\t\t\t\tvar (\n\t\t\t\t\tsource = \"cgroup\"\n\t\t\t\t\tdata   = filepath.Base(subsystemPath)\n\t\t\t\t)\n\t\t\t\tif data == \"systemd\" {\n\t\t\t\t\tdata = cgroups.CgroupNamePrefix + data\n\t\t\t\t\tsource = \"systemd\"\n\t\t\t\t}\n\t\t\t\treturn unix.Mount(source, procfd, \"cgroup\", uintptr(flags), data)\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := mountToRootfs(b, c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor _, mc := range merged {\n\t\tfor _, ss := range strings.Split(mc, \",\") {\n\t\t\t// symlink(2) is very dumb, it will just shove the path into\n\t\t\t// the link and doesn't do any checks or relative path\n\t\t\t// conversion. Also, don't error out if the cgroup already exists.\n\t\t\tif err := os.Symlink(mc, filepath.Join(c.root, m.Destination, ss)); err != nil && !os.IsExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n\tdest, err := securejoin.SecureJoin(c.root, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\treturn err\n\t}\n\treturn utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n\t\tif err := unix.Mount(m.Source, procfd, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n\t\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n\t\t\tif err == unix.EPERM || err == unix.EBUSY {\n\t\t\t\tsrc := fs2.UnifiedMountpoint\n\t\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n\t\t\t\t\t// Emulate cgroupns by bind-mounting\n\t\t\t\t\t// the container cgroup path rather than\n\t\t\t\t\t// the whole /sys/fs/cgroup.\n\t\t\t\t\tsrc = c.cgroup2Path\n\t\t\t\t}\n\t\t\t\terr = unix.Mount(src, procfd, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n\t\t\t\tif err == unix.ENOENT && c.rootlessCgroups {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n\t// Set up a scratch dir for the tmpfs on the host.\n\ttmpdir, err := prepareTmp(\"/tmp\")\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to setup tmpdir\")\n\t}\n\tdefer cleanupTmp(tmpdir)\n\ttmpDir, err := ioutil.TempDir(tmpdir, \"runctmpdir\")\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to create tmpdir\")\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\t// Configure the *host* tmpdir as if it's the container mount. We change\n\t// m.Destination since we are going to mount *on the host*.\n\toldDest := m.Destination\n\tm.Destination = tmpDir\n\terr = mountPropagate(m, \"/\", mountLabel)\n\tm.Destination = oldDest\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif Err != nil {\n\t\t\tif err := unix.Unmount(tmpDir, unix.MNT_DETACH); err != nil {\n\t\t\t\tlogrus.Warnf(\"tmpcopyup: failed to unmount tmpdir on error: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) (Err error) {\n\t\t// Copy the container data to the host tmpdir. We append \"/\" to force\n\t\t// CopyDirectory to resolve the symlink rather than trying to copy the\n\t\t// symlink itself.\n\t\tif err := fileutils.CopyDirectory(procfd+\"/\", tmpDir); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to copy %s to %s (%s): %w\", m.Destination, procfd, tmpDir, err)\n\t\t}\n\t\t// Now move the mount into the container.\n\t\tif err := unix.Mount(tmpDir, procfd, \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to move mount %s to %s (%s): %w\", tmpDir, procfd, m.Destination, err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc mountToRootfs(m *configs.Mount, c *mountConfig) error {\n\trootfs := c.root\n\tmountLabel := c.label\n\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch m.Device {\n\tcase \"proc\", \"sysfs\":\n\t\t// If the destination already exists and is not a directory, we bail\n\t\t// out This is to avoid mounting through a symlink or similar -- which\n\t\t// has been a \"fun\" attack scenario in the past.\n\t\t// TODO: This won't be necessary once we switch to libpathrs and we can\n\t\t//       stop all of these symlink-exchange attacks.\n\t\tif fi, err := os.Lstat(dest); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if fi.Mode()&os.ModeDir == 0 {\n\t\t\treturn fmt.Errorf(\"filesystem %q must be mounted on ordinary directory\", m.Device)\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Selinux kernels do not support labeling of /proc or /sys\n\t\treturn mountPropagate(m, rootfs, \"\")\n\tcase \"mqueue\":\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn label.SetFileLabel(dest, mountLabel)\n\tcase \"tmpfs\":\n\t\tstat, err := os.Stat(dest)\n\t\tif err != nil {\n\t\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {\n\t\t\terr = doTmpfsCopyUp(m, rootfs, mountLabel)\n\t\t} else {\n\t\t\terr = mountPropagate(m, rootfs, mountLabel)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif stat != nil {\n\t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// Initially mounted rw in mountPropagate, remount to ro if flag set.\n\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\tif err := remount(m, rootfs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\tcase \"bind\":\n\t\tif err := prepareBindMount(m, rootfs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, mountLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// bind mount won't change mount options, we need remount to make mount options effective.\n\t\t// first check that we have non-default options required before attempting a remount\n\t\tif m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {\n\t\t\t// only remount if unique mount options are set\n\t\t\tif err := remount(m, rootfs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Relabel != \"\" {\n\t\t\tif err := label.Validate(m.Relabel); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tshared := label.IsShared(m.Relabel)\n\t\t\tif err := label.Relabel(m.Source, mountLabel, shared); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"cgroup\":\n\t\tif cgroups.IsCgroup2UnifiedMode() {\n\t\t\treturn mountCgroupV2(m, c)\n\t\t}\n\t\treturn mountCgroupV1(m, c)\n\tdefault:\n\t\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn mountPropagate(m, rootfs, mountLabel)\n\t}\n\treturn nil\n}\n\nfunc getCgroupMounts(m *configs.Mount) ([]*configs.Mount, error) {\n\tmounts, err := cgroups.GetCgroupMounts(false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcgroupPaths, err := cgroups.ParseCgroupFile(\"/proc/self/cgroup\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar binds []*configs.Mount\n\n\tfor _, mm := range mounts {\n\t\tdir, err := mm.GetOwnCgroup(cgroupPaths)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trelDir, err := filepath.Rel(mm.Root, dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbinds = append(binds, &configs.Mount{\n\t\t\tDevice:           \"bind\",\n\t\t\tSource:           filepath.Join(mm.Mountpoint, relDir),\n\t\t\tDestination:      filepath.Join(m.Destination, filepath.Base(mm.Mountpoint)),\n\t\t\tFlags:            unix.MS_BIND | unix.MS_REC | m.Flags,\n\t\t\tPropagationFlags: m.PropagationFlags,\n\t\t})\n\t}\n\n\treturn binds, nil\n}\n\n// checkProcMount checks to ensure that the mount destination is not over the top of /proc.\n// dest is required to be an abs path and have any symlinks resolved before calling this function.\n//\n// if source is nil, don't stat the filesystem.  This is used for restore of a checkpoint.\nfunc checkProcMount(rootfs, dest, source string) error {\n\tconst procPath = \"/proc\"\n\tpath, err := filepath.Rel(filepath.Join(rootfs, procPath), dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// pass if the mount path is located outside of /proc\n\tif strings.HasPrefix(path, \"..\") {\n\t\treturn nil\n\t}\n\tif path == \".\" {\n\t\t// an empty source is pasted on restore\n\t\tif source == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t// only allow a mount on-top of proc if it's source is \"proc\"\n\t\tisproc, err := isProc(source)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// pass if the mount is happening on top of /proc and the source of\n\t\t// the mount is a proc filesystem\n\t\tif isproc {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"%q cannot be mounted because it is not of type proc\", dest)\n\t}\n\n\t// Here dest is definitely under /proc. Do not allow those,\n\t// except for a few specific entries emulated by lxcfs.\n\tvalidProcMounts := []string{\n\t\t\"/proc/cpuinfo\",\n\t\t\"/proc/diskstats\",\n\t\t\"/proc/meminfo\",\n\t\t\"/proc/stat\",\n\t\t\"/proc/swaps\",\n\t\t\"/proc/uptime\",\n\t\t\"/proc/loadavg\",\n\t\t\"/proc/slabinfo\",\n\t\t\"/proc/net/dev\",\n\t}\n\tfor _, valid := range validProcMounts {\n\t\tpath, err := filepath.Rel(filepath.Join(rootfs, valid), dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path == \".\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%q cannot be mounted because it is inside /proc\", dest)\n}\n\nfunc isProc(path string) (bool, error) {\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn false, err\n\t}\n\treturn s.Type == unix.PROC_SUPER_MAGIC, nil\n}\n\nfunc setupDevSymlinks(rootfs string) error {\n\tvar links = [][2]string{\n\t\t{\"/proc/self/fd\", \"/dev/fd\"},\n\t\t{\"/proc/self/fd/0\", \"/dev/stdin\"},\n\t\t{\"/proc/self/fd/1\", \"/dev/stdout\"},\n\t\t{\"/proc/self/fd/2\", \"/dev/stderr\"},\n\t}\n\t// kcore support can be toggled with CONFIG_PROC_KCORE; only create a symlink\n\t// in /dev if it exists in /proc.\n\tif _, err := os.Stat(\"/proc/kcore\"); err == nil {\n\t\tlinks = append(links, [2]string{\"/proc/kcore\", \"/dev/core\"})\n\t}\n\tfor _, link := range links {\n\t\tvar (\n\t\t\tsrc = link[0]\n\t\t\tdst = filepath.Join(rootfs, link[1])\n\t\t)\n\t\tif err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {\n\t\t\treturn fmt.Errorf(\"symlink %s %s %s\", src, dst, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// If stdin, stdout, and/or stderr are pointing to `/dev/null` in the parent's rootfs\n// this method will make them point to `/dev/null` in this container's rootfs.  This\n// needs to be called after we chroot/pivot into the container's rootfs so that any\n// symlinks are resolved locally.\nfunc reOpenDevNull() error {\n\tvar stat, devNullStat unix.Stat_t\n\tfile, err := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to open /dev/null - %s\", err)\n\t}\n\tdefer file.Close()\n\tif err := unix.Fstat(int(file.Fd()), &devNullStat); err != nil {\n\t\treturn err\n\t}\n\tfor fd := 0; fd < 3; fd++ {\n\t\tif err := unix.Fstat(fd, &stat); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif stat.Rdev == devNullStat.Rdev {\n\t\t\t// Close and re-open the fd.\n\t\t\tif err := unix.Dup3(int(file.Fd()), fd, 0); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Create the device nodes in the container.\nfunc createDevices(config *configs.Config) error {\n\tuseBindMount := userns.RunningInUserNS() || config.Namespaces.Contains(configs.NEWUSER)\n\toldMask := unix.Umask(0000)\n\tfor _, node := range config.Devices {\n\n\t\t// The /dev/ptmx device is setup by setupPtmx()\n\t\tif utils.CleanPath(node.Path) == \"/dev/ptmx\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// containers running in a user namespace are not allowed to mknod\n\t\t// devices so we can just bind mount it from the host.\n\t\tif err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {\n\t\t\tunix.Umask(oldMask)\n\t\t\treturn err\n\t\t}\n\t}\n\tunix.Umask(oldMask)\n\treturn nil\n}\n\nfunc bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {\n\tf, err := os.Create(dest)\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tif f != nil {\n\t\tf.Close()\n\t}\n\treturn utils.WithProcfd(rootfs, dest, func(procfd string) error {\n\t\treturn unix.Mount(node.Path, procfd, \"bind\", unix.MS_BIND, \"\")\n\t})\n}\n\n// Creates the device node in the rootfs of the container.\nfunc createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n\tif node.Path == \"\" {\n\t\t// The node only exists for cgroup reasons, ignore it here.\n\t\treturn nil\n\t}\n\tdest, err := securejoin.SecureJoin(rootfs, node.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(filepath.Dir(dest), 0755); err != nil {\n\t\treturn err\n\t}\n\tif bind {\n\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t}\n\tif err := mknodDevice(dest, node); err != nil {\n\t\tif os.IsExist(err) {\n\t\t\treturn nil\n\t\t} else if os.IsPermission(err) {\n\t\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc mknodDevice(dest string, node *devices.Device) error {\n\tfileMode := node.FileMode\n\tswitch node.Type {\n\tcase devices.BlockDevice:\n\t\tfileMode |= unix.S_IFBLK\n\tcase devices.CharDevice:\n\t\tfileMode |= unix.S_IFCHR\n\tcase devices.FifoDevice:\n\t\tfileMode |= unix.S_IFIFO\n\tdefault:\n\t\treturn fmt.Errorf(\"%c is not a valid device type for device %s\", node.Type, node.Path)\n\t}\n\tdev, err := node.Mkdev()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Mknod(dest, uint32(fileMode), int(dev)); err != nil {\n\t\treturn err\n\t}\n\treturn unix.Chown(dest, int(node.Uid), int(node.Gid))\n}\n\n// Get the parent mount point of directory passed in as argument. Also return\n// optional fields.\nfunc getParentMount(rootfs string) (string, string, error) {\n\tmi, err := mountinfo.GetMounts(mountinfo.ParentsFilter(rootfs))\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tif len(mi) < 1 {\n\t\treturn \"\", \"\", fmt.Errorf(\"could not find parent mount of %s\", rootfs)\n\t}\n\n\t// find the longest mount point\n\tvar idx, maxlen int\n\tfor i := range mi {\n\t\tif len(mi[i].Mountpoint) > maxlen {\n\t\t\tmaxlen = len(mi[i].Mountpoint)\n\t\t\tidx = i\n\t\t}\n\t}\n\treturn mi[idx].Mountpoint, mi[idx].Optional, nil\n}\n\n// Make parent mount private if it was shared\nfunc rootfsParentMountPrivate(rootfs string) error {\n\tsharedMount := false\n\n\tparentMount, optionalOpts, err := getParentMount(rootfs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toptsSplit := strings.Split(optionalOpts, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\tsharedMount = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Make parent mount PRIVATE if it was shared. It is needed for two\n\t// reasons. First of all pivot_root() will fail if parent mount is\n\t// shared. Secondly when we bind mount rootfs it will propagate to\n\t// parent namespace and we don't want that to happen.\n\tif sharedMount {\n\t\treturn unix.Mount(\"\", parentMount, \"\", unix.MS_PRIVATE, \"\")\n\t}\n\n\treturn nil\n}\n\nfunc prepareRoot(config *configs.Config) error {\n\tflag := unix.MS_SLAVE | unix.MS_REC\n\tif config.RootPropagation != 0 {\n\t\tflag = config.RootPropagation\n\t}\n\tif err := unix.Mount(\"\", \"/\", \"\", uintptr(flag), \"\"); err != nil {\n\t\treturn err\n\t}\n\n\t// Make parent mount private to make sure following bind mount does\n\t// not propagate in other namespaces. Also it will help with kernel\n\t// check pass in pivot_root. (IS_SHARED(new_mnt->mnt_parent))\n\tif err := rootfsParentMountPrivate(config.Rootfs); err != nil {\n\t\treturn err\n\t}\n\n\treturn unix.Mount(config.Rootfs, config.Rootfs, \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n}\n\nfunc setReadonly() error {\n\tflags := uintptr(unix.MS_BIND | unix.MS_REMOUNT | unix.MS_RDONLY)\n\n\terr := unix.Mount(\"\", \"/\", \"\", flags, \"\")\n\tif err == nil {\n\t\treturn nil\n\t}\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(\"/\", &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: \"/\", Err: err}\n\t}\n\tflags |= uintptr(s.Flags)\n\treturn unix.Mount(\"\", \"/\", \"\", flags, \"\")\n\n}\n\nfunc setupPtmx(config *configs.Config) error {\n\tptmx := filepath.Join(config.Rootfs, \"dev/ptmx\")\n\tif err := os.Remove(ptmx); err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\tif err := os.Symlink(\"pts/ptmx\", ptmx); err != nil {\n\t\treturn fmt.Errorf(\"symlink dev ptmx %s\", err)\n\t}\n\treturn nil\n}\n\n// pivotRoot will call pivot_root such that rootfs becomes the new root\n// filesystem, and everything else is cleaned up.\nfunc pivotRoot(rootfs string) error {\n\t// While the documentation may claim otherwise, pivot_root(\".\", \".\") is\n\t// actually valid. What this results in is / being the new root but\n\t// /proc/self/cwd being the old root. Since we can play around with the cwd\n\t// with pivot_root this allows us to pivot without creating directories in\n\t// the rootfs. Shout-outs to the LXC developers for giving us this idea.\n\n\toldroot, err := unix.Open(\"/\", unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Close(oldroot)\n\n\tnewroot, err := unix.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Close(newroot)\n\n\t// Change to the new root so that the pivot_root actually acts on it.\n\tif err := unix.Fchdir(newroot); err != nil {\n\t\treturn err\n\t}\n\n\tif err := unix.PivotRoot(\".\", \".\"); err != nil {\n\t\treturn fmt.Errorf(\"pivot_root %s\", err)\n\t}\n\n\t// Currently our \".\" is oldroot (according to the current kernel code).\n\t// However, purely for safety, we will fchdir(oldroot) since there isn't\n\t// really any guarantee from the kernel what /proc/self/cwd will be after a\n\t// pivot_root(2).\n\n\tif err := unix.Fchdir(oldroot); err != nil {\n\t\treturn err\n\t}\n\n\t// Make oldroot rslave to make sure our unmounts don't propagate to the\n\t// host (and thus bork the machine). We don't use rprivate because this is\n\t// known to cause issues due to races where we still have a reference to a\n\t// mount while a process in the host namespace are trying to operate on\n\t// something they think has no mounts (devicemapper in particular).\n\tif err := unix.Mount(\"\", \".\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\treturn err\n\t}\n\t// Preform the unmount. MNT_DETACH allows us to unmount /proc/self/cwd.\n\tif err := unix.Unmount(\".\", unix.MNT_DETACH); err != nil {\n\t\treturn err\n\t}\n\n\t// Switch back to our shiny new root.\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn fmt.Errorf(\"chdir / %s\", err)\n\t}\n\treturn nil\n}\n\nfunc msMoveRoot(rootfs string) error {\n\t// Before we move the root and chroot we have to mask all \"full\" sysfs and\n\t// procfs mounts which exist on the host. This is because while the kernel\n\t// has protections against mounting procfs if it has masks, when using\n\t// chroot(2) the *host* procfs mount is still reachable in the mount\n\t// namespace and the kernel permits procfs mounts inside --no-pivot\n\t// containers.\n\t//\n\t// Users shouldn't be using --no-pivot except in exceptional circumstances,\n\t// but to avoid such a trivial security flaw we apply a best-effort\n\t// protection here. The kernel only allows a mount of a pseudo-filesystem\n\t// like procfs or sysfs if there is a *full* mount (the root of the\n\t// filesystem is mounted) without any other locked mount points covering a\n\t// subtree of the mount.\n\t//\n\t// So we try to unmount (or mount tmpfs on top of) any mountpoint which is\n\t// a full mount of either sysfs or procfs (since those are the most\n\t// concerning filesystems to us).\n\tmountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {\n\t\t// Collect every sysfs and procfs filesystem, except for those which\n\t\t// are non-full mounts or are inside the rootfs of the container.\n\t\tif info.Root != \"/\" ||\n\t\t\t(info.FSType != \"proc\" && info.FSType != \"sysfs\") ||\n\t\t\tstrings.HasPrefix(info.Mountpoint, rootfs) {\n\t\t\tskip = true\n\t\t}\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, info := range mountinfos {\n\t\tp := info.Mountpoint\n\t\t// Be sure umount events are not propagated to the host.\n\t\tif err := unix.Mount(\"\", p, \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\t\tif err == unix.ENOENT {\n\t\t\t\t// If the mountpoint doesn't exist that means that we've\n\t\t\t\t// already blasted away some parent directory of the mountpoint\n\t\t\t\t// and so we don't care about this error.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif err := unix.Unmount(p, unix.MNT_DETACH); err != nil {\n\t\t\tif err != unix.EINVAL && err != unix.EPERM {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\t// If we have not privileges for umounting (e.g. rootless), then\n\t\t\t\t// cover the path.\n\t\t\t\tif err := unix.Mount(\"tmpfs\", p, \"tmpfs\", 0, \"\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move the rootfs on top of \"/\" in our mount namespace.\n\tif err := unix.Mount(rootfs, \"/\", \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn chroot()\n}\n\nfunc chroot() error {\n\tif err := unix.Chroot(\".\"); err != nil {\n\t\treturn err\n\t}\n\treturn unix.Chdir(\"/\")\n}\n\n// createIfNotExists creates a file or a directory only if it does not already exist.\nfunc createIfNotExists(path string, isDir bool) error {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif isDir {\n\t\t\t\treturn os.MkdirAll(path, 0755)\n\t\t\t}\n\t\t\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf, err := os.OpenFile(path, os.O_CREATE, 0755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf.Close()\n\t\t}\n\t}\n\treturn nil\n}\n\n// readonlyPath will make a path read only.\nfunc readonlyPath(path string) error {\n\tif err := unix.Mount(path, path, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn &os.PathError{Op: \"bind-mount\", Path: path, Err: err}\n\t}\n\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tflags := uintptr(s.Flags) & (unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC)\n\n\tif err := unix.Mount(path, path, \"\", flags|unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, \"\"); err != nil {\n\t\treturn &os.PathError{Op: \"bind-mount-ro\", Path: path, Err: err}\n\t}\n\n\treturn nil\n}\n\n// remountReadonly will remount an existing mount point and ensure that it is read-only.\nfunc remountReadonly(m *configs.Mount) error {\n\tvar (\n\t\tdest  = m.Destination\n\t\tflags = m.Flags\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\t// There is a special case in the kernel for\n\t\t// MS_REMOUNT | MS_BIND, which allows us to change only the\n\t\t// flags even as an unprivileged user (i.e. user namespace)\n\t\t// assuming we don't drop any security related flags (nodev,\n\t\t// nosuid, etc.). So, let's use that case so that we can do\n\t\t// this re-mount without failing in a userns.\n\t\tflags |= unix.MS_REMOUNT | unix.MS_BIND | unix.MS_RDONLY\n\t\tif err := unix.Mount(\"\", dest, \"\", uintptr(flags), \"\"); err != nil {\n\t\t\tswitch err {\n\t\t\tcase unix.EBUSY:\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unable to mount %s as readonly max retries reached\", dest)\n}\n\n// maskPath masks the top of the specified path inside a container to avoid\n// security issues from processes reading information from non-namespace aware\n// mounts ( proc/kcore ).\n// For files, maskPath bind mounts /dev/null over the top of the specified path.\n// For directories, maskPath mounts read-only tmpfs over the top of the specified path.\nfunc maskPath(path string, mountLabel string) error {\n\tif err := unix.Mount(\"/dev/null\", path, \"\", unix.MS_BIND, \"\"); err != nil && !os.IsNotExist(err) {\n\t\tif err == unix.ENOTDIR {\n\t\t\treturn unix.Mount(\"tmpfs\", path, \"tmpfs\", unix.MS_RDONLY, label.FormatMountLabel(\"\", mountLabel))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// writeSystemProperty writes the value to a path under /proc/sys as determined from the key.\n// For e.g. net.ipv4.ip_forward translated to /proc/sys/net/ipv4/ip_forward.\nfunc writeSystemProperty(key, value string) error {\n\tkeyPath := strings.Replace(key, \".\", \"/\", -1)\n\treturn ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0644)\n}\n\nfunc remount(m *configs.Mount, rootfs string) error {\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn unix.Mount(m.Source, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n\t})\n}\n\n// Do the mount operation followed by additional mounts required to take care\n// of propagation flags. This will always be scoped inside the container rootfs.\nfunc mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {\n\tvar (\n\t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n\t\tflags = m.Flags\n\t)\n\t// Delay mounting the filesystem read-only if we need to do further\n\t// operations on it. We need to set up files in \"/dev\" and tmpfs mounts may\n\t// need to be chmod-ed after mounting. The mount will be remounted ro later\n\t// in finalizeRootfs() if necessary.\n\tif libcontainerUtils.CleanPath(m.Destination) == \"/dev\" || m.Device == \"tmpfs\" {\n\t\tflags &= ^unix.MS_RDONLY\n\t}\n\n\t// Because the destination is inside a container path which might be\n\t// mutating underneath us, we verify that we are actually going to mount\n\t// inside the container with WithProcfd() -- mounting through a procfd\n\t// mounts on the target.\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn unix.Mount(m.Source, procfd, m.Device, uintptr(flags), data)\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"mount through procfd: %w\", err)\n\t}\n\t// We have to apply mount propagation flags in a separate WithProcfd() call\n\t// because the previous call invalidates the passed procfd -- the mount\n\t// target needs to be re-opened.\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\tfor _, pflag := range m.PropagationFlags {\n\t\t\tif err := unix.Mount(\"\", procfd, \"\", uintptr(pflag), \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"change mount propagation through procfd: %w\", err)\n\t}\n\treturn nil\n}\n", "package utils\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unsafe\"\n\n\t\"github.com/cyphar/filepath-securejoin\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\texitSignalOffset = 128\n)\n\n// NativeEndian is the native byte order of the host system.\nvar NativeEndian binary.ByteOrder\n\nfunc init() {\n\t// Copied from <golang.org/x/net/internal/socket/sys.go>.\n\ti := uint32(1)\n\tb := (*[4]byte)(unsafe.Pointer(&i))\n\tif b[0] == 1 {\n\t\tNativeEndian = binary.LittleEndian\n\t} else {\n\t\tNativeEndian = binary.BigEndian\n\t}\n}\n\n// ResolveRootfs ensures that the current working directory is\n// not a symlink and returns the absolute path to the rootfs\nfunc ResolveRootfs(uncleanRootfs string) (string, error) {\n\trootfs, err := filepath.Abs(uncleanRootfs)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn filepath.EvalSymlinks(rootfs)\n}\n\n// ExitStatus returns the correct exit status for a process based on if it\n// was signaled or exited cleanly\nfunc ExitStatus(status unix.WaitStatus) int {\n\tif status.Signaled() {\n\t\treturn exitSignalOffset + int(status.Signal())\n\t}\n\treturn status.ExitStatus()\n}\n\n// WriteJSON writes the provided struct v to w using standard json marshaling\nfunc WriteJSON(w io.Writer, v interface{}) error {\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(data)\n\treturn err\n}\n\n// CleanPath makes a path safe for use with filepath.Join. This is done by not\n// only cleaning the path, but also (if the path is relative) adding a leading\n// '/' and cleaning it (then removing the leading '/'). This ensures that a\n// path resulting from prepending another path will always resolve to lexically\n// be a subdirectory of the prefixed path. This is all done lexically, so paths\n// that include symlinks won't be safe as a result of using CleanPath.\nfunc CleanPath(path string) string {\n\t// Deal with empty strings nicely.\n\tif path == \"\" {\n\t\treturn \"\"\n\t}\n\n\t// Ensure that all paths are cleaned (especially problematic ones like\n\t// \"/../../../../../\" which can cause lots of issues).\n\tpath = filepath.Clean(path)\n\n\t// If the path isn't absolute, we need to do more processing to fix paths\n\t// such as \"../../../../<etc>/some/path\". We also shouldn't convert absolute\n\t// paths to relative ones.\n\tif !filepath.IsAbs(path) {\n\t\tpath = filepath.Clean(string(os.PathSeparator) + path)\n\t\t// This can't fail, as (by definition) all paths are relative to root.\n\t\tpath, _ = filepath.Rel(string(os.PathSeparator), path)\n\t}\n\n\t// Clean the path again for good measure.\n\treturn filepath.Clean(path)\n}\n\n// stripRoot returns the passed path, stripping the root path if it was\n// (lexicially) inside it. Note that both passed paths will always be treated\n// as absolute, and the returned path will also always be absolute. In\n// addition, the paths are cleaned before stripping the root.\nfunc stripRoot(root, path string) string {\n\t// Make the paths clean and absolute.\n\troot, path = CleanPath(\"/\"+root), CleanPath(\"/\"+path)\n\tswitch {\n\tcase path == root:\n\t\tpath = \"/\"\n\tcase root == \"/\":\n\t\t// do nothing\n\tcase strings.HasPrefix(path, root+\"/\"):\n\t\tpath = strings.TrimPrefix(path, root+\"/\")\n\t}\n\treturn CleanPath(\"/\" + path)\n}\n\n// WithProcfd runs the passed closure with a procfd path (/proc/self/fd/...)\n// corresponding to the unsafePath resolved within the root. Before passing the\n// fd, this path is verified to have been inside the root -- so operating on it\n// through the passed fdpath should be safe. Do not access this path through\n// the original path strings, and do not attempt to use the pathname outside of\n// the passed closure (the file handle will be freed once the closure returns).\nfunc WithProcfd(root, unsafePath string, fn func(procfd string) error) error {\n\t// Remove the root then forcefully resolve inside the root.\n\tunsafePath = stripRoot(root, unsafePath)\n\tpath, err := securejoin.SecureJoin(root, unsafePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"resolving path inside rootfs failed: %v\", err)\n\t}\n\n\t// Open the target path.\n\tfh, err := os.OpenFile(path, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"open o_path procfd: %w\", err)\n\t}\n\tdefer fh.Close()\n\n\t// Double-check the path is the one we expected.\n\tprocfd := \"/proc/self/fd/\" + strconv.Itoa(int(fh.Fd()))\n\tif realpath, err := os.Readlink(procfd); err != nil {\n\t\treturn fmt.Errorf(\"procfd verification failed: %w\", err)\n\t} else if realpath != path {\n\t\treturn fmt.Errorf(\"possibly malicious path detected -- refusing to operate on %s\", realpath)\n\t}\n\n\t// Run the closure.\n\treturn fn(procfd)\n}\n\n// SearchLabels searches a list of key-value pairs for the provided key and\n// returns the corresponding value. The pairs must be separated with '='.\nfunc SearchLabels(labels []string, query string) string {\n\tfor _, l := range labels {\n\t\tparts := strings.SplitN(l, \"=\", 2)\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif parts[0] == query {\n\t\t\treturn parts[1]\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// Annotations returns the bundle path and user defined annotations from the\n// libcontainer state.  We need to remove the bundle because that is a label\n// added by libcontainer.\nfunc Annotations(labels []string) (bundle string, userAnnotations map[string]string) {\n\tuserAnnotations = make(map[string]string)\n\tfor _, l := range labels {\n\t\tparts := strings.SplitN(l, \"=\", 2)\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif parts[0] == \"bundle\" {\n\t\t\tbundle = parts[1]\n\t\t} else {\n\t\t\tuserAnnotations[parts[0]] = parts[1]\n\t\t}\n\t}\n\treturn\n}\n", "package utils\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nvar labelTest = []struct {\n\tlabels        []string\n\tquery         string\n\texpectedValue string\n}{\n\t{[]string{\"bundle=/path/to/bundle\"}, \"bundle\", \"/path/to/bundle\"},\n\t{[]string{\"test=a\", \"test=b\"}, \"bundle\", \"\"},\n\t{[]string{\"bundle=a\", \"test=b\", \"bundle=c\"}, \"bundle\", \"a\"},\n\t{[]string{\"\", \"test=a\", \"bundle=b\"}, \"bundle\", \"b\"},\n\t{[]string{\"test\", \"bundle=a\"}, \"bundle\", \"a\"},\n\t{[]string{\"test=a\", \"bundle=\"}, \"bundle\", \"\"},\n}\n\nfunc TestSearchLabels(t *testing.T) {\n\tfor _, tt := range labelTest {\n\t\tif v := SearchLabels(tt.labels, tt.query); v != tt.expectedValue {\n\t\t\tt.Errorf(\"expected value '%s' for query '%s'; got '%s'\", tt.expectedValue, tt.query, v)\n\t\t}\n\t}\n}\n\nfunc TestResolveRootfs(t *testing.T) {\n\tdir := \"rootfs\"\n\tif err := os.Mkdir(dir, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(dir)\n\n\tpath, err := ResolveRootfs(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpwd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif path != pwd+\"/rootfs\" {\n\t\tt.Errorf(\"expected rootfs to be abs and was %s\", path)\n\t}\n}\n\nfunc TestResolveRootfsWithSymlink(t *testing.T) {\n\tdir := \"rootfs\"\n\ttmpDir, _ := filepath.EvalSymlinks(os.TempDir())\n\tif err := os.Symlink(tmpDir, dir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(dir)\n\n\tpath, err := ResolveRootfs(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif path != tmpDir {\n\t\tt.Errorf(\"expected rootfs to be the real path %s and was %s\", path, os.TempDir())\n\t}\n}\n\nfunc TestResolveRootfsWithNonExistingDir(t *testing.T) {\n\t_, err := ResolveRootfs(\"foo\")\n\tif err == nil {\n\t\tt.Error(\"expected error to happen but received nil\")\n\t}\n}\n\nfunc TestExitStatus(t *testing.T) {\n\tstatus := unix.WaitStatus(0)\n\tex := ExitStatus(status)\n\tif ex != 0 {\n\t\tt.Errorf(\"expected exit status to equal 0 and received %d\", ex)\n\t}\n}\n\nfunc TestExitStatusSignaled(t *testing.T) {\n\tstatus := unix.WaitStatus(2)\n\tex := ExitStatus(status)\n\tif ex != 130 {\n\t\tt.Errorf(\"expected exit status to equal 130 and received %d\", ex)\n\t}\n}\n\nfunc TestWriteJSON(t *testing.T) {\n\tperson := struct {\n\t\tName string\n\t\tAge  int\n\t}{\n\t\tName: \"Alice\",\n\t\tAge:  30,\n\t}\n\n\tvar b bytes.Buffer\n\terr := WriteJSON(&b, person)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := `{\"Name\":\"Alice\",\"Age\":30}`\n\tif b.String() != expected {\n\t\tt.Errorf(\"expected to write %s but was %s\", expected, b.String())\n\t}\n}\n\nfunc TestCleanPath(t *testing.T) {\n\tpath := CleanPath(\"\")\n\tif path != \"\" {\n\t\tt.Errorf(\"expected to receive empty string and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"rootfs\")\n\tif path != \"rootfs\" {\n\t\tt.Errorf(\"expected to receive 'rootfs' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"../../../var\")\n\tif path != \"var\" {\n\t\tt.Errorf(\"expected to receive 'var' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"/../../../var\")\n\tif path != \"/var\" {\n\t\tt.Errorf(\"expected to receive '/var' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"/foo/bar/\")\n\tif path != \"/foo/bar\" {\n\t\tt.Errorf(\"expected to receive '/foo/bar' and received %s\", path)\n\t}\n\n\tpath = CleanPath(\"/foo/bar/../\")\n\tif path != \"/foo\" {\n\t\tt.Errorf(\"expected to receive '/foo' and received %s\", path)\n\t}\n}\n\nfunc TestStripRoot(t *testing.T) {\n\tfor _, test := range []struct {\n\t\troot, path, out string\n\t}{\n\t\t// Works with multiple components.\n\t\t{\"/a/b\", \"/a/b/c\", \"/c\"},\n\t\t{\"/hello/world\", \"/hello/world/the/quick-brown/fox\", \"/the/quick-brown/fox\"},\n\t\t// '/' must be a no-op.\n\t\t{\"/\", \"/a/b/c\", \"/a/b/c\"},\n\t\t// Must be the correct order.\n\t\t{\"/a/b\", \"/a/c/b\", \"/a/c/b\"},\n\t\t// Must be at start.\n\t\t{\"/abc/def\", \"/foo/abc/def/bar\", \"/foo/abc/def/bar\"},\n\t\t// Must be a lexical parent.\n\t\t{\"/foo/bar\", \"/foo/barSAMECOMPONENT\", \"/foo/barSAMECOMPONENT\"},\n\t\t// Must only strip the root once.\n\t\t{\"/foo/bar\", \"/foo/bar/foo/bar/baz\", \"/foo/bar/baz\"},\n\t\t// Deal with .. in a fairly sane way.\n\t\t{\"/foo/bar\", \"/foo/bar/../baz\", \"/foo/baz\"},\n\t\t{\"/foo/bar\", \"../../../../../../foo/bar/baz\", \"/baz\"},\n\t\t{\"/foo/bar\", \"/../../../../../../foo/bar/baz\", \"/baz\"},\n\t\t{\"/foo/bar/../baz\", \"/foo/baz/bar\", \"/bar\"},\n\t\t{\"/foo/bar/../baz\", \"/foo/baz/../bar/../baz/./foo\", \"/foo\"},\n\t\t// All paths are made absolute before stripping.\n\t\t{\"foo/bar\", \"/foo/bar/baz/bee\", \"/baz/bee\"},\n\t\t{\"/foo/bar\", \"foo/bar/baz/beef\", \"/baz/beef\"},\n\t\t{\"foo/bar\", \"foo/bar/baz/beets\", \"/baz/beets\"},\n\t} {\n\t\tgot := stripRoot(test.root, test.path)\n\t\tif got != test.out {\n\t\t\tt.Errorf(\"stripRoot(%q, %q) -- got %q, expected %q\", test.root, test.path, got, test.out)\n\t\t}\n\t}\n}\n"], "filenames": ["libcontainer/container_linux.go", "libcontainer/rootfs_linux.go", "libcontainer/utils/utils.go", "libcontainer/utils/utils_test.go"], "buggy_code_start_loc": [1220, 27, 5, 145], "buggy_code_end_loc": [1286, 1085, 90, 145], "fixing_code_start_loc": [1219, 28, 6, 146], "fixing_code_end_loc": [1293, 1082, 145, 181], "type": "CWE-362", "message": "runc before 1.0.0-rc95 allows a Container Filesystem Breakout via Directory Traversal. To exploit the vulnerability, an attacker must be able to create multiple containers with a fairly specific mount configuration. The problem occurs via a symlink-exchange attack that relies on a race condition.", "other": {"cve": {"id": "CVE-2021-30465", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-27T13:15:08.077", "lastModified": "2023-03-27T18:15:10.693", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "runc before 1.0.0-rc95 allows a Container Filesystem Breakout via Directory Traversal. To exploit the vulnerability, an attacker must be able to create multiple containers with a fairly specific mount configuration. The problem occurs via a symlink-exchange attack that relies on a race condition."}, {"lang": "es", "value": "runc versiones anteriores a 1.0.0-rc95, permite un Container Filesystem Breakout por medio de un Salto de Directorio.&#xa0;Para explotar la vulnerabilidad, un atacante debe ser capaz de crear varios contenedores con una configuraci\u00f3n de montaje bastante espec\u00edfica.&#xa0;El problema ocurre por medio de un ataque de intercambio de enlaces simb\u00f3licos que se basa en una condici\u00f3n de carrera"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.1.1", "matchCriteriaId": "D522E8C1-E7F0-4A3D-AF68-6D962944A0E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "949172CC-EBB5-47F6-B987-207C802EED0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc10:*:*:*:*:*:*", "matchCriteriaId": "6E890B4D-9270-428B-8143-9B5124F0F96E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "F6D87B50-2849-4F4D-A0F9-4F7EBA3C2647"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "3E580E25-F94C-4DA4-8718-15D5F1C3ADAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "FD565CE0-D9E9-4FD9-8998-8AC55030FAB7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "093326B1-448C-4E3B-886D-CAC8B6813BFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "F672C421-789D-4F21-B483-DA3EB251BA1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "E13C190A-D7CE-4204-8CEF-B7317D3FFBF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc8:*:*:*:*:*:*", "matchCriteriaId": "15AEA3E2-A82F-4562-AFE6-B83A767B94E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc9:*:*:*:*:*:*", "matchCriteriaId": "EB5109FF-7C41-477E-B817-F63F06D866C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc90:*:*:*:*:*:*", "matchCriteriaId": "B6B8085F-4B68-47E4-8B4B-FB8C2742EEF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc91:*:*:*:*:*:*", "matchCriteriaId": "978AFEA7-C64F-4B24-B314-4E0E7D5C521A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc92:*:*:*:*:*:*", "matchCriteriaId": "A134E568-C11C-4D12-9B61-BFA58A080B96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc93:*:*:*:*:*:*", "matchCriteriaId": "6FAC79BA-7A2A-45E3-8806-E2C812991ACC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:1.0.0:rc94:*:*:*:*:*:*", "matchCriteriaId": "151570F5-F04B-4F31-AE6E-F364FC8AC01C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/05/19/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.opensuse.org/show_bug.cgi?id=1185405", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/security/advisories/GHSA-c3xm-pvg7-gh7r", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00023.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/35ZW6NBZSBH5PWIT7JU4HXOXGFVDCOHH/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4HOARVIT47RULTTFWAU7XBG4WY6TDDHV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-26", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210708-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f"}}