{"buggy_code": ["// Copyright 2020-2023 Project Capsule Authors.\n// SPDX-License-Identifier: Apache-2.0\n\npackage request\n\nimport (\n\t\"fmt\"\n\th \"net/http\"\n\t\"strings\"\n\n\tauthenticationv1 \"k8s.io/api/authentication/v1\"\n\tauthorizationv1 \"k8s.io/api/authorization/v1\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n)\n\ntype http struct {\n\t*h.Request\n\tauthTypes          []AuthType\n\tusernameClaimField string\n\tclient             client.Writer\n}\n\nfunc NewHTTP(request *h.Request, authTypes []AuthType, usernameClaimField string, client client.Writer) Request {\n\treturn &http{Request: request, authTypes: authTypes, usernameClaimField: usernameClaimField, client: client}\n}\n\nfunc (h http) GetHTTPRequest() *h.Request {\n\treturn h.Request\n}\n\n//nolint:funlen\nfunc (h http) GetUserAndGroups() (username string, groups []string, err error) {\n\tfor _, fn := range h.authenticationFns() {\n\t\t// User authentication data is extracted according to the preferred order:\n\t\t// in case of first match blocking the iteration\n\t\tif username, groups, err = fn(); err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\t// In case of error, we're blocking the request flow here\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\t// In case the requester is asking for impersonation, we have to be sure that's allowed by creating a\n\t// SubjectAccessReview with the requested data, before proceeding.\n\tif impersonateGroups := GetImpersonatingGroups(h.Request); len(impersonateGroups) > 0 {\n\t\tfor _, impersonateGroup := range impersonateGroups {\n\t\t\tac := &authorizationv1.SubjectAccessReview{\n\t\t\t\tSpec: authorizationv1.SubjectAccessReviewSpec{\n\t\t\t\t\tResourceAttributes: &authorizationv1.ResourceAttributes{\n\t\t\t\t\t\tVerb:     \"impersonate\",\n\t\t\t\t\t\tResource: \"groups\",\n\t\t\t\t\t\tName:     impersonateGroup,\n\t\t\t\t\t},\n\t\t\t\t\tUser:   username,\n\t\t\t\t\tGroups: groups,\n\t\t\t\t},\n\t\t\t}\n\t\t\tif err = h.client.Create(h.Request.Context(), ac); err != nil {\n\t\t\t\treturn \"\", nil, err\n\t\t\t}\n\n\t\t\tif !ac.Status.Allowed {\n\t\t\t\treturn \"\", nil, NewErrUnauthorized(fmt.Sprintf(\"the current user %s cannot impersonate the group %s\", username, impersonateGroup))\n\t\t\t}\n\t\t}\n\n\t\tdefer func() {\n\t\t\tgroups = impersonateGroups\n\t\t}()\n\t}\n\n\tif impersonateUser := GetImpersonatingUser(h.Request); len(impersonateUser) > 0 {\n\t\tac := &authorizationv1.SubjectAccessReview{\n\t\t\tSpec: authorizationv1.SubjectAccessReviewSpec{\n\t\t\t\tResourceAttributes: &authorizationv1.ResourceAttributes{\n\t\t\t\t\tVerb:     \"impersonate\",\n\t\t\t\t\tResource: \"users\",\n\t\t\t\t\tName:     impersonateUser,\n\t\t\t\t},\n\t\t\t\tUser:   username,\n\t\t\t\tGroups: groups,\n\t\t\t},\n\t\t}\n\t\tif err = h.client.Create(h.Request.Context(), ac); err != nil {\n\t\t\treturn \"\", nil, err\n\t\t}\n\n\t\tif !ac.Status.Allowed {\n\t\t\treturn \"\", nil, NewErrUnauthorized(fmt.Sprintf(\"the current user %s cannot impersonate the user %s\", username, impersonateUser))\n\t\t}\n\n\t\t// Assign impersonate user after group impersonation with current user\n\t\t// As defer func works in LIFO, if user is also impersonating groups, they will be set to correct value in the previous defer func.\n\t\t// Otherwise, groups will be set to nil, meaning we are checking just user permissions.\n\t\tdefer func() {\n\t\t\tusername = impersonateUser\n\t\t\tgroups = nil\n\t\t}()\n\t}\n\n\treturn username, groups, nil\n}\n\nfunc (h http) processBearerToken() (username string, groups []string, err error) {\n\ttr := &authenticationv1.TokenReview{\n\t\tSpec: authenticationv1.TokenReviewSpec{\n\t\t\tToken: h.bearerToken(),\n\t\t},\n\t}\n\n\tif err = h.client.Create(h.Request.Context(), tr); err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"cannot create TokenReview\")\n\t}\n\n\tif statusErr := tr.Status.Error; len(statusErr) > 0 {\n\t\treturn \"\", nil, fmt.Errorf(\"cannot verify the token due to error\")\n\t}\n\n\treturn tr.Status.User.Username, tr.Status.User.Groups, nil\n}\n\nfunc (h http) bearerToken() string {\n\treturn strings.ReplaceAll(h.Header.Get(\"Authorization\"), \"Bearer \", \"\")\n}\n\ntype authenticationFn func() (username string, groups []string, err error)\n\nfunc (h http) authenticationFns() []authenticationFn {\n\tfns := make([]authenticationFn, 0, len(h.authTypes)+1)\n\n\tfor _, authType := range h.authTypes {\n\t\t//nolint:exhaustive\n\t\tswitch authType {\n\t\tcase BearerToken:\n\t\t\tfns = append(fns, func() (username string, groups []string, err error) {\n\t\t\t\tif len(h.bearerToken()) == 0 {\n\t\t\t\t\treturn \"\", nil, NewErrUnauthorized(\"unauthenticated users not supported\")\n\t\t\t\t}\n\n\t\t\t\treturn h.processBearerToken()\n\t\t\t})\n\t\tcase TLSCertificate:\n\t\t\t// If the proxy is handling a non TLS connection, we have to skip the authentication strategy,\n\t\t\t// since the TLS section of the request would be nil.\n\t\t\tif h.TLS == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfns = append(fns, func() (username string, groups []string, err error) {\n\t\t\t\tif pc := h.TLS.PeerCertificates; len(pc) == 0 {\n\t\t\t\t\terr = NewErrUnauthorized(\"no provided peer certificates\")\n\t\t\t\t} else {\n\t\t\t\t\tusername, groups = pc[0].Subject.CommonName, pc[0].Subject.Organization\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t})\n\t\t}\n\t}\n\t// Dead man switch, if no strategy worked, the proxy cannot work\n\tfns = append(fns, func() (string, []string, error) {\n\t\treturn \"\", nil, NewErrUnauthorized(\"unauthenticated users not supported\")\n\t})\n\n\treturn fns\n}\n"], "fixing_code": ["// Copyright 2020-2023 Project Capsule Authors.\n// SPDX-License-Identifier: Apache-2.0\n\npackage request\n\nimport (\n\t\"fmt\"\n\th \"net/http\"\n\t\"strings\"\n\n\tauthenticationv1 \"k8s.io/api/authentication/v1\"\n\tauthorizationv1 \"k8s.io/api/authorization/v1\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n)\n\ntype http struct {\n\t*h.Request\n\tauthTypes          []AuthType\n\tusernameClaimField string\n\tclient             client.Writer\n}\n\nfunc NewHTTP(request *h.Request, authTypes []AuthType, usernameClaimField string, client client.Writer) Request {\n\treturn &http{Request: request, authTypes: authTypes, usernameClaimField: usernameClaimField, client: client}\n}\n\nfunc (h http) GetHTTPRequest() *h.Request {\n\treturn h.Request\n}\n\n//nolint:funlen\nfunc (h http) GetUserAndGroups() (username string, groups []string, err error) {\n\tfor _, fn := range h.authenticationFns() {\n\t\t// User authentication data is extracted according to the preferred order:\n\t\t// in case of first match blocking the iteration\n\t\tif username, groups, err = fn(); err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\t// In case of error, we're blocking the request flow here\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\t// In case the requester is asking for impersonation, we have to be sure that's allowed by creating a\n\t// SubjectAccessReview with the requested data, before proceeding.\n\tif impersonateGroups := GetImpersonatingGroups(h.Request); len(impersonateGroups) > 0 {\n\t\tfor _, impersonateGroup := range impersonateGroups {\n\t\t\tac := &authorizationv1.SubjectAccessReview{\n\t\t\t\tSpec: authorizationv1.SubjectAccessReviewSpec{\n\t\t\t\t\tResourceAttributes: &authorizationv1.ResourceAttributes{\n\t\t\t\t\t\tVerb:     \"impersonate\",\n\t\t\t\t\t\tResource: \"groups\",\n\t\t\t\t\t\tName:     impersonateGroup,\n\t\t\t\t\t},\n\t\t\t\t\tUser:   username,\n\t\t\t\t\tGroups: groups,\n\t\t\t\t},\n\t\t\t}\n\t\t\tif err = h.client.Create(h.Request.Context(), ac); err != nil {\n\t\t\t\treturn \"\", nil, err\n\t\t\t}\n\n\t\t\tif !ac.Status.Allowed {\n\t\t\t\treturn \"\", nil, NewErrUnauthorized(fmt.Sprintf(\"the current user %s cannot impersonate the group %s\", username, impersonateGroup))\n\t\t\t}\n\t\t}\n\n\t\tdefer func() {\n\t\t\tgroups = impersonateGroups\n\t\t}()\n\t}\n\n\tif impersonateUser := GetImpersonatingUser(h.Request); len(impersonateUser) > 0 {\n\t\tac := &authorizationv1.SubjectAccessReview{\n\t\t\tSpec: authorizationv1.SubjectAccessReviewSpec{\n\t\t\t\tResourceAttributes: &authorizationv1.ResourceAttributes{\n\t\t\t\t\tVerb:     \"impersonate\",\n\t\t\t\t\tResource: \"users\",\n\t\t\t\t\tName:     impersonateUser,\n\t\t\t\t},\n\t\t\t\tUser:   username,\n\t\t\t\tGroups: groups,\n\t\t\t},\n\t\t}\n\t\tif err = h.client.Create(h.Request.Context(), ac); err != nil {\n\t\t\treturn \"\", nil, err\n\t\t}\n\n\t\tif !ac.Status.Allowed {\n\t\t\treturn \"\", nil, NewErrUnauthorized(fmt.Sprintf(\"the current user %s cannot impersonate the user %s\", username, impersonateUser))\n\t\t}\n\n\t\t// Assign impersonate user after group impersonation with current user\n\t\t// As defer func works in LIFO, if user is also impersonating groups, they will be set to correct value in the previous defer func.\n\t\t// Otherwise, groups will be set to nil, meaning we are checking just user permissions.\n\t\tdefer func() {\n\t\t\tusername = impersonateUser\n\t\t\tgroups = nil\n\t\t}()\n\t}\n\n\treturn username, groups, nil\n}\n\nfunc (h http) processBearerToken() (username string, groups []string, err error) {\n\ttr := &authenticationv1.TokenReview{\n\t\tSpec: authenticationv1.TokenReviewSpec{\n\t\t\tToken: h.bearerToken(),\n\t\t},\n\t}\n\n\tif err = h.client.Create(h.Request.Context(), tr); err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"cannot create TokenReview\")\n\t}\n\n\tif !tr.Status.Authenticated {\n\t\treturn \"\", nil, fmt.Errorf(\"cannot verify the token due to error\")\n\t}\n\n\tif statusErr := tr.Status.Error; len(statusErr) > 0 {\n\t\treturn \"\", nil, fmt.Errorf(\"cannot verify the token due to error\")\n\t}\n\n\treturn tr.Status.User.Username, tr.Status.User.Groups, nil\n}\n\nfunc (h http) bearerToken() string {\n\treturn strings.ReplaceAll(h.Header.Get(\"Authorization\"), \"Bearer \", \"\")\n}\n\ntype authenticationFn func() (username string, groups []string, err error)\n\nfunc (h http) authenticationFns() []authenticationFn {\n\tfns := make([]authenticationFn, 0, len(h.authTypes)+1)\n\n\tfor _, authType := range h.authTypes {\n\t\t//nolint:exhaustive\n\t\tswitch authType {\n\t\tcase BearerToken:\n\t\t\tfns = append(fns, func() (username string, groups []string, err error) {\n\t\t\t\tif len(h.bearerToken()) == 0 {\n\t\t\t\t\treturn \"\", nil, NewErrUnauthorized(\"unauthenticated users not supported\")\n\t\t\t\t}\n\n\t\t\t\treturn h.processBearerToken()\n\t\t\t})\n\t\tcase TLSCertificate:\n\t\t\t// If the proxy is handling a non TLS connection, we have to skip the authentication strategy,\n\t\t\t// since the TLS section of the request would be nil.\n\t\t\tif h.TLS == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfns = append(fns, func() (username string, groups []string, err error) {\n\t\t\t\tif pc := h.TLS.PeerCertificates; len(pc) == 0 {\n\t\t\t\t\terr = NewErrUnauthorized(\"no provided peer certificates\")\n\t\t\t\t} else {\n\t\t\t\t\tusername, groups = pc[0].Subject.CommonName, pc[0].Subject.Organization\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t})\n\t\t}\n\t}\n\t// Dead man switch, if no strategy worked, the proxy cannot work\n\tfns = append(fns, func() (string, []string, error) {\n\t\treturn \"\", nil, NewErrUnauthorized(\"unauthenticated users not supported\")\n\t})\n\n\treturn fns\n}\n"], "filenames": ["internal/request/http.go"], "buggy_code_start_loc": [116], "buggy_code_end_loc": [116], "fixing_code_start_loc": [117], "fixing_code_end_loc": [121], "type": "CWE-287", "message": "capsule-proxy is a reverse proxy for the capsule operator project. Affected versions are subject to a privilege escalation vulnerability which is based on a missing check if the user is authenticated based on the `TokenReview` result. All the clusters running with the `anonymous-auth` Kubernetes API Server setting disable (set to `false`) are affected since it would be possible to bypass the token review mechanism, interacting with the upper Kubernetes API Server. This privilege escalation cannot be exploited if you're relying only on client certificates (SSL/TLS). This vulnerability has been addressed in version 0.4.6. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-48312", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-24T18:15:07.127", "lastModified": "2023-11-30T20:21:40.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "capsule-proxy is a reverse proxy for the capsule operator project. Affected versions are subject to a privilege escalation vulnerability which is based on a missing check if the user is authenticated based on the `TokenReview` result. All the clusters running with the `anonymous-auth` Kubernetes API Server setting disable (set to `false`) are affected since it would be possible to bypass the token review mechanism, interacting with the upper Kubernetes API Server. This privilege escalation cannot be exploited if you're relying only on client certificates (SSL/TLS). This vulnerability has been addressed in version 0.4.6. Users are advised to upgrade."}, {"lang": "es", "value": "Capsule-proxy es un proxy inverso para el proyecto del operador de c\u00e1psulas. Las versiones afectadas est\u00e1n sujetas a una vulnerabilidad de escalada de privilegios que se basa en una verificaci\u00f3n faltante si el usuario est\u00e1 autenticado seg\u00fan el resultado de \"TokenReview\". Todos los cl\u00fasteres que se ejecutan con la configuraci\u00f3n del servidor API de Kubernetes `anonymous-auth` deshabilitada (establecida en `false`) se ven afectados ya que ser\u00eda posible omitir el mecanismo de revisi\u00f3n de tokens, interactuando con el servidor API de Kubernetes superior. Esta escalada de privilegios no se puede aprovechar si conf\u00eda \u00fanicamente en certificados de cliente (SSL/TLS). Esta vulnerabilidad se ha solucionado en la versi\u00f3n 0.4.6. Se recomienda a los usuarios que actualicen."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clastix:capsule-proxy:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.5", "matchCriteriaId": "9337A5E5-9358-466F-9BEF-D1EE51DD5A18"}]}]}], "references": [{"url": "https://github.com/projectcapsule/capsule-proxy/commit/472404f7006a4152e4eec76dee07324dd1e6e823", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/projectcapsule/capsule-proxy/security/advisories/GHSA-fpvw-6m5v-hqfp", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/projectcapsule/capsule-proxy/commit/472404f7006a4152e4eec76dee07324dd1e6e823"}}