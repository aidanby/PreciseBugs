{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"archetype\"\nrequire \"digest/sha1\"\n\nclass Post < ActiveRecord::Base\n  include RateLimiter::OnCreateRecord\n  include Trashable\n  include Searchable\n  include HasCustomFields\n  include LimitedEdit\n\n  self.ignored_columns = [\n    \"avg_time\", # TODO(2021-01-04): remove\n    \"image_url\", # TODO(2021-06-01): remove\n  ]\n\n  cattr_accessor :plugin_permitted_create_params, :plugin_permitted_update_params\n  self.plugin_permitted_create_params = {}\n  self.plugin_permitted_update_params = {}\n\n  # increase this number to force a system wide post rebake\n  # Recreate `index_for_rebake_old` when the number is increased\n  # Version 1, was the initial version\n  # Version 2 15-12-2017, introduces CommonMark and a huge number of onebox fixes\n  BAKED_VERSION = 2\n\n  # Time between the delete and permanent delete of a post\n  PERMANENT_DELETE_TIMER = 5.minutes\n\n  rate_limit\n  rate_limit :limit_posts_per_day\n\n  belongs_to :user\n  belongs_to :topic\n\n  belongs_to :reply_to_user, class_name: \"User\"\n\n  has_many :post_replies\n  has_many :replies, through: :post_replies\n  has_many :post_actions, dependent: :destroy\n  has_many :topic_links\n  has_many :group_mentions, dependent: :destroy\n\n  has_many :upload_references, as: :target, dependent: :destroy\n  has_many :uploads, through: :upload_references\n\n  has_one :post_stat\n\n  has_many :bookmarks, as: :bookmarkable\n\n  has_one :incoming_email\n\n  has_many :post_details\n\n  has_many :post_revisions\n  has_many :revisions, -> { order(:number) }, foreign_key: :post_id, class_name: \"PostRevision\"\n\n  has_many :user_actions, foreign_key: :target_post_id\n\n  belongs_to :image_upload, class_name: \"Upload\"\n\n  has_many :post_hotlinked_media, dependent: :destroy, class_name: \"PostHotlinkedMedia\"\n  has_many :reviewables, as: :target, dependent: :destroy\n\n  validates_with PostValidator, unless: :skip_validation\n\n  after_commit :index_search\n\n  # We can pass several creating options to a post via attributes\n  attr_accessor :image_sizes,\n                :quoted_post_numbers,\n                :no_bump,\n                :invalidate_oneboxes,\n                :cooking_options,\n                :skip_unique_check,\n                :skip_validation\n\n  MISSING_UPLOADS ||= \"missing uploads\"\n  MISSING_UPLOADS_IGNORED ||= \"missing uploads ignored\"\n  NOTICE ||= \"notice\"\n\n  SHORT_POST_CHARS ||= 1200\n\n  register_custom_field_type(MISSING_UPLOADS, :json)\n  register_custom_field_type(MISSING_UPLOADS_IGNORED, :boolean)\n\n  register_custom_field_type(NOTICE, :json)\n\n  scope :private_posts_for_user,\n        ->(user) {\n          where(\n            \"topics.id IN (#{Topic::PRIVATE_MESSAGES_SQL_USER})\n      OR topics.id IN (#{Topic::PRIVATE_MESSAGES_SQL_GROUP})\",\n            user_id: user.id,\n          )\n        }\n\n  scope :by_newest, -> { order(\"created_at DESC, id DESC\") }\n  scope :by_post_number, -> { order(\"post_number ASC\") }\n  scope :with_user, -> { includes(:user) }\n  scope :created_since, ->(time_ago) { where(\"posts.created_at > ?\", time_ago) }\n  scope :public_posts,\n        -> { joins(:topic).where(\"topics.archetype <> ?\", Archetype.private_message) }\n  scope :private_posts,\n        -> { joins(:topic).where(\"topics.archetype = ?\", Archetype.private_message) }\n  scope :with_topic_subtype, ->(subtype) { joins(:topic).where(\"topics.subtype = ?\", subtype) }\n  scope :visible, -> { joins(:topic).where(\"topics.visible = true\").where(hidden: false) }\n  scope :secured,\n        ->(guardian) { where(\"posts.post_type IN (?)\", Topic.visible_post_types(guardian&.user)) }\n\n  scope :for_mailing_list,\n        ->(user, since) {\n          q =\n            created_since(since).joins(\n              \"INNER JOIN (#{Topic.for_digest(user, Time.at(0)).select(:id).to_sql}) AS digest_topics ON digest_topics.id = posts.topic_id\",\n            ) # we want all topics with new content, regardless when they were created\n              .order(\"posts.created_at ASC\")\n\n          q = q.where.not(post_type: Post.types[:whisper]) unless user.staff?\n          q\n        }\n\n  scope :raw_match,\n        ->(pattern, type = \"string\") {\n          type = type&.downcase\n\n          case type\n          when \"string\"\n            where(\"raw ILIKE ?\", \"%#{pattern}%\")\n          when \"regex\"\n            where(\"raw ~* ?\", \"(?n)#{pattern}\")\n          end\n        }\n\n  scope :have_uploads,\n        -> {\n          where(\n            \"\n          (\n            posts.cooked LIKE '%<a %' OR\n            posts.cooked LIKE '%<img %' OR\n            posts.cooked LIKE '%<video %'\n          ) AND (\n            posts.cooked LIKE ? OR\n            posts.cooked LIKE '%/original/%' OR\n            posts.cooked LIKE '%/optimized/%' OR\n            posts.cooked LIKE '%data-orig-src=%' OR\n            posts.cooked LIKE '%/uploads/short-url/%'\n          )\",\n            \"%/uploads/#{RailsMultisite::ConnectionManagement.current_db}/%\",\n          )\n        }\n\n  delegate :username, to: :user\n\n  def self.hidden_reasons\n    @hidden_reasons ||=\n      Enum.new(\n        flag_threshold_reached: 1,\n        flag_threshold_reached_again: 2,\n        new_user_spam_threshold_reached: 3,\n        flagged_by_tl3_user: 4,\n        email_spam_header_found: 5,\n        flagged_by_tl4_user: 6,\n        email_authentication_result_header: 7,\n        imported_as_unlisted: 8,\n      )\n  end\n\n  def self.types\n    @types ||= Enum.new(regular: 1, moderator_action: 2, small_action: 3, whisper: 4)\n  end\n\n  def self.cook_methods\n    @cook_methods ||= Enum.new(regular: 1, raw_html: 2, email: 3)\n  end\n\n  def self.notices\n    @notices ||= Enum.new(custom: \"custom\", new_user: \"new_user\", returning_user: \"returning_user\")\n  end\n\n  def self.find_by_detail(key, value)\n    includes(:post_details).find_by(post_details: { key: key, value: value })\n  end\n\n  def self.find_by_number(topic_id, post_number)\n    find_by(topic_id: topic_id, post_number: post_number)\n  end\n\n  def whisper?\n    post_type == Post.types[:whisper]\n  end\n\n  def add_detail(key, value, extra = nil)\n    post_details.build(key: key, value: value, extra: extra)\n  end\n\n  def limit_posts_per_day\n    if user && user.new_user_posting_on_first_day? && post_number && post_number > 1\n      RateLimiter.new(\n        user,\n        \"first-day-replies-per-day\",\n        SiteSetting.max_replies_in_first_day,\n        1.day.to_i,\n      )\n    end\n  end\n\n  def readers_count\n    read_count = reads - 1 # Excludes poster\n    read_count < 0 ? 0 : read_count\n  end\n\n  def publish_change_to_clients!(type, opts = {})\n    # special failsafe for posts missing topics consistency checks should fix,\n    # but message is safe to skip\n    return unless topic\n\n    skip_topic_stats = opts.delete(:skip_topic_stats)\n\n    message = {\n      id: id,\n      post_number: post_number,\n      updated_at: Time.now,\n      user_id: user_id,\n      last_editor_id: last_editor_id,\n      type: type,\n      version: version,\n    }.merge(opts)\n\n    publish_message!(\"/topic/#{topic_id}\", message)\n    Topic.publish_stats_to_clients!(topic.id, type) unless skip_topic_stats\n  end\n\n  def publish_message!(channel, message, opts = {})\n    return unless topic\n\n    if Topic.visible_post_types.include?(post_type)\n      opts.merge!(topic.secure_audience_publish_messages)\n    else\n      opts[:user_ids] = User.human_users.where(\"admin OR moderator OR id = ?\", user_id).pluck(:id)\n    end\n\n    MessageBus.publish(channel, message, opts) if opts[:user_ids] != [] && opts[:group_ids] != []\n  end\n\n  def trash!(trashed_by = nil)\n    self.topic_links.each(&:destroy)\n    self.save_custom_fields if self.custom_fields.delete(Post::NOTICE)\n    super(trashed_by)\n  end\n\n  def recover!\n    super\n    recover_public_post_actions\n    TopicLink.extract_from(self)\n    QuotedPost.extract_from(self)\n    topic.category.update_latest if topic && topic.category_id && topic.category\n  end\n\n  # The key we use in redis to ensure unique posts\n  def unique_post_key\n    \"unique#{topic&.private_message? ? \"-pm\" : \"\"}-post-#{user_id}:#{raw_hash}\"\n  end\n\n  def store_unique_post_key\n    if SiteSetting.unique_posts_mins > 0\n      Discourse.redis.setex(unique_post_key, SiteSetting.unique_posts_mins.minutes.to_i, id)\n    end\n  end\n\n  def matches_recent_post?\n    post_id = Discourse.redis.get(unique_post_key)\n    post_id != (nil) && post_id.to_i != (id)\n  end\n\n  def raw_hash\n    return if raw.blank?\n    Digest::SHA1.hexdigest(raw)\n  end\n\n  def self.allowed_image_classes\n    @allowed_image_classes ||= %w[avatar favicon thumbnail emoji ytp-thumbnail-image]\n  end\n\n  def post_analyzer\n    @post_analyzers ||= {}\n    @post_analyzers[raw_hash] ||= PostAnalyzer.new(raw, topic_id)\n  end\n\n  %w[\n    raw_mentions\n    linked_hosts\n    embedded_media_count\n    attachment_count\n    link_count\n    raw_links\n    has_oneboxes?\n  ].each { |attr| define_method(attr) { post_analyzer.public_send(attr) } }\n\n  def add_nofollow?\n    return false if user&.staff?\n    user.blank? || SiteSetting.tl3_links_no_follow? || !user.has_trust_level?(TrustLevel[3])\n  end\n\n  def omit_nofollow?\n    !add_nofollow?\n  end\n\n  def cook(raw, opts = {})\n    # For some posts, for example those imported via RSS, we support raw HTML. In that\n    # case we can skip the rendering pipeline.\n    return raw if cook_method == Post.cook_methods[:raw_html]\n\n    options = opts.dup\n    options[:cook_method] = cook_method\n\n    # A rule in our Markdown pipeline may have Guardian checks that require a\n    # user to be present. The last editing user of the post will be more\n    # generally up to date than the creating user. For example, we use\n    # this when cooking #hashtags to determine whether we should render\n    # the found hashtag based on whether the user can access the category it\n    # is referencing.\n    options[:user_id] = self.last_editor_id\n    options[:omit_nofollow] = true if omit_nofollow?\n\n    if self.with_secure_uploads?\n      each_upload_url do |url|\n        uri = URI.parse(url)\n        if FileHelper.is_supported_media?(File.basename(uri.path))\n          raw =\n            raw.sub(\n              url,\n              Rails.application.routes.url_for(\n                controller: \"uploads\",\n                action: \"show_secure\",\n                path: uri.path[1..-1],\n                host: Discourse.current_hostname,\n              ),\n            )\n        end\n      end\n    end\n\n    cooked = post_analyzer.cook(raw, options)\n\n    new_cooked = Plugin::Filter.apply(:after_post_cook, self, cooked)\n\n    if post_type == Post.types[:regular]\n      if new_cooked != cooked && new_cooked.blank?\n        Rails.logger.debug(\"Plugin is blanking out post: #{self.url}\\nraw: #{raw}\")\n      elsif new_cooked.blank?\n        Rails.logger.debug(\"Blank post detected post: #{self.url}\\nraw: #{raw}\")\n      end\n    end\n\n    new_cooked\n  end\n\n  # Sometimes the post is being edited by someone else, for example, a mod.\n  # If that's the case, they should not be bound by the original poster's\n  # restrictions, for example on not posting images.\n  def acting_user\n    @acting_user || user\n  end\n\n  def acting_user=(pu)\n    @acting_user = pu\n  end\n\n  def last_editor\n    self.last_editor_id ? (User.find_by_id(self.last_editor_id) || user) : user\n  end\n\n  def allowed_spam_hosts\n    hosts =\n      SiteSetting\n        .allowed_spam_host_domains\n        .split(\"|\")\n        .map { |h| h.strip }\n        .reject { |h| !h.include?(\".\") }\n\n    hosts << GlobalSetting.hostname\n    hosts << RailsMultisite::ConnectionManagement.current_hostname\n  end\n\n  def total_hosts_usage\n    hosts = linked_hosts.clone\n    allowlisted = allowed_spam_hosts\n\n    hosts.reject! { |h| allowlisted.any? { |w| h.end_with?(w) } }\n\n    return hosts if hosts.length == 0\n\n    TopicLink\n      .where(domain: hosts.keys, user_id: acting_user.id)\n      .group(:domain, :post_id)\n      .count\n      .each_key do |tuple|\n        domain = tuple[0]\n        hosts[domain] = (hosts[domain] || 0) + 1\n      end\n\n    hosts\n  end\n\n  # Prevent new users from posting the same hosts too many times.\n  def has_host_spam?\n    if acting_user.present? &&\n         (\n           acting_user.staged? || acting_user.mature_staged? ||\n             acting_user.has_trust_level?(TrustLevel[1])\n         )\n      return false\n    end\n    return false if topic&.private_message?\n\n    total_hosts_usage.values.any? { |count| count >= SiteSetting.newuser_spam_host_threshold }\n  end\n\n  def archetype\n    topic&.archetype\n  end\n\n  def self.regular_order\n    order(:sort_order, :post_number)\n  end\n\n  def self.reverse_order\n    order(\"sort_order desc, post_number desc\")\n  end\n\n  def self.summary(topic_id)\n    topic_id = topic_id.to_i\n\n    # percent rank has tons of ties\n    where(topic_id: topic_id).where(\n      [\n        \"posts.id = ANY(\n          (\n            SELECT posts.id\n            FROM posts\n            WHERE posts.topic_id = #{topic_id.to_i}\n            AND posts.post_number = 1\n          ) UNION\n          (\n            SELECT p1.id\n            FROM posts p1\n            WHERE p1.percent_rank <= ?\n            AND p1.topic_id = #{topic_id.to_i}\n            ORDER BY p1.percent_rank\n            LIMIT ?\n          )\n        )\",\n        SiteSetting.summary_percent_filter.to_f / 100.0,\n        SiteSetting.summary_max_results,\n      ],\n    )\n  end\n\n  def delete_post_notices\n    self.custom_fields.delete(Post::NOTICE)\n    self.save_custom_fields\n  end\n\n  def recover_public_post_actions\n    PostAction\n      .publics\n      .with_deleted\n      .where(post_id: self.id, id: self.custom_fields[\"deleted_public_actions\"])\n      .find_each do |post_action|\n        post_action.recover!\n        post_action.save!\n      end\n\n    self.custom_fields.delete(\"deleted_public_actions\")\n    self.save_custom_fields\n  end\n\n  def filter_quotes(parent_post = nil)\n    return cooked if parent_post.blank?\n\n    # We only filter quotes when there is exactly 1\n    return cooked unless (quote_count == 1)\n\n    parent_raw = parent_post.raw.sub(%r{\\[quote.+/quote\\]}m, \"\")\n\n    if raw[parent_raw] || (parent_raw.size < SHORT_POST_CHARS)\n      return cooked.sub(%r{\\<aside.+\\</aside\\>}m, \"\")\n    end\n\n    cooked\n  end\n\n  def external_id\n    \"#{topic_id}/#{post_number}\"\n  end\n\n  def reply_to_post\n    return if reply_to_post_number.blank?\n    @reply_to_post ||=\n      Post.find_by(\n        \"topic_id = :topic_id AND post_number = :post_number\",\n        topic_id: topic_id,\n        post_number: reply_to_post_number,\n      )\n  end\n\n  def reply_notification_target\n    return if reply_to_post_number.blank?\n    Post.find_by(\n      \"topic_id = :topic_id AND post_number = :post_number AND user_id <> :user_id\",\n      topic_id: topic_id,\n      post_number: reply_to_post_number,\n      user_id: user_id,\n    ).try(:user)\n  end\n\n  def self.excerpt(cooked, maxlength = nil, options = {})\n    maxlength ||= SiteSetting.post_excerpt_maxlength\n    PrettyText.excerpt(cooked, maxlength, options)\n  end\n\n  # Strip out most of the markup\n  def excerpt(maxlength = nil, options = {})\n    Post.excerpt(cooked, maxlength, options.merge(post: self))\n  end\n\n  def excerpt_for_topic\n    Post.excerpt(\n      cooked,\n      SiteSetting.topic_excerpt_maxlength,\n      strip_links: true,\n      strip_images: true,\n      post: self,\n    )\n  end\n\n  def is_first_post?\n    post_number.blank? ? topic.try(:highest_post_number) == 0 : post_number == 1\n  end\n\n  def is_category_description?\n    topic.present? && topic.is_category_topic? && is_first_post?\n  end\n\n  def is_reply_by_email?\n    via_email && post_number.present? && post_number > 1\n  end\n\n  def is_flagged?\n    flags.count != 0\n  end\n\n  def flags\n    post_actions.where(\n      post_action_type_id: PostActionType.flag_types_without_custom.values,\n      deleted_at: nil,\n    )\n  end\n\n  def reviewable_flag\n    ReviewableFlaggedPost.pending.find_by(target: self)\n  end\n\n  def with_secure_uploads?\n    return false if !SiteSetting.secure_uploads?\n    SiteSetting.login_required? ||\n      (topic.present? && (topic.private_message? || topic.category&.read_restricted))\n  end\n\n  def hide!(post_action_type_id, reason = nil, custom_message: nil)\n    return if hidden?\n\n    reason ||=\n      (\n        if hidden_at\n          Post.hidden_reasons[:flag_threshold_reached_again]\n        else\n          Post.hidden_reasons[:flag_threshold_reached]\n        end\n      )\n\n    hiding_again = hidden_at.present?\n\n    self.hidden = true\n    self.hidden_at = Time.zone.now\n    self.hidden_reason_id = reason\n    self.skip_unique_check = true\n\n    Post.transaction do\n      save!\n\n      Topic.where(\n        \"id = :topic_id AND NOT EXISTS(SELECT 1 FROM POSTS WHERE topic_id = :topic_id AND NOT hidden)\",\n        topic_id: topic_id,\n      ).update_all(visible: false)\n\n      UserStatCountUpdater.decrement!(self)\n    end\n\n    # inform user\n    if user.present?\n      options = {\n        url: url,\n        edit_delay: SiteSetting.cooldown_minutes_after_hiding_posts,\n        flag_reason:\n          I18n.t(\n            \"flag_reasons.#{PostActionType.types[post_action_type_id]}\",\n            locale: SiteSetting.default_locale,\n            base_path: Discourse.base_path,\n          ),\n      }\n\n      message = custom_message\n      message = hiding_again ? :post_hidden_again : :post_hidden if message.nil?\n\n      Jobs.enqueue_in(\n        5.seconds,\n        :send_system_message,\n        user_id: user.id,\n        message_type: message.to_s,\n        message_options: options,\n      )\n    end\n  end\n\n  def unhide!\n    Post.transaction do\n      self.update!(hidden: false)\n      self.topic.update(visible: true) if is_first_post?\n      UserStatCountUpdater.increment!(self)\n      save(validate: false)\n    end\n\n    publish_change_to_clients!(:acted)\n  end\n\n  def full_url\n    \"#{Discourse.base_url}#{url}\"\n  end\n\n  def url(opts = nil)\n    opts ||= {}\n\n    if topic\n      Post.url(topic.slug, topic.id, post_number, opts)\n    else\n      \"/404\"\n    end\n  end\n\n  def canonical_url\n    topic_view = TopicView.new(topic, nil, post_number: post_number)\n\n    page = \"\"\n\n    page = \"?page=#{topic_view.page}\" if topic_view.page > 1\n\n    \"#{topic.url}#{page}#post_#{post_number}\"\n  end\n\n  def unsubscribe_url(user)\n    key_value = UnsubscribeKey.create_key_for(user, UnsubscribeKey::TOPIC_TYPE, post: self)\n\n    \"#{Discourse.base_url}/email/unsubscribe/#{key_value}\"\n  end\n\n  def self.url(slug, topic_id, post_number, opts = nil)\n    opts ||= {}\n\n    result = +\"/t/\"\n    result << \"#{slug}/\" if !opts[:without_slug]\n\n    \"#{result}#{topic_id}/#{post_number}\"\n  end\n\n  def self.urls(post_ids)\n    ids = post_ids.map { |u| u }\n    if ids.length > 0\n      urls = {}\n      Topic\n        .joins(:posts)\n        .where(\"posts.id\" => ids)\n        .select([\"posts.id as post_id\", \"post_number\", \"topics.slug\", \"topics.title\", \"topics.id\"])\n        .each { |t| urls[t.post_id.to_i] = url(t.slug, t.id, t.post_number) }\n      urls\n    else\n      {}\n    end\n  end\n\n  def revise(updated_by, changes = {}, opts = {})\n    PostRevisor.new(self).revise!(updated_by, changes, opts)\n  end\n\n  def self.rebake_old(limit, priority: :normal, rate_limiter: true)\n    limiter =\n      RateLimiter.new(\n        nil,\n        \"global_periodical_rebake_limit\",\n        GlobalSetting.max_old_rebakes_per_15_minutes,\n        900,\n        global: true,\n      )\n\n    problems = []\n    Post\n      .where(\"baked_version IS NULL OR baked_version < ?\", BAKED_VERSION)\n      .order(\"id desc\")\n      .limit(limit)\n      .pluck(:id)\n      .each do |id|\n        begin\n          break if !limiter.can_perform?\n\n          post = Post.find(id)\n          post.rebake!(priority: priority)\n\n          begin\n            limiter.performed! if rate_limiter\n          rescue RateLimiter::LimitExceeded\n            break\n          end\n        rescue => e\n          problems << { post: post, ex: e }\n\n          attempts = post.custom_fields[\"rebake_attempts\"].to_i\n\n          if attempts > 3\n            post.update_columns(baked_version: BAKED_VERSION)\n            Discourse.warn_exception(\n              e,\n              message: \"Can not rebake post# #{post.id} after 3 attempts, giving up\",\n            )\n          else\n            post.custom_fields[\"rebake_attempts\"] = attempts + 1\n            post.save_custom_fields\n          end\n        end\n      end\n    problems\n  end\n\n  def rebake!(invalidate_broken_images: false, invalidate_oneboxes: false, priority: nil)\n    new_cooked = cook(raw, topic_id: topic_id, invalidate_oneboxes: invalidate_oneboxes)\n    old_cooked = cooked\n\n    update_columns(cooked: new_cooked, baked_at: Time.zone.now, baked_version: BAKED_VERSION)\n\n    topic&.update_excerpt(excerpt_for_topic) if is_first_post?\n\n    if invalidate_broken_images\n      post_hotlinked_media.download_failed.destroy_all\n      post_hotlinked_media.upload_create_failed.destroy_all\n    end\n\n    # Extracts urls from the body\n    TopicLink.extract_from(self)\n    QuotedPost.extract_from(self)\n\n    # make sure we trigger the post process\n    trigger_post_process(bypass_bump: true, priority: priority)\n\n    publish_change_to_clients!(:rebaked)\n\n    new_cooked != old_cooked\n  end\n\n  def set_owner(new_user, actor, skip_revision = false)\n    return if user_id == new_user.id\n\n    edit_reason = I18n.t(\"change_owner.post_revision_text\", locale: SiteSetting.default_locale)\n\n    revise(\n      actor,\n      { raw: self.raw, user_id: new_user.id, edit_reason: edit_reason },\n      bypass_bump: true,\n      skip_revision: skip_revision,\n      skip_validations: true,\n    )\n\n    topic.update_columns(last_post_user_id: new_user.id) if post_number == topic.highest_post_number\n  end\n\n  before_create { PostCreator.before_create_tasks(self) }\n\n  def self.estimate_posts_per_day\n    val = Discourse.redis.get(\"estimated_posts_per_day\")\n    return val.to_i if val\n\n    posts_per_day =\n      Topic.listable_topics.secured.joins(:posts).merge(Post.created_since(30.days.ago)).count / 30\n    Discourse.redis.setex(\"estimated_posts_per_day\", 1.day.to_i, posts_per_day.to_s)\n    posts_per_day\n  end\n\n  before_save do\n    self.last_editor_id ||= user_id\n\n    if will_save_change_to_raw?\n      self.cooked = cook(raw, topic_id: topic_id) if !new_record?\n      self.baked_at = Time.zone.now\n      self.baked_version = BAKED_VERSION\n    end\n  end\n\n  def advance_draft_sequence\n    return if topic.blank? # could be deleted\n    DraftSequence.next!(last_editor_id, topic.draft_key) if last_editor_id\n  end\n\n  # TODO: move to post-analyzer?\n  # Determine what posts are quoted by this post\n  def extract_quoted_post_numbers\n    temp_collector = []\n\n    # Create relationships for the quotes\n    raw\n      .scan(/\\[quote=\\\"([^\"]+)\"\\]/)\n      .each do |quote|\n        args = parse_quote_into_arguments(quote)\n        # If the topic attribute is present, ensure it's the same topic\n        if !(args[:topic].present? && topic_id != args[:topic]) && args[:post] != post_number\n          temp_collector << args[:post]\n        end\n      end\n\n    temp_collector.uniq!\n    self.quoted_post_numbers = temp_collector\n    self.quote_count = temp_collector.size\n  end\n\n  def save_reply_relationships\n    add_to_quoted_post_numbers(reply_to_post_number)\n    return if self.quoted_post_numbers.blank?\n\n    # Create a reply relationship between quoted posts and this new post\n    self.quoted_post_numbers.each do |p|\n      post = Post.find_by(topic_id: topic_id, post_number: p)\n      create_reply_relationship_with(post)\n    end\n  end\n\n  # Enqueue post processing for this post\n  def trigger_post_process(\n    bypass_bump: false,\n    priority: :normal,\n    new_post: false,\n    skip_pull_hotlinked_images: false\n  )\n    args = {\n      bypass_bump: bypass_bump,\n      cooking_options: self.cooking_options,\n      new_post: new_post,\n      post_id: id,\n      skip_pull_hotlinked_images: skip_pull_hotlinked_images,\n    }\n\n    args[:image_sizes] = image_sizes if self.image_sizes.present?\n    args[:invalidate_oneboxes] = true if self.invalidate_oneboxes.present?\n    args[:queue] = priority.to_s if priority && priority != :normal\n\n    Jobs.enqueue(:process_post, args)\n    DiscourseEvent.trigger(:after_trigger_post_process, self)\n  end\n\n  def self.public_posts_count_per_day(\n    start_date,\n    end_date,\n    category_id = nil,\n    include_subcategories = false\n  )\n    result =\n      public_posts.where(\n        \"posts.created_at >= ? AND posts.created_at <= ?\",\n        start_date,\n        end_date,\n      ).where(post_type: Post.types[:regular])\n\n    if category_id\n      if include_subcategories\n        result = result.where(\"topics.category_id IN (?)\", Category.subcategory_ids(category_id))\n      else\n        result = result.where(\"topics.category_id = ?\", category_id)\n      end\n    end\n\n    result.group(\"date(posts.created_at)\").order(\"date(posts.created_at)\").count\n  end\n\n  def self.private_messages_count_per_day(start_date, end_date, topic_subtype)\n    private_posts\n      .with_topic_subtype(topic_subtype)\n      .where(\"posts.created_at >= ? AND posts.created_at <= ?\", start_date, end_date)\n      .group(\"date(posts.created_at)\")\n      .order(\"date(posts.created_at)\")\n      .count\n  end\n\n  def reply_history(max_replies = 100, guardian = nil)\n    post_ids = DB.query_single(<<~SQL, post_id: id, topic_id: topic_id)\n    WITH RECURSIVE breadcrumb(id, reply_to_post_number) AS (\n          SELECT p.id, p.reply_to_post_number FROM posts AS p\n            WHERE p.id = :post_id\n          UNION\n             SELECT p.id, p.reply_to_post_number FROM posts AS p, breadcrumb\n               WHERE breadcrumb.reply_to_post_number = p.post_number\n                 AND p.topic_id = :topic_id\n        )\n    SELECT id from breadcrumb\n    WHERE id <> :post_id\n    ORDER by id\n    SQL\n\n    # [1,2,3][-10,-1] => nil\n    post_ids = (post_ids[(0 - max_replies)..-1] || post_ids)\n\n    Post.secured(guardian).where(id: post_ids).includes(:user, :topic).order(:id).to_a\n  end\n\n  MAX_REPLY_LEVEL ||= 1000\n\n  def reply_ids(guardian = nil, only_replies_to_single_post: true)\n    builder = DB.build(<<~SQL)\n      WITH RECURSIVE breadcrumb(id, level) AS (\n        SELECT :post_id, 0\n        UNION\n        SELECT reply_post_id, level + 1\n        FROM post_replies AS r\n          JOIN posts AS p ON p.id = reply_post_id\n          JOIN breadcrumb AS b ON (r.post_id = b.id)\n        WHERE r.post_id <> r.reply_post_id\n          AND b.level < :max_reply_level\n          AND p.topic_id = :topic_id\n      ), breadcrumb_with_count AS (\n          SELECT\n            id,\n            level,\n            COUNT(*) AS count\n          FROM post_replies AS r\n            JOIN breadcrumb AS b ON (r.reply_post_id = b.id)\n          WHERE r.reply_post_id <> r.post_id\n          GROUP BY id, level\n      )\n      SELECT id, MIN(level) AS level\n      FROM breadcrumb_with_count\n      /*where*/\n      GROUP BY id\n      ORDER BY id\n    SQL\n\n    builder.where(\"level > 0\")\n\n    # ignore posts that aren't replies to exactly one post\n    # for example it skips a post when it contains 2 quotes (which are replies) from different posts\n    builder.where(\"count = 1\") if only_replies_to_single_post\n\n    replies = builder.query_hash(post_id: id, max_reply_level: MAX_REPLY_LEVEL, topic_id: topic_id)\n    replies.each { |r| r.symbolize_keys! }\n\n    secured_ids = Post.secured(guardian).where(id: replies.map { |r| r[:id] }).pluck(:id).to_set\n\n    replies.reject { |r| !secured_ids.include?(r[:id]) }\n  end\n\n  def revert_to(number)\n    return if number >= version\n    post_revision = PostRevision.find_by(post_id: id, number: (number + 1))\n    post_revision.modifications.each do |attribute, change|\n      attribute = \"version\" if attribute == \"cached_version\"\n      write_attribute(attribute, change[0])\n    end\n  end\n\n  def self.rebake_all_quoted_posts(user_id)\n    return if user_id.blank?\n\n    DB.exec(<<~SQL, user_id)\n      WITH user_quoted_posts AS (\n        SELECT post_id\n          FROM quoted_posts\n         WHERE quoted_post_id IN (SELECT id FROM posts WHERE user_id = ?)\n      )\n      UPDATE posts\n         SET baked_version = NULL\n       WHERE baked_version IS NOT NULL\n         AND id IN (SELECT post_id FROM user_quoted_posts)\n    SQL\n  end\n\n  def seen?(user)\n    PostTiming.where(topic_id: topic_id, post_number: post_number, user_id: user.id).exists?\n  end\n\n  def index_search\n    Scheduler::Defer.later \"Index post for search\" do\n      SearchIndexer.index(self)\n    end\n  end\n\n  def locked?\n    locked_by_id.present?\n  end\n\n  def link_post_uploads(fragments: nil)\n    upload_ids = []\n\n    each_upload_url(fragments: fragments) do |src, _, sha1|\n      upload = nil\n      upload = Upload.find_by(sha1: sha1) if sha1.present?\n      upload ||= Upload.get_from_url(src)\n\n      # Link any video thumbnails\n      if SiteSetting.video_thumbnails_enabled && upload.present? &&\n           FileHelper.supported_video.include?(upload.extension&.downcase)\n        # Video thumbnails have the filename of the video file sha1 with a .png or .jpg extension.\n        # This is because at time of upload in the composer we don't know the topic/post id yet\n        # and there is no thumbnail info added to the markdown to tie the thumbnail to the topic/post after\n        # creation.\n        thumbnail =\n          Upload\n            .where(\"original_filename like ?\", \"#{upload.sha1}.%\")\n            .order(id: :desc)\n            .first if upload.sha1.present?\n        if thumbnail.present? && self.is_first_post? && !self.topic.image_upload_id\n          upload_ids << thumbnail.id\n          self.topic.update_column(:image_upload_id, thumbnail.id)\n          extra_sizes =\n            ThemeModifierHelper.new(\n              theme_ids: Theme.user_selectable.pluck(:id),\n            ).topic_thumbnail_sizes\n          self.topic.generate_thumbnails!(extra_sizes: extra_sizes)\n        end\n      end\n      upload_ids << upload.id if upload.present?\n    end\n\n    upload_references =\n      upload_ids.map do |upload_id|\n        {\n          target_id: self.id,\n          target_type: self.class.name,\n          upload_id: upload_id,\n          created_at: Time.zone.now,\n          updated_at: Time.zone.now,\n        }\n      end\n\n    UploadReference.transaction do\n      UploadReference.where(target: self).delete_all\n      UploadReference.insert_all(upload_references) if upload_references.size > 0\n\n      if SiteSetting.secure_uploads?\n        Upload\n          .where(id: upload_ids, access_control_post_id: nil)\n          .where(\"id NOT IN (SELECT upload_id FROM custom_emojis)\")\n          .update_all(access_control_post_id: self.id)\n      end\n    end\n  end\n\n  def update_uploads_secure_status(source:)\n    if Discourse.store.external? && SiteSetting.secure_uploads?\n      Jobs.enqueue(:update_post_uploads_secure_status, post_id: self.id, source: source)\n    end\n  end\n\n  def each_upload_url(fragments: nil, include_local_upload: true)\n    current_db = RailsMultisite::ConnectionManagement.current_db\n    upload_patterns = [\n      %r{/uploads/#{current_db}/},\n      %r{/original/},\n      %r{/optimized/},\n      %r{/uploads/short-url/[a-zA-Z0-9]+(\\.[a-z0-9]+)?},\n    ]\n\n    fragments ||= Nokogiri::HTML5.fragment(self.cooked)\n    selectors = fragments.css(\"a/@href\", \"img/@src\", \"source/@src\", \"track/@src\", \"video/@poster\")\n\n    links =\n      selectors\n        .map do |media|\n          src = media.value\n          next if src.blank?\n\n          if src.end_with?(\"/images/transparent.png\") &&\n               (parent = media.parent)[\"data-orig-src\"].present?\n            parent[\"data-orig-src\"]\n          else\n            src\n          end\n        end\n        .compact\n        .uniq\n\n    links.each do |src|\n      src = src.split(\"?\")[0]\n\n      if src.start_with?(\"upload://\")\n        sha1 = Upload.sha1_from_short_url(src)\n        yield(src, nil, sha1)\n        next\n      elsif src.include?(\"/uploads/short-url/\")\n        sha1 = Upload.sha1_from_short_path(src)\n        yield(src, nil, sha1)\n        next\n      end\n\n      next if upload_patterns.none? { |pattern| src =~ pattern }\n      next if Rails.configuration.multisite && src.exclude?(current_db)\n\n      src = \"#{SiteSetting.force_https ? \"https\" : \"http\"}:#{src}\" if src.start_with?(\"//\")\n      if !Discourse.store.has_been_uploaded?(src) && !Upload.secure_uploads_url?(src) &&\n           !(include_local_upload && src =~ %r{\\A/[^/]}i)\n        next\n      end\n\n      path =\n        begin\n          URI(\n            UrlHelper.unencode(GlobalSetting.cdn_url ? src.sub(GlobalSetting.cdn_url, \"\") : src),\n          )&.path\n        rescue URI::Error\n        end\n\n      next if path.blank?\n\n      sha1 =\n        if path.include? \"optimized\"\n          OptimizedImage.extract_sha1(path)\n        else\n          Upload.extract_sha1(path) || Upload.sha1_from_short_path(path)\n        end\n\n      yield(src, path, sha1)\n    end\n  end\n\n  def self.find_missing_uploads(include_local_upload: true)\n    missing_uploads = []\n    missing_post_uploads = {}\n    count = 0\n\n    DistributedMutex.synchronize(\"find_missing_uploads\", validity: 30.minutes) do\n      PostCustomField.where(name: Post::MISSING_UPLOADS).delete_all\n      query =\n        Post\n          .have_uploads\n          .joins(:topic)\n          .joins(\n            \"LEFT JOIN post_custom_fields ON posts.id = post_custom_fields.post_id AND post_custom_fields.name = '#{Post::MISSING_UPLOADS_IGNORED}'\",\n          )\n          .where(\"post_custom_fields.id IS NULL\")\n          .select(:id, :cooked)\n\n      query.find_in_batches do |posts|\n        ids = posts.pluck(:id)\n        sha1s =\n          Upload\n            .joins(:upload_references)\n            .where(upload_references: { target_type: \"Post\" })\n            .where(\"upload_references.target_id BETWEEN ? AND ?\", ids.min, ids.max)\n            .pluck(:sha1)\n\n        posts.each do |post|\n          post.each_upload_url do |src, path, sha1|\n            next if sha1.present? && sha1s.include?(sha1)\n\n            missing_post_uploads[post.id] ||= []\n\n            if missing_uploads.include?(src)\n              missing_post_uploads[post.id] << src\n              next\n            end\n\n            upload_id = nil\n            upload_id = Upload.where(sha1: sha1).pick(:id) if sha1.present?\n            upload_id ||= yield(post, src, path, sha1)\n\n            if upload_id.blank?\n              missing_uploads << src\n              missing_post_uploads[post.id] << src\n            end\n          end\n        end\n      end\n\n      missing_post_uploads =\n        missing_post_uploads.reject do |post_id, uploads|\n          if uploads.present?\n            PostCustomField.create!(\n              post_id: post_id,\n              name: Post::MISSING_UPLOADS,\n              value: uploads.to_json,\n            )\n            count += uploads.count\n          end\n\n          uploads.empty?\n        end\n    end\n\n    { uploads: missing_uploads, post_uploads: missing_post_uploads, count: count }\n  end\n\n  def owned_uploads_via_access_control\n    Upload.where(access_control_post_id: self.id)\n  end\n\n  def image_url\n    raw_url = image_upload&.url\n    UrlHelper.cook_url(raw_url, secure: image_upload&.secure?, local: true) if raw_url\n  end\n\n  def cannot_permanently_delete_reason(user)\n    if self.deleted_by_id == user&.id && self.deleted_at >= Post::PERMANENT_DELETE_TIMER.ago\n      time_left =\n        RateLimiter.time_left(\n          Post::PERMANENT_DELETE_TIMER.to_i - Time.zone.now.to_i + self.deleted_at.to_i,\n        )\n      I18n.t(\"post.cannot_permanently_delete.wait_or_different_admin\", time_left: time_left)\n    end\n  end\n\n  def mentions\n    PrettyText.extract_mentions(Nokogiri::HTML5.fragment(cooked))\n  end\n\n  private\n\n  def parse_quote_into_arguments(quote)\n    return {} unless quote.present?\n    args = HashWithIndifferentAccess.new\n    quote.first.scan(/([a-z]+)\\:(\\d+)/).each { |arg| args[arg[0]] = arg[1].to_i }\n    args\n  end\n\n  def add_to_quoted_post_numbers(num)\n    return unless num.present?\n    self.quoted_post_numbers ||= []\n    self.quoted_post_numbers << num\n  end\n\n  def create_reply_relationship_with(post)\n    return if post.nil? || self.deleted_at.present?\n    post_reply = post.post_replies.new(reply_post_id: id)\n    if post_reply.save\n      if Topic.visible_post_types.include?(self.post_type)\n        Post.where(id: post.id).update_all [\"reply_count = reply_count + 1\"]\n      end\n    end\n  end\nend\n\n# == Schema Information\n#\n# Table name: posts\n#\n#  id                      :integer          not null, primary key\n#  user_id                 :integer\n#  topic_id                :integer          not null\n#  post_number             :integer          not null\n#  raw                     :text             not null\n#  cooked                  :text             not null\n#  created_at              :datetime         not null\n#  updated_at              :datetime         not null\n#  reply_to_post_number    :integer\n#  reply_count             :integer          default(0), not null\n#  quote_count             :integer          default(0), not null\n#  deleted_at              :datetime\n#  off_topic_count         :integer          default(0), not null\n#  like_count              :integer          default(0), not null\n#  incoming_link_count     :integer          default(0), not null\n#  bookmark_count          :integer          default(0), not null\n#  score                   :float\n#  reads                   :integer          default(0), not null\n#  post_type               :integer          default(1), not null\n#  sort_order              :integer\n#  last_editor_id          :integer\n#  hidden                  :boolean          default(FALSE), not null\n#  hidden_reason_id        :integer\n#  notify_moderators_count :integer          default(0), not null\n#  spam_count              :integer          default(0), not null\n#  illegal_count           :integer          default(0), not null\n#  inappropriate_count     :integer          default(0), not null\n#  last_version_at         :datetime         not null\n#  user_deleted            :boolean          default(FALSE), not null\n#  reply_to_user_id        :integer\n#  percent_rank            :float            default(1.0)\n#  notify_user_count       :integer          default(0), not null\n#  like_score              :integer          default(0), not null\n#  deleted_by_id           :integer\n#  edit_reason             :string\n#  word_count              :integer\n#  version                 :integer          default(1), not null\n#  cook_method             :integer          default(1), not null\n#  wiki                    :boolean          default(FALSE), not null\n#  baked_at                :datetime\n#  baked_version           :integer\n#  hidden_at               :datetime\n#  self_edits              :integer          default(0), not null\n#  reply_quoted            :boolean          default(FALSE), not null\n#  via_email               :boolean          default(FALSE), not null\n#  raw_email               :text\n#  public_version          :integer          default(1), not null\n#  action_code             :string\n#  locked_by_id            :integer\n#  image_upload_id         :bigint\n#  outbound_message_id     :string\n#\n# Indexes\n#\n#  idx_posts_created_at_topic_id                          (created_at,topic_id) WHERE (deleted_at IS NULL)\n#  idx_posts_deleted_posts                                (topic_id,post_number) WHERE (deleted_at IS NOT NULL)\n#  idx_posts_user_id_deleted_at                           (user_id) WHERE (deleted_at IS NULL)\n#  index_for_rebake_old                                   (id) WHERE (((baked_version IS NULL) OR (baked_version < 2)) AND (deleted_at IS NULL))\n#  index_posts_on_id_and_baked_version                    (id DESC,baked_version) WHERE (deleted_at IS NULL)\n#  index_posts_on_id_topic_id_where_not_deleted_or_empty  (id,topic_id) WHERE ((deleted_at IS NULL) AND (raw <> ''::text))\n#  index_posts_on_image_upload_id                         (image_upload_id)\n#  index_posts_on_reply_to_post_number                    (reply_to_post_number)\n#  index_posts_on_topic_id_and_created_at                 (topic_id,created_at)\n#  index_posts_on_topic_id_and_percent_rank               (topic_id,percent_rank)\n#  index_posts_on_topic_id_and_post_number                (topic_id,post_number) UNIQUE\n#  index_posts_on_topic_id_and_sort_order                 (topic_id,sort_order)\n#  index_posts_on_user_id_and_created_at                  (user_id,created_at)\n#  index_posts_user_and_likes                             (user_id,like_count DESC,created_at DESC) WHERE (post_number > 1)\n#\n", "# frozen_string_literal: true\n\nRSpec.describe Post do\n  fab!(:coding_horror) { Fabricate(:coding_horror) }\n\n  let(:upload_path) { Discourse.store.upload_path }\n\n  before { Oneboxer.stubs :onebox }\n\n  it_behaves_like \"it has custom fields\"\n\n  it { is_expected.to have_many(:reviewables).dependent(:destroy) }\n\n  describe \"#hidden_reasons\" do\n    context \"when verifying enum sequence\" do\n      before { @hidden_reasons = Post.hidden_reasons }\n\n      it \"'flag_threshold_reached' should be at 1st position\" do\n        expect(@hidden_reasons[:flag_threshold_reached]).to eq(1)\n      end\n\n      it \"'flagged_by_tl3_user' should be at 4th position\" do\n        expect(@hidden_reasons[:flagged_by_tl3_user]).to eq(4)\n      end\n    end\n  end\n\n  describe \"#types\" do\n    context \"when verifying enum sequence\" do\n      before { @types = Post.types }\n\n      it \"'regular' should be at 1st position\" do\n        expect(@types[:regular]).to eq(1)\n      end\n\n      it \"'whisper' should be at 4th position\" do\n        expect(@types[:whisper]).to eq(4)\n      end\n    end\n  end\n\n  describe \"#cook_methods\" do\n    context \"when verifying enum sequence\" do\n      before { @cook_methods = Post.cook_methods }\n\n      it \"'regular' should be at 1st position\" do\n        expect(@cook_methods[:regular]).to eq(1)\n      end\n\n      it \"'email' should be at 3rd position\" do\n        expect(@cook_methods[:email]).to eq(3)\n      end\n    end\n  end\n\n  # Help us build a post with a raw body\n  def post_with_body(body, user = nil)\n    args = post_args.merge(raw: body)\n    args[:user] = user if user.present?\n    Fabricate.build(:post, args)\n  end\n\n  it { is_expected.to validate_presence_of :raw }\n\n  # Min/max body lengths, respecting padding\n  it { is_expected.not_to allow_value(\"x\").for(:raw) }\n  it { is_expected.not_to allow_value(\"x\" * (SiteSetting.max_post_length + 1)).for(:raw) }\n  it { is_expected.not_to allow_value((\" \" * SiteSetting.min_post_length) + \"x\").for(:raw) }\n\n  it { is_expected.to rate_limit }\n\n  let(:topic) { Fabricate(:topic) }\n  let(:post_args) { { user: topic.user, topic: topic } }\n\n  describe \"scopes\" do\n    describe \"#by_newest\" do\n      it \"returns posts ordered by created_at desc\" do\n        2.times { |t| Fabricate(:post, created_at: t.seconds.from_now) }\n        expect(Post.by_newest.first.created_at).to be > Post.by_newest.last.created_at\n      end\n    end\n\n    describe \"#with_user\" do\n      it \"gives you a user\" do\n        Fabricate(:post, user: Fabricate.build(:user))\n        expect(Post.with_user.first.user).to be_a User\n      end\n    end\n  end\n\n  describe \"revisions and deleting/recovery\" do\n    context \"with a post without links\" do\n      let(:post) { Fabricate(:post, post_args) }\n\n      before do\n        post.trash!\n        post.reload\n      end\n\n      it \"doesn't create a new revision when deleted\" do\n        expect(post.revisions.count).to eq(0)\n      end\n\n      describe \"recovery\" do\n        before do\n          post.recover!\n          post.reload\n        end\n\n        it \"doesn't create a new revision when recovered\" do\n          expect(post.revisions.count).to eq(0)\n        end\n      end\n    end\n\n    context \"with a post with links\" do\n      let(:post) { Fabricate(:post_with_external_links) }\n      before do\n        post.trash!\n        post.reload\n      end\n\n      describe \"recovery\" do\n        it \"recreates the topic_link records\" do\n          TopicLink.expects(:extract_from).with(post)\n          post.recover!\n        end\n      end\n    end\n  end\n\n  context \"with a post with notices\" do\n    let(:post) do\n      post = Fabricate(:post, post_args)\n      post.upsert_custom_fields(\n        Post::NOTICE => {\n          type: Post.notices[:returning_user],\n          last_posted_at: 1.day.ago,\n        },\n      )\n      post\n    end\n\n    it \"will have its notice cleared when post is trashed\" do\n      expect { post.trash! }.to change { post.custom_fields }.to({})\n    end\n  end\n\n  describe \"with_secure_uploads?\" do\n    let(:topic) { Fabricate(:topic) }\n    let!(:post) { Fabricate(:post, topic: topic) }\n    it \"returns false if secure uploads is not enabled\" do\n      expect(post.with_secure_uploads?).to eq(false)\n    end\n\n    context \"when secure uploads is enabled\" do\n      before do\n        setup_s3\n        SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n        SiteSetting.secure_uploads = true\n      end\n\n      context \"if login_required\" do\n        before { SiteSetting.login_required = true }\n\n        it \"returns true\" do\n          expect(post.with_secure_uploads?).to eq(true)\n        end\n      end\n\n      context \"if the topic category is read_restricted\" do\n        let(:category) { Fabricate(:private_category, group: Fabricate(:group)) }\n        before { topic.change_category_to_id(category.id) }\n\n        it \"returns true\" do\n          expect(post.with_secure_uploads?).to eq(true)\n        end\n      end\n\n      context \"if the post is in a PM topic\" do\n        let(:topic) { Fabricate(:private_message_topic) }\n\n        it \"returns true\" do\n          expect(post.with_secure_uploads?).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"flagging helpers\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:user) { coding_horror }\n    fab!(:admin) { Fabricate(:admin) }\n\n    it \"is_flagged? is accurate\" do\n      PostActionCreator.off_topic(user, post)\n      expect(post.reload.is_flagged?).to eq(true)\n\n      PostActionDestroyer.destroy(user, post, :off_topic)\n      expect(post.reload.is_flagged?).to eq(false)\n    end\n\n    it \"is_flagged? is true if flag was deferred\" do\n      result = PostActionCreator.off_topic(user, post)\n      result.reviewable.perform(admin, :ignore_and_do_nothing)\n      expect(post.reload.is_flagged?).to eq(true)\n    end\n\n    it \"is_flagged? is true if flag was cleared\" do\n      result = PostActionCreator.off_topic(user, post)\n      result.reviewable.perform(admin, :disagree)\n      expect(post.reload.is_flagged?).to eq(true)\n    end\n\n    it \"reviewable_flag is nil when ignored\" do\n      result = PostActionCreator.spam(user, post)\n      expect(post.reviewable_flag).to eq(result.reviewable)\n\n      result.reviewable.perform(admin, :ignore_and_do_nothing)\n      expect(post.reviewable_flag).to be_nil\n    end\n\n    it \"reviewable_flag is nil when disagreed\" do\n      result = PostActionCreator.spam(user, post)\n      expect(post.reviewable_flag).to eq(result.reviewable)\n\n      result.reviewable.perform(admin, :disagree)\n      expect(post.reload.reviewable_flag).to be_nil\n    end\n  end\n\n  describe \"maximum media embeds\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:post_no_images) { Fabricate.build(:post, post_args.merge(user: newuser)) }\n    let(:post_one_image) { post_with_body(\"![sherlock](http://bbc.co.uk/sherlock.jpg)\", newuser) }\n    let(:post_two_images) do\n      post_with_body(\n        \"<img src='http://discourse.org/logo.png'> <img src='http://bbc.co.uk/sherlock.jpg'>\",\n        newuser,\n      )\n    end\n    let(:post_with_avatars) do\n      post_with_body(\n        '<img alt=\"smiley\" title=\":smiley:\" src=\"/assets/emoji/smiley.png\" class=\"avatar\"> <img alt=\"wink\" title=\":wink:\" src=\"/assets/emoji/wink.png\" class=\"avatar\">',\n        newuser,\n      )\n    end\n    let(:post_with_favicon) do\n      post_with_body('<img src=\"/images/favicons/discourse.png\" class=\"favicon\">', newuser)\n    end\n    let(:post_image_within_quote) do\n      post_with_body('[quote]<img src=\"coolimage.png\">[/quote]', newuser)\n    end\n    let(:post_image_within_code) do\n      post_with_body('<code><img src=\"coolimage.png\"></code>', newuser)\n    end\n    let(:post_image_within_pre) { post_with_body('<pre><img src=\"coolimage.png\"></pre>', newuser) }\n    let(:post_with_thumbnail) do\n      post_with_body('<img src=\"/assets/emoji/smiley.png\" class=\"thumbnail\">', newuser)\n    end\n    let(:post_with_two_classy_images) do\n      post_with_body(\n        \"<img src='http://discourse.org/logo.png' class='classy'> <img src='http://bbc.co.uk/sherlock.jpg' class='classy'>\",\n        newuser,\n      )\n    end\n    let(:post_with_two_embedded_media) do\n      post_with_body(\n        '<video width=\"950\" height=\"700\" controls><source src=\"https://bbc.co.uk/news.mp4\" type=\"video/mp4\"></video><audio controls><source type=\"audio/mpeg\" src=\"https://example.com/audio.mp3\"></audio>',\n        newuser,\n      )\n    end\n\n    it \"returns 0 images for an empty post\" do\n      expect(Fabricate.build(:post).embedded_media_count).to eq(0)\n    end\n\n    it \"finds images from markdown\" do\n      expect(post_one_image.embedded_media_count).to eq(1)\n    end\n\n    it \"finds images from HTML\" do\n      expect(post_two_images.embedded_media_count).to eq(2)\n    end\n\n    it \"doesn't count avatars as images\" do\n      expect(post_with_avatars.embedded_media_count).to eq(0)\n    end\n\n    it \"allows images by default\" do\n      expect(post_one_image).to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media`\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_one_image).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media` in a quote\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_image_within_quote).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media` in code\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_image_within_code).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media` in pre\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_image_within_pre).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media`\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 4\n      expect(post_one_image).to be_valid\n    end\n\n    it \"doesn't count favicons as images\" do\n      PrettyText.stubs(:cook).returns(post_with_favicon.raw)\n      expect(post_with_favicon.embedded_media_count).to eq(0)\n    end\n\n    it \"doesn't count thumbnails as images\" do\n      PrettyText.stubs(:cook).returns(post_with_thumbnail.raw)\n      expect(post_with_thumbnail.embedded_media_count).to eq(0)\n    end\n\n    it \"doesn't count allowlisted images\" do\n      Post.stubs(:allowed_image_classes).returns([\"classy\"])\n      # I dislike this, but passing in a custom allowlist is hard\n      PrettyText.stubs(:cook).returns(post_with_two_classy_images.raw)\n      expect(post_with_two_classy_images.embedded_media_count).to eq(0)\n    end\n\n    it \"counts video and audio as embedded media\" do\n      expect(post_with_two_embedded_media.embedded_media_count).to eq(2)\n    end\n\n    context \"with validation\" do\n      before { SiteSetting.newuser_max_embedded_media = 1 }\n\n      context \"with newuser\" do\n        it \"allows a new user to post below the limit\" do\n          expect(post_one_image).to be_valid\n        end\n\n        it \"doesn't allow more than the maximum number of images\" do\n          expect(post_two_images).not_to be_valid\n        end\n\n        it \"doesn't allow more than the maximum number of embedded media items\" do\n          expect(post_with_two_embedded_media).not_to be_valid\n        end\n\n        it \"doesn't allow a new user to edit their post to insert an image\" do\n          post_no_images.user.trust_level = TrustLevel[0]\n          post_no_images.save\n          expect {\n            post_no_images.revise(post_no_images.user, raw: post_two_images.raw)\n            post_no_images.reload\n          }.not_to change(post_no_images, :raw)\n        end\n      end\n\n      it \"allows more images from a not-new account\" do\n        post_two_images.user.trust_level = TrustLevel[1]\n        expect(post_two_images).to be_valid\n      end\n    end\n  end\n\n  describe \"maximum attachments\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:post_no_attachments) { Fabricate.build(:post, post_args.merge(user: newuser)) }\n    let(:post_one_attachment) do\n      post_with_body(\n        \"<a class='attachment' href='/#{upload_path}/1/2082985.txt'>file.txt</a>\",\n        newuser,\n      )\n    end\n    let(:post_two_attachments) do\n      post_with_body(\n        \"<a class='attachment' href='/#{upload_path}/2/20947092.log'>errors.log</a> <a class='attachment' href='/#{upload_path}/3/283572385.3ds'>model.3ds</a>\",\n        newuser,\n      )\n    end\n\n    it \"returns 0 attachments for an empty post\" do\n      expect(Fabricate.build(:post).attachment_count).to eq(0)\n    end\n\n    it \"finds attachments from HTML\" do\n      expect(post_two_attachments.attachment_count).to eq(2)\n    end\n\n    context \"with validation\" do\n      before { SiteSetting.newuser_max_attachments = 1 }\n\n      context \"with newuser\" do\n        it \"allows a new user to post below the limit\" do\n          expect(post_one_attachment).to be_valid\n        end\n\n        it \"doesn't allow more than the maximum\" do\n          expect(post_two_attachments).not_to be_valid\n        end\n\n        it \"doesn't allow a new user to edit their post to insert an attachment\" do\n          post_no_attachments.user.trust_level = TrustLevel[0]\n          post_no_attachments.save\n          expect {\n            post_no_attachments.revise(post_no_attachments.user, raw: post_two_attachments.raw)\n            post_no_attachments.reload\n          }.not_to change(post_no_attachments, :raw)\n        end\n      end\n\n      it \"allows more attachments from a not-new account\" do\n        post_two_attachments.user.trust_level = TrustLevel[1]\n        expect(post_two_attachments).to be_valid\n      end\n    end\n  end\n\n  describe \"links\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:no_links) { post_with_body(\"hello world my name is evil trout\", newuser) }\n    let(:one_link) { post_with_body(\"[jlawr](http://www.imdb.com/name/nm2225369)\", newuser) }\n    let(:two_links) do\n      post_with_body(\n        \"<a href='http://disneyland.disney.go.com/'>disney</a> <a href='http://reddit.com'>reddit</a>\",\n        newuser,\n      )\n    end\n    let(:three_links) do\n      post_with_body(\n        \"http://discourse.org and http://discourse.org/another_url and http://www.imdb.com/name/nm2225369\",\n        newuser,\n      )\n    end\n\n    describe \"raw_links\" do\n      it \"returns a blank collection for a post with no links\" do\n        expect(no_links.raw_links).to be_blank\n      end\n\n      it \"finds a link within markdown\" do\n        expect(one_link.raw_links).to eq([\"http://www.imdb.com/name/nm2225369\"])\n      end\n\n      it \"can find two links from html\" do\n        expect(two_links.raw_links).to eq(%w[http://disneyland.disney.go.com/ http://reddit.com])\n      end\n\n      it \"can find three links without markup\" do\n        expect(three_links.raw_links).to eq(\n          %w[\n            http://discourse.org\n            http://discourse.org/another_url\n            http://www.imdb.com/name/nm2225369\n          ],\n        )\n      end\n    end\n\n    describe \"linked_hosts\" do\n      it \"returns blank with no links\" do\n        expect(no_links.linked_hosts).to be_blank\n      end\n\n      it \"returns the host and a count for links\" do\n        expect(two_links.linked_hosts).to eq(\"disneyland.disney.go.com\" => 1, \"reddit.com\" => 1)\n      end\n\n      it \"it counts properly with more than one link on the same host\" do\n        expect(three_links.linked_hosts).to eq(\"discourse.org\" => 1, \"www.imdb.com\" => 1)\n      end\n    end\n\n    describe \"total host usage\" do\n      it \"has none for a regular post\" do\n        expect(no_links.total_hosts_usage).to be_blank\n      end\n\n      context \"with a previous host\" do\n        let(:another_disney_link) do\n          post_with_body(\n            \"[radiator springs](http://disneyland.disney.go.com/disney-california-adventure/radiator-springs-racers/)\",\n            newuser,\n          )\n        end\n\n        before do\n          another_disney_link.save\n          TopicLink.extract_from(another_disney_link)\n        end\n\n        it \"contains the new post's links, PLUS the previous one\" do\n          expect(two_links.total_hosts_usage).to eq(\n            \"disneyland.disney.go.com\" => 2,\n            \"reddit.com\" => 1,\n          )\n        end\n      end\n    end\n  end\n\n  describe \"maximums\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:post_one_link) do\n      post_with_body(\"[sherlock](http://www.bbc.co.uk/programmes/b018ttws)\", newuser)\n    end\n    let(:post_onebox) { post_with_body(\"http://www.google.com\", newuser) }\n    let(:post_code_link) { post_with_body(\"<code>http://www.google.com</code>\", newuser) }\n    let(:post_two_links) do\n      post_with_body(\n        \"<a href='http://discourse.org'>discourse</a> <a href='http://twitter.com'>twitter</a>\",\n        newuser,\n      )\n    end\n    let(:post_with_mentions) do\n      post_with_body(\"hello @#{newuser.username} how are you doing?\", newuser)\n    end\n\n    it \"returns 0 links for an empty post\" do\n      expect(Fabricate.build(:post).link_count).to eq(0)\n    end\n\n    it \"returns 0 links for a post with mentions\" do\n      expect(post_with_mentions.link_count).to eq(0)\n    end\n\n    it \"finds links from markdown\" do\n      expect(post_one_link.link_count).to eq(1)\n    end\n\n    it \"finds links from HTML\" do\n      expect(post_two_links.link_count).to eq(2)\n    end\n\n    context \"with validation\" do\n      before { SiteSetting.newuser_max_links = 1 }\n\n      context \"with newuser\" do\n        it \"returns true when within the amount of links allowed\" do\n          expect(post_one_link).to be_valid\n        end\n\n        it \"doesn't allow more links than allowed\" do\n          expect(post_two_links).not_to be_valid\n        end\n      end\n\n      it \"allows multiple links for basic accounts\" do\n        post_two_links.user.trust_level = TrustLevel[1]\n        expect(post_two_links).to be_valid\n      end\n\n      context \"with min_trust_to_post_links\" do\n        it \"considers oneboxes links\" do\n          SiteSetting.min_trust_to_post_links = 3\n          post_onebox.user.trust_level = TrustLevel[2]\n          expect(post_onebox).not_to be_valid\n        end\n\n        it \"considers links within code\" do\n          SiteSetting.min_trust_to_post_links = 3\n          post_onebox.user.trust_level = TrustLevel[2]\n          expect(post_code_link).not_to be_valid\n        end\n\n        it \"doesn't allow allow links if `min_trust_to_post_links` is not met\" do\n          SiteSetting.min_trust_to_post_links = 2\n          post_two_links.user.trust_level = TrustLevel[1]\n          expect(post_one_link).not_to be_valid\n        end\n\n        it \"will skip the check for allowlisted domains\" do\n          SiteSetting.allowed_link_domains = \"www.bbc.co.uk\"\n          SiteSetting.min_trust_to_post_links = 2\n          post_two_links.user.trust_level = TrustLevel[1]\n          expect(post_one_link).to be_valid\n        end\n      end\n    end\n  end\n\n  describe \"@mentions\" do\n    context \"with raw_mentions\" do\n      it \"returns an empty array with no matches\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"Hello Jake and Finn!\"))\n        expect(post.raw_mentions).to eq([])\n      end\n\n      it \"returns lowercase unique versions of the mentions\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@Jake @Finn @Jake\"))\n        expect(post.raw_mentions).to eq(%w[jake finn])\n      end\n\n      it \"ignores pre\" do\n        # we need to force an inline\n        post = Fabricate.build(:post, post_args.merge(raw: \"p <pre>@Jake</pre> @Finn\"))\n        expect(post.raw_mentions).to eq([\"finn\"])\n      end\n\n      it \"catches content between pre tags\" do\n        # per common mark we need to force an inline\n        post = Fabricate.build(:post, post_args.merge(raw: \"a <pre>hello</pre> @Finn <pre></pre>\"))\n        expect(post.raw_mentions).to eq([\"finn\"])\n      end\n\n      it \"ignores code\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@Jake `@Finn`\"))\n        expect(post.raw_mentions).to eq([\"jake\"])\n      end\n\n      it \"ignores quotes\" do\n        post =\n          Fabricate.build(\n            :post,\n            post_args.merge(raw: \"[quote=\\\"Evil Trout\\\"]\\n@Jake\\n[/quote]\\n@Finn\"),\n          )\n        expect(post.raw_mentions).to eq([\"finn\"])\n      end\n\n      it \"handles underscore in username\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@Jake @Finn @Jake_Old\"))\n        expect(post.raw_mentions).to eq(%w[jake finn jake_old])\n      end\n\n      it \"handles hyphen in groupname\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@org-board\"))\n        expect(post.raw_mentions).to eq([\"org-board\"])\n      end\n    end\n\n    context \"with max mentions\" do\n      fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n      let(:post_with_one_mention) { post_with_body(\"@Jake is the person I'm mentioning\", newuser) }\n      let(:post_with_two_mentions) do\n        post_with_body(\"@Jake @Finn are the people I'm mentioning\", newuser)\n      end\n\n      context \"with new user\" do\n        before do\n          SiteSetting.newuser_max_mentions_per_post = 1\n          SiteSetting.max_mentions_per_post = 5\n        end\n\n        it \"allows a new user to have newuser_max_mentions_per_post mentions\" do\n          expect(post_with_one_mention).to be_valid\n        end\n\n        it \"doesn't allow a new user to have more than newuser_max_mentions_per_post mentions\" do\n          expect(post_with_two_mentions).not_to be_valid\n        end\n      end\n\n      context \"when not a new user\" do\n        before do\n          SiteSetting.newuser_max_mentions_per_post = 0\n          SiteSetting.max_mentions_per_post = 1\n        end\n\n        it \"allows vmax_mentions_per_post mentions\" do\n          post_with_one_mention.user.trust_level = TrustLevel[1]\n          expect(post_with_one_mention).to be_valid\n        end\n\n        it \"doesn't allow to have more than max_mentions_per_post mentions\" do\n          post_with_two_mentions.user.trust_level = TrustLevel[1]\n          expect(post_with_two_mentions).not_to be_valid\n        end\n      end\n    end\n  end\n\n  describe \"validation\" do\n    it \"validates our default post\" do\n      expect(Fabricate.build(:post, post_args)).to be_valid\n    end\n\n    it \"create blank posts as invalid\" do\n      expect(Fabricate.build(:post, raw: \"\")).not_to be_valid\n    end\n  end\n\n  describe \"raw_hash\" do\n    let(:raw) { \"this is our test post body\" }\n    let(:post) { post_with_body(raw) }\n\n    it \"returns a value\" do\n      expect(post.raw_hash).to be_present\n    end\n\n    it \"returns blank for a nil body\" do\n      post.raw = nil\n      expect(post.raw_hash).to be_blank\n    end\n\n    it \"returns the same value for the same raw\" do\n      expect(post.raw_hash).to eq(post_with_body(raw).raw_hash)\n    end\n\n    it \"returns a different value for a different raw\" do\n      expect(post.raw_hash).not_to eq(post_with_body(\"something else\").raw_hash)\n    end\n\n    it \"returns a different value with different text case\" do\n      expect(post.raw_hash).not_to eq(post_with_body(\"THIS is OUR TEST post BODy\").raw_hash)\n    end\n  end\n\n  describe \"revise\" do\n    let(:post) { Fabricate(:post, post_args) }\n    let(:first_version_at) { post.last_version_at }\n\n    it \"has no revision\" do\n      expect(post.revisions.size).to eq(0)\n      expect(first_version_at).to be_present\n      expect(post.revise(post.user, raw: post.raw)).to eq(false)\n    end\n\n    context \"with the same body\" do\n      it \"doesn't change version\" do\n        expect {\n          post.revise(post.user, raw: post.raw)\n          post.reload\n        }.not_to change(post, :version)\n      end\n    end\n\n    context \"with grace period editing & edit windows\" do\n      before { SiteSetting.editing_grace_period = 1.minute.to_i }\n\n      it \"works\" do\n        revised_at = post.updated_at + 2.minutes\n        new_revised_at = revised_at + 2.minutes\n\n        # grace period edit\n        post.revise(post.user, { raw: \"updated body\" }, revised_at: post.updated_at + 10.seconds)\n        post.reload\n        expect(post.version).to eq(1)\n        expect(post.public_version).to eq(1)\n        expect(post.revisions.size).to eq(0)\n        expect(post.last_version_at.to_i).to eq(first_version_at.to_i)\n\n        # revision much later\n        post.revise(post.user, { raw: \"another updated body\" }, revised_at: revised_at)\n        post.reload\n        expect(post.version).to eq(2)\n        expect(post.public_version).to eq(2)\n        expect(post.revisions.size).to eq(1)\n        expect(post.last_version_at.to_i).to eq(revised_at.to_i)\n\n        # new edit window\n        post.revise(\n          post.user,\n          { raw: \"yet another updated body\" },\n          revised_at: revised_at + 10.seconds,\n        )\n        post.reload\n        expect(post.version).to eq(2)\n        expect(post.public_version).to eq(2)\n        expect(post.revisions.size).to eq(1)\n        expect(post.last_version_at.to_i).to eq(revised_at.to_i)\n\n        # after second window\n        post.revise(\n          post.user,\n          { raw: \"yet another, another updated body\" },\n          revised_at: new_revised_at,\n        )\n        post.reload\n        expect(post.version).to eq(3)\n        expect(post.public_version).to eq(3)\n        expect(post.revisions.size).to eq(2)\n        expect(post.last_version_at.to_i).to eq(new_revised_at.to_i)\n      end\n    end\n\n    context \"with rate limiter\" do\n      let(:changed_by) { coding_horror }\n\n      it \"triggers a rate limiter\" do\n        EditRateLimiter.any_instance.expects(:performed!)\n        post.revise(changed_by, raw: \"updated body\")\n      end\n    end\n\n    context \"with a new body\" do\n      let(:changed_by) { coding_horror }\n      let!(:result) { post.revise(changed_by, raw: \"updated body\") }\n\n      it \"acts correctly\" do\n        expect(result).to eq(true)\n        expect(post.raw).to eq(\"updated body\")\n        expect(post.invalidate_oneboxes).to eq(true)\n        expect(post.version).to eq(2)\n        expect(post.public_version).to eq(2)\n        expect(post.revisions.size).to eq(1)\n        expect(post.revisions.first.user).to be_present\n      end\n\n      context \"when second poster posts again quickly\" do\n        it \"is a grace period edit, because the second poster posted again quickly\" do\n          SiteSetting.editing_grace_period = 1.minute.to_i\n          post.revise(\n            changed_by,\n            { raw: \"yet another updated body\" },\n            revised_at: post.updated_at + 10.seconds,\n          )\n          post.reload\n\n          expect(post.version).to eq(2)\n          expect(post.public_version).to eq(2)\n          expect(post.revisions.size).to eq(1)\n        end\n      end\n    end\n  end\n\n  describe \"before save\" do\n    let(:cooked) do\n      \"<p><div class=\\\"lightbox-wrapper\\\"><a data-download-href=\\\"//localhost:3000/#{upload_path}/34784374092783e2fef84b8bc96d9b54c11ceea0\\\" href=\\\"//localhost:3000/#{upload_path}/original/1X/34784374092783e2fef84b8bc96d9b54c11ceea0.gif\\\" class=\\\"lightbox\\\" title=\\\"Sword reworks.gif\\\"><img src=\\\"//localhost:3000/#{upload_path}/optimized/1X/34784374092783e2fef84b8bc96d9b54c11ceea0_1_690x276.gif\\\" width=\\\"690\\\" height=\\\"276\\\"><div class=\\\"meta\\\">\\n<span class=\\\"filename\\\">Sword reworks.gif</span><span class=\\\"informations\\\">1000x400 1000 KB</span><span class=\\\"expand\\\"></span>\\n</div></a></div></p>\"\n    end\n\n    let(:post) do\n      Fabricate(\n        :post,\n        raw:\n          \"<img src=\\\"/#{upload_path}/original/1X/34784374092783e2fef84b8bc96d9b54c11ceea0.gif\\\" width=\\\"690\\\" height=\\\"276\\\">\",\n        cooked: cooked,\n      )\n    end\n\n    it \"should not cook the post if raw has not been changed\" do\n      post.save!\n      expect(post.cooked).to eq(cooked)\n    end\n  end\n\n  describe \"after save\" do\n    let(:post) { Fabricate(:post, post_args) }\n\n    it \"has correct info set\" do\n      expect(post.user_deleted?).to eq(false)\n      expect(post.post_number).to be_present\n      expect(post.excerpt).to be_present\n      expect(post.post_type).to eq(Post.types[:regular])\n      expect(post.revisions).to be_blank\n      expect(post.cooked).to be_present\n      expect(post.external_id).to be_present\n      expect(post.quote_count).to eq(0)\n      expect(post.replies).to be_blank\n    end\n\n    context \"with extract_quoted_post_numbers\" do\n      let!(:post) { Fabricate(:post, post_args) }\n      let(:reply) { Fabricate.build(:post, post_args) }\n\n      it \"finds the quote when in the same topic\" do\n        reply.raw =\n          \"[quote=\\\"EvilTrout, post:#{post.post_number}, topic:#{post.topic_id}\\\"]hello[/quote]\"\n        reply.extract_quoted_post_numbers\n        expect(reply.quoted_post_numbers).to eq([post.post_number])\n      end\n\n      it \"doesn't find the quote in a different topic\" do\n        reply.raw =\n          \"[quote=\\\"EvilTrout, post:#{post.post_number}, topic:#{post.topic_id + 1}\\\"]hello[/quote]\"\n        reply.extract_quoted_post_numbers\n        expect(reply.quoted_post_numbers).to be_blank\n      end\n\n      it \"doesn't find the quote in the same post\" do\n        reply = Fabricate.build(:post, post_args.merge(post_number: 646))\n        reply.raw =\n          \"[quote=\\\"EvilTrout, post:#{reply.post_number}, topic:#{post.topic_id}\\\"]hello[/quote]\"\n        reply.extract_quoted_post_numbers\n        expect(reply.quoted_post_numbers).to be_blank\n      end\n    end\n\n    context \"with a new reply\" do\n      fab!(:topic) { Fabricate(:topic) }\n      let(:other_user) { coding_horror }\n      let(:reply_text) { \"[quote=\\\"Evil Trout, post:1\\\"]\\nhello\\n[/quote]\\nHmmm!\" }\n      let!(:post) do\n        PostCreator.new(topic.user, raw: Fabricate.build(:post).raw, topic_id: topic.id).create\n      end\n      let!(:reply) do\n        PostCreator.new(\n          other_user,\n          raw: reply_text,\n          topic_id: topic.id,\n          reply_to_post_number: post.post_number,\n        ).create\n      end\n\n      it \"has a quote\" do\n        expect(reply.quote_count).to eq(1)\n      end\n\n      it \"has a reply to the user of the original user\" do\n        expect(reply.reply_to_user).to eq(post.user)\n      end\n\n      it \"increases the reply count of the parent\" do\n        post.reload\n        expect(post.reply_count).to eq(1)\n      end\n\n      it \"increases the reply count of the topic\" do\n        topic.reload\n        expect(topic.reply_count).to eq(1)\n      end\n\n      it \"is the child of the parent post\" do\n        expect(post.replies).to eq([reply])\n      end\n\n      it \"doesn't change the post count when you edit the reply\" do\n        reply.raw = \"updated raw\"\n        reply.save\n        post.reload\n        expect(post.reply_count).to eq(1)\n      end\n\n      context \"with a multi-quote reply\" do\n        let!(:multi_reply) do\n          raw =\n            \"[quote=\\\"Evil Trout, post:1\\\"]post1 quote[/quote]\\nAha!\\n[quote=\\\"Evil Trout, post:2\\\"]post2 quote[/quote]\\nNeat-o\"\n          PostCreator.new(\n            other_user,\n            raw: raw,\n            topic_id: topic.id,\n            reply_to_post_number: post.post_number,\n          ).create\n        end\n\n        it \"has the correct info set\" do\n          expect(multi_reply.quote_count).to eq(2)\n          expect(post.replies.include?(multi_reply)).to eq(true)\n          expect(reply.replies.include?(multi_reply)).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"summary\" do\n    let!(:p1) { Fabricate(:post, post_args.merge(score: 4, percent_rank: 0.33)) }\n    let!(:p2) { Fabricate(:post, post_args.merge(score: 10, percent_rank: 0.66)) }\n    let!(:p3) { Fabricate(:post, post_args.merge(score: 5, percent_rank: 0.99)) }\n    fab!(:p4) { Fabricate(:post, percent_rank: 0.99) }\n\n    it \"returns the OP and posts above the threshold in summary mode\" do\n      SiteSetting.summary_percent_filter = 66\n      expect(Post.summary(topic.id).order(:post_number)).to eq([p1, p2])\n      expect(Post.summary(p4.topic.id)).to eq([p4])\n    end\n  end\n\n  describe \"sort_order\" do\n    context \"with a regular topic\" do\n      let!(:p1) { Fabricate(:post, post_args) }\n      let!(:p2) { Fabricate(:post, post_args) }\n      let!(:p3) { Fabricate(:post, post_args) }\n\n      it \"defaults to created order\" do\n        expect(Post.regular_order).to eq([p1, p2, p3])\n      end\n    end\n  end\n\n  describe \"reply_history\" do\n    let!(:p1) { Fabricate(:post, post_args) }\n    let!(:p2) { Fabricate(:post, post_args.merge(reply_to_post_number: p1.post_number)) }\n    let!(:p3) { Fabricate(:post, post_args) }\n    let!(:p4) { Fabricate(:post, post_args.merge(reply_to_post_number: p2.post_number)) }\n\n    it \"returns the posts in reply to this post\" do\n      expect(p4.reply_history).to eq([p1, p2])\n      expect(p4.reply_history(1)).to eq([p2])\n      expect(p3.reply_history).to be_blank\n      expect(p2.reply_history).to eq([p1])\n    end\n  end\n\n  describe \"reply_ids\" do\n    fab!(:topic) { Fabricate(:topic) }\n    let!(:p1) { Fabricate(:post, topic: topic, post_number: 1) }\n    let!(:p2) { Fabricate(:post, topic: topic, post_number: 2, reply_to_post_number: 1) }\n    let!(:p3) { Fabricate(:post, topic: topic, post_number: 3) }\n    let!(:p4) { Fabricate(:post, topic: topic, post_number: 4, reply_to_post_number: 2) }\n    let!(:p5) { Fabricate(:post, topic: topic, post_number: 5, reply_to_post_number: 4) }\n    let!(:p6) { Fabricate(:post, topic: topic, post_number: 6) }\n\n    before do\n      PostReply.create!(post: p1, reply: p2)\n      PostReply.create!(post: p2, reply: p4)\n      PostReply.create!(post: p2, reply: p6) # simulates p6 quoting p2\n      PostReply.create!(post: p3, reply: p5) # simulates p5 quoting p3\n      PostReply.create!(post: p4, reply: p5)\n      PostReply.create!(post: p6, reply: p6) # https://meta.discourse.org/t/topic-quoting-itself-displays-reply-indicator/76085\n    end\n\n    it \"returns the reply ids and their level\" do\n      expect(p1.reply_ids).to eq(\n        [{ id: p2.id, level: 1 }, { id: p4.id, level: 2 }, { id: p6.id, level: 2 }],\n      )\n      expect(p2.reply_ids).to eq([{ id: p4.id, level: 1 }, { id: p6.id, level: 1 }])\n      expect(p3.reply_ids).to be_empty # has no replies\n      expect(p4.reply_ids).to be_empty # p5 replies to 2 posts (p4 and p3)\n      expect(p5.reply_ids).to be_empty # has no replies\n      expect(p6.reply_ids).to be_empty # quotes itself\n    end\n\n    it \"ignores posts moved to other topics\" do\n      p2.update_column(:topic_id, Fabricate(:topic).id)\n      expect(p1.reply_ids).to be_blank\n    end\n\n    it \"doesn't include the same reply twice\" do\n      PostReply.create!(post: p4, reply: p1)\n      expect(p1.reply_ids.size).to eq(4)\n    end\n\n    it \"does not skip any replies\" do\n      expect(p1.reply_ids(only_replies_to_single_post: false)).to eq(\n        [\n          { id: p2.id, level: 1 },\n          { id: p4.id, level: 2 },\n          { id: p5.id, level: 3 },\n          { id: p6.id, level: 2 },\n        ],\n      )\n      expect(p2.reply_ids(only_replies_to_single_post: false)).to eq(\n        [{ id: p4.id, level: 1 }, { id: p5.id, level: 2 }, { id: p6.id, level: 1 }],\n      )\n      expect(p3.reply_ids(only_replies_to_single_post: false)).to eq([{ id: p5.id, level: 1 }])\n      expect(p4.reply_ids(only_replies_to_single_post: false)).to eq([{ id: p5.id, level: 1 }])\n      expect(p5.reply_ids(only_replies_to_single_post: false)).to be_empty # has no replies\n      expect(p6.reply_ids(only_replies_to_single_post: false)).to be_empty # quotes itself\n    end\n  end\n\n  describe \"urls\" do\n    it \"no-ops for empty list\" do\n      expect(Post.urls([])).to eq({})\n    end\n\n    # integration test -> should move to centralized integration test\n    it \"finds urls for posts presented\" do\n      p1 = Fabricate(:post)\n      p2 = Fabricate(:post)\n      expect(Post.urls([p1.id, p2.id])).to eq(p1.id => p1.url, p2.id => p2.url)\n    end\n  end\n\n  describe \"details\" do\n    it \"adds details\" do\n      post = Fabricate.build(:post)\n      post.add_detail(\"key\", \"value\")\n      expect(post.post_details.size).to eq(1)\n      expect(post.post_details.first.key).to eq(\"key\")\n      expect(post.post_details.first.value).to eq(\"value\")\n    end\n\n    it \"can find a post by a detail\" do\n      detail = Fabricate(:post_detail)\n      post = detail.post\n      expect(Post.find_by_detail(detail.key, detail.value).id).to eq(post.id)\n    end\n  end\n\n  describe \"cooking\" do\n    let(:post) do\n      Fabricate.build(:post, post_args.merge(raw: \"please read my blog http://blog.example.com\"))\n    end\n\n    it \"should unconditionally follow links for staff\" do\n      SiteSetting.tl3_links_no_follow = true\n      post.user.trust_level = 1\n      post.user.moderator = true\n      post.save\n\n      expect(post.cooked).not_to match(/nofollow/)\n    end\n\n    it \"should add nofollow to links in the post for trust levels below 3\" do\n      post.user.trust_level = 2\n      post.save\n      expect(post.cooked).to match(/noopener nofollow ugc/)\n    end\n\n    it \"when tl3_links_no_follow is false, should not add nofollow for trust level 3 and higher\" do\n      SiteSetting.tl3_links_no_follow = false\n      post.user.trust_level = 3\n      post.save\n      expect(post.cooked).not_to match(/nofollow/)\n    end\n\n    it \"when tl3_links_no_follow is true, should add nofollow for trust level 3 and higher\" do\n      SiteSetting.tl3_links_no_follow = true\n      post.user.trust_level = 3\n      post.save\n      expect(post.cooked).to match(/noopener nofollow ugc/)\n    end\n\n    it \"passes the last_editor_id as the markdown user_id option\" do\n      post.save\n      post.reload\n      PostAnalyzer\n        .any_instance\n        .expects(:cook)\n        .with(post.raw, { cook_method: Post.cook_methods[:regular], user_id: post.last_editor_id })\n      post.cook(post.raw)\n      user_editor = Fabricate(:user)\n      post.update!(last_editor_id: user_editor.id)\n      PostAnalyzer\n        .any_instance\n        .expects(:cook)\n        .with(post.raw, { cook_method: Post.cook_methods[:regular], user_id: user_editor.id })\n      post.cook(post.raw)\n    end\n\n    describe \"mentions\" do\n      fab!(:group) do\n        Fabricate(\n          :group,\n          visibility_level: Group.visibility_levels[:members],\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n        )\n      end\n\n      before { Jobs.run_immediately! }\n\n      describe \"when user can not mention a group\" do\n        it \"should not create the mention with the notify class\" do\n          post = Fabricate(:post, raw: \"hello @#{group.name}\")\n          post.trigger_post_process\n          post.reload\n\n          expect(post.cooked).to eq(\n            %Q|<p>hello <a class=\"mention-group\" href=\"/groups/#{group.name}\">@#{group.name}</a></p>|,\n          )\n        end\n      end\n\n      describe \"when user can mention a group\" do\n        before { group.add(post.user) }\n\n        it \"should create the mention\" do\n          post.update!(raw: \"hello @#{group.name}\")\n          post.trigger_post_process\n          post.reload\n\n          expect(post.cooked).to eq(\n            %Q|<p>hello <a class=\"mention-group notify\" href=\"/groups/#{group.name}\">@#{group.name}</a></p>|,\n          )\n        end\n      end\n\n      describe \"when group owner can mention a group\" do\n        before do\n          group.update!(mentionable_level: Group::ALIAS_LEVELS[:owners_mods_and_admins])\n          group.add_owner(post.user)\n        end\n\n        it \"should create the mention\" do\n          post.update!(raw: \"hello @#{group.name}\")\n          post.trigger_post_process\n          post.reload\n\n          expect(post.cooked).to eq(\n            %Q|<p>hello <a class=\"mention-group notify\" href=\"/groups/#{group.name}\">@#{group.name}</a></p>|,\n          )\n        end\n      end\n    end\n  end\n\n  describe \"has_host_spam\" do\n    let(:raw) do\n      \"hello from my site http://www.example.net http://#{GlobalSetting.hostname} http://#{RailsMultisite::ConnectionManagement.current_hostname}\"\n    end\n\n    it \"correctly detects host spam\" do\n      post = Fabricate(:post, raw: raw)\n\n      expect(post.total_hosts_usage).to eq(\"www.example.net\" => 1)\n      post.acting_user.trust_level = 0\n\n      expect(post.has_host_spam?).to eq(false)\n\n      SiteSetting.newuser_spam_host_threshold = 1\n\n      expect(post.has_host_spam?).to eq(true)\n\n      SiteSetting.allowed_spam_host_domains = \"bla.com|boo.com | example.net \"\n      expect(post.has_host_spam?).to eq(false)\n    end\n\n    it \"doesn't punish staged users\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      user = Fabricate(:user, staged: true, trust_level: 0)\n      post = Fabricate(:post, raw: raw, user: user)\n      expect(post.has_host_spam?).to eq(false)\n    end\n\n    it \"punishes previously staged users that were created within 1 day\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      SiteSetting.newuser_max_links = 3\n      user = Fabricate(:user, staged: true, trust_level: 0)\n      user.created_at = 1.hour.ago\n      user.unstage!\n      post = Fabricate(:post, raw: raw, user: user)\n      expect(post.has_host_spam?).to eq(true)\n    end\n\n    it \"doesn't punish previously staged users over 1 day old\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      SiteSetting.newuser_max_links = 3\n      user = Fabricate(:user, staged: true, trust_level: 0)\n      user.created_at = 2.days.ago\n      user.unstage!\n      post = Fabricate(:post, raw: raw, user: user)\n      expect(post.has_host_spam?).to eq(false)\n    end\n\n    it \"ignores private messages\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      user = Fabricate(:user, trust_level: 0)\n      post =\n        Fabricate(:post, raw: raw, user: user, topic: Fabricate(:private_message_topic, user: user))\n      expect(post.has_host_spam?).to eq(false)\n    end\n  end\n\n  it \"has custom fields\" do\n    post = Fabricate(:post)\n    expect(post.custom_fields[\"a\"]).to eq(nil)\n\n    post.custom_fields[\"Tommy\"] = \"Hanks\"\n    post.custom_fields[\"Vincent\"] = \"Vega\"\n    post.save\n\n    post = Post.find(post.id)\n    expect(post.custom_fields).to eq(\"Tommy\" => \"Hanks\", \"Vincent\" => \"Vega\")\n  end\n\n  describe \"#excerpt_for_topic\" do\n    it \"returns a topic excerpt, defaulting to 220 chars\" do\n      expected_excerpt =\n        \"This is a sample post with semi-long raw content. The raw content is also more than \\ntwo hundred characters to satisfy any test conditions that require content longer \\nthan the typical test post raw content. It really is&hellip;\"\n      post = Fabricate(:post_with_long_raw_content)\n      post.rebake!\n      excerpt = post.excerpt_for_topic\n      expect(excerpt).to eq(expected_excerpt)\n    end\n\n    it \"respects the site setting for topic excerpt\" do\n      SiteSetting.topic_excerpt_maxlength = 10\n      expected_excerpt = \"This is a &hellip;\"\n      post = Fabricate(:post_with_long_raw_content)\n      post.rebake!\n      excerpt = post.excerpt_for_topic\n      expect(excerpt).to eq(expected_excerpt)\n    end\n  end\n\n  describe \"#rebake!\" do\n    it \"will rebake a post correctly\" do\n      post = create_post\n      expect(post.baked_at).not_to eq(nil)\n      first_baked = post.baked_at\n      first_cooked = post.cooked\n\n      DB.exec(\"UPDATE posts SET cooked = 'frogs' WHERE id = ?\", [post.id])\n      post.reload\n\n      post.expects(:publish_change_to_clients!).with(:rebaked)\n\n      result = post.rebake!\n\n      expect(post.baked_at).not_to eq_time(first_baked)\n      expect(post.cooked).to eq(first_cooked)\n      expect(result).to eq(true)\n    end\n\n    it \"updates the topic excerpt at the same time if it is the OP\" do\n      post = create_post\n      post.topic.update(excerpt: \"test\")\n      DB.exec(\"UPDATE posts SET cooked = 'frogs' WHERE id = ?\", [post.id])\n      post.reload\n      result = post.rebake!\n      post.topic.reload\n      expect(post.topic.excerpt).not_to eq(\"test\")\n    end\n\n    it \"does not update the topic excerpt if the post is not the OP\" do\n      post = create_post\n      post2 = create_post\n      post.topic.update(excerpt: \"test\")\n      result = post2.rebake!\n      post.topic.reload\n      expect(post.topic.excerpt).to eq(\"test\")\n    end\n\n    it \"works with posts in deleted topics\" do\n      post = create_post\n      post.topic.trash!\n      post.reload\n      post.rebake!\n    end\n\n    it \"uses inline onebox cache by default\" do\n      Jobs.run_immediately!\n      stub_request(:get, \"http://testonebox.com/vvf\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is Testonebox!</title>\n        </head></html>\n      HTML\n      post = create_post(raw: <<~POST).reload\n        hello inline onebox http://testonebox.com/vvf\n      POST\n      expect(post.cooked).to include(\"hello this is Testonebox!\")\n\n      stub_request(:get, \"http://testonebox.com/vvf\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is updated Testonebox!</title>\n        </head></html>\n      HTML\n      post.rebake!\n      expect(post.reload.cooked).to include(\"hello this is Testonebox!\")\n    ensure\n      InlineOneboxer.invalidate(\"http://testonebox.com/vvf\")\n    end\n\n    it \"passing invalidate_oneboxes: true ignores inline onebox cache\" do\n      Jobs.run_immediately!\n      stub_request(:get, \"http://testonebox.com/vvf22\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is Testonebox!</title>\n        </head></html>\n      HTML\n      post = create_post(raw: <<~POST).reload\n        hello inline onebox http://testonebox.com/vvf22\n      POST\n      expect(post.cooked).to include(\"hello this is Testonebox!\")\n\n      stub_request(:get, \"http://testonebox.com/vvf22\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is updated Testonebox!</title>\n        </head></html>\n      HTML\n      post.rebake!(invalidate_oneboxes: true)\n      expect(post.reload.cooked).to include(\"hello this is updated Testonebox!\")\n    ensure\n      InlineOneboxer.invalidate(\"http://testonebox.com/vvf22\")\n    end\n  end\n\n  describe \"#set_owner\" do\n    fab!(:post) { Fabricate(:post) }\n\n    it \"will change owner of a post correctly\" do\n      post.set_owner(coding_horror, Discourse.system_user)\n      post.reload\n\n      expect(post.user).to eq(coding_horror)\n      expect(post.revisions.size).to eq(1)\n    end\n\n    it \"skips creating new post revision if skip_revision is true\" do\n      post.set_owner(coding_horror, Discourse.system_user, true)\n      post.reload\n\n      expect(post.user).to eq(coding_horror)\n      expect(post.revisions.size).to eq(0)\n    end\n\n    it \"uses default locale for edit reason\" do\n      I18n.locale = \"de\"\n\n      post.set_owner(coding_horror, Discourse.system_user)\n      post.reload\n\n      expected_reason =\n        I18n.with_locale(SiteSetting.default_locale) { I18n.t(\"change_owner.post_revision_text\") }\n\n      expect(post.edit_reason).to eq(expected_reason)\n    end\n  end\n\n  describe \".rebake_old\" do\n    it \"will catch posts it needs to rebake\" do\n      post = create_post\n      post.update_columns(baked_at: Time.new(2000, 1, 1), baked_version: -1)\n      Post.rebake_old(100)\n\n      post.reload\n      expect(post.baked_at).to be > 1.day.ago\n\n      baked = post.baked_at\n      Post.rebake_old(100)\n      post.reload\n      expect(post.baked_at).to eq_time(baked)\n    end\n\n    it \"will rate limit globally\" do\n      post1 = create_post\n      post2 = create_post\n      post3 = create_post\n\n      Post.where(id: [post1.id, post2.id, post3.id]).update_all(baked_version: -1)\n\n      global_setting :max_old_rebakes_per_15_minutes, 2\n\n      RateLimiter.clear_all_global!\n      RateLimiter.enable\n\n      Post.rebake_old(100)\n\n      expect(post3.reload.baked_version).not_to eq(-1)\n      expect(post2.reload.baked_version).not_to eq(-1)\n      expect(post1.reload.baked_version).to eq(-1)\n    end\n  end\n\n  describe \"#hide!\" do\n    fab!(:post) { Fabricate(:post) }\n\n    after { Discourse.redis.flushdb }\n\n    it \"should ignore the unique post validator when hiding a post with similar content as a recent post\" do\n      post_2 = Fabricate(:post, user: post.user)\n      SiteSetting.unique_posts_mins = 10\n      post.store_unique_post_key\n\n      expect(post_2.valid?).to eq(false)\n      expect(post_2.errors.full_messages.to_s).to include(I18n.t(:just_posted_that))\n\n      post_2.hide!(PostActionType.types[:off_topic])\n\n      expect(post_2.reload.hidden).to eq(true)\n    end\n\n    it \"should decrease user_stat topic_count for first post\" do\n      expect do post.hide!(PostActionType.types[:off_topic]) end.to change {\n        post.user.user_stat.reload.topic_count\n      }.from(1).to(0)\n    end\n\n    it \"should decrease user_stat post_count\" do\n      post_2 = Fabricate(:post, topic: post.topic, user: post.user)\n\n      expect do post_2.hide!(PostActionType.types[:off_topic]) end.to change {\n        post_2.user.user_stat.reload.post_count\n      }.from(1).to(0)\n    end\n  end\n\n  describe \"#unhide!\" do\n    fab!(:post) { Fabricate(:post) }\n\n    before { SiteSetting.unique_posts_mins = 5 }\n\n    it \"will unhide the first post & make the topic visible\" do\n      hidden_topic = Fabricate(:topic, visible: false)\n\n      post = create_post(topic: hidden_topic)\n      post.update_columns(hidden: true, hidden_at: Time.now, hidden_reason_id: 1)\n      post.reload\n\n      expect(post.hidden).to eq(true)\n\n      post.expects(:publish_change_to_clients!).with(:acted)\n\n      post.unhide!\n\n      post.reload\n      hidden_topic.reload\n\n      expect(post.hidden).to eq(false)\n      expect(hidden_topic.visible).to eq(true)\n    end\n\n    it \"should increase user_stat topic_count for first post\" do\n      post.hide!(PostActionType.types[:off_topic])\n\n      expect do post.unhide! end.to change { post.user.user_stat.reload.topic_count }.from(0).to(1)\n    end\n\n    it \"should decrease user_stat post_count\" do\n      post_2 = Fabricate(:post, topic: post.topic, user: post.user)\n      post_2.hide!(PostActionType.types[:off_topic])\n\n      expect do post_2.unhide! end.to change { post_2.user.user_stat.reload.post_count }.from(0).to(\n        1,\n      )\n    end\n  end\n\n  it \"will unhide the post but will keep the topic invisible/unlisted\" do\n    hidden_topic = Fabricate(:topic, visible: false)\n    create_post(topic: hidden_topic)\n    second_post = create_post(topic: hidden_topic)\n\n    second_post.update_columns(hidden: true, hidden_at: Time.now, hidden_reason_id: 1)\n    second_post.expects(:publish_change_to_clients!).with(:acted)\n\n    second_post.unhide!\n\n    second_post.reload\n    hidden_topic.reload\n\n    expect(second_post.hidden).to eq(false)\n    expect(hidden_topic.visible).to eq(false)\n  end\n\n  it \"automatically orders post revisions by number ascending\" do\n    post = Fabricate(:post)\n    post.revisions.create!(user_id: 1, post_id: post.id, number: 2)\n    post.revisions.create!(user_id: 1, post_id: post.id, number: 1)\n    expect(post.revisions.pluck(:number)).to eq([1, 2])\n  end\n\n  describe \"video_thumbnails\" do\n    fab!(:video_upload) { Fabricate(:upload, extension: \"mp4\") }\n    fab!(:image_upload) { Fabricate(:upload) }\n    fab!(:image_upload_2) { Fabricate(:upload) }\n    let(:base_url) { \"#{Discourse.base_url_no_prefix}#{Discourse.base_path}\" }\n    let(:video_url) { \"#{base_url}#{video_upload.url}\" }\n\n    let(:raw_video) { <<~RAW }\n      <video width=\"100%\" height=\"100%\" controls>\n        <source src=\"#{video_url}\">\n        <a href=\"#{video_url}\">#{video_url}</a>\n      </video>\n      RAW\n\n    let(:post) { Fabricate(:post, raw: raw_video) }\n\n    before { SiteSetting.video_thumbnails_enabled = true }\n\n    it \"has a topic thumbnail\" do\n      # Thumbnails are tied to a specific video file by using the\n      # video's sha1 as the image filename\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(1)\n    end\n\n    it \"only applies for video uploads\" do\n      image_upload.original_filename = \"#{image_upload_2.sha1}.png\"\n      image_upload.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(0)\n    end\n\n    it \"does not overwrite existing thumbnails\" do\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      post.topic.image_upload_id = image_upload_2.id\n      post.topic.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.image_upload_id).to eq(image_upload_2.id)\n    end\n\n    it \"uses the newest thumbnail\" do\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      image_upload_2.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload_2.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(1)\n      expect(post.topic.image_upload_id).to eq(image_upload_2.id)\n    end\n\n    it \"does not create thumbnails when disabled\" do\n      SiteSetting.video_thumbnails_enabled = false\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(0)\n    end\n  end\n\n  describe \"uploads\" do\n    fab!(:video_upload) { Fabricate(:upload, extension: \"mp4\") }\n    fab!(:image_upload) { Fabricate(:upload) }\n    fab!(:audio_upload) { Fabricate(:upload, extension: \"ogg\") }\n    fab!(:attachment_upload) { Fabricate(:upload, extension: \"csv\") }\n    fab!(:attachment_upload_2) { Fabricate(:upload) }\n    fab!(:attachment_upload_3) { Fabricate(:upload, extension: nil) }\n\n    let(:base_url) { \"#{Discourse.base_url_no_prefix}#{Discourse.base_path}\" }\n    let(:video_url) { \"#{base_url}#{video_upload.url}\" }\n    let(:audio_url) { \"#{base_url}#{audio_upload.url}\" }\n\n    let(:raw_multiple) { <<~RAW }\n      <a href=\"#{attachment_upload.url}\">Link</a>\n      [test|attachment](#{attachment_upload_2.short_url})\n      [test3|attachment](#{attachment_upload_3.short_url})\n      <img src=\"#{image_upload.url}\">\n\n      <video width=\"100%\" height=\"100%\" controls>\n        <source src=\"#{video_url}\">\n        <a href=\"#{video_url}\">#{video_url}</a>\n      </video>\n\n      <audio controls>\n        <source src=\"#{audio_url}\">\n        <a href=\"#{audio_url}\">#{audio_url}</a>\n      </audio>\n      RAW\n\n    let(:post) { Fabricate(:post, raw: raw_multiple) }\n\n    it \"removes post uploads on destroy\" do\n      post.link_post_uploads\n\n      post.trash!\n      expect(UploadReference.count).to eq(6)\n\n      post.destroy!\n      expect(UploadReference.count).to eq(0)\n    end\n\n    describe \"#link_post_uploads\" do\n      it \"finds all the uploads in the post\" do\n        post.link_post_uploads\n\n        expect(UploadReference.where(target: post).pluck(:upload_id)).to contain_exactly(\n          video_upload.id,\n          image_upload.id,\n          audio_upload.id,\n          attachment_upload.id,\n          attachment_upload_2.id,\n          attachment_upload_3.id,\n        )\n      end\n\n      it \"cleans the reverse index up for the current post\" do\n        post.link_post_uploads\n\n        post_uploads_ids = post.upload_references.pluck(:id)\n\n        post.link_post_uploads\n\n        expect(post.reload.upload_references.pluck(:id)).to_not contain_exactly(post_uploads_ids)\n      end\n\n      context \"when secure uploads is enabled\" do\n        before do\n          setup_s3\n          SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n          SiteSetting.secure_uploads = true\n        end\n\n        it \"sets the access_control_post_id on uploads in the post that don't already have the value set\" do\n          other_post = Fabricate(:post)\n          video_upload.update(access_control_post_id: other_post.id)\n          audio_upload.update(access_control_post_id: other_post.id)\n\n          post.link_post_uploads\n\n          image_upload.reload\n          video_upload.reload\n          expect(image_upload.access_control_post_id).to eq(post.id)\n          expect(video_upload.access_control_post_id).not_to eq(post.id)\n        end\n\n        context \"for custom emoji\" do\n          before { CustomEmoji.create(name: \"meme\", upload: image_upload) }\n          it \"never sets an access control post because they should not be secure\" do\n            post.link_post_uploads\n            expect(image_upload.reload.access_control_post_id).to eq(nil)\n          end\n        end\n      end\n    end\n\n    describe \"#update_uploads_secure_status\" do\n      fab!(:user) { Fabricate(:user, trust_level: 0) }\n\n      let(:raw) { <<~RAW }\n        <a href=\"#{attachment_upload.url}\">Link</a>\n        <img src=\"#{image_upload.url}\">\n        RAW\n\n      before do\n        Jobs.run_immediately!\n\n        setup_s3\n        SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n        SiteSetting.secure_uploads = true\n\n        attachment_upload.update!(original_filename: \"hello.csv\")\n\n        stub_upload(attachment_upload)\n        stub_upload(image_upload)\n      end\n\n      it \"marks image and attachment uploads as secure in PMs when secure_uploads is ON\" do\n        SiteSetting.secure_uploads = true\n        post =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:private_message_topic, user: user),\n          )\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: post).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, true], [image_upload.id, true])\n      end\n\n      it \"marks image uploads as not secure in PMs when when secure_uploads is ON\" do\n        SiteSetting.secure_uploads = false\n        post =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:private_message_topic, user: user),\n          )\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: post).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, false], [image_upload.id, false])\n      end\n\n      it \"marks attachments as secure when relevant setting is enabled\" do\n        SiteSetting.secure_uploads = true\n        private_category = Fabricate(:private_category, group: Fabricate(:group))\n        post =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:topic, user: user, category: private_category),\n          )\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: post).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, true], [image_upload.id, true])\n      end\n\n      it \"does not mark an upload as secure if it has already been used in a public topic\" do\n        post = Fabricate(:post, raw: raw, user: user, topic: Fabricate(:topic, user: user))\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        pm =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:private_message_topic, user: user),\n          )\n        pm.link_post_uploads\n        pm.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: pm).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, false], [image_upload.id, false])\n      end\n    end\n  end\n\n  describe \"topic updated_at\" do\n    let :topic do\n      create_post.topic\n    end\n\n    def updates_topic_updated_at\n      time = freeze_time 1.day.from_now\n      result = yield\n\n      topic.reload\n      expect(topic.updated_at).to eq_time(time)\n\n      result\n    end\n\n    it \"will update topic updated_at for all topic related events\" do\n      SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n\n      post =\n        updates_topic_updated_at do\n          create_post(topic_id: topic.id, post_type: Post.types[:whisper])\n        end\n\n      updates_topic_updated_at { PostDestroyer.new(Discourse.system_user, post).destroy }\n\n      updates_topic_updated_at { PostDestroyer.new(Discourse.system_user, post).recover }\n    end\n  end\n\n  describe \"have_uploads\" do\n    it \"should find all posts with the upload\" do\n      ids = []\n      ids << Fabricate(\n        :post,\n        cooked: \"A post with upload <img src='/#{upload_path}/1/defghijklmno.png'>\",\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          \"A post with optimized image <img src='/#{upload_path}/_optimized/601/961/defghijklmno.png'>\",\n      ).id\n      Fabricate(:post)\n      ids << Fabricate(\n        :post,\n        cooked: \"A post with upload <img src='/#{upload_path}/original/1X/abc/defghijklmno.png'>\",\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          \"A post with upload link <a href='https://cdn.example.com/original/1X/abc/defghijklmno.png'>\",\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          \"A post with optimized image <img src='https://cdn.example.com/bucket/optimized/1X/abc/defghijklmno.png'>\",\n      ).id\n      Fabricate(\n        :post,\n        cooked:\n          \"A post with external link <a href='https://example.com/wp-content/uploads/abcdef.gif'>\",\n      )\n      ids << Fabricate(\n        :post,\n        cooked:\n          'A post with missing upload <img src=\"https://cdn.example.com/images/transparent.png\" data-orig-src=\"upload://defghijklmno.png\">',\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          'A post with video upload <video width=\"100%\" height=\"100%\" controls=\"\"><source src=\"https://cdn.example.com/uploads/short-url/XefghijklmU9.mp4\"><a href=\"https://cdn.example.com/uploads/short-url/XefghijklmU9.mp4\">https://cdn.example.com/uploads/short-url/XefghijklmU9.mp4</a></video>',\n      ).id\n      expect(Post.have_uploads.order(:id).pluck(:id)).to eq(ids)\n    end\n  end\n\n  describe \"#each_upload_url\" do\n    it \"correctly identifies all upload urls\" do\n      SiteSetting.authorized_extensions = \"*\"\n      upload1 = Fabricate(:upload)\n      upload2 = Fabricate(:upload)\n      upload3 = Fabricate(:video_upload)\n      upload4 = Fabricate(:upload)\n      upload5 = Fabricate(:upload)\n      upload6 = Fabricate(:video_upload)\n      upload7 = Fabricate(:upload, extension: \"vtt\")\n\n      set_cdn_url \"https://awesome.com/somepath\"\n\n      post = Fabricate(:post, raw: <<~RAW)\n      A post with image, video and link upload.\n\n      ![](#{upload1.short_url})\n\n      \"#{GlobalSetting.cdn_url}#{upload4.url}\"\n\n      <a href='#{Discourse.base_url}#{upload2.url}'>Link to upload</a>\n      ![](http://example.com/external.png)\n\n      #{Discourse.base_url}#{upload3.short_path}\n\n      <video poster=\"#{Discourse.base_url}#{upload5.url}\">\n        <source src=\"#{Discourse.base_url}#{upload6.url}\" type=\"video/mp4\" />\n        <track src=\"#{Discourse.base_url}#{upload7.url}\" label=\"English\" kind=\"subtitles\" srclang=\"en\" default />\n      </video>\n      RAW\n\n      urls = []\n      paths = []\n\n      post.each_upload_url do |src, path, _|\n        urls << src\n        paths << path\n      end\n\n      expect(urls).to contain_exactly(\n        \"#{GlobalSetting.cdn_url}#{upload1.url}\",\n        \"#{GlobalSetting.cdn_url}#{upload4.url}\",\n        \"#{Discourse.base_url}#{upload2.url}\",\n        \"#{Discourse.base_url}#{upload3.short_path}\",\n        \"#{Discourse.base_url}#{upload5.url}\",\n        \"#{Discourse.base_url}#{upload6.url}\",\n        \"#{Discourse.base_url}#{upload7.url}\",\n      )\n\n      expect(paths).to contain_exactly(\n        upload1.url,\n        upload4.url,\n        upload2.url,\n        nil,\n        upload5.url,\n        upload6.url,\n        upload7.url,\n      )\n    end\n\n    it \"correctly identifies secure uploads\" do\n      setup_s3\n      SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n      SiteSetting.secure_uploads = true\n\n      upload1 = Fabricate(:upload_s3, secure: true)\n      upload2 = Fabricate(:upload_s3, secure: true)\n\n      # Test including domain:\n      upload1_url = UrlHelper.cook_url(upload1.url, secure: true)\n      # Test without domain:\n      upload2_path = URI.parse(UrlHelper.cook_url(upload2.url, secure: true)).path\n\n      post = Fabricate(:post, raw: <<~RAW)\n       <img src=\"#{upload1_url}\"/>\n       <img src=\"#{upload2_path}\"/>\n      RAW\n\n      sha1s = []\n\n      post.each_upload_url { |src, path, sha| sha1s << sha }\n\n      expect(sha1s).to contain_exactly(upload1.sha1, upload2.sha1)\n    end\n\n    it \"correctly identifies missing uploads with short url\" do\n      upload = Fabricate(:upload)\n      url = upload.short_url\n      sha1 = upload.sha1\n      upload.destroy!\n\n      post = Fabricate(:post, raw: \"![upload](#{url})\")\n\n      urls = []\n      paths = []\n      sha1s = []\n\n      post.each_upload_url do |src, path, sha|\n        urls << src\n        paths << path\n        sha1s << sha\n      end\n\n      expect(urls).to contain_exactly(url)\n      expect(paths).to contain_exactly(nil)\n      expect(sha1s).to contain_exactly(sha1)\n    end\n\n    it \"should skip external urls with upload url in query string\" do\n      setup_s3\n\n      urls = []\n      upload = Fabricate(:upload_s3)\n      post =\n        Fabricate(\n          :post,\n          raw:\n            \"<a href='https://link.example.com/redirect?url=#{Discourse.store.cdn_url(upload.url)}'>Link to upload</a>\",\n        )\n      post.each_upload_url { |src, _, _| urls << src }\n      expect(urls).to be_empty\n    end\n\n    it \"skip S3 cdn urls with different path\" do\n      setup_s3\n      SiteSetting.Upload.stubs(:s3_cdn_url).returns(\"https://cdn.example.com/site1\")\n\n      urls = []\n      raw =\n        \"<img src='https://cdn.example.com/site1/original/1X/bc68acbc8c022726e69f980e00d6811212r.jpg' /><img src='https://cdn.example.com/site2/original/1X/bc68acbc8c022726e69f980e00d68112128.jpg' />\"\n      post = Fabricate(:post, raw: raw)\n      post.each_upload_url { |src, _, _| urls << src }\n      expect(urls).to contain_exactly(\n        \"https://cdn.example.com/site1/original/1X/bc68acbc8c022726e69f980e00d6811212r.jpg\",\n      )\n    end\n  end\n\n  describe \"#publish_changes_to_client!\" do\n    fab!(:user1) { Fabricate(:user) }\n    fab!(:user3) { Fabricate(:user) }\n    fab!(:topic) { Fabricate(:private_message_topic, user: user1) }\n    fab!(:post) { Fabricate(:post, topic: topic) }\n    fab!(:group_user) { Fabricate(:group_user, user: user3) }\n    fab!(:topic_allowed_group) do\n      Fabricate(:topic_allowed_group, topic: topic, group: group_user.group)\n    end\n    let(:user2) { topic.allowed_users.last }\n\n    it \"send message to all users participating in private conversation\" do\n      freeze_time\n      message = {\n        id: post.id,\n        post_number: post.post_number,\n        updated_at: Time.now,\n        user_id: post.user_id,\n        last_editor_id: post.last_editor_id,\n        type: :created,\n        version: post.version,\n      }\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{topic.id}\") { post.publish_change_to_clients!(:created) }\n\n      created_message = messages.select { |msg| msg.data[:type] == :created }.first\n      expect(created_message).to be_present\n      expect(created_message.data).to eq(message)\n      expect(created_message.user_ids.sort).to eq([user1.id, user2.id, user3.id].sort)\n\n      stats_message = messages.select { |msg| msg.data[:type] == :created }.first\n      expect(stats_message).to be_present\n      expect(stats_message.user_ids.sort).to eq([user1.id, user2.id, user3.id].sort)\n    end\n\n    it \"also publishes topic stats\" do\n      messages =\n        MessageBus.track_publish(\"/topic/#{topic.id}\") { post.publish_change_to_clients!(:created) }\n\n      stats_message = messages.select { |msg| msg.data[:type] == :stats }.first\n      expect(stats_message).to be_present\n    end\n\n    it \"skips publishing topic stats when requested\" do\n      messages =\n        MessageBus.track_publish(\"/topic/#{topic.id}\") do\n          post.publish_change_to_clients!(:anything, { skip_topic_stats: true })\n        end\n\n      stats_message = messages.select { |msg| msg.data[:type] == :stats }.first\n      expect(stats_message).to be_blank\n\n      # ensure that :skip_topic_stats did not get merged with the message\n      other_message = messages.select { |msg| msg.data[:type] == :anything }.first\n      expect(other_message).to be_present\n      expect(other_message.data.key?(:skip_topic_stats)).to be_falsey\n    end\n  end\n\n  describe \"#cannot_permanently_delete_reason\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:admin) { Fabricate(:admin) }\n\n    before do\n      freeze_time\n      PostDestroyer.new(admin, post).destroy\n    end\n\n    it \"returns error message if same admin and time did not pass\" do\n      expect(post.cannot_permanently_delete_reason(admin)).to eq(\n        I18n.t(\n          \"post.cannot_permanently_delete.wait_or_different_admin\",\n          time_left: RateLimiter.time_left(Post::PERMANENT_DELETE_TIMER.to_i),\n        ),\n      )\n    end\n\n    it \"returns nothing if different admin\" do\n      expect(post.cannot_permanently_delete_reason(Fabricate(:admin))).to eq(nil)\n    end\n  end\n\n  describe \"#canonical_url\" do\n    it \"is able to determine correct canonical urls\" do\n      # ugly, but no interface to set this and we don't want to create\n      # 100 posts to test this thing\n      TopicView.stubs(:chunk_size).returns(2)\n\n      post1 = Fabricate(:post)\n      topic = post1.topic\n\n      post2 = Fabricate(:post, topic: topic)\n      post3 = Fabricate(:post, topic: topic)\n      post4 = Fabricate(:post, topic: topic)\n\n      topic_url = post1.topic.url\n\n      expect(post1.canonical_url).to eq(\"#{topic_url}#post_#{post1.post_number}\")\n      expect(post2.canonical_url).to eq(\"#{topic_url}#post_#{post2.post_number}\")\n\n      expect(post3.canonical_url).to eq(\"#{topic_url}?page=2#post_#{post3.post_number}\")\n      expect(post4.canonical_url).to eq(\"#{topic_url}?page=2#post_#{post4.post_number}\")\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"archetype\"\nrequire \"digest/sha1\"\n\nclass Post < ActiveRecord::Base\n  include RateLimiter::OnCreateRecord\n  include Trashable\n  include Searchable\n  include HasCustomFields\n  include LimitedEdit\n\n  self.ignored_columns = [\n    \"avg_time\", # TODO(2021-01-04): remove\n    \"image_url\", # TODO(2021-06-01): remove\n  ]\n\n  cattr_accessor :plugin_permitted_create_params, :plugin_permitted_update_params\n  self.plugin_permitted_create_params = {}\n  self.plugin_permitted_update_params = {}\n\n  # increase this number to force a system wide post rebake\n  # Recreate `index_for_rebake_old` when the number is increased\n  # Version 1, was the initial version\n  # Version 2 15-12-2017, introduces CommonMark and a huge number of onebox fixes\n  BAKED_VERSION = 2\n\n  # Time between the delete and permanent delete of a post\n  PERMANENT_DELETE_TIMER = 5.minutes\n\n  rate_limit\n  rate_limit :limit_posts_per_day\n\n  belongs_to :user\n  belongs_to :topic\n\n  belongs_to :reply_to_user, class_name: \"User\"\n\n  has_many :post_replies\n  has_many :replies, through: :post_replies\n  has_many :post_actions, dependent: :destroy\n  has_many :topic_links\n  has_many :group_mentions, dependent: :destroy\n\n  has_many :upload_references, as: :target, dependent: :destroy\n  has_many :uploads, through: :upload_references\n\n  has_one :post_stat\n\n  has_many :bookmarks, as: :bookmarkable\n\n  has_one :incoming_email\n\n  has_many :post_details\n\n  has_many :post_revisions\n  has_many :revisions, -> { order(:number) }, foreign_key: :post_id, class_name: \"PostRevision\"\n\n  has_many :user_actions, foreign_key: :target_post_id\n\n  belongs_to :image_upload, class_name: \"Upload\"\n\n  has_many :post_hotlinked_media, dependent: :destroy, class_name: \"PostHotlinkedMedia\"\n  has_many :reviewables, as: :target, dependent: :destroy\n\n  validates_with PostValidator, unless: :skip_validation\n  validates :edit_reason, length: { maximum: 1000 }\n\n  after_commit :index_search\n\n  # We can pass several creating options to a post via attributes\n  attr_accessor :image_sizes,\n                :quoted_post_numbers,\n                :no_bump,\n                :invalidate_oneboxes,\n                :cooking_options,\n                :skip_unique_check,\n                :skip_validation\n\n  MISSING_UPLOADS ||= \"missing uploads\"\n  MISSING_UPLOADS_IGNORED ||= \"missing uploads ignored\"\n  NOTICE ||= \"notice\"\n\n  SHORT_POST_CHARS ||= 1200\n\n  register_custom_field_type(MISSING_UPLOADS, :json)\n  register_custom_field_type(MISSING_UPLOADS_IGNORED, :boolean)\n\n  register_custom_field_type(NOTICE, :json)\n\n  scope :private_posts_for_user,\n        ->(user) {\n          where(\n            \"topics.id IN (#{Topic::PRIVATE_MESSAGES_SQL_USER})\n      OR topics.id IN (#{Topic::PRIVATE_MESSAGES_SQL_GROUP})\",\n            user_id: user.id,\n          )\n        }\n\n  scope :by_newest, -> { order(\"created_at DESC, id DESC\") }\n  scope :by_post_number, -> { order(\"post_number ASC\") }\n  scope :with_user, -> { includes(:user) }\n  scope :created_since, ->(time_ago) { where(\"posts.created_at > ?\", time_ago) }\n  scope :public_posts,\n        -> { joins(:topic).where(\"topics.archetype <> ?\", Archetype.private_message) }\n  scope :private_posts,\n        -> { joins(:topic).where(\"topics.archetype = ?\", Archetype.private_message) }\n  scope :with_topic_subtype, ->(subtype) { joins(:topic).where(\"topics.subtype = ?\", subtype) }\n  scope :visible, -> { joins(:topic).where(\"topics.visible = true\").where(hidden: false) }\n  scope :secured,\n        ->(guardian) { where(\"posts.post_type IN (?)\", Topic.visible_post_types(guardian&.user)) }\n\n  scope :for_mailing_list,\n        ->(user, since) {\n          q =\n            created_since(since).joins(\n              \"INNER JOIN (#{Topic.for_digest(user, Time.at(0)).select(:id).to_sql}) AS digest_topics ON digest_topics.id = posts.topic_id\",\n            ) # we want all topics with new content, regardless when they were created\n              .order(\"posts.created_at ASC\")\n\n          q = q.where.not(post_type: Post.types[:whisper]) unless user.staff?\n          q\n        }\n\n  scope :raw_match,\n        ->(pattern, type = \"string\") {\n          type = type&.downcase\n\n          case type\n          when \"string\"\n            where(\"raw ILIKE ?\", \"%#{pattern}%\")\n          when \"regex\"\n            where(\"raw ~* ?\", \"(?n)#{pattern}\")\n          end\n        }\n\n  scope :have_uploads,\n        -> {\n          where(\n            \"\n          (\n            posts.cooked LIKE '%<a %' OR\n            posts.cooked LIKE '%<img %' OR\n            posts.cooked LIKE '%<video %'\n          ) AND (\n            posts.cooked LIKE ? OR\n            posts.cooked LIKE '%/original/%' OR\n            posts.cooked LIKE '%/optimized/%' OR\n            posts.cooked LIKE '%data-orig-src=%' OR\n            posts.cooked LIKE '%/uploads/short-url/%'\n          )\",\n            \"%/uploads/#{RailsMultisite::ConnectionManagement.current_db}/%\",\n          )\n        }\n\n  delegate :username, to: :user\n\n  def self.hidden_reasons\n    @hidden_reasons ||=\n      Enum.new(\n        flag_threshold_reached: 1,\n        flag_threshold_reached_again: 2,\n        new_user_spam_threshold_reached: 3,\n        flagged_by_tl3_user: 4,\n        email_spam_header_found: 5,\n        flagged_by_tl4_user: 6,\n        email_authentication_result_header: 7,\n        imported_as_unlisted: 8,\n      )\n  end\n\n  def self.types\n    @types ||= Enum.new(regular: 1, moderator_action: 2, small_action: 3, whisper: 4)\n  end\n\n  def self.cook_methods\n    @cook_methods ||= Enum.new(regular: 1, raw_html: 2, email: 3)\n  end\n\n  def self.notices\n    @notices ||= Enum.new(custom: \"custom\", new_user: \"new_user\", returning_user: \"returning_user\")\n  end\n\n  def self.find_by_detail(key, value)\n    includes(:post_details).find_by(post_details: { key: key, value: value })\n  end\n\n  def self.find_by_number(topic_id, post_number)\n    find_by(topic_id: topic_id, post_number: post_number)\n  end\n\n  def whisper?\n    post_type == Post.types[:whisper]\n  end\n\n  def add_detail(key, value, extra = nil)\n    post_details.build(key: key, value: value, extra: extra)\n  end\n\n  def limit_posts_per_day\n    if user && user.new_user_posting_on_first_day? && post_number && post_number > 1\n      RateLimiter.new(\n        user,\n        \"first-day-replies-per-day\",\n        SiteSetting.max_replies_in_first_day,\n        1.day.to_i,\n      )\n    end\n  end\n\n  def readers_count\n    read_count = reads - 1 # Excludes poster\n    read_count < 0 ? 0 : read_count\n  end\n\n  def publish_change_to_clients!(type, opts = {})\n    # special failsafe for posts missing topics consistency checks should fix,\n    # but message is safe to skip\n    return unless topic\n\n    skip_topic_stats = opts.delete(:skip_topic_stats)\n\n    message = {\n      id: id,\n      post_number: post_number,\n      updated_at: Time.now,\n      user_id: user_id,\n      last_editor_id: last_editor_id,\n      type: type,\n      version: version,\n    }.merge(opts)\n\n    publish_message!(\"/topic/#{topic_id}\", message)\n    Topic.publish_stats_to_clients!(topic.id, type) unless skip_topic_stats\n  end\n\n  def publish_message!(channel, message, opts = {})\n    return unless topic\n\n    if Topic.visible_post_types.include?(post_type)\n      opts.merge!(topic.secure_audience_publish_messages)\n    else\n      opts[:user_ids] = User.human_users.where(\"admin OR moderator OR id = ?\", user_id).pluck(:id)\n    end\n\n    MessageBus.publish(channel, message, opts) if opts[:user_ids] != [] && opts[:group_ids] != []\n  end\n\n  def trash!(trashed_by = nil)\n    self.topic_links.each(&:destroy)\n    self.save_custom_fields if self.custom_fields.delete(Post::NOTICE)\n    super(trashed_by)\n  end\n\n  def recover!\n    super\n    recover_public_post_actions\n    TopicLink.extract_from(self)\n    QuotedPost.extract_from(self)\n    topic.category.update_latest if topic && topic.category_id && topic.category\n  end\n\n  # The key we use in redis to ensure unique posts\n  def unique_post_key\n    \"unique#{topic&.private_message? ? \"-pm\" : \"\"}-post-#{user_id}:#{raw_hash}\"\n  end\n\n  def store_unique_post_key\n    if SiteSetting.unique_posts_mins > 0\n      Discourse.redis.setex(unique_post_key, SiteSetting.unique_posts_mins.minutes.to_i, id)\n    end\n  end\n\n  def matches_recent_post?\n    post_id = Discourse.redis.get(unique_post_key)\n    post_id != (nil) && post_id.to_i != (id)\n  end\n\n  def raw_hash\n    return if raw.blank?\n    Digest::SHA1.hexdigest(raw)\n  end\n\n  def self.allowed_image_classes\n    @allowed_image_classes ||= %w[avatar favicon thumbnail emoji ytp-thumbnail-image]\n  end\n\n  def post_analyzer\n    @post_analyzers ||= {}\n    @post_analyzers[raw_hash] ||= PostAnalyzer.new(raw, topic_id)\n  end\n\n  %w[\n    raw_mentions\n    linked_hosts\n    embedded_media_count\n    attachment_count\n    link_count\n    raw_links\n    has_oneboxes?\n  ].each { |attr| define_method(attr) { post_analyzer.public_send(attr) } }\n\n  def add_nofollow?\n    return false if user&.staff?\n    user.blank? || SiteSetting.tl3_links_no_follow? || !user.has_trust_level?(TrustLevel[3])\n  end\n\n  def omit_nofollow?\n    !add_nofollow?\n  end\n\n  def cook(raw, opts = {})\n    # For some posts, for example those imported via RSS, we support raw HTML. In that\n    # case we can skip the rendering pipeline.\n    return raw if cook_method == Post.cook_methods[:raw_html]\n\n    options = opts.dup\n    options[:cook_method] = cook_method\n\n    # A rule in our Markdown pipeline may have Guardian checks that require a\n    # user to be present. The last editing user of the post will be more\n    # generally up to date than the creating user. For example, we use\n    # this when cooking #hashtags to determine whether we should render\n    # the found hashtag based on whether the user can access the category it\n    # is referencing.\n    options[:user_id] = self.last_editor_id\n    options[:omit_nofollow] = true if omit_nofollow?\n\n    if self.with_secure_uploads?\n      each_upload_url do |url|\n        uri = URI.parse(url)\n        if FileHelper.is_supported_media?(File.basename(uri.path))\n          raw =\n            raw.sub(\n              url,\n              Rails.application.routes.url_for(\n                controller: \"uploads\",\n                action: \"show_secure\",\n                path: uri.path[1..-1],\n                host: Discourse.current_hostname,\n              ),\n            )\n        end\n      end\n    end\n\n    cooked = post_analyzer.cook(raw, options)\n\n    new_cooked = Plugin::Filter.apply(:after_post_cook, self, cooked)\n\n    if post_type == Post.types[:regular]\n      if new_cooked != cooked && new_cooked.blank?\n        Rails.logger.debug(\"Plugin is blanking out post: #{self.url}\\nraw: #{raw}\")\n      elsif new_cooked.blank?\n        Rails.logger.debug(\"Blank post detected post: #{self.url}\\nraw: #{raw}\")\n      end\n    end\n\n    new_cooked\n  end\n\n  # Sometimes the post is being edited by someone else, for example, a mod.\n  # If that's the case, they should not be bound by the original poster's\n  # restrictions, for example on not posting images.\n  def acting_user\n    @acting_user || user\n  end\n\n  def acting_user=(pu)\n    @acting_user = pu\n  end\n\n  def last_editor\n    self.last_editor_id ? (User.find_by_id(self.last_editor_id) || user) : user\n  end\n\n  def allowed_spam_hosts\n    hosts =\n      SiteSetting\n        .allowed_spam_host_domains\n        .split(\"|\")\n        .map { |h| h.strip }\n        .reject { |h| !h.include?(\".\") }\n\n    hosts << GlobalSetting.hostname\n    hosts << RailsMultisite::ConnectionManagement.current_hostname\n  end\n\n  def total_hosts_usage\n    hosts = linked_hosts.clone\n    allowlisted = allowed_spam_hosts\n\n    hosts.reject! { |h| allowlisted.any? { |w| h.end_with?(w) } }\n\n    return hosts if hosts.length == 0\n\n    TopicLink\n      .where(domain: hosts.keys, user_id: acting_user.id)\n      .group(:domain, :post_id)\n      .count\n      .each_key do |tuple|\n        domain = tuple[0]\n        hosts[domain] = (hosts[domain] || 0) + 1\n      end\n\n    hosts\n  end\n\n  # Prevent new users from posting the same hosts too many times.\n  def has_host_spam?\n    if acting_user.present? &&\n         (\n           acting_user.staged? || acting_user.mature_staged? ||\n             acting_user.has_trust_level?(TrustLevel[1])\n         )\n      return false\n    end\n    return false if topic&.private_message?\n\n    total_hosts_usage.values.any? { |count| count >= SiteSetting.newuser_spam_host_threshold }\n  end\n\n  def archetype\n    topic&.archetype\n  end\n\n  def self.regular_order\n    order(:sort_order, :post_number)\n  end\n\n  def self.reverse_order\n    order(\"sort_order desc, post_number desc\")\n  end\n\n  def self.summary(topic_id)\n    topic_id = topic_id.to_i\n\n    # percent rank has tons of ties\n    where(topic_id: topic_id).where(\n      [\n        \"posts.id = ANY(\n          (\n            SELECT posts.id\n            FROM posts\n            WHERE posts.topic_id = #{topic_id.to_i}\n            AND posts.post_number = 1\n          ) UNION\n          (\n            SELECT p1.id\n            FROM posts p1\n            WHERE p1.percent_rank <= ?\n            AND p1.topic_id = #{topic_id.to_i}\n            ORDER BY p1.percent_rank\n            LIMIT ?\n          )\n        )\",\n        SiteSetting.summary_percent_filter.to_f / 100.0,\n        SiteSetting.summary_max_results,\n      ],\n    )\n  end\n\n  def delete_post_notices\n    self.custom_fields.delete(Post::NOTICE)\n    self.save_custom_fields\n  end\n\n  def recover_public_post_actions\n    PostAction\n      .publics\n      .with_deleted\n      .where(post_id: self.id, id: self.custom_fields[\"deleted_public_actions\"])\n      .find_each do |post_action|\n        post_action.recover!\n        post_action.save!\n      end\n\n    self.custom_fields.delete(\"deleted_public_actions\")\n    self.save_custom_fields\n  end\n\n  def filter_quotes(parent_post = nil)\n    return cooked if parent_post.blank?\n\n    # We only filter quotes when there is exactly 1\n    return cooked unless (quote_count == 1)\n\n    parent_raw = parent_post.raw.sub(%r{\\[quote.+/quote\\]}m, \"\")\n\n    if raw[parent_raw] || (parent_raw.size < SHORT_POST_CHARS)\n      return cooked.sub(%r{\\<aside.+\\</aside\\>}m, \"\")\n    end\n\n    cooked\n  end\n\n  def external_id\n    \"#{topic_id}/#{post_number}\"\n  end\n\n  def reply_to_post\n    return if reply_to_post_number.blank?\n    @reply_to_post ||=\n      Post.find_by(\n        \"topic_id = :topic_id AND post_number = :post_number\",\n        topic_id: topic_id,\n        post_number: reply_to_post_number,\n      )\n  end\n\n  def reply_notification_target\n    return if reply_to_post_number.blank?\n    Post.find_by(\n      \"topic_id = :topic_id AND post_number = :post_number AND user_id <> :user_id\",\n      topic_id: topic_id,\n      post_number: reply_to_post_number,\n      user_id: user_id,\n    ).try(:user)\n  end\n\n  def self.excerpt(cooked, maxlength = nil, options = {})\n    maxlength ||= SiteSetting.post_excerpt_maxlength\n    PrettyText.excerpt(cooked, maxlength, options)\n  end\n\n  # Strip out most of the markup\n  def excerpt(maxlength = nil, options = {})\n    Post.excerpt(cooked, maxlength, options.merge(post: self))\n  end\n\n  def excerpt_for_topic\n    Post.excerpt(\n      cooked,\n      SiteSetting.topic_excerpt_maxlength,\n      strip_links: true,\n      strip_images: true,\n      post: self,\n    )\n  end\n\n  def is_first_post?\n    post_number.blank? ? topic.try(:highest_post_number) == 0 : post_number == 1\n  end\n\n  def is_category_description?\n    topic.present? && topic.is_category_topic? && is_first_post?\n  end\n\n  def is_reply_by_email?\n    via_email && post_number.present? && post_number > 1\n  end\n\n  def is_flagged?\n    flags.count != 0\n  end\n\n  def flags\n    post_actions.where(\n      post_action_type_id: PostActionType.flag_types_without_custom.values,\n      deleted_at: nil,\n    )\n  end\n\n  def reviewable_flag\n    ReviewableFlaggedPost.pending.find_by(target: self)\n  end\n\n  def with_secure_uploads?\n    return false if !SiteSetting.secure_uploads?\n    SiteSetting.login_required? ||\n      (topic.present? && (topic.private_message? || topic.category&.read_restricted))\n  end\n\n  def hide!(post_action_type_id, reason = nil, custom_message: nil)\n    return if hidden?\n\n    reason ||=\n      (\n        if hidden_at\n          Post.hidden_reasons[:flag_threshold_reached_again]\n        else\n          Post.hidden_reasons[:flag_threshold_reached]\n        end\n      )\n\n    hiding_again = hidden_at.present?\n\n    self.hidden = true\n    self.hidden_at = Time.zone.now\n    self.hidden_reason_id = reason\n    self.skip_unique_check = true\n\n    Post.transaction do\n      save!\n\n      Topic.where(\n        \"id = :topic_id AND NOT EXISTS(SELECT 1 FROM POSTS WHERE topic_id = :topic_id AND NOT hidden)\",\n        topic_id: topic_id,\n      ).update_all(visible: false)\n\n      UserStatCountUpdater.decrement!(self)\n    end\n\n    # inform user\n    if user.present?\n      options = {\n        url: url,\n        edit_delay: SiteSetting.cooldown_minutes_after_hiding_posts,\n        flag_reason:\n          I18n.t(\n            \"flag_reasons.#{PostActionType.types[post_action_type_id]}\",\n            locale: SiteSetting.default_locale,\n            base_path: Discourse.base_path,\n          ),\n      }\n\n      message = custom_message\n      message = hiding_again ? :post_hidden_again : :post_hidden if message.nil?\n\n      Jobs.enqueue_in(\n        5.seconds,\n        :send_system_message,\n        user_id: user.id,\n        message_type: message.to_s,\n        message_options: options,\n      )\n    end\n  end\n\n  def unhide!\n    Post.transaction do\n      self.update!(hidden: false)\n      self.topic.update(visible: true) if is_first_post?\n      UserStatCountUpdater.increment!(self)\n      save(validate: false)\n    end\n\n    publish_change_to_clients!(:acted)\n  end\n\n  def full_url\n    \"#{Discourse.base_url}#{url}\"\n  end\n\n  def url(opts = nil)\n    opts ||= {}\n\n    if topic\n      Post.url(topic.slug, topic.id, post_number, opts)\n    else\n      \"/404\"\n    end\n  end\n\n  def canonical_url\n    topic_view = TopicView.new(topic, nil, post_number: post_number)\n\n    page = \"\"\n\n    page = \"?page=#{topic_view.page}\" if topic_view.page > 1\n\n    \"#{topic.url}#{page}#post_#{post_number}\"\n  end\n\n  def unsubscribe_url(user)\n    key_value = UnsubscribeKey.create_key_for(user, UnsubscribeKey::TOPIC_TYPE, post: self)\n\n    \"#{Discourse.base_url}/email/unsubscribe/#{key_value}\"\n  end\n\n  def self.url(slug, topic_id, post_number, opts = nil)\n    opts ||= {}\n\n    result = +\"/t/\"\n    result << \"#{slug}/\" if !opts[:without_slug]\n\n    \"#{result}#{topic_id}/#{post_number}\"\n  end\n\n  def self.urls(post_ids)\n    ids = post_ids.map { |u| u }\n    if ids.length > 0\n      urls = {}\n      Topic\n        .joins(:posts)\n        .where(\"posts.id\" => ids)\n        .select([\"posts.id as post_id\", \"post_number\", \"topics.slug\", \"topics.title\", \"topics.id\"])\n        .each { |t| urls[t.post_id.to_i] = url(t.slug, t.id, t.post_number) }\n      urls\n    else\n      {}\n    end\n  end\n\n  def revise(updated_by, changes = {}, opts = {})\n    PostRevisor.new(self).revise!(updated_by, changes, opts)\n  end\n\n  def self.rebake_old(limit, priority: :normal, rate_limiter: true)\n    limiter =\n      RateLimiter.new(\n        nil,\n        \"global_periodical_rebake_limit\",\n        GlobalSetting.max_old_rebakes_per_15_minutes,\n        900,\n        global: true,\n      )\n\n    problems = []\n    Post\n      .where(\"baked_version IS NULL OR baked_version < ?\", BAKED_VERSION)\n      .order(\"id desc\")\n      .limit(limit)\n      .pluck(:id)\n      .each do |id|\n        begin\n          break if !limiter.can_perform?\n\n          post = Post.find(id)\n          post.rebake!(priority: priority)\n\n          begin\n            limiter.performed! if rate_limiter\n          rescue RateLimiter::LimitExceeded\n            break\n          end\n        rescue => e\n          problems << { post: post, ex: e }\n\n          attempts = post.custom_fields[\"rebake_attempts\"].to_i\n\n          if attempts > 3\n            post.update_columns(baked_version: BAKED_VERSION)\n            Discourse.warn_exception(\n              e,\n              message: \"Can not rebake post# #{post.id} after 3 attempts, giving up\",\n            )\n          else\n            post.custom_fields[\"rebake_attempts\"] = attempts + 1\n            post.save_custom_fields\n          end\n        end\n      end\n    problems\n  end\n\n  def rebake!(invalidate_broken_images: false, invalidate_oneboxes: false, priority: nil)\n    new_cooked = cook(raw, topic_id: topic_id, invalidate_oneboxes: invalidate_oneboxes)\n    old_cooked = cooked\n\n    update_columns(cooked: new_cooked, baked_at: Time.zone.now, baked_version: BAKED_VERSION)\n\n    topic&.update_excerpt(excerpt_for_topic) if is_first_post?\n\n    if invalidate_broken_images\n      post_hotlinked_media.download_failed.destroy_all\n      post_hotlinked_media.upload_create_failed.destroy_all\n    end\n\n    # Extracts urls from the body\n    TopicLink.extract_from(self)\n    QuotedPost.extract_from(self)\n\n    # make sure we trigger the post process\n    trigger_post_process(bypass_bump: true, priority: priority)\n\n    publish_change_to_clients!(:rebaked)\n\n    new_cooked != old_cooked\n  end\n\n  def set_owner(new_user, actor, skip_revision = false)\n    return if user_id == new_user.id\n\n    edit_reason = I18n.t(\"change_owner.post_revision_text\", locale: SiteSetting.default_locale)\n\n    revise(\n      actor,\n      { raw: self.raw, user_id: new_user.id, edit_reason: edit_reason },\n      bypass_bump: true,\n      skip_revision: skip_revision,\n      skip_validations: true,\n    )\n\n    topic.update_columns(last_post_user_id: new_user.id) if post_number == topic.highest_post_number\n  end\n\n  before_create { PostCreator.before_create_tasks(self) }\n\n  def self.estimate_posts_per_day\n    val = Discourse.redis.get(\"estimated_posts_per_day\")\n    return val.to_i if val\n\n    posts_per_day =\n      Topic.listable_topics.secured.joins(:posts).merge(Post.created_since(30.days.ago)).count / 30\n    Discourse.redis.setex(\"estimated_posts_per_day\", 1.day.to_i, posts_per_day.to_s)\n    posts_per_day\n  end\n\n  before_save do\n    self.last_editor_id ||= user_id\n\n    if will_save_change_to_raw?\n      self.cooked = cook(raw, topic_id: topic_id) if !new_record?\n      self.baked_at = Time.zone.now\n      self.baked_version = BAKED_VERSION\n    end\n  end\n\n  def advance_draft_sequence\n    return if topic.blank? # could be deleted\n    DraftSequence.next!(last_editor_id, topic.draft_key) if last_editor_id\n  end\n\n  # TODO: move to post-analyzer?\n  # Determine what posts are quoted by this post\n  def extract_quoted_post_numbers\n    temp_collector = []\n\n    # Create relationships for the quotes\n    raw\n      .scan(/\\[quote=\\\"([^\"]+)\"\\]/)\n      .each do |quote|\n        args = parse_quote_into_arguments(quote)\n        # If the topic attribute is present, ensure it's the same topic\n        if !(args[:topic].present? && topic_id != args[:topic]) && args[:post] != post_number\n          temp_collector << args[:post]\n        end\n      end\n\n    temp_collector.uniq!\n    self.quoted_post_numbers = temp_collector\n    self.quote_count = temp_collector.size\n  end\n\n  def save_reply_relationships\n    add_to_quoted_post_numbers(reply_to_post_number)\n    return if self.quoted_post_numbers.blank?\n\n    # Create a reply relationship between quoted posts and this new post\n    self.quoted_post_numbers.each do |p|\n      post = Post.find_by(topic_id: topic_id, post_number: p)\n      create_reply_relationship_with(post)\n    end\n  end\n\n  # Enqueue post processing for this post\n  def trigger_post_process(\n    bypass_bump: false,\n    priority: :normal,\n    new_post: false,\n    skip_pull_hotlinked_images: false\n  )\n    args = {\n      bypass_bump: bypass_bump,\n      cooking_options: self.cooking_options,\n      new_post: new_post,\n      post_id: id,\n      skip_pull_hotlinked_images: skip_pull_hotlinked_images,\n    }\n\n    args[:image_sizes] = image_sizes if self.image_sizes.present?\n    args[:invalidate_oneboxes] = true if self.invalidate_oneboxes.present?\n    args[:queue] = priority.to_s if priority && priority != :normal\n\n    Jobs.enqueue(:process_post, args)\n    DiscourseEvent.trigger(:after_trigger_post_process, self)\n  end\n\n  def self.public_posts_count_per_day(\n    start_date,\n    end_date,\n    category_id = nil,\n    include_subcategories = false\n  )\n    result =\n      public_posts.where(\n        \"posts.created_at >= ? AND posts.created_at <= ?\",\n        start_date,\n        end_date,\n      ).where(post_type: Post.types[:regular])\n\n    if category_id\n      if include_subcategories\n        result = result.where(\"topics.category_id IN (?)\", Category.subcategory_ids(category_id))\n      else\n        result = result.where(\"topics.category_id = ?\", category_id)\n      end\n    end\n\n    result.group(\"date(posts.created_at)\").order(\"date(posts.created_at)\").count\n  end\n\n  def self.private_messages_count_per_day(start_date, end_date, topic_subtype)\n    private_posts\n      .with_topic_subtype(topic_subtype)\n      .where(\"posts.created_at >= ? AND posts.created_at <= ?\", start_date, end_date)\n      .group(\"date(posts.created_at)\")\n      .order(\"date(posts.created_at)\")\n      .count\n  end\n\n  def reply_history(max_replies = 100, guardian = nil)\n    post_ids = DB.query_single(<<~SQL, post_id: id, topic_id: topic_id)\n    WITH RECURSIVE breadcrumb(id, reply_to_post_number) AS (\n          SELECT p.id, p.reply_to_post_number FROM posts AS p\n            WHERE p.id = :post_id\n          UNION\n             SELECT p.id, p.reply_to_post_number FROM posts AS p, breadcrumb\n               WHERE breadcrumb.reply_to_post_number = p.post_number\n                 AND p.topic_id = :topic_id\n        )\n    SELECT id from breadcrumb\n    WHERE id <> :post_id\n    ORDER by id\n    SQL\n\n    # [1,2,3][-10,-1] => nil\n    post_ids = (post_ids[(0 - max_replies)..-1] || post_ids)\n\n    Post.secured(guardian).where(id: post_ids).includes(:user, :topic).order(:id).to_a\n  end\n\n  MAX_REPLY_LEVEL ||= 1000\n\n  def reply_ids(guardian = nil, only_replies_to_single_post: true)\n    builder = DB.build(<<~SQL)\n      WITH RECURSIVE breadcrumb(id, level) AS (\n        SELECT :post_id, 0\n        UNION\n        SELECT reply_post_id, level + 1\n        FROM post_replies AS r\n          JOIN posts AS p ON p.id = reply_post_id\n          JOIN breadcrumb AS b ON (r.post_id = b.id)\n        WHERE r.post_id <> r.reply_post_id\n          AND b.level < :max_reply_level\n          AND p.topic_id = :topic_id\n      ), breadcrumb_with_count AS (\n          SELECT\n            id,\n            level,\n            COUNT(*) AS count\n          FROM post_replies AS r\n            JOIN breadcrumb AS b ON (r.reply_post_id = b.id)\n          WHERE r.reply_post_id <> r.post_id\n          GROUP BY id, level\n      )\n      SELECT id, MIN(level) AS level\n      FROM breadcrumb_with_count\n      /*where*/\n      GROUP BY id\n      ORDER BY id\n    SQL\n\n    builder.where(\"level > 0\")\n\n    # ignore posts that aren't replies to exactly one post\n    # for example it skips a post when it contains 2 quotes (which are replies) from different posts\n    builder.where(\"count = 1\") if only_replies_to_single_post\n\n    replies = builder.query_hash(post_id: id, max_reply_level: MAX_REPLY_LEVEL, topic_id: topic_id)\n    replies.each { |r| r.symbolize_keys! }\n\n    secured_ids = Post.secured(guardian).where(id: replies.map { |r| r[:id] }).pluck(:id).to_set\n\n    replies.reject { |r| !secured_ids.include?(r[:id]) }\n  end\n\n  def revert_to(number)\n    return if number >= version\n    post_revision = PostRevision.find_by(post_id: id, number: (number + 1))\n    post_revision.modifications.each do |attribute, change|\n      attribute = \"version\" if attribute == \"cached_version\"\n      write_attribute(attribute, change[0])\n    end\n  end\n\n  def self.rebake_all_quoted_posts(user_id)\n    return if user_id.blank?\n\n    DB.exec(<<~SQL, user_id)\n      WITH user_quoted_posts AS (\n        SELECT post_id\n          FROM quoted_posts\n         WHERE quoted_post_id IN (SELECT id FROM posts WHERE user_id = ?)\n      )\n      UPDATE posts\n         SET baked_version = NULL\n       WHERE baked_version IS NOT NULL\n         AND id IN (SELECT post_id FROM user_quoted_posts)\n    SQL\n  end\n\n  def seen?(user)\n    PostTiming.where(topic_id: topic_id, post_number: post_number, user_id: user.id).exists?\n  end\n\n  def index_search\n    Scheduler::Defer.later \"Index post for search\" do\n      SearchIndexer.index(self)\n    end\n  end\n\n  def locked?\n    locked_by_id.present?\n  end\n\n  def link_post_uploads(fragments: nil)\n    upload_ids = []\n\n    each_upload_url(fragments: fragments) do |src, _, sha1|\n      upload = nil\n      upload = Upload.find_by(sha1: sha1) if sha1.present?\n      upload ||= Upload.get_from_url(src)\n\n      # Link any video thumbnails\n      if SiteSetting.video_thumbnails_enabled && upload.present? &&\n           FileHelper.supported_video.include?(upload.extension&.downcase)\n        # Video thumbnails have the filename of the video file sha1 with a .png or .jpg extension.\n        # This is because at time of upload in the composer we don't know the topic/post id yet\n        # and there is no thumbnail info added to the markdown to tie the thumbnail to the topic/post after\n        # creation.\n        thumbnail =\n          Upload\n            .where(\"original_filename like ?\", \"#{upload.sha1}.%\")\n            .order(id: :desc)\n            .first if upload.sha1.present?\n        if thumbnail.present? && self.is_first_post? && !self.topic.image_upload_id\n          upload_ids << thumbnail.id\n          self.topic.update_column(:image_upload_id, thumbnail.id)\n          extra_sizes =\n            ThemeModifierHelper.new(\n              theme_ids: Theme.user_selectable.pluck(:id),\n            ).topic_thumbnail_sizes\n          self.topic.generate_thumbnails!(extra_sizes: extra_sizes)\n        end\n      end\n      upload_ids << upload.id if upload.present?\n    end\n\n    upload_references =\n      upload_ids.map do |upload_id|\n        {\n          target_id: self.id,\n          target_type: self.class.name,\n          upload_id: upload_id,\n          created_at: Time.zone.now,\n          updated_at: Time.zone.now,\n        }\n      end\n\n    UploadReference.transaction do\n      UploadReference.where(target: self).delete_all\n      UploadReference.insert_all(upload_references) if upload_references.size > 0\n\n      if SiteSetting.secure_uploads?\n        Upload\n          .where(id: upload_ids, access_control_post_id: nil)\n          .where(\"id NOT IN (SELECT upload_id FROM custom_emojis)\")\n          .update_all(access_control_post_id: self.id)\n      end\n    end\n  end\n\n  def update_uploads_secure_status(source:)\n    if Discourse.store.external? && SiteSetting.secure_uploads?\n      Jobs.enqueue(:update_post_uploads_secure_status, post_id: self.id, source: source)\n    end\n  end\n\n  def each_upload_url(fragments: nil, include_local_upload: true)\n    current_db = RailsMultisite::ConnectionManagement.current_db\n    upload_patterns = [\n      %r{/uploads/#{current_db}/},\n      %r{/original/},\n      %r{/optimized/},\n      %r{/uploads/short-url/[a-zA-Z0-9]+(\\.[a-z0-9]+)?},\n    ]\n\n    fragments ||= Nokogiri::HTML5.fragment(self.cooked)\n    selectors = fragments.css(\"a/@href\", \"img/@src\", \"source/@src\", \"track/@src\", \"video/@poster\")\n\n    links =\n      selectors\n        .map do |media|\n          src = media.value\n          next if src.blank?\n\n          if src.end_with?(\"/images/transparent.png\") &&\n               (parent = media.parent)[\"data-orig-src\"].present?\n            parent[\"data-orig-src\"]\n          else\n            src\n          end\n        end\n        .compact\n        .uniq\n\n    links.each do |src|\n      src = src.split(\"?\")[0]\n\n      if src.start_with?(\"upload://\")\n        sha1 = Upload.sha1_from_short_url(src)\n        yield(src, nil, sha1)\n        next\n      elsif src.include?(\"/uploads/short-url/\")\n        sha1 = Upload.sha1_from_short_path(src)\n        yield(src, nil, sha1)\n        next\n      end\n\n      next if upload_patterns.none? { |pattern| src =~ pattern }\n      next if Rails.configuration.multisite && src.exclude?(current_db)\n\n      src = \"#{SiteSetting.force_https ? \"https\" : \"http\"}:#{src}\" if src.start_with?(\"//\")\n      if !Discourse.store.has_been_uploaded?(src) && !Upload.secure_uploads_url?(src) &&\n           !(include_local_upload && src =~ %r{\\A/[^/]}i)\n        next\n      end\n\n      path =\n        begin\n          URI(\n            UrlHelper.unencode(GlobalSetting.cdn_url ? src.sub(GlobalSetting.cdn_url, \"\") : src),\n          )&.path\n        rescue URI::Error\n        end\n\n      next if path.blank?\n\n      sha1 =\n        if path.include? \"optimized\"\n          OptimizedImage.extract_sha1(path)\n        else\n          Upload.extract_sha1(path) || Upload.sha1_from_short_path(path)\n        end\n\n      yield(src, path, sha1)\n    end\n  end\n\n  def self.find_missing_uploads(include_local_upload: true)\n    missing_uploads = []\n    missing_post_uploads = {}\n    count = 0\n\n    DistributedMutex.synchronize(\"find_missing_uploads\", validity: 30.minutes) do\n      PostCustomField.where(name: Post::MISSING_UPLOADS).delete_all\n      query =\n        Post\n          .have_uploads\n          .joins(:topic)\n          .joins(\n            \"LEFT JOIN post_custom_fields ON posts.id = post_custom_fields.post_id AND post_custom_fields.name = '#{Post::MISSING_UPLOADS_IGNORED}'\",\n          )\n          .where(\"post_custom_fields.id IS NULL\")\n          .select(:id, :cooked)\n\n      query.find_in_batches do |posts|\n        ids = posts.pluck(:id)\n        sha1s =\n          Upload\n            .joins(:upload_references)\n            .where(upload_references: { target_type: \"Post\" })\n            .where(\"upload_references.target_id BETWEEN ? AND ?\", ids.min, ids.max)\n            .pluck(:sha1)\n\n        posts.each do |post|\n          post.each_upload_url do |src, path, sha1|\n            next if sha1.present? && sha1s.include?(sha1)\n\n            missing_post_uploads[post.id] ||= []\n\n            if missing_uploads.include?(src)\n              missing_post_uploads[post.id] << src\n              next\n            end\n\n            upload_id = nil\n            upload_id = Upload.where(sha1: sha1).pick(:id) if sha1.present?\n            upload_id ||= yield(post, src, path, sha1)\n\n            if upload_id.blank?\n              missing_uploads << src\n              missing_post_uploads[post.id] << src\n            end\n          end\n        end\n      end\n\n      missing_post_uploads =\n        missing_post_uploads.reject do |post_id, uploads|\n          if uploads.present?\n            PostCustomField.create!(\n              post_id: post_id,\n              name: Post::MISSING_UPLOADS,\n              value: uploads.to_json,\n            )\n            count += uploads.count\n          end\n\n          uploads.empty?\n        end\n    end\n\n    { uploads: missing_uploads, post_uploads: missing_post_uploads, count: count }\n  end\n\n  def owned_uploads_via_access_control\n    Upload.where(access_control_post_id: self.id)\n  end\n\n  def image_url\n    raw_url = image_upload&.url\n    UrlHelper.cook_url(raw_url, secure: image_upload&.secure?, local: true) if raw_url\n  end\n\n  def cannot_permanently_delete_reason(user)\n    if self.deleted_by_id == user&.id && self.deleted_at >= Post::PERMANENT_DELETE_TIMER.ago\n      time_left =\n        RateLimiter.time_left(\n          Post::PERMANENT_DELETE_TIMER.to_i - Time.zone.now.to_i + self.deleted_at.to_i,\n        )\n      I18n.t(\"post.cannot_permanently_delete.wait_or_different_admin\", time_left: time_left)\n    end\n  end\n\n  def mentions\n    PrettyText.extract_mentions(Nokogiri::HTML5.fragment(cooked))\n  end\n\n  private\n\n  def parse_quote_into_arguments(quote)\n    return {} unless quote.present?\n    args = HashWithIndifferentAccess.new\n    quote.first.scan(/([a-z]+)\\:(\\d+)/).each { |arg| args[arg[0]] = arg[1].to_i }\n    args\n  end\n\n  def add_to_quoted_post_numbers(num)\n    return unless num.present?\n    self.quoted_post_numbers ||= []\n    self.quoted_post_numbers << num\n  end\n\n  def create_reply_relationship_with(post)\n    return if post.nil? || self.deleted_at.present?\n    post_reply = post.post_replies.new(reply_post_id: id)\n    if post_reply.save\n      if Topic.visible_post_types.include?(self.post_type)\n        Post.where(id: post.id).update_all [\"reply_count = reply_count + 1\"]\n      end\n    end\n  end\nend\n\n# == Schema Information\n#\n# Table name: posts\n#\n#  id                      :integer          not null, primary key\n#  user_id                 :integer\n#  topic_id                :integer          not null\n#  post_number             :integer          not null\n#  raw                     :text             not null\n#  cooked                  :text             not null\n#  created_at              :datetime         not null\n#  updated_at              :datetime         not null\n#  reply_to_post_number    :integer\n#  reply_count             :integer          default(0), not null\n#  quote_count             :integer          default(0), not null\n#  deleted_at              :datetime\n#  off_topic_count         :integer          default(0), not null\n#  like_count              :integer          default(0), not null\n#  incoming_link_count     :integer          default(0), not null\n#  bookmark_count          :integer          default(0), not null\n#  score                   :float\n#  reads                   :integer          default(0), not null\n#  post_type               :integer          default(1), not null\n#  sort_order              :integer\n#  last_editor_id          :integer\n#  hidden                  :boolean          default(FALSE), not null\n#  hidden_reason_id        :integer\n#  notify_moderators_count :integer          default(0), not null\n#  spam_count              :integer          default(0), not null\n#  illegal_count           :integer          default(0), not null\n#  inappropriate_count     :integer          default(0), not null\n#  last_version_at         :datetime         not null\n#  user_deleted            :boolean          default(FALSE), not null\n#  reply_to_user_id        :integer\n#  percent_rank            :float            default(1.0)\n#  notify_user_count       :integer          default(0), not null\n#  like_score              :integer          default(0), not null\n#  deleted_by_id           :integer\n#  edit_reason             :string\n#  word_count              :integer\n#  version                 :integer          default(1), not null\n#  cook_method             :integer          default(1), not null\n#  wiki                    :boolean          default(FALSE), not null\n#  baked_at                :datetime\n#  baked_version           :integer\n#  hidden_at               :datetime\n#  self_edits              :integer          default(0), not null\n#  reply_quoted            :boolean          default(FALSE), not null\n#  via_email               :boolean          default(FALSE), not null\n#  raw_email               :text\n#  public_version          :integer          default(1), not null\n#  action_code             :string\n#  locked_by_id            :integer\n#  image_upload_id         :bigint\n#  outbound_message_id     :string\n#\n# Indexes\n#\n#  idx_posts_created_at_topic_id                          (created_at,topic_id) WHERE (deleted_at IS NULL)\n#  idx_posts_deleted_posts                                (topic_id,post_number) WHERE (deleted_at IS NOT NULL)\n#  idx_posts_user_id_deleted_at                           (user_id) WHERE (deleted_at IS NULL)\n#  index_for_rebake_old                                   (id) WHERE (((baked_version IS NULL) OR (baked_version < 2)) AND (deleted_at IS NULL))\n#  index_posts_on_id_and_baked_version                    (id DESC,baked_version) WHERE (deleted_at IS NULL)\n#  index_posts_on_id_topic_id_where_not_deleted_or_empty  (id,topic_id) WHERE ((deleted_at IS NULL) AND (raw <> ''::text))\n#  index_posts_on_image_upload_id                         (image_upload_id)\n#  index_posts_on_reply_to_post_number                    (reply_to_post_number)\n#  index_posts_on_topic_id_and_created_at                 (topic_id,created_at)\n#  index_posts_on_topic_id_and_percent_rank               (topic_id,percent_rank)\n#  index_posts_on_topic_id_and_post_number                (topic_id,post_number) UNIQUE\n#  index_posts_on_topic_id_and_sort_order                 (topic_id,sort_order)\n#  index_posts_on_user_id_and_created_at                  (user_id,created_at)\n#  index_posts_user_and_likes                             (user_id,like_count DESC,created_at DESC) WHERE (post_number > 1)\n#\n", "# frozen_string_literal: true\n\nRSpec.describe Post do\n  fab!(:coding_horror) { Fabricate(:coding_horror) }\n\n  let(:upload_path) { Discourse.store.upload_path }\n\n  before { Oneboxer.stubs :onebox }\n\n  it_behaves_like \"it has custom fields\"\n\n  it { is_expected.to have_many(:reviewables).dependent(:destroy) }\n\n  describe \"#hidden_reasons\" do\n    context \"when verifying enum sequence\" do\n      before { @hidden_reasons = Post.hidden_reasons }\n\n      it \"'flag_threshold_reached' should be at 1st position\" do\n        expect(@hidden_reasons[:flag_threshold_reached]).to eq(1)\n      end\n\n      it \"'flagged_by_tl3_user' should be at 4th position\" do\n        expect(@hidden_reasons[:flagged_by_tl3_user]).to eq(4)\n      end\n    end\n  end\n\n  describe \"#types\" do\n    context \"when verifying enum sequence\" do\n      before { @types = Post.types }\n\n      it \"'regular' should be at 1st position\" do\n        expect(@types[:regular]).to eq(1)\n      end\n\n      it \"'whisper' should be at 4th position\" do\n        expect(@types[:whisper]).to eq(4)\n      end\n    end\n  end\n\n  describe \"#cook_methods\" do\n    context \"when verifying enum sequence\" do\n      before { @cook_methods = Post.cook_methods }\n\n      it \"'regular' should be at 1st position\" do\n        expect(@cook_methods[:regular]).to eq(1)\n      end\n\n      it \"'email' should be at 3rd position\" do\n        expect(@cook_methods[:email]).to eq(3)\n      end\n    end\n  end\n\n  # Help us build a post with a raw body\n  def post_with_body(body, user = nil)\n    args = post_args.merge(raw: body)\n    args[:user] = user if user.present?\n    Fabricate.build(:post, args)\n  end\n\n  it { is_expected.to validate_presence_of :raw }\n  it { is_expected.to validate_length_of(:edit_reason).is_at_most(1000) }\n\n  # Min/max body lengths, respecting padding\n  it { is_expected.not_to allow_value(\"x\").for(:raw) }\n  it { is_expected.not_to allow_value(\"x\" * (SiteSetting.max_post_length + 1)).for(:raw) }\n  it { is_expected.not_to allow_value((\" \" * SiteSetting.min_post_length) + \"x\").for(:raw) }\n\n  it { is_expected.to rate_limit }\n\n  let(:topic) { Fabricate(:topic) }\n  let(:post_args) { { user: topic.user, topic: topic } }\n\n  describe \"scopes\" do\n    describe \"#by_newest\" do\n      it \"returns posts ordered by created_at desc\" do\n        2.times { |t| Fabricate(:post, created_at: t.seconds.from_now) }\n        expect(Post.by_newest.first.created_at).to be > Post.by_newest.last.created_at\n      end\n    end\n\n    describe \"#with_user\" do\n      it \"gives you a user\" do\n        Fabricate(:post, user: Fabricate.build(:user))\n        expect(Post.with_user.first.user).to be_a User\n      end\n    end\n  end\n\n  describe \"revisions and deleting/recovery\" do\n    context \"with a post without links\" do\n      let(:post) { Fabricate(:post, post_args) }\n\n      before do\n        post.trash!\n        post.reload\n      end\n\n      it \"doesn't create a new revision when deleted\" do\n        expect(post.revisions.count).to eq(0)\n      end\n\n      describe \"recovery\" do\n        before do\n          post.recover!\n          post.reload\n        end\n\n        it \"doesn't create a new revision when recovered\" do\n          expect(post.revisions.count).to eq(0)\n        end\n      end\n    end\n\n    context \"with a post with links\" do\n      let(:post) { Fabricate(:post_with_external_links) }\n      before do\n        post.trash!\n        post.reload\n      end\n\n      describe \"recovery\" do\n        it \"recreates the topic_link records\" do\n          TopicLink.expects(:extract_from).with(post)\n          post.recover!\n        end\n      end\n    end\n  end\n\n  context \"with a post with notices\" do\n    let(:post) do\n      post = Fabricate(:post, post_args)\n      post.upsert_custom_fields(\n        Post::NOTICE => {\n          type: Post.notices[:returning_user],\n          last_posted_at: 1.day.ago,\n        },\n      )\n      post\n    end\n\n    it \"will have its notice cleared when post is trashed\" do\n      expect { post.trash! }.to change { post.custom_fields }.to({})\n    end\n  end\n\n  describe \"with_secure_uploads?\" do\n    let(:topic) { Fabricate(:topic) }\n    let!(:post) { Fabricate(:post, topic: topic) }\n    it \"returns false if secure uploads is not enabled\" do\n      expect(post.with_secure_uploads?).to eq(false)\n    end\n\n    context \"when secure uploads is enabled\" do\n      before do\n        setup_s3\n        SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n        SiteSetting.secure_uploads = true\n      end\n\n      context \"if login_required\" do\n        before { SiteSetting.login_required = true }\n\n        it \"returns true\" do\n          expect(post.with_secure_uploads?).to eq(true)\n        end\n      end\n\n      context \"if the topic category is read_restricted\" do\n        let(:category) { Fabricate(:private_category, group: Fabricate(:group)) }\n        before { topic.change_category_to_id(category.id) }\n\n        it \"returns true\" do\n          expect(post.with_secure_uploads?).to eq(true)\n        end\n      end\n\n      context \"if the post is in a PM topic\" do\n        let(:topic) { Fabricate(:private_message_topic) }\n\n        it \"returns true\" do\n          expect(post.with_secure_uploads?).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"flagging helpers\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:user) { coding_horror }\n    fab!(:admin) { Fabricate(:admin) }\n\n    it \"is_flagged? is accurate\" do\n      PostActionCreator.off_topic(user, post)\n      expect(post.reload.is_flagged?).to eq(true)\n\n      PostActionDestroyer.destroy(user, post, :off_topic)\n      expect(post.reload.is_flagged?).to eq(false)\n    end\n\n    it \"is_flagged? is true if flag was deferred\" do\n      result = PostActionCreator.off_topic(user, post)\n      result.reviewable.perform(admin, :ignore_and_do_nothing)\n      expect(post.reload.is_flagged?).to eq(true)\n    end\n\n    it \"is_flagged? is true if flag was cleared\" do\n      result = PostActionCreator.off_topic(user, post)\n      result.reviewable.perform(admin, :disagree)\n      expect(post.reload.is_flagged?).to eq(true)\n    end\n\n    it \"reviewable_flag is nil when ignored\" do\n      result = PostActionCreator.spam(user, post)\n      expect(post.reviewable_flag).to eq(result.reviewable)\n\n      result.reviewable.perform(admin, :ignore_and_do_nothing)\n      expect(post.reviewable_flag).to be_nil\n    end\n\n    it \"reviewable_flag is nil when disagreed\" do\n      result = PostActionCreator.spam(user, post)\n      expect(post.reviewable_flag).to eq(result.reviewable)\n\n      result.reviewable.perform(admin, :disagree)\n      expect(post.reload.reviewable_flag).to be_nil\n    end\n  end\n\n  describe \"maximum media embeds\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:post_no_images) { Fabricate.build(:post, post_args.merge(user: newuser)) }\n    let(:post_one_image) { post_with_body(\"![sherlock](http://bbc.co.uk/sherlock.jpg)\", newuser) }\n    let(:post_two_images) do\n      post_with_body(\n        \"<img src='http://discourse.org/logo.png'> <img src='http://bbc.co.uk/sherlock.jpg'>\",\n        newuser,\n      )\n    end\n    let(:post_with_avatars) do\n      post_with_body(\n        '<img alt=\"smiley\" title=\":smiley:\" src=\"/assets/emoji/smiley.png\" class=\"avatar\"> <img alt=\"wink\" title=\":wink:\" src=\"/assets/emoji/wink.png\" class=\"avatar\">',\n        newuser,\n      )\n    end\n    let(:post_with_favicon) do\n      post_with_body('<img src=\"/images/favicons/discourse.png\" class=\"favicon\">', newuser)\n    end\n    let(:post_image_within_quote) do\n      post_with_body('[quote]<img src=\"coolimage.png\">[/quote]', newuser)\n    end\n    let(:post_image_within_code) do\n      post_with_body('<code><img src=\"coolimage.png\"></code>', newuser)\n    end\n    let(:post_image_within_pre) { post_with_body('<pre><img src=\"coolimage.png\"></pre>', newuser) }\n    let(:post_with_thumbnail) do\n      post_with_body('<img src=\"/assets/emoji/smiley.png\" class=\"thumbnail\">', newuser)\n    end\n    let(:post_with_two_classy_images) do\n      post_with_body(\n        \"<img src='http://discourse.org/logo.png' class='classy'> <img src='http://bbc.co.uk/sherlock.jpg' class='classy'>\",\n        newuser,\n      )\n    end\n    let(:post_with_two_embedded_media) do\n      post_with_body(\n        '<video width=\"950\" height=\"700\" controls><source src=\"https://bbc.co.uk/news.mp4\" type=\"video/mp4\"></video><audio controls><source type=\"audio/mpeg\" src=\"https://example.com/audio.mp3\"></audio>',\n        newuser,\n      )\n    end\n\n    it \"returns 0 images for an empty post\" do\n      expect(Fabricate.build(:post).embedded_media_count).to eq(0)\n    end\n\n    it \"finds images from markdown\" do\n      expect(post_one_image.embedded_media_count).to eq(1)\n    end\n\n    it \"finds images from HTML\" do\n      expect(post_two_images.embedded_media_count).to eq(2)\n    end\n\n    it \"doesn't count avatars as images\" do\n      expect(post_with_avatars.embedded_media_count).to eq(0)\n    end\n\n    it \"allows images by default\" do\n      expect(post_one_image).to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media`\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_one_image).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media` in a quote\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_image_within_quote).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media` in code\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_image_within_code).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media` in pre\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 3\n      expect(post_image_within_pre).not_to be_valid\n    end\n\n    it \"doesn't allow more than `min_trust_to_post_embedded_media`\" do\n      SiteSetting.min_trust_to_post_embedded_media = 4\n      post_one_image.user.trust_level = 4\n      expect(post_one_image).to be_valid\n    end\n\n    it \"doesn't count favicons as images\" do\n      PrettyText.stubs(:cook).returns(post_with_favicon.raw)\n      expect(post_with_favicon.embedded_media_count).to eq(0)\n    end\n\n    it \"doesn't count thumbnails as images\" do\n      PrettyText.stubs(:cook).returns(post_with_thumbnail.raw)\n      expect(post_with_thumbnail.embedded_media_count).to eq(0)\n    end\n\n    it \"doesn't count allowlisted images\" do\n      Post.stubs(:allowed_image_classes).returns([\"classy\"])\n      # I dislike this, but passing in a custom allowlist is hard\n      PrettyText.stubs(:cook).returns(post_with_two_classy_images.raw)\n      expect(post_with_two_classy_images.embedded_media_count).to eq(0)\n    end\n\n    it \"counts video and audio as embedded media\" do\n      expect(post_with_two_embedded_media.embedded_media_count).to eq(2)\n    end\n\n    context \"with validation\" do\n      before { SiteSetting.newuser_max_embedded_media = 1 }\n\n      context \"with newuser\" do\n        it \"allows a new user to post below the limit\" do\n          expect(post_one_image).to be_valid\n        end\n\n        it \"doesn't allow more than the maximum number of images\" do\n          expect(post_two_images).not_to be_valid\n        end\n\n        it \"doesn't allow more than the maximum number of embedded media items\" do\n          expect(post_with_two_embedded_media).not_to be_valid\n        end\n\n        it \"doesn't allow a new user to edit their post to insert an image\" do\n          post_no_images.user.trust_level = TrustLevel[0]\n          post_no_images.save\n          expect {\n            post_no_images.revise(post_no_images.user, raw: post_two_images.raw)\n            post_no_images.reload\n          }.not_to change(post_no_images, :raw)\n        end\n      end\n\n      it \"allows more images from a not-new account\" do\n        post_two_images.user.trust_level = TrustLevel[1]\n        expect(post_two_images).to be_valid\n      end\n    end\n  end\n\n  describe \"maximum attachments\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:post_no_attachments) { Fabricate.build(:post, post_args.merge(user: newuser)) }\n    let(:post_one_attachment) do\n      post_with_body(\n        \"<a class='attachment' href='/#{upload_path}/1/2082985.txt'>file.txt</a>\",\n        newuser,\n      )\n    end\n    let(:post_two_attachments) do\n      post_with_body(\n        \"<a class='attachment' href='/#{upload_path}/2/20947092.log'>errors.log</a> <a class='attachment' href='/#{upload_path}/3/283572385.3ds'>model.3ds</a>\",\n        newuser,\n      )\n    end\n\n    it \"returns 0 attachments for an empty post\" do\n      expect(Fabricate.build(:post).attachment_count).to eq(0)\n    end\n\n    it \"finds attachments from HTML\" do\n      expect(post_two_attachments.attachment_count).to eq(2)\n    end\n\n    context \"with validation\" do\n      before { SiteSetting.newuser_max_attachments = 1 }\n\n      context \"with newuser\" do\n        it \"allows a new user to post below the limit\" do\n          expect(post_one_attachment).to be_valid\n        end\n\n        it \"doesn't allow more than the maximum\" do\n          expect(post_two_attachments).not_to be_valid\n        end\n\n        it \"doesn't allow a new user to edit their post to insert an attachment\" do\n          post_no_attachments.user.trust_level = TrustLevel[0]\n          post_no_attachments.save\n          expect {\n            post_no_attachments.revise(post_no_attachments.user, raw: post_two_attachments.raw)\n            post_no_attachments.reload\n          }.not_to change(post_no_attachments, :raw)\n        end\n      end\n\n      it \"allows more attachments from a not-new account\" do\n        post_two_attachments.user.trust_level = TrustLevel[1]\n        expect(post_two_attachments).to be_valid\n      end\n    end\n  end\n\n  describe \"links\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:no_links) { post_with_body(\"hello world my name is evil trout\", newuser) }\n    let(:one_link) { post_with_body(\"[jlawr](http://www.imdb.com/name/nm2225369)\", newuser) }\n    let(:two_links) do\n      post_with_body(\n        \"<a href='http://disneyland.disney.go.com/'>disney</a> <a href='http://reddit.com'>reddit</a>\",\n        newuser,\n      )\n    end\n    let(:three_links) do\n      post_with_body(\n        \"http://discourse.org and http://discourse.org/another_url and http://www.imdb.com/name/nm2225369\",\n        newuser,\n      )\n    end\n\n    describe \"raw_links\" do\n      it \"returns a blank collection for a post with no links\" do\n        expect(no_links.raw_links).to be_blank\n      end\n\n      it \"finds a link within markdown\" do\n        expect(one_link.raw_links).to eq([\"http://www.imdb.com/name/nm2225369\"])\n      end\n\n      it \"can find two links from html\" do\n        expect(two_links.raw_links).to eq(%w[http://disneyland.disney.go.com/ http://reddit.com])\n      end\n\n      it \"can find three links without markup\" do\n        expect(three_links.raw_links).to eq(\n          %w[\n            http://discourse.org\n            http://discourse.org/another_url\n            http://www.imdb.com/name/nm2225369\n          ],\n        )\n      end\n    end\n\n    describe \"linked_hosts\" do\n      it \"returns blank with no links\" do\n        expect(no_links.linked_hosts).to be_blank\n      end\n\n      it \"returns the host and a count for links\" do\n        expect(two_links.linked_hosts).to eq(\"disneyland.disney.go.com\" => 1, \"reddit.com\" => 1)\n      end\n\n      it \"it counts properly with more than one link on the same host\" do\n        expect(three_links.linked_hosts).to eq(\"discourse.org\" => 1, \"www.imdb.com\" => 1)\n      end\n    end\n\n    describe \"total host usage\" do\n      it \"has none for a regular post\" do\n        expect(no_links.total_hosts_usage).to be_blank\n      end\n\n      context \"with a previous host\" do\n        let(:another_disney_link) do\n          post_with_body(\n            \"[radiator springs](http://disneyland.disney.go.com/disney-california-adventure/radiator-springs-racers/)\",\n            newuser,\n          )\n        end\n\n        before do\n          another_disney_link.save\n          TopicLink.extract_from(another_disney_link)\n        end\n\n        it \"contains the new post's links, PLUS the previous one\" do\n          expect(two_links.total_hosts_usage).to eq(\n            \"disneyland.disney.go.com\" => 2,\n            \"reddit.com\" => 1,\n          )\n        end\n      end\n    end\n  end\n\n  describe \"maximums\" do\n    fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n    let(:post_one_link) do\n      post_with_body(\"[sherlock](http://www.bbc.co.uk/programmes/b018ttws)\", newuser)\n    end\n    let(:post_onebox) { post_with_body(\"http://www.google.com\", newuser) }\n    let(:post_code_link) { post_with_body(\"<code>http://www.google.com</code>\", newuser) }\n    let(:post_two_links) do\n      post_with_body(\n        \"<a href='http://discourse.org'>discourse</a> <a href='http://twitter.com'>twitter</a>\",\n        newuser,\n      )\n    end\n    let(:post_with_mentions) do\n      post_with_body(\"hello @#{newuser.username} how are you doing?\", newuser)\n    end\n\n    it \"returns 0 links for an empty post\" do\n      expect(Fabricate.build(:post).link_count).to eq(0)\n    end\n\n    it \"returns 0 links for a post with mentions\" do\n      expect(post_with_mentions.link_count).to eq(0)\n    end\n\n    it \"finds links from markdown\" do\n      expect(post_one_link.link_count).to eq(1)\n    end\n\n    it \"finds links from HTML\" do\n      expect(post_two_links.link_count).to eq(2)\n    end\n\n    context \"with validation\" do\n      before { SiteSetting.newuser_max_links = 1 }\n\n      context \"with newuser\" do\n        it \"returns true when within the amount of links allowed\" do\n          expect(post_one_link).to be_valid\n        end\n\n        it \"doesn't allow more links than allowed\" do\n          expect(post_two_links).not_to be_valid\n        end\n      end\n\n      it \"allows multiple links for basic accounts\" do\n        post_two_links.user.trust_level = TrustLevel[1]\n        expect(post_two_links).to be_valid\n      end\n\n      context \"with min_trust_to_post_links\" do\n        it \"considers oneboxes links\" do\n          SiteSetting.min_trust_to_post_links = 3\n          post_onebox.user.trust_level = TrustLevel[2]\n          expect(post_onebox).not_to be_valid\n        end\n\n        it \"considers links within code\" do\n          SiteSetting.min_trust_to_post_links = 3\n          post_onebox.user.trust_level = TrustLevel[2]\n          expect(post_code_link).not_to be_valid\n        end\n\n        it \"doesn't allow allow links if `min_trust_to_post_links` is not met\" do\n          SiteSetting.min_trust_to_post_links = 2\n          post_two_links.user.trust_level = TrustLevel[1]\n          expect(post_one_link).not_to be_valid\n        end\n\n        it \"will skip the check for allowlisted domains\" do\n          SiteSetting.allowed_link_domains = \"www.bbc.co.uk\"\n          SiteSetting.min_trust_to_post_links = 2\n          post_two_links.user.trust_level = TrustLevel[1]\n          expect(post_one_link).to be_valid\n        end\n      end\n    end\n  end\n\n  describe \"@mentions\" do\n    context \"with raw_mentions\" do\n      it \"returns an empty array with no matches\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"Hello Jake and Finn!\"))\n        expect(post.raw_mentions).to eq([])\n      end\n\n      it \"returns lowercase unique versions of the mentions\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@Jake @Finn @Jake\"))\n        expect(post.raw_mentions).to eq(%w[jake finn])\n      end\n\n      it \"ignores pre\" do\n        # we need to force an inline\n        post = Fabricate.build(:post, post_args.merge(raw: \"p <pre>@Jake</pre> @Finn\"))\n        expect(post.raw_mentions).to eq([\"finn\"])\n      end\n\n      it \"catches content between pre tags\" do\n        # per common mark we need to force an inline\n        post = Fabricate.build(:post, post_args.merge(raw: \"a <pre>hello</pre> @Finn <pre></pre>\"))\n        expect(post.raw_mentions).to eq([\"finn\"])\n      end\n\n      it \"ignores code\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@Jake `@Finn`\"))\n        expect(post.raw_mentions).to eq([\"jake\"])\n      end\n\n      it \"ignores quotes\" do\n        post =\n          Fabricate.build(\n            :post,\n            post_args.merge(raw: \"[quote=\\\"Evil Trout\\\"]\\n@Jake\\n[/quote]\\n@Finn\"),\n          )\n        expect(post.raw_mentions).to eq([\"finn\"])\n      end\n\n      it \"handles underscore in username\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@Jake @Finn @Jake_Old\"))\n        expect(post.raw_mentions).to eq(%w[jake finn jake_old])\n      end\n\n      it \"handles hyphen in groupname\" do\n        post = Fabricate.build(:post, post_args.merge(raw: \"@org-board\"))\n        expect(post.raw_mentions).to eq([\"org-board\"])\n      end\n    end\n\n    context \"with max mentions\" do\n      fab!(:newuser) { Fabricate(:user, trust_level: TrustLevel[0]) }\n      let(:post_with_one_mention) { post_with_body(\"@Jake is the person I'm mentioning\", newuser) }\n      let(:post_with_two_mentions) do\n        post_with_body(\"@Jake @Finn are the people I'm mentioning\", newuser)\n      end\n\n      context \"with new user\" do\n        before do\n          SiteSetting.newuser_max_mentions_per_post = 1\n          SiteSetting.max_mentions_per_post = 5\n        end\n\n        it \"allows a new user to have newuser_max_mentions_per_post mentions\" do\n          expect(post_with_one_mention).to be_valid\n        end\n\n        it \"doesn't allow a new user to have more than newuser_max_mentions_per_post mentions\" do\n          expect(post_with_two_mentions).not_to be_valid\n        end\n      end\n\n      context \"when not a new user\" do\n        before do\n          SiteSetting.newuser_max_mentions_per_post = 0\n          SiteSetting.max_mentions_per_post = 1\n        end\n\n        it \"allows vmax_mentions_per_post mentions\" do\n          post_with_one_mention.user.trust_level = TrustLevel[1]\n          expect(post_with_one_mention).to be_valid\n        end\n\n        it \"doesn't allow to have more than max_mentions_per_post mentions\" do\n          post_with_two_mentions.user.trust_level = TrustLevel[1]\n          expect(post_with_two_mentions).not_to be_valid\n        end\n      end\n    end\n  end\n\n  describe \"validation\" do\n    it \"validates our default post\" do\n      expect(Fabricate.build(:post, post_args)).to be_valid\n    end\n\n    it \"create blank posts as invalid\" do\n      expect(Fabricate.build(:post, raw: \"\")).not_to be_valid\n    end\n  end\n\n  describe \"raw_hash\" do\n    let(:raw) { \"this is our test post body\" }\n    let(:post) { post_with_body(raw) }\n\n    it \"returns a value\" do\n      expect(post.raw_hash).to be_present\n    end\n\n    it \"returns blank for a nil body\" do\n      post.raw = nil\n      expect(post.raw_hash).to be_blank\n    end\n\n    it \"returns the same value for the same raw\" do\n      expect(post.raw_hash).to eq(post_with_body(raw).raw_hash)\n    end\n\n    it \"returns a different value for a different raw\" do\n      expect(post.raw_hash).not_to eq(post_with_body(\"something else\").raw_hash)\n    end\n\n    it \"returns a different value with different text case\" do\n      expect(post.raw_hash).not_to eq(post_with_body(\"THIS is OUR TEST post BODy\").raw_hash)\n    end\n  end\n\n  describe \"revise\" do\n    let(:post) { Fabricate(:post, post_args) }\n    let(:first_version_at) { post.last_version_at }\n\n    it \"has no revision\" do\n      expect(post.revisions.size).to eq(0)\n      expect(first_version_at).to be_present\n      expect(post.revise(post.user, raw: post.raw)).to eq(false)\n    end\n\n    context \"with the same body\" do\n      it \"doesn't change version\" do\n        expect {\n          post.revise(post.user, raw: post.raw)\n          post.reload\n        }.not_to change(post, :version)\n      end\n    end\n\n    context \"with grace period editing & edit windows\" do\n      before { SiteSetting.editing_grace_period = 1.minute.to_i }\n\n      it \"works\" do\n        revised_at = post.updated_at + 2.minutes\n        new_revised_at = revised_at + 2.minutes\n\n        # grace period edit\n        post.revise(post.user, { raw: \"updated body\" }, revised_at: post.updated_at + 10.seconds)\n        post.reload\n        expect(post.version).to eq(1)\n        expect(post.public_version).to eq(1)\n        expect(post.revisions.size).to eq(0)\n        expect(post.last_version_at.to_i).to eq(first_version_at.to_i)\n\n        # revision much later\n        post.revise(post.user, { raw: \"another updated body\" }, revised_at: revised_at)\n        post.reload\n        expect(post.version).to eq(2)\n        expect(post.public_version).to eq(2)\n        expect(post.revisions.size).to eq(1)\n        expect(post.last_version_at.to_i).to eq(revised_at.to_i)\n\n        # new edit window\n        post.revise(\n          post.user,\n          { raw: \"yet another updated body\" },\n          revised_at: revised_at + 10.seconds,\n        )\n        post.reload\n        expect(post.version).to eq(2)\n        expect(post.public_version).to eq(2)\n        expect(post.revisions.size).to eq(1)\n        expect(post.last_version_at.to_i).to eq(revised_at.to_i)\n\n        # after second window\n        post.revise(\n          post.user,\n          { raw: \"yet another, another updated body\" },\n          revised_at: new_revised_at,\n        )\n        post.reload\n        expect(post.version).to eq(3)\n        expect(post.public_version).to eq(3)\n        expect(post.revisions.size).to eq(2)\n        expect(post.last_version_at.to_i).to eq(new_revised_at.to_i)\n      end\n    end\n\n    context \"with rate limiter\" do\n      let(:changed_by) { coding_horror }\n\n      it \"triggers a rate limiter\" do\n        EditRateLimiter.any_instance.expects(:performed!)\n        post.revise(changed_by, raw: \"updated body\")\n      end\n    end\n\n    context \"with a new body\" do\n      let(:changed_by) { coding_horror }\n      let!(:result) { post.revise(changed_by, raw: \"updated body\") }\n\n      it \"acts correctly\" do\n        expect(result).to eq(true)\n        expect(post.raw).to eq(\"updated body\")\n        expect(post.invalidate_oneboxes).to eq(true)\n        expect(post.version).to eq(2)\n        expect(post.public_version).to eq(2)\n        expect(post.revisions.size).to eq(1)\n        expect(post.revisions.first.user).to be_present\n      end\n\n      context \"when second poster posts again quickly\" do\n        it \"is a grace period edit, because the second poster posted again quickly\" do\n          SiteSetting.editing_grace_period = 1.minute.to_i\n          post.revise(\n            changed_by,\n            { raw: \"yet another updated body\" },\n            revised_at: post.updated_at + 10.seconds,\n          )\n          post.reload\n\n          expect(post.version).to eq(2)\n          expect(post.public_version).to eq(2)\n          expect(post.revisions.size).to eq(1)\n        end\n      end\n    end\n  end\n\n  describe \"before save\" do\n    let(:cooked) do\n      \"<p><div class=\\\"lightbox-wrapper\\\"><a data-download-href=\\\"//localhost:3000/#{upload_path}/34784374092783e2fef84b8bc96d9b54c11ceea0\\\" href=\\\"//localhost:3000/#{upload_path}/original/1X/34784374092783e2fef84b8bc96d9b54c11ceea0.gif\\\" class=\\\"lightbox\\\" title=\\\"Sword reworks.gif\\\"><img src=\\\"//localhost:3000/#{upload_path}/optimized/1X/34784374092783e2fef84b8bc96d9b54c11ceea0_1_690x276.gif\\\" width=\\\"690\\\" height=\\\"276\\\"><div class=\\\"meta\\\">\\n<span class=\\\"filename\\\">Sword reworks.gif</span><span class=\\\"informations\\\">1000x400 1000 KB</span><span class=\\\"expand\\\"></span>\\n</div></a></div></p>\"\n    end\n\n    let(:post) do\n      Fabricate(\n        :post,\n        raw:\n          \"<img src=\\\"/#{upload_path}/original/1X/34784374092783e2fef84b8bc96d9b54c11ceea0.gif\\\" width=\\\"690\\\" height=\\\"276\\\">\",\n        cooked: cooked,\n      )\n    end\n\n    it \"should not cook the post if raw has not been changed\" do\n      post.save!\n      expect(post.cooked).to eq(cooked)\n    end\n  end\n\n  describe \"after save\" do\n    let(:post) { Fabricate(:post, post_args) }\n\n    it \"has correct info set\" do\n      expect(post.user_deleted?).to eq(false)\n      expect(post.post_number).to be_present\n      expect(post.excerpt).to be_present\n      expect(post.post_type).to eq(Post.types[:regular])\n      expect(post.revisions).to be_blank\n      expect(post.cooked).to be_present\n      expect(post.external_id).to be_present\n      expect(post.quote_count).to eq(0)\n      expect(post.replies).to be_blank\n    end\n\n    context \"with extract_quoted_post_numbers\" do\n      let!(:post) { Fabricate(:post, post_args) }\n      let(:reply) { Fabricate.build(:post, post_args) }\n\n      it \"finds the quote when in the same topic\" do\n        reply.raw =\n          \"[quote=\\\"EvilTrout, post:#{post.post_number}, topic:#{post.topic_id}\\\"]hello[/quote]\"\n        reply.extract_quoted_post_numbers\n        expect(reply.quoted_post_numbers).to eq([post.post_number])\n      end\n\n      it \"doesn't find the quote in a different topic\" do\n        reply.raw =\n          \"[quote=\\\"EvilTrout, post:#{post.post_number}, topic:#{post.topic_id + 1}\\\"]hello[/quote]\"\n        reply.extract_quoted_post_numbers\n        expect(reply.quoted_post_numbers).to be_blank\n      end\n\n      it \"doesn't find the quote in the same post\" do\n        reply = Fabricate.build(:post, post_args.merge(post_number: 646))\n        reply.raw =\n          \"[quote=\\\"EvilTrout, post:#{reply.post_number}, topic:#{post.topic_id}\\\"]hello[/quote]\"\n        reply.extract_quoted_post_numbers\n        expect(reply.quoted_post_numbers).to be_blank\n      end\n    end\n\n    context \"with a new reply\" do\n      fab!(:topic) { Fabricate(:topic) }\n      let(:other_user) { coding_horror }\n      let(:reply_text) { \"[quote=\\\"Evil Trout, post:1\\\"]\\nhello\\n[/quote]\\nHmmm!\" }\n      let!(:post) do\n        PostCreator.new(topic.user, raw: Fabricate.build(:post).raw, topic_id: topic.id).create\n      end\n      let!(:reply) do\n        PostCreator.new(\n          other_user,\n          raw: reply_text,\n          topic_id: topic.id,\n          reply_to_post_number: post.post_number,\n        ).create\n      end\n\n      it \"has a quote\" do\n        expect(reply.quote_count).to eq(1)\n      end\n\n      it \"has a reply to the user of the original user\" do\n        expect(reply.reply_to_user).to eq(post.user)\n      end\n\n      it \"increases the reply count of the parent\" do\n        post.reload\n        expect(post.reply_count).to eq(1)\n      end\n\n      it \"increases the reply count of the topic\" do\n        topic.reload\n        expect(topic.reply_count).to eq(1)\n      end\n\n      it \"is the child of the parent post\" do\n        expect(post.replies).to eq([reply])\n      end\n\n      it \"doesn't change the post count when you edit the reply\" do\n        reply.raw = \"updated raw\"\n        reply.save\n        post.reload\n        expect(post.reply_count).to eq(1)\n      end\n\n      context \"with a multi-quote reply\" do\n        let!(:multi_reply) do\n          raw =\n            \"[quote=\\\"Evil Trout, post:1\\\"]post1 quote[/quote]\\nAha!\\n[quote=\\\"Evil Trout, post:2\\\"]post2 quote[/quote]\\nNeat-o\"\n          PostCreator.new(\n            other_user,\n            raw: raw,\n            topic_id: topic.id,\n            reply_to_post_number: post.post_number,\n          ).create\n        end\n\n        it \"has the correct info set\" do\n          expect(multi_reply.quote_count).to eq(2)\n          expect(post.replies.include?(multi_reply)).to eq(true)\n          expect(reply.replies.include?(multi_reply)).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"summary\" do\n    let!(:p1) { Fabricate(:post, post_args.merge(score: 4, percent_rank: 0.33)) }\n    let!(:p2) { Fabricate(:post, post_args.merge(score: 10, percent_rank: 0.66)) }\n    let!(:p3) { Fabricate(:post, post_args.merge(score: 5, percent_rank: 0.99)) }\n    fab!(:p4) { Fabricate(:post, percent_rank: 0.99) }\n\n    it \"returns the OP and posts above the threshold in summary mode\" do\n      SiteSetting.summary_percent_filter = 66\n      expect(Post.summary(topic.id).order(:post_number)).to eq([p1, p2])\n      expect(Post.summary(p4.topic.id)).to eq([p4])\n    end\n  end\n\n  describe \"sort_order\" do\n    context \"with a regular topic\" do\n      let!(:p1) { Fabricate(:post, post_args) }\n      let!(:p2) { Fabricate(:post, post_args) }\n      let!(:p3) { Fabricate(:post, post_args) }\n\n      it \"defaults to created order\" do\n        expect(Post.regular_order).to eq([p1, p2, p3])\n      end\n    end\n  end\n\n  describe \"reply_history\" do\n    let!(:p1) { Fabricate(:post, post_args) }\n    let!(:p2) { Fabricate(:post, post_args.merge(reply_to_post_number: p1.post_number)) }\n    let!(:p3) { Fabricate(:post, post_args) }\n    let!(:p4) { Fabricate(:post, post_args.merge(reply_to_post_number: p2.post_number)) }\n\n    it \"returns the posts in reply to this post\" do\n      expect(p4.reply_history).to eq([p1, p2])\n      expect(p4.reply_history(1)).to eq([p2])\n      expect(p3.reply_history).to be_blank\n      expect(p2.reply_history).to eq([p1])\n    end\n  end\n\n  describe \"reply_ids\" do\n    fab!(:topic) { Fabricate(:topic) }\n    let!(:p1) { Fabricate(:post, topic: topic, post_number: 1) }\n    let!(:p2) { Fabricate(:post, topic: topic, post_number: 2, reply_to_post_number: 1) }\n    let!(:p3) { Fabricate(:post, topic: topic, post_number: 3) }\n    let!(:p4) { Fabricate(:post, topic: topic, post_number: 4, reply_to_post_number: 2) }\n    let!(:p5) { Fabricate(:post, topic: topic, post_number: 5, reply_to_post_number: 4) }\n    let!(:p6) { Fabricate(:post, topic: topic, post_number: 6) }\n\n    before do\n      PostReply.create!(post: p1, reply: p2)\n      PostReply.create!(post: p2, reply: p4)\n      PostReply.create!(post: p2, reply: p6) # simulates p6 quoting p2\n      PostReply.create!(post: p3, reply: p5) # simulates p5 quoting p3\n      PostReply.create!(post: p4, reply: p5)\n      PostReply.create!(post: p6, reply: p6) # https://meta.discourse.org/t/topic-quoting-itself-displays-reply-indicator/76085\n    end\n\n    it \"returns the reply ids and their level\" do\n      expect(p1.reply_ids).to eq(\n        [{ id: p2.id, level: 1 }, { id: p4.id, level: 2 }, { id: p6.id, level: 2 }],\n      )\n      expect(p2.reply_ids).to eq([{ id: p4.id, level: 1 }, { id: p6.id, level: 1 }])\n      expect(p3.reply_ids).to be_empty # has no replies\n      expect(p4.reply_ids).to be_empty # p5 replies to 2 posts (p4 and p3)\n      expect(p5.reply_ids).to be_empty # has no replies\n      expect(p6.reply_ids).to be_empty # quotes itself\n    end\n\n    it \"ignores posts moved to other topics\" do\n      p2.update_column(:topic_id, Fabricate(:topic).id)\n      expect(p1.reply_ids).to be_blank\n    end\n\n    it \"doesn't include the same reply twice\" do\n      PostReply.create!(post: p4, reply: p1)\n      expect(p1.reply_ids.size).to eq(4)\n    end\n\n    it \"does not skip any replies\" do\n      expect(p1.reply_ids(only_replies_to_single_post: false)).to eq(\n        [\n          { id: p2.id, level: 1 },\n          { id: p4.id, level: 2 },\n          { id: p5.id, level: 3 },\n          { id: p6.id, level: 2 },\n        ],\n      )\n      expect(p2.reply_ids(only_replies_to_single_post: false)).to eq(\n        [{ id: p4.id, level: 1 }, { id: p5.id, level: 2 }, { id: p6.id, level: 1 }],\n      )\n      expect(p3.reply_ids(only_replies_to_single_post: false)).to eq([{ id: p5.id, level: 1 }])\n      expect(p4.reply_ids(only_replies_to_single_post: false)).to eq([{ id: p5.id, level: 1 }])\n      expect(p5.reply_ids(only_replies_to_single_post: false)).to be_empty # has no replies\n      expect(p6.reply_ids(only_replies_to_single_post: false)).to be_empty # quotes itself\n    end\n  end\n\n  describe \"urls\" do\n    it \"no-ops for empty list\" do\n      expect(Post.urls([])).to eq({})\n    end\n\n    # integration test -> should move to centralized integration test\n    it \"finds urls for posts presented\" do\n      p1 = Fabricate(:post)\n      p2 = Fabricate(:post)\n      expect(Post.urls([p1.id, p2.id])).to eq(p1.id => p1.url, p2.id => p2.url)\n    end\n  end\n\n  describe \"details\" do\n    it \"adds details\" do\n      post = Fabricate.build(:post)\n      post.add_detail(\"key\", \"value\")\n      expect(post.post_details.size).to eq(1)\n      expect(post.post_details.first.key).to eq(\"key\")\n      expect(post.post_details.first.value).to eq(\"value\")\n    end\n\n    it \"can find a post by a detail\" do\n      detail = Fabricate(:post_detail)\n      post = detail.post\n      expect(Post.find_by_detail(detail.key, detail.value).id).to eq(post.id)\n    end\n  end\n\n  describe \"cooking\" do\n    let(:post) do\n      Fabricate.build(:post, post_args.merge(raw: \"please read my blog http://blog.example.com\"))\n    end\n\n    it \"should unconditionally follow links for staff\" do\n      SiteSetting.tl3_links_no_follow = true\n      post.user.trust_level = 1\n      post.user.moderator = true\n      post.save\n\n      expect(post.cooked).not_to match(/nofollow/)\n    end\n\n    it \"should add nofollow to links in the post for trust levels below 3\" do\n      post.user.trust_level = 2\n      post.save\n      expect(post.cooked).to match(/noopener nofollow ugc/)\n    end\n\n    it \"when tl3_links_no_follow is false, should not add nofollow for trust level 3 and higher\" do\n      SiteSetting.tl3_links_no_follow = false\n      post.user.trust_level = 3\n      post.save\n      expect(post.cooked).not_to match(/nofollow/)\n    end\n\n    it \"when tl3_links_no_follow is true, should add nofollow for trust level 3 and higher\" do\n      SiteSetting.tl3_links_no_follow = true\n      post.user.trust_level = 3\n      post.save\n      expect(post.cooked).to match(/noopener nofollow ugc/)\n    end\n\n    it \"passes the last_editor_id as the markdown user_id option\" do\n      post.save\n      post.reload\n      PostAnalyzer\n        .any_instance\n        .expects(:cook)\n        .with(post.raw, { cook_method: Post.cook_methods[:regular], user_id: post.last_editor_id })\n      post.cook(post.raw)\n      user_editor = Fabricate(:user)\n      post.update!(last_editor_id: user_editor.id)\n      PostAnalyzer\n        .any_instance\n        .expects(:cook)\n        .with(post.raw, { cook_method: Post.cook_methods[:regular], user_id: user_editor.id })\n      post.cook(post.raw)\n    end\n\n    describe \"mentions\" do\n      fab!(:group) do\n        Fabricate(\n          :group,\n          visibility_level: Group.visibility_levels[:members],\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n        )\n      end\n\n      before { Jobs.run_immediately! }\n\n      describe \"when user can not mention a group\" do\n        it \"should not create the mention with the notify class\" do\n          post = Fabricate(:post, raw: \"hello @#{group.name}\")\n          post.trigger_post_process\n          post.reload\n\n          expect(post.cooked).to eq(\n            %Q|<p>hello <a class=\"mention-group\" href=\"/groups/#{group.name}\">@#{group.name}</a></p>|,\n          )\n        end\n      end\n\n      describe \"when user can mention a group\" do\n        before { group.add(post.user) }\n\n        it \"should create the mention\" do\n          post.update!(raw: \"hello @#{group.name}\")\n          post.trigger_post_process\n          post.reload\n\n          expect(post.cooked).to eq(\n            %Q|<p>hello <a class=\"mention-group notify\" href=\"/groups/#{group.name}\">@#{group.name}</a></p>|,\n          )\n        end\n      end\n\n      describe \"when group owner can mention a group\" do\n        before do\n          group.update!(mentionable_level: Group::ALIAS_LEVELS[:owners_mods_and_admins])\n          group.add_owner(post.user)\n        end\n\n        it \"should create the mention\" do\n          post.update!(raw: \"hello @#{group.name}\")\n          post.trigger_post_process\n          post.reload\n\n          expect(post.cooked).to eq(\n            %Q|<p>hello <a class=\"mention-group notify\" href=\"/groups/#{group.name}\">@#{group.name}</a></p>|,\n          )\n        end\n      end\n    end\n  end\n\n  describe \"has_host_spam\" do\n    let(:raw) do\n      \"hello from my site http://www.example.net http://#{GlobalSetting.hostname} http://#{RailsMultisite::ConnectionManagement.current_hostname}\"\n    end\n\n    it \"correctly detects host spam\" do\n      post = Fabricate(:post, raw: raw)\n\n      expect(post.total_hosts_usage).to eq(\"www.example.net\" => 1)\n      post.acting_user.trust_level = 0\n\n      expect(post.has_host_spam?).to eq(false)\n\n      SiteSetting.newuser_spam_host_threshold = 1\n\n      expect(post.has_host_spam?).to eq(true)\n\n      SiteSetting.allowed_spam_host_domains = \"bla.com|boo.com | example.net \"\n      expect(post.has_host_spam?).to eq(false)\n    end\n\n    it \"doesn't punish staged users\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      user = Fabricate(:user, staged: true, trust_level: 0)\n      post = Fabricate(:post, raw: raw, user: user)\n      expect(post.has_host_spam?).to eq(false)\n    end\n\n    it \"punishes previously staged users that were created within 1 day\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      SiteSetting.newuser_max_links = 3\n      user = Fabricate(:user, staged: true, trust_level: 0)\n      user.created_at = 1.hour.ago\n      user.unstage!\n      post = Fabricate(:post, raw: raw, user: user)\n      expect(post.has_host_spam?).to eq(true)\n    end\n\n    it \"doesn't punish previously staged users over 1 day old\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      SiteSetting.newuser_max_links = 3\n      user = Fabricate(:user, staged: true, trust_level: 0)\n      user.created_at = 2.days.ago\n      user.unstage!\n      post = Fabricate(:post, raw: raw, user: user)\n      expect(post.has_host_spam?).to eq(false)\n    end\n\n    it \"ignores private messages\" do\n      SiteSetting.newuser_spam_host_threshold = 1\n      user = Fabricate(:user, trust_level: 0)\n      post =\n        Fabricate(:post, raw: raw, user: user, topic: Fabricate(:private_message_topic, user: user))\n      expect(post.has_host_spam?).to eq(false)\n    end\n  end\n\n  it \"has custom fields\" do\n    post = Fabricate(:post)\n    expect(post.custom_fields[\"a\"]).to eq(nil)\n\n    post.custom_fields[\"Tommy\"] = \"Hanks\"\n    post.custom_fields[\"Vincent\"] = \"Vega\"\n    post.save\n\n    post = Post.find(post.id)\n    expect(post.custom_fields).to eq(\"Tommy\" => \"Hanks\", \"Vincent\" => \"Vega\")\n  end\n\n  describe \"#excerpt_for_topic\" do\n    it \"returns a topic excerpt, defaulting to 220 chars\" do\n      expected_excerpt =\n        \"This is a sample post with semi-long raw content. The raw content is also more than \\ntwo hundred characters to satisfy any test conditions that require content longer \\nthan the typical test post raw content. It really is&hellip;\"\n      post = Fabricate(:post_with_long_raw_content)\n      post.rebake!\n      excerpt = post.excerpt_for_topic\n      expect(excerpt).to eq(expected_excerpt)\n    end\n\n    it \"respects the site setting for topic excerpt\" do\n      SiteSetting.topic_excerpt_maxlength = 10\n      expected_excerpt = \"This is a &hellip;\"\n      post = Fabricate(:post_with_long_raw_content)\n      post.rebake!\n      excerpt = post.excerpt_for_topic\n      expect(excerpt).to eq(expected_excerpt)\n    end\n  end\n\n  describe \"#rebake!\" do\n    it \"will rebake a post correctly\" do\n      post = create_post\n      expect(post.baked_at).not_to eq(nil)\n      first_baked = post.baked_at\n      first_cooked = post.cooked\n\n      DB.exec(\"UPDATE posts SET cooked = 'frogs' WHERE id = ?\", [post.id])\n      post.reload\n\n      post.expects(:publish_change_to_clients!).with(:rebaked)\n\n      result = post.rebake!\n\n      expect(post.baked_at).not_to eq_time(first_baked)\n      expect(post.cooked).to eq(first_cooked)\n      expect(result).to eq(true)\n    end\n\n    it \"updates the topic excerpt at the same time if it is the OP\" do\n      post = create_post\n      post.topic.update(excerpt: \"test\")\n      DB.exec(\"UPDATE posts SET cooked = 'frogs' WHERE id = ?\", [post.id])\n      post.reload\n      result = post.rebake!\n      post.topic.reload\n      expect(post.topic.excerpt).not_to eq(\"test\")\n    end\n\n    it \"does not update the topic excerpt if the post is not the OP\" do\n      post = create_post\n      post2 = create_post\n      post.topic.update(excerpt: \"test\")\n      result = post2.rebake!\n      post.topic.reload\n      expect(post.topic.excerpt).to eq(\"test\")\n    end\n\n    it \"works with posts in deleted topics\" do\n      post = create_post\n      post.topic.trash!\n      post.reload\n      post.rebake!\n    end\n\n    it \"uses inline onebox cache by default\" do\n      Jobs.run_immediately!\n      stub_request(:get, \"http://testonebox.com/vvf\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is Testonebox!</title>\n        </head></html>\n      HTML\n      post = create_post(raw: <<~POST).reload\n        hello inline onebox http://testonebox.com/vvf\n      POST\n      expect(post.cooked).to include(\"hello this is Testonebox!\")\n\n      stub_request(:get, \"http://testonebox.com/vvf\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is updated Testonebox!</title>\n        </head></html>\n      HTML\n      post.rebake!\n      expect(post.reload.cooked).to include(\"hello this is Testonebox!\")\n    ensure\n      InlineOneboxer.invalidate(\"http://testonebox.com/vvf\")\n    end\n\n    it \"passing invalidate_oneboxes: true ignores inline onebox cache\" do\n      Jobs.run_immediately!\n      stub_request(:get, \"http://testonebox.com/vvf22\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is Testonebox!</title>\n        </head></html>\n      HTML\n      post = create_post(raw: <<~POST).reload\n        hello inline onebox http://testonebox.com/vvf22\n      POST\n      expect(post.cooked).to include(\"hello this is Testonebox!\")\n\n      stub_request(:get, \"http://testonebox.com/vvf22\").to_return(status: 200, body: <<~HTML)\n        <html><head>\n          <title>hello this is updated Testonebox!</title>\n        </head></html>\n      HTML\n      post.rebake!(invalidate_oneboxes: true)\n      expect(post.reload.cooked).to include(\"hello this is updated Testonebox!\")\n    ensure\n      InlineOneboxer.invalidate(\"http://testonebox.com/vvf22\")\n    end\n  end\n\n  describe \"#set_owner\" do\n    fab!(:post) { Fabricate(:post) }\n\n    it \"will change owner of a post correctly\" do\n      post.set_owner(coding_horror, Discourse.system_user)\n      post.reload\n\n      expect(post.user).to eq(coding_horror)\n      expect(post.revisions.size).to eq(1)\n    end\n\n    it \"skips creating new post revision if skip_revision is true\" do\n      post.set_owner(coding_horror, Discourse.system_user, true)\n      post.reload\n\n      expect(post.user).to eq(coding_horror)\n      expect(post.revisions.size).to eq(0)\n    end\n\n    it \"uses default locale for edit reason\" do\n      I18n.locale = \"de\"\n\n      post.set_owner(coding_horror, Discourse.system_user)\n      post.reload\n\n      expected_reason =\n        I18n.with_locale(SiteSetting.default_locale) { I18n.t(\"change_owner.post_revision_text\") }\n\n      expect(post.edit_reason).to eq(expected_reason)\n    end\n  end\n\n  describe \".rebake_old\" do\n    it \"will catch posts it needs to rebake\" do\n      post = create_post\n      post.update_columns(baked_at: Time.new(2000, 1, 1), baked_version: -1)\n      Post.rebake_old(100)\n\n      post.reload\n      expect(post.baked_at).to be > 1.day.ago\n\n      baked = post.baked_at\n      Post.rebake_old(100)\n      post.reload\n      expect(post.baked_at).to eq_time(baked)\n    end\n\n    it \"will rate limit globally\" do\n      post1 = create_post\n      post2 = create_post\n      post3 = create_post\n\n      Post.where(id: [post1.id, post2.id, post3.id]).update_all(baked_version: -1)\n\n      global_setting :max_old_rebakes_per_15_minutes, 2\n\n      RateLimiter.clear_all_global!\n      RateLimiter.enable\n\n      Post.rebake_old(100)\n\n      expect(post3.reload.baked_version).not_to eq(-1)\n      expect(post2.reload.baked_version).not_to eq(-1)\n      expect(post1.reload.baked_version).to eq(-1)\n    end\n  end\n\n  describe \"#hide!\" do\n    fab!(:post) { Fabricate(:post) }\n\n    after { Discourse.redis.flushdb }\n\n    it \"should ignore the unique post validator when hiding a post with similar content as a recent post\" do\n      post_2 = Fabricate(:post, user: post.user)\n      SiteSetting.unique_posts_mins = 10\n      post.store_unique_post_key\n\n      expect(post_2.valid?).to eq(false)\n      expect(post_2.errors.full_messages.to_s).to include(I18n.t(:just_posted_that))\n\n      post_2.hide!(PostActionType.types[:off_topic])\n\n      expect(post_2.reload.hidden).to eq(true)\n    end\n\n    it \"should decrease user_stat topic_count for first post\" do\n      expect do post.hide!(PostActionType.types[:off_topic]) end.to change {\n        post.user.user_stat.reload.topic_count\n      }.from(1).to(0)\n    end\n\n    it \"should decrease user_stat post_count\" do\n      post_2 = Fabricate(:post, topic: post.topic, user: post.user)\n\n      expect do post_2.hide!(PostActionType.types[:off_topic]) end.to change {\n        post_2.user.user_stat.reload.post_count\n      }.from(1).to(0)\n    end\n  end\n\n  describe \"#unhide!\" do\n    fab!(:post) { Fabricate(:post) }\n\n    before { SiteSetting.unique_posts_mins = 5 }\n\n    it \"will unhide the first post & make the topic visible\" do\n      hidden_topic = Fabricate(:topic, visible: false)\n\n      post = create_post(topic: hidden_topic)\n      post.update_columns(hidden: true, hidden_at: Time.now, hidden_reason_id: 1)\n      post.reload\n\n      expect(post.hidden).to eq(true)\n\n      post.expects(:publish_change_to_clients!).with(:acted)\n\n      post.unhide!\n\n      post.reload\n      hidden_topic.reload\n\n      expect(post.hidden).to eq(false)\n      expect(hidden_topic.visible).to eq(true)\n    end\n\n    it \"should increase user_stat topic_count for first post\" do\n      post.hide!(PostActionType.types[:off_topic])\n\n      expect do post.unhide! end.to change { post.user.user_stat.reload.topic_count }.from(0).to(1)\n    end\n\n    it \"should decrease user_stat post_count\" do\n      post_2 = Fabricate(:post, topic: post.topic, user: post.user)\n      post_2.hide!(PostActionType.types[:off_topic])\n\n      expect do post_2.unhide! end.to change { post_2.user.user_stat.reload.post_count }.from(0).to(\n        1,\n      )\n    end\n  end\n\n  it \"will unhide the post but will keep the topic invisible/unlisted\" do\n    hidden_topic = Fabricate(:topic, visible: false)\n    create_post(topic: hidden_topic)\n    second_post = create_post(topic: hidden_topic)\n\n    second_post.update_columns(hidden: true, hidden_at: Time.now, hidden_reason_id: 1)\n    second_post.expects(:publish_change_to_clients!).with(:acted)\n\n    second_post.unhide!\n\n    second_post.reload\n    hidden_topic.reload\n\n    expect(second_post.hidden).to eq(false)\n    expect(hidden_topic.visible).to eq(false)\n  end\n\n  it \"automatically orders post revisions by number ascending\" do\n    post = Fabricate(:post)\n    post.revisions.create!(user_id: 1, post_id: post.id, number: 2)\n    post.revisions.create!(user_id: 1, post_id: post.id, number: 1)\n    expect(post.revisions.pluck(:number)).to eq([1, 2])\n  end\n\n  describe \"video_thumbnails\" do\n    fab!(:video_upload) { Fabricate(:upload, extension: \"mp4\") }\n    fab!(:image_upload) { Fabricate(:upload) }\n    fab!(:image_upload_2) { Fabricate(:upload) }\n    let(:base_url) { \"#{Discourse.base_url_no_prefix}#{Discourse.base_path}\" }\n    let(:video_url) { \"#{base_url}#{video_upload.url}\" }\n\n    let(:raw_video) { <<~RAW }\n      <video width=\"100%\" height=\"100%\" controls>\n        <source src=\"#{video_url}\">\n        <a href=\"#{video_url}\">#{video_url}</a>\n      </video>\n      RAW\n\n    let(:post) { Fabricate(:post, raw: raw_video) }\n\n    before { SiteSetting.video_thumbnails_enabled = true }\n\n    it \"has a topic thumbnail\" do\n      # Thumbnails are tied to a specific video file by using the\n      # video's sha1 as the image filename\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(1)\n    end\n\n    it \"only applies for video uploads\" do\n      image_upload.original_filename = \"#{image_upload_2.sha1}.png\"\n      image_upload.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(0)\n    end\n\n    it \"does not overwrite existing thumbnails\" do\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      post.topic.image_upload_id = image_upload_2.id\n      post.topic.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.image_upload_id).to eq(image_upload_2.id)\n    end\n\n    it \"uses the newest thumbnail\" do\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      image_upload_2.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload_2.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(1)\n      expect(post.topic.image_upload_id).to eq(image_upload_2.id)\n    end\n\n    it \"does not create thumbnails when disabled\" do\n      SiteSetting.video_thumbnails_enabled = false\n      image_upload.original_filename = \"#{video_upload.sha1}.png\"\n      image_upload.save!\n      post.link_post_uploads\n\n      post.topic.reload\n      expect(post.topic.topic_thumbnails.length).to eq(0)\n    end\n  end\n\n  describe \"uploads\" do\n    fab!(:video_upload) { Fabricate(:upload, extension: \"mp4\") }\n    fab!(:image_upload) { Fabricate(:upload) }\n    fab!(:audio_upload) { Fabricate(:upload, extension: \"ogg\") }\n    fab!(:attachment_upload) { Fabricate(:upload, extension: \"csv\") }\n    fab!(:attachment_upload_2) { Fabricate(:upload) }\n    fab!(:attachment_upload_3) { Fabricate(:upload, extension: nil) }\n\n    let(:base_url) { \"#{Discourse.base_url_no_prefix}#{Discourse.base_path}\" }\n    let(:video_url) { \"#{base_url}#{video_upload.url}\" }\n    let(:audio_url) { \"#{base_url}#{audio_upload.url}\" }\n\n    let(:raw_multiple) { <<~RAW }\n      <a href=\"#{attachment_upload.url}\">Link</a>\n      [test|attachment](#{attachment_upload_2.short_url})\n      [test3|attachment](#{attachment_upload_3.short_url})\n      <img src=\"#{image_upload.url}\">\n\n      <video width=\"100%\" height=\"100%\" controls>\n        <source src=\"#{video_url}\">\n        <a href=\"#{video_url}\">#{video_url}</a>\n      </video>\n\n      <audio controls>\n        <source src=\"#{audio_url}\">\n        <a href=\"#{audio_url}\">#{audio_url}</a>\n      </audio>\n      RAW\n\n    let(:post) { Fabricate(:post, raw: raw_multiple) }\n\n    it \"removes post uploads on destroy\" do\n      post.link_post_uploads\n\n      post.trash!\n      expect(UploadReference.count).to eq(6)\n\n      post.destroy!\n      expect(UploadReference.count).to eq(0)\n    end\n\n    describe \"#link_post_uploads\" do\n      it \"finds all the uploads in the post\" do\n        post.link_post_uploads\n\n        expect(UploadReference.where(target: post).pluck(:upload_id)).to contain_exactly(\n          video_upload.id,\n          image_upload.id,\n          audio_upload.id,\n          attachment_upload.id,\n          attachment_upload_2.id,\n          attachment_upload_3.id,\n        )\n      end\n\n      it \"cleans the reverse index up for the current post\" do\n        post.link_post_uploads\n\n        post_uploads_ids = post.upload_references.pluck(:id)\n\n        post.link_post_uploads\n\n        expect(post.reload.upload_references.pluck(:id)).to_not contain_exactly(post_uploads_ids)\n      end\n\n      context \"when secure uploads is enabled\" do\n        before do\n          setup_s3\n          SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n          SiteSetting.secure_uploads = true\n        end\n\n        it \"sets the access_control_post_id on uploads in the post that don't already have the value set\" do\n          other_post = Fabricate(:post)\n          video_upload.update(access_control_post_id: other_post.id)\n          audio_upload.update(access_control_post_id: other_post.id)\n\n          post.link_post_uploads\n\n          image_upload.reload\n          video_upload.reload\n          expect(image_upload.access_control_post_id).to eq(post.id)\n          expect(video_upload.access_control_post_id).not_to eq(post.id)\n        end\n\n        context \"for custom emoji\" do\n          before { CustomEmoji.create(name: \"meme\", upload: image_upload) }\n          it \"never sets an access control post because they should not be secure\" do\n            post.link_post_uploads\n            expect(image_upload.reload.access_control_post_id).to eq(nil)\n          end\n        end\n      end\n    end\n\n    describe \"#update_uploads_secure_status\" do\n      fab!(:user) { Fabricate(:user, trust_level: 0) }\n\n      let(:raw) { <<~RAW }\n        <a href=\"#{attachment_upload.url}\">Link</a>\n        <img src=\"#{image_upload.url}\">\n        RAW\n\n      before do\n        Jobs.run_immediately!\n\n        setup_s3\n        SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n        SiteSetting.secure_uploads = true\n\n        attachment_upload.update!(original_filename: \"hello.csv\")\n\n        stub_upload(attachment_upload)\n        stub_upload(image_upload)\n      end\n\n      it \"marks image and attachment uploads as secure in PMs when secure_uploads is ON\" do\n        SiteSetting.secure_uploads = true\n        post =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:private_message_topic, user: user),\n          )\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: post).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, true], [image_upload.id, true])\n      end\n\n      it \"marks image uploads as not secure in PMs when when secure_uploads is ON\" do\n        SiteSetting.secure_uploads = false\n        post =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:private_message_topic, user: user),\n          )\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: post).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, false], [image_upload.id, false])\n      end\n\n      it \"marks attachments as secure when relevant setting is enabled\" do\n        SiteSetting.secure_uploads = true\n        private_category = Fabricate(:private_category, group: Fabricate(:group))\n        post =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:topic, user: user, category: private_category),\n          )\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: post).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, true], [image_upload.id, true])\n      end\n\n      it \"does not mark an upload as secure if it has already been used in a public topic\" do\n        post = Fabricate(:post, raw: raw, user: user, topic: Fabricate(:topic, user: user))\n        post.link_post_uploads\n        post.update_uploads_secure_status(source: \"test\")\n\n        pm =\n          Fabricate(\n            :post,\n            raw: raw,\n            user: user,\n            topic: Fabricate(:private_message_topic, user: user),\n          )\n        pm.link_post_uploads\n        pm.update_uploads_secure_status(source: \"test\")\n\n        expect(\n          UploadReference.where(target: pm).joins(:upload).pluck(:upload_id, :secure),\n        ).to contain_exactly([attachment_upload.id, false], [image_upload.id, false])\n      end\n    end\n  end\n\n  describe \"topic updated_at\" do\n    let :topic do\n      create_post.topic\n    end\n\n    def updates_topic_updated_at\n      time = freeze_time 1.day.from_now\n      result = yield\n\n      topic.reload\n      expect(topic.updated_at).to eq_time(time)\n\n      result\n    end\n\n    it \"will update topic updated_at for all topic related events\" do\n      SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n\n      post =\n        updates_topic_updated_at do\n          create_post(topic_id: topic.id, post_type: Post.types[:whisper])\n        end\n\n      updates_topic_updated_at { PostDestroyer.new(Discourse.system_user, post).destroy }\n\n      updates_topic_updated_at { PostDestroyer.new(Discourse.system_user, post).recover }\n    end\n  end\n\n  describe \"have_uploads\" do\n    it \"should find all posts with the upload\" do\n      ids = []\n      ids << Fabricate(\n        :post,\n        cooked: \"A post with upload <img src='/#{upload_path}/1/defghijklmno.png'>\",\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          \"A post with optimized image <img src='/#{upload_path}/_optimized/601/961/defghijklmno.png'>\",\n      ).id\n      Fabricate(:post)\n      ids << Fabricate(\n        :post,\n        cooked: \"A post with upload <img src='/#{upload_path}/original/1X/abc/defghijklmno.png'>\",\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          \"A post with upload link <a href='https://cdn.example.com/original/1X/abc/defghijklmno.png'>\",\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          \"A post with optimized image <img src='https://cdn.example.com/bucket/optimized/1X/abc/defghijklmno.png'>\",\n      ).id\n      Fabricate(\n        :post,\n        cooked:\n          \"A post with external link <a href='https://example.com/wp-content/uploads/abcdef.gif'>\",\n      )\n      ids << Fabricate(\n        :post,\n        cooked:\n          'A post with missing upload <img src=\"https://cdn.example.com/images/transparent.png\" data-orig-src=\"upload://defghijklmno.png\">',\n      ).id\n      ids << Fabricate(\n        :post,\n        cooked:\n          'A post with video upload <video width=\"100%\" height=\"100%\" controls=\"\"><source src=\"https://cdn.example.com/uploads/short-url/XefghijklmU9.mp4\"><a href=\"https://cdn.example.com/uploads/short-url/XefghijklmU9.mp4\">https://cdn.example.com/uploads/short-url/XefghijklmU9.mp4</a></video>',\n      ).id\n      expect(Post.have_uploads.order(:id).pluck(:id)).to eq(ids)\n    end\n  end\n\n  describe \"#each_upload_url\" do\n    it \"correctly identifies all upload urls\" do\n      SiteSetting.authorized_extensions = \"*\"\n      upload1 = Fabricate(:upload)\n      upload2 = Fabricate(:upload)\n      upload3 = Fabricate(:video_upload)\n      upload4 = Fabricate(:upload)\n      upload5 = Fabricate(:upload)\n      upload6 = Fabricate(:video_upload)\n      upload7 = Fabricate(:upload, extension: \"vtt\")\n\n      set_cdn_url \"https://awesome.com/somepath\"\n\n      post = Fabricate(:post, raw: <<~RAW)\n      A post with image, video and link upload.\n\n      ![](#{upload1.short_url})\n\n      \"#{GlobalSetting.cdn_url}#{upload4.url}\"\n\n      <a href='#{Discourse.base_url}#{upload2.url}'>Link to upload</a>\n      ![](http://example.com/external.png)\n\n      #{Discourse.base_url}#{upload3.short_path}\n\n      <video poster=\"#{Discourse.base_url}#{upload5.url}\">\n        <source src=\"#{Discourse.base_url}#{upload6.url}\" type=\"video/mp4\" />\n        <track src=\"#{Discourse.base_url}#{upload7.url}\" label=\"English\" kind=\"subtitles\" srclang=\"en\" default />\n      </video>\n      RAW\n\n      urls = []\n      paths = []\n\n      post.each_upload_url do |src, path, _|\n        urls << src\n        paths << path\n      end\n\n      expect(urls).to contain_exactly(\n        \"#{GlobalSetting.cdn_url}#{upload1.url}\",\n        \"#{GlobalSetting.cdn_url}#{upload4.url}\",\n        \"#{Discourse.base_url}#{upload2.url}\",\n        \"#{Discourse.base_url}#{upload3.short_path}\",\n        \"#{Discourse.base_url}#{upload5.url}\",\n        \"#{Discourse.base_url}#{upload6.url}\",\n        \"#{Discourse.base_url}#{upload7.url}\",\n      )\n\n      expect(paths).to contain_exactly(\n        upload1.url,\n        upload4.url,\n        upload2.url,\n        nil,\n        upload5.url,\n        upload6.url,\n        upload7.url,\n      )\n    end\n\n    it \"correctly identifies secure uploads\" do\n      setup_s3\n      SiteSetting.authorized_extensions = \"pdf|png|jpg|csv\"\n      SiteSetting.secure_uploads = true\n\n      upload1 = Fabricate(:upload_s3, secure: true)\n      upload2 = Fabricate(:upload_s3, secure: true)\n\n      # Test including domain:\n      upload1_url = UrlHelper.cook_url(upload1.url, secure: true)\n      # Test without domain:\n      upload2_path = URI.parse(UrlHelper.cook_url(upload2.url, secure: true)).path\n\n      post = Fabricate(:post, raw: <<~RAW)\n       <img src=\"#{upload1_url}\"/>\n       <img src=\"#{upload2_path}\"/>\n      RAW\n\n      sha1s = []\n\n      post.each_upload_url { |src, path, sha| sha1s << sha }\n\n      expect(sha1s).to contain_exactly(upload1.sha1, upload2.sha1)\n    end\n\n    it \"correctly identifies missing uploads with short url\" do\n      upload = Fabricate(:upload)\n      url = upload.short_url\n      sha1 = upload.sha1\n      upload.destroy!\n\n      post = Fabricate(:post, raw: \"![upload](#{url})\")\n\n      urls = []\n      paths = []\n      sha1s = []\n\n      post.each_upload_url do |src, path, sha|\n        urls << src\n        paths << path\n        sha1s << sha\n      end\n\n      expect(urls).to contain_exactly(url)\n      expect(paths).to contain_exactly(nil)\n      expect(sha1s).to contain_exactly(sha1)\n    end\n\n    it \"should skip external urls with upload url in query string\" do\n      setup_s3\n\n      urls = []\n      upload = Fabricate(:upload_s3)\n      post =\n        Fabricate(\n          :post,\n          raw:\n            \"<a href='https://link.example.com/redirect?url=#{Discourse.store.cdn_url(upload.url)}'>Link to upload</a>\",\n        )\n      post.each_upload_url { |src, _, _| urls << src }\n      expect(urls).to be_empty\n    end\n\n    it \"skip S3 cdn urls with different path\" do\n      setup_s3\n      SiteSetting.Upload.stubs(:s3_cdn_url).returns(\"https://cdn.example.com/site1\")\n\n      urls = []\n      raw =\n        \"<img src='https://cdn.example.com/site1/original/1X/bc68acbc8c022726e69f980e00d6811212r.jpg' /><img src='https://cdn.example.com/site2/original/1X/bc68acbc8c022726e69f980e00d68112128.jpg' />\"\n      post = Fabricate(:post, raw: raw)\n      post.each_upload_url { |src, _, _| urls << src }\n      expect(urls).to contain_exactly(\n        \"https://cdn.example.com/site1/original/1X/bc68acbc8c022726e69f980e00d6811212r.jpg\",\n      )\n    end\n  end\n\n  describe \"#publish_changes_to_client!\" do\n    fab!(:user1) { Fabricate(:user) }\n    fab!(:user3) { Fabricate(:user) }\n    fab!(:topic) { Fabricate(:private_message_topic, user: user1) }\n    fab!(:post) { Fabricate(:post, topic: topic) }\n    fab!(:group_user) { Fabricate(:group_user, user: user3) }\n    fab!(:topic_allowed_group) do\n      Fabricate(:topic_allowed_group, topic: topic, group: group_user.group)\n    end\n    let(:user2) { topic.allowed_users.last }\n\n    it \"send message to all users participating in private conversation\" do\n      freeze_time\n      message = {\n        id: post.id,\n        post_number: post.post_number,\n        updated_at: Time.now,\n        user_id: post.user_id,\n        last_editor_id: post.last_editor_id,\n        type: :created,\n        version: post.version,\n      }\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{topic.id}\") { post.publish_change_to_clients!(:created) }\n\n      created_message = messages.select { |msg| msg.data[:type] == :created }.first\n      expect(created_message).to be_present\n      expect(created_message.data).to eq(message)\n      expect(created_message.user_ids.sort).to eq([user1.id, user2.id, user3.id].sort)\n\n      stats_message = messages.select { |msg| msg.data[:type] == :created }.first\n      expect(stats_message).to be_present\n      expect(stats_message.user_ids.sort).to eq([user1.id, user2.id, user3.id].sort)\n    end\n\n    it \"also publishes topic stats\" do\n      messages =\n        MessageBus.track_publish(\"/topic/#{topic.id}\") { post.publish_change_to_clients!(:created) }\n\n      stats_message = messages.select { |msg| msg.data[:type] == :stats }.first\n      expect(stats_message).to be_present\n    end\n\n    it \"skips publishing topic stats when requested\" do\n      messages =\n        MessageBus.track_publish(\"/topic/#{topic.id}\") do\n          post.publish_change_to_clients!(:anything, { skip_topic_stats: true })\n        end\n\n      stats_message = messages.select { |msg| msg.data[:type] == :stats }.first\n      expect(stats_message).to be_blank\n\n      # ensure that :skip_topic_stats did not get merged with the message\n      other_message = messages.select { |msg| msg.data[:type] == :anything }.first\n      expect(other_message).to be_present\n      expect(other_message.data.key?(:skip_topic_stats)).to be_falsey\n    end\n  end\n\n  describe \"#cannot_permanently_delete_reason\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:admin) { Fabricate(:admin) }\n\n    before do\n      freeze_time\n      PostDestroyer.new(admin, post).destroy\n    end\n\n    it \"returns error message if same admin and time did not pass\" do\n      expect(post.cannot_permanently_delete_reason(admin)).to eq(\n        I18n.t(\n          \"post.cannot_permanently_delete.wait_or_different_admin\",\n          time_left: RateLimiter.time_left(Post::PERMANENT_DELETE_TIMER.to_i),\n        ),\n      )\n    end\n\n    it \"returns nothing if different admin\" do\n      expect(post.cannot_permanently_delete_reason(Fabricate(:admin))).to eq(nil)\n    end\n  end\n\n  describe \"#canonical_url\" do\n    it \"is able to determine correct canonical urls\" do\n      # ugly, but no interface to set this and we don't want to create\n      # 100 posts to test this thing\n      TopicView.stubs(:chunk_size).returns(2)\n\n      post1 = Fabricate(:post)\n      topic = post1.topic\n\n      post2 = Fabricate(:post, topic: topic)\n      post3 = Fabricate(:post, topic: topic)\n      post4 = Fabricate(:post, topic: topic)\n\n      topic_url = post1.topic.url\n\n      expect(post1.canonical_url).to eq(\"#{topic_url}#post_#{post1.post_number}\")\n      expect(post2.canonical_url).to eq(\"#{topic_url}#post_#{post2.post_number}\")\n\n      expect(post3.canonical_url).to eq(\"#{topic_url}?page=2#post_#{post3.post_number}\")\n      expect(post4.canonical_url).to eq(\"#{topic_url}?page=2#post_#{post4.post_number}\")\n    end\n  end\nend\n"], "filenames": ["app/models/post.rb", "spec/models/post_spec.rb"], "buggy_code_start_loc": [66, 63], "buggy_code_end_loc": [66, 63], "fixing_code_start_loc": [67, 64], "fixing_code_end_loc": [68, 65], "type": "CWE-770", "message": "Discourse is an open source discussion platform. Prior to version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches, a malicious user can edit a post in a topic and cause a DoS with a carefully crafted edit reason. The issue is patched in version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-37906", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-28T16:15:11.947", "lastModified": "2023-08-03T17:49:29.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. Prior to version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches, a malicious user can edit a post in a topic and cause a DoS with a carefully crafted edit reason. The issue is patched in version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.0.6", "matchCriteriaId": "8706E13A-141F-4E47-AA17-8DA913CE2020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BF272688-1B08-4ABC-8002-66B59690F9A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "A29A2465-B21D-4147-8292-DCF864D385B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "BBC3511E-3D68-42E2-B521-966FB429B640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "EC8B99C2-E267-4EC2-AF09-C9AD1EEE76D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "F21A22EE-081A-4489-A7F8-22E2DBC5B00E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E6C8FB3-4B19-4510-B9A8-BCF9ED8ED7C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6b:*:*:beta:*:*:*", "matchCriteriaId": "5B827291-6483-4BB7-AF76-530B669B3ED5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "551E70ED-34FF-4989-91C9-6312DE4AB4DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "204FB99A-8F11-4F04-9ED9-D94551790116"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "46A8705C-0DF6-45D7-A38C-D2AB69194C59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F59B0D8E-CFFB-4EBA-9D6A-526F9541BA17"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D801A898-27D0-4076-8AF9-2B574FA11723"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E7CBBD4A-4FDB-49E0-A5B6-22701C12BDF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9E7328DF-1924-4D0D-AC6B-1BA2D9CF1D4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9421CE10-F226-4F2C-9DA7-EBB44B73C304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "1E71FBB6-ECAD-4581-9982-4C330D55FEAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "1B631CCC-D456-49FF-B626-59C40BD4E167"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BE83F98D-F7AA-434B-8438-5B1FB96681B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "EB93F19B-9087-44CE-B884-45F434B7906F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5A88A5A3-EF1A-4E86-B074-CE0AC4325484"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "0650B4C7-BCFE-4180-8FEF-4170A67E8BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "388F376E-46C9-4163-992D-95E3E4548D0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D661090A-DA61-4BBE-85C3-6F48C053C84B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "4A458242-D6DD-46E3-AF09-66BC87C5D7A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A8FACCBA-0D3B-4E6F-85A0-1CBD2B367F71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F1D83D80-A0BE-4794-91A1-599AF558FB67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "BD15B6B2-BFB3-4271-A507-48E9B827FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "E0003042-9B14-4E1B-800F-3D154FFE8A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "E449EA29-81C8-4477-977E-746EACDBED86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6FC6D4DF-8686-4054-A0C1-784E194171E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "C574C37D-3D99-4430-A3D5-199883556B64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "F344E950-EFF9-4405-99D7-0B615C32873F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "0A50DE1B-29EB-4014-B5B6-46CF493485F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "638B3E17-9F0A-4A96-B8D3-DDFEA518DBE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6D3E3AEB-8CD4-4EE7-9C81-2F74512071DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "254FF9D9-E696-41C8-B15B-DA089D2C6597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "2A5001E1-E716-43AA-8093-E0EED9E07909"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "7FD16B13-516A-4D03-B1EF-A11156471A06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E886D9EF-7FBD-4A24-A8B6-54E4B15403C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "369A83D1-AB7E-488D-9D74-26A69DFC1AD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "3189CAC1-8970-4A33-B1E4-EB9EC3C19A25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A8733438-7625-400E-8237-BAE3D9F147AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "E87F1ED0-FD0D-4767-8E7C-325D920B79BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "97811266-A13C-4441-A1B5-BFA4B0862DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "3D09D157-4B19-4561-AB20-952F2EA9BA0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "789087AF-0011-4E8F-A5AB-432A5F91BBA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13b:*:*:beta:*:*:*", "matchCriteriaId": "8EC9DC8C-56DC-482B-8847-BD0CFACA6F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "F63B3D13-24F6-4EFA-9528-DBF59D973A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7F3A2388-18DE-46B0-BC13-7714E25D1B1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "940B11CB-053F-4D60-8BC4-81CA659D2F7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "83684DCB-B201-43B8-8B6E-6D0B13B7E437"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "DF92E1FD-9B41-4A41-8B13-9D789C5729D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "351D224A-E67C-454C-AF43-8AD6CD44C685"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E058CA6D-A295-4CAD-8C85-E8C83BAFEBD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "FF99C114-1BCA-4400-BC7E-EDA1F55559CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BBA1EFBA-5A26-46A0-B2A6-53B9924253BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "FE5B90B0-B6CC-4189-9C98-CF29017A47B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A1818628-5F4E-4E5D-974A-0BEBCE821209"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "14785840-3BC0-4030-AE44-E3013DF19AD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "90444209-684C-4BF8-9BCF-6B29EA0A0593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "668E15DE-8CF2-4AF3-B13A-9080046B1E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "1191861C-1B2C-4762-805D-FCDC20F84D05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "3CB518E5-CCC0-46B8-848E-C492BCF7E9BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CA1F68FE-67EA-4408-8E0F-558B0FAFFF32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "66E9F05C-799A-43D3-9367-FCA86166BD65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "85DB4097-6EFC-4017-ADFD-56EE49BB2F34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD283EA2-9026-497F-A7DE-E16CE0764ED0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "ED19DDDF-A29E-4C3F-A818-23D7E37B6974"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "508D0052-B7D7-4A08-8BB0-7D7A1EDAB96D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "3E50BFB0-67D3-4EDE-93FE-85EAF605461E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "D7EE0134-6AD7-4695-B536-1959FE3A9672"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "25DFFB5C-277F-4436-9BCE-643E98721C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "B8B80EB2-0B48-4AFA-8A09-26006CCDB022"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AC8705E0-23ED-4817-8B69-21A4963C27F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "BAA156A9-A9FB-4D03-B0EE-4AA303D7A9CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F733E585-075C-402A-9B34-1FE79DE4137E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "05C43439-C694-47AA-90AF-0AC2277E3D3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "B391F8A1-F102-4C88-864C-1386452CDAB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "0BC33C93-9947-4983-96A3-7DE223929817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B46DE141-1224-499E-AAE0-6CC0D5249B2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "D8D07501-A07E-4743-A188-2E5BBC3C8F97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "64FD2A30-EE33-4680-9DCF-29283DBA3C4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "B517F7A2-6FD1-4A7B-80E7-1167EC296591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "E6CA6EA5-DDAD-4882-AD1B-634C0CD741BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F14DCB07-9464-4DDE-98A1-FAE85DD60FBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6EDFD679-4710-4A62-B254-E658EED4295B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "A1B81072-08A5-4EC6-B737-E35C505C1E47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A0748A9E-5737-48F9-BB66-6576AFE16198"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "453E51D9-89A1-4A91-B218-05C45CC4E329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "51542BA7-8151-4FC9-9C86-36CEB476B912"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "5F95391C-0B75-47D2-9770-561E05414CEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "10384675-B949-4B50-AF42-B5A3EE27250B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "7C0DB1C0-5749-4508-A265-C2138F7852E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "CA9977CF-575C-4A19-84C8-EBB68EBE88C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "87C525C5-E282-4EC6-956F-0C94DC11FC69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "7F02A2A8-6312-4F6D-ABBF-952CA4C5E02E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "DE54D1A3-FC2A-40DE-9177-50332208B0B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "170AE3DA-92C1-4D1D-9CAC-543C01FFF479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "2130C3C5-E4A5-41C3-89F0-C6FB4E47D096"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "74248527-B884-4134-95C8-DEAF3D774A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta17:*:*:beta:*:*:*", "matchCriteriaId": "01A8AF9C-8BF6-4ADC-A85A-A5C1F9FFB2C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "B4038D09-467C-4815-A429-F0E1E3E545E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6F273237-7223-4047-83B7-16A49B7E554A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "CF26EE13-554C-4180-98A2-238D84E40927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "12688C9C-291D-4BF2-93F9-09AA323C52A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "A7F7A437-D538-4B44-AC41-C95641A11A35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "9BB61DCF-52DB-498D-8779-D565E548C285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "EE56BB77-B7F7-4BE7-AD9C-33888C5D01FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "9DB49E1D-BCC8-4984-A81D-5DAC5E3DF168"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "F775EA72-CCE3-4230-A666-EFDAA61F71FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5E65BDEE-850A-41C6-8CFB-BD8B3A105CD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "AF196429-FDED-4C3F-9F7D-0A2BF7DCAD1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "64B84326-5397-4C60-8007-F7E7D81DC661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "9A0A526A-9662-4E39-8BF6-E464BE1A2B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "712DACC2-A21E-429F-8A7B-86D8F7CE3468"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E93F9F6-5B03-4F77-B8B4-AEC9E4011692"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "C5B2B98E-804F-4525-B726-3F1DF2693F79"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "582E339F-678A-4377-8EE0-8F4208E3EF78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "1BF1D945-6EAA-4FA7-8252-2FED079587F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9325DFF5-EA7B-4B8D-A227-4B1A59449CE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0ECB28DA-3CA1-4011-9170-BFBF2ED3E091"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "2A6399B0-471B-4B26-859C-3836F2A6B7D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "131E2AE4-E35D-495D-8907-3B899BB8AC41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "83601528-0DD9-4835-B6C0-0F341871CC15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4AEB5AAF-73EB-4356-8C53-10E22B2F910E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9EB199D6-E253-4EC2-BF0B-059F7B6662ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "94A586EB-B0E0-4190-88DF-3BCC04E5EF84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0BF27B44-9AA7-4B91-9B4B-0E84418F5632"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "461744BD-3974-4C33-8514-0A917DC90C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6A86FB2B-6915-49C0-B993-0711AAECA5FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9EF3DD36-2776-4CD2-A3F1-88872024D223"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "D91D71ED-F08F-4DB5-B7DD-062E7C11435F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "62B5812A-FB52-4F4B-9A15-3AA5CD6562E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "83231EC0-E3F7-4E35-B165-487C2725B4F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "A53AFFA6-7B98-47F2-9BD7-71C83A69CE26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A42D3FB9-9197-4101-A729-876C490BD572"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A5DE0C47-0C66-4EFE-AF82-1B22F4F54A44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "E587D10F-BEF8-4923-AF76-6DC3172880EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "155568EF-6A7E-423A-B5EA-D20E407B271B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "7E94B119-8C75-43DF-A2DF-A5B3E04F0778"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5348F94F-F6AE-4400-8AC7-036111EF43D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "57948A73-C9C5-4C24-947D-0A4659C7002E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "3532EE37-2D0F-496C-B5A8-F9315FFB4552"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "2CAE7CC9-B91D-494C-B91A-497D6FE6B14B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "623BBBF8-4121-466A-82C8-D179B02B3E34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "648D010A-8B8D-42AA-8888-09E4E0FAA954"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "8ADC7613-25E3-4CB8-A962-2775C20E4D4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "1B0099F0-A275-4C65-9B79-041374F183DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "FE69800E-5CB5-4916-879C-51DE5E94489F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "8C64EAFE-2B60-4D95-869F-4A2FC98B99C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "AB2045F1-AC39-4738-B3F0-33F00D23C921"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E32589F8-2E87-40D2-BAD3-E6C1C088CA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "4868BAFD-BFE5-4361-855A-644B040E7233"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4B6C25BF-5B2A-43C4-8918-E32BA9DD8A22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "EB9917D3-D848-4D2B-8A44-B3723BA377DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "7046D95B-73CE-406B-ACC3-FD71F7DEC7CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "D3BA5033-2C06-42FF-962E-48EBA2EBB469"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "630D29DE-0FD7-4306-BA80-20D0791D334B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "08F94E42-07A1-480D-B6DD-D96AE38F1EBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FA4B3DE5-21DA-4185-AF74-AAA6DD89FB3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E602BEF9-E89D-40F7-BC6F-5C6F9F25BA97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "C06A8627-683D-4328-BE7A-4A33A4B736F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E3EF8240-D3F5-422C-B70A-90C6CBA4E622"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "93CC792D-AE0B-498E-8374-5D09EF4E28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "093D4EA8-B002-4AB4-97C9-CEE4D70BF3C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "4C778180-E7BF-4EF2-8B19-0388E23E1424"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "0C0B2BC1-35F1-4A1D-B9B2-54426B4ADF34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6BCAB620-465A-41FF-A064-FB638DD3A557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "6AFCB802-A275-444C-8245-D0397322125F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9F9B70E2-AAAD-4E61-AEB2-E5F635F6AAD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6182074E-C467-448C-9299-B92CFE4EEBE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "09EA8F36-7647-42D0-8675-34C002E0754D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "9CE2276A-9680-4B14-9636-806F7E4C1669"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AD150166-4C8D-47E3-989A-1A71A46C36A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CF5CA6AD-FA4D-47DF-A684-5DAD7662EA13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "B94F75B8-7C84-4727-9D18-114A815E1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "4D94E03A-32EE-408F-81FA-4B9C25AA7DDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD495875-007C-4A90-B940-B62E6FA492CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "05F1B84E-8AF8-46E8-9DE9-00D1DE348C2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BCCEFDFB-61E6-4846-8093-B5CEB0D8450C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "0BC63647-B692-4BB9-9A3D-6F8DF19C3494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "05F0ED55-C8C6-47C1-859A-60046838B6F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "6A2D59BC-2EE8-4F9C-AB5B-B9D01B44F7CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "933DFEBC-5568-431B-809D-AFAEFD08E985"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "BE920E80-C02B-4EC8-982F-ADE89C936684"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CDAE3441-12BA-41F4-8A5A-B2EE844C86BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "1443EA1B-D210-4219-8452-CBFD5FACBC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "948A4B4A-A11F-477E-BEC5-0D60C7E3570C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "98B2A052-5427-4B72-9F59-82F430836CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "CB6D636E-B51F-4648-A637-62B2603BA18F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "3DA17871-7ED7-4D68-A46D-D15DC5B3235F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "705FE965-0415-4382-8CA1-A19DF3B5EF35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "BC6EDCE3-D564-434F-9A7F-D4A6D579F8F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "FB05E54B-9CF6-45A7-8D47-C98DB6D19E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "03CD1C5E-18F5-4C6D-B92C-C511C8C12D0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "FF4ABB9D-69DF-42D5-AD60-F9CEEC1B6730"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7B4DCCF5-E290-4BDA-AAB9-DF362A2EB7B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "3AE1F3A2-8340-4ED7-B943-ACDA9617DF64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5E033AB7-9987-4C30-849F-2495376CA4F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "D87E9338-C7F6-43BA-886F-C30987ADBA1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E24EB90F-FE81-4746-8741-8DC9346F79C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "D237956F-FC90-467E-A493-24EFDA1A9F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "F7AA9AB8-AB6F-43E2-B3E5-685EE9BFE7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "5BC240A1-431E-4A50-88DC-7AC9BC674254"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "3F85AFD4-D397-4FDB-B762-521BD5FF14C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "D40CDCE1-3462-4D6C-A3C7-487F175264CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B9BBED17-A6BA-4F17-8814-8D8521F28375"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "888B8ECF-EBE0-4821-82F6-B0026E95E407"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FD0302B1-C0BA-49EE-8E1B-E8A43879BFC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9FE11D4E-32EE-48F4-8082-B37D2F804450"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9D797DA5-1AE5-4D49-B133-AF45D7FB0A4A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/dcc825bda505a344eda403a1b8733f30e784034a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-pjv6-47x6-mx7c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/dcc825bda505a344eda403a1b8733f30e784034a"}}