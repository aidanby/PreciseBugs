{"buggy_code": ["/*\n * SPDX-License-Identifier: ISC\n * SPDX-URL: https://spdx.org/licenses/ISC.html\n *\n * Copyright (C) 2006 Atheme Project (http://atheme.org/)\n * Copyright (C) 2019 Atheme Development Group (https://atheme.github.io/)\n *\n * Data structures and macros for SASL mechanisms.\n */\n\n#ifndef ATHEME_INC_SASL_H\n#define ATHEME_INC_SASL_H 1\n\n#include <atheme/attributes.h>\n#include <atheme/constants.h>\n#include <atheme/sourceinfo.h>\n#include <atheme/stdheaders.h>\n#include <atheme/structures.h>\n\n// Maximum number of parameters for an SASL S2S command (arbitrary, increment in future if necessary)\n#define SASL_MESSAGE_MAXPARA            8\n\n// Maximum length of an SASL mechanism name (including terminating NULL byte)\n#define SASL_MECHANISM_MAXLEN           60U\n\n// Maximum length of data that can be transferred in one shot\n#define SASL_S2S_MAXLEN_ATONCE_RAW      300U\n#define SASL_S2S_MAXLEN_ATONCE_B64      400U\n\n// Maximum length of data that can be buffered as one message/request\n#define SASL_S2S_MAXLEN_TOTAL_RAW       3072U\n#define SASL_S2S_MAXLEN_TOTAL_B64       4096U\n\n// Flags for sasl_session->flags\n#define ASASL_SFLAG_NONE                0x00000000U // Nothing special\n#define ASASL_SFLAG_MARKED_FOR_DELETION 0x00000001U // See sasl_delete_stale() in modules/saslserv/main.c\n#define ASASL_SFLAG_CLIENT_SECURE       0x00000002U // The client is connected to the network securely\n\n// Flags for sasl_input_buf->flags\n#define ASASL_INFLAG_NONE               0x00000000U // Nothing special\n#define ASASL_INFLAG_WIPE_BUF           0x00000001U // Call smemzero() on the input buffers after processing them\n\n// Flags for sasl_output_buf->flags\n#define ASASL_OUTFLAG_NONE              0x00000000U // Nothing special\n#define ASASL_OUTFLAG_FREE_BUF          0x00000001U // Call sfree() on the output buffer after processing it\n#define ASASL_OUTFLAG_WIPE_BUF          0x00000002U // Call smemzero() on the output buffers after processing them\n\nstruct sasl_session\n{\n\tmowgli_node_t                   node;                   // Node for entry into the active sessions list\n\tconst struct sasl_mechanism *   mechptr;                // Mechanism they're using\n\tstruct server *                 server;                 // Server they're on\n\tstruct sourceinfo *             si;                     // The source info for logcommand(), bad_password(), and login hooks\n\tvoid *                          mechdata;               // Mechanism-specific allocated memory\n\tchar *                          certfp;                 // TLS client certificate fingerprint (if any)\n\tchar *                          host;                   // Hostname\n\tchar *                          ip;                     // IP address\n\tchar *                          buf;                    // Buffered Base-64 data from them (so far)\n\tsize_t                          len;                    // Length of buffered Base-64 data\n\tunsigned int                    flags;                  // Flags (described above)\n\tchar                            authcid[NICKLEN + 1];   // Authentication identity (user having credentials verified)\n\tchar                            authzid[NICKLEN + 1];   // Authorization identity (user being logged in)\n\tchar                            authceid[IDLEN + 1];    // Entity ID for authcid\n\tchar                            authzeid[IDLEN + 1];    // Entity ID for authzid\n\tchar                            uid[UIDLEN + 1];        // Network UID\n};\n\nstruct sasl_sourceinfo\n{\n\tstruct sourceinfo       parent;\n\tstruct sasl_session *   sess;\n};\n\nstruct sasl_message\n{\n\tstruct server * server;\n\tchar *          uid;\n\tchar *          parv[SASL_MESSAGE_MAXPARA];\n\tint             parc;\n\tchar            mode;\n};\n\nstruct sasl_input_buf\n{\n\tconst void *    buf;\n\tconst size_t    len;\n\tunsigned int *  flags;\n};\n\nstruct sasl_output_buf\n{\n\tvoid *          buf;\n\tsize_t          len;\n\tunsigned int    flags;\n};\n\nenum sasl_mechanism_result\n{\n\tASASL_MRESULT_ERROR     = 1,    // An error has occurred in the mechanism, or the client screwed up\n\tASASL_MRESULT_FAILURE   = 2,    // Client supplied invalid credentials; run bad_password() on the target\n\tASASL_MRESULT_CONTINUE  = 3,    // Everything looks good so far, but we need more data from the client\n\tASASL_MRESULT_SUCCESS   = 4,    // The client has successfully authenticated\n};\n\ntypedef enum sasl_mechanism_result (*sasl_mech_start_fn)(struct sasl_session *restrict,\n    struct sasl_output_buf *restrict) ATHEME_FATTR_WUR;\n\ntypedef enum sasl_mechanism_result (*sasl_mech_step_fn)(struct sasl_session *restrict,\n    const struct sasl_input_buf *restrict, struct sasl_output_buf *restrict) ATHEME_FATTR_WUR;\n\ntypedef void (*sasl_mech_finish_fn)(struct sasl_session *);\n\nstruct sasl_mechanism\n{\n\tchar                name[SASL_MECHANISM_MAXLEN];\n\tsasl_mech_start_fn  mech_start;\n\tsasl_mech_step_fn   mech_step;\n\tsasl_mech_finish_fn mech_finish;\n\tbool                password_based;\n};\n\ntypedef bool (*sasl_authxid_can_login_fn)(struct sasl_session *restrict, const char *restrict,\n                                          struct myuser **restrict) ATHEME_FATTR_WUR;\n\nstruct sasl_core_functions\n{\n\tvoid                      (*mech_register)(const struct sasl_mechanism *);\n\tvoid                      (*mech_unregister)(const struct sasl_mechanism *);\n\tsasl_authxid_can_login_fn   authcid_can_login;\n\tsasl_authxid_can_login_fn   authzid_can_login;\n\tvoid                      (*recalc_mechlist)(const struct sasl_session *, const struct myuser *, const char **);\n};\n\n#endif /* !ATHEME_INC_SASL_H */\n", "/*\n * SPDX-License-Identifier: ISC\n * SPDX-URL: https://spdx.org/licenses/ISC.html\n *\n * Copyright (C) 2006-2015 Atheme Project (http://atheme.org/)\n * Copyright (C) 2017-2019 Atheme Development Group (https://atheme.github.io/)\n *\n * This file contains the main() routine.\n */\n\n#include <atheme.h>\n\n#ifndef MINIMUM\n#  define MINIMUM(a, b) (((a) < (b)) ? (a) : (b))\n#endif\n\n#define ASASL_OUTFLAGS_WIPE_FREE_BUF    (ASASL_OUTFLAG_WIPE_BUF | ASASL_OUTFLAG_FREE_BUF)\n#define LOGIN_CANCELLED_STR             \"There was a problem logging you in; login cancelled\"\n\nstatic mowgli_list_t sasl_sessions;\nstatic mowgli_list_t sasl_mechanisms;\nstatic char sasl_mechlist_string[SASL_S2S_MAXLEN_ATONCE_B64];\nstatic bool sasl_hide_server_names;\n\nstatic mowgli_eventloop_timer_t *sasl_delete_stale_timer = NULL;\nstatic struct service *saslsvs = NULL;\n\nstatic const char *\nsasl_format_sourceinfo(struct sourceinfo *const restrict si, const bool full)\n{\n\tstatic char result[BUFSIZE];\n\n\tconst struct sasl_sourceinfo *const ssi = (const struct sasl_sourceinfo *) si;\n\n\tif (full)\n\t\t(void) snprintf(result, sizeof result, \"SASL/%s:%s[%s]:%s\",\n\t\t                *ssi->sess->uid ? ssi->sess->uid : \"?\",\n\t\t                ssi->sess->host ? ssi->sess->host : \"?\",\n\t\t                ssi->sess->ip ? ssi->sess->ip : \"?\",\n\t\t                ssi->sess->server ? ssi->sess->server->name : \"?\");\n\telse\n\t\t(void) snprintf(result, sizeof result, \"SASL(%s)\",\n\t\t                ssi->sess->host ? ssi->sess->host : \"?\");\n\n\treturn result;\n}\n\nstatic const char *\nsasl_get_source_name(struct sourceinfo *const restrict si)\n{\n\tstatic char result[HOSTLEN + 1 + NICKLEN + 11];\n\tchar description[BUFSIZE];\n\n\tconst struct sasl_sourceinfo *const ssi = (const struct sasl_sourceinfo *) si;\n\n\tif (ssi->sess->server && ! sasl_hide_server_names)\n\t\t(void) snprintf(description, sizeof description, \"Unknown user on %s (via SASL)\",\n\t\t                                                 ssi->sess->server->name);\n\telse\n\t\t(void) mowgli_strlcpy(description, \"Unknown user (via SASL)\", sizeof description);\n\n\t// we can reasonably assume that si->v is non-null as this is part of the SASL vtable\n\tif (si->sourcedesc)\n\t\t(void) snprintf(result, sizeof result, \"<%s:%s>%s\", description, si->sourcedesc,\n\t\t                si->smu ? entity(si->smu)->name : \"\");\n\telse\n\t\t(void) snprintf(result, sizeof result, \"<%s>%s\", description, si->smu ? entity(si->smu)->name : \"\");\n\n\treturn result;\n}\n\nstatic void\nsasl_sourceinfo_recreate(struct sasl_session *const restrict p)\n{\n\tstatic struct sourceinfo_vtable sasl_vtable = {\n\n\t\t.description        = \"SASL\",\n\t\t.format             = sasl_format_sourceinfo,\n\t\t.get_source_name    = sasl_get_source_name,\n\t\t.get_source_mask    = sasl_get_source_name,\n\t};\n\n\tif (p->si)\n\t\t(void) atheme_object_unref(p->si);\n\n\tstruct sasl_sourceinfo *const ssi = smalloc(sizeof *ssi);\n\n\t(void) atheme_object_init(atheme_object(ssi), \"<sasl sourceinfo>\", &sfree);\n\n\tssi->parent.s = p->server;\n\tssi->parent.connection = curr_uplink->conn;\n\n\tif (p->host)\n\t\tssi->parent.sourcedesc = p->host;\n\n\tssi->parent.service = saslsvs;\n\tssi->parent.v = &sasl_vtable;\n\n\tssi->parent.force_language = language_find(\"en\");\n\tssi->sess = p;\n\n\tp->si = &ssi->parent;\n}\n\nstatic struct sasl_session *\nsasl_session_find(const char *const restrict uid)\n{\n\tif (! uid || ! *uid)\n\t\treturn NULL;\n\n\tmowgli_node_t *n;\n\n\tMOWGLI_ITER_FOREACH(n, sasl_sessions.head)\n\t{\n\t\tstruct sasl_session *const p = n->data;\n\n\t\tif (strcmp(p->uid, uid) == 0)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sasl_session *\nsasl_session_find_or_make(const struct sasl_message *const restrict smsg)\n{\n\tstruct sasl_session *p;\n\n\tif (! (p = sasl_session_find(smsg->uid)))\n\t{\n\t\tp = smalloc(sizeof *p);\n\n\t\tp->server = smsg->server;\n\n\t\t(void) mowgli_strlcpy(p->uid, smsg->uid, sizeof p->uid);\n\t\t(void) mowgli_node_add(p, &p->node, &sasl_sessions);\n\t}\n\n\treturn p;\n}\n\nstatic const struct sasl_mechanism *\nsasl_mechanism_find(const char *const restrict name)\n{\n\tmowgli_node_t *n;\n\n\tMOWGLI_ITER_FOREACH(n, sasl_mechanisms.head)\n\t{\n\t\tconst struct sasl_mechanism *const mptr = n->data;\n\n\t\tif (strcmp(mptr->name, name) == 0)\n\t\t\treturn mptr;\n\t}\n\n\t(void) slog(LG_DEBUG, \"%s: cannot find mechanism '%s'!\", MOWGLI_FUNC_NAME, name);\n\n\treturn NULL;\n}\n\nstatic void\nsasl_server_eob(struct server ATHEME_VATTR_UNUSED *const restrict s)\n{\n\t(void) sasl_mechlist_sts(sasl_mechlist_string);\n}\n\nstatic void\nsasl_mechlist_string_build(const struct sasl_session *const restrict p, const struct myuser *const restrict mu,\n                           const char **const restrict avoid)\n{\n\tchar buf[sizeof sasl_mechlist_string];\n\tchar *bufptr = buf;\n\tsize_t written = 0;\n\tmowgli_node_t *n;\n\n\t(void) memset(buf, 0x00, sizeof buf);\n\n\tMOWGLI_ITER_FOREACH(n, sasl_mechanisms.head)\n\t{\n\t\tconst struct sasl_mechanism *const mptr = n->data;\n\t\tbool in_avoid_list = false;\n\n\t\tcontinue_if_fail(mptr != NULL);\n\n\t\tfor (size_t i = 0; avoid != NULL && avoid[i] != NULL; i++)\n\t\t{\n\t\t\tif (strcmp(mptr->name, avoid[i]) == 0)\n\t\t\t{\n\t\t\t\tin_avoid_list = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (in_avoid_list || (mptr->password_based && mu != NULL && (mu->flags & MU_NOPASSWORD)))\n\t\t\tcontinue;\n\n\t\tconst size_t namelen = strlen(mptr->name);\n\n\t\tif (written + namelen >= sizeof buf)\n\t\t\tbreak;\n\n\t\t(void) memcpy(bufptr, mptr->name, namelen);\n\n\t\tbufptr += namelen;\n\t\t*bufptr++ = ',';\n\t\twritten += namelen + 1;\n\t}\n\n\tif (written)\n\t\t*(--bufptr) = 0x00;\n\n\tif (p)\n\t\t(void) sasl_sts(p->uid, 'M', buf);\n\telse\n\t\t(void) memcpy(sasl_mechlist_string, buf, sizeof buf);\n}\n\nstatic void\nsasl_mechlist_do_rebuild(void)\n{\n\t(void) sasl_mechlist_string_build(NULL, NULL, NULL);\n\n\tif (me.connected)\n\t\t(void) sasl_mechlist_sts(sasl_mechlist_string);\n}\n\nstatic bool\nsasl_may_impersonate(struct myuser *const source_mu, struct myuser *const target_mu)\n{\n\tif (source_mu == target_mu)\n\t\treturn true;\n\n\tchar priv[BUFSIZE] = PRIV_IMPERSONATE_ANY;\n\n\t// Check for wildcard priv\n\tif (has_priv_myuser(source_mu, priv))\n\t\treturn true;\n\n\t// Check for target-operclass specific priv\n\tconst char *const classname = (target_mu->soper && target_mu->soper->classname) ?\n\t                                  target_mu->soper->classname : \"user\";\n\t(void) snprintf(priv, sizeof priv, PRIV_IMPERSONATE_CLASS_FMT, classname);\n\tif (has_priv_myuser(source_mu, priv))\n\t\treturn true;\n\n\t// Check for target-entity specific priv\n\t(void) snprintf(priv, sizeof priv, PRIV_IMPERSONATE_ENTITY_FMT, entity(target_mu)->name);\n\tif (has_priv_myuser(source_mu, priv))\n\t\treturn true;\n\n\t// Allow modules to check too\n\tstruct hook_sasl_may_impersonate req = {\n\n\t\t.source_mu = source_mu,\n\t\t.target_mu = target_mu,\n\t\t.allowed = false,\n\t};\n\n\t(void) hook_call_sasl_may_impersonate(&req);\n\n\treturn req.allowed;\n}\n\nstatic struct myuser *\nsasl_user_can_login(struct sasl_session *const restrict p)\n{\n\t// source_mu is the user whose credentials we verified (\"authentication id\" / authcid)\n\t// target_mu is the user who will be ultimately logged in (\"authorization id\" / authzid)\n\tstruct myuser *source_mu;\n\tstruct myuser *target_mu;\n\n\tif (! *p->authceid || ! (source_mu = myuser_find_uid(p->authceid)))\n\t\treturn NULL;\n\n\tif (! *p->authzeid)\n\t{\n\t\ttarget_mu = source_mu;\n\n\t\t(void) mowgli_strlcpy(p->authzid, p->authcid, sizeof p->authzid);\n\t\t(void) mowgli_strlcpy(p->authzeid, p->authceid, sizeof p->authzeid);\n\t}\n\telse if (! (target_mu = myuser_find_uid(p->authzeid)))\n\t\treturn NULL;\n\n\tif (! sasl_may_impersonate(source_mu, target_mu))\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\",\n\t\t                                       entity(source_mu)->name, entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif (! (target_mu->flags & MU_LOGINNOLIMIT)\n\t\t&& !has_priv_myuser(target_mu, PRIV_LOGIN_NOLIMIT)\n\t\t&& MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (too many logins)\",\n\t\t                                       entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\t/* We just did SASL authentication for a user.  With IRCds which do not\n\t * have unique UIDs for users, we will likely be expecting the login\n\t * data to be bursted.  As a result, we should give the core a heads'\n\t * up that this is going to happen so that hooks will be properly\n\t * fired...\n\t */\n\tif (ircd->flags & IRCD_SASL_USE_PUID)\n\t{\n\t\ttarget_mu->flags &= ~MU_NOBURSTLOGIN;\n\t\ttarget_mu->flags |= MU_PENDINGLOGIN;\n\t}\n\n\tif (target_mu != source_mu)\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\",\n\t\t                                       entity(source_mu)->name, entity(target_mu)->name);\n\n\treturn target_mu;\n}\n\nstatic void\nsasl_session_destroy(struct sasl_session *const restrict p)\n{\n\tmowgli_node_t *n;\n\n\tMOWGLI_ITER_FOREACH(n, sasl_sessions.head)\n\t{\n\t\tif (n == &p->node && n->data == p)\n\t\t{\n\t\t\t(void) mowgli_node_delete(n, &sasl_sessions);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p->mechptr && p->mechptr->mech_finish)\n\t\t(void) p->mechptr->mech_finish(p);\n\n\tif (p->si)\n\t\t(void) atheme_object_unref(p->si);\n\n\tstruct user *const u = user_find(p->uid);\n\tif (u)\n\t\t// If the user is still on the network, allow them to use NickServ IDENTIFY/LOGIN again\n\t\tu->flags &= ~UF_DOING_SASL;\n\n\t(void) sfree(p->certfp);\n\t(void) sfree(p->host);\n\t(void) sfree(p->buf);\n\t(void) sfree(p->ip);\n\t(void) sfree(p);\n}\n\nstatic inline void\nsasl_session_abort(struct sasl_session *const restrict p)\n{\n\t(void) sasl_sts(p->uid, 'D', \"F\");\n\t(void) sasl_session_destroy(p);\n}\n\nstatic bool\nsasl_session_success(struct sasl_session *const restrict p, struct myuser *const restrict mu, const bool destroy)\n{\n\t/* Only burst an account name and vhost if the user has verified their e-mail address;\n\t * this prevents spambots from creating accounts to join registered-user-only channels\n\t */\n\tif (! (mu->flags & MU_WAITAUTH))\n\t{\n\t\tconst struct metadata *const md = metadata_find(mu, \"private:usercloak\");\n\t\tconst char *const cloak = ((md != NULL) ? md->value : \"*\");\n\n\t\t(void) svslogin_sts(p->uid, \"*\", \"*\", cloak, mu);\n\t}\n\n\t(void) sasl_sts(p->uid, 'D', \"S\");\n\n\tif (destroy)\n\t\t(void) sasl_session_destroy(p);\n\n\treturn true;\n}\n\nstatic bool\nsasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\n\t// Find the account if necessary\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// If the user is already logged in, and not to the same account, log them out first\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\n\t// If they were not killed above, log them in now\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t// If they're not logged in, or logging in to a different account, do a full login\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Otherwise, just update login time ...\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic enum sasl_mechanism_result ATHEME_FATTR_WUR\nsasl_process_input(struct sasl_session *const restrict p, char *const restrict buf, const size_t len,\n                   struct sasl_output_buf *const restrict outbuf)\n{\n\t// A single + character is not data at all -- invoke mech_step without an input buffer\n\tif (*buf == '+' && len == 1)\n\t\treturn p->mechptr->mech_step(p, NULL, outbuf);\n\n\tunsigned char decbuf[SASL_S2S_MAXLEN_TOTAL_RAW + 1];\n\tconst size_t declen = base64_decode(buf, decbuf, SASL_S2S_MAXLEN_TOTAL_RAW);\n\n\tif (declen == BASE64_FAIL)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: base64_decode() failed\", MOWGLI_FUNC_NAME);\n\t\treturn ASASL_MRESULT_ERROR;\n\t}\n\n\t/* Account for the fact that the client may have sent whitespace; our\n\t * decoder is tolerant of whitespace and will skip over it    -- amdj\n\t */\n\tif (declen == 0)\n\t\treturn p->mechptr->mech_step(p, NULL, outbuf);\n\n\tunsigned int inflags = ASASL_INFLAG_NONE;\n\tconst struct sasl_input_buf inbuf = {\n\t\t.buf    = decbuf,\n\t\t.len    = declen,\n\t\t.flags  = &inflags,\n\t};\n\n\t// Ensure input is NULL-terminated for modules that want to process the data as a string\n\tdecbuf[declen] = 0x00;\n\n\t// Pass the data to the mechanism\n\tconst enum sasl_mechanism_result rc = p->mechptr->mech_step(p, &inbuf, outbuf);\n\n\t// The mechanism instructed us to wipe the input data now that it has been processed\n\tif (inflags & ASASL_INFLAG_WIPE_BUF)\n\t{\n\t\t/* If we got here, the bufferred base64-encoded input data is either in a\n\t\t * dedicated buffer (buf == p->buf && len == p->len) or directly from a\n\t\t * parv[] inside struct sasl_message. Either way buf is mutable.    -- amdj\n\t\t */\n\t\t(void) smemzero(buf, len);          // Erase the base64-encoded input data\n\t\t(void) smemzero(decbuf, declen);    // Erase the base64-decoded input data\n\t}\n\n\treturn rc;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_process_output(struct sasl_session *const restrict p, struct sasl_output_buf *const restrict outbuf)\n{\n\tchar encbuf[SASL_S2S_MAXLEN_TOTAL_B64 + 1];\n\tconst size_t enclen = base64_encode(outbuf->buf, outbuf->len, encbuf, sizeof encbuf);\n\n\tif ((outbuf->flags & ASASL_OUTFLAGS_WIPE_FREE_BUF) == ASASL_OUTFLAGS_WIPE_FREE_BUF)\n\t\t// The mechanism instructed us to wipe and free the output data now that it has been encoded\n\t\t(void) smemzerofree(outbuf->buf, outbuf->len);\n\telse if (outbuf->flags & ASASL_OUTFLAG_WIPE_BUF)\n\t\t// The mechanism instructed us to wipe the output data now that it has been encoded\n\t\t(void) smemzero(outbuf->buf, outbuf->len);\n\telse if (outbuf->flags & ASASL_OUTFLAG_FREE_BUF)\n\t\t// The mechanism instructed us to free the output data now that it has been encoded\n\t\t(void) sfree(outbuf->buf);\n\n\toutbuf->buf = NULL;\n\toutbuf->len = 0;\n\n\tif (enclen == BASE64_FAIL)\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: base64_encode() failed\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\n\tchar *encbufptr = encbuf;\n\tsize_t encbuflast = SASL_S2S_MAXLEN_ATONCE_B64;\n\n\tfor (size_t encbufrem = enclen; encbufrem != 0; /* No action */)\n\t{\n\t\tchar encbufpart[SASL_S2S_MAXLEN_ATONCE_B64 + 1];\n\t\tconst size_t encbufptrlen = MINIMUM(SASL_S2S_MAXLEN_ATONCE_B64, encbufrem);\n\n\t\t(void) memset(encbufpart, 0x00, sizeof encbufpart);\n\t\t(void) memcpy(encbufpart, encbufptr, encbufptrlen);\n\t\t(void) sasl_sts(p->uid, 'C', encbufpart);\n\n\t\t// The mechanism instructed us to wipe the output data now that it has been transmitted\n\t\tif (outbuf->flags & ASASL_OUTFLAG_WIPE_BUF)\n\t\t{\n\t\t\t(void) smemzero(encbufpart, encbufptrlen);\n\t\t\t(void) smemzero(encbufptr, encbufptrlen);\n\t\t}\n\n\t\tencbufptr += encbufptrlen;\n\t\tencbufrem -= encbufptrlen;\n\t\tencbuflast = encbufptrlen;\n\t}\n\n\t/* The end of a packet is indicated by a string not of the maximum length. If the last string\n\t * was the maximum length, send another, empty string, to advance the session.    -- amdj\n\t */\n\tif (encbuflast == SASL_S2S_MAXLEN_ATONCE_B64)\n\t\t(void) sasl_sts(p->uid, 'C', \"+\");\n\n\treturn true;\n}\n\n/* given an entire sasl message, advance session by passing data to mechanism\n * and feeding returned data back to client.\n */\nstatic bool ATHEME_FATTR_WUR\nsasl_process_packet(struct sasl_session *const restrict p, char *const restrict buf, const size_t len)\n{\n\tstruct sasl_output_buf outbuf = {\n\t\t.buf    = NULL,\n\t\t.len    = 0,\n\t\t.flags  = ASASL_OUTFLAG_NONE,\n\t};\n\n\tenum sasl_mechanism_result rc;\n\tbool have_responded = false;\n\n\tif (! p->mechptr && ! len)\n\t{\n\t\t// First piece of data in a session is the name of the SASL mechanism that will be used\n\t\tif (! (p->mechptr = sasl_mechanism_find(buf)))\n\t\t{\n\t\t\t(void) sasl_sts(p->uid, 'M', sasl_mechlist_string);\n\t\t\treturn false;\n\t\t}\n\n\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\tif (p->mechptr->mech_start)\n\t\t\trc = p->mechptr->mech_start(p, &outbuf);\n\t\telse\n\t\t\trc = ASASL_MRESULT_CONTINUE;\n\t}\n\telse if (! p->mechptr)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: session has no mechanism?\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\trc = sasl_process_input(p, buf, len, &outbuf);\n\t}\n\n\tif (outbuf.buf && outbuf.len)\n\t{\n\t\tif (! sasl_process_output(p, &outbuf))\n\t\t\treturn false;\n\n\t\thave_responded = true;\n\t}\n\n\t// Some progress has been made, reset timeout.\n\tp->flags &= ~ASASL_SFLAG_MARKED_FOR_DELETION;\n\n\tswitch (rc)\n\t{\n\t\tcase ASASL_MRESULT_CONTINUE:\n\t\t{\n\t\t\tif (! have_responded)\n\t\t\t\t/* We want more data from the client, but we haven't sent any of our own.\n\t\t\t\t * Send an empty string to advance the session.    -- amdj\n\t\t\t\t */\n\t\t\t\t(void) sasl_sts(p->uid, 'C', \"+\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcase ASASL_MRESULT_SUCCESS:\n\t\t{\n\t\t\tstruct user *const u = user_find(p->uid);\n\t\t\tstruct myuser *const mu = sasl_user_can_login(p);\n\n\t\t\tif (! mu)\n\t\t\t{\n\t\t\t\tif (u)\n\t\t\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/* If the user is already on the network, attempt to log them in immediately.\n\t\t\t * Otherwise, we will log them in on introduction of user to network\n\t\t\t */\n\t\t\tif (u && ! sasl_handle_login(p, u, mu))\n\t\t\t\treturn false;\n\n\t\t\treturn sasl_session_success(p, mu, (u != NULL));\n\t\t}\n\n\t\tcase ASASL_MRESULT_FAILURE:\n\t\t{\n\t\t\tif (*p->authceid)\n\t\t\t{\n\t\t\t\t/* If we reach this, they failed SASL auth, so if they were trying\n\t\t\t\t * to authenticate as a specific user, run bad_password() on them.\n\t\t\t\t */\n\t\t\t\tstruct myuser *const mu = myuser_find_uid(p->authceid);\n\n\t\t\t\tif (! mu)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* We might have more information to construct a more accurate sourceinfo now?\n\t\t\t\t * TODO: Investigate whether this is necessary\n\t\t\t\t */\n\t\t\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\t\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN (%s) to \\2%s\\2 (bad password)\",\n\t\t\t\t                                       p->mechptr->name, entity(mu)->name);\n\t\t\t\t(void) bad_password(p->si, mu);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tcase ASASL_MRESULT_ERROR:\n\t\t\treturn false;\n\t}\n\n\t/* This is only here to keep GCC happy -- Clang can see that the switch() handles all legal\n\t * values of the enumeration, and so knows that this function will never get to this point;\n\t * GCC is dumb, and warns that control reaches the end of this non-void function.    -- amdj\n\t */\n\treturn false;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_process_buffer(struct sasl_session *const restrict p)\n{\n\t// Ensure the buffer is NULL-terminated so that base64_decode() doesn't overrun it\n\tp->buf[p->len] = 0x00;\n\n\tif (! sasl_process_packet(p, p->buf, p->len))\n\t\treturn false;\n\n\t(void) sfree(p->buf);\n\n\tp->buf = NULL;\n\tp->len = 0;\n\n\treturn true;\n}\n\nstatic void\nsasl_input_hostinfo(const struct sasl_message *const restrict smsg, struct sasl_session *const restrict p)\n{\n\tp->host = sstrdup(smsg->parv[0]);\n\tp->ip   = sstrdup(smsg->parv[1]);\n\n\tif (smsg->parc >= 3 && strcmp(smsg->parv[2], \"P\") != 0)\n\t\tp->flags |= ASASL_SFLAG_CLIENT_SECURE;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_input_startauth(const struct sasl_message *const restrict smsg, struct sasl_session *const restrict p)\n{\n\tif (strcmp(smsg->parv[0], \"EXTERNAL\") == 0)\n\t{\n\t\tif (smsg->parc < 2)\n\t\t{\n\t\t\t(void) slog(LG_DEBUG, \"%s: client %s starting EXTERNAL authentication without a \"\n\t\t\t                      \"fingerprint\", MOWGLI_FUNC_NAME, p->uid);\n\t\t\treturn false;\n\t\t}\n\n\t\t(void) sfree(p->certfp);\n\n\t\tp->certfp = sstrdup(smsg->parv[1]);\n\t\tp->flags |= ASASL_SFLAG_CLIENT_SECURE;\n\t}\n\n\tstruct user *const u = user_find(p->uid);\n\n\tif (u && u->myuser)\n\t{\n\t\t/* If the user is already on the network, they're doing an IRCv3.2 SASL\n\t\t * reauthentication. This means that if the user is logged in, we need\n\t\t * to call the user_can_logout hooks and maybe abort the exchange now.\n\t\t */\n\t\t(void) slog(LG_DEBUG, \"%s: user %s ('%s') is logged in as '%s' -- executing user_can_logout hooks\",\n\t\t                      MOWGLI_FUNC_NAME, p->uid, u->nick, entity(u->myuser)->name);\n\n\t\tstruct hook_user_logout_check req = {\n\t\t\t.si      = p->si,\n\t\t\t.u       = u,\n\t\t\t.allowed = true,\n\t\t\t.relogin = true,\n\t\t};\n\n\t\t(void) hook_call_user_can_logout(&req);\n\n\t\tif (! req.allowed)\n\t\t{\n\t\t\t(void) notice(saslsvs->nick, u->nick,\n\t\t\t              \"You cannot log out \\2%s\\2 because the server configuration disallows it.\",\n\t\t\t              entity(u->myuser)->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (u)\n\t\tu->flags |= UF_DOING_SASL;\n\n\treturn sasl_process_packet(p, smsg->parv[0], 0);\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_input_clientdata(const struct sasl_message *const restrict smsg, struct sasl_session *const restrict p)\n{\n\t/* This is complicated.\n\t *\n\t * Clients are restricted to sending us 300 bytes (400 Base-64 characters), but the mechanism\n\t * that they have chosen could require them to send more than this amount, so they have to send\n\t * it 400 Base-64 characters at a time in stages. When we receive data less than 400 characters,\n\t * we know we don't need to buffer any more data, and can finally process it.\n\t *\n\t * However, if the client wants to send us a multiple of 400 characters and no more, we would be\n\t * waiting forever for them to send 'the rest', even though there isn't any. This is solved by\n\t * having them send a single '+' character to indicate that they have no more data to send.\n\t *\n\t * This is also what clients send us when they do not want to send us any data at all, and in\n\t * either event, this is *NOT* *DATA* we are receiving, and we should not buffer it.\n\t *\n\t * Also, if the data is a single '*' character, the client is aborting authentication. Servers\n\t * should send us a 'D' packet instead of a 'C *' packet in this case, but this is for if they\n\t * don't. Note that this will usually result in the client getting a 904 numeric instead of 906,\n\t * but the alternative is not treating '*' specially and then going on to fail to decode it in\n\t * sasl_process_input() above, which will result in ... an aborted session and a 904 numeric.\n\t * So this just saves time.\n\t */\n\n\tconst size_t len = strlen(smsg->parv[0]);\n\n\t// Abort?\n\tif (len == 1 && smsg->parv[0][0] == '*')\n\t\treturn false;\n\n\t// End of data?\n\tif (len == 1 && smsg->parv[0][0] == '+')\n\t{\n\t\tif (p->buf)\n\t\t\treturn sasl_process_buffer(p);\n\n\t\t// This function already deals with the special case of 1 '+' character\n\t\treturn sasl_process_packet(p, smsg->parv[0], len);\n\t}\n\n\t/* Optimisation: If there is no buffer yet and this data is less than 400 characters, we don't\n\t * need to buffer it at all, and can process it immediately.\n\t */\n\tif (! p->buf && len < SASL_S2S_MAXLEN_ATONCE_B64)\n\t\treturn sasl_process_packet(p, smsg->parv[0], len);\n\n\t/* We need to buffer the data now, but first check if the client hasn't sent us an excessive\n\t * amount already.\n\t */\n\tif ((p->len + len) > SASL_S2S_MAXLEN_TOTAL_B64)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: client %s has exceeded allowed data length\", MOWGLI_FUNC_NAME, p->uid);\n\t\treturn false;\n\t}\n\n\t// (Re)allocate a buffer, append the received data to it, and update its recorded length.\n\tp->buf = srealloc(p->buf, p->len + len + 1);\n\t(void) memcpy(p->buf + p->len, smsg->parv[0], len);\n\tp->len += len;\n\n\t// Messages not exactly 400 characters are the end of data.\n\tif (len < SASL_S2S_MAXLEN_ATONCE_B64)\n\t\treturn sasl_process_buffer(p);\n\n\treturn true;\n}\n\nstatic void\nsasl_input(struct sasl_message *const restrict smsg)\n{\n\tstruct sasl_session *const p = sasl_session_find_or_make(smsg);\n\n\tbool ret = true;\n\n\tswitch (smsg->mode)\n\t{\n\t\tcase 'H':\n\t\t\t// (H)ost information\n\t\t\t(void) sasl_input_hostinfo(smsg, p);\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t// (S)tart authentication\n\t\t\tret = sasl_input_startauth(smsg, p);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\t// (C)lient data\n\t\t\tret = sasl_input_clientdata(smsg, p);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\t// (D)one -- when we receive it, means client abort\n\t\t\t(void) sasl_session_destroy(p);\n\t\t\tbreak;\n\t}\n\n\tif (! ret)\n\t\t(void) sasl_session_abort(p);\n}\n\nstatic void\nsasl_user_add(struct hook_user_nick *const restrict data)\n{\n\t// If the user has been killed, don't do anything.\n\tstruct user *const u = data->u;\n\tif (! u)\n\t\treturn;\n\n\t// Not concerned unless it's an SASL login.\n\tstruct sasl_session *const p = sasl_session_find(u->uid);\n\tif (! p)\n\t\treturn;\n\n\t(void) sasl_handle_login(p, u, NULL);\n\t(void) sasl_session_destroy(p);\n}\n\nstatic void\nsasl_delete_stale(void ATHEME_VATTR_UNUSED *const restrict vptr)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, sasl_sessions.head)\n\t{\n\t\tstruct sasl_session *const p = n->data;\n\n\t\tif (p->flags & ASASL_SFLAG_MARKED_FOR_DELETION)\n\t\t\t(void) sasl_session_destroy(p);\n\t\telse\n\t\t\tp->flags |= ASASL_SFLAG_MARKED_FOR_DELETION;\n\t}\n}\n\nstatic void\nsasl_mech_register(const struct sasl_mechanism *const restrict mech)\n{\n\tif (sasl_mechanism_find(mech->name))\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: ignoring attempt to register %s again\", MOWGLI_FUNC_NAME, mech->name);\n\t\treturn;\n\t}\n\n\t(void) slog(LG_DEBUG, \"%s: registering %s\", MOWGLI_FUNC_NAME, mech->name);\n\n\tmowgli_node_t *const node = mowgli_node_create();\n\n\tif (! node)\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: mowgli_node_create() failed; out of memory?\", MOWGLI_FUNC_NAME);\n\t\treturn;\n\t}\n\n\t/* Here we cast it to (void *) because mowgli_node_add() expects that; it cannot be made const because then\n\t * it would have to return a (const void *) too which would cause multiple warnings any time it is actually\n\t * storing, and thus gets assigned to, a pointer to a mutable object.\n\t *\n\t * To avoid the cast generating a diagnostic due to dropping a const qualifier, we first cast to uintptr_t.\n\t * This is not unprecedented in this codebase; libathemecore/crypto.c & libathemecore/strshare.c do the\n\t * same thing.\n\t */\n\t(void) mowgli_node_add((void *)((uintptr_t) mech), node, &sasl_mechanisms);\n\n\t(void) sasl_mechlist_do_rebuild();\n}\n\nstatic void\nsasl_mech_unregister(const struct sasl_mechanism *const restrict mech)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, sasl_sessions.head)\n\t{\n\t\tstruct sasl_session *const session = n->data;\n\n\t\tif (session->mechptr == mech)\n\t\t{\n\t\t\t(void) slog(LG_DEBUG, \"%s: destroying session %s\", MOWGLI_FUNC_NAME, session->uid);\n\t\t\t(void) sasl_session_destroy(session);\n\t\t}\n\t}\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, sasl_mechanisms.head)\n\t{\n\t\tif (n->data == mech)\n\t\t{\n\t\t\t(void) slog(LG_DEBUG, \"%s: unregistering %s\", MOWGLI_FUNC_NAME, mech->name);\n\t\t\t(void) mowgli_node_delete(n, &sasl_mechanisms);\n\t\t\t(void) mowgli_node_free(n);\n\t\t\t(void) sasl_mechlist_do_rebuild();\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline bool ATHEME_FATTR_WUR\nsasl_authxid_can_login(struct sasl_session *const restrict p, const char *const restrict authxid,\n                       struct myuser **const restrict muo, char *const restrict val_name,\n                       char *const restrict val_eid, const char *const restrict other_val_eid)\n{\n\treturn_val_if_fail(p != NULL, false);\n\treturn_val_if_fail(p->si != NULL, false);\n\treturn_val_if_fail(p->mechptr != NULL, false);\n\n\tstruct myuser *const mu = myuser_find_by_nick(authxid);\n\n\tif (! mu)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: myuser_find_by_nick: does not exist\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\tif (metadata_find(mu, \"private:freeze:freezer\"))\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(mu)->name);\n\t\treturn false;\n\t}\n\n\tif (muo)\n\t\t*muo = mu;\n\n\t(void) mowgli_strlcpy(val_name, entity(mu)->name, NICKLEN + 1);\n\t(void) mowgli_strlcpy(val_eid, entity(mu)->id, IDLEN + 1);\n\n\tif (p->mechptr->password_based && (mu->flags & MU_NOPASSWORD))\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN %s to \\2%s\\2 (password authentication disabled)\",\n\t\t                  p->mechptr->name, entity(mu)->name);\n\n\t\treturn false;\n\t}\n\n\tif (strcmp(val_eid, other_val_eid) == 0)\n\t\t// We have already executed the user_can_login hook for this user\n\t\treturn true;\n\n\tstruct hook_user_login_check req = {\n\n\t\t.si         = p->si,\n\t\t.mu         = mu,\n\t\t.allowed    = true,\n\t};\n\n\t(void) hook_call_user_can_login(&req);\n\n\tif (! req.allowed)\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(mu)->name);\n\n\treturn req.allowed;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_authcid_can_login(struct sasl_session *const restrict p, const char *const restrict authcid,\n                       struct myuser **const restrict muo)\n{\n\treturn sasl_authxid_can_login(p, authcid, muo, p->authcid, p->authceid, p->authzeid);\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_authzid_can_login(struct sasl_session *const restrict p, const char *const restrict authzid,\n                       struct myuser **const restrict muo)\n{\n\treturn sasl_authxid_can_login(p, authzid, muo, p->authzid, p->authzeid, p->authceid);\n}\n\nextern const struct sasl_core_functions sasl_core_functions;\nconst struct sasl_core_functions sasl_core_functions = {\n\n\t.mech_register      = &sasl_mech_register,\n\t.mech_unregister    = &sasl_mech_unregister,\n\t.authcid_can_login  = &sasl_authcid_can_login,\n\t.authzid_can_login  = &sasl_authzid_can_login,\n\t.recalc_mechlist    = &sasl_mechlist_string_build,\n};\n\nstatic void\nsaslserv_message_handler(struct sourceinfo *const restrict si, const int parc, char **const restrict parv)\n{\n\t// this should never happen\n\tif (parv[0][0] == '&')\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: got parv with local channel: %s\", MOWGLI_FUNC_NAME, parv[0]);\n\t\treturn;\n\t}\n\n\t// make a copy of the original for debugging\n\tchar orig[BUFSIZE];\n\t(void) mowgli_strlcpy(orig, parv[parc - 1], sizeof orig);\n\n\t// lets go through this to get the command\n\tchar *const cmd = strtok(parv[parc - 1], \" \");\n\tchar *const text = strtok(NULL, \"\");\n\n\tif (! cmd)\n\t\treturn;\n\n\tif (*orig == '\\001')\n\t{\n\t\t(void) handle_ctcp_common(si, cmd, text);\n\t\treturn;\n\t}\n\n\t(void) command_fail(si, fault_noprivs, _(\"This service exists to identify connecting clients \"\n\t                                         \"to the network. It has no public interface.\"));\n}\n\nstatic void\nmod_init(struct module *const restrict m)\n{\n\tif (! (saslsvs = service_add(\"saslserv\", &saslserv_message_handler)))\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: service_add() failed\", m->name);\n\t\tm->mflags |= MODFLAG_FAIL;\n\t\treturn;\n\t}\n\n\t(void) hook_add_sasl_input(&sasl_input);\n\t(void) hook_add_user_add(&sasl_user_add);\n\t(void) hook_add_server_eob(&sasl_server_eob);\n\n\tsasl_delete_stale_timer = mowgli_timer_add(base_eventloop, \"sasl_delete_stale\", &sasl_delete_stale, NULL, SECONDS_PER_MINUTE / 2);\n\tauthservice_loaded++;\n\n\t(void) add_bool_conf_item(\"HIDE_SERVER_NAMES\", &saslsvs->conf_table, 0, &sasl_hide_server_names, false);\n}\n\nstatic void\nmod_deinit(const enum module_unload_intent ATHEME_VATTR_UNUSED intent)\n{\n\t(void) hook_del_sasl_input(&sasl_input);\n\t(void) hook_del_user_add(&sasl_user_add);\n\t(void) hook_del_server_eob(&sasl_server_eob);\n\n\t(void) mowgli_timer_destroy(base_eventloop, sasl_delete_stale_timer);\n\n\t(void) del_conf_item(\"HIDE_SERVER_NAMES\", &saslsvs->conf_table);\n\t(void) service_delete(saslsvs);\n\n\tauthservice_loaded--;\n\n\tif (sasl_sessions.head)\n\t\t(void) slog(LG_ERROR, \"saslserv/main: shutting down with a non-empty session list; \"\n\t\t                      \"a mechanism did not unregister itself! (BUG)\");\n}\n\nSIMPLE_DECLARE_MODULE_V1(\"saslserv/main\", MODULE_UNLOAD_CAPABILITY_OK)\n"], "fixing_code": ["/*\n * SPDX-License-Identifier: ISC\n * SPDX-URL: https://spdx.org/licenses/ISC.html\n *\n * Copyright (C) 2006 Atheme Project (http://atheme.org/)\n * Copyright (C) 2019 Atheme Development Group (https://atheme.github.io/)\n *\n * Data structures and macros for SASL mechanisms.\n */\n\n#ifndef ATHEME_INC_SASL_H\n#define ATHEME_INC_SASL_H 1\n\n#include <atheme/attributes.h>\n#include <atheme/constants.h>\n#include <atheme/sourceinfo.h>\n#include <atheme/stdheaders.h>\n#include <atheme/structures.h>\n\n// Maximum number of parameters for an SASL S2S command (arbitrary, increment in future if necessary)\n#define SASL_MESSAGE_MAXPARA            8\n\n// Maximum length of an SASL mechanism name (including terminating NULL byte)\n#define SASL_MECHANISM_MAXLEN           60U\n\n// Maximum length of data that can be transferred in one shot\n#define SASL_S2S_MAXLEN_ATONCE_RAW      300U\n#define SASL_S2S_MAXLEN_ATONCE_B64      400U\n\n// Maximum length of data that can be buffered as one message/request\n#define SASL_S2S_MAXLEN_TOTAL_RAW       3072U\n#define SASL_S2S_MAXLEN_TOTAL_B64       4096U\n\n// Flags for sasl_session->flags\n#define ASASL_SFLAG_NONE                0x00000000U // Nothing special\n#define ASASL_SFLAG_MARKED_FOR_DELETION 0x00000001U // See sasl_delete_stale() in modules/saslserv/main.c\n#define ASASL_SFLAG_CLIENT_SECURE       0x00000002U // The client is connected to the network securely\n\n// Flags for sasl_input_buf->flags\n#define ASASL_INFLAG_NONE               0x00000000U // Nothing special\n#define ASASL_INFLAG_WIPE_BUF           0x00000001U // Call smemzero() on the input buffers after processing them\n\n// Flags for sasl_output_buf->flags\n#define ASASL_OUTFLAG_NONE              0x00000000U // Nothing special\n#define ASASL_OUTFLAG_FREE_BUF          0x00000001U // Call sfree() on the output buffer after processing it\n#define ASASL_OUTFLAG_WIPE_BUF          0x00000002U // Call smemzero() on the output buffers after processing them\n\nstruct sasl_session\n{\n\tmowgli_node_t                   node;                   // Node for entry into the active sessions list\n\tconst struct sasl_mechanism *   mechptr;                // Mechanism they're using\n\tstruct server *                 server;                 // Server they're on\n\tstruct sourceinfo *             si;                     // The source info for logcommand(), bad_password(), and login hooks\n\tvoid *                          mechdata;               // Mechanism-specific allocated memory\n\tchar *                          certfp;                 // TLS client certificate fingerprint (if any)\n\tchar *                          host;                   // Hostname\n\tchar *                          ip;                     // IP address\n\tchar *                          buf;                    // Buffered Base-64 data from them (so far)\n\tsize_t                          len;                    // Length of buffered Base-64 data\n\tunsigned int                    flags;                  // Flags (described above)\n\tchar                            authcid[NICKLEN + 1];   // Authentication identity (user having credentials verified)\n\tchar                            authzid[NICKLEN + 1];   // Authorization identity (user being logged in)\n\tchar                            authceid[IDLEN + 1];    // Entity ID for authcid\n\tchar                            authzeid[IDLEN + 1];    // Entity ID for authzid\n\tchar                            pendingeid[IDLEN + 1];  // Entity ID for pending login (for pre-reg clients)\n\tchar                            uid[UIDLEN + 1];        // Network UID\n};\n\nstruct sasl_sourceinfo\n{\n\tstruct sourceinfo       parent;\n\tstruct sasl_session *   sess;\n};\n\nstruct sasl_message\n{\n\tstruct server * server;\n\tchar *          uid;\n\tchar *          parv[SASL_MESSAGE_MAXPARA];\n\tint             parc;\n\tchar            mode;\n};\n\nstruct sasl_input_buf\n{\n\tconst void *    buf;\n\tconst size_t    len;\n\tunsigned int *  flags;\n};\n\nstruct sasl_output_buf\n{\n\tvoid *          buf;\n\tsize_t          len;\n\tunsigned int    flags;\n};\n\nenum sasl_mechanism_result\n{\n\tASASL_MRESULT_ERROR     = 1,    // An error has occurred in the mechanism, or the client screwed up\n\tASASL_MRESULT_FAILURE   = 2,    // Client supplied invalid credentials; run bad_password() on the target\n\tASASL_MRESULT_CONTINUE  = 3,    // Everything looks good so far, but we need more data from the client\n\tASASL_MRESULT_SUCCESS   = 4,    // The client has successfully authenticated\n};\n\ntypedef enum sasl_mechanism_result (*sasl_mech_start_fn)(struct sasl_session *restrict,\n    struct sasl_output_buf *restrict) ATHEME_FATTR_WUR;\n\ntypedef enum sasl_mechanism_result (*sasl_mech_step_fn)(struct sasl_session *restrict,\n    const struct sasl_input_buf *restrict, struct sasl_output_buf *restrict) ATHEME_FATTR_WUR;\n\ntypedef void (*sasl_mech_finish_fn)(struct sasl_session *);\n\nstruct sasl_mechanism\n{\n\tchar                name[SASL_MECHANISM_MAXLEN];\n\tsasl_mech_start_fn  mech_start;\n\tsasl_mech_step_fn   mech_step;\n\tsasl_mech_finish_fn mech_finish;\n\tbool                password_based;\n};\n\ntypedef bool (*sasl_authxid_can_login_fn)(struct sasl_session *restrict, const char *restrict,\n                                          struct myuser **restrict) ATHEME_FATTR_WUR;\n\nstruct sasl_core_functions\n{\n\tvoid                      (*mech_register)(const struct sasl_mechanism *);\n\tvoid                      (*mech_unregister)(const struct sasl_mechanism *);\n\tsasl_authxid_can_login_fn   authcid_can_login;\n\tsasl_authxid_can_login_fn   authzid_can_login;\n\tvoid                      (*recalc_mechlist)(const struct sasl_session *, const struct myuser *, const char **);\n};\n\n#endif /* !ATHEME_INC_SASL_H */\n", "/*\n * SPDX-License-Identifier: ISC\n * SPDX-URL: https://spdx.org/licenses/ISC.html\n *\n * Copyright (C) 2006-2015 Atheme Project (http://atheme.org/)\n * Copyright (C) 2017-2019 Atheme Development Group (https://atheme.github.io/)\n *\n * This file contains the main() routine.\n */\n\n#include <atheme.h>\n\n#ifndef MINIMUM\n#  define MINIMUM(a, b) (((a) < (b)) ? (a) : (b))\n#endif\n\n#define ASASL_OUTFLAGS_WIPE_FREE_BUF    (ASASL_OUTFLAG_WIPE_BUF | ASASL_OUTFLAG_FREE_BUF)\n#define LOGIN_CANCELLED_STR             \"There was a problem logging you in; login cancelled\"\n\nstatic mowgli_list_t sasl_sessions;\nstatic mowgli_list_t sasl_mechanisms;\nstatic char sasl_mechlist_string[SASL_S2S_MAXLEN_ATONCE_B64];\nstatic bool sasl_hide_server_names;\n\nstatic mowgli_eventloop_timer_t *sasl_delete_stale_timer = NULL;\nstatic struct service *saslsvs = NULL;\n\nstatic const char *\nsasl_format_sourceinfo(struct sourceinfo *const restrict si, const bool full)\n{\n\tstatic char result[BUFSIZE];\n\n\tconst struct sasl_sourceinfo *const ssi = (const struct sasl_sourceinfo *) si;\n\n\tif (full)\n\t\t(void) snprintf(result, sizeof result, \"SASL/%s:%s[%s]:%s\",\n\t\t                *ssi->sess->uid ? ssi->sess->uid : \"?\",\n\t\t                ssi->sess->host ? ssi->sess->host : \"?\",\n\t\t                ssi->sess->ip ? ssi->sess->ip : \"?\",\n\t\t                ssi->sess->server ? ssi->sess->server->name : \"?\");\n\telse\n\t\t(void) snprintf(result, sizeof result, \"SASL(%s)\",\n\t\t                ssi->sess->host ? ssi->sess->host : \"?\");\n\n\treturn result;\n}\n\nstatic const char *\nsasl_get_source_name(struct sourceinfo *const restrict si)\n{\n\tstatic char result[HOSTLEN + 1 + NICKLEN + 11];\n\tchar description[BUFSIZE];\n\n\tconst struct sasl_sourceinfo *const ssi = (const struct sasl_sourceinfo *) si;\n\n\tif (ssi->sess->server && ! sasl_hide_server_names)\n\t\t(void) snprintf(description, sizeof description, \"Unknown user on %s (via SASL)\",\n\t\t                                                 ssi->sess->server->name);\n\telse\n\t\t(void) mowgli_strlcpy(description, \"Unknown user (via SASL)\", sizeof description);\n\n\t// we can reasonably assume that si->v is non-null as this is part of the SASL vtable\n\tif (si->sourcedesc)\n\t\t(void) snprintf(result, sizeof result, \"<%s:%s>%s\", description, si->sourcedesc,\n\t\t                si->smu ? entity(si->smu)->name : \"\");\n\telse\n\t\t(void) snprintf(result, sizeof result, \"<%s>%s\", description, si->smu ? entity(si->smu)->name : \"\");\n\n\treturn result;\n}\n\nstatic void\nsasl_sourceinfo_recreate(struct sasl_session *const restrict p)\n{\n\tstatic struct sourceinfo_vtable sasl_vtable = {\n\n\t\t.description        = \"SASL\",\n\t\t.format             = sasl_format_sourceinfo,\n\t\t.get_source_name    = sasl_get_source_name,\n\t\t.get_source_mask    = sasl_get_source_name,\n\t};\n\n\tif (p->si)\n\t\t(void) atheme_object_unref(p->si);\n\n\tstruct sasl_sourceinfo *const ssi = smalloc(sizeof *ssi);\n\n\t(void) atheme_object_init(atheme_object(ssi), \"<sasl sourceinfo>\", &sfree);\n\n\tssi->parent.s = p->server;\n\tssi->parent.connection = curr_uplink->conn;\n\n\tif (p->host)\n\t\tssi->parent.sourcedesc = p->host;\n\n\tssi->parent.service = saslsvs;\n\tssi->parent.v = &sasl_vtable;\n\n\tssi->parent.force_language = language_find(\"en\");\n\tssi->sess = p;\n\n\tp->si = &ssi->parent;\n}\n\nstatic struct sasl_session *\nsasl_session_find(const char *const restrict uid)\n{\n\tif (! uid || ! *uid)\n\t\treturn NULL;\n\n\tmowgli_node_t *n;\n\n\tMOWGLI_ITER_FOREACH(n, sasl_sessions.head)\n\t{\n\t\tstruct sasl_session *const p = n->data;\n\n\t\tif (strcmp(p->uid, uid) == 0)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sasl_session *\nsasl_session_find_or_make(const struct sasl_message *const restrict smsg)\n{\n\tstruct sasl_session *p;\n\n\tif (! (p = sasl_session_find(smsg->uid)))\n\t{\n\t\tp = smalloc(sizeof *p);\n\n\t\tp->server = smsg->server;\n\n\t\t(void) mowgli_strlcpy(p->uid, smsg->uid, sizeof p->uid);\n\t\t(void) mowgli_node_add(p, &p->node, &sasl_sessions);\n\t}\n\n\treturn p;\n}\n\nstatic const struct sasl_mechanism *\nsasl_mechanism_find(const char *const restrict name)\n{\n\tmowgli_node_t *n;\n\n\tMOWGLI_ITER_FOREACH(n, sasl_mechanisms.head)\n\t{\n\t\tconst struct sasl_mechanism *const mptr = n->data;\n\n\t\tif (strcmp(mptr->name, name) == 0)\n\t\t\treturn mptr;\n\t}\n\n\t(void) slog(LG_DEBUG, \"%s: cannot find mechanism '%s'!\", MOWGLI_FUNC_NAME, name);\n\n\treturn NULL;\n}\n\nstatic void\nsasl_server_eob(struct server ATHEME_VATTR_UNUSED *const restrict s)\n{\n\t(void) sasl_mechlist_sts(sasl_mechlist_string);\n}\n\nstatic void\nsasl_mechlist_string_build(const struct sasl_session *const restrict p, const struct myuser *const restrict mu,\n                           const char **const restrict avoid)\n{\n\tchar buf[sizeof sasl_mechlist_string];\n\tchar *bufptr = buf;\n\tsize_t written = 0;\n\tmowgli_node_t *n;\n\n\t(void) memset(buf, 0x00, sizeof buf);\n\n\tMOWGLI_ITER_FOREACH(n, sasl_mechanisms.head)\n\t{\n\t\tconst struct sasl_mechanism *const mptr = n->data;\n\t\tbool in_avoid_list = false;\n\n\t\tcontinue_if_fail(mptr != NULL);\n\n\t\tfor (size_t i = 0; avoid != NULL && avoid[i] != NULL; i++)\n\t\t{\n\t\t\tif (strcmp(mptr->name, avoid[i]) == 0)\n\t\t\t{\n\t\t\t\tin_avoid_list = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (in_avoid_list || (mptr->password_based && mu != NULL && (mu->flags & MU_NOPASSWORD)))\n\t\t\tcontinue;\n\n\t\tconst size_t namelen = strlen(mptr->name);\n\n\t\tif (written + namelen >= sizeof buf)\n\t\t\tbreak;\n\n\t\t(void) memcpy(bufptr, mptr->name, namelen);\n\n\t\tbufptr += namelen;\n\t\t*bufptr++ = ',';\n\t\twritten += namelen + 1;\n\t}\n\n\tif (written)\n\t\t*(--bufptr) = 0x00;\n\n\tif (p)\n\t\t(void) sasl_sts(p->uid, 'M', buf);\n\telse\n\t\t(void) memcpy(sasl_mechlist_string, buf, sizeof buf);\n}\n\nstatic void\nsasl_mechlist_do_rebuild(void)\n{\n\t(void) sasl_mechlist_string_build(NULL, NULL, NULL);\n\n\tif (me.connected)\n\t\t(void) sasl_mechlist_sts(sasl_mechlist_string);\n}\n\nstatic bool\nsasl_may_impersonate(struct myuser *const source_mu, struct myuser *const target_mu)\n{\n\tif (source_mu == target_mu)\n\t\treturn true;\n\n\tchar priv[BUFSIZE] = PRIV_IMPERSONATE_ANY;\n\n\t// Check for wildcard priv\n\tif (has_priv_myuser(source_mu, priv))\n\t\treturn true;\n\n\t// Check for target-operclass specific priv\n\tconst char *const classname = (target_mu->soper && target_mu->soper->classname) ?\n\t                                  target_mu->soper->classname : \"user\";\n\t(void) snprintf(priv, sizeof priv, PRIV_IMPERSONATE_CLASS_FMT, classname);\n\tif (has_priv_myuser(source_mu, priv))\n\t\treturn true;\n\n\t// Check for target-entity specific priv\n\t(void) snprintf(priv, sizeof priv, PRIV_IMPERSONATE_ENTITY_FMT, entity(target_mu)->name);\n\tif (has_priv_myuser(source_mu, priv))\n\t\treturn true;\n\n\t// Allow modules to check too\n\tstruct hook_sasl_may_impersonate req = {\n\n\t\t.source_mu = source_mu,\n\t\t.target_mu = target_mu,\n\t\t.allowed = false,\n\t};\n\n\t(void) hook_call_sasl_may_impersonate(&req);\n\n\treturn req.allowed;\n}\n\nstatic struct myuser *\nsasl_user_can_login(struct sasl_session *const restrict p)\n{\n\t// source_mu is the user whose credentials we verified (\"authentication id\" / authcid)\n\t// target_mu is the user who will be ultimately logged in (\"authorization id\" / authzid)\n\tstruct myuser *source_mu;\n\tstruct myuser *target_mu;\n\n\tif (! *p->authceid || ! (source_mu = myuser_find_uid(p->authceid)))\n\t\treturn NULL;\n\n\tif (! *p->authzeid)\n\t{\n\t\ttarget_mu = source_mu;\n\n\t\t(void) mowgli_strlcpy(p->authzid, p->authcid, sizeof p->authzid);\n\t\t(void) mowgli_strlcpy(p->authzeid, p->authceid, sizeof p->authzeid);\n\t}\n\telse if (! (target_mu = myuser_find_uid(p->authzeid)))\n\t\treturn NULL;\n\n\tif (! sasl_may_impersonate(source_mu, target_mu))\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\",\n\t\t                                       entity(source_mu)->name, entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif (! (target_mu->flags & MU_LOGINNOLIMIT)\n\t\t&& !has_priv_myuser(target_mu, PRIV_LOGIN_NOLIMIT)\n\t\t&& MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (too many logins)\",\n\t\t                                       entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\t/* We just did SASL authentication for a user.  With IRCds which do not\n\t * have unique UIDs for users, we will likely be expecting the login\n\t * data to be bursted.  As a result, we should give the core a heads'\n\t * up that this is going to happen so that hooks will be properly\n\t * fired...\n\t */\n\tif (ircd->flags & IRCD_SASL_USE_PUID)\n\t{\n\t\ttarget_mu->flags &= ~MU_NOBURSTLOGIN;\n\t\ttarget_mu->flags |= MU_PENDINGLOGIN;\n\t}\n\n\tif (target_mu != source_mu)\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\",\n\t\t                                       entity(source_mu)->name, entity(target_mu)->name);\n\n\treturn target_mu;\n}\n\nstatic void\nsasl_session_destroy(struct sasl_session *const restrict p)\n{\n\tmowgli_node_t *n;\n\n\tMOWGLI_ITER_FOREACH(n, sasl_sessions.head)\n\t{\n\t\tif (n == &p->node && n->data == p)\n\t\t{\n\t\t\t(void) mowgli_node_delete(n, &sasl_sessions);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p->mechptr && p->mechptr->mech_finish)\n\t\t(void) p->mechptr->mech_finish(p);\n\n\tif (p->si)\n\t\t(void) atheme_object_unref(p->si);\n\n\tstruct user *const u = user_find(p->uid);\n\tif (u)\n\t\t// If the user is still on the network, allow them to use NickServ IDENTIFY/LOGIN again\n\t\tu->flags &= ~UF_DOING_SASL;\n\n\t(void) sfree(p->certfp);\n\t(void) sfree(p->host);\n\t(void) sfree(p->buf);\n\t(void) sfree(p->ip);\n\t(void) sfree(p);\n}\n\nstatic inline void\nsasl_session_abort(struct sasl_session *const restrict p)\n{\n\t(void) sasl_sts(p->uid, 'D', \"F\");\n\t(void) sasl_session_destroy(p);\n}\n\nstatic bool\nsasl_session_success(struct sasl_session *const restrict p, struct myuser *const restrict mu, const bool destroy)\n{\n\t/* Only burst an account name and vhost if the user has verified their e-mail address;\n\t * this prevents spambots from creating accounts to join registered-user-only channels\n\t */\n\tif (! (mu->flags & MU_WAITAUTH))\n\t{\n\t\tconst struct metadata *const md = metadata_find(mu, \"private:usercloak\");\n\t\tconst char *const cloak = ((md != NULL) ? md->value : \"*\");\n\n\t\t(void) svslogin_sts(p->uid, \"*\", \"*\", cloak, mu);\n\t}\n\n\t(void) sasl_sts(p->uid, 'D', \"S\");\n\n\tif (destroy)\n\t\t(void) sasl_session_destroy(p);\n\n\treturn true;\n}\n\nstatic bool\nsasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\n\t// Find the account if necessary\n\tif (! mu)\n\t{\n\t\tif (! *p->pendingeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an pendingeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (! (mu = myuser_find_uid(p->pendingeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// If the user is already logged in, and not to the same account, log them out first\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\n\t// If they were not killed above, log them in now\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t// If they're not logged in, or logging in to a different account, do a full login\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Otherwise, just update login time ...\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic enum sasl_mechanism_result ATHEME_FATTR_WUR\nsasl_process_input(struct sasl_session *const restrict p, char *const restrict buf, const size_t len,\n                   struct sasl_output_buf *const restrict outbuf)\n{\n\t// A single + character is not data at all -- invoke mech_step without an input buffer\n\tif (*buf == '+' && len == 1)\n\t\treturn p->mechptr->mech_step(p, NULL, outbuf);\n\n\tunsigned char decbuf[SASL_S2S_MAXLEN_TOTAL_RAW + 1];\n\tconst size_t declen = base64_decode(buf, decbuf, SASL_S2S_MAXLEN_TOTAL_RAW);\n\n\tif (declen == BASE64_FAIL)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: base64_decode() failed\", MOWGLI_FUNC_NAME);\n\t\treturn ASASL_MRESULT_ERROR;\n\t}\n\n\t/* Account for the fact that the client may have sent whitespace; our\n\t * decoder is tolerant of whitespace and will skip over it    -- amdj\n\t */\n\tif (declen == 0)\n\t\treturn p->mechptr->mech_step(p, NULL, outbuf);\n\n\tunsigned int inflags = ASASL_INFLAG_NONE;\n\tconst struct sasl_input_buf inbuf = {\n\t\t.buf    = decbuf,\n\t\t.len    = declen,\n\t\t.flags  = &inflags,\n\t};\n\n\t// Ensure input is NULL-terminated for modules that want to process the data as a string\n\tdecbuf[declen] = 0x00;\n\n\t// Pass the data to the mechanism\n\tconst enum sasl_mechanism_result rc = p->mechptr->mech_step(p, &inbuf, outbuf);\n\n\t// The mechanism instructed us to wipe the input data now that it has been processed\n\tif (inflags & ASASL_INFLAG_WIPE_BUF)\n\t{\n\t\t/* If we got here, the bufferred base64-encoded input data is either in a\n\t\t * dedicated buffer (buf == p->buf && len == p->len) or directly from a\n\t\t * parv[] inside struct sasl_message. Either way buf is mutable.    -- amdj\n\t\t */\n\t\t(void) smemzero(buf, len);          // Erase the base64-encoded input data\n\t\t(void) smemzero(decbuf, declen);    // Erase the base64-decoded input data\n\t}\n\n\treturn rc;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_process_output(struct sasl_session *const restrict p, struct sasl_output_buf *const restrict outbuf)\n{\n\tchar encbuf[SASL_S2S_MAXLEN_TOTAL_B64 + 1];\n\tconst size_t enclen = base64_encode(outbuf->buf, outbuf->len, encbuf, sizeof encbuf);\n\n\tif ((outbuf->flags & ASASL_OUTFLAGS_WIPE_FREE_BUF) == ASASL_OUTFLAGS_WIPE_FREE_BUF)\n\t\t// The mechanism instructed us to wipe and free the output data now that it has been encoded\n\t\t(void) smemzerofree(outbuf->buf, outbuf->len);\n\telse if (outbuf->flags & ASASL_OUTFLAG_WIPE_BUF)\n\t\t// The mechanism instructed us to wipe the output data now that it has been encoded\n\t\t(void) smemzero(outbuf->buf, outbuf->len);\n\telse if (outbuf->flags & ASASL_OUTFLAG_FREE_BUF)\n\t\t// The mechanism instructed us to free the output data now that it has been encoded\n\t\t(void) sfree(outbuf->buf);\n\n\toutbuf->buf = NULL;\n\toutbuf->len = 0;\n\n\tif (enclen == BASE64_FAIL)\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: base64_encode() failed\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\n\tchar *encbufptr = encbuf;\n\tsize_t encbuflast = SASL_S2S_MAXLEN_ATONCE_B64;\n\n\tfor (size_t encbufrem = enclen; encbufrem != 0; /* No action */)\n\t{\n\t\tchar encbufpart[SASL_S2S_MAXLEN_ATONCE_B64 + 1];\n\t\tconst size_t encbufptrlen = MINIMUM(SASL_S2S_MAXLEN_ATONCE_B64, encbufrem);\n\n\t\t(void) memset(encbufpart, 0x00, sizeof encbufpart);\n\t\t(void) memcpy(encbufpart, encbufptr, encbufptrlen);\n\t\t(void) sasl_sts(p->uid, 'C', encbufpart);\n\n\t\t// The mechanism instructed us to wipe the output data now that it has been transmitted\n\t\tif (outbuf->flags & ASASL_OUTFLAG_WIPE_BUF)\n\t\t{\n\t\t\t(void) smemzero(encbufpart, encbufptrlen);\n\t\t\t(void) smemzero(encbufptr, encbufptrlen);\n\t\t}\n\n\t\tencbufptr += encbufptrlen;\n\t\tencbufrem -= encbufptrlen;\n\t\tencbuflast = encbufptrlen;\n\t}\n\n\t/* The end of a packet is indicated by a string not of the maximum length. If the last string\n\t * was the maximum length, send another, empty string, to advance the session.    -- amdj\n\t */\n\tif (encbuflast == SASL_S2S_MAXLEN_ATONCE_B64)\n\t\t(void) sasl_sts(p->uid, 'C', \"+\");\n\n\treturn true;\n}\n\n/* given an entire sasl message, advance session by passing data to mechanism\n * and feeding returned data back to client.\n */\nstatic bool ATHEME_FATTR_WUR\nsasl_process_packet(struct sasl_session *const restrict p, char *const restrict buf, const size_t len)\n{\n\tstruct sasl_output_buf outbuf = {\n\t\t.buf    = NULL,\n\t\t.len    = 0,\n\t\t.flags  = ASASL_OUTFLAG_NONE,\n\t};\n\n\tenum sasl_mechanism_result rc;\n\tbool have_responded = false;\n\n\tif (! p->mechptr && ! len)\n\t{\n\t\t// First piece of data in a session is the name of the SASL mechanism that will be used\n\t\tif (! (p->mechptr = sasl_mechanism_find(buf)))\n\t\t{\n\t\t\t(void) sasl_sts(p->uid, 'M', sasl_mechlist_string);\n\t\t\treturn false;\n\t\t}\n\n\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\tif (p->mechptr->mech_start)\n\t\t\trc = p->mechptr->mech_start(p, &outbuf);\n\t\telse\n\t\t\trc = ASASL_MRESULT_CONTINUE;\n\t}\n\telse if (! p->mechptr)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: session has no mechanism?\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\trc = sasl_process_input(p, buf, len, &outbuf);\n\t}\n\n\tif (outbuf.buf && outbuf.len)\n\t{\n\t\tif (! sasl_process_output(p, &outbuf))\n\t\t\treturn false;\n\n\t\thave_responded = true;\n\t}\n\n\t// Some progress has been made, reset timeout.\n\tp->flags &= ~ASASL_SFLAG_MARKED_FOR_DELETION;\n\n\tswitch (rc)\n\t{\n\t\tcase ASASL_MRESULT_CONTINUE:\n\t\t{\n\t\t\tif (! have_responded)\n\t\t\t\t/* We want more data from the client, but we haven't sent any of our own.\n\t\t\t\t * Send an empty string to advance the session.    -- amdj\n\t\t\t\t */\n\t\t\t\t(void) sasl_sts(p->uid, 'C', \"+\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcase ASASL_MRESULT_SUCCESS:\n\t\t{\n\t\t\tstruct user *const u = user_find(p->uid);\n\t\t\tstruct myuser *const mu = sasl_user_can_login(p);\n\n\t\t\tif (! mu)\n\t\t\t{\n\t\t\t\tif (u)\n\t\t\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t(void) mowgli_strlcpy(p->pendingeid, p->authzeid, sizeof p->pendingeid);\n\n\t\t\t/* If the user is already on the network, attempt to log them in immediately.\n\t\t\t * Otherwise, we will log them in on introduction of user to network\n\t\t\t */\n\t\t\tif (u && ! sasl_handle_login(p, u, mu))\n\t\t\t\treturn false;\n\n\t\t\treturn sasl_session_success(p, mu, (u != NULL));\n\t\t}\n\n\t\tcase ASASL_MRESULT_FAILURE:\n\t\t{\n\t\t\tif (*p->authceid)\n\t\t\t{\n\t\t\t\t/* If we reach this, they failed SASL auth, so if they were trying\n\t\t\t\t * to authenticate as a specific user, run bad_password() on them.\n\t\t\t\t */\n\t\t\t\tstruct myuser *const mu = myuser_find_uid(p->authceid);\n\n\t\t\t\tif (! mu)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* We might have more information to construct a more accurate sourceinfo now?\n\t\t\t\t * TODO: Investigate whether this is necessary\n\t\t\t\t */\n\t\t\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\t\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN (%s) to \\2%s\\2 (bad password)\",\n\t\t\t\t                                       p->mechptr->name, entity(mu)->name);\n\t\t\t\t(void) bad_password(p->si, mu);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tcase ASASL_MRESULT_ERROR:\n\t\t\treturn false;\n\t}\n\n\t/* This is only here to keep GCC happy -- Clang can see that the switch() handles all legal\n\t * values of the enumeration, and so knows that this function will never get to this point;\n\t * GCC is dumb, and warns that control reaches the end of this non-void function.    -- amdj\n\t */\n\treturn false;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_process_buffer(struct sasl_session *const restrict p)\n{\n\t// Ensure the buffer is NULL-terminated so that base64_decode() doesn't overrun it\n\tp->buf[p->len] = 0x00;\n\n\tif (! sasl_process_packet(p, p->buf, p->len))\n\t\treturn false;\n\n\t(void) sfree(p->buf);\n\n\tp->buf = NULL;\n\tp->len = 0;\n\n\treturn true;\n}\n\nstatic void\nsasl_input_hostinfo(const struct sasl_message *const restrict smsg, struct sasl_session *const restrict p)\n{\n\tp->host = sstrdup(smsg->parv[0]);\n\tp->ip   = sstrdup(smsg->parv[1]);\n\n\tif (smsg->parc >= 3 && strcmp(smsg->parv[2], \"P\") != 0)\n\t\tp->flags |= ASASL_SFLAG_CLIENT_SECURE;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_input_startauth(const struct sasl_message *const restrict smsg, struct sasl_session *const restrict p)\n{\n\tif (strcmp(smsg->parv[0], \"EXTERNAL\") == 0)\n\t{\n\t\tif (smsg->parc < 2)\n\t\t{\n\t\t\t(void) slog(LG_DEBUG, \"%s: client %s starting EXTERNAL authentication without a \"\n\t\t\t                      \"fingerprint\", MOWGLI_FUNC_NAME, p->uid);\n\t\t\treturn false;\n\t\t}\n\n\t\t(void) sfree(p->certfp);\n\n\t\tp->certfp = sstrdup(smsg->parv[1]);\n\t\tp->flags |= ASASL_SFLAG_CLIENT_SECURE;\n\t}\n\n\tstruct user *const u = user_find(p->uid);\n\n\tif (u && u->myuser)\n\t{\n\t\t/* If the user is already on the network, they're doing an IRCv3.2 SASL\n\t\t * reauthentication. This means that if the user is logged in, we need\n\t\t * to call the user_can_logout hooks and maybe abort the exchange now.\n\t\t */\n\t\t(void) slog(LG_DEBUG, \"%s: user %s ('%s') is logged in as '%s' -- executing user_can_logout hooks\",\n\t\t                      MOWGLI_FUNC_NAME, p->uid, u->nick, entity(u->myuser)->name);\n\n\t\tstruct hook_user_logout_check req = {\n\t\t\t.si      = p->si,\n\t\t\t.u       = u,\n\t\t\t.allowed = true,\n\t\t\t.relogin = true,\n\t\t};\n\n\t\t(void) hook_call_user_can_logout(&req);\n\n\t\tif (! req.allowed)\n\t\t{\n\t\t\t(void) notice(saslsvs->nick, u->nick,\n\t\t\t              \"You cannot log out \\2%s\\2 because the server configuration disallows it.\",\n\t\t\t              entity(u->myuser)->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (u)\n\t\tu->flags |= UF_DOING_SASL;\n\n\treturn sasl_process_packet(p, smsg->parv[0], 0);\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_input_clientdata(const struct sasl_message *const restrict smsg, struct sasl_session *const restrict p)\n{\n\t/* This is complicated.\n\t *\n\t * Clients are restricted to sending us 300 bytes (400 Base-64 characters), but the mechanism\n\t * that they have chosen could require them to send more than this amount, so they have to send\n\t * it 400 Base-64 characters at a time in stages. When we receive data less than 400 characters,\n\t * we know we don't need to buffer any more data, and can finally process it.\n\t *\n\t * However, if the client wants to send us a multiple of 400 characters and no more, we would be\n\t * waiting forever for them to send 'the rest', even though there isn't any. This is solved by\n\t * having them send a single '+' character to indicate that they have no more data to send.\n\t *\n\t * This is also what clients send us when they do not want to send us any data at all, and in\n\t * either event, this is *NOT* *DATA* we are receiving, and we should not buffer it.\n\t *\n\t * Also, if the data is a single '*' character, the client is aborting authentication. Servers\n\t * should send us a 'D' packet instead of a 'C *' packet in this case, but this is for if they\n\t * don't. Note that this will usually result in the client getting a 904 numeric instead of 906,\n\t * but the alternative is not treating '*' specially and then going on to fail to decode it in\n\t * sasl_process_input() above, which will result in ... an aborted session and a 904 numeric.\n\t * So this just saves time.\n\t */\n\n\tconst size_t len = strlen(smsg->parv[0]);\n\n\t// Abort?\n\tif (len == 1 && smsg->parv[0][0] == '*')\n\t\treturn false;\n\n\t// End of data?\n\tif (len == 1 && smsg->parv[0][0] == '+')\n\t{\n\t\tif (p->buf)\n\t\t\treturn sasl_process_buffer(p);\n\n\t\t// This function already deals with the special case of 1 '+' character\n\t\treturn sasl_process_packet(p, smsg->parv[0], len);\n\t}\n\n\t/* Optimisation: If there is no buffer yet and this data is less than 400 characters, we don't\n\t * need to buffer it at all, and can process it immediately.\n\t */\n\tif (! p->buf && len < SASL_S2S_MAXLEN_ATONCE_B64)\n\t\treturn sasl_process_packet(p, smsg->parv[0], len);\n\n\t/* We need to buffer the data now, but first check if the client hasn't sent us an excessive\n\t * amount already.\n\t */\n\tif ((p->len + len) > SASL_S2S_MAXLEN_TOTAL_B64)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: client %s has exceeded allowed data length\", MOWGLI_FUNC_NAME, p->uid);\n\t\treturn false;\n\t}\n\n\t// (Re)allocate a buffer, append the received data to it, and update its recorded length.\n\tp->buf = srealloc(p->buf, p->len + len + 1);\n\t(void) memcpy(p->buf + p->len, smsg->parv[0], len);\n\tp->len += len;\n\n\t// Messages not exactly 400 characters are the end of data.\n\tif (len < SASL_S2S_MAXLEN_ATONCE_B64)\n\t\treturn sasl_process_buffer(p);\n\n\treturn true;\n}\n\nstatic void\nsasl_input(struct sasl_message *const restrict smsg)\n{\n\tstruct sasl_session *const p = sasl_session_find_or_make(smsg);\n\n\tbool ret = true;\n\n\tswitch (smsg->mode)\n\t{\n\t\tcase 'H':\n\t\t\t// (H)ost information\n\t\t\t(void) sasl_input_hostinfo(smsg, p);\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t// (S)tart authentication\n\t\t\tret = sasl_input_startauth(smsg, p);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\t// (C)lient data\n\t\t\tret = sasl_input_clientdata(smsg, p);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\t// (D)one -- when we receive it, means client abort\n\t\t\t(void) sasl_session_destroy(p);\n\t\t\tbreak;\n\t}\n\n\tif (! ret)\n\t\t(void) sasl_session_abort(p);\n}\n\nstatic void\nsasl_user_add(struct hook_user_nick *const restrict data)\n{\n\t// If the user has been killed, don't do anything.\n\tstruct user *const u = data->u;\n\tif (! u)\n\t\treturn;\n\n\t// Not concerned unless it's an SASL login.\n\tstruct sasl_session *const p = sasl_session_find(u->uid);\n\tif (! p)\n\t\treturn;\n\n\t(void) sasl_handle_login(p, u, NULL);\n\t(void) sasl_session_destroy(p);\n}\n\nstatic void\nsasl_delete_stale(void ATHEME_VATTR_UNUSED *const restrict vptr)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, sasl_sessions.head)\n\t{\n\t\tstruct sasl_session *const p = n->data;\n\n\t\tif (p->flags & ASASL_SFLAG_MARKED_FOR_DELETION)\n\t\t\t(void) sasl_session_destroy(p);\n\t\telse\n\t\t\tp->flags |= ASASL_SFLAG_MARKED_FOR_DELETION;\n\t}\n}\n\nstatic void\nsasl_mech_register(const struct sasl_mechanism *const restrict mech)\n{\n\tif (sasl_mechanism_find(mech->name))\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: ignoring attempt to register %s again\", MOWGLI_FUNC_NAME, mech->name);\n\t\treturn;\n\t}\n\n\t(void) slog(LG_DEBUG, \"%s: registering %s\", MOWGLI_FUNC_NAME, mech->name);\n\n\tmowgli_node_t *const node = mowgli_node_create();\n\n\tif (! node)\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: mowgli_node_create() failed; out of memory?\", MOWGLI_FUNC_NAME);\n\t\treturn;\n\t}\n\n\t/* Here we cast it to (void *) because mowgli_node_add() expects that; it cannot be made const because then\n\t * it would have to return a (const void *) too which would cause multiple warnings any time it is actually\n\t * storing, and thus gets assigned to, a pointer to a mutable object.\n\t *\n\t * To avoid the cast generating a diagnostic due to dropping a const qualifier, we first cast to uintptr_t.\n\t * This is not unprecedented in this codebase; libathemecore/crypto.c & libathemecore/strshare.c do the\n\t * same thing.\n\t */\n\t(void) mowgli_node_add((void *)((uintptr_t) mech), node, &sasl_mechanisms);\n\n\t(void) sasl_mechlist_do_rebuild();\n}\n\nstatic void\nsasl_mech_unregister(const struct sasl_mechanism *const restrict mech)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, sasl_sessions.head)\n\t{\n\t\tstruct sasl_session *const session = n->data;\n\n\t\tif (session->mechptr == mech)\n\t\t{\n\t\t\t(void) slog(LG_DEBUG, \"%s: destroying session %s\", MOWGLI_FUNC_NAME, session->uid);\n\t\t\t(void) sasl_session_destroy(session);\n\t\t}\n\t}\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, sasl_mechanisms.head)\n\t{\n\t\tif (n->data == mech)\n\t\t{\n\t\t\t(void) slog(LG_DEBUG, \"%s: unregistering %s\", MOWGLI_FUNC_NAME, mech->name);\n\t\t\t(void) mowgli_node_delete(n, &sasl_mechanisms);\n\t\t\t(void) mowgli_node_free(n);\n\t\t\t(void) sasl_mechlist_do_rebuild();\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline bool ATHEME_FATTR_WUR\nsasl_authxid_can_login(struct sasl_session *const restrict p, const char *const restrict authxid,\n                       struct myuser **const restrict muo, char *const restrict val_name,\n                       char *const restrict val_eid, const char *const restrict other_val_eid)\n{\n\treturn_val_if_fail(p != NULL, false);\n\treturn_val_if_fail(p->si != NULL, false);\n\treturn_val_if_fail(p->mechptr != NULL, false);\n\n\tstruct myuser *const mu = myuser_find_by_nick(authxid);\n\n\tif (! mu)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: myuser_find_by_nick: does not exist\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\tif (metadata_find(mu, \"private:freeze:freezer\"))\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(mu)->name);\n\t\treturn false;\n\t}\n\n\tif (muo)\n\t\t*muo = mu;\n\n\t(void) mowgli_strlcpy(val_name, entity(mu)->name, NICKLEN + 1);\n\t(void) mowgli_strlcpy(val_eid, entity(mu)->id, IDLEN + 1);\n\n\tif (p->mechptr->password_based && (mu->flags & MU_NOPASSWORD))\n\t{\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN %s to \\2%s\\2 (password authentication disabled)\",\n\t\t                  p->mechptr->name, entity(mu)->name);\n\n\t\treturn false;\n\t}\n\n\tif (strcmp(val_eid, other_val_eid) == 0)\n\t\t// We have already executed the user_can_login hook for this user\n\t\treturn true;\n\n\tstruct hook_user_login_check req = {\n\n\t\t.si         = p->si,\n\t\t.mu         = mu,\n\t\t.allowed    = true,\n\t};\n\n\t(void) hook_call_user_can_login(&req);\n\n\tif (! req.allowed)\n\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(mu)->name);\n\n\treturn req.allowed;\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_authcid_can_login(struct sasl_session *const restrict p, const char *const restrict authcid,\n                       struct myuser **const restrict muo)\n{\n\treturn sasl_authxid_can_login(p, authcid, muo, p->authcid, p->authceid, p->authzeid);\n}\n\nstatic bool ATHEME_FATTR_WUR\nsasl_authzid_can_login(struct sasl_session *const restrict p, const char *const restrict authzid,\n                       struct myuser **const restrict muo)\n{\n\treturn sasl_authxid_can_login(p, authzid, muo, p->authzid, p->authzeid, p->authceid);\n}\n\nextern const struct sasl_core_functions sasl_core_functions;\nconst struct sasl_core_functions sasl_core_functions = {\n\n\t.mech_register      = &sasl_mech_register,\n\t.mech_unregister    = &sasl_mech_unregister,\n\t.authcid_can_login  = &sasl_authcid_can_login,\n\t.authzid_can_login  = &sasl_authzid_can_login,\n\t.recalc_mechlist    = &sasl_mechlist_string_build,\n};\n\nstatic void\nsaslserv_message_handler(struct sourceinfo *const restrict si, const int parc, char **const restrict parv)\n{\n\t// this should never happen\n\tif (parv[0][0] == '&')\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: got parv with local channel: %s\", MOWGLI_FUNC_NAME, parv[0]);\n\t\treturn;\n\t}\n\n\t// make a copy of the original for debugging\n\tchar orig[BUFSIZE];\n\t(void) mowgli_strlcpy(orig, parv[parc - 1], sizeof orig);\n\n\t// lets go through this to get the command\n\tchar *const cmd = strtok(parv[parc - 1], \" \");\n\tchar *const text = strtok(NULL, \"\");\n\n\tif (! cmd)\n\t\treturn;\n\n\tif (*orig == '\\001')\n\t{\n\t\t(void) handle_ctcp_common(si, cmd, text);\n\t\treturn;\n\t}\n\n\t(void) command_fail(si, fault_noprivs, _(\"This service exists to identify connecting clients \"\n\t                                         \"to the network. It has no public interface.\"));\n}\n\nstatic void\nmod_init(struct module *const restrict m)\n{\n\tif (! (saslsvs = service_add(\"saslserv\", &saslserv_message_handler)))\n\t{\n\t\t(void) slog(LG_ERROR, \"%s: service_add() failed\", m->name);\n\t\tm->mflags |= MODFLAG_FAIL;\n\t\treturn;\n\t}\n\n\t(void) hook_add_sasl_input(&sasl_input);\n\t(void) hook_add_user_add(&sasl_user_add);\n\t(void) hook_add_server_eob(&sasl_server_eob);\n\n\tsasl_delete_stale_timer = mowgli_timer_add(base_eventloop, \"sasl_delete_stale\", &sasl_delete_stale, NULL, SECONDS_PER_MINUTE / 2);\n\tauthservice_loaded++;\n\n\t(void) add_bool_conf_item(\"HIDE_SERVER_NAMES\", &saslsvs->conf_table, 0, &sasl_hide_server_names, false);\n}\n\nstatic void\nmod_deinit(const enum module_unload_intent ATHEME_VATTR_UNUSED intent)\n{\n\t(void) hook_del_sasl_input(&sasl_input);\n\t(void) hook_del_user_add(&sasl_user_add);\n\t(void) hook_del_server_eob(&sasl_server_eob);\n\n\t(void) mowgli_timer_destroy(base_eventloop, sasl_delete_stale_timer);\n\n\t(void) del_conf_item(\"HIDE_SERVER_NAMES\", &saslsvs->conf_table);\n\t(void) service_delete(saslsvs);\n\n\tauthservice_loaded--;\n\n\tif (sasl_sessions.head)\n\t\t(void) slog(LG_ERROR, \"saslserv/main: shutting down with a non-empty session list; \"\n\t\t                      \"a mechanism did not unregister itself! (BUG)\");\n}\n\nSIMPLE_DECLARE_MODULE_V1(\"saslserv/main\", MODULE_UNLOAD_CAPABILITY_OK)\n"], "filenames": ["include/atheme/sasl.h", "modules/saslserv/main.c"], "buggy_code_start_loc": [64, 388], "buggy_code_end_loc": [64, 639], "fixing_code_start_loc": [65, 388], "fixing_code_end_loc": [66, 642], "type": "CWE-287", "message": "Atheme IRC Services before 7.2.12, when used in conjunction with InspIRCd, allows authentication bypass by ending an IRC handshake at a certain point during a challenge-response login sequence.", "other": {"cve": {"id": "CVE-2022-24976", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-14T12:15:27.680", "lastModified": "2022-02-23T15:51:09.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Atheme IRC Services before 7.2.12, when used in conjunction with InspIRCd, allows authentication bypass by ending an IRC handshake at a certain point during a challenge-response login sequence."}, {"lang": "es", "value": "Atheme IRC Services versiones anteriores a 7.2.12, cuando es usado en conjunto con InspIRCd, permite omitir la autenticaci\u00f3n al terminar un handshake de IRC en un punto determinado durante una secuencia de inicio de sesi\u00f3n de desaf\u00edo-respuesta"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:atheme:atheme:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.2.0", "versionEndExcluding": "7.2.12", "matchCriteriaId": "2DE6E0F0-71DB-47CA-894E-07B39BD488D2"}]}]}], "references": [{"url": "https://github.com/atheme/atheme/commit/4e664c75d0b280a052eb8b5e81aa41944e593c52", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/atheme/atheme/compare/v7.2.11...v7.2.12", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/01/30/4", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/atheme/atheme/commit/4e664c75d0b280a052eb8b5e81aa41944e593c52"}}