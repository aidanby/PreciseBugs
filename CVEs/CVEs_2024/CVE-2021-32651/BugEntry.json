{"buggy_code": ["package io.onedev.server.plugin.authenticator.ldap;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.List;\n\nimport javax.annotation.Nullable;\nimport javax.naming.AuthenticationException;\nimport javax.naming.CompositeName;\nimport javax.naming.Context;\nimport javax.naming.InvalidNameException;\nimport javax.naming.Name;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.PartialResultException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.validation.constraints.NotNull;\n\nimport org.apache.shiro.authc.AccountException;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.hibernate.validator.constraints.NotEmpty;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.server.model.support.administration.authenticator.Authenticated;\nimport io.onedev.server.model.support.administration.authenticator.Authenticator;\nimport io.onedev.server.web.editable.annotation.Editable;\nimport io.onedev.server.web.editable.annotation.Password;\n\n@Editable(name=\"Generic LDAP\", order=200)\npublic class LdapAuthenticator extends Authenticator {\n\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate static final Logger logger  = LoggerFactory.getLogger(LdapAuthenticator.class);\n\n\tprivate String ldapUrl;\n\t\n    private String managerDN;\n    \n    private String managerPassword;\n    \n    private String userSearchBase;\n    \n    private String userSearchFilter;\n    \n    private String userFullNameAttribute = \"displayName\";\n    \n    private String userEmailAttribute = \"mail\";\n    \n    private String userSshKeyAttribute;\n    \n    private GroupRetrieval groupRetrieval = new DoNotRetrieveGroups();\n    \n    @Editable(order=100, name=\"LDAP URL\", description=\n        \t\"Specifies LDAP URL, for example: <i>ldap://localhost</i>, or <i>ldaps://localhost</i>.\")\n    @NotEmpty\n\tpublic String getLdapUrl() {\n\t\treturn ldapUrl;\n\t}\n\n\tpublic void setLdapUrl(String ldapUrl) {\n\t\tthis.ldapUrl = ldapUrl;\n\t}\n\n\t@Editable(order=300, description=\"\"\n\t\t\t+ \"To authenticate user against LDAP and retrieve associated attributes and groups, OneDev would have to \"\n\t\t\t+ \"first authenticate itself against the LDAP server and OneDev does that by sending 'manager' DN and \"\n\t\t\t+ \"password\")\n\t@NotEmpty\n\tpublic String getManagerDN() {\n\t\treturn managerDN;\n\t}\n\n\tpublic void setManagerDN(String managerDN) {\n\t\tthis.managerDN = managerDN;\n\t}\n\n\t@Editable(order=400, description=\"Specifies password of above manager DN\")\n\t@NotEmpty\n\t@Password\n\tpublic String getManagerPassword() {\n\t\treturn managerPassword;\n\t}\n\n\tpublic void setManagerPassword(String managerPassword) {\n\t\tthis.managerPassword = managerPassword;\n\t}\n\n\t@Editable(order=500, description=\n\t\t\t\"Specifies the base node for user search. For example: <i>ou=users, dc=example, dc=com</i>\")\n\t@NotEmpty\n\tpublic String getUserSearchBase() {\n\t\treturn userSearchBase;\n\t}\n\n\tpublic void setUserSearchBase(String userSearchBase) {\n\t\tthis.userSearchBase = userSearchBase;\n\t}\n\n\t@Editable(order=600, description=\n\t\t     \"This filter is used to determine the LDAP entry for current user. \" + \n\t\t     \"For example: <i>(&(uid={0})(objectclass=person))</i>. In this example, \" +\n\t\t     \"<i>{0}</i> represents login name of current user.\")\n\t@NotEmpty\n\tpublic String getUserSearchFilter() {\n\t\treturn userSearchFilter;\n\t}\n\n\tpublic void setUserSearchFilter(String userSearchFilter) {\n\t\tthis.userSearchFilter = userSearchFilter;\n\t}\n\n\t@Editable(order=700, description=\"\"\n\t\t\t+ \"Optionally specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"\n\t\t\t+ \"full name. This field is normally set to <i>displayName</i> according to RFC 2798. If left empty, full \"\n\t\t\t+ \"name of the user will not be retrieved\")\n\tpublic String getUserFullNameAttribute() {\n\t\treturn userFullNameAttribute;\n\t}\n\n\tpublic void setUserFullNameAttribute(String userFullNameAttribute) {\n\t\tthis.userFullNameAttribute = userFullNameAttribute;\n\t}\n\n\t@Editable(order=800, description=\"\"\n\t\t\t+ \"Specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"\n\t\t\t+ \"email. This field is normally set to <i>mail</i> according to RFC 2798\")\n\t@NotEmpty\n\tpublic String getUserEmailAttribute() {\n\t\treturn userEmailAttribute;\n\t}\n\n\tpublic void setUserEmailAttribute(String userEmailAttribute) {\n\t\tthis.userEmailAttribute = userEmailAttribute;\n\t}\n\n\t@Editable(name=\"User SSH Key Attribute\", order=850, description=\"\"\n\t\t\t+ \"Optionally specify name of the attribute inside the user LDAP entry whose values will be taken as user \"\n\t\t\t+ \"SSH keys. SSH keys will be managed by LDAP only if this field is set\")\n\tpublic String getUserSshKeyAttribute() {\n\t\treturn userSshKeyAttribute;\n\t}\n\n\tpublic void setUserSshKeyAttribute(String userSshKeyAttribute) {\n\t\tthis.userSshKeyAttribute = userSshKeyAttribute;\n\t}\n\n\t@Editable(order=900, description=\"Specify the strategy to retrieve group membership information. \"\n\t\t\t+ \"To give appropriate permissions to a LDAP group, a OneDev group with same name should \"\n\t\t\t+ \"be defined. Use strategy <tt>Do Not Retrieve Groups</tt> if you want to manage group \"\n\t\t\t+ \"memberships at OneDev side\")\n\t@NotNull(message=\"may not be empty\")\n\tpublic GroupRetrieval getGroupRetrieval() {\n\t\treturn groupRetrieval;\n\t}\n\n\tpublic void setGroupRetrieval(GroupRetrieval groupRetrieval) {\n\t\tthis.groupRetrieval = groupRetrieval;\n\t}\n\n\t@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\", token.getUsername());\n        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");\n        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);\n        \n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n        \n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n        \n        attributeNames.add(getUserEmailAttribute());\n        \n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \"follow\");\n        \n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore()) \n                throw new UnknownAccountException(\"Unknown account\");\n            \n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"//\"));\n                buffer.append(\"//\");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \"//\"), \"/\"));\n                \n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\"ldap\")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \"//\");\n            \tuserDN = StringUtils.substringAfter(userDN, \"/\");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n            \n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n                \n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n                \n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) \n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n                \n                if (getUserSshKeyAttribute() != null) \n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n            \n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter) \n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n            \n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\"Email is required but not available in ldap directory\");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}\n\t\n\tprivate Collection<String> retrieveGroupsByAttribute(DirContext ctx, DirContext referralCtx, \n\t\t\tAttributes searchResultAttributes) {\n\t\tCollection<String> groupNames = new HashSet<>();\n\t\ttry {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute) getGroupRetrieval();\n            Attribute attribute = searchResultAttributes.get(groupRetrieval.getUserGroupsAttribute());\n            if (attribute != null) {\n                for (NamingEnumeration<?> e = attribute.getAll(); e.hasMore();) {\n\n                \t// use composite name instead of DN according to\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4307193\n                    Name groupDN = new CompositeName().add((String) e.next());\n                    logger.debug(\"Looking up group entry '\" + groupDN + \"'...\");\n                    \n                    DirContext groupCtx = null;\n                    try {\n                        if (referralCtx != null)\n                            groupCtx = (DirContext) referralCtx.lookup(groupDN);\n                        else\n                            groupCtx = (DirContext) ctx.lookup(groupDN);\n\n                        if (groupCtx == null) {\n                            throw new RuntimeException(\"Can not find group entry \" +\n                            \t\t\"identified by '\" + groupDN + \"'.\");\n                        }\n                        String groupNameAttribute = groupRetrieval.getGroupNameAttribute();\n                        Attributes groupAttributes = groupCtx.getAttributes(\"\", \n                        \t\tnew String[]{groupNameAttribute});\n                        if (groupAttributes == null \n                        \t\t|| groupAttributes.get(groupNameAttribute) == null\n                                || groupAttributes.get(groupNameAttribute).get() == null) {\n                            throw new RuntimeException(\"Can not find attribute '\" \n                            \t\t+ groupNameAttribute + \"' in returned group entry.\");\n                        }\n                        groupNames.add((String) groupAttributes.get(groupNameAttribute).get());\n                    } finally {\n                        if (groupCtx != null) {\n                            try {\n                                groupCtx.close();\n                            } catch (NamingException ne) {\n                            }\n                        }\n                    }\n                }\n            } else {\n                logger.warn(\"No attribute identified by '\" + groupRetrieval.getUserGroupsAttribute() \n                \t\t+ \"' inside fetched user LDAP entry.\");\n            }\n\t\t} catch (NamingException e) {\n\t\t\tlogger.error(\"Error retrieving groups by attribute\");\n\t\t}\n\t\treturn groupNames;\n\t}\n\t\n\tprivate Collection<String> retrieveGroupsByFilter(DirContext ctx, DirContext referralCtx, String userDN) {\n\t\tCollection<String> groupNames = new HashSet<>();\n\t\ttry {\n\t    \tSearchGroupsUsingFilter groupRetrieval = (SearchGroupsUsingFilter) getGroupRetrieval();\n\t    \tString groupNameAttribute = groupRetrieval.getGroupNameAttribute();\n\t        Name groupSearchBase = new CompositeName().add(groupRetrieval.getGroupSearchBase());\n\t        String groupSearchFilter = StringUtils.replace(groupRetrieval.getGroupSearchFilter(), \"{0}\", userDN);\n\t        groupSearchFilter = StringUtils.replace(groupSearchFilter, \"\\\\\", \"\\\\\\\\\");\n\t\n\t        logger.debug(\"Evaluated group search filter: \" + groupSearchFilter);\n\t        SearchControls searchControls = new SearchControls();\n\t        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\t        searchControls.setReturningAttributes(new String[]{groupNameAttribute});\n\t        searchControls.setReturningObjFlag(true);\n\t\n\t    \tNamingEnumeration<SearchResult> results;\n\t        if (referralCtx != null)\n\t            results = referralCtx.search(groupSearchBase, groupSearchFilter, searchControls);\n\t        else\n\t            results = ctx.search(groupSearchBase, groupSearchFilter, searchControls);\n\t        if (results != null) {\n\t            while (results.hasMore()) {\n\t            \tSearchResult searchResult = (SearchResult) results.next();\n\t                Attributes searchResultAttributes = searchResult.getAttributes();\n\t                if (searchResultAttributes == null \n\t                \t\t|| searchResultAttributes.get(groupNameAttribute) == null\n\t                        || searchResultAttributes.get(groupNameAttribute).get() == null) {\n\t                    throw new RuntimeException(\"Can not find attribute '\" \n\t                    \t\t+ groupNameAttribute + \"' in the returned group object.\");\n\t                }\n\t                groupNames.add((String) searchResultAttributes.get(groupNameAttribute).get());\n\t            }\n\t        }\n        } catch (PartialResultException pre) {\n            logger.warn(\"Partial exception detected. You may try to set property \" +\n            \t\t\"'follow referrals' to true to avoid this exception.\", pre);\n\t\t} catch (NamingException e) {\n\t\t\tlogger.error(\"Error retrieving groups by filter\", e);\n\t\t}\n\t\treturn groupNames;\n\t}\n\n\t@Nullable\n\tprivate Collection<String> retrieveSshKeys(Attributes searchResultAttributes) {\n\t\tAttribute attribute = searchResultAttributes.get(getUserSshKeyAttribute());\n\t\tif (attribute != null) {\n\t\t\tCollection<String> sshKeys = new ArrayList<>();\n\t\t\ttry {\n\t\t\t\tNamingEnumeration<?> ldapValues = attribute.getAll();\n\t\t\t\twhile (ldapValues.hasMore()) {\n\t\t\t\t\tObject value = ldapValues.next();\n\t\t\t\t\tif (value instanceof String) \n\t\t\t\t\t\tsshKeys.add((String) value);\n\t\t\t\t\telse \n\t\t\t\t\t\tlogger.error(\"SSH key from ldap is not a String\");\n\t\t\t\t}\n\n\t\t\t} catch (NamingException e) {\n\t\t\t\tlogger.error(\"Error retrieving SSH keys\", e);\n\t\t\t}\n\t\t\treturn sshKeys;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isManagingMemberships() {\n\t\treturn !(getGroupRetrieval() instanceof DoNotRetrieveGroups);\n\t}\n\n\t@Override\n\tpublic boolean isManagingSshKeys() {\n\t\treturn getUserSshKeyAttribute() != null;\n\t}\n\t\n}\n"], "fixing_code": ["package io.onedev.server.plugin.authenticator.ldap;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.List;\n\nimport javax.annotation.Nullable;\nimport javax.naming.AuthenticationException;\nimport javax.naming.CompositeName;\nimport javax.naming.Context;\nimport javax.naming.InvalidNameException;\nimport javax.naming.Name;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.PartialResultException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.validation.constraints.NotNull;\n\nimport org.apache.shiro.authc.AccountException;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.hibernate.validator.constraints.NotEmpty;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.server.model.support.administration.authenticator.Authenticated;\nimport io.onedev.server.model.support.administration.authenticator.Authenticator;\nimport io.onedev.server.web.editable.annotation.Editable;\nimport io.onedev.server.web.editable.annotation.Password;\n\n@Editable(name=\"Generic LDAP\", order=200)\npublic class LdapAuthenticator extends Authenticator {\n\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate static final Logger logger  = LoggerFactory.getLogger(LdapAuthenticator.class);\n\n\tprivate String ldapUrl;\n\t\n    private String managerDN;\n    \n    private String managerPassword;\n    \n    private String userSearchBase;\n    \n    private String userSearchFilter;\n    \n    private String userFullNameAttribute = \"displayName\";\n    \n    private String userEmailAttribute = \"mail\";\n    \n    private String userSshKeyAttribute;\n    \n    private GroupRetrieval groupRetrieval = new DoNotRetrieveGroups();\n    \n    @Editable(order=100, name=\"LDAP URL\", description=\n        \t\"Specifies LDAP URL, for example: <i>ldap://localhost</i>, or <i>ldaps://localhost</i>.\")\n    @NotEmpty\n\tpublic String getLdapUrl() {\n\t\treturn ldapUrl;\n\t}\n\n\tpublic void setLdapUrl(String ldapUrl) {\n\t\tthis.ldapUrl = ldapUrl;\n\t}\n\n\t@Editable(order=300, description=\"\"\n\t\t\t+ \"To authenticate user against LDAP and retrieve associated attributes and groups, OneDev would have to \"\n\t\t\t+ \"first authenticate itself against the LDAP server and OneDev does that by sending 'manager' DN and \"\n\t\t\t+ \"password\")\n\t@NotEmpty\n\tpublic String getManagerDN() {\n\t\treturn managerDN;\n\t}\n\n\tpublic void setManagerDN(String managerDN) {\n\t\tthis.managerDN = managerDN;\n\t}\n\n\t@Editable(order=400, description=\"Specifies password of above manager DN\")\n\t@NotEmpty\n\t@Password\n\tpublic String getManagerPassword() {\n\t\treturn managerPassword;\n\t}\n\n\tpublic void setManagerPassword(String managerPassword) {\n\t\tthis.managerPassword = managerPassword;\n\t}\n\n\t@Editable(order=500, description=\n\t\t\t\"Specifies the base node for user search. For example: <i>ou=users, dc=example, dc=com</i>\")\n\t@NotEmpty\n\tpublic String getUserSearchBase() {\n\t\treturn userSearchBase;\n\t}\n\n\tpublic void setUserSearchBase(String userSearchBase) {\n\t\tthis.userSearchBase = userSearchBase;\n\t}\n\n\t@Editable(order=600, description=\n\t\t     \"This filter is used to determine the LDAP entry for current user. \" + \n\t\t     \"For example: <i>(&(uid={0})(objectclass=person))</i>. In this example, \" +\n\t\t     \"<i>{0}</i> represents login name of current user.\")\n\t@NotEmpty\n\tpublic String getUserSearchFilter() {\n\t\treturn userSearchFilter;\n\t}\n\n\tpublic void setUserSearchFilter(String userSearchFilter) {\n\t\tthis.userSearchFilter = userSearchFilter;\n\t}\n\n\t@Editable(order=700, description=\"\"\n\t\t\t+ \"Optionally specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"\n\t\t\t+ \"full name. This field is normally set to <i>displayName</i> according to RFC 2798. If left empty, full \"\n\t\t\t+ \"name of the user will not be retrieved\")\n\tpublic String getUserFullNameAttribute() {\n\t\treturn userFullNameAttribute;\n\t}\n\n\tpublic void setUserFullNameAttribute(String userFullNameAttribute) {\n\t\tthis.userFullNameAttribute = userFullNameAttribute;\n\t}\n\n\t@Editable(order=800, description=\"\"\n\t\t\t+ \"Specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"\n\t\t\t+ \"email. This field is normally set to <i>mail</i> according to RFC 2798\")\n\t@NotEmpty\n\tpublic String getUserEmailAttribute() {\n\t\treturn userEmailAttribute;\n\t}\n\n\tpublic void setUserEmailAttribute(String userEmailAttribute) {\n\t\tthis.userEmailAttribute = userEmailAttribute;\n\t}\n\n\t@Editable(name=\"User SSH Key Attribute\", order=850, description=\"\"\n\t\t\t+ \"Optionally specify name of the attribute inside the user LDAP entry whose values will be taken as user \"\n\t\t\t+ \"SSH keys. SSH keys will be managed by LDAP only if this field is set\")\n\tpublic String getUserSshKeyAttribute() {\n\t\treturn userSshKeyAttribute;\n\t}\n\n\tpublic void setUserSshKeyAttribute(String userSshKeyAttribute) {\n\t\tthis.userSshKeyAttribute = userSshKeyAttribute;\n\t}\n\n\t@Editable(order=900, description=\"Specify the strategy to retrieve group membership information. \"\n\t\t\t+ \"To give appropriate permissions to a LDAP group, a OneDev group with same name should \"\n\t\t\t+ \"be defined. Use strategy <tt>Do Not Retrieve Groups</tt> if you want to manage group \"\n\t\t\t+ \"memberships at OneDev side\")\n\t@NotNull(message=\"may not be empty\")\n\tpublic GroupRetrieval getGroupRetrieval() {\n\t\treturn groupRetrieval;\n\t}\n\n\tpublic void setGroupRetrieval(GroupRetrieval groupRetrieval) {\n\t\tthis.groupRetrieval = groupRetrieval;\n\t}\n\n\t@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\", \n        \t\tescape(token.getUsername()));\n        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");\n        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);\n        \n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n        \n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n        \n        attributeNames.add(getUserEmailAttribute());\n        \n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \"follow\");\n        \n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore()) \n                throw new UnknownAccountException(\"Unknown account\");\n            \n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"//\"));\n                buffer.append(\"//\");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \"//\"), \"/\"));\n                \n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\"ldap\")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \"//\");\n            \tuserDN = StringUtils.substringAfter(userDN, \"/\");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n            \n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n                \n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n                \n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) \n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n                \n                if (getUserSshKeyAttribute() != null) \n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n            \n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter) \n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n            \n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\"Email is required but not available in ldap directory\");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}\n\t\n\tprivate Collection<String> retrieveGroupsByAttribute(DirContext ctx, DirContext referralCtx, \n\t\t\tAttributes searchResultAttributes) {\n\t\tCollection<String> groupNames = new HashSet<>();\n\t\ttry {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute) getGroupRetrieval();\n            Attribute attribute = searchResultAttributes.get(groupRetrieval.getUserGroupsAttribute());\n            if (attribute != null) {\n                for (NamingEnumeration<?> e = attribute.getAll(); e.hasMore();) {\n\n                \t// use composite name instead of DN according to\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4307193\n                    Name groupDN = new CompositeName().add((String) e.next());\n                    logger.debug(\"Looking up group entry '\" + groupDN + \"'...\");\n                    \n                    DirContext groupCtx = null;\n                    try {\n                        if (referralCtx != null)\n                            groupCtx = (DirContext) referralCtx.lookup(groupDN);\n                        else\n                            groupCtx = (DirContext) ctx.lookup(groupDN);\n\n                        if (groupCtx == null) {\n                            throw new RuntimeException(\"Can not find group entry \" +\n                            \t\t\"identified by '\" + groupDN + \"'.\");\n                        }\n                        String groupNameAttribute = groupRetrieval.getGroupNameAttribute();\n                        Attributes groupAttributes = groupCtx.getAttributes(\"\", \n                        \t\tnew String[]{groupNameAttribute});\n                        if (groupAttributes == null \n                        \t\t|| groupAttributes.get(groupNameAttribute) == null\n                                || groupAttributes.get(groupNameAttribute).get() == null) {\n                            throw new RuntimeException(\"Can not find attribute '\" \n                            \t\t+ groupNameAttribute + \"' in returned group entry.\");\n                        }\n                        groupNames.add((String) groupAttributes.get(groupNameAttribute).get());\n                    } finally {\n                        if (groupCtx != null) {\n                            try {\n                                groupCtx.close();\n                            } catch (NamingException ne) {\n                            }\n                        }\n                    }\n                }\n            } else {\n                logger.warn(\"No attribute identified by '\" + groupRetrieval.getUserGroupsAttribute() \n                \t\t+ \"' inside fetched user LDAP entry.\");\n            }\n\t\t} catch (NamingException e) {\n\t\t\tlogger.error(\"Error retrieving groups by attribute\");\n\t\t}\n\t\treturn groupNames;\n\t}\n\t\n\tprivate Collection<String> retrieveGroupsByFilter(DirContext ctx, DirContext referralCtx, String userDN) {\n\t\tCollection<String> groupNames = new HashSet<>();\n\t\ttry {\n\t    \tSearchGroupsUsingFilter groupRetrieval = (SearchGroupsUsingFilter) getGroupRetrieval();\n\t    \tString groupNameAttribute = groupRetrieval.getGroupNameAttribute();\n\t        Name groupSearchBase = new CompositeName().add(groupRetrieval.getGroupSearchBase());\n\t        String groupSearchFilter = StringUtils.replace(groupRetrieval.getGroupSearchFilter(), \"{0}\", userDN);\n\t        groupSearchFilter = StringUtils.replace(groupSearchFilter, \"\\\\\", \"\\\\\\\\\");\n\t\n\t        logger.debug(\"Evaluated group search filter: \" + groupSearchFilter);\n\t        SearchControls searchControls = new SearchControls();\n\t        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\t        searchControls.setReturningAttributes(new String[]{groupNameAttribute});\n\t        searchControls.setReturningObjFlag(true);\n\t\n\t    \tNamingEnumeration<SearchResult> results;\n\t        if (referralCtx != null)\n\t            results = referralCtx.search(groupSearchBase, groupSearchFilter, searchControls);\n\t        else\n\t            results = ctx.search(groupSearchBase, groupSearchFilter, searchControls);\n\t        if (results != null) {\n\t            while (results.hasMore()) {\n\t            \tSearchResult searchResult = (SearchResult) results.next();\n\t                Attributes searchResultAttributes = searchResult.getAttributes();\n\t                if (searchResultAttributes == null \n\t                \t\t|| searchResultAttributes.get(groupNameAttribute) == null\n\t                        || searchResultAttributes.get(groupNameAttribute).get() == null) {\n\t                    throw new RuntimeException(\"Can not find attribute '\" \n\t                    \t\t+ groupNameAttribute + \"' in the returned group object.\");\n\t                }\n\t                groupNames.add((String) searchResultAttributes.get(groupNameAttribute).get());\n\t            }\n\t        }\n        } catch (PartialResultException pre) {\n            logger.warn(\"Partial exception detected. You may try to set property \" +\n            \t\t\"'follow referrals' to true to avoid this exception.\", pre);\n\t\t} catch (NamingException e) {\n\t\t\tlogger.error(\"Error retrieving groups by filter\", e);\n\t\t}\n\t\treturn groupNames;\n\t}\n\n\t@Nullable\n\tprivate Collection<String> retrieveSshKeys(Attributes searchResultAttributes) {\n\t\tAttribute attribute = searchResultAttributes.get(getUserSshKeyAttribute());\n\t\tif (attribute != null) {\n\t\t\tCollection<String> sshKeys = new ArrayList<>();\n\t\t\ttry {\n\t\t\t\tNamingEnumeration<?> ldapValues = attribute.getAll();\n\t\t\t\twhile (ldapValues.hasMore()) {\n\t\t\t\t\tObject value = ldapValues.next();\n\t\t\t\t\tif (value instanceof String) \n\t\t\t\t\t\tsshKeys.add((String) value);\n\t\t\t\t\telse \n\t\t\t\t\t\tlogger.error(\"SSH key from ldap is not a String\");\n\t\t\t\t}\n\n\t\t\t} catch (NamingException e) {\n\t\t\t\tlogger.error(\"Error retrieving SSH keys\", e);\n\t\t\t}\n\t\t\treturn sshKeys;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isManagingMemberships() {\n\t\treturn !(getGroupRetrieval() instanceof DoNotRetrieveGroups);\n\t}\n\n\t@Override\n\tpublic boolean isManagingSshKeys() {\n\t\treturn getUserSshKeyAttribute() != null;\n\t}\n\t\n\t/* Copied from Spring LdapEncoder.java */\n    private static String[] FILTER_ESCAPE_TABLE = new String['\\\\' + 1];\n\n    static {\n\n        // Filter encoding table -------------------------------------\n\n        // fill with char itself\n        for (char c = 0; c < FILTER_ESCAPE_TABLE.length; c++) {\n            FILTER_ESCAPE_TABLE[c] = String.valueOf(c);\n        }\n\n        // escapes (RFC2254)\n        FILTER_ESCAPE_TABLE['*'] = \"\\\\2a\";\n        FILTER_ESCAPE_TABLE['('] = \"\\\\28\";\n        FILTER_ESCAPE_TABLE[')'] = \"\\\\29\";\n        FILTER_ESCAPE_TABLE['\\\\'] = \"\\\\5c\";\n        FILTER_ESCAPE_TABLE[0] = \"\\\\00\";\n\n    }\n\n    private static String escape(String value) {\n        // make buffer roomy\n        StringBuilder encodedValue = new StringBuilder(value.length() * 2);\n\n        int length = value.length();\n\n        for (int i = 0; i < length; i++) {\n\n            char c = value.charAt(i);\n\n            if (c < FILTER_ESCAPE_TABLE.length) {\n                encodedValue.append(FILTER_ESCAPE_TABLE[c]);\n            } else {\n                // default: add the char\n                encodedValue.append(c);\n            }\n        }\n\n        return encodedValue.toString();\n    }\t\n\t\n}\n"], "filenames": ["server-plugin/server-plugin-authenticator-ldap/src/main/java/io/onedev/server/plugin/authenticator/ldap/LdapAuthenticator.java"], "buggy_code_start_loc": [184], "buggy_code_end_loc": [439], "fixing_code_start_loc": [184], "fixing_code_end_loc": [484], "type": "CWE-90", "message": "OneDev is a development operations platform. If the LDAP external authentication mechanism is enabled in OneDev versions 4.4.1 and prior, an attacker can manipulate a user search filter to send forged queries to the application and explore the LDAP tree using Blind LDAP Injection techniques. The specific payload depends on how the User Search Filter property is configured in OneDev. This issue was fixed in version 4.4.2.", "other": {"cve": {"id": "CVE-2021-32651", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-01T18:15:07.747", "lastModified": "2021-06-16T14:28:20.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OneDev is a development operations platform. If the LDAP external authentication mechanism is enabled in OneDev versions 4.4.1 and prior, an attacker can manipulate a user search filter to send forged queries to the application and explore the LDAP tree using Blind LDAP Injection techniques. The specific payload depends on how the User Search Filter property is configured in OneDev. This issue was fixed in version 4.4.2."}, {"lang": "es", "value": "OneDev es una plataforma de operaciones de desarrollo. Si el mecanismo de autenticaci\u00f3n externa LDAP est\u00e1 habilitado en OneDev versiones 4.4.1 y anteriores, un atacante puede manipular un filtro de b\u00fasqueda de usuario para enviar consultas falsas hacia la aplicaci\u00f3n y explorar el LDAP tree usando t\u00e9cnicas de inyecci\u00f3n Blind LDAP. La carga \u00fatil espec\u00edfica depende de c\u00f3mo la propiedad User Search Filter est\u00e1 configurada en OneDev. Este problema fue corregido en versi\u00f3n 4.4.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-90"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:onedev_project:onedev:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.2", "matchCriteriaId": "36DF0039-F0C3-4536-98CF-FC08028C065F"}]}]}], "references": [{"url": "https://github.com/theonedev/onedev/commit/4440f0c57e440488d7e653417b2547eaae8ad19c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/theonedev/onedev/security/advisories/GHSA-5864-2496-4xjf", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/theonedev/onedev/commit/4440f0c57e440488d7e653417b2547eaae8ad19c"}}