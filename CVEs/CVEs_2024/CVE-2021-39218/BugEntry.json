{"buggy_code": ["//! Implements a registry of modules for a store.\n\nuse crate::{signatures::SignatureCollection, Module};\nuse std::{\n    collections::BTreeMap,\n    sync::{Arc, RwLock},\n};\nuse wasmtime_environ::{EntityRef, FilePos, StackMap, TrapCode};\nuse wasmtime_jit::CompiledModule;\nuse wasmtime_runtime::{ModuleInfo, VMCallerCheckedAnyfunc, VMTrampoline};\n\nlazy_static::lazy_static! {\n    static ref GLOBAL_MODULES: RwLock<GlobalModuleRegistry> = Default::default();\n}\n\n/// Used for registering modules with a store.\n///\n/// The map is from the ending (exclusive) address for the module code to\n/// the registered module.\n///\n/// The `BTreeMap` is used to quickly locate a module based on a program counter value.\n#[derive(Default)]\npub struct ModuleRegistry {\n    modules_with_code: BTreeMap<usize, Arc<RegisteredModule>>,\n    modules_without_code: Vec<Arc<CompiledModule>>,\n}\n\nimpl ModuleRegistry {\n    /// Fetches information about a registered module given a program counter value.\n    pub fn lookup_module(&self, pc: usize) -> Option<Arc<dyn ModuleInfo>> {\n        self.module(pc)\n            .map(|m| -> Arc<dyn ModuleInfo> { m.clone() })\n    }\n\n    fn module(&self, pc: usize) -> Option<&Arc<RegisteredModule>> {\n        let (end, info) = self.modules_with_code.range(pc..).next()?;\n        if pc < info.start || *end < pc {\n            return None;\n        }\n\n        Some(info)\n    }\n\n    /// Registers a new module with the registry.\n    pub fn register(&mut self, module: &Module) {\n        let compiled_module = module.compiled_module();\n\n        // If there's not actually any functions in this module then we may\n        // still need to preserve it for its data segments. Instances of this\n        // module will hold a pointer to the data stored in the module itself,\n        // and for schemes like uffd this performs lazy initialization which\n        // could use the module in the future. For that reason we continue to\n        // register empty modules and retain them.\n        if compiled_module.finished_functions().len() == 0 {\n            self.modules_without_code.push(compiled_module.clone());\n            return;\n        }\n\n        // The module code range is exclusive for end, so make it inclusive as it\n        // may be a valid PC value\n        let code = compiled_module.code();\n        assert!(!code.is_empty());\n        let start = code.as_ptr() as usize;\n        let end = start + code.len() - 1;\n\n        // Ensure the module isn't already present in the registry\n        // This is expected when a module is instantiated multiple times in the\n        // same store\n        if let Some(m) = self.modules_with_code.get(&end) {\n            assert_eq!(m.start, start);\n            return;\n        }\n\n        // Assert that this module's code doesn't collide with any other registered modules\n        if let Some((_, prev)) = self.modules_with_code.range(end..).next() {\n            assert!(prev.start > end);\n        }\n\n        if let Some((prev_end, _)) = self.modules_with_code.range(..=start).next_back() {\n            assert!(*prev_end < start);\n        }\n\n        let prev = self.modules_with_code.insert(\n            end,\n            Arc::new(RegisteredModule {\n                start,\n                module: compiled_module.clone(),\n                signatures: module.signatures().clone(),\n            }),\n        );\n        assert!(prev.is_none());\n\n        GLOBAL_MODULES.write().unwrap().register(start, end, module);\n    }\n\n    /// Looks up a trampoline from an anyfunc.\n    pub fn lookup_trampoline(&self, anyfunc: &VMCallerCheckedAnyfunc) -> Option<VMTrampoline> {\n        let module = self.module(anyfunc.func_ptr.as_ptr() as usize)?;\n        module.signatures.trampoline(anyfunc.type_index)\n    }\n}\n\nimpl Drop for ModuleRegistry {\n    fn drop(&mut self) {\n        let mut info = GLOBAL_MODULES.write().unwrap();\n        for end in self.modules_with_code.keys() {\n            info.unregister(*end);\n        }\n    }\n}\n\nstruct RegisteredModule {\n    start: usize,\n    module: Arc<CompiledModule>,\n    signatures: Arc<SignatureCollection>,\n}\n\nimpl ModuleInfo for RegisteredModule {\n    fn lookup_stack_map(&self, pc: usize) -> Option<&StackMap> {\n        let text_offset = pc - self.start;\n        let (index, func_offset) = self.module.func_by_text_offset(text_offset)?;\n        let info = self.module.func_info(index);\n\n        // Do a binary search to find the stack map for the given offset.\n        //\n        // Because GC safepoints are technically only associated with a single\n        // PC, we should ideally only care about `Ok(index)` values returned\n        // from the binary search. However, safepoints are inserted right before\n        // calls, and there are two things that can disturb the PC/offset\n        // associated with the safepoint versus the PC we actually use to query\n        // for the stack map:\n        //\n        // 1. The `backtrace` crate gives us the PC in a frame that will be\n        //    *returned to*, and where execution will continue from, rather than\n        //    the PC of the call we are currently at. So we would need to\n        //    disassemble one instruction backwards to query the actual PC for\n        //    the stack map.\n        //\n        //    TODO: One thing we *could* do to make this a little less error\n        //    prone, would be to assert/check that the nearest GC safepoint\n        //    found is within `max_encoded_size(any kind of call instruction)`\n        //    our queried PC for the target architecture.\n        //\n        // 2. Cranelift's stack maps only handle the stack, not\n        //    registers. However, some references that are arguments to a call\n        //    may need to be in registers. In these cases, what Cranelift will\n        //    do is:\n        //\n        //      a. spill all the live references,\n        //      b. insert a GC safepoint for those references,\n        //      c. reload the references into registers, and finally\n        //      d. make the call.\n        //\n        //    Step (c) adds drift between the GC safepoint and the location of\n        //    the call, which is where we actually walk the stack frame and\n        //    collect its live references.\n        //\n        //    Luckily, the spill stack slots for the live references are still\n        //    up to date, so we can still find all the on-stack roots.\n        //    Furthermore, we do not have a moving GC, so we don't need to worry\n        //    whether the following code will reuse the references in registers\n        //    (which would not have been updated to point to the moved objects)\n        //    or reload from the stack slots (which would have been updated to\n        //    point to the moved objects).\n\n        let index = match info\n            .stack_maps\n            .binary_search_by_key(&func_offset, |i| i.code_offset)\n        {\n            // Exact hit.\n            Ok(i) => i,\n\n            // `Err(0)` means that the associated stack map would have been the\n            // first element in the array if this pc had an associated stack\n            // map, but this pc does not have an associated stack map. This can\n            // only happen inside a Wasm frame if there are no live refs at this\n            // pc.\n            Err(0) => return None,\n\n            Err(i) => i - 1,\n        };\n\n        Some(&info.stack_maps[index].stack_map)\n    }\n}\n\n// Counterpart to `RegisteredModule`, but stored in the global registry.\nstruct GlobalRegisteredModule {\n    start: usize,\n    module: Arc<CompiledModule>,\n    wasm_backtrace_details_env_used: bool,\n    /// Note that modules can be instantiated in many stores, so the purpose of\n    /// this field is to keep track of how many stores have registered a\n    /// module. Information is only removed from the global registry when this\n    /// reference count reaches 0.\n    references: usize,\n}\n\n/// This is the global module registry that stores information for all modules\n/// that are currently in use by any `Store`.\n///\n/// The purpose of this map is to be called from signal handlers to determine\n/// whether a program counter is a wasm trap or not. Specifically macOS has\n/// no contextual information about the thread available, hence the necessity\n/// for global state rather than using thread local state.\n///\n/// This is similar to `ModuleRegistry` except that it has less information and\n/// supports removal. Any time anything is registered with a `ModuleRegistry`\n/// it is also automatically registered with the singleton global module\n/// registry. When a `ModuleRegistry` is destroyed then all of its entries\n/// are removed from the global module registry.\n#[derive(Default)]\npub struct GlobalModuleRegistry(BTreeMap<usize, GlobalRegisteredModule>);\n\nimpl GlobalModuleRegistry {\n    /// Returns whether the `pc`, according to globally registered information,\n    /// is a wasm trap or not.\n    pub(crate) fn is_wasm_pc(pc: usize) -> bool {\n        let modules = GLOBAL_MODULES.read().unwrap();\n\n        match modules.module(pc) {\n            Some((entry, text_offset)) => {\n                wasmtime_environ::lookup_file_pos(entry.module.address_map_data(), text_offset)\n                    .is_some()\n            }\n            None => false,\n        }\n    }\n\n    /// Returns, if found, the corresponding module for the `pc` as well as the\n    /// pc transformed to a relative offset within the text section.\n    fn module(&self, pc: usize) -> Option<(&GlobalRegisteredModule, usize)> {\n        let (end, info) = self.0.range(pc..).next()?;\n        if pc < info.start || *end < pc {\n            return None;\n        }\n        Some((info, pc - info.start))\n    }\n\n    // Work with the global instance of `GlobalModuleRegistry`. Note that only\n    // shared access is allowed, this isn't intended to mutate the contents.\n    pub(crate) fn with<R>(f: impl FnOnce(&GlobalModuleRegistry) -> R) -> R {\n        f(&GLOBAL_MODULES.read().unwrap())\n    }\n\n    /// Fetches frame information about a program counter in a backtrace.\n    ///\n    /// Returns an object if this `pc` is known to some previously registered\n    /// module, or returns `None` if no information can be found. The first\n    /// boolean returned indicates whether the original module has unparsed\n    /// debug information due to the compiler's configuration. The second\n    /// boolean indicates whether the engine used to compile this module is\n    /// using environment variables to control debuginfo parsing.\n    pub(crate) fn lookup_frame_info(&self, pc: usize) -> Option<(FrameInfo, bool, bool)> {\n        let (module, offset) = self.module(pc)?;\n        module.lookup_frame_info(offset).map(|info| {\n            (\n                info,\n                module.has_unparsed_debuginfo(),\n                module.wasm_backtrace_details_env_used,\n            )\n        })\n    }\n\n    /// Fetches trap information about a program counter in a backtrace.\n    pub(crate) fn lookup_trap_code(&self, pc: usize) -> Option<TrapCode> {\n        let (module, offset) = self.module(pc)?;\n        wasmtime_environ::lookup_trap_code(module.module.trap_data(), offset)\n    }\n\n    /// Registers a new region of code, described by `(start, end)` and with\n    /// the given function information, with the global information.\n    fn register(&mut self, start: usize, end: usize, module: &Module) {\n        let info = self.0.entry(end).or_insert_with(|| GlobalRegisteredModule {\n            start,\n            module: module.compiled_module().clone(),\n            wasm_backtrace_details_env_used: module\n                .engine()\n                .config()\n                .wasm_backtrace_details_env_used,\n            references: 0,\n        });\n\n        // Note that ideally we'd debug_assert that the information previously\n        // stored, if any, matches the `functions` we were given, but for now we\n        // just do some simple checks to hope it's the same.\n        assert_eq!(info.start, start);\n        info.references += 1;\n    }\n\n    /// Unregisters a region of code (keyed by the `end` address) from the\n    /// global information.\n    fn unregister(&mut self, end: usize) {\n        let info = self.0.get_mut(&end).unwrap();\n        info.references -= 1;\n        if info.references == 0 {\n            self.0.remove(&end);\n        }\n    }\n}\n\nimpl GlobalRegisteredModule {\n    /// Determines if the related module has unparsed debug information.\n    pub fn has_unparsed_debuginfo(&self) -> bool {\n        self.module.has_unparsed_debuginfo()\n    }\n\n    /// Fetches frame information about a program counter in a backtrace.\n    ///\n    /// Returns an object if this `pc` is known to this module, or returns `None`\n    /// if no information can be found.\n    pub fn lookup_frame_info(&self, text_offset: usize) -> Option<FrameInfo> {\n        let (index, _func_offset) = self.module.func_by_text_offset(text_offset)?;\n        let info = self.module.func_info(index);\n        let instr = wasmtime_environ::lookup_file_pos(self.module.address_map_data(), text_offset);\n\n        // In debug mode for now assert that we found a mapping for `pc` within\n        // the function, because otherwise something is buggy along the way and\n        // not accounting for all the instructions. This isn't super critical\n        // though so we can omit this check in release mode.\n        debug_assert!(\n            instr.is_some(),\n            \"failed to find instruction for {:#x}\",\n            text_offset\n        );\n\n        let instr = instr.unwrap_or(info.start_srcloc);\n\n        // Use our wasm-relative pc to symbolize this frame. If there's a\n        // symbolication context (dwarf debug info) available then we can try to\n        // look this up there.\n        //\n        // Note that dwarf pcs are code-section-relative, hence the subtraction\n        // from the location of `instr`. Also note that all errors are ignored\n        // here for now since technically wasm modules can always have any\n        // custom section contents.\n        let mut symbols = Vec::new();\n\n        if let Some(s) = &self.module.symbolize_context().ok().and_then(|c| c) {\n            if let Some(offset) = instr.file_offset() {\n                let to_lookup = u64::from(offset) - s.code_section_offset();\n                if let Ok(mut frames) = s.addr2line().find_frames(to_lookup) {\n                    while let Ok(Some(frame)) = frames.next() {\n                        symbols.push(FrameSymbol {\n                            name: frame\n                                .function\n                                .as_ref()\n                                .and_then(|l| l.raw_name().ok())\n                                .map(|s| s.to_string()),\n                            file: frame\n                                .location\n                                .as_ref()\n                                .and_then(|l| l.file)\n                                .map(|s| s.to_string()),\n                            line: frame.location.as_ref().and_then(|l| l.line),\n                            column: frame.location.as_ref().and_then(|l| l.column),\n                        });\n                    }\n                }\n            }\n        }\n\n        let module = self.module.module();\n        let index = module.func_index(index);\n\n        Some(FrameInfo {\n            module_name: module.name.clone(),\n            func_index: index.index() as u32,\n            func_name: module.func_names.get(&index).cloned(),\n            instr,\n            func_start: info.start_srcloc,\n            symbols,\n        })\n    }\n}\n\n/// Description of a frame in a backtrace for a [`Trap`].\n///\n/// Whenever a WebAssembly trap occurs an instance of [`Trap`] is created. Each\n/// [`Trap`] has a backtrace of the WebAssembly frames that led to the trap, and\n/// each frame is described by this structure.\n///\n/// [`Trap`]: crate::Trap\n#[derive(Debug)]\npub struct FrameInfo {\n    module_name: Option<String>,\n    func_index: u32,\n    func_name: Option<String>,\n    func_start: FilePos,\n    instr: FilePos,\n    symbols: Vec<FrameSymbol>,\n}\n\nimpl FrameInfo {\n    /// Returns the WebAssembly function index for this frame.\n    ///\n    /// This function index is the index in the function index space of the\n    /// WebAssembly module that this frame comes from.\n    pub fn func_index(&self) -> u32 {\n        self.func_index\n    }\n\n    /// Returns the identifer of the module that this frame is for.\n    ///\n    /// Module identifiers are present in the `name` section of a WebAssembly\n    /// binary, but this may not return the exact item in the `name` section.\n    /// Module names can be overwritten at construction time or perhaps inferred\n    /// from file names. The primary purpose of this function is to assist in\n    /// debugging and therefore may be tweaked over time.\n    ///\n    /// This function returns `None` when no name can be found or inferred.\n    pub fn module_name(&self) -> Option<&str> {\n        self.module_name.as_deref()\n    }\n\n    /// Returns a descriptive name of the function for this frame, if one is\n    /// available.\n    ///\n    /// The name of this function may come from the `name` section of the\n    /// WebAssembly binary, or wasmtime may try to infer a better name for it if\n    /// not available, for example the name of the export if it's exported.\n    ///\n    /// This return value is primarily used for debugging and human-readable\n    /// purposes for things like traps. Note that the exact return value may be\n    /// tweaked over time here and isn't guaranteed to be something in\n    /// particular about a wasm module due to its primary purpose of assisting\n    /// in debugging.\n    ///\n    /// This function returns `None` when no name could be inferred.\n    pub fn func_name(&self) -> Option<&str> {\n        self.func_name.as_deref()\n    }\n\n    /// Returns the offset within the original wasm module this frame's program\n    /// counter was at.\n    ///\n    /// The offset here is the offset from the beginning of the original wasm\n    /// module to the instruction that this frame points to.\n    pub fn module_offset(&self) -> usize {\n        self.instr.file_offset().unwrap_or(u32::MAX) as usize\n    }\n\n    /// Returns the offset from the original wasm module's function to this\n    /// frame's program counter.\n    ///\n    /// The offset here is the offset from the beginning of the defining\n    /// function of this frame (within the wasm module) to the instruction this\n    /// frame points to.\n    pub fn func_offset(&self) -> usize {\n        match self.instr.file_offset() {\n            Some(i) => (i - self.func_start.file_offset().unwrap()) as usize,\n            None => u32::MAX as usize,\n        }\n    }\n\n    /// Returns the debug symbols found, if any, for this function frame.\n    ///\n    /// When a wasm program is compiled with DWARF debug information then this\n    /// function may be populated to return symbols which contain extra debug\n    /// information about a frame including the filename and line number. If no\n    /// debug information was found or if it was malformed then this will return\n    /// an empty array.\n    pub fn symbols(&self) -> &[FrameSymbol] {\n        &self.symbols\n    }\n}\n\n/// Debug information for a symbol that is attached to a [`FrameInfo`].\n///\n/// When DWARF debug information is present in a wasm file then this structure\n/// can be found on a [`FrameInfo`] and can be used to learn about filenames,\n/// line numbers, etc, which are the origin of a function in a stack trace.\n#[derive(Debug)]\npub struct FrameSymbol {\n    name: Option<String>,\n    file: Option<String>,\n    line: Option<u32>,\n    column: Option<u32>,\n}\n\nimpl FrameSymbol {\n    /// Returns the function name associated with this symbol.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it. Also note that the symbol is\n    /// frequently mangled, so you might need to run some form of demangling\n    /// over it.\n    pub fn name(&self) -> Option<&str> {\n        self.name.as_deref()\n    }\n\n    /// Returns the source code filename this symbol was defined in.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it.\n    pub fn file(&self) -> Option<&str> {\n        self.file.as_deref()\n    }\n\n    /// Returns the 1-indexed source code line number this symbol was defined\n    /// on.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it.\n    pub fn line(&self) -> Option<u32> {\n        self.line\n    }\n\n    /// Returns the 1-indexed source code column number this symbol was defined\n    /// on.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it.\n    pub fn column(&self) -> Option<u32> {\n        self.column\n    }\n}\n\n#[test]\nfn test_frame_info() -> Result<(), anyhow::Error> {\n    use crate::*;\n    let mut store = Store::<()>::default();\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (export \"add\") (param $x i32) (param $y i32) (result i32) (i32.add (local.get $x) (local.get $y)))\n                (func (export \"sub\") (param $x i32) (param $y i32) (result i32) (i32.sub (local.get $x) (local.get $y)))\n                (func (export \"mul\") (param $x i32) (param $y i32) (result i32) (i32.mul (local.get $x) (local.get $y)))\n                (func (export \"div_s\") (param $x i32) (param $y i32) (result i32) (i32.div_s (local.get $x) (local.get $y)))\n                (func (export \"div_u\") (param $x i32) (param $y i32) (result i32) (i32.div_u (local.get $x) (local.get $y)))\n                (func (export \"rem_s\") (param $x i32) (param $y i32) (result i32) (i32.rem_s (local.get $x) (local.get $y)))\n                (func (export \"rem_u\") (param $x i32) (param $y i32) (result i32) (i32.rem_u (local.get $x) (local.get $y)))\n            )\n         \"#,\n    )?;\n    // Create an instance to ensure the frame information is registered.\n    Instance::new(&mut store, &module, &[])?;\n\n    GlobalModuleRegistry::with(|modules| {\n        for (i, alloc) in module.compiled_module().finished_functions() {\n            let (start, end) = unsafe {\n                let ptr = (*alloc).as_ptr();\n                let len = (*alloc).len();\n                (ptr as usize, ptr as usize + len)\n            };\n            for pc in start..end {\n                let (frame, _, _) = modules.lookup_frame_info(pc).unwrap();\n                assert!(\n                    frame.func_index() == i.as_u32(),\n                    \"lookup of {:#x} returned {}, expected {}\",\n                    pc,\n                    frame.func_index(),\n                    i.as_u32()\n                );\n            }\n        }\n    });\n    Ok(())\n}\n"], "fixing_code": ["//! Implements a registry of modules for a store.\n\nuse crate::{signatures::SignatureCollection, Module};\nuse std::{\n    collections::BTreeMap,\n    sync::{Arc, RwLock},\n};\nuse wasmtime_environ::{EntityRef, FilePos, StackMap, TrapCode};\nuse wasmtime_jit::CompiledModule;\nuse wasmtime_runtime::{ModuleInfo, VMCallerCheckedAnyfunc, VMTrampoline};\n\nlazy_static::lazy_static! {\n    static ref GLOBAL_MODULES: RwLock<GlobalModuleRegistry> = Default::default();\n}\n\n/// Used for registering modules with a store.\n///\n/// The map is from the ending (exclusive) address for the module code to\n/// the registered module.\n///\n/// The `BTreeMap` is used to quickly locate a module based on a program counter value.\n#[derive(Default)]\npub struct ModuleRegistry {\n    modules_with_code: BTreeMap<usize, Arc<RegisteredModule>>,\n    modules_without_code: Vec<Arc<CompiledModule>>,\n}\n\nimpl ModuleRegistry {\n    /// Fetches information about a registered module given a program counter value.\n    pub fn lookup_module(&self, pc: usize) -> Option<Arc<dyn ModuleInfo>> {\n        self.module(pc)\n            .map(|m| -> Arc<dyn ModuleInfo> { m.clone() })\n    }\n\n    fn module(&self, pc: usize) -> Option<&Arc<RegisteredModule>> {\n        let (end, info) = self.modules_with_code.range(pc..).next()?;\n        if pc < info.start || *end < pc {\n            return None;\n        }\n\n        Some(info)\n    }\n\n    /// Registers a new module with the registry.\n    pub fn register(&mut self, module: &Module) {\n        let compiled_module = module.compiled_module();\n\n        // If there's not actually any functions in this module then we may\n        // still need to preserve it for its data segments. Instances of this\n        // module will hold a pointer to the data stored in the module itself,\n        // and for schemes like uffd this performs lazy initialization which\n        // could use the module in the future. For that reason we continue to\n        // register empty modules and retain them.\n        if compiled_module.finished_functions().len() == 0 {\n            self.modules_without_code.push(compiled_module.clone());\n            return;\n        }\n\n        // The module code range is exclusive for end, so make it inclusive as it\n        // may be a valid PC value\n        let code = compiled_module.code();\n        assert!(!code.is_empty());\n        let start = code.as_ptr() as usize;\n        let end = start + code.len() - 1;\n\n        // Ensure the module isn't already present in the registry\n        // This is expected when a module is instantiated multiple times in the\n        // same store\n        if let Some(m) = self.modules_with_code.get(&end) {\n            assert_eq!(m.start, start);\n            return;\n        }\n\n        // Assert that this module's code doesn't collide with any other registered modules\n        if let Some((_, prev)) = self.modules_with_code.range(end..).next() {\n            assert!(prev.start > end);\n        }\n\n        if let Some((prev_end, _)) = self.modules_with_code.range(..=start).next_back() {\n            assert!(*prev_end < start);\n        }\n\n        let prev = self.modules_with_code.insert(\n            end,\n            Arc::new(RegisteredModule {\n                start,\n                module: compiled_module.clone(),\n                signatures: module.signatures().clone(),\n            }),\n        );\n        assert!(prev.is_none());\n\n        GLOBAL_MODULES.write().unwrap().register(start, end, module);\n    }\n\n    /// Looks up a trampoline from an anyfunc.\n    pub fn lookup_trampoline(&self, anyfunc: &VMCallerCheckedAnyfunc) -> Option<VMTrampoline> {\n        let module = self.module(anyfunc.func_ptr.as_ptr() as usize)?;\n        module.signatures.trampoline(anyfunc.type_index)\n    }\n}\n\nimpl Drop for ModuleRegistry {\n    fn drop(&mut self) {\n        let mut info = GLOBAL_MODULES.write().unwrap();\n        for end in self.modules_with_code.keys() {\n            info.unregister(*end);\n        }\n    }\n}\n\nstruct RegisteredModule {\n    start: usize,\n    module: Arc<CompiledModule>,\n    signatures: Arc<SignatureCollection>,\n}\n\nimpl ModuleInfo for RegisteredModule {\n    fn lookup_stack_map(&self, pc: usize) -> Option<&StackMap> {\n        let text_offset = pc - self.start;\n        let (index, func_offset) = self.module.func_by_text_offset(text_offset)?;\n        let info = self.module.func_info(index);\n\n        // Do a binary search to find the stack map for the given offset.\n        let index = match info\n            .stack_maps\n            .binary_search_by_key(&func_offset, |i| i.code_offset)\n        {\n            // Found it.\n            Ok(i) => i,\n\n            // No stack map associated with this PC.\n            //\n            // Because we know we are in Wasm code, and we must be at some kind\n            // of call/safepoint, then the Cranelift backend must have avoided\n            // emitting a stack map for this location because no refs were live.\n            #[cfg(not(feature = \"old-x86-backend\"))]\n            Err(_) => return None,\n\n            // ### Old x86_64 backend specific code.\n            //\n            // Because GC safepoints are technically only associated with a\n            // single PC, we should ideally only care about `Ok(index)` values\n            // returned from the binary search. However, safepoints are inserted\n            // right before calls, and there are two things that can disturb the\n            // PC/offset associated with the safepoint versus the PC we actually\n            // use to query for the stack map:\n            //\n            // 1. The `backtrace` crate gives us the PC in a frame that will be\n            //    *returned to*, and where execution will continue from, rather than\n            //    the PC of the call we are currently at. So we would need to\n            //    disassemble one instruction backwards to query the actual PC for\n            //    the stack map.\n            //\n            //    TODO: One thing we *could* do to make this a little less error\n            //    prone, would be to assert/check that the nearest GC safepoint\n            //    found is within `max_encoded_size(any kind of call instruction)`\n            //    our queried PC for the target architecture.\n            //\n            // 2. Cranelift's stack maps only handle the stack, not\n            //    registers. However, some references that are arguments to a call\n            //    may need to be in registers. In these cases, what Cranelift will\n            //    do is:\n            //\n            //      a. spill all the live references,\n            //      b. insert a GC safepoint for those references,\n            //      c. reload the references into registers, and finally\n            //      d. make the call.\n            //\n            //    Step (c) adds drift between the GC safepoint and the location of\n            //    the call, which is where we actually walk the stack frame and\n            //    collect its live references.\n            //\n            //    Luckily, the spill stack slots for the live references are still\n            //    up to date, so we can still find all the on-stack roots.\n            //    Furthermore, we do not have a moving GC, so we don't need to worry\n            //    whether the following code will reuse the references in registers\n            //    (which would not have been updated to point to the moved objects)\n            //    or reload from the stack slots (which would have been updated to\n            //    point to the moved objects).\n            #[cfg(feature = \"old-x86-backend\")]\n            Err(0) => return None,\n            #[cfg(feature = \"old-x86-backend\")]\n            Err(i) => i - 1,\n        };\n\n        Some(&info.stack_maps[index].stack_map)\n    }\n}\n\n// Counterpart to `RegisteredModule`, but stored in the global registry.\nstruct GlobalRegisteredModule {\n    start: usize,\n    module: Arc<CompiledModule>,\n    wasm_backtrace_details_env_used: bool,\n    /// Note that modules can be instantiated in many stores, so the purpose of\n    /// this field is to keep track of how many stores have registered a\n    /// module. Information is only removed from the global registry when this\n    /// reference count reaches 0.\n    references: usize,\n}\n\n/// This is the global module registry that stores information for all modules\n/// that are currently in use by any `Store`.\n///\n/// The purpose of this map is to be called from signal handlers to determine\n/// whether a program counter is a wasm trap or not. Specifically macOS has\n/// no contextual information about the thread available, hence the necessity\n/// for global state rather than using thread local state.\n///\n/// This is similar to `ModuleRegistry` except that it has less information and\n/// supports removal. Any time anything is registered with a `ModuleRegistry`\n/// it is also automatically registered with the singleton global module\n/// registry. When a `ModuleRegistry` is destroyed then all of its entries\n/// are removed from the global module registry.\n#[derive(Default)]\npub struct GlobalModuleRegistry(BTreeMap<usize, GlobalRegisteredModule>);\n\nimpl GlobalModuleRegistry {\n    /// Returns whether the `pc`, according to globally registered information,\n    /// is a wasm trap or not.\n    pub(crate) fn is_wasm_pc(pc: usize) -> bool {\n        let modules = GLOBAL_MODULES.read().unwrap();\n\n        match modules.module(pc) {\n            Some((entry, text_offset)) => {\n                wasmtime_environ::lookup_file_pos(entry.module.address_map_data(), text_offset)\n                    .is_some()\n            }\n            None => false,\n        }\n    }\n\n    /// Returns, if found, the corresponding module for the `pc` as well as the\n    /// pc transformed to a relative offset within the text section.\n    fn module(&self, pc: usize) -> Option<(&GlobalRegisteredModule, usize)> {\n        let (end, info) = self.0.range(pc..).next()?;\n        if pc < info.start || *end < pc {\n            return None;\n        }\n        Some((info, pc - info.start))\n    }\n\n    // Work with the global instance of `GlobalModuleRegistry`. Note that only\n    // shared access is allowed, this isn't intended to mutate the contents.\n    pub(crate) fn with<R>(f: impl FnOnce(&GlobalModuleRegistry) -> R) -> R {\n        f(&GLOBAL_MODULES.read().unwrap())\n    }\n\n    /// Fetches frame information about a program counter in a backtrace.\n    ///\n    /// Returns an object if this `pc` is known to some previously registered\n    /// module, or returns `None` if no information can be found. The first\n    /// boolean returned indicates whether the original module has unparsed\n    /// debug information due to the compiler's configuration. The second\n    /// boolean indicates whether the engine used to compile this module is\n    /// using environment variables to control debuginfo parsing.\n    pub(crate) fn lookup_frame_info(&self, pc: usize) -> Option<(FrameInfo, bool, bool)> {\n        let (module, offset) = self.module(pc)?;\n        module.lookup_frame_info(offset).map(|info| {\n            (\n                info,\n                module.has_unparsed_debuginfo(),\n                module.wasm_backtrace_details_env_used,\n            )\n        })\n    }\n\n    /// Fetches trap information about a program counter in a backtrace.\n    pub(crate) fn lookup_trap_code(&self, pc: usize) -> Option<TrapCode> {\n        let (module, offset) = self.module(pc)?;\n        wasmtime_environ::lookup_trap_code(module.module.trap_data(), offset)\n    }\n\n    /// Registers a new region of code, described by `(start, end)` and with\n    /// the given function information, with the global information.\n    fn register(&mut self, start: usize, end: usize, module: &Module) {\n        let info = self.0.entry(end).or_insert_with(|| GlobalRegisteredModule {\n            start,\n            module: module.compiled_module().clone(),\n            wasm_backtrace_details_env_used: module\n                .engine()\n                .config()\n                .wasm_backtrace_details_env_used,\n            references: 0,\n        });\n\n        // Note that ideally we'd debug_assert that the information previously\n        // stored, if any, matches the `functions` we were given, but for now we\n        // just do some simple checks to hope it's the same.\n        assert_eq!(info.start, start);\n        info.references += 1;\n    }\n\n    /// Unregisters a region of code (keyed by the `end` address) from the\n    /// global information.\n    fn unregister(&mut self, end: usize) {\n        let info = self.0.get_mut(&end).unwrap();\n        info.references -= 1;\n        if info.references == 0 {\n            self.0.remove(&end);\n        }\n    }\n}\n\nimpl GlobalRegisteredModule {\n    /// Determines if the related module has unparsed debug information.\n    pub fn has_unparsed_debuginfo(&self) -> bool {\n        self.module.has_unparsed_debuginfo()\n    }\n\n    /// Fetches frame information about a program counter in a backtrace.\n    ///\n    /// Returns an object if this `pc` is known to this module, or returns `None`\n    /// if no information can be found.\n    pub fn lookup_frame_info(&self, text_offset: usize) -> Option<FrameInfo> {\n        let (index, _func_offset) = self.module.func_by_text_offset(text_offset)?;\n        let info = self.module.func_info(index);\n        let instr = wasmtime_environ::lookup_file_pos(self.module.address_map_data(), text_offset);\n\n        // In debug mode for now assert that we found a mapping for `pc` within\n        // the function, because otherwise something is buggy along the way and\n        // not accounting for all the instructions. This isn't super critical\n        // though so we can omit this check in release mode.\n        debug_assert!(\n            instr.is_some(),\n            \"failed to find instruction for {:#x}\",\n            text_offset\n        );\n\n        let instr = instr.unwrap_or(info.start_srcloc);\n\n        // Use our wasm-relative pc to symbolize this frame. If there's a\n        // symbolication context (dwarf debug info) available then we can try to\n        // look this up there.\n        //\n        // Note that dwarf pcs are code-section-relative, hence the subtraction\n        // from the location of `instr`. Also note that all errors are ignored\n        // here for now since technically wasm modules can always have any\n        // custom section contents.\n        let mut symbols = Vec::new();\n\n        if let Some(s) = &self.module.symbolize_context().ok().and_then(|c| c) {\n            if let Some(offset) = instr.file_offset() {\n                let to_lookup = u64::from(offset) - s.code_section_offset();\n                if let Ok(mut frames) = s.addr2line().find_frames(to_lookup) {\n                    while let Ok(Some(frame)) = frames.next() {\n                        symbols.push(FrameSymbol {\n                            name: frame\n                                .function\n                                .as_ref()\n                                .and_then(|l| l.raw_name().ok())\n                                .map(|s| s.to_string()),\n                            file: frame\n                                .location\n                                .as_ref()\n                                .and_then(|l| l.file)\n                                .map(|s| s.to_string()),\n                            line: frame.location.as_ref().and_then(|l| l.line),\n                            column: frame.location.as_ref().and_then(|l| l.column),\n                        });\n                    }\n                }\n            }\n        }\n\n        let module = self.module.module();\n        let index = module.func_index(index);\n\n        Some(FrameInfo {\n            module_name: module.name.clone(),\n            func_index: index.index() as u32,\n            func_name: module.func_names.get(&index).cloned(),\n            instr,\n            func_start: info.start_srcloc,\n            symbols,\n        })\n    }\n}\n\n/// Description of a frame in a backtrace for a [`Trap`].\n///\n/// Whenever a WebAssembly trap occurs an instance of [`Trap`] is created. Each\n/// [`Trap`] has a backtrace of the WebAssembly frames that led to the trap, and\n/// each frame is described by this structure.\n///\n/// [`Trap`]: crate::Trap\n#[derive(Debug)]\npub struct FrameInfo {\n    module_name: Option<String>,\n    func_index: u32,\n    func_name: Option<String>,\n    func_start: FilePos,\n    instr: FilePos,\n    symbols: Vec<FrameSymbol>,\n}\n\nimpl FrameInfo {\n    /// Returns the WebAssembly function index for this frame.\n    ///\n    /// This function index is the index in the function index space of the\n    /// WebAssembly module that this frame comes from.\n    pub fn func_index(&self) -> u32 {\n        self.func_index\n    }\n\n    /// Returns the identifer of the module that this frame is for.\n    ///\n    /// Module identifiers are present in the `name` section of a WebAssembly\n    /// binary, but this may not return the exact item in the `name` section.\n    /// Module names can be overwritten at construction time or perhaps inferred\n    /// from file names. The primary purpose of this function is to assist in\n    /// debugging and therefore may be tweaked over time.\n    ///\n    /// This function returns `None` when no name can be found or inferred.\n    pub fn module_name(&self) -> Option<&str> {\n        self.module_name.as_deref()\n    }\n\n    /// Returns a descriptive name of the function for this frame, if one is\n    /// available.\n    ///\n    /// The name of this function may come from the `name` section of the\n    /// WebAssembly binary, or wasmtime may try to infer a better name for it if\n    /// not available, for example the name of the export if it's exported.\n    ///\n    /// This return value is primarily used for debugging and human-readable\n    /// purposes for things like traps. Note that the exact return value may be\n    /// tweaked over time here and isn't guaranteed to be something in\n    /// particular about a wasm module due to its primary purpose of assisting\n    /// in debugging.\n    ///\n    /// This function returns `None` when no name could be inferred.\n    pub fn func_name(&self) -> Option<&str> {\n        self.func_name.as_deref()\n    }\n\n    /// Returns the offset within the original wasm module this frame's program\n    /// counter was at.\n    ///\n    /// The offset here is the offset from the beginning of the original wasm\n    /// module to the instruction that this frame points to.\n    pub fn module_offset(&self) -> usize {\n        self.instr.file_offset().unwrap_or(u32::MAX) as usize\n    }\n\n    /// Returns the offset from the original wasm module's function to this\n    /// frame's program counter.\n    ///\n    /// The offset here is the offset from the beginning of the defining\n    /// function of this frame (within the wasm module) to the instruction this\n    /// frame points to.\n    pub fn func_offset(&self) -> usize {\n        match self.instr.file_offset() {\n            Some(i) => (i - self.func_start.file_offset().unwrap()) as usize,\n            None => u32::MAX as usize,\n        }\n    }\n\n    /// Returns the debug symbols found, if any, for this function frame.\n    ///\n    /// When a wasm program is compiled with DWARF debug information then this\n    /// function may be populated to return symbols which contain extra debug\n    /// information about a frame including the filename and line number. If no\n    /// debug information was found or if it was malformed then this will return\n    /// an empty array.\n    pub fn symbols(&self) -> &[FrameSymbol] {\n        &self.symbols\n    }\n}\n\n/// Debug information for a symbol that is attached to a [`FrameInfo`].\n///\n/// When DWARF debug information is present in a wasm file then this structure\n/// can be found on a [`FrameInfo`] and can be used to learn about filenames,\n/// line numbers, etc, which are the origin of a function in a stack trace.\n#[derive(Debug)]\npub struct FrameSymbol {\n    name: Option<String>,\n    file: Option<String>,\n    line: Option<u32>,\n    column: Option<u32>,\n}\n\nimpl FrameSymbol {\n    /// Returns the function name associated with this symbol.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it. Also note that the symbol is\n    /// frequently mangled, so you might need to run some form of demangling\n    /// over it.\n    pub fn name(&self) -> Option<&str> {\n        self.name.as_deref()\n    }\n\n    /// Returns the source code filename this symbol was defined in.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it.\n    pub fn file(&self) -> Option<&str> {\n        self.file.as_deref()\n    }\n\n    /// Returns the 1-indexed source code line number this symbol was defined\n    /// on.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it.\n    pub fn line(&self) -> Option<u32> {\n        self.line\n    }\n\n    /// Returns the 1-indexed source code column number this symbol was defined\n    /// on.\n    ///\n    /// Note that this may not be present with malformed debug information, or\n    /// the debug information may not include it.\n    pub fn column(&self) -> Option<u32> {\n        self.column\n    }\n}\n\n#[test]\nfn test_frame_info() -> Result<(), anyhow::Error> {\n    use crate::*;\n    let mut store = Store::<()>::default();\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (export \"add\") (param $x i32) (param $y i32) (result i32) (i32.add (local.get $x) (local.get $y)))\n                (func (export \"sub\") (param $x i32) (param $y i32) (result i32) (i32.sub (local.get $x) (local.get $y)))\n                (func (export \"mul\") (param $x i32) (param $y i32) (result i32) (i32.mul (local.get $x) (local.get $y)))\n                (func (export \"div_s\") (param $x i32) (param $y i32) (result i32) (i32.div_s (local.get $x) (local.get $y)))\n                (func (export \"div_u\") (param $x i32) (param $y i32) (result i32) (i32.div_u (local.get $x) (local.get $y)))\n                (func (export \"rem_s\") (param $x i32) (param $y i32) (result i32) (i32.rem_s (local.get $x) (local.get $y)))\n                (func (export \"rem_u\") (param $x i32) (param $y i32) (result i32) (i32.rem_u (local.get $x) (local.get $y)))\n            )\n         \"#,\n    )?;\n    // Create an instance to ensure the frame information is registered.\n    Instance::new(&mut store, &module, &[])?;\n\n    GlobalModuleRegistry::with(|modules| {\n        for (i, alloc) in module.compiled_module().finished_functions() {\n            let (start, end) = unsafe {\n                let ptr = (*alloc).as_ptr();\n                let len = (*alloc).len();\n                (ptr as usize, ptr as usize + len)\n            };\n            for pc in start..end {\n                let (frame, _, _) = modules.lookup_frame_info(pc).unwrap();\n                assert!(\n                    frame.func_index() == i.as_u32(),\n                    \"lookup of {:#x} returned {}, expected {}\",\n                    pc,\n                    frame.func_index(),\n                    i.as_u32()\n                );\n            }\n        }\n    });\n    Ok(())\n}\n"], "filenames": ["crates/wasmtime/src/module/registry.rs"], "buggy_code_start_loc": [125], "buggy_code_end_loc": [180], "fixing_code_start_loc": [124], "fixing_code_end_loc": [184], "type": "CWE-125", "message": "Wasmtime is an open source runtime for WebAssembly & WASI. In Wasmtime from version 0.26.0 and before version 0.30.0 is affected by a memory unsoundness vulnerability. There was an invalid free and out-of-bounds read and write bug when running Wasm that uses `externref`s in Wasmtime. To trigger this bug, Wasmtime needs to be running Wasm that uses `externref`s, the host creates non-null `externrefs`, Wasmtime performs a garbage collection (GC), and there has to be a Wasm frame on the stack that is at a GC safepoint where there are no live references at this safepoint, and there is a safepoint with live references earlier in this frame's function. Under this scenario, Wasmtime would incorrectly use the GC stack map for the safepoint from earlier in the function instead of the empty safepoint. This would result in Wasmtime treating arbitrary stack slots as `externref`s that needed to be rooted for GC. At the *next* GC, it would be determined that nothing was referencing these bogus `externref`s (because nothing could ever reference them, because they are not really `externref`s) and then Wasmtime would deallocate them and run `<ExternRef as Drop>::drop` on them. This results in a free of memory that is not necessarily on the heap (and shouldn't be freed at this moment even if it was), as well as potential out-of-bounds reads and writes. Even though support for `externref`s (via the reference types proposal) is enabled by default, unless you are creating non-null `externref`s in your host code or explicitly triggering GCs, you cannot be affected by this bug. We have reason to believe that the effective impact of this bug is relatively small because usage of `externref` is currently quite rare. This bug has been patched and users should upgrade to Wasmtime version 0.30.0. If you cannot upgrade Wasmtime at this time, you can avoid this bug by disabling the reference types proposal by passing `false` to `wasmtime::Config::wasm_reference_types`.", "other": {"cve": {"id": "CVE-2021-39218", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-17T21:15:07.417", "lastModified": "2021-12-10T20:06:31.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wasmtime is an open source runtime for WebAssembly & WASI. In Wasmtime from version 0.26.0 and before version 0.30.0 is affected by a memory unsoundness vulnerability. There was an invalid free and out-of-bounds read and write bug when running Wasm that uses `externref`s in Wasmtime. To trigger this bug, Wasmtime needs to be running Wasm that uses `externref`s, the host creates non-null `externrefs`, Wasmtime performs a garbage collection (GC), and there has to be a Wasm frame on the stack that is at a GC safepoint where there are no live references at this safepoint, and there is a safepoint with live references earlier in this frame's function. Under this scenario, Wasmtime would incorrectly use the GC stack map for the safepoint from earlier in the function instead of the empty safepoint. This would result in Wasmtime treating arbitrary stack slots as `externref`s that needed to be rooted for GC. At the *next* GC, it would be determined that nothing was referencing these bogus `externref`s (because nothing could ever reference them, because they are not really `externref`s) and then Wasmtime would deallocate them and run `<ExternRef as Drop>::drop` on them. This results in a free of memory that is not necessarily on the heap (and shouldn't be freed at this moment even if it was), as well as potential out-of-bounds reads and writes. Even though support for `externref`s (via the reference types proposal) is enabled by default, unless you are creating non-null `externref`s in your host code or explicitly triggering GCs, you cannot be affected by this bug. We have reason to believe that the effective impact of this bug is relatively small because usage of `externref` is currently quite rare. This bug has been patched and users should upgrade to Wasmtime version 0.30.0. If you cannot upgrade Wasmtime at this time, you can avoid this bug by disabling the reference types proposal by passing `false` to `wasmtime::Config::wasm_reference_types`."}, {"lang": "es", "value": "Wasmtime es un runtime de c\u00f3digo abierto para WebAssembly y WASI. En Wasmtime desde la versi\u00f3n 0.26.0 y versiones anteriores a 0.30.0, est\u00e1 afectado por una vulnerabilidad por falta de memoria. Se presentaba un error de lectura y escritura no v\u00e1lida y fuera de l\u00edmites cuando se ejecutaba Wasm que usa \"externref\"s en Wasmtime. Para desencadenar este fallo, Wasmtime necesita estar ejecutando Wasm que usa \"externref\"s, el host crea \"externrefs\" no nulos, Wasmtime lleva a cabo una recolecci\u00f3n de basura (GC), y tiene que presentar un marco Wasm en la pila que est\u00e1 en un punto de seguridad de GC donde no hay referencias vivas en este punto de seguridad, y presenta un punto de seguridad con referencias vivas antes en la funci\u00f3n de este marco. Bajo este escenario, Wasmtime usar\u00eda incorrectamente el mapa de pila de la GC para el punto de seguridad de antes en la funci\u00f3n en lugar del punto de seguridad vac\u00edo. Esto resultar\u00eda en que Wasmtime tratara ranuras de pila arbitrarias como \"externref\"s que deb\u00edan ser enraizadas para la GC. En la *next* GC, se determinar\u00eda que nada hac\u00eda referencia a estas falsas \"externref\"s (porque nada podr\u00eda hacer referencia a ellas, ya que no son realmente \"externref\"s) y entonces Wasmtime las desasignar\u00eda y ejecutar\u00eda \"(ExternRef as Drop)::drop\" sobre ellas. Esto resulta en una liberaci\u00f3n de memoria que no est\u00e1 necesariamente en la pila (y no deber\u00eda ser liberada en este momento incluso si lo estuviera), as\u00ed como potenciales lecturas y escrituras fuera de l\u00edmites. Aunque el soporte para \"externref\"s (por medio de la propuesta de tipos de referencia) est\u00e1 habilitado por defecto, a menos que est\u00e9s creando \"externref\"s no nulos en tu c\u00f3digo anfitri\u00f3n o activando expl\u00edcitamente GCs, no puedes ser afectado por este error. Tenemos razones para creer que el impacto efectivo de este bug es relativamente peque\u00f1o porque el uso de \"externref\" es actualmente bastante raro. Este bug ha sido parcheado y los usuarios deber\u00edan actualizar a la versi\u00f3n 0.30.0 de Wasmtime. Si no puedes actualizar Wasmtime en este momento, puedes evitar este bug al desactivar la propuesta de tipos de referencia pasando \"false\" a \"wasmtime::Config::wasm_reference_types\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-590"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:*:*", "versionStartIncluding": "0.26.0", "versionEndExcluding": "0.30.0", "matchCriteriaId": "9D31302E-6D4C-434D-ABF7-B898B206E1AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://crates.io/crates/wasmtime", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/bytecodealliance/wasmtime/commit/398a73f0dd862dbe703212ebae8e34036a18c11c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bytecodealliance/wasmtime/commit/398a73f0dd862dbe703212ebae8e34036a18c11c"}}