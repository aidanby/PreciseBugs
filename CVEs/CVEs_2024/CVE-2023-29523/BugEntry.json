{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.lang.ref.SoftReference;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.inject.Provider;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.ObjectUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.dom.DOMDocument;\nimport org.dom4j.io.DocumentResult;\nimport org.dom4j.io.OutputFormat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.Diff;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.Revision;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.suigeneris.jrcs.util.ToString;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContextException;\nimport org.xwiki.context.ExecutionContextManager;\nimport org.xwiki.display.internal.DocumentDisplayer;\nimport org.xwiki.display.internal.DocumentDisplayerParameters;\nimport org.xwiki.filter.input.DefaultInputStreamInputSource;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.filter.input.StringInputSource;\nimport org.xwiki.filter.instance.input.DocumentInstanceInputProperties;\nimport org.xwiki.filter.instance.output.DocumentInstanceOutputProperties;\nimport org.xwiki.filter.output.DefaultOutputStreamOutputTarget;\nimport org.xwiki.filter.output.DefaultWriterOutputTarget;\nimport org.xwiki.filter.output.OutputTarget;\nimport org.xwiki.filter.xar.input.XARInputProperties;\nimport org.xwiki.filter.xar.output.XAROutputProperties;\nimport org.xwiki.filter.xml.output.DefaultResultOutputTarget;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.link.LinkException;\nimport org.xwiki.link.LinkStore;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.document.DefaultDocumentAuthors;\nimport org.xwiki.model.internal.reference.DefaultSymbolScheme;\nimport org.xwiki.model.internal.reference.EntityReferenceFactory;\nimport org.xwiki.model.internal.reference.LocalStringEntityReferenceSerializer;\nimport org.xwiki.model.internal.reference.LocalUidStringEntityReferenceSerializer;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectPropertyReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.ObjectReferenceResolver;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.MacroBlock;\nimport org.xwiki.rendering.block.SectionBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.block.match.MacroBlockMatcher;\nimport org.xwiki.rendering.internal.parser.LinkParser;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.parser.ContentParser;\nimport org.xwiki.rendering.parser.MissingParserException;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.parser.Parser;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.renderer.printer.DefaultWikiPrinter;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxRegistry;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationException;\nimport org.xwiki.rendering.transformation.TransformationManager;\nimport org.xwiki.rendering.util.ErrorBlockGenerator;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.store.TemporaryAttachmentSessionsManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.store.merge.MergeManager;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.xar.internal.model.XarDocumentModel;\nimport org.xwiki.xml.XMLUtils;\nimport org.xwiki.xml.html.HTMLUtils;\n\nimport com.xpn.xwiki.CoreConfiguration;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.criteria.impl.RevisionCriteria;\nimport com.xpn.xwiki.doc.merge.MergeConfiguration;\nimport com.xpn.xwiki.doc.merge.MergeResult;\nimport com.xpn.xwiki.doc.rcs.XWikiRCSNodeInfo;\nimport com.xpn.xwiki.internal.cache.rendering.RenderingCache;\nimport com.xpn.xwiki.internal.doc.BaseObjects;\nimport com.xpn.xwiki.internal.doc.XWikiAttachmentList;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterUtils;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.xml.DOMXMLWriter;\nimport com.xpn.xwiki.internal.xml.XMLWriter;\nimport com.xpn.xwiki.objects.BaseCollection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseObjectReference;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.LargeStringProperty;\nimport com.xpn.xwiki.objects.ListProperty;\nimport com.xpn.xwiki.objects.ObjectDiff;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.ListClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.classes.StaticListClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateAttachmentStore;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.validation.XWikiValidationInterface;\nimport com.xpn.xwiki.validation.XWikiValidationStatus;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.ObjectAddForm;\nimport com.xpn.xwiki.web.ObjectPolicyType;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiRequest;\n\npublic class XWikiDocument implements DocumentModelBridge, Cloneable\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiDocument.class);\n\n    private static final String TM_FAILEDDOCUMENTPARSE = \"core.document.error.failedParse\";\n\n    /**\n     * An attachment waiting to be deleted at next document save.\n     *\n     * @version $Id$\n     * @since 5.2M1\n     */\n    public static class XWikiAttachmentToRemove\n    {\n        /**\n         * @see #getAttachment()\n         */\n        private XWikiAttachment attachment;\n\n        /**\n         * @see #isToRecycleBin()\n         */\n        private boolean toRecycleBin;\n\n        /**\n         * @param attachment the attachment to delete\n         * @param toRecycleBin true of the attachment should be moved to the recycle bin\n         */\n        public XWikiAttachmentToRemove(XWikiAttachment attachment, boolean toRecycleBin)\n        {\n            this.attachment = attachment;\n            this.toRecycleBin = toRecycleBin;\n        }\n\n        /**\n         * @return the attachment to delete\n         */\n        public XWikiAttachment getAttachment()\n        {\n            return this.attachment;\n        }\n\n        /**\n         * @return true of the attachment should be moved to the recycle bin\n         */\n        public boolean isToRecycleBin()\n        {\n            return this.toRecycleBin;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return this.attachment.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (obj instanceof XWikiAttachmentToRemove) {\n                return this.attachment.equals(((XWikiAttachmentToRemove) obj).getAttachment());\n            }\n\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return this.attachment.toString();\n        }\n    }\n\n    /**\n     * Regex Pattern to recognize if there's HTML code in a XWiki page.\n     */\n    private static final Pattern HTML_TAG_PATTERN = Pattern.compile(\n        \"</?+(html|img|a|i|br?|embed|script|form|input|textarea|object|font|li|[dou]l|table|center|hr|p) ?([^>]*+)>\");\n\n    public static final EntityReference COMMENTSCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"XWikiComments\");\n\n    public static final EntityReference SHEETCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"SheetClass\");\n\n    public static final int HAS_ATTACHMENTS = 1;\n\n    public static final int HAS_OBJECTS = 2;\n\n    public static final int HAS_CLASS = 4;\n\n    /**\n     * The name of the key in the XWikiContext which contains the document used to check for programming rights.\n     */\n    public static final String CKEY_SDOC = \"sdoc\";\n\n    /**\n     * Separator string between database name and space name.\n     */\n    public static final String DB_SPACE_SEP = \":\";\n\n    /**\n     * Separator string between space name and page name.\n     */\n    public static final String SPACE_NAME_SEP = \".\";\n\n    private static final LocalStringEntityReferenceSerializer LOCAL_REFERENCE_SERIALIZER =\n        new LocalStringEntityReferenceSerializer(new DefaultSymbolScheme());\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks.\n     */\n    private static DocumentReferenceResolver<String> getCurrentDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<ResourceReference> getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class, ResourceReference.class));\n    }\n\n    private static EntityReferenceResolver<String> getXClassEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"xclass\");\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private static DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to resolve parent references in the way they are stored externally (database, xml, etc), ie relative or\n     * absolute.\n     */\n    private static EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static ObjectReferenceResolver<EntityReference> getCurrentReferenceObjectReferenceResolver()\n    {\n        return Utils.getComponent(ObjectReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to convert a syntax defined as String into a Syntax object.\n     */\n    private static SyntaxRegistry getSyntaxRegistry()\n    {\n        return Utils.getComponent(SyntaxRegistry.class);\n    }\n\n    /**\n     * Used to retrieve backlinks from an XDOM.\n     */\n    private static LinkParser getLinkParser() {\n        return Utils.getComponent(LinkParser.class);\n    }\n\n    /**\n     * @return the user module configuration, used for instance to determine where users are stored\n     */\n    private static UserConfiguration getUserConfiguration()\n    {\n        return Utils.getComponent(UserConfiguration.class);\n    }\n\n    private String title;\n\n    /**\n     * Reference to this document's parent.\n     * <p>\n     * Note that we're saving the parent reference as a relative reference instead of an absolute one because We want\n     * the ability (for example) to create a parent reference relative to the current space or wiki so that a copy of\n     * this XWikiDocument object would retain that relativity. This is for example useful when copying a Wiki into\n     * another Wiki so that the copied XWikiDcoument's parent reference points to the new wiki.\n     */\n    private EntityReference parentReference;\n\n    private DocumentReference documentReference;\n\n    private String content;\n\n    private String meta;\n\n    private String format;\n\n    private String customClass;\n\n    private Date contentUpdateDate;\n\n    private Date updateDate;\n\n    private Date creationDate;\n\n    protected Version version;\n\n    private long id = 0;\n\n    private boolean mostRecent = true;\n\n    private boolean isNew = true;\n\n    /**\n     * The reference to the document that is the template for the current document.\n     *\n     * @todo this field is not used yet since it's not currently saved in the database.\n     */\n    private DocumentReference templateDocumentReference;\n\n    private Locale locale;\n\n    private Locale defaultLocale;\n\n    /**\n     * Indicates whether the document is 'hidden', meaning that it should not be returned in public search results.\n     * WARNING: this is a temporary hack until the new data model is designed and implemented. No code should rely on or\n     * use this property, since it will be replaced with a generic metadata.\n     */\n    private boolean hidden = false;\n\n    /**\n     * Comment on the latest modification.\n     */\n    private String comment;\n\n    /**\n     * Wiki syntax supported by this document. This is used to support different syntaxes inside the same wiki. For\n     * example a page can use the MediaWiki 1.0 syntax while another one uses the XWiki 2.1 syntax.\n     */\n    private Syntax syntax;\n\n    /**\n     * Is latest modification a minor edit.\n     */\n    private boolean isMinorEdit = false;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isContentDirty = true;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isMetaDataDirty = true;\n\n    private int elements = HAS_OBJECTS | HAS_ATTACHMENTS;\n\n    // Meta Data\n    private BaseClass xClass;\n\n    private String xClassXML;\n\n    /**\n     * Map holding document objects indexed by XClass references (i.e. Document References since a XClass reference\n     * points to a document). The preserve index ordering (consistent sorted order for output to XML, rendering in\n     * velocity, etc.)\n     */\n    private Map<DocumentReference, BaseObjects> xObjects = new ConcurrentSkipListMap<>();\n\n    /**\n     * The publicly exposed Map.\n     */\n    private Map<DocumentReference, List<BaseObject>> publicXObjects = new Map<DocumentReference, List<BaseObject>>()\n    {\n        @Override\n        public List<BaseObject> put(DocumentReference key, List<BaseObject> value)\n        {\n            // Makes sure to always insert BaseObjects\n            return xObjects.put(key, value instanceof BaseObjects ? (BaseObjects) value : new BaseObjects(value));\n        }\n\n        @Override\n        public void putAll(Map<? extends DocumentReference, ? extends List<BaseObject>> m)\n        {\n            m.forEach(this::put);\n        }\n\n        @Override\n        public int size()\n        {\n            return xObjects.size();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return xObjects.isEmpty();\n        }\n\n        @Override\n        public boolean containsKey(Object key)\n        {\n            return xObjects.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(Object value)\n        {\n            return xObjects.containsValue(value);\n        }\n\n        @Override\n        public List<BaseObject> get(Object key)\n        {\n            return xObjects.get(key);\n        }\n\n        @Override\n        public List<BaseObject> remove(Object key)\n        {\n            return xObjects.remove(key);\n        }\n\n        @Override\n        public void clear()\n        {\n            xObjects.clear();            \n        }\n\n        @Override\n        public Set<DocumentReference> keySet()\n        {\n            return xObjects.keySet();\n        }\n\n        @Override\n        public Collection<List<BaseObject>> values()\n        {\n            return (Collection) xObjects.values();\n        }\n\n        @Override\n        public Set<Entry<DocumentReference, List<BaseObject>>> entrySet()\n        {\n            return (Set) xObjects.entrySet();\n        }\n    };\n\n    private final XWikiAttachmentList attachmentList = new XWikiAttachmentList(XWikiDocument.this);\n\n    // Caching\n    private boolean fromCache = false;\n\n    private List<BaseObject> xObjectsToRemove = new ArrayList<BaseObject>();\n\n    private List<XWikiAttachmentToRemove> attachmentsToRemove = new ArrayList<XWikiAttachmentToRemove>();\n\n    /**\n     * The view template (vm file) to use. When not set the default view template is used.\n     *\n     * @see com.xpn.xwiki.web.ViewAction#render(XWikiContext)\n     */\n    private String defaultTemplate;\n\n    private String validationScript;\n\n    private Object wikiNode;\n\n    /**\n     * We are using a SoftReference which will allow the archive to be discarded by the Garbage collector as long as the\n     * context is closed (usually during the request)\n     */\n    private SoftReference<XWikiDocumentArchive> archive;\n\n    private XWikiStoreInterface store;\n\n    /**\n     * @see #getOriginalDocument()\n     */\n    private XWikiDocument originalDocument;\n\n    /**\n     * Used to display the title and the content of this document. Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private DocumentDisplayer documentDisplayer;\n\n    /**\n     * @see #getDefaultEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * @see #getExplicitDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<String> explicitDocumentReferenceResolver;\n\n    /**\n     * @see #getExplicitReferenceDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<EntityReference> explicitReferenceDocumentReferenceResolver;\n\n    /**\n     * @see #getPageReferenceResolver()\n     */\n    private PageReferenceResolver<EntityReference> pageReferenceResolver;\n\n    /**\n     * @see #getUidStringEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> uidStringEntityReferenceSerializer;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private JobProgressManager progress;\n\n    private ContextualLocalizationManager localization;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private EntityReferenceFactory entityReferenceFactory;\n\n    /**\n     * The document structure expressed as a tree of Block objects. We store it for performance reasons since parsing is\n     * a costly operation that we don't want to repeat whenever some code ask for the XDOM information.\n     */\n    private XDOM xdomCache;\n\n    /**\n     * Use to store rendered documents in #getRenderedContent(). Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private RenderingCache renderingCache;\n\n    /**\n     * Cache the parent reference resolved as an absolute reference for improved performance (so that we don't have to\n     * resolve the relative reference every time getParentReference() is called.\n     */\n    private DocumentReference parentReferenceCache;\n\n    /**\n     * Cache the document reference with locale resolved kept for improved performance (so that we don't have to resolve\n     * it every time getPageReference() is called.\n     */\n    private DocumentReference documentReferenceWithLocaleCache;\n\n    /**\n     * Cache the page reference resolved kept for improved performance (so that we don't have to resolve it every time\n     * getPageReference() is called.\n     */\n    private PageReference pageReferenceCache;\n\n    /**\n     * Cache the page reference with locale resolved kept for improved performance (so that we don't have to resolve it\n     * every time getPageReference() is called.\n     */\n    private PageReference pageReferenceWithLocaleCache;\n\n    /**\n     * @see #getKey()\n     */\n    private String keyCache;\n\n    /**\n     * @see #getLocalKey()\n     */\n    private String localKeyCache;\n\n    private RenderingContext renderingContext;\n\n    /**\n     * @see #getAuthors()\n     */\n    private final DefaultDocumentAuthors authors = new DefaultDocumentAuthors(this);\n\n    /**\n     * Create a document for the given reference, with the {@link Locale#ROOT} even if the reference contains a locale.\n     * If you want to create a document for another locale, use {@link #XWikiDocument(DocumentReference, Locale)}.\n     * @since 2.2M1\n     */\n    public XWikiDocument(DocumentReference reference)\n    {\n        init(reference);\n    }\n\n    /**\n     * @since 6.2\n     */\n    public XWikiDocument(DocumentReference reference, Locale locale)\n    {\n        init(reference);\n\n        this.locale = locale;\n    }\n\n    /**\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument()\n    {\n        this(null);\n    }\n\n    /**\n     * Constructor that specifies the local document identifier: space name, document name. {@link #setDatabase(String)}\n     * must be called afterwards to specify the wiki name.\n     *\n     * @param space the space this document belongs to\n     * @param name the name of the document\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String space, String name)\n    {\n        this(null, space, name);\n    }\n\n    /**\n     * Constructor that specifies the full document identifier: wiki name, space name, document name.\n     *\n     * @param wiki The wiki this document belongs to.\n     * @param space The space this document belongs to.\n     * @param name The name of the document (can contain either the page name or the space and page name)\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String wiki, String space, String name)\n    {\n        // We allow to specify the space in the name (eg name = \"space.page\"). In this case the passed space is\n        // ignored.\n\n        // Build an entity reference that will serve as a current context reference against which to resolve if the\n        // passed name doesn't contain a space.\n        EntityReference contextReference = null;\n        if (!StringUtils.isEmpty(space)) {\n            contextReference = new EntityReference(space, EntityType.SPACE);\n        }\n\n        DocumentReference reference = getCurrentDocumentReferenceResolver().resolve(name, contextReference);\n\n        if (!StringUtils.isEmpty(wiki)) {\n            reference = reference.replaceParent(reference.getWikiReference(), new WikiReference(wiki));\n        }\n\n        init(reference);\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference.\n     */\n    private DocumentReferenceResolver<String> getExplicitDocumentReferenceResolver()\n    {\n        if (this.explicitDocumentReferenceResolver == null) {\n            this.explicitDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"explicit\");\n        }\n\n        return this.explicitDocumentReferenceResolver;\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private DocumentReferenceResolver<EntityReference> getExplicitReferenceDocumentReferenceResolver()\n    {\n        if (this.explicitReferenceDocumentReferenceResolver == null) {\n            this.explicitReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"explicit\");\n        }\n\n        return this.explicitReferenceDocumentReferenceResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getPageReferenceResolver()\n    {\n        if (this.pageReferenceResolver == null) {\n            this.pageReferenceResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE);\n        }\n\n        return this.pageReferenceResolver;\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    /**\n     * Used to compute document identifier.\n     */\n    private EntityReferenceSerializer<String> getUidStringEntityReferenceSerializer()\n    {\n        if (this.uidStringEntityReferenceSerializer == null) {\n            this.uidStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"uid\");\n        }\n\n        return this.uidStringEntityReferenceSerializer;\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private EntityReferenceFactory getEntityReferenceFactory()\n    {\n        if (this.entityReferenceFactory == null && Utils.getRootComponentManager() != null) {\n            try {\n                this.entityReferenceFactory = Utils.getRootComponentManager().getInstance(EntityReferenceFactory.class);\n            } catch (ComponentLookupException e) {\n                // Not a big deal\n            }\n        }\n\n        return this.entityReferenceFactory;\n    }\n\n    private <E extends EntityReference> E intern(E reference)\n    {\n        EntityReferenceFactory factory = getEntityReferenceFactory();\n\n        return factory != null ? factory.getReference(reference) : reference;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    private UserReferenceSerializer<DocumentReference> getUserReferenceDocumentReferenceSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceResolver<DocumentReference> getUserReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceStringSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING);\n    }\n\n    private UserReferenceResolver<String> getUserReferenceStringResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_STRING);\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceCompactWikiSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING, \"compactwiki/document\");\n    }\n\n    private LinkStore getLinkStore()\n    {\n        return Utils.getComponent(LinkStore.class);        \n    }\n\n    public XWikiStoreInterface getStore(XWikiContext context)\n    {\n        return context.getWiki().getStore();\n    }\n\n    /**\n     * @deprecated use {@link XWiki#getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public XWikiAttachmentStoreInterface getAttachmentStore(XWikiContext context)\n    {\n        return context.getWiki().getAttachmentStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore(XWikiContext context)\n    {\n        return context.getWiki().getVersioningStore();\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    /**\n     * Helper to produce and cache a local uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (in a wiki) (5:space4:name2:lg)\n     */\n    private String getLocalKey()\n    {\n        if (this.localKeyCache == null) {\n            this.localKeyCache =\n                LocalUidStringEntityReferenceSerializer.INSTANCE.serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.localKeyCache;\n    }\n\n    /**\n     * Helper to produce and cache a uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (8:wikiname5:space4:name2:lg or 8:wikiname5:space4:name)\n     * @since 4.0M1\n     */\n    public String getKey()\n    {\n        if (this.keyCache == null) {\n            this.keyCache = getUidStringEntityReferenceSerializer().serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.keyCache;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int) Util.getHash(getLocalKey());\n    }\n\n    /**\n     * @return the unique id used to represent the document, as a number. This id is technical and is equivalent to the\n     *         Document Reference + the language of the Document. This technical id should only be used for the storage\n     *         layer and all user APIs should instead use Document Reference and language as they are model-related\n     *         while the id isn't (it's purely technical).\n     */\n    public long getId()\n    {\n        // TODO: Ensure uniqueness of the generated id\n        // The implementation doesn't guarantee a unique id since it uses a hashing method which never guarantee\n        // uniqueness. However, the hash algorithm is really unlikely to collide in a given wiki. This needs to be\n        // fixed to produce a real unique id since otherwise we can have clashes in the database.\n\n        // Note: We don't use the wiki name in the document id's computation. The main historical reason is so\n        // that all things saved in a given wiki's database are always stored relative to that wiki so that\n        // changing that wiki's name is simpler.\n\n        this.id = Util.getHash(getLocalKey());\n\n        return this.id;\n    }\n\n    /**\n     * @see #getId()\n     */\n    public void setId(long id)\n    {\n        this.id = id;\n    }\n\n    /**\n     * Return the full local space reference. For example a document located in sub-space <code>space11</code> of space\n     * <code>space1</code> will return <code>space1.space11</code>.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the local reference the space of the document as String\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getSpace()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference());\n    }\n\n    /**\n     * Set the full local space reference.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @see #getSpace()\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setSpace(String spaces)\n    {\n        if (spaces != null) {\n            DocumentReference reference = getDocumentReference();\n            EntityReference spaceReference = getRelativeEntityReferenceResolver().resolve(spaces, EntityType.SPACE);\n            spaceReference = spaceReference.appendParent(getDocumentReference().getWikiReference());\n            setDocumentReferenceInternal(\n                new DocumentReference(reference.getName(), new SpaceReference(spaceReference)));\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the name of the space of the document\n     * @see #getSpace()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    public String getWeb()\n    {\n        return getSpace();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated\n    public void setWeb(String space)\n    {\n        setSpace(space);\n    }\n\n    @Override\n    public String getVersion()\n    {\n        return getRCSVersion().toString();\n    }\n\n    public void setVersion(String version)\n    {\n        if (!StringUtils.isEmpty(version)) {\n            this.version = new Version(version);\n        }\n    }\n\n    public Version getRCSVersion()\n    {\n        if (this.version == null) {\n            return new Version(\"1.1\");\n        }\n        return this.version;\n    }\n\n    public void setRCSVersion(Version version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * @return the copy of this XWikiDocument instance before any modification was made to it. This copy is used for\n     *         finding out differences made to this document (useful for example to send the correct notifications to\n     *         document change listeners).\n     */\n    @Override\n    public XWikiDocument getOriginalDocument()\n    {\n        return this.originalDocument;\n    }\n\n    /**\n     * @param originalDocument the original document representing this document instance before any change was made to\n     *            it, prior to the last time it was saved\n     * @see #getOriginalDocument()\n     */\n    public void setOriginalDocument(XWikiDocument originalDocument)\n    {\n        this.originalDocument = originalDocument;\n    }\n\n    /**\n     * @return the parent reference or null if the parent is not set\n     * @since 2.2M1\n     */\n    public DocumentReference getParentReference()\n    {\n        // Ensure we always return absolute document references for the parent since we always want well-constructed\n        // references and since we store the parent reference as relative internally.\n        if (this.parentReferenceCache == null && getRelativeParentReference() != null) {\n            this.parentReferenceCache = intern(getExplicitReferenceDocumentReferenceResolver()\n                .resolve(getRelativeParentReference(), getDocumentReference()));\n        }\n\n        return this.parentReferenceCache;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the parent reference stored in the database, which is relative to this document, or an empty string (\"\")\n     *         if the parent is not set\n     * @see #getParentReference()\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getParent()\n    {\n        String parentReferenceAsString;\n        if (getParentReference() != null) {\n            parentReferenceAsString = getDefaultEntityReferenceSerializer().serialize(getRelativeParentReference());\n        } else {\n            parentReferenceAsString = \"\";\n        }\n        return parentReferenceAsString;\n    }\n\n    /**\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument getParentDoc()\n    {\n        return new XWikiDocument(getParentReference());\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setParentReference(EntityReference parentReference)\n    {\n        if (!Objects.equals(getRelativeParentReference(), parentReference)) {\n            this.parentReference = intern(parentReference);\n\n            // Clean the absolute parent reference cache to rebuild it next time getParentReference is called.\n            this.parentReferenceCache = null;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @param parent the reference of the parent relative to the document\n     * @deprecated use {@link #setParentReference(EntityReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setParent(String parent)\n    {\n        // If the passed parent is an empty string we also need to set the reference to null. The reason is that\n        // in the database we store \"\" when the parent is empty and thus when Hibernate loads this class it'll call\n        // setParent with \"\" if the parent had not been set when saved.\n        if (StringUtils.isEmpty(parent)) {\n            setParentReference((EntityReference) null);\n        } else {\n            setParentReference(getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT));\n        }\n    }\n\n    @Override\n    public String getContent()\n    {\n        return this.content;\n    }\n\n    public void setContent(String content)\n    {\n        if (content == null) {\n            content = \"\";\n        }\n\n        boolean notEqual = !content.equals(this.content);\n\n        this.content = content;\n\n        if (notEqual) {\n            // invalidate parsed xdom\n            this.xdomCache = null;\n            setContentDirty(true);\n            setWikiNode(null);\n        }\n    }\n\n    public void setContent(XDOM content) throws XWikiException\n    {\n        setContent(renderXDOM(content, getSyntax()));\n    }\n\n    /**\n     * @return the default rendering cache\n     */\n    private RenderingCache getRenderingCache()\n    {\n        if (this.renderingCache == null) {\n            this.renderingCache = Utils.getComponent((Type) RenderingCache.class);\n        }\n        return this.renderingCache;\n    }\n\n    /**\n     * @return the configured document displayer\n     */\n    private DocumentDisplayer getDocumentDisplayer()\n    {\n        if (this.documentDisplayer == null) {\n            this.documentDisplayer = Utils.getComponent((Type) DocumentDisplayer.class, \"configured\");\n        }\n        return this.documentDisplayer;\n    }\n\n    private Syntax getOutputSyntax()\n    {\n        return getRenderingContext().getTargetSyntax();\n    }\n\n    /**\n     * Parse, execute and render the document.\n     * \n     * @param targetSyntax the syntax to use to render the document\n     * @param executionContextIsolated see {@link DocumentDisplayerParameters#isExecutionContextIsolated()}\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see\n     *            {@link DocumentDisplayerParameters#isTransformationContextRestricted()}\n     * @param translate get translated content of the document\n     * @return the result of the document execution rendered in the passed syntax\n     * @throws XWikiException when failing to display the document\n     */\n    private String display(Syntax targetSyntax, boolean executionContextIsolated, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, boolean translate) throws XWikiException\n    {\n        // Note: We are currently duplicating code from getRendered signature because some calling\n        // code is expecting that the rendering will happen in the calling document's context and not in this\n        // document's context. For example this is true for the Admin page, see\n        // https://jira.xwiki.org/browse/XWIKI-4274 for more details.\n\n        getProgress().startStep(this, \"document.progress.render\", \"Render document [{}] in syntax [{}]\",\n            getDocumentReference(), targetSyntax);\n\n        try {\n            getProgress().pushLevelProgress(3, getDocumentReference());\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.translatedcontent\",\n                \"Get translated content\");\n\n            XWikiContext xcontext = getXWikiContext();\n\n            XWikiDocument tdoc = translate ? getTranslatedDocument(xcontext) : this;\n            String translatedContent = tdoc.getContent();\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.cache\",\n                \"Try to get content from the cache\");\n\n            String renderedContent = getRenderingCache().getRenderedContent(tdoc.getDocumentReferenceWithLocale(),\n                translatedContent, xcontext);\n\n            if (renderedContent == null) {\n                getProgress().startStep(getDocumentReference(), \"document.progress.render.execute\", \"Execute content\");\n\n                // Configure display\n                DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n                parameters.setExecutionContextIsolated(executionContextIsolated);\n                parameters.setTransformationContextIsolated(transformationContextIsolated);\n                parameters.setTransformationContextRestricted(transformationContextRestricted);\n                // Render the translated content (matching the current language) using this document's syntax.\n                parameters.setContentTranslated(tdoc != this);\n                parameters.setTargetSyntax(targetSyntax);\n\n                // Execute display\n                XDOM contentXDOM = getDocumentDisplayer().display(this, parameters);\n\n                // Render the result\n                renderedContent = renderXDOM(contentXDOM, targetSyntax);\n\n                getRenderingCache().setRenderedContent(getDocumentReference(), translatedContent, renderedContent,\n                    xcontext);\n            }\n\n            return renderedContent;\n        } finally {\n            getProgress().popLevelProgress(getDocumentReference());\n            getProgress().endStep(this);\n        }\n    }\n\n    public String getRenderedContent(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, context);\n    }\n\n    /**\n     * @since 8.4RC1\n     */\n    public String getRenderedContent(boolean transformationContextIsolated, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), transformationContextIsolated, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), restricted, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, false, context, false);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(Syntax targetSyntax, boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, restricted, context, false);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     * The translations are retrieved if they exist and based on XWiki preferences\n     * (see {@link #getTranslatedDocument(XWikiContext)}).\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    public String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated, XWikiContext context)\n        throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, transformationContextIsolated, false, context, true);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     *\n     * @param targetSyntax the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @param retrieveTranslation if true retrieve the translation of the document according to the preferences (see\n     *  {@link #getTranslatedDocument(XWikiContext)}). If false, render the current document.\n     * @return the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    private String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, XWikiContext context, boolean retrieveTranslation)\n        throws XWikiException\n    {\n        // Make sure the context secure document is the current document so that it's executed with its own\n        // rights\n        Object currentSdoc = context.get(\"sdoc\");\n        try {\n            XWikiDocument sdoc;\n\n            if (retrieveTranslation) {\n                sdoc = getTranslatedDocument(context);\n            } else {\n                sdoc = this;\n            }\n            context.put(\"sdoc\", sdoc);\n\n            return display(targetSyntax, false, transformationContextIsolated, transformationContextRestricted,\n                retrieveTranslation);\n        } finally {\n            context.put(\"sdoc\", currentSdoc);\n        }\n    }\n\n    public String getRenderedContent(XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 1.6M1\n     */\n    public String getRenderedContent(String text, String syntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            sDocument, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 2.0M3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, restrictedTransformationContext, null, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, XWikiContext context)\n    {\n        try {\n            return getRenderedContent(text, Syntax.valueOf(sourceSyntaxId), Syntax.valueOf(targetSyntaxId),\n                restrictedTransformationContext, sDocument, true, context);\n        } catch (ParseException e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        }\n\n        return \"\";\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, XWikiDocument sDocument, boolean isolated,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), false, sDocument, isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 14.10\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), restrictedTransformationContext, sDocument,\n            isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, Syntax targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        Map<String, Object> backup = null;\n\n        getProgress().startStep(this, \"document.progress.renderText\",\n            \"Execute content [{}] in the context of document [{}]\",\n            StringUtils.substring(text, 0, 100) + (text.length() >= 100 ? \"...\" : \"\"), getDocumentReference());\n\n        XWikiDocument currentSDocument = (XWikiDocument) context.get(CKEY_SDOC);\n        try {\n            // We have to render the given text in the context of this document. Check if this document is already\n            // on the context (same Java object reference). We don't check if the document references are equal\n            // because this document can have temporary changes that are not present on the context document even if\n            // it has the same document reference.\n            if (isolated && context.getDoc() != this) {\n                backup = new HashMap<>();\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute the document with the right of the provided sdocument's author\n            if (sDocument != null) {\n                context.put(CKEY_SDOC, sDocument);\n            }\n\n            // Reuse this document's reference so that the Velocity macro name-space is computed based on it.\n            XWikiDocument fakeDocument = new XWikiDocument(getDocumentReference());\n            fakeDocument.setSyntax(sourceSyntaxId);\n            fakeDocument.setContent(text);\n\n            // We don't let displayer take care of the context isolation because we don't want the fake document to be\n            // context document\n            return fakeDocument.display(targetSyntaxId, false, isolated, restrictedTransformationContext,\n                false);\n        } catch (Exception e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        } finally {\n            if (backup != null) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDocument);\n\n            getProgress().endStep(this);\n        }\n\n        return \"\";\n    }\n\n    public String getEscapedContent(XWikiContext context) throws XWikiException\n    {\n        return XMLUtils.escape(getTranslatedContent(context));\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getName()\n    {\n        return getDocumentReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setName(String name)\n    {\n        if (name != null) {\n            DocumentReference reference = getDocumentReference();\n            // TODO: ensure that other parameters are copied properly\n            setDocumentReferenceInternal(\n                new DocumentReference(name, new SpaceReference(reference.getParent()), reference.getLocale()));\n        }\n    }\n\n    @Override\n    public DocumentReference getDocumentReference()\n    {\n        return this.documentReference;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReference()\n    {\n        if (this.pageReferenceCache == null) {\n            this.pageReferenceCache = intern(getPageReferenceResolver().resolve(getDocumentReference()));\n        }\n\n        return this.pageReferenceCache;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} including the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReferenceWithLocale()\n    {\n        if (this.pageReferenceWithLocaleCache == null) {\n            this.pageReferenceWithLocaleCache = intern(new PageReference(getPageReference(), getLocale()));\n        }\n\n        return this.pageReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the {@link DocumentReference} of the document also containing the document {@link Locale}\n     * @since 5.3M2\n     */\n    public DocumentReference getDocumentReferenceWithLocale()\n    {\n        if (this.documentReferenceWithLocaleCache == null) {\n            this.documentReferenceWithLocaleCache = intern(new DocumentReference(this.documentReference, getLocale()));\n        }\n\n        return this.documentReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the document's space + page name (eg \"space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getFullName()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference());\n    }\n\n    /**\n     * @return the docoument's wiki + space + page name (eg \"wiki:space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getPrefixedFullName()\n    {\n        return getDefaultEntityReferenceSerializer().serialize(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated don't change the reference of a document once it's been constructed. Instead you can\n     *             clone the doc, rename it or copy it.\n     */\n    @Deprecated(since = \"2.2.3\")\n    public void setDocumentReference(DocumentReference reference)\n    {\n        // Don't allow setting a null reference for now, ie. don't do anything to preserve backward compatibility\n        // with previous behavior (i.e. {@link #setFullName}.\n        if (reference != null) {\n            // Retro compatibility, make sure <code>this.documentReference</code> does not contain the Locale (for now)\n            DocumentReference referenceWithoutLocale =\n                reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference;\n\n            if (!referenceWithoutLocale.equals(getDocumentReference())) {\n                setDocumentReferenceInternal(referenceWithoutLocale);\n            }\n        }\n    }\n\n    private void setDocumentReferenceInternal(DocumentReference reference)\n    {\n        this.documentReference = intern(reference);\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.parentReferenceCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String name)\n    {\n        setFullName(name, null);\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String fullName, XWikiContext context)\n    {\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors and to be\n        // consistent with {@link #setName} and {@link #setSpace}.\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            setDocumentReference(getCurrentMixedDocumentReferenceResolver().resolve(fullName));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getWikiName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getWikiName()\n    {\n        return getDatabase();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getSpaceName()\n    {\n        return this.getSpace();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getPageName()\n    {\n        return this.getName();\n    }\n\n    @Override\n    public String getTitle()\n    {\n        return (this.title != null) ? this.title : \"\";\n    }\n\n    /**\n     * Get the rendered version of the document title. The title is extracted and then Velocity is applied on it and\n     * it's then rendered using the passed Syntax. The following logic is used to extract the title:\n     * <ul>\n     * <li>If a Sheet is specified for the document and this Sheet document contains a non empty title then it's\n     * used</li>\n     * <li>If not and the document's title is specified then it's used</li>\n     * <li>If not and if the title compatibility mode is turned on ({@code xwiki.title.compatibility=1} in\n     * {@code xwiki.cfg}) then an attempt is made to extract the title from the first heading found in the document's\n     * content</li>\n     * <li>If not, then at last resort the page name is returned</li>\n     * </ul>\n     *\n     * @param outputSyntax the syntax to render to; this is not taken into account for XWiki 1.0 syntax\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(Syntax outputSyntax, XWikiContext context)\n    {\n        DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n        parameters.setTitleDisplayed(true);\n        parameters.setExecutionContextIsolated(true);\n        parameters.setTargetSyntax(outputSyntax);\n        try {\n            XDOM titleXDOM = getDocumentDisplayer().display(this, parameters);\n            return renderXDOM(titleXDOM, outputSyntax);\n        } catch (Exception e) {\n            // We've failed to extract the Document's title or to render it. We log an error but we use the page name\n            // as the returned title in order to not generate errors in lots of places in the wiki (e.g. Activity\n            // Stream, menus, etc). The title is used in a lots of places...\n            LOGGER.error(\"Failed to render title for [{}]\", getDocumentReference(), e);\n            return getDocumentReference().getName();\n        }\n    }\n\n    /**\n     * Similar to {@link #getRenderedTitle(Syntax, XWikiContext)} but the output Syntax used is XHTML 1.0 unless the\n     * current skin defines another output Syntax in which case it's the one used.\n     *\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(XWikiContext context)\n    {\n        return getRenderedTitle(getOutputSyntax(), context);\n    }\n\n    public void setTitle(String title)\n    {\n        if (title != null && !title.equals(this.title)) {\n            // Document titles usually contain velocity script, so it is not enough to set the metadata dirty, since we\n            // want to content author to be updated for programming or script rights to be updated.\n            setContentDirty(true);\n        }\n        this.title = title;\n    }\n\n    public String getFormat()\n    {\n        return this.format != null ? this.format : \"\";\n    }\n\n    public void setFormat(String format)\n    {\n        if (!format.equals(this.format)) {\n            this.format = format;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link DocumentReference}\n     * @return the user as {@link DocumentReference}\n     */\n    private DocumentReference userStringToReference(String userString)\n    {\n        DocumentReference userReference;\n\n        if (StringUtils.isEmpty(userString)) {\n            userReference = null;\n        } else {\n            userReference = getExplicitReferenceDocumentReferenceResolver().resolve(\n                getXClassEntityReferenceResolver().resolve(userString, EntityType.DOCUMENT), getDocumentReference());\n\n            if (userReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                userReference = null;\n            }\n        }\n\n        return userReference;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(DocumentReference userReference)\n    {\n        String userString;\n\n        if (userReference != null) {\n            userString = getCompactWikiEntityReferenceSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            userString = XWikiRightService.GUEST_USER_FULLNAME;\n        }\n\n        return userString;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(UserReference userReference)\n    {\n        // The user API is missing the concept of relative user references ATM so we're forced to check where the users\n        // are stored in order to make sure user references stored in the database are relative.\n        // See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            // Users are stored as documents. We want the user references that are stored in the database to be relative\n            // as much as possible (because it makes the content portable). For this we omit the wiki reference when the\n            // user (profile document) reference is from the same wiki as this document.\n            return getUserReferenceCompactWikiSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            return getUserReferenceStringSerializer().serialize(userReference);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link UserReference}\n     * @return the user as {@link UserReference}\n     */\n    private UserReference userStringToUserReference(String userString)\n    {\n        // The user API is missing the concept of relative user references ATM so if we want to resolve (partial) user\n        // references that were stored in the database relative to this document then we need to check where the users\n        // are stored. See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            return getUserReferenceStringResolver().resolve(userString, getDocumentReference().getWikiReference());\n        } else {\n            return getUserReferenceStringResolver().resolve(userString);\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getEffectiveMetadataAuthor()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getAuthorReference()\n    {\n        UserReference effectiveMetadataAuthor = getAuthors().getEffectiveMetadataAuthor();\n        if (this.getAuthors().getEffectiveMetadataAuthor() != null\n            && effectiveMetadataAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(effectiveMetadataAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setEffectiveMetadataAuthor(UserReference)}\n     * instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setAuthorReference(DocumentReference authorReference)\n    {\n        if (authorReference == null) {\n            this.authors.setEffectiveMetadataAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (authorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(authorReference);\n            this.authors.setEffectiveMetadataAuthor(user);\n            // We also set the original metadata author for backward compatibility.\n            this.authors.setOriginalMetadataAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated since 3.0M3 use {@link #getAuthorReference()} instead\n     */\n    @Deprecated\n    public String getAuthor()\n    {\n        return userReferenceToString(getAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setAuthor(String author)\n    {\n        setAuthorReference(userStringToReference(author));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getContentAuthor()} instead\n     */\n    @Override\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getContentAuthorReference()\n    {\n        UserReference contentAuthor = this.getAuthors().getContentAuthor();\n        if (contentAuthor != null && contentAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(contentAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setContentAuthor(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setContentAuthorReference(DocumentReference contentAuthorReference)\n    {\n        if (contentAuthorReference == null) {\n            this.authors.setContentAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (contentAuthorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(contentAuthorReference);\n            this.authors.setContentAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getContentAuthorReference()} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public String getContentAuthor()\n    {\n        return userReferenceToString(getContentAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setContentAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setContentAuthor(String contentAuthor)\n    {\n        setContentAuthorReference(userStringToReference(contentAuthor));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getCreator()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getCreatorReference()\n    {\n        UserReference creator = this.getAuthors().getCreator();\n        if (creator != null && creator != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(creator);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setCreator(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setCreatorReference(DocumentReference creatorReference)\n    {\n        if (creatorReference == null) {\n            this.authors.setCreator(GuestUserReference.INSTANCE);\n        } else {\n            if (creatorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(creatorReference);\n            this.authors.setCreator(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getCreatorReference()} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public String getCreator()\n    {\n        return userReferenceToString(getCreatorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setCreatorReference} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public void setCreator(String creator)\n    {\n        setCreatorReference(userStringToReference(creator));\n    }\n\n    @Override\n    public Date getDate()\n    {\n        if (this.updateDate == null) {\n            return new Date();\n        } else {\n            return this.updateDate;\n        }\n    }\n\n    public void setDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.updateDate))) {\n            setMetaDataDirty(true);\n        }\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.updateDate = date;\n    }\n\n    @Override\n    public Date getCreationDate()\n    {\n        if (this.creationDate == null) {\n            return new Date();\n        } else {\n            return this.creationDate;\n        }\n    }\n\n    public void setCreationDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.creationDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.creationDate = date;\n    }\n\n    public Date getContentUpdateDate()\n    {\n        if (this.contentUpdateDate == null) {\n            return new Date();\n        } else {\n            return this.contentUpdateDate;\n        }\n    }\n\n    public void setContentUpdateDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.contentUpdateDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.contentUpdateDate = date;\n    }\n\n    public String getMeta()\n    {\n        return this.meta;\n    }\n\n    public void setMeta(String meta)\n    {\n        if (meta == null) {\n            if (this.meta != null) {\n                setMetaDataDirty(true);\n            }\n        } else if (!meta.equals(this.meta)) {\n            setMetaDataDirty(true);\n        }\n        this.meta = meta;\n    }\n\n    public void appendMeta(String meta)\n    {\n        StringBuilder buf = new StringBuilder(this.meta);\n        buf.append(meta);\n        buf.append(\"\\n\");\n        this.meta = buf.toString();\n        setMetaDataDirty(true);\n    }\n\n    public boolean isContentDirty()\n    {\n        return this.isContentDirty;\n    }\n\n    /**\n     * Increment the current document version.\n     * This method will use {@link #getNextVersion(Version, boolean)} to compute the new version.\n     */\n    public void incrementVersion()\n    {\n        this.version = getNextVersion(this.version, isMinorEdit());\n    }\n\n    /**\n     * This method computes the next version and returns it, but won't change the current version.\n     * In order to change the current version, see {@link #incrementVersion()}.\n     *\n     * @param version the based version from which to compute the next one.\n     * @param minorEdit true means it's a minor edition.\n     * @return the new version computed based on the current one.\n     * @since 11.2RC1\n     */\n    public static Version getNextVersion(Version version, boolean minorEdit)\n    {\n        if (version == null) {\n            return new Version(\"1.1\");\n        }\n        if (minorEdit) {\n            return version.next();\n        } else {\n            return version.getBranchPoint().next().newBranch(1);\n        }\n    }\n\n    public void setContentDirty(boolean contentDirty)\n    {\n        this.isContentDirty = contentDirty;\n    }\n\n    public boolean isMetaDataDirty()\n    {\n        return this.isMetaDataDirty;\n    }\n\n    public void setMetaDataDirty(boolean metaDataDirty)\n    {\n        this.isMetaDataDirty = metaDataDirty;\n    }\n\n    public String getAttachmentURL(String filename, XWikiContext context)\n    {\n        return getAttachmentURL(filename, \"download\", context);\n    }\n\n    public String getAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        return getAttachmentURL(filename, action, null, context);\n    }\n\n    public String getExternalAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createAttachmentURL(filename, getSpace(), getName(), action, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getAttachmentURL(String filename, String action, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentURL(new AttachmentReference(filename, this.getDocumentReference()),\n            action, querystring, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, XWikiContext context)\n    {\n        return getAttachmentRevisionURL(filename, revision, null, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentRevisionURL(new AttachmentReference(filename, getDocumentReference()),\n            revision, querystring, context);\n    }\n\n    /**\n     * @param action the action, see the {@code struts-config.xml} file for a list of all existing action names\n     * @param params the URL query string\n     * @param redirect true if the URL is going to be used in {@link HttpServletResponse#sendRedirect(String)}\n     * @param context the XWiki context\n     * @return the URL\n     */\n    public String getURL(String action, String params, boolean redirect, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, params, null, getDatabase(), context);\n\n        if (redirect && isRedirectAbsolute(context)) {\n            if (url == null) {\n                return null;\n            } else {\n                return url.toString();\n            }\n        } else {\n            return context.getURLFactory().getURL(url, context);\n        }\n    }\n\n    private boolean isRedirectAbsolute(XWikiContext context)\n    {\n        return StringUtils.equals(\"1\", context.getWiki().Param(\"xwiki.redirect.absoluteurl\"));\n    }\n\n    public String getURL(String action, boolean redirect, XWikiContext context)\n    {\n        return getURL(action, null, redirect, context);\n    }\n\n    public String getURL(String action, XWikiContext context)\n    {\n        return getURL(action, false, context);\n    }\n\n    public String getURL(String action, String querystring, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, querystring, null, getDatabase(), context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getURL(String action, String querystring, String anchor, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createURL(getSpace(), getName(), action, querystring, anchor, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getExternalURL(String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, null, null, getDatabase(),\n            context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String action, String querystring, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, querystring, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getParentURL(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getParentReference());\n        URL url = context.getURLFactory().createURL(doc.getSpace(), doc.getName(), \"view\", null, null, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public XWikiDocumentArchive getDocumentArchive(XWikiContext context) throws XWikiException\n    {\n        loadArchive(context);\n        return getDocumentArchive();\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClassName the name of the custom {@link com.xpn.xwiki.api.Document} class of the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(String customClassName, XWikiContext context)\n    {\n        if (!((customClassName == null) || (customClassName.equals(\"\")))) {\n            try {\n                return newDocument(Class.forName(customClassName), context);\n            } catch (ClassNotFoundException e) {\n                LOGGER.error(\"Failed to get java Class object from class name\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClass the custom {@link com.xpn.xwiki.api.Document} class the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(Class<?> customClass, XWikiContext context)\n    {\n        if (customClass != null) {\n            try {\n                Class<?>[] classes = new Class[] { XWikiDocument.class, XWikiContext.class };\n                Object[] args = new Object[] { this, context };\n\n                return (com.xpn.xwiki.api.Document) customClass.getConstructor(classes).newInstance(args);\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to create a custom Document object\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    public com.xpn.xwiki.api.Document newDocument(XWikiContext context)\n    {\n        String customClass = getCustomClass();\n        return newDocument(customClass, context);\n    }\n\n    public void loadArchive(XWikiContext context) throws XWikiException\n    {\n        if ((this.archive == null || this.archive.get() == null)) {\n            XWikiDocumentArchive arch;\n            // A document not comming from the database cannot have an archive stored in the database\n            if (this.isNew()) {\n                arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            } else {\n                arch = getVersioningStore(context).getXWikiDocumentArchive(this, context);\n            }\n            // We are using a SoftReference which will allow the archive to be\n            // discarded by the Garbage collector as long as the context is closed (usually during\n            // the request)\n            this.archive = new SoftReference<>(arch);\n        }\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, null is\n     *         returned.\n     */\n    public XWikiDocumentArchive getDocumentArchive()\n    {\n        // If there is a soft reference, return it.\n        if (this.archive != null) {\n            return this.archive.get();\n        }\n        // Some APIs are expecting the archive to be null for loading it\n        // (e.g. VersioningStore#loadXWikiDocumentArchive), so it's better to keep it null than to return an\n        // empty archive which would never be populated.\n        return null;\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, we get it using\n     *         the current context. If there is an exception, null is returned.\n     */\n    public XWikiDocumentArchive loadDocumentArchive()\n    {\n        XWikiDocumentArchive arch = getDocumentArchive();\n        if (arch != null) {\n            return arch;\n        }\n\n        // A document not comming from the database cannot have an archive stored in the database\n        if (this.isNew()) {\n            arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            setDocumentArchive(arch);\n            return arch;\n        }\n\n        XWikiContext xcontext = getXWikiContext();\n\n        try {\n            arch = getVersioningStore(xcontext).getXWikiDocumentArchive(this, xcontext);\n\n            // Put a copy of the archive in the soft reference for later use if needed.\n            setDocumentArchive(arch);\n\n            return arch;\n        } catch (Exception e) {\n            // VersioningStore.getXWikiDocumentArchive may throw an XWikiException, and xcontext or VersioningStore\n            // may be null (tests)\n            // To maintain the behavior of this method we can't throw an exception.\n            // Formerly, null was returned if there was no SoftReference.\n            LOGGER.warn(\"Could not get document archive\", e);\n            return null;\n        }\n    }\n\n    public void setDocumentArchive(XWikiDocumentArchive arch)\n    {\n        // We are using a SoftReference which will allow the archive to be\n        // discarded by the Garbage collector as long as the context is closed (usually during the\n        // request)\n        if (arch != null) {\n            this.archive = new SoftReference<XWikiDocumentArchive>(arch);\n        } else {\n            // Some APIs are expecting the archive to be null for loading it\n            // (e.g. VersioningStore#loadXWikiDocumentArchive), so we allow setting it back to null.\n            this.archive = null;\n        }\n    }\n\n    public void setDocumentArchive(String sarch) throws XWikiException\n    {\n        XWikiDocumentArchive xda = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n        xda.setArchive(sarch);\n        setDocumentArchive(xda);\n    }\n\n    public Version[] getRevisions(XWikiContext context) throws XWikiException\n    {\n        return getVersioningStore(context).getXWikiDocVersions(this, context);\n    }\n\n    public String[] getRecentRevisions(int nb, XWikiContext context) throws XWikiException\n    {\n        try {\n            Version[] revisions = getVersioningStore(context).getXWikiDocVersions(this, context);\n            int length = nb;\n            // 0 means all revisions\n            if (nb == 0) {\n                length = revisions.length;\n            }\n\n            if (revisions.length < length) {\n                length = revisions.length;\n            }\n\n            String[] recentrevs = new String[length];\n            for (int i = 1; i <= length; i++) {\n                recentrevs[i - 1] = revisions[revisions.length - i].toString();\n            }\n            return recentrevs;\n        } catch (Exception e) {\n            return new String[0];\n        }\n    }\n\n    /**\n     * Get document versions matching criterias like author, minimum creation date, etc.\n     *\n     * @param criteria criteria used to match versions\n     * @return a list of matching versions\n     */\n    public List<String> getRevisions(RevisionCriteria criteria, XWikiContext context) throws XWikiException\n    {\n        List<String> results = new ArrayList<String>();\n\n        Version[] revisions = getRevisions(context);\n\n        XWikiRCSNodeInfo nextNodeinfo = null;\n        XWikiRCSNodeInfo nodeinfo;\n        for (Version revision : revisions) {\n            nodeinfo = nextNodeinfo;\n            nextNodeinfo = getRevisionInfo(revision.toString(), context);\n\n            if (nodeinfo == null) {\n                continue;\n            }\n\n            // Minor/Major version matching\n            if (criteria.getIncludeMinorVersions() || !nextNodeinfo.isMinorEdit()) {\n                // Author matching\n                if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                    // Date range matching\n                    Date versionDate = nodeinfo.getDate();\n                    if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                        results.add(nodeinfo.getVersion().toString());\n                    }\n                }\n            }\n        }\n\n        nodeinfo = nextNodeinfo;\n        if (nodeinfo != null) {\n            if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                // Date range matching\n                Date versionDate = nodeinfo.getDate();\n                if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                    results.add(nodeinfo.getVersion().toString());\n                }\n            }\n        }\n\n        return criteria.getRange().subList(results);\n    }\n\n    public XWikiRCSNodeInfo getRevisionInfo(String version, XWikiContext context) throws XWikiException\n    {\n        return getDocumentArchive(context).getNode(new Version(version));\n    }\n\n    /**\n     * @return Is this version the most recent one. False if and only if there are newer versions of this document in\n     *         the database.\n     */\n    public boolean isMostRecent()\n    {\n        return this.mostRecent;\n    }\n\n    /**\n     * must not be used unless in store system.\n     *\n     * @param mostRecent - mark document as most recent.\n     */\n    public void setMostRecent(boolean mostRecent)\n    {\n        this.mostRecent = mostRecent;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseClass getXClass()\n    {\n        if (this.xClass == null) {\n            BaseClass emptyClass = new BaseClass();\n            // Make sure not to cause any false document versions if this document is saved.\n            emptyClass.setDirty(false);\n\n            this.setXClass(emptyClass);\n        }\n        return this.xClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClass(BaseClass xwikiClass)\n    {\n        xwikiClass.setOwnerDocument(this);\n\n        this.xClass = xwikiClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public Map<DocumentReference, List<BaseObject>> getXObjects()\n    {\n        return (Map) this.publicXObjects;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(Map<DocumentReference, List<BaseObject>> objects)\n    {\n        if (objects == null) {\n            // Make sure we don`t set a null objects map since we assume everywhere that it is not null when using it.\n            objects = new HashMap<>();\n        }\n\n        boolean isDirty = false;\n\n        for (List<BaseObject> objList : objects.values()) {\n            for (BaseObject obj : objList) {\n                obj.setOwnerDocument(this);\n                isDirty = true;\n            }\n        }\n\n        // This operation resulted in marking the current document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n\n        // Replace the current objects with the provided ones.\n        Map<DocumentReference, BaseObjects> objectsCopy = new ConcurrentSkipListMap<>();\n        objects.forEach((k, v) -> objectsCopy.put(k, new BaseObjects(v)));\n        this.xObjects = objectsCopy;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @deprecated use {@link #getXObject()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getxWikiObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public List<BaseClass> getXClasses(XWikiContext context)\n    {\n        List<BaseClass> list = new ArrayList<BaseClass>();\n\n        // getXObjects() is a TreeMap, with elements sorted by className reference\n        for (DocumentReference classReference : getXObjects().keySet()) {\n            BaseClass bclass = null;\n            List<BaseObject> objects = getXObjects(classReference);\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        break;\n                    }\n                }\n            }\n            if (bclass != null) {\n                list.add(bclass);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Create and add a new object to the document with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the index of teh newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public int createXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject object = BaseClass.newCustomClassInstance(absoluteClassReference, context);\n        object.setOwnerDocument(this);\n        object.setXClassReference(classReference);\n        BaseObjects objects = this.xObjects.get(absoluteClassReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(absoluteClassReference, objects);\n        }\n        objects.add(object);\n        int nb = objects.size() - 1;\n        object.setNumber(nb);\n        setMetaDataDirty(true);\n        return nb;\n    }\n\n    /**\n     * @deprecated use {@link #createXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int createNewObject(String className, XWikiContext context) throws XWikiException\n    {\n        return createXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public int getXObjectSize(DocumentReference classReference)\n    {\n        try {\n            return getXObjects().get(classReference).size();\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n\n    /**\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public int getXObjectSize(EntityReference classReference)\n    {\n        return getXObjectSize(resolveClassReference(classReference));\n    }\n\n    /**\n     * @deprecated use {@link #getXObjectSize(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int getObjectNumbers(String className)\n    {\n        return getXObjectSize(resolveClassReference(className));\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the given class reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param classReference the reference of the xclass for which to retrieve the xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *          or an empty list.\n     * @since 2.2M1\n     */\n    public List<BaseObject> getXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> xobjects = null;\n\n        if (classReference != null) {\n            xobjects = getXObjects().get(classReference);\n        }\n\n        return xobjects != null ? xobjects : Collections.emptyList();\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the class reference corresponding to the resolution of the\n     * given entity reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param reference the reference that is resolved to an xclass for retrieving the corresponding xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *           or an empty list.\n     * @since 3.3M1\n     */\n    public List<BaseObject> getXObjects(EntityReference reference)\n    {\n        if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObjects(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * @deprecated use {@link #getXObjects(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public Vector<BaseObject> getObjects(String className)\n    {\n        List<BaseObject> result = this.xObjects.get(resolveClassReference(className));\n        return result == null ? null : new Vector<BaseObject>(result);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(DocumentReference classReference, List<BaseObject> objects)\n    {\n        // Remove existing objects\n        List<BaseObject> existingbjects = this.xObjects.get(classReference);\n        if (existingbjects != null) {\n            existingbjects.clear();\n        }\n\n        for (BaseObject obj : objects) {\n            obj.setOwnerDocument(this);\n        }\n\n        // Add new objects\n        this.xObjects.put(classReference, new BaseObjects(objects));\n\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @since 3.3M1\n     */\n    public BaseObject getXObject(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        } else if (reference.getType() == EntityType.OBJECT) {\n            // object reference\n            return getXObject(getCurrentReferenceObjectReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference)\n    {\n        BaseObject result = null;\n        List<BaseObject> objects = getXObjects().get(classReference);\n        if (objects != null) {\n            for (BaseObject object : objects) {\n                if (object != null) {\n                    result = object;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get an object of this document based on its reference.\n     *\n     * @param objectReference the reference of the object\n     * @return the XWiki object\n     * @since 3.2M1\n     */\n    public BaseObject getXObject(ObjectReference objectReference)\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        return baseObjectReference.getObjectNumber() == null ? this.getXObject(baseObjectReference.getXClassReference())\n            : getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber());\n    }\n\n    /**\n     * Get or create an object of this document based on its reference.\n     *\n     * @param objectReference The reference of the object.\n     * @param create If the object shall be created if missing.\n     * @param context The XWiki context for creating the object.\n     * @return The found or created objected.\n     * @throws XWikiException If object creation failed.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public BaseObject getXObject(ObjectReference objectReference, boolean create, XWikiContext context)\n        throws XWikiException\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        if (baseObjectReference.getObjectNumber() == null) {\n            return getXObject(baseObjectReference.getXClassReference(), create, context);\n        } else {\n            return getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber(), create,\n                context);\n        }\n    }\n\n    /**\n     * Convert the given {@link ObjectReference} into a {@link BaseObjectReference}.\n     */\n    private BaseObjectReference getBaseObjectReference(ObjectReference objectReference)\n    {\n        if (objectReference instanceof BaseObjectReference) {\n            return (BaseObjectReference) objectReference;\n        } else {\n            return new BaseObjectReference(objectReference);\n        }\n    }\n\n    /**\n     * Get an object property of this document based on its reference.\n     *\n     * @param objectPropertyReference the reference of the object property\n     * @return the object property\n     * @since 3.2M3\n     */\n    public BaseProperty<ObjectPropertyReference> getXObjectProperty(ObjectPropertyReference objectPropertyReference)\n    {\n        BaseObject object = getXObject((ObjectReference) objectPropertyReference.getParent());\n\n        if (object != null) {\n            return (BaseProperty<ObjectPropertyReference>) object.getField(objectPropertyReference.getName());\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className)\n    {\n        return getXObject(resolveClassReference(className));\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, int nb)\n    {\n        List<BaseObject> objects = getXObjects().get(classReference);\n\n        if (objects != null && objects.size() > nb) {\n            return objects.get(nb);\n        }\n\n        return null;\n    }\n\n    /**\n     * Get an xobject with the passed xclass at the passed location.\n     * <p>\n     * If <code>create</code> is true and the is no xobject at the passed located, it's created.\n     *\n     * @param classReference the xlcass of the object to retrieve\n     * @param number the location of the xobject\n     * @param create if true the xobject is created when it does not exist\n     * @param xcontext the XWiki context\n     * @return a {@link BaseObject} stored at passed location\n     * @throws XWikiException when failing to create new xobject instance\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public BaseObject getXObject(EntityReference classReference, int number, boolean create, XWikiContext xcontext)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n\n        BaseObject xobject = getXObject(absoluteClassReference, number);\n\n        if (xobject == null && create) {\n            xobject = BaseClass.newCustomClassInstance(absoluteClassReference, xcontext);\n\n            setXObject(number, xobject);\n        }\n\n        return xobject;\n    }\n\n    /**\n     * @since 4.1M1\n     */\n    public BaseObject getXObject(EntityReference classReference, int nb)\n    {\n        return getXObject(\n            getCurrentReferenceDocumentReferenceResolver().resolve(classReference, getDocumentReference()), nb);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, int)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, int nb)\n    {\n        return getXObject(resolveClassReference(className), nb);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value)\n    {\n        return getXObject(classReference, key, value, false);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value)\n    {\n        return getObject(className, key, value, false);\n    }\n\n    /**\n     * @return 6.3M1\n     */\n    public BaseObject getXObject(EntityReference reference, String key, String value, boolean failover)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference, key, value, failover);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()),\n                key, value, failover);\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value, boolean failover)\n    {\n        try {\n            if (value == null) {\n                if (failover) {\n                    return getXObject(classReference);\n                } else {\n                    return null;\n                }\n            }\n\n            List<BaseObject> objects = getXObjects().get(classReference);\n            if ((objects == null) || (objects.size() == 0)) {\n                return null;\n            }\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    if (value.equals(obj.getStringValue(key))) {\n                        return obj;\n                    }\n                }\n            }\n\n            if (failover) {\n                return getXObject(classReference);\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            if (failover) {\n                return getXObject(classReference);\n            }\n\n            LOGGER.warn(\"Exception while accessing objects for document [{}]: {}\", getDocumentReference(),\n                e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String, boolean)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value, boolean failover)\n    {\n        return getXObject(resolveClassReference(className), key, value, failover);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated\n    public void addXObject(DocumentReference classReference, BaseObject object)\n    {\n        List<BaseObject> vobj = this.xObjects.get(classReference);\n        if (vobj == null) {\n            setXObject(classReference, 0, object);\n        } else {\n            setXObject(classReference, vobj.size(), object);\n        }\n    }\n\n    /**\n     * Add the object to the document.\n     *\n     * @param object the xobject to add\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void addXObject(BaseObject object)\n    {\n        object.setOwnerDocument(this);\n\n        List<BaseObject> vobj = this.xObjects.get(object.getXClassReference());\n        if (vobj == null) {\n            setXObject(0, object);\n        } else {\n            setXObject(vobj.size(), object);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void addObject(String className, BaseObject object)\n    {\n        addXObject(resolveClassReference(className), object);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #setXObject(int, BaseObject)} instead\n     */\n    @Deprecated\n    public void setXObject(DocumentReference classReference, int nb, BaseObject object)\n    {\n        if (object != null) {\n            object.setOwnerDocument(this);\n            object.setNumber(nb);\n        }\n\n        BaseObjects objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(classReference, objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Replaces the object at the specified position and for the specified object's xclass.\n     *\n     * @param nb index of the element to replace\n     * @param object the xobject to insert\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void setXObject(int nb, BaseObject object)\n    {\n        object.setOwnerDocument(this);\n        object.setNumber(nb);\n\n        BaseObjects objects = this.xObjects.get(object.getXClassReference());\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(object.getXClassReference(), objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #setXObject(DocumentReference, int, BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setObject(String className, int nb, BaseObject object)\n    {\n        setXObject(resolveClassReference(className), nb, object);\n    }\n\n    /**\n     * @return true if the document is a new one (i.e. it has never been saved) or false otherwise\n     */\n    public boolean isNew()\n    {\n        return this.isNew;\n    }\n\n    public void setNew(boolean aNew)\n    {\n        this.isNew = aNew;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXClass(XWikiDocument templatedoc)\n    {\n        BaseClass bclass = getXClass();\n        BaseClass tbclass = templatedoc.getXClass();\n        if (tbclass != null) {\n            if (bclass == null) {\n                setXClass(tbclass.clone());\n            } else {\n                getXClass().merge(tbclass.clone());\n            }\n        }\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #mergeXClass(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiClass(XWikiDocument templatedoc)\n    {\n        mergeXClass(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXObjects(XWikiDocument templateDoc)\n    {\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templateDoc.getXObjects().entrySet()) {\n            // Documents can't have objects of types defined in a different wiki so we make sure the class reference\n            // matches this document's wiki.\n            DocumentReference classReference = entry.getKey().replaceParent(entry.getKey().getWikiReference(),\n                getDocumentReference().getWikiReference());\n            // Copy the objects from the template document only if this document doesn't have them already.\n            //\n            // Note: this might be a bit misleading since it will not add objects from the template if some objects of\n            // that class already exist in the current document.\n            if (getXObjectSize(classReference) == 0) {\n                for (BaseObject object : entry.getValue()) {\n                    if (object != null) {\n                        addXObject(object.duplicate());\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #mergeXObjects(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiObjects(XWikiDocument templatedoc)\n    {\n        mergeXObjects(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void cloneXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, true);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void duplicateXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, false);\n    }\n\n    /**\n     * Copy specified document objects into current document.\n     *\n     * @param templatedoc the document to copy\n     * @param keepsIdentity if true it does an exact java copy, otherwise it duplicate objects with the new document\n     *            name (and new class names)\n     */\n    private void cloneXObjects(XWikiDocument templatedoc, boolean keepsIdentity)\n    {\n        // clean map\n        this.xObjects.clear();\n\n        // fill map\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templatedoc.getXObjects().entrySet()) {\n            List<BaseObject> tobjects = entry.getValue();\n\n            // clone and insert xobjects\n            for (BaseObject otherObject : tobjects) {\n                if (otherObject != null) {\n                    if (keepsIdentity) {\n                        addXObject(otherObject.clone());\n                    } else {\n                        BaseObject newObject = otherObject.duplicate(getDocumentReference());\n                        setXObject(newObject.getNumber(), newObject);\n                    }\n                } else if (keepsIdentity) {\n                    // set null object to make sure to have exactly the same thing when cloning a document\n                    addXObject(entry.getKey(), null);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public DocumentReference getTemplateDocumentReference()\n    {\n        return this.templateDocumentReference;\n    }\n\n    /**\n     * @deprecated use {@link #getTemplateDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getTemplate()\n    {\n        String templateReferenceAsString;\n        DocumentReference templateDocumentReference = getTemplateDocumentReference();\n        if (templateDocumentReference != null) {\n            templateReferenceAsString = LOCAL_REFERENCE_SERIALIZER.serialize(templateDocumentReference);\n        } else {\n            templateReferenceAsString = \"\";\n        }\n        return templateReferenceAsString;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setTemplateDocumentReference(DocumentReference templateDocumentReference)\n    {\n        if (!Objects.equals(getTemplateDocumentReference(), templateDocumentReference)) {\n            this.templateDocumentReference = templateDocumentReference;\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #setTemplateDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setTemplate(String template)\n    {\n        DocumentReference templateReference = null;\n        if (!StringUtils.isEmpty(template)) {\n            templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n        }\n        setTemplateDocumentReference(templateReference);\n    }\n\n    public String displayPrettyName(String fieldname, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayPrettyName(fieldname, showMandatory, before, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayPrettyName(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, BaseObject obj,\n        XWikiContext context)\n    {\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String dprettyName = \"\";\n            if (showMandatory) {\n                dprettyName = context.getWiki().addMandatory(context);\n            }\n            if (before) {\n                return dprettyName + pclass.getPrettyName(context);\n            } else {\n                return pclass.getPrettyName(context) + dprettyName;\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayTooltip(fieldname, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String tooltip = pclass.getTooltip(context);\n            if ((tooltip != null) && (!tooltip.trim().equals(\"\"))) {\n                String img = \"<img src=\\\"\" + context.getWiki().getSkinFile(\"info.gif\", context)\n                    + \"\\\" class=\\\"tooltip_image\\\" align=\\\"middle\\\" />\";\n                result = context.getWiki().addTooltip(img, tooltip, context);\n            }\n        } catch (Exception e) {\n\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n\n            result = display(fieldname, object, context);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to display field [\" + fieldname + \"] of document [\"\n                + getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) + \"]\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String type = null;\n        try {\n            type = (String) context.get(\"display\");\n        } catch (Exception e) {\n        }\n\n        if (type == null) {\n            type = \"view\";\n        }\n\n        return display(fieldname, type, obj, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, XWikiContext context)\n    {\n        return display(fieldname, mode, \"\", context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, BaseObject obj, boolean isolated, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param prefix the prefix to add in the field identifier in edit display for example\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, String prefix, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            if (object == null) {\n                return \"\";\n            } else {\n                return display(fieldname, mode, prefix, object, context);\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, String wrappingSyntaxId, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, wrappingSyntaxId, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, boolean isolated,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj,\n            context.getWiki().getCurrentContentSyntaxId(getSyntaxId(), context), isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, wrappingSyntaxId, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId) && HTMLUtils.containsElementText(result)) {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                result.append(\"{{/html}}\");\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, XWikiContext context)\n    {\n        return displayForm(classReference, header, format, true, context);\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, XWikiContext context)\n    {\n        return displayForm(className, header, format, true, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, boolean linebreak,\n        XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (format.endsWith(\"\\\\n\")) {\n            linebreak = true;\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        VelocityContext vcontext;\n        try {\n            vcontext = getVelocityContextFactory().createContext();\n        } catch (XWikiVelocityException e) {\n            LOGGER.error(\"Failed to create a standard VelocityContext\", e);\n\n            vcontext = new XWikiVelocityContext();\n        }\n\n        for (String propertyName : bclass.getPropertyList()) {\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            vcontext.put(pclass.getName(), pclass.getPrettyName());\n        }\n        result.append(evaluate(header, context.getDoc().getPrefixedFullName(), vcontext, context));\n        if (linebreak) {\n            result.append(\"\\n\");\n        }\n\n        // display each line\n        for (int i = 0; i < objects.size(); i++) {\n            vcontext.put(\"id\", Integer.valueOf(i + 1));\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                for (String name : bclass.getPropertyList()) {\n                    vcontext.put(name, display(name, object, context));\n                }\n                result.append(evaluate(format, context.getDoc().getPrefixedFullName(), vcontext, context));\n                if (linebreak) {\n                    result.append(\"\\n\");\n                }\n            }\n        }\n        return result.toString();\n    }\n\n    private String evaluate(String content, String name, VelocityContext vcontext, XWikiContext context)\n    {\n        StringWriter writer = new StringWriter();\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, name, content);\n            return writer.toString();\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}]\", name, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, boolean linebreak, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), header, format, linebreak, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (objects == null) {\n            return \"\";\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        result.append(\"{table}\\n\");\n        boolean first = true;\n        for (String propertyName : bclass.getPropertyList()) {\n            if (first == true) {\n                first = false;\n            } else {\n                result.append(\"|\");\n            }\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            result.append(pclass.getPrettyName());\n        }\n        result.append(\"\\n\");\n        for (int i = 0; i < objects.size(); i++) {\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                first = true;\n                for (String propertyName : bclass.getPropertyList()) {\n                    if (first == true) {\n                        first = false;\n                    } else {\n                        result.append(\"|\");\n                    }\n                    String data = display(propertyName, object, context);\n                    data = data.trim();\n                    data = data.replaceAll(\"\\n\", \" \");\n                    if (data.length() == 0) {\n                        result.append(\"&nbsp;\");\n                    } else {\n                        result.append(data);\n                    }\n                }\n                result.append(\"\\n\");\n            }\n        }\n        result.append(\"{table}\\n\");\n        return result.toString();\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), context);\n    }\n\n    public boolean isFromCache()\n    {\n        return this.fromCache;\n    }\n\n    public void setFromCache(boolean fromCache)\n    {\n        this.fromCache = fromCache;\n    }\n\n    public void readDocMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String defaultLanguage = eform.getDefaultLanguage();\n        if (defaultLanguage != null) {\n            setDefaultLanguage(defaultLanguage);\n        }\n\n        String defaultTemplate = eform.getDefaultTemplate();\n        if (defaultTemplate != null) {\n            setDefaultTemplate(defaultTemplate);\n        }\n\n        String creator = eform.getCreator();\n        if ((creator != null) && (!creator.equals(getCreator()))) {\n            if ((getCreatorReference().equals(context.getUserReference()))\n                || (context.getWiki().getRightService().hasAdminRights(context))) {\n                setCreator(creator);\n            }\n        }\n\n        String parent = eform.getParent();\n        if (parent != null) {\n            setParent(parent);\n        }\n\n        // Read the comment from the form\n        String comment = eform.getComment();\n        if (comment != null) {\n            setComment(comment);\n        }\n\n        // Read the minor edit checkbox from the form\n        setMinorEdit(eform.isMinorEdit());\n\n        String tags = eform.getTags();\n        if (!StringUtils.isEmpty(tags)) {\n            setTags(tags, context);\n        }\n\n        // Set the Syntax id if defined\n        String syntaxId = eform.getSyntaxId();\n        if (syntaxId != null) {\n            setSyntax(resolveSyntax(syntaxId));\n        }\n\n        // Read the hidden checkbox from the form\n        if (eform.getHidden() != null) {\n            setHidden(\"1\".equals(eform.getHidden()));\n        }\n    }\n\n    private Syntax resolveSyntax(String syntaxId)\n    {\n        Syntax syntax;\n        try {\n            syntax = getSyntaxRegistry().resolveSyntax(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntax();\n            LOGGER.warn(\"Failed to set syntax [{}] for [{}], setting syntax [{}] instead.\", syntaxId,\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()), syntax.toIdString(), e);\n        }\n        return syntax;\n    }\n\n    /**\n     * add tags to the document.\n     */\n    public void setTags(String tagsStr, XWikiContext context) throws XWikiException\n    {\n        BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n        StaticListClass tagProp = (StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS);\n\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS, true, context);\n\n        tags.safeput(XWikiConstant.TAG_CLASS_PROP_TAGS, tagProp.fromString(tagsStr));\n\n        setMetaDataDirty(true);\n    }\n\n    public String getTags(XWikiContext context)\n    {\n        ListProperty prop = (ListProperty) getTagProperty(context);\n\n        // I don't know why we need to XML-escape the list of tags but for backwards compatibility we need to keep doing\n        // this. When this method was added it was using ListProperty#getTextValue() which used to return\n        // ListProperty#toFormString() before we fixed it to return the unescaped value because we need to save the raw\n        // value in the database and ListProperty#getTextValue() is called when the list property is saved.\n        return prop != null ? prop.toFormString() : \"\";\n    }\n\n    public List<String> getTagsList(XWikiContext context)\n    {\n        List<String> tagList = null;\n\n        BaseProperty prop = getTagProperty(context);\n        if (prop != null) {\n            tagList = (List<String>) prop.getValue();\n        }\n\n        return tagList;\n    }\n\n    private BaseProperty getTagProperty(XWikiContext context)\n    {\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS);\n\n        return tags != null ? ((BaseProperty) tags.safeget(XWikiConstant.TAG_CLASS_PROP_TAGS)) : null;\n    }\n\n    public List<String> getTagsPossibleValues(XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n            String possibleValues =\n                ((StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS)).getValues();\n\n            return ListClass.getListFromString(possibleValues);\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to get tag class\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    public void readTranslationMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String content = eform.getContent();\n        if (content != null) {\n            // Cleanup in case we use HTMLAREA\n            // content = context.getUtil().substitute(\"s/<br class=\\\\\\\"htmlarea\\\\\\\"\\\\/>/\\\\r\\\\n/g\",\n            // content);\n            content = context.getUtil().substitute(\"s/<br class=\\\"htmlarea\\\" \\\\/>/\\r\\n/g\", content);\n            setContent(content);\n        }\n        String title = eform.getTitle();\n        if (title != null) {\n            setTitle(title);\n        }\n    }\n\n    /**\n     * Updates properties of existing objects with the values from the given form.\n     *\n     * @param eform The form to read the values from\n     * @param context The context used for getting the classes of objects\n     * @throws XWikiException On errors\n     */\n    public void readObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        for (DocumentReference reference : getXObjects().keySet()) {\n            List<BaseObject> oldObjects = getXObjects(reference);\n            BaseObjects newObjects = new BaseObjects();\n            while (newObjects.size() < oldObjects.size()) {\n                newObjects.add(null);\n            }\n            for (int i = 0; i < oldObjects.size(); i++) {\n                BaseObject oldobject = oldObjects.get(i);\n                if (oldobject != null) {\n                    BaseClass baseclass = oldobject.getXClass(context);\n                    BaseObject newobject = (BaseObject) baseclass.fromMap(\n                        eform.getObject(\n                            LOCAL_REFERENCE_SERIALIZER.serialize(baseclass.getDocumentReference()) + \"_\" + i),\n                        oldobject);\n                    newobject.setNumber(oldobject.getNumber());\n                    newobject.setGuid(oldobject.getGuid());\n                    newobject.setOwnerDocument(this);\n                    newObjects.set(newobject.getNumber(), newobject);\n                }\n            }\n            getXObjects().put(reference, newObjects);\n        }\n    }\n\n    /**\n     * Create and/or update objects in a document given a list of HTTP parameters of the form {@code\n     * <spacename>.<classname>_<number>_<propertyname>}. If the object already exists, the field is replaced by the\n     * given value. If the object doesn't exist in the document, it is created and the property {@code <propertyname>}\n     * is initialized with the given value.\n     *\n     * @param eform is form information that contains all the query parameters\n     * @param context\n     * @throws XWikiException\n     * @since 7.1M1\n     */\n    public void readObjectsFromFormUpdateOrCreate(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        Map<String, SortedMap<Integer, Map<String, String[]>>> updateOrCreateMap = eform.getUpdateOrCreateMap();\n        for (Entry<String, SortedMap<Integer, Map<String, String[]>>> requestClassEntries : updateOrCreateMap\n            .entrySet()) {\n            String className = requestClassEntries.getKey();\n            DocumentReference requestClassReference = getCurrentDocumentReferenceResolver().resolve(className);\n\n            SortedMap<Integer, Map<String, String[]>> requestObjectMap = requestClassEntries.getValue();\n            for (Entry<Integer, Map<String, String[]>> requestObjectEntry : requestObjectMap.entrySet()) {\n                Integer requestObjectNumber = requestObjectEntry.getKey();\n                Map<String, String[]> requestObjectPropertyMap = requestObjectEntry.getValue();\n                List<String> properties = new ArrayList<>(requestObjectPropertyMap.keySet());\n                try {\n                    BaseClass xClass = context.getWiki().getDocument(requestClassReference, context).getXClass();\n\n                    // clean-up the properties that do not belong to the xclass\n                    for (String property : properties) {\n                        if (!xClass.getPropertyList().contains(property)) {\n                            requestObjectPropertyMap.remove(property);\n                        }\n                    }\n                } catch (XWikiException e) {\n                    // If the class page cannot be found, skip entirely the property update\n                    LOGGER.warn(\"Failed to load document [{}], ignoring properties update [{}]. Reason: [{}]\",\n                        requestClassReference, StringUtils.join(properties, \",\"),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    continue;\n                }\n\n                if (!requestObjectPropertyMap.isEmpty()) {\n                    BaseObject oldObject = getXObject(requestClassReference, requestObjectNumber, true, context);\n                    BaseClass baseClass = oldObject.getXClass(context);\n                    BaseObject newObject = (BaseObject) baseClass.fromMap(requestObjectPropertyMap, oldObject);\n                    newObject.setNumber(oldObject.getNumber());\n                    newObject.setGuid(oldObject.getGuid());\n                    newObject.setOwnerDocument(this);\n                    setXObject(requestObjectNumber, newObject);\n                }\n            }\n        }\n    }\n\n    public void readFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        readDocMetaFromForm(eform, context);\n        readTranslationMetaFromForm(eform, context);\n\n        readAddedUpdatedAndRemovedObjectsFromForm(eform, context);\n        readTemporaryUploadedFiles(eform);\n    }\n\n    private TemporaryAttachmentSessionsManager getTemporaryAttachmentManager()\n    {\n        return Utils.getComponent(TemporaryAttachmentSessionsManager.class);\n    }\n\n    /**\n     * Read the list of attachment that should be added from {@link EditForm#getTemporaryUploadedFiles()} and attach\n     * them to the current document if they can be found in the {@link TemporaryAttachmentSessionsManager}.\n     *\n     * @param editForm the form from which to read the list of files.\n     * @since 14.3RC1\n     */\n    @Unstable\n    public void readTemporaryUploadedFiles(EditForm editForm)\n    {\n        getTemporaryAttachmentManager().attachTemporaryAttachmentsInDocument(this, editForm.getTemporaryUploadedFiles());\n    }\n\n    /**\n     * Adds objects, applies property updates and removes objects as specified in the form.\n     *\n     * @param eform The form from which the values shall be read.\n     * @param context The XWiki context.\n     * @throws XWikiException If an error occurs.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public void readAddedUpdatedAndRemovedObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        // We add the new objects that have been submitted in the form, before filling them with their values.\n        Map<String, List<Integer>> objectsToAdd = eform.getObjectsToAdd();\n        for (String className : objectsToAdd.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToAdd.get(className);\n            for (Integer classId : classIds) {\n                // we ensure that the object has not been added yet, for example because of the update or create.\n                getXObject(classReference, classId, true, context);\n            }\n        }\n\n        ObjectPolicyType objectPolicy = eform.getObjectPolicy();\n        if (objectPolicy == null || objectPolicy.equals(ObjectPolicyType.UPDATE)) {\n            readObjectsFromForm(eform, context);\n        } else if (objectPolicy.equals(ObjectPolicyType.UPDATE_OR_CREATE)) {\n            readObjectsFromFormUpdateOrCreate(eform, context);\n        }\n\n        // remove xobjects\n        Map<String, List<Integer>> objectsToRemove = eform.getObjectsToRemove();\n        for (String className : objectsToRemove.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToRemove.get(className);\n            for (Integer classId : classIds) {\n                BaseObject xObject = getXObject(classReference, classId);\n                if (xObject != null) {\n                    removeXObject(xObject);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void readFromTemplate(DocumentReference templateDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        if (templateDocumentReference != null) {\n            String content = getContent();\n            if (!content.equals(\"\\n\") && !content.equals(\"\") && !isNew()) {\n                Object[] args = { getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY,\n                    \"Cannot add a template to document {0} because it already has content\", null, args);\n            } else {\n                XWiki xwiki = context.getWiki();\n                XWikiDocument templatedoc = xwiki.getDocument(templateDocumentReference, context);\n                if (templatedoc.isNew()) {\n                    Object[] args = { getDefaultEntityReferenceSerializer().serialize(templateDocumentReference),\n                    getCompactEntityReferenceSerializer().serialize(getDocumentReference()) };\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_APP_TEMPLATE_DOES_NOT_EXIST,\n                        \"Template document {0} does not exist when adding to document {1}\", null, args);\n                } else {\n                    setTemplateDocumentReference(templateDocumentReference);\n                    setTitle(templatedoc.getTitle());\n                    setContent(templatedoc.getContent());\n\n                    // Set the new document syntax as the syntax of the template since the template content\n                    // is copied into the new document\n                    setSyntax(templatedoc.getSyntax());\n\n                    // If the parent is not set in the current document set the template parent as the parent.\n                    if (getParentReference() == null) {\n                        setParentReference(templatedoc.getRelativeParentReference());\n                    }\n\n                    if (isNew()) {\n                        // We might have received the objects from the cache and the template objects might have been\n                        // copied already we need to remove them\n                        setXObjects(new TreeMap<DocumentReference, List<BaseObject>>());\n                    }\n                    // Merge the external objects.\n                    // Currently the choice is not to merge the base class and object because it is not the preferred\n                    // way of using external classes and objects.\n                    mergeXObjects(templatedoc);\n\n                    // Copy the attachments from the template document, but don't overwrite existing attachments because\n                    // the user can add attachments from the WYSIWYG editor before the save button is clicked (and thus\n                    // before the template is applied).\n                    copyAttachments(templatedoc, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * Use the document passed as parameter as the new identity for the current document.\n     *\n     * @param document the document containing the new identity\n     */\n    public void clone(XWikiDocument document)\n    {\n        this.id = document.id;\n\n        setDocumentReference(document.getDocumentReference());\n        setRCSVersion(document.getRCSVersion());\n        setDocumentArchive(document.getDocumentArchive());\n        setAuthorReference(document.getAuthorReference());\n        setContentAuthorReference(document.getContentAuthorReference());\n        setContent(document.getContent());\n        setCreationDate(document.getCreationDate());\n        setDate(document.getDate());\n        setCustomClass(document.getCustomClass());\n        setContentUpdateDate(document.getContentUpdateDate());\n        setTitle(document.getTitle());\n        setFormat(document.getFormat());\n        setFromCache(document.isFromCache());\n        setElements(document.getElements());\n        setMeta(document.getMeta());\n        setMostRecent(document.isMostRecent());\n        setNew(document.isNew());\n        setStore(document.getStore());\n        setTemplateDocumentReference(document.getTemplateDocumentReference());\n        setParentReference(document.getRelativeParentReference());\n        setCreatorReference(document.getCreatorReference());\n        setDefaultLocale(document.getDefaultLocale());\n        setDefaultTemplate(document.getDefaultTemplate());\n        setValidationScript(document.getValidationScript());\n        setLocale(document.getLocale());\n        setXClass(document.getXClass().clone());\n        setXClassXML(document.getXClassXML());\n        setComment(document.getComment());\n        setMinorEdit(document.isMinorEdit());\n        setSyntax(document.getSyntax());\n        setHidden(document.isHidden());\n\n        cloneXObjects(document);\n        cloneAttachments(document);\n\n        setContentDirty(document.isContentDirty());\n        setMetaDataDirty(document.isMetaDataDirty());\n\n        this.elements = document.elements;\n\n        this.originalDocument = document.originalDocument;\n    }\n\n    @Override\n    public XWikiDocument clone()\n    {\n        return cloneInternal(getDocumentReference(), true, false);\n    }\n\n    /**\n     * Duplicate this document and give it a new name.\n     *\n     * @since 2.2.3\n     */\n    public XWikiDocument duplicate(DocumentReference newDocumentReference)\n    {\n        return cloneInternal(newDocumentReference, false, false);\n    }\n\n    private void cloneDocumentArchive(XWikiDocument originalDocument) throws XWikiException\n    {\n        XWikiDocumentArchive documentArchive = originalDocument.getDocumentArchive();\n        if (documentArchive != null) {\n            this.setDocumentArchive(documentArchive.clone(this.getId(), getXWikiContext()));\n        }\n    }\n\n    private XWikiDocument cloneInternal(DocumentReference newDocumentReference,\n        boolean keepsIdentity,\n        boolean cloneArchive)\n    {\n        XWikiDocument doc = null;\n\n        try {\n            Constructor<? extends XWikiDocument> constructor = getClass().getConstructor(DocumentReference.class);\n            doc = constructor.newInstance(newDocumentReference);\n\n            // Make sure the coordinate of the document is fully accurate before any other manipulation\n            doc.setLocale(getLocale());\n\n            // use version field instead of getRCSVersion because it returns \"1.1\" if version==null.\n            doc.version = this.version;\n            doc.id = this.id;\n            if (cloneArchive) {\n                doc.cloneDocumentArchive(this);\n            } else {\n                // Without this explicit initialization, it is possible for the archive to be incorrectly initialized.\n                // For instance, with the archive of the cloned document.\n                // Here we guarantee that further calls of APIs to get the archive will properly populate the data.\n                doc.setDocumentArchive((XWikiDocumentArchive) null);\n            }\n            doc.getAuthors().copyAuthors(getAuthors());\n            doc.setContent(getContent());\n            doc.setCreationDate(getCreationDate());\n            doc.setDate(getDate());\n            doc.setCustomClass(getCustomClass());\n            doc.setContentUpdateDate(getContentUpdateDate());\n            doc.setTitle(getTitle());\n            doc.setFormat(getFormat());\n            doc.setFromCache(isFromCache());\n            doc.setElements(getElements());\n            doc.setMeta(getMeta());\n            doc.setMostRecent(isMostRecent());\n            doc.setNew(isNew());\n            doc.setStore(getStore());\n            doc.setTemplateDocumentReference(getTemplateDocumentReference());\n            doc.setParentReference(getRelativeParentReference());\n            doc.setDefaultLocale(getDefaultLocale());\n            doc.setDefaultTemplate(getDefaultTemplate());\n            doc.setValidationScript(getValidationScript());\n            doc.setComment(getComment());\n            doc.setMinorEdit(isMinorEdit());\n            doc.setSyntax(getSyntax());\n            doc.setHidden(isHidden());\n\n            if (this.xClass != null) {\n                doc.setXClass(this.xClass.clone());\n            }\n\n            if (keepsIdentity) {\n                doc.setXClassXML(getXClassXML());\n                doc.cloneXObjects(this);\n                doc.cloneAttachments(this);\n            } else {\n                doc.getXClass().setCustomMapping(null);\n                doc.duplicateXObjects(this);\n                doc.copyAttachments(this);\n            }\n\n            doc.setContentDirty(isContentDirty());\n            doc.setMetaDataDirty(isMetaDataDirty());\n\n            doc.elements = this.elements;\n\n            doc.originalDocument = this.originalDocument;\n        } catch (Exception e) {\n            // This should not happen\n            LOGGER.error(\"Exception while cloning document\", e);\n        }\n        return doc;\n    }\n\n    /**\n     * Clone attachments from another document. This implementation expects that this document is the same as the other\n     * document and thus attachments will be saved in the database in the same place as the ones which they are cloning.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    private void cloneAttachments(final XWikiDocument sourceDocument)\n    {\n        this.getAttachmentList().clear();\n        for (XWikiAttachment attach : sourceDocument.getAttachmentList()) {\n            XWikiAttachment newAttach = (XWikiAttachment) attach.clone();\n\n            setAttachment(newAttach);\n        }\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    public void copyAttachments(XWikiDocument sourceDocument)\n    {\n        copyAttachments(sourceDocument, true);\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     * @param overwrite whether to overwrite the existing attachments or not\n     * @since 8.4.6\n     * @since 9.6RC1\n     */\n    private void copyAttachments(XWikiDocument sourceDocument, boolean overwrite)\n    {\n        if (overwrite) {\n            // Note: when clearing the attachment list, we automatically mark the document's metadata as dirty.\n            getAttachmentList().clear();\n        }\n\n        for (XWikiAttachment attachment : sourceDocument.getAttachmentList()) {\n            if (overwrite || this.getAttachment(attachment.getFilename()) == null) {\n                try {\n                    copyAttachment(attachment, true);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"Cannot copy attachment [{}] from [{}] to [{}]. Root cause is [{}].\",\n                        attachment.getFilename(), sourceDocument.getDocumentReference(), this.getDocumentReference(),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    // Skip this attachment because we cannot load its content.\n                    continue;\n                }\n            }\n        }\n    }\n\n    /**\n     * Copies the given attachment to this document.\n     * \n     * @param attachment the source attachment to be copied to this document\n     * @param reset whether to reset or not the attachment meta data that is specific to the source (version, author,\n     *            date)\n     * @throws XWikiException if loading the content of the given attachment fails\n     */\n    private void copyAttachment(XWikiAttachment attachment, boolean reset) throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n        XWikiAttachment newAttachment = attachment.clone();\n\n        // Make sure we copy the attachment content also, not just its meta data. For this we need to load\n        // the attachment content from the source document. Note that the owner document will be overwritten\n        // below when we call setAttachment().\n        newAttachment.setDoc(attachment.getDoc(), false);\n        newAttachment.loadAttachmentContent(xcontext);\n        // We need to set the content of the attachment to be dirty because the dirty bit is used to signal\n        // that there is a reason to save the copied attachment, otherwise the copied attachment will be\n        // empty since the original attachment content is not modified in this operation.\n        newAttachment.getAttachment_content().setContentDirty(true);\n\n        if (reset) {\n            // Reset the meta data that is specific to the original attachment (version, author, date).\n            newAttachment.setRCSVersion(null);\n            newAttachment.setAuthorReference(xcontext.getUserReference());\n            newAttachment.setDate(new Date());\n        }\n\n        // Add the attachment copy to the list of attachments of this document.\n        setAttachment(newAttachment);\n    }\n\n    /**\n     * Load attachment content from database.\n     *\n     * @param context the XWiki context\n     * @throws XWikiException when failing to load attachments\n     * @since 5.3M2\n     */\n    public void loadAttachmentsContent(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n        }\n    }\n\n    /**\n     * Same as {@link #loadAttachmentContent(XWikiAttachment, XWikiContext)} but in some context we don't really care if\n     * an attachment content could not be loaded (we are going to overwrite or ignore it).\n     * \n     * @param context the XWiki context\n     * @since 10.1RC1\n     */\n    public void loadAttachmentsContentSafe(XWikiContext context)\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            try {\n                attachment.loadAttachmentContent(context);\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Failed to load attachment [{}]: {}\", attachment.getReference(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n    }\n\n    public void loadAttachments(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n            attachment.loadArchive(context);\n        }\n    }\n\n    @Override\n    public boolean equals(Object object)\n    {\n        // Same Java object, they sure are equal\n        if (this == object) {\n            return true;\n        }\n\n        // Reference/language (document identifier)\n\n        XWikiDocument doc = (XWikiDocument) object;\n        if (!getDocumentReference().equals(doc.getDocumentReference())) {\n            return false;\n        }\n\n        if (!getDefaultLocale().equals(doc.getDefaultLocale())) {\n            return false;\n        }\n\n        if (!getLocale().equals(doc.getLocale())) {\n            return false;\n        }\n\n        if (getTranslation() != doc.getTranslation()) {\n            return false;\n        }\n\n        // Authors\n\n        if (ObjectUtils.notEqual(getAuthorReference(), doc.getAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getContentAuthorReference(), doc.getContentAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getCreatorReference(), doc.getCreatorReference())) {\n            return false;\n        }\n\n        // Version\n\n        if (!getVersion().equals(doc.getVersion())) {\n            return false;\n        }\n\n        if (getDate().getTime() != doc.getDate().getTime()) {\n            return false;\n        }\n\n        if (getContentUpdateDate().getTime() != doc.getContentUpdateDate().getTime()) {\n            return false;\n        }\n\n        if (getCreationDate().getTime() != doc.getCreationDate().getTime()) {\n            return false;\n        }\n\n        if (!getComment().equals(doc.getComment())) {\n            return false;\n        }\n\n        if (isMinorEdit() != doc.isMinorEdit()) {\n            return false;\n        }\n\n        // Datas\n\n        if (!equalsData(doc)) {\n            return false;\n        }\n\n        // We consider that 2 documents are still equal even when they have different original\n        // documents (see getOriginalDocument() for more details as to what is an original\n        // document).\n\n        return true;\n    }\n\n    /**\n     * Same as {@link #equals(Object)} but only for actual datas of the document.\n     * <p>\n     * The goal being to compare two versions of the same document this method skip every version/reference/author\n     * related information. For example it allows to compare a document comming from a another wiki and easily check if\n     * thoses actually are the same thing whatever the plumbing differences.\n     *\n     * @param otherDocument the document to compare\n     * @return true if bith documents have the same datas\n     * @since 4.1.1\n     */\n    public boolean equalsData(XWikiDocument otherDocument)\n    {\n        // Same Java object, they sure are equal\n        if (this == otherDocument) {\n            return true;\n        }\n\n        if (ObjectUtils.notEqual(getParentReference(), otherDocument.getParentReference())) {\n            return false;\n        }\n\n        if (!getFormat().equals(otherDocument.getFormat())) {\n            return false;\n        }\n\n        if (!getTitle().equals(otherDocument.getTitle())) {\n            return false;\n        }\n\n        if (!getContent().equals(otherDocument.getContent())) {\n            return false;\n        }\n\n        if (!getDefaultTemplate().equals(otherDocument.getDefaultTemplate())) {\n            return false;\n        }\n\n        if (!getValidationScript().equals(otherDocument.getValidationScript())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getSyntax(), otherDocument.getSyntax())) {\n            return false;\n        }\n\n        if (isHidden() != otherDocument.isHidden()) {\n            return false;\n        }\n\n        // XClass\n\n        if (!getXClass().equals(otherDocument.getXClass())) {\n            return false;\n        }\n\n        // XObjects\n\n        Set<DocumentReference> myObjectClassReferences = getXObjects().keySet();\n        Set<DocumentReference> otherObjectClassReferences = otherDocument.getXObjects().keySet();\n        if (!myObjectClassReferences.equals(otherObjectClassReferences)) {\n            return false;\n        }\n\n        for (DocumentReference reference : myObjectClassReferences) {\n            List<BaseObject> myObjects = getXObjects(reference);\n            List<BaseObject> otherObjects = otherDocument.getXObjects(reference);\n            if (myObjects.size() != otherObjects.size()) {\n                return false;\n            }\n            for (int i = 0; i < myObjects.size(); i++) {\n                if ((myObjects.get(i) == null && otherObjects.get(i) != null)\n                    || (myObjects.get(i) != null && otherObjects.get(i) == null)) {\n                    return false;\n                }\n                if (myObjects.get(i) == null && otherObjects.get(i) == null) {\n                    continue;\n                }\n                if (!myObjects.get(i).equals(otherObjects.get(i))) {\n                    return false;\n                }\n            }\n        }\n\n        // Attachments\n        List<XWikiAttachment> attachments = getAttachmentList();\n        List<XWikiAttachment> otherAttachments = otherDocument.getAttachmentList();\n        if (attachments.size() != otherAttachments.size()) {\n            return false;\n        }\n        for (XWikiAttachment attachment : attachments) {\n            XWikiAttachment otherAttachment = otherDocument.getAttachment(attachment.getFilename());\n            try {\n                if (otherAttachment == null || !attachment.equalsData(otherAttachment, null)) {\n                    return false;\n                }\n            } catch (XWikiException e) {\n                throw new RuntimeException(\n                    String.format(\"Failed to compare attachments with reference [%s]\", attachment.getReference()), e);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Retrieve the document in the current context language as an XML string. The rendrered document content and all\n     * XObjects are included. Document attachments and archived versions are excluded. You should prefer\n     * toXML(OutputStream, true, true, false, false, XWikiContext)} or toXML(com.xpn.xwiki.util.XMLWriter, true, true,\n     * false, false, XWikiContext) on the translated document when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document in the current context language\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String getXMLContent(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(context);\n        return tdoc.toXML(true, true, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObject are included. Rendered content, attachments and archived\n     * version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObjects attachments and archived version are included. Rendered\n     * content is excluded. You should prefer toXML(OutputStream, true, false, true, true, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, true, true, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toFullXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, true, true, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. All XObjects and attachments are\n     * included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param zipname the name of the new entry to create\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, String zipname, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        ZipEntry zipentry = new ZipEntry(zipname);\n        zos.putNextEntry(zipentry);\n        toXML(zos, true, false, true, withVersions, context);\n        zos.closeEntry();\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects and attachments are included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.2M2\")\n    public void addToZip(ZipOutputStream zos, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        String zipname =\n            getDocumentReference().getLastSpaceReference().getName() + \"/\" + getDocumentReference().getName();\n        String language = getLanguage();\n        if (!StringUtils.isEmpty(language)) {\n            zipname += \".\" + language;\n        }\n        addToZip(zos, zipname, withVersions, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects, attachments and archived versions are included. Rendered content is\n     * excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, XWikiContext context) throws XWikiException, IOException\n    {\n        addToZip(zos, true, context);\n    }\n\n    /**\n     * Serialize the document to an XML string. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an errors occurs during wiki operations\n     */\n    public String toXML(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        StringWriter writer = new StringWriter();\n\n        toXML(new DefaultWriterOutputTarget(writer), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        return writer.toString();\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. All XObject are included. Rendered content, attachments and\n     * archived version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(XWikiContext context) throws XWikiException\n    {\n        return toXMLDocument(true, false, false, false, context);\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        Document doc = new DOMDocument();\n        DOMXMLWriter wr = new DOMXMLWriter(doc, new OutputFormat(\"\", true, context.getWiki().getEncoding()));\n\n        try {\n            toXML(wr, bWithObjects, bWithRendering, bWithAttachmentContent, bWithVersions, context);\n            return doc;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Serialize the document to a {@link com.xpn.xwiki.internal.xml.XMLWriter}.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void toXML(XMLWriter wr, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        // IMPORTANT: we don't use directly XMLWriter's SAX apis here because it's not really working well\n        DocumentResult domResult = new DocumentResult();\n\n        toXML(new DefaultResultOutputTarget(domResult), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        wr.write(domResult.getDocument().getRootElement());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     */\n    public void toXML(OutputStream out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        toXML(new DefaultOutputStreamOutputTarget(out), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param out the output where to write the XML\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param format true if the XML should be formated\n     * @param encoding the encoding to use to write the XML\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 9.0RC1\n     */\n    public void toXML(OutputTarget out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, boolean format, String encoding) throws XWikiException\n    {\n        // Input\n        DocumentInstanceInputProperties documentProperties = new DocumentInstanceInputProperties();\n        documentProperties.setWithWikiObjects(bWithObjects);\n        documentProperties.setWithWikiDocumentContentHTML(bWithRendering);\n        documentProperties.setWithWikiAttachmentsContent(bWithAttachmentContent);\n        documentProperties.setWithJRCSRevisions(bWithVersions);\n        documentProperties.setWithRevisions(false);\n\n        // Output\n        XAROutputProperties xarProperties = new XAROutputProperties();\n        xarProperties.setPreserveVersion(bWithVersions);\n        xarProperties.setEncoding(encoding);\n        xarProperties.setFormat(format);\n        xarProperties.setTarget(out);\n\n        toXML(documentProperties, xarProperties);\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param xarProperties the configuration of the output filter\n     * @param documentProperties the configuration of the input filter\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 13.8RC1\n     */\n    public void toXML(DocumentInstanceInputProperties documentProperties, XAROutputProperties xarProperties)\n        throws XWikiException\n    {\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).exportEntity(this, xarProperties.getTarget(),\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_DOC_EXPORT,\n                \"Error serializing XML\", e, null);\n        }\n    }\n\n    protected String encodedXMLStringAsUTF8(String xmlString)\n    {\n        if (xmlString == null) {\n            return \"\";\n        }\n\n        int length = xmlString.length();\n        char character;\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            character = xmlString.charAt(i);\n            switch (character) {\n                case '&':\n                    result.append(\"&amp;\");\n                    break;\n                case '\"':\n                    result.append(\"&quot;\");\n                    break;\n                case '<':\n                    result.append(\"&lt;\");\n                    break;\n                case '>':\n                    result.append(\"&gt;\");\n                    break;\n                case '\\n':\n                    result.append(\"\\n\");\n                    break;\n                case '\\r':\n                    result.append(\"\\r\");\n                    break;\n                case '\\t':\n                    result.append(\"\\t\");\n                    break;\n                default:\n                    if (character < 0x20) {\n                    } else if (character > 0x7F) {\n                        result.append(\"&#x\");\n                        result.append(Integer.toHexString(character).toUpperCase());\n                        result.append(\";\");\n                    } else {\n                        result.append(character);\n                    }\n                    break;\n            }\n        }\n\n        return result.toString();\n    }\n\n    protected String getElement(Element docel, String name)\n    {\n        Element el = docel.element(name);\n        if (el == null) {\n            return \"\";\n        } else {\n            return el.getText();\n        }\n    }\n\n    public void fromXML(String xml) throws XWikiException\n    {\n        fromXML(xml, false);\n    }\n\n    public void fromXML(InputStream is) throws XWikiException\n    {\n        fromXML(is, false);\n    }\n\n    public void fromXML(InputSource source, boolean withArchive) throws XWikiException\n    {\n        // Output\n        DocumentInstanceOutputProperties documentProperties = new DocumentInstanceOutputProperties();\n        XWikiContext xcontext = getXWikiContext();\n        if (xcontext != null) {\n            documentProperties.setDefaultReference(getXWikiContext().getWikiReference());\n        }\n\n        // Input\n        XARInputProperties xarProperties = new XARInputProperties();\n        xarProperties.setWithHistory(withArchive);\n\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).importEntity(XWikiDocument.class, this, source,\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // We have been reading from XML so the document does not need a new version when saved\n        setMetaDataDirty(false);\n        setContentDirty(false);\n    }\n\n    public void fromXML(String source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new StringInputSource(source), withArchive);\n    }\n\n    public void fromXML(InputStream source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new DefaultInputStreamInputSource(source), withArchive);\n    }\n\n    /**\n     * @deprecated use {@link #fromXML(InputStream)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void fromXML(Document domdoc, boolean withArchive) throws XWikiException\n    {\n        // Serialize the Document (could not find a way to convert a dom4j Document into a usable StAX source)\n        StringWriter writer = new StringWriter();\n        try {\n            org.dom4j.io.XMLWriter domWriter = new org.dom4j.io.XMLWriter(writer);\n            domWriter.write(domdoc);\n            domWriter.flush();\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // Actually parse the XML\n        fromXML(writer.toString(), withArchive);\n    }\n\n    /**\n     * Check if provided xml document is a wiki document.\n     *\n     * @param domdoc the xml document.\n     * @return true if provided xml document is a wiki document.\n     */\n    public static boolean containsXMLWikiDocument(Document domdoc)\n    {\n        return domdoc.getRootElement().getName().equals(XarDocumentModel.ELEMENT_DOCUMENT);\n    }\n\n    public void setAttachmentList(List<XWikiAttachment> list)\n    {\n        // For backwards compatibility reasons (and in general), we need to allow callers to do something like\n        // setAttachmentList(getAttachmentList())\n        if (this.attachmentList != list) {\n            this.attachmentList.clear();\n            this.attachmentList.addAll(list);\n        }\n    }\n\n    public List<XWikiAttachment> getAttachmentList()\n    {\n        return this.attachmentList;\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(XWikiContext context) throws XWikiException\n    {\n        saveAllAttachments(true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(boolean updateParent, boolean transaction, XWikiContext context)\n        throws XWikiException\n    {\n        for (XWikiAttachment attachment : this.attachmentList) {\n            saveAttachmentContent(attachment, false, transaction, context);\n        }\n\n        // Save the document\n        if (updateParent) {\n            context.getWiki().saveDocument(this, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentsContent(List<XWikiAttachment> attachments, XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : attachments) {\n            saveAttachmentContent(attachment, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        saveAttachmentContent(attachment, true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, boolean updateParent, boolean transaction,\n        XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            // Save the attachment\n            XWikiAttachmentStoreInterface store =\n                resolveXWikiAttachmentStoreInterface(attachment.getContentStore(), context);\n            store.saveAttachmentContent(attachment, false, context, transaction);\n\n            // We need to make sure there is a version upgrade\n            setMetaDataDirty(true);\n\n            // Save the document\n            if (updateParent) {\n                context.getWiki().saveDocument(this, context);\n            }\n        } catch (OutOfMemoryError e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_JAVA_HEAP_SPACE,\n                \"Out Of Memory Exception\");\n        } finally {\n            if (currentWiki != null) {\n                context.setWikiId(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link XWikiAttachment#loadContent(XWikiContext)}\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public void loadAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        String database = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            attachment.loadAttachmentContent(context);\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n        }\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     * <p>\n     * The attachment will be move to recycle bin.\n     *\n     * @param attachment the attachment to remove\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachment)\n    {\n        return removeAttachment(attachment, true);\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     *\n     * @param attachmentToRemove the attachment to remove\n     * @param toRecycleBin indicate if the attachment should be moved to recycle bin\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachmentToRemove, boolean toRecycleBin)\n    {\n        if (this.attachmentList.remove(attachmentToRemove)) {\n            this.attachmentsToRemove.add(new XWikiAttachmentToRemove(attachmentToRemove, toRecycleBin));\n            setMetaDataDirty(true);\n        } else {\n            attachmentToRemove = null;\n        }\n        return attachmentToRemove;\n    }\n\n    /**\n     * @return the attachment planned for removal\n     */\n    public List<XWikiAttachmentToRemove> getAttachmentsToRemove()\n    {\n        return this.attachmentsToRemove;\n    }\n\n    /**\n     * Clear the list of attachments planned for removal.\n     */\n    public void clearAttachmentsToRemove()\n    {\n        this.attachmentsToRemove.clear();\n    }\n\n    /**\n     * Get the wiki document references pointing to this document.\n     * <p>\n     * Theses links are stored in the Solr search core when the document is indexed. You can use \"backlinks\" in\n     * XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable links storage in the database.\n     * <p>\n     * Since 14.8RC1, this method return all backlinked documents and not just those located in the context wiki.\n     *\n     * @param context the XWiki context.\n     * @return the found wiki document references\n     * @throws XWikiException error when getting pages names from database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getBackLinkedReferences(XWikiContext context) throws XWikiException\n    {\n        Set<EntityReference> references;\n        try {\n            references = getLinkStore().resolveBackLinkedEntities(getDocumentReference());\n        } catch (LinkException e) {\n            throw new XWikiException(\"Failed to load backlinks for reference [\" + getDocumentReference() + \"]\", e);\n        }\n\n        Set<DocumentReference> documentReferences = new HashSet<>(references.size());\n        for (EntityReference entityReference : references) {\n            // Resolve the DOCUMENT reference\n            DocumentReference linkReference = context.getWiki().getDocumentReference(entityReference, context);\n\n            // Retro compatibility: remove the locale as it's what is expected of #getBackLinkedReferences(XWikicontext)\n            if (linkReference.getLocale() != null) {\n                linkReference = new DocumentReference(linkReference, (Locale) null);\n            }\n\n            // Add the reference\n            documentReferences.add(linkReference);\n        }\n\n        return new ArrayList<>(documentReferences);\n    }\n\n    /**\n     * @deprecated use {@link #getBackLinkedReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getBackLinkedPages(XWikiContext context) throws XWikiException\n    {\n        List<DocumentReference> references = getBackLinkedReferences(context);\n\n        EntityReferenceSerializer<String> serializer = getCompactWikiEntityReferenceSerializer();\n\n        List<String> documentNames = new ArrayList<>(references.size());\n        for (DocumentReference reference : references) {\n            // Serialize the reference\n            documentNames.add(serializer.serialize(reference));\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Get a list of unique links from this document to others documents.\n     * <ul>\n     * <li>xwiki/1.0 content: get the unique links associated to document from database. This is stored when the\n     * document is saved. You can use \"backlinks\" in XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable\n     * links storage in the database.</li>\n     * <li>Other content: call {@link #getUniqueLinkedPages(XWikiContext)} and generate the List.</li>\n     * </ul>\n     *\n     * @param context the XWiki context\n     * @return the found wiki links.\n     * @throws XWikiException error when getting links from database when xwiki/1.0 content.\n     * @since 1.9M2\n     */\n    public Set<XWikiLink> getUniqueWikiLinkedPages(XWikiContext context) throws XWikiException\n    {\n        Set<XWikiLink> links;\n\n        // We don't handle the links the same way in 1.0 syntax for retro-compatibility reason\n        // So here we explicitly get the link from the DB instead of looking inside the document.\n        if (is10Syntax()) {\n            links = new LinkedHashSet<>(getStore(context).loadLinks(getId(), context, true));\n        } else {\n            Set<String> linkedPages = getUniqueLinkedPages(context);\n            links = new LinkedHashSet<>(linkedPages.size());\n            for (String linkedPage : linkedPages) {\n                XWikiLink wikiLink = new XWikiLink();\n\n                wikiLink.setDocId(getId());\n                wikiLink.setFullName(LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n                wikiLink.setLink(linkedPage);\n\n                links.add(wikiLink);\n            }\n        }\n\n        return links;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) wiki links (pointing to wiki page) from this\n     * xwiki/1.0 document's content to others documents.\n     *\n     * @param context the XWiki context.\n     * @return the document references for linked pages, if null an error append.\n     * @since 1.9M2\n     */\n    private Set<DocumentReference> getUniqueLinkedPages10(XWikiContext context)\n    {\n        Set<DocumentReference> pageNames;\n\n        try {\n            List<String> list = context.getUtil().getUniqueMatches(getContent(), \"\\\\[(.*?)\\\\]\", 1);\n            pageNames = new HashSet<DocumentReference>(list.size());\n\n            DocumentReference currentDocumentReference = getDocumentReference();\n            for (String name : list) {\n                int i1 = name.indexOf('>');\n                if (i1 != -1) {\n                    name = name.substring(i1 + 1);\n                }\n                i1 = name.indexOf(\"&gt;\");\n                if (i1 != -1) {\n                    name = name.substring(i1 + 4);\n                }\n                i1 = name.indexOf('#');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n                i1 = name.indexOf('?');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n\n                // Let's get rid of anything that's not a real link\n                if (name.trim().equals(\"\") || (name.indexOf('$') != -1) || (name.indexOf(\"://\") != -1)\n                    || (name.indexOf('\"') != -1) || (name.indexOf('\\'') != -1) || (name.indexOf(\"..\") != -1)\n                    || (name.indexOf(':') != -1) || (name.indexOf('=') != -1)) {\n                    continue;\n                }\n\n                // generate the link\n                String newname = StringUtils.replace(Util.noaccents(name), \" \", \"\");\n\n                // If it is a local link let's add the space\n                if (newname.indexOf('.') == -1) {\n                    newname = getSpace() + \".\" + name;\n                }\n                if (context.getWiki().exists(newname, context)) {\n                    name = newname;\n                } else {\n                    // If it is a local link let's add the space\n                    if (name.indexOf('.') == -1) {\n                        name = getSpace() + \".\" + name;\n                    }\n                }\n\n                // If the reference is empty, the link is an autolink\n                if (!StringUtils.isEmpty(name)) {\n                    // The reference may not have the space or even document specified (in case of an empty\n                    // string)\n                    // Thus we need to find the fully qualified document name\n                    DocumentReference documentReference = getCurrentDocumentReferenceResolver().resolve(name);\n\n                    // Verify that the link is not an autolink (i.e. a link to the current document)\n                    if (!documentReference.equals(currentDocumentReference)) {\n                        pageNames.add(documentReference);\n                    }\n                }\n            }\n\n            return pageNames;\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to get linked documents\", e);\n\n            return null;\n        }\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to entities specified in the passed {@code entityTypes} map (the keys represent\n     * the entity references that will be returned).\n     *\n     * @param context the XWiki context\n     * @param entityTypes the mapping of the types of references to return (and their corresponding resource types)\n     * @return the serialized entity references, and null if an error happened\n     * @since 14.2RC1\n     */\n    private Set<EntityReference> getUniqueLinkedEntityReferences(XWikiContext context,\n        Map<EntityType, Set<ResourceType>> entityTypes)\n    {\n        Set<EntityReference> references;\n\n        XWikiDocument contextDoc = context.getDoc();\n        WikiReference contextWikiReference = context.getWikiReference();\n\n        try {\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiReference(getDocumentReference().getWikiReference());\n\n            if (is10Syntax()) {\n                references = (Set) getUniqueLinkedPages10(context);\n            } else {\n                references = new LinkedHashSet<>();\n\n                // Document content\n                XDOM dom = getXDOM();\n                getUniqueLinkedEntityReferences(dom, entityTypes, references);\n\n                // XObjects\n                for (List<BaseObject> xobjects : getXObjects().values()) {\n                    xobjects.stream()\n                        .forEach(xobject -> getUniqueLinkedEntityReferences(xobject, entityTypes, references, context));\n                }\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiReference(contextWikiReference);\n        }\n\n        return references;\n    }\n\n    private void getUniqueLinkedEntityReferences(BaseObject xobject, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references, XWikiContext xcontext)\n    {\n        if (xobject == null) {\n            return;\n        }\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n\n        for (Object fieldClass : xclass.getProperties()) {\n            // Wiki content stored in xobjects\n            if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                PropertyInterface field = xobject.getField(textAreaClass.getName());\n\n                // Make sure the field is the right type (might happen while a document is being migrated)\n                if (field instanceof LargeStringProperty) {\n                    LargeStringProperty largeField = (LargeStringProperty) field;\n\n                    try {\n                        XDOM dom = parseContent(getSyntax(), largeField.getValue(), getDocumentReference());\n                        getUniqueLinkedEntityReferences(dom, entityTypes, references);\n                    } catch (XWikiException e) {\n                        LOGGER.warn(\"Failed to extract links from xobject property [{}], skipping it. Error: {}\",\n                            largeField.getReference(), ExceptionUtils.getRootCauseMessage(e));\n                    }\n                }\n            }\n        }\n    }\n\n    private void getUniqueLinkedEntityReferences(XDOM dom, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references)\n    {\n        Set<EntityReference> uniqueLinkedEntityReferences =\n            getLinkParser().getUniqueLinkedEntityReferences(dom, entityTypes, getDocumentReference());\n        references.addAll(uniqueLinkedEntityReferences);\n    }\n\n    private Set<DocumentReference> toDocumentReferenceSet(Collection<? extends EntityReference> entityReferences,\n        DocumentReference baseReference)\n    {\n        Set<DocumentReference> documentReferences = new LinkedHashSet<>(entityReferences.size());\n\n        for (EntityReference entityRefefence : entityReferences) {\n            documentReferences.add(getCurrentReferenceDocumentReferenceResolver().resolve(entityRefefence,\n                EntityType.DOCUMENT, baseReference));\n        }\n\n        return documentReferences;\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to documents (either using a Document Reference or a Page Reference).\n     *\n     * @param context the XWiki context\n     * @return the serialized entity references, and null if an error happened\n     * @since 1.9M2\n     */\n    public Set<String> getUniqueLinkedPages(XWikiContext context)\n    {\n        // Only return document references.\n        Set<EntityReference> references = getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT,\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE,\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n        Set<String> documentNames = new LinkedHashSet<>(references.size());\n\n        XWikiDocument contextDoc = context.getDoc();\n        String contextWiki = context.getWikiId();\n        EntityReferenceSerializer<String> serializer;\n\n        try {\n            // Specify the right context information for using the compact wiki serializer properly\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiId(getDocumentReference().getWikiReference().getName());\n\n            // for retro-compatibility reason we don't use the same serializer for 1.0 syntax.\n            if (is10Syntax()) {\n                serializer = getCompactEntityReferenceSerializer();\n            } else {\n                serializer = getCompactWikiEntityReferenceSerializer();\n            }\n\n            for (EntityReference reference : references) {\n                // Get the reference of the document\n                DocumentReference linkDocumentReference = context.getWiki().getDocumentReference(reference, context);\n\n                // Serialize the reference\n                documentNames.add(serializer.serialize(linkDocumentReference));\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiId(contextWiki);\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) entity references pointed by wiki links (pointing\n     * to wiki document or attachments) for the current context document.\n     *\n     * @param context the XWiki context\n     * @return the entity references pointing to either document or attachments. If {@code null}, an error happened\n     * @since 14.2RC1\n     */\n    @Unstable\n    public Set<EntityReference> getUniqueLinkedEntities(XWikiContext context)\n    {\n        // Return both document and attachment references.\n        // Note that we return PAGE and PAGE_ATTACHMENT since it's not possible to convert them to DOCUMENT and\n        // ATTACHMENT since there's no way of knowing (without querying the DB) if they point to a terminal page or\n        // a non-terminal one (and thus the conversion would be wrong).\n        return getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE),\n            EntityType.ATTACHMENT, Set.of(\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE_ATTACHMENT, Set.of(\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     * {@link #getChildren(int, int, com.xpn.xwiki.XWikiContext)}\n     *\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(XWikiContext context) throws XWikiException\n    {\n        return getChildrenReferences(0, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(XWikiContext context) throws XWikiException\n    {\n        return getChildren(0, 0, context);\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     *\n     * @param nb The number of results to return.\n     * @param start The number of results to skip before we begin returning results.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return the list of document references\n     * @throws XWikiException If there's an error querying the database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        // Use cases:\n        // - the parent document reference saved in the database matches the reference of this document, in its fully\n        // serialized form (eg \"wiki:space.page\"). Note that this is normally not required since the wiki part\n        // isn't saved in the database when it matches the current wiki.\n        // - the parent document reference saved in the database matches the reference of this document, in its\n        // serialized form without the wiki part (eg \"space.page\"). The reason we don't need to specify the wiki\n        // part is because document parents saved in the database don't have the wiki part specified when it matches\n        // the current wiki.\n        // - the parent document reference saved in the database matches the page name part of this document's\n        // reference (eg \"page\") and the parent document's space is the same as this document's space.\n        List<DocumentReference> children = new ArrayList<DocumentReference>();\n\n        try {\n            Query query = getStore().getQueryManager()\n                .createQuery(\"select distinct doc.fullName from XWikiDocument doc where \"\n                    + \"doc.parent=:prefixedFullName or doc.parent=:fullName or (doc.parent=:name and doc.space=:space)\",\n                    Query.XWQL);\n            query.addFilter(Utils.getComponent(QueryFilter.class, \"hidden\"));\n            query.bindValue(\"prefixedFullName\",\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()));\n            query.bindValue(\"fullName\", LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n            query.bindValue(\"name\", getDocumentReference().getName());\n            query.bindValue(\"space\",\n                LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference()));\n            query.setLimit(nb).setOffset(start);\n\n            List<String> queryResults = query.execute();\n            WikiReference wikiReference = this.getDocumentReference().getWikiReference();\n            for (String fullName : queryResults) {\n                children.add(getCurrentDocumentReferenceResolver().resolve(fullName, wikiReference));\n            }\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to retrieve children for document [%s]\", this.getDocumentReference()), e);\n        }\n\n        return children;\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        List<String> childrenNames = new ArrayList<String>();\n        for (DocumentReference reference : getChildrenReferences(nb, start, context)) {\n            childrenNames.add(LOCAL_REFERENCE_SERIALIZER.serialize(reference));\n        }\n        return childrenNames;\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public void renameProperties(DocumentReference classReference, Map<String, String> fieldsToRename)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            return;\n        }\n\n        boolean isDirty = false;\n        for (BaseObject bobject : objects) {\n            if (bobject == null) {\n                continue;\n            }\n            for (Map.Entry<String, String> entry : fieldsToRename.entrySet()) {\n                String origname = entry.getKey();\n                String newname = entry.getValue();\n                BaseProperty origprop = (BaseProperty) bobject.safeget(origname);\n                if (origprop != null) {\n                    BaseProperty prop = origprop.clone();\n                    bobject.removeField(origname);\n                    prop.setName(newname);\n                    bobject.addField(newname, prop);\n\n                    isDirty = true;\n                }\n            }\n        }\n\n        // If at least one property was renamed, mark the document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #renameProperties(DocumentReference, Map)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void renameProperties(String className, Map<String, String> fieldsToRename)\n    {\n        renameProperties(resolveClassReference(className), fieldsToRename);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void addXObjectToRemove(BaseObject object)\n    {\n        getXObjectsToRemove().add(object);\n        object.setOwnerDocument(null);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Automatically add objects present in the old version, but not in the current document, to the list of objects\n     * marked for removal from the database.\n     *\n     * @param previousVersion the version of the document present in the database\n     * @since 3.3M2\n     */\n    public void addXObjectsToRemoveFromVersion(XWikiDocument previousVersion)\n    {\n        if (previousVersion == null) {\n            return;\n        }\n        for (List<BaseObject> objects : previousVersion.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                if (originalObj != null) {\n                    BaseObject newObj = getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    if (newObj == null) {\n                        // The object was deleted.\n                        this.addXObjectToRemove(originalObj);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectToRemove(BaseObject)} )} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void addObjectsToRemove(BaseObject object)\n    {\n        addXObjectToRemove(object);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List<BaseObject> getXObjectsToRemove()\n    {\n        return this.xObjectsToRemove;\n    }\n\n    /**\n     * @deprecated use {@link #getObjectsToRemove()} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public ArrayList<BaseObject> getObjectsToRemove()\n    {\n        return (ArrayList<BaseObject>) getXObjectsToRemove();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjectsToRemove(List<BaseObject> objectsToRemove)\n    {\n        this.xObjectsToRemove = objectsToRemove;\n        setMetaDataDirty(true);\n    }\n\n    public List<String> getIncludedPages(XWikiContext context)\n    {\n        try {\n            return getIncludedPagesInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we return an empty list of included pages. We don't want to fail by throwing an\n            // exception since it'll lead to several errors in the UI (such as in the Information Panel in edit mode).\n            LOGGER.error(\"Failed to get included pages for [{}]\", getDocumentReference(), e);\n            return Collections.emptyList();\n        }\n    }\n\n    private List<String> getIncludedPagesInternal(XWikiContext context)\n    {\n        if (is10Syntax()) {\n            return getIncludedPagesForXWiki10Syntax(getContent(), context);\n        } else {\n            // Find all include macros listed on the page\n            XDOM dom = getXDOM();\n\n            List<String> result = new ArrayList<String>();\n            List<MacroBlock> macroBlocks =\n                dom.getBlocks(new ClassBlockMatcher(MacroBlock.class), Block.Axes.DESCENDANT);\n            for (MacroBlock macroBlock : macroBlocks) {\n                // - Add each document pointed to by the include macro\n                // - Also add all the included pages found in the velocity macro when using the deprecated #include*\n                // macros\n                // This should be removed when we fully drop support for the XWiki Syntax 1.0 but for now we want to\n                // play nice with people migrating from 1.0 to 2.0 syntax\n\n                if (macroBlock.getId().equalsIgnoreCase(\"include\") || macroBlock.getId().equalsIgnoreCase(\"display\")) {\n                    String documentName = macroBlock.getParameters().get(\"reference\");\n                    if (StringUtils.isEmpty(documentName)) {\n                        documentName = macroBlock.getParameters().get(\"document\");\n                        if (StringUtils.isEmpty(documentName)) {\n                            continue;\n                        }\n                    }\n\n                    DocumentReference documentReference =\n                        getExplicitDocumentReferenceResolver().resolve(documentName, getDocumentReference());\n                    if (this.getDocumentReference().equals(documentReference)) {\n                        // Skip auto-includes since they are not allowed anyway.\n                        continue;\n                    }\n\n                    documentName = LOCAL_REFERENCE_SERIALIZER.serialize(documentReference);\n\n                    result.add(documentName);\n                } else if (macroBlock.getId().equalsIgnoreCase(\"velocity\")\n                    && !StringUtils.isEmpty(macroBlock.getContent())) {\n                    // Try to find matching content inside each velocity macro\n                    result.addAll(getIncludedPagesForXWiki10Syntax(macroBlock.getContent(), context));\n                }\n            }\n\n            return result;\n        }\n    }\n\n    private List<String> getIncludedPagesForXWiki10Syntax(String content, XWikiContext context)\n    {\n        try {\n            String pattern = \"#include(Topic|InContext|Form|Macros|parseGroovyFromPage)\\\\([\\\"'](.*?)[\\\"']\\\\)\";\n            List<String> list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, getSpace() + \".\" + name);\n                }\n            }\n\n            return list;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to extract include target from provided content [\" + content + \"]\", e);\n\n            return null;\n        }\n    }\n\n    public List<String> getIncludedMacros(XWikiContext context)\n    {\n        return context.getWiki().getIncludedMacros(getSpace(), getContent(), context);\n    }\n\n    public String displayRendered(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n        throws XWikiException\n    {\n        String result = pclass.displayView(pclass.getName(), prefix, object, context);\n        return getRenderedContent(result, Syntax.XWIKI_1_0.toIdString(), context);\n    }\n\n    public String displayView(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayView(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayEdit(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayEdit(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayHidden(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayHidden(pclass.getName(), prefix, object, context);\n    }\n\n    /**\n     * Return the first attachment of the attachment list either exactly matching the provided filename or that matches \n     * the provided filename with a n arbitrary extension (i.e., filename.ext). To get only attachments that exactly\n     * matches the provided filename use {@link #getExactAttachment(String)}.\n     * \n     * @param filename the file name of the attachment with or without the extension\n     * @return the {@link XWikiAttachment} corresponding to the file name, null if none can be found\n     * @see #getExactAttachment(String) \n     */\n    public XWikiAttachment getAttachment(String filename)\n    {\n        XWikiAttachment output = this.attachmentList.getByFilename(filename);\n        if (output != null) {\n            return output;\n        }\n\n        for (XWikiAttachment attach : getAttachmentList()) {\n            if (attach.getFilename().startsWith(filename + \".\")) {\n                return attach;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Return the attachment that exactly matches the provided file. To also get the first attachment that matches the\n     * provided filename with an arbitrary extension use {@link #getAttachment(String)}.\n     *\n     * @param filename the file name of the attachment\n     * @return the {@link XWikiAttachment} exactly corresponding to the file name, null if none can be found\n     * @since 14.1RC1\n     * @since 13.10.3\n     */\n    public XWikiAttachment getExactAttachment(String filename)\n    {\n        return this.attachmentList.getByFilename(filename);\n    }\n\n    /**\n     * Add passed attachment to the document.\n     *\n     * @param attachment the attachment to add\n     * @since 5.3M2\n     * @deprecated use {@link #setAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public void addAttachment(XWikiAttachment attachment)\n    {\n        setAttachment(attachment);\n    }\n\n    /**\n     * Insert passed attachment in the document and return any pre-existing attachment with the same name.\n     * \n     * @param attachment the attachment to insert in the document\n     * @return the attachment replaced by the passed attachment\n     * @since 9.10RC1\n     */\n    public XWikiAttachment setAttachment(XWikiAttachment attachment)\n    {\n        return this.attachmentList.set(attachment);\n    }\n\n    /**\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiAttachment addAttachment(String fileName, byte[] content, XWikiContext context) throws XWikiException\n    {\n        try {\n            return setAttachment(fileName, new ByteArrayInputStream(content != null ? content : new byte[0]), context);\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to set Attachment content\", e);\n        }\n    }\n\n    /**\n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws XWikiException never sent\n     * @throws IOException when failing to read the passed content\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public XWikiAttachment addAttachment(String fileName, InputStream content, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        return setAttachment(fileName, content, context);\n    }\n\n    /**\n     * Create or update attachment with the passed name with the passed content.\n     * \n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws IOException when failing to read the passed content\n     * @since 9.10rc1\n     */\n    public XWikiAttachment setAttachment(String fileName, InputStream content, XWikiContext context) throws IOException\n    {\n        int i = fileName.indexOf('\\\\');\n        if (i == -1) {\n            i = fileName.indexOf('/');\n        }\n\n        String filename = fileName.substring(i + 1);\n\n        XWikiAttachment attachment = getExactAttachment(filename);\n        if (attachment == null) {\n            attachment = new XWikiAttachment(this, filename);\n\n            // Add the attachment in the current doc\n            setAttachment(attachment);\n        }\n\n        attachment.setContent(content);\n        attachment.setAuthorReference(context.getUserReference());\n\n        return attachment;\n    }\n\n    public BaseObject getFirstObject(String fieldname)\n    {\n        // Keeping this function with context null for compatibility reasons.\n        // It should not be used, since it would miss properties which are only defined in the class\n        // and not present in the object because the object was not updated\n        return getFirstObject(fieldname, null);\n    }\n\n    public BaseObject getFirstObject(String fieldname, XWikiContext context)\n    {\n        Collection<List<BaseObject>> objectscoll = getXObjects().values();\n        if (objectscoll == null) {\n            return null;\n        }\n\n        for (List<BaseObject> objects : objectscoll) {\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    BaseClass bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        Set<String> set = bclass.getPropertyList();\n                        if ((set != null) && set.contains(fieldname)) {\n                            return obj;\n                        }\n                    }\n                    Set<String> set = obj.getPropertyList();\n                    if ((set != null) && set.contains(fieldname)) {\n                        return obj;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setProperty(EntityReference classReference, String fieldName, BaseProperty value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.safeput(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setProperty(EntityReference, String, BaseProperty)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setProperty(String className, String fieldName, BaseProperty value)\n    {\n        setProperty(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName)\n    {\n        return getIntValue(classReference, fieldName, 0);\n    }\n\n    /**\n     * Retrieve the int value of the given property of the first object of the given class.\n     *\n     * @param classReference the reference of the object to find\n     * @param fieldName the property to get the value from\n     * @param defaultValue the default value to return if the object doesn't exist, or if the property is not set\n     * @return the retrieved value or the default value.\n     * @since 11.9RC1\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName, int defaultValue)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return defaultValue;\n        }\n\n        return obj.getIntValue(fieldName, defaultValue);\n    }\n\n    /**\n     * @deprecated use {@link #getIntValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public int getIntValue(String className, String fieldName)\n    {\n        return getIntValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public long getLongValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return 0;\n        }\n\n        return obj.getLongValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getLongValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public long getLongValue(String className, String fieldName)\n    {\n        return getLongValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 6.2M1\n     */\n    public String getStringValue(EntityReference classReference, String fieldName)\n    {\n        return getStringValue(resolveClassReference(classReference), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public String getStringValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return \"\";\n        }\n\n        String result = obj.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getStringValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public String getStringValue(String className, String fieldName)\n    {\n        return getStringValue(resolveClassReference(className), fieldName);\n    }\n\n    public int getIntValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getIntValue(fieldName);\n        }\n    }\n\n    public long getLongValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getLongValue(fieldName);\n        }\n    }\n\n    public String getStringValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return \"\";\n        }\n\n        String result = object.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringValue(String className, String fieldName, String value)\n    {\n        setStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List getListValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return new ArrayList();\n        }\n\n        return obj.getListValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getListValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List getListValue(String className, String fieldName)\n    {\n        return getListValue(resolveClassReference(className), fieldName);\n    }\n\n    public List getListValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return new ArrayList();\n        }\n\n        return object.getListValue(fieldName);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringListValue(String className, String fieldName, List value)\n    {\n        setStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setDBStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setDBStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setDBStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setDBStringListValue(String className, String fieldName, List value)\n    {\n        setDBStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setLargeStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setLargeStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setLargeStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setLargeStringValue(String className, String fieldName, String value)\n    {\n        setLargeStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setIntValue(EntityReference classReference, String fieldName, int value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setIntValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setIntValue(EntityReference, String, int)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setIntValue(String className, String fieldName, int value)\n    {\n        setIntValue(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getDatabase()\n    {\n        return getDocumentReference().getWikiReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setDatabase(String database)\n    {\n        if (database != null) {\n            DocumentReference reference = getDocumentReference();\n            WikiReference wiki = reference.getWikiReference();\n            WikiReference newWiki = new WikiReference(database);\n            if (!newWiki.equals(wiki)) {\n                setDocumentReferenceInternal(reference.replaceParent(wiki, newWiki));\n            }\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getLanguage()\n    {\n        return getLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setLanguage(String language)\n    {\n        setLocale(LocaleUtils.toLocale(Util.normalizeLanguage(language), Locale.ROOT));\n    }\n\n    /**\n     * @return the locale of the document\n     */\n    public Locale getLocale()\n    {\n        return this.locale != null ? this.locale : Locale.ROOT;\n    }\n\n    /**\n     * @param locale the locale of the document\n     */\n    public void setLocale(Locale locale)\n    {\n        this.locale = locale;\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDefaultLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getDefaultLanguage()\n    {\n        return getDefaultLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setDefaultLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setDefaultLanguage(String defaultLanguage)\n    {\n        setDefaultLocale(LocaleUtils.toLocale(defaultLanguage, Locale.ROOT));\n    }\n\n    public Locale getDefaultLocale()\n    {\n        return this.defaultLocale != null ? this.defaultLocale : Locale.ROOT;\n    }\n\n    public void setDefaultLocale(Locale defaultLocale)\n    {\n        this.defaultLocale = defaultLocale;\n\n        setMetaDataDirty(true);\n    }\n\n    public int getTranslation()\n    {\n        return getLocale().equals(Locale.ROOT) ? 0 : 1;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's called by Hibernate when loading a XWikiDocument.\n     *\n     * @deprecated stored in the database to speedup some queries (really ?) but in {@link XWikiDocument}\n     *             it's calculated based on the document locale\n     */\n    @Deprecated(since = \"5.4.6\")\n    public void setTranslation(int translation)\n    {\n        // Do nothing\n    }\n\n    public String getTranslatedContent(XWikiContext context) throws XWikiException\n    {\n        String language = context.getWiki().getLanguagePreference(context);\n\n        return getTranslatedContent(language, context);\n    }\n\n    public String getTranslatedContent(String locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(locale, context);\n        return tdoc.getContent();\n    }\n\n    public XWikiDocument getTranslatedDocument(XWikiContext context) throws XWikiException\n    {\n        String locale = context.getWiki().getLanguagePreference(context);\n        return getTranslatedDocument(locale, context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param language the language of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     * @deprecated use {@link #getTranslatedDocument(Locale, XWikiContext)} insead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public XWikiDocument getTranslatedDocument(String language, XWikiContext context) throws XWikiException\n    {\n        return getTranslatedDocument(LocaleUtils.toLocale(language, Locale.ROOT), context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param locale the locale of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     */\n    public XWikiDocument getTranslatedDocument(Locale locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = this;\n\n        if (locale != null && !locale.equals(Locale.ROOT) && !locale.equals(getDefaultLocale())) {\n            try {\n                tdoc = context.getWiki().getDocument(new DocumentReference(getDocumentReference(), locale), context);\n\n                if (!tdoc.isNew()) {\n                    return tdoc;\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Error when loading document {} for locale {}\", getDocumentReference(), locale, e);\n            }\n\n            tdoc = getTranslatedDocument(LocaleUtils.getParentLocale(locale), context);\n        }\n\n        return tdoc;\n    }\n\n    /**\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage(XWikiContext context) throws XWikiException\n    {\n        return getRealLanguage();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getRealLanguage()\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Override\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage()\n    {\n        String lang = getLanguage();\n        if (lang.equals(\"\")) {\n            return getDefaultLanguage();\n        } else {\n            return lang;\n        }\n    }\n\n    /**\n     * @return the actual locale of the document\n     */\n    public Locale getRealLocale()\n    {\n        Locale locale = getLocale();\n        if (locale.equals(Locale.ROOT)) {\n            locale = getDefaultLocale();\n        }\n\n        return locale;\n    }\n\n    /**\n     * @deprecated use {@link #getTranslationLocales(XWikiContext)} instead\n     */\n    @Deprecated(since = \"5.1M2\")\n    public List<String> getTranslationList(XWikiContext context) throws XWikiException\n    {\n        // in few cases like accessing a deleted document, the store might be null.\n        if (getStore() != null) {\n            return getStore().getTranslationList(this, context);\n        } else {\n            return Collections.emptyList();\n        }\n\n    }\n\n    /**\n     * The locales of the translation of this document (the default locale is not included).\n     *\n     * @param context the XWiki context\n     * @return the locales of the translations\n     * @throws XWikiException if retriving the translations from the database failed\n     */\n    public List<Locale> getTranslationLocales(XWikiContext context) throws XWikiException\n    {\n        List<String> translations = getTranslationList(context);\n\n        List<Locale> locales = new ArrayList<Locale>(translations.size());\n        for (String translationString : translations) {\n            locales.add(LocaleUtils.toLocale(translationString));\n        }\n\n        return locales;\n    }\n\n    public List<Delta> getXMLDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.toXML(context)), ToString.stringToArray(toDoc.toXML(context))));\n    }\n\n    public List<Delta> getContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.getContent()), ToString.stringToArray(toDoc.getContent())));\n    }\n\n    public List<Delta> getContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n        if (fromDoc == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", fromRev,\n                    this.getDocumentReference()));\n        }\n        if (toRev == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", toRev,\n                    this.getDocumentReference()));\n        }\n        return getContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n        return getContentDiff(revdoc, this, context);\n    }\n\n    public List<Delta> getLastChanges(XWikiContext context) throws XWikiException, DifferentiationFailedException\n    {\n        Version version = getRCSVersion();\n        try {\n            String prev = getDocumentArchive(context).getPrevVersion(version).toString();\n            XWikiDocument prevDoc = context.getWiki().getDocument(this, prev, context);\n\n            return getDeltas(\n                Diff.diff(ToString.stringToArray(prevDoc.getContent()), ToString.stringToArray(getContent())));\n        } catch (Exception ex) {\n            LOGGER.debug(\"Exception getting differences from previous version: \" + ex.getMessage());\n        }\n\n        return new ArrayList<Delta>();\n    }\n\n    public List<Delta> getRenderedContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        String originalContent = fromDoc.getRenderedContent(context);\n        String newContent = toDoc.getRenderedContent(context);\n\n        return getDeltas(Diff.diff(ToString.stringToArray(originalContent), ToString.stringToArray(newContent)));\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getRenderedContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getRenderedContentDiff(revdoc, this, context);\n    }\n\n    protected List<Delta> getDeltas(Revision rev)\n    {\n        List<Delta> list = new ArrayList<Delta>();\n        for (int i = 0; i < rev.size(); i++) {\n            list.add(rev.getDelta(i));\n        }\n\n        return list;\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, String toRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getMetaDataDiff(fromDoc, toDoc, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getMetaDataDiff(revdoc, this, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException\n    {\n        List<MetaDataDiff> list = new ArrayList<MetaDataDiff>();\n\n        if (fromDoc == null || toDoc == null) {\n            return list;\n        }\n\n        if (!fromDoc.getTitle().equals(toDoc.getTitle())) {\n            list.add(new MetaDataDiff(\"title\", fromDoc.getTitle(), toDoc.getTitle()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getRelativeParentReference(), toDoc.getRelativeParentReference())) {\n            list.add(new MetaDataDiff(\"parent\", fromDoc.getParent(), toDoc.getParent()));\n        }\n\n        UserReference fromDocOriginalAuthor = fromDoc.getAuthors().getOriginalMetadataAuthor();\n        UserReference toDocOriginalAuthor = toDoc.getAuthors().getOriginalMetadataAuthor();\n        if (ObjectUtils.notEqual(fromDocOriginalAuthor, toDocOriginalAuthor)) {\n            list.add(new MetaDataDiff(\"author\", userReferenceToString(fromDocOriginalAuthor),\n                userReferenceToString(toDocOriginalAuthor)));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDocumentReference(), toDoc.getDocumentReference())) {\n            list.add(new MetaDataDiff(\"reference\", fromDoc.getDocumentReference(), toDoc.getDocumentReference()));\n        }\n\n        if (!fromDoc.getSpace().equals(toDoc.getSpace())) {\n            list.add(new MetaDataDiff(\"web\", fromDoc.getSpace(), toDoc.getSpace()));\n        }\n\n        if (!fromDoc.getName().equals(toDoc.getName())) {\n            list.add(new MetaDataDiff(\"name\", fromDoc.getName(), toDoc.getName()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getLocale(), toDoc.getLocale())) {\n            list.add(new MetaDataDiff(\"language\", fromDoc.getLanguage(), toDoc.getLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDefaultLocale(), toDoc.getDefaultLocale())) {\n            list.add(new MetaDataDiff(\"defaultLanguage\", fromDoc.getDefaultLanguage(), toDoc.getDefaultLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getSyntax(), toDoc.getSyntax())) {\n            list.add(new MetaDataDiff(\"syntax\", fromDoc.getSyntax(), toDoc.getSyntax()));\n        }\n\n        if (fromDoc.isHidden() != toDoc.isHidden()) {\n            list.add(new MetaDataDiff(\"hidden\", fromDoc.isHidden(), toDoc.isHidden()));\n        }\n\n        return list;\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getObjectDiff(fromDoc, toDoc, context);\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getObjectDiff(revdoc, this, context);\n    }\n\n    /**\n     * Return the object differences between two document versions. There is no hard requirement on the order of the two\n     * versions, but the results are semantically correct only if the two versions are given in the right order.\n     *\n     * @param fromDoc The old ('before') version of the document.\n     * @param toDoc The new ('after') version of the document.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return The object differences. The returned list's elements are other lists, one for each changed object. The\n     *         inner lists contain {@link ObjectDiff} elements, one object for each changed property of the object.\n     *         Additionally, if the object was added or removed, then the first entry in the list will be an\n     *         \"object-added\" or \"object-removed\" marker.\n     */\n    public List<List<ObjectDiff>> getObjectDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n\n        // Since objects could have been deleted or added, we iterate on both the old and the new\n        // object collections.\n        // First, iterate over the old objects.\n        for (List<BaseObject> objects : fromDoc.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (originalObj != null) {\n                    BaseObject newObj = toDoc.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    List<ObjectDiff> dlist;\n                    if (newObj == null) {\n                        // The object was deleted.\n                        dlist = new BaseObject().getDiff(originalObj, context);\n                        ObjectDiff deleteMarker =\n                            new ObjectDiff(originalObj.getXClassReference(), originalObj.getNumber(),\n                                originalObj.getGuid(), ObjectDiff.ACTION_OBJECTREMOVED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, deleteMarker);\n                    } else {\n                        // The object exists in both versions, but might have been changed.\n                        dlist = newObj.getDiff(originalObj, context);\n                    }\n                    if (!dlist.isEmpty()) {\n                        difflist.add(dlist);\n                    }\n                }\n            }\n        }\n\n        // Second, iterate over the objects which are only in the new version.\n        for (List<BaseObject> objects : toDoc.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (newObj != null) {\n                    BaseObject originalObj = fromDoc.getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // TODO: Refactor this so that getDiff() accepts null Object as input.\n                        // Only consider added objects, the other case was treated above.\n                        originalObj = new BaseObject();\n                        originalObj.setXClassReference(newObj.getRelativeXClassReference());\n                        originalObj.setNumber(newObj.getNumber());\n                        originalObj.setGuid(newObj.getGuid());\n                        List<ObjectDiff> dlist = newObj.getDiff(originalObj, context);\n                        ObjectDiff addMarker = new ObjectDiff(newObj.getXClassReference(), newObj.getNumber(),\n                            newObj.getGuid(), ObjectDiff.ACTION_OBJECTADDED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, addMarker);\n                        if (!dlist.isEmpty()) {\n                            difflist.add(dlist);\n                        }\n                    }\n                }\n            }\n        }\n\n        return difflist;\n    }\n\n    public List<List<ObjectDiff>> getClassDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n        BaseClass oldClass = fromDoc.getXClass();\n        BaseClass newClass = toDoc.getXClass();\n\n        if ((newClass == null) && (oldClass == null)) {\n            return difflist;\n        }\n\n        List<ObjectDiff> dlist = newClass.getDiff(oldClass, context);\n        if (!dlist.isEmpty()) {\n            difflist.add(dlist);\n        }\n\n        return difflist;\n    }\n\n    /**\n     * @param fromDoc\n     * @param toDoc\n     * @param context\n     * @return\n     */\n    public List<AttachmentDiff> getAttachmentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<AttachmentDiff> difflist = new ArrayList<AttachmentDiff>();\n        for (XWikiAttachment origAttach : fromDoc.getAttachmentList()) {\n            String fileName = origAttach.getFilename();\n            XWikiAttachment newAttach = toDoc.getAttachment(fileName);\n            origAttach = retrieveDeletedAttachment(fromDoc, origAttach, context);\n            if (newAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.DELETE, origAttach, newAttach));\n            } else {\n                newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n                try {\n                    if (!origAttach.equalsData(newAttach, context)) {\n                        difflist\n                            .add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.CHANGE, origAttach, newAttach));\n                    }\n                } catch (XWikiException e) {\n                    LOGGER.error(\"Failed to compare attachments [{}] and [{}]\", origAttach.getReference(),\n                        newAttach.getReference(), e);\n                }\n            }\n        }\n\n        for (XWikiAttachment newAttach : toDoc.getAttachmentList()) {\n            String fileName = newAttach.getFilename();\n            XWikiAttachment origAttach = fromDoc.getAttachment(fileName);\n            newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n            if (origAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.INSERT, origAttach, newAttach));\n            }\n        }\n\n        return difflist;\n    }\n\n    private XWikiAttachment retrieveDeletedAttachment(XWikiDocument doc, XWikiAttachment attachment,\n        XWikiContext context)\n    {\n        XWikiAttachment result = null;\n\n        InputStream is = null;\n        try {\n            is = attachment.getContentInputStream(context);\n            if (is == null) {\n                AttachmentRecycleBinStore attachmentRecycleBinStore = context.getWiki().getAttachmentRecycleBinStore();\n                List<DeletedAttachment> allDeletedAttachments =\n                    attachmentRecycleBinStore.getAllDeletedAttachments(doc, context, true);\n\n                for (DeletedAttachment deletedAttachment : allDeletedAttachments) {\n                    XWikiAttachment restoredAttachment = deletedAttachment.restoreAttachment();\n                    if (restoredAttachment.getDate().before(attachment.getDate())) {\n                        break;\n                    }\n                    result = restoredAttachment;\n                }\n\n                if (result != null) {\n                    if (!Objects.equals(attachment.getVersion(), result.getVersion())) {\n                        result = result.getAttachmentRevision(attachment.getVersion(), context);\n                    }\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Error while trying to load deleted attachment [{}] for doc [{}]\", attachment, doc, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException ex) {\n\n                }\n            }\n        }\n\n        if (result == null) {\n            result = attachment;\n        } else {\n            result.setDoc(doc);\n        }\n        return result;\n    }\n\n    /**\n     * Rename the current document and all the backlinks leading to it. Will also change parent field in all documents\n     * which list the document we are renaming as their parent.\n     * <p>\n     * See {@link #rename(DocumentReference, List, List, XWikiContext)} for more details.\n     *\n     * @param newDocumentReference the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, getBackLinkedReferences(context), context);\n    }\n\n    /**\n     * Rename the current document and all the links pointing to it in the list of passed backlink documents. The\n     * renaming algorithm takes into account the fact that there are several ways to write a link to a given page and\n     * all those forms need to be renamed. For example the following links all point to the same page:\n     * <ul>\n     * <li>[Page]</li>\n     * <li>[Page?param=1]</li>\n     * <li>[currentwiki:Page]</li>\n     * <li>[CurrentSpace.Page]</li>\n     * <li>[currentwiki:CurrentSpace.Page]</li>\n     * </ul>\n     * <p>\n     * Note: links without a space are renamed with the space added and all documents which have the document being\n     * renamed as parent have their parent field set to \"currentwiki:CurrentSpace.Page\".\n     * </p>\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, backlinkDocumentReferences, getChildrenReferences(context), context);\n    }\n\n    /**\n     * Same as {@link #rename(DocumentReference, List, XWikiContext)} but the list of documents having the current\n     * document as their parent is passed in parameter.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context) throws XWikiException\n    {\n        // TODO: Do all this in a single DB transaction as otherwise the state will be unknown if\n        // something fails in the middle...\n\n        // TODO: Why do we verify if the document has just been created and not been saved.\n        // If the user is trying to rename to the same name... In that case, simply exits for efficiency.\n        if (isNew() || getDocumentReference().equals(newDocumentReference)) {\n            return;\n        }\n        context.getWiki().renameByCopyAndDelete(this,\n            newDocumentReference,\n            backlinkDocumentReferences,\n            childDocumentReferences, context);\n    }\n\n    /**\n     * Clone a document and change its reference.\n     *\n     * @param newDocumentReference the new reference of the cloned document.\n     * @param context the current context.\n     * @return a clone of the current document with a new reference.\n     * @throws XWikiException in case of problem during the clone operation.\n     * @since 12.5RC1\n     */\n    public XWikiDocument cloneRename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        loadAttachments(context);\n        loadArchive(context);\n        return this.cloneInternal(newDocumentReference, true, true);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        return copyDocument(newDocumentReference, true, context);\n    }\n\n    /**\n     * @since 14.3RC1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, boolean cloneArchive, XWikiContext context)\n        throws XWikiException\n    {\n        loadAttachments(context);\n        if (cloneArchive) {\n            loadArchive(context);\n        }\n\n        XWikiDocument newdoc = cloneInternal(newDocumentReference, false, cloneArchive);\n\n        // If the copied document has a title set to the original page name then set the new title to be the new page\n        // name.\n        if (StringUtils.equals(newdoc.getTitle(), getPrettyName(this.getDocumentReference()))) {\n            newdoc.setTitle(getPrettyName(newDocumentReference));\n        }\n\n        newdoc.setOriginalDocument(null);\n        newdoc.setContentDirty(true);\n        newdoc.setNew(true);\n\n        return newdoc;\n    }\n\n    /**\n     * Avoid the technical \"WebHome\" name.\n     *\n     * @param documentReference a document reference\n     * @return the last space name if the document is the home of a space, the document name otherwise\n     */\n    private String getPrettyName(DocumentReference documentReference)\n    {\n        EntityReferenceProvider defaultEntityReferenceProvider = Utils.getComponent(EntityReferenceProvider.class);\n        if (defaultEntityReferenceProvider.getDefaultReference(documentReference.getType()).getName()\n            .equals(documentReference.getName())) {\n            return documentReference.getLastSpaceReference().getName();\n        }\n        return documentReference.getName();\n    }\n\n    /**\n     * @deprecated use {@link #copyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument copyDocument(String newDocumentName, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), context);\n    }\n\n    public XWikiLock getLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock theLock = getStore(context).loadLock(getId(), context, true);\n        if (theLock != null) {\n            int timeout = context.getWiki().getXWikiPreferenceAsInt(\"lock_Timeout\", 30 * 60, context);\n            if (theLock.getDate().getTime() + timeout * 1000 < new Date().getTime()) {\n                getStore(context).deleteLock(theLock, context, true);\n                theLock = null;\n            }\n        }\n\n        return theLock;\n    }\n\n    public void setLock(String userName, XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = new XWikiLock(getId(), userName);\n        getStore(context).saveLock(lock, context, true);\n    }\n\n    public void removeLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = getStore(context).loadLock(getId(), context, true);\n        if (lock != null) {\n            getStore(context).deleteLock(lock, context, true);\n        }\n    }\n\n    public void insertText(String text, String marker, XWikiContext context) throws XWikiException\n    {\n        setContent(StringUtils.replaceOnce(getContent(), marker, text + marker));\n        context.getWiki().saveDocument(this, context);\n    }\n\n    public Object getWikiNode()\n    {\n        return this.wikiNode;\n    }\n\n    public void setWikiNode(Object wikiNode)\n    {\n        this.wikiNode = wikiNode;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String getXClassXML()\n    {\n        return this.xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #getXClassXML()} instead as Hibernate uses this through reflection. It cannot be\n     *             removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getxWikiClassXML()\n    {\n        return getXClassXML();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClassXML(String xClassXML)\n    {\n        this.xClassXML = xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #setXClassXML(String)} ()} instead as Hibernate uses this through reflection. It\n     *             cannot be removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setxWikiClassXML(String xClassXML)\n    {\n        setXClassXML(xClassXML);\n    }\n\n    public int getElements()\n    {\n        return this.elements;\n    }\n\n    public void setElements(int elements)\n    {\n        this.elements = elements;\n    }\n\n    public void setElement(int element, boolean toggle)\n    {\n        if (toggle) {\n            this.elements = this.elements | element;\n        } else {\n            this.elements = this.elements & (~element);\n        }\n    }\n\n    public boolean hasElement(int element)\n    {\n        return ((this.elements & element) == element);\n    }\n\n    /**\n     * Gets the default edit mode for this document. An edit mode (other than the default \"edit\") can be enforced by\n     * creating an {@code XWiki.EditModeClass} object in the current document, with the appropriate value for the\n     * defaultEditMode property, or by adding this object in a sheet included by the document. This function also falls\n     * back on the old {@code SheetClass}, deprecated since 3.1M2, which can be attached to included documents to\n     * specify that the current document should be edited inline.\n     *\n     * @return the default edit mode for this document (\"edit\" or \"inline\" usually)\n     * @param context the context of the request for this document\n     * @throws XWikiException since XWiki 6.3M1 it's not used anymore and \"edit\" is returned in case of error, with an\n     *             error log\n     */\n    public String getDefaultEditMode(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getDefaultEditModeInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we default to the \"edit\" mode. We don't want to fail by throwing an exception\n            // since it'll lead to several errors in the UI (such as when evaluating contentview.vm for example).\n            LOGGER.error(\"Failed to get the default edit mode for [{}]\", getDocumentReference(), e);\n            return \"edit\";\n        }\n    }\n\n    private String getDefaultEditModeInternal(XWikiContext context) throws XWikiException\n    {\n        String editModeProperty = \"defaultEditMode\";\n        DocumentReference editModeClass =\n            getCurrentReferenceDocumentReferenceResolver().resolve(XWikiConstant.EDIT_MODE_CLASS);\n        // check if the current document has any edit mode class object attached to it, and read the edit mode from it\n        BaseObject editModeObject = this.getXObject(editModeClass);\n        if (editModeObject != null) {\n            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n            if (StringUtils.isEmpty(defaultEditMode)) {\n                return \"edit\";\n            } else {\n                return defaultEditMode;\n            }\n        }\n        // otherwise look for included documents\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        if (is10Syntax()) {\n            if (getContent().indexOf(\"includeForm(\") != -1) {\n                return \"inline\";\n            }\n        } else {\n            // Algorithm: look in all include macros and for all document included check if one of them\n            // has an EditModeClass object attached to it, or a SheetClass object (deprecated since 3.1M2) attached to\n            // it. If so then the edit mode is inline.\n\n            // Find all include macros and extract the document names\n            // TODO: Is there a good way not to hardcode the macro name? The macro itself shouldn't know\n            // its own name since it's a deployment time concern.\n            for (Block macroBlock : getXDOM().getBlocks(new MacroBlockMatcher(\"include\"), Axes.CHILD)) {\n                // Find the document reference to include by checking the macro's \"reference\" parameter.\n                // For backward-compatibility we also check for a \"document\" parameter since this is the parameter name\n                // that was used prior to XWiki 3.4M1 when the \"reference\" one was introduced and thus when the\n                // \"document\" one was deprecated.\n                String includedDocumentReference = macroBlock.getParameter(\"reference\");\n                if (includedDocumentReference == null) {\n                    includedDocumentReference = macroBlock.getParameter(\"document\");\n                }\n                if (includedDocumentReference != null) {\n                    // Resolve the document name into a valid Reference\n                    DocumentReference documentReference =\n                        getCurrentMixedDocumentReferenceResolver().resolve(includedDocumentReference);\n                    XWikiDocument includedDocument = xwiki.getDocument(documentReference, context);\n                    if (!includedDocument.isNew()) {\n                        // get the edit mode object, first the new class and then the deprecated class if new class\n                        // is not found\n                        editModeObject = includedDocument.getXObject(editModeClass);\n                        if (editModeObject == null) {\n                            editModeObject = includedDocument.getXObject(SHEETCLASS_REFERENCE);\n                        }\n                        if (editModeObject != null) {\n                            // Use the user-defined default edit mode if set.\n                            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n                            if (StringUtils.isBlank(defaultEditMode)) {\n                                // TODO: maybe here the real value should be returned if the object is edit mode class,\n                                // and inline only if the object is sheetclass\n                                return \"inline\";\n                            } else {\n                                return defaultEditMode;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return \"edit\";\n    }\n\n    public String getDefaultEditURL(XWikiContext context) throws XWikiException\n    {\n        String editMode = getDefaultEditMode(context);\n\n        if (\"inline\".equals(editMode)) {\n            return getEditURL(\"inline\", \"\", context);\n        } else {\n            com.xpn.xwiki.XWiki xwiki = context.getWiki();\n            String editor = xwiki.getEditorPreference(context);\n            return getEditURL(\"edit\", editor, context);\n        }\n    }\n\n    public String getEditURL(String action, String mode, XWikiContext context) throws XWikiException\n    {\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        String language = \"\";\n        XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n        String realLang = tdoc.getRealLanguage(context);\n        if ((xwiki.isMultiLingual(context) == true) && (!realLang.equals(\"\"))) {\n            language = realLang;\n        }\n\n        return getEditURL(action, mode, language, context);\n    }\n\n    public String getEditURL(String action, String mode, String language, XWikiContext context)\n    {\n        StringBuilder editparams = new StringBuilder();\n        if (!mode.equals(\"\")) {\n            editparams.append(\"xpage=\");\n            editparams.append(mode);\n        }\n\n        if (!language.equals(\"\")) {\n            if (!mode.equals(\"\")) {\n                editparams.append(\"&\");\n            }\n            editparams.append(\"language=\");\n            editparams.append(language);\n        }\n\n        return getURL(action, editparams.toString(), context);\n    }\n\n    public String getDefaultTemplate()\n    {\n        if (this.defaultTemplate == null) {\n            return \"\";\n        } else {\n            return this.defaultTemplate;\n        }\n    }\n\n    public void setDefaultTemplate(String defaultTemplate)\n    {\n        this.defaultTemplate = defaultTemplate;\n\n        setMetaDataDirty(true);\n    }\n\n    public Vector<BaseObject> getComments()\n    {\n        return getComments(true);\n    }\n\n    /**\n     * @return the syntax of the document\n     * @since 2.3M1\n     */\n    @Override\n    public Syntax getSyntax()\n    {\n        // Can't be initialized in the XWikiDocument constructor because #getDefaultDocumentSyntax() need to create a\n        // XWikiDocument object to get preferences from wiki preferences pages and would thus generate an infinite loop\n        if (isNew() && this.syntax == null) {\n            this.syntax = getDefaultDocumentSyntax();\n        }\n\n        return this.syntax;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     * </p>\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getSyntaxId()\n     * @deprecated use {link #getSyntax()} instead\n     */\n    @Override\n    @Deprecated(since = \"2.3M1\")\n    public String getSyntaxId()\n    {\n        return getSyntax().toIdString();\n    }\n\n    /**\n     * @param syntax the new syntax to set for this document\n     * @see #getSyntax()\n     * @since 2.3M1\n     */\n    public void setSyntax(Syntax syntax)\n    {\n        if (ObjectUtils.notEqual(this.syntax, syntax)) {\n            this.syntax = syntax;\n            // invalidate parsed xdom\n            this.xdomCache = null;\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @param syntaxId the new syntax id to set (e.g. {@code xwiki/2.0}, {@code xwiki/2.1}, etc)\n     * @see #getSyntaxId()\n     * @deprecated use {link #setSyntax(Syntax)} instead\n     */\n    @Deprecated(since = \"2.3M1\")\n    public void setSyntaxId(String syntaxId)\n    {\n        Syntax syntax;\n\n        // In order to preserve backward-compatibility with previous versions of XWiki in which the notion of Syntax Id\n        // did not exist, we check the passed syntaxId parameter. Since this parameter comes from the database (it's\n        // called automatically by Hibernate) it can be NULL or empty. In this case we consider the document is in\n        // syntax/1.0 syntax.\n        if (StringUtils.isBlank(syntaxId)) {\n            syntax = Syntax.XWIKI_1_0;\n        } else {\n            syntax = resolveSyntax(syntaxId);\n        }\n\n        setSyntax(syntax);\n    }\n\n    public Vector<BaseObject> getComments(boolean asc)\n    {\n        List<BaseObject> list = getXObjects(COMMENTSCLASS_REFERENCE);\n        if (list == null) {\n            return null;\n        } else if (asc) {\n            return new Vector<BaseObject>(list);\n        } else {\n            Vector<BaseObject> newlist = new Vector<BaseObject>();\n            for (int i = list.size() - 1; i >= 0; i--) {\n                newlist.add(list.get(i));\n            }\n            return newlist;\n        }\n    }\n\n    public boolean isCurrentUserCreator(XWikiContext context)\n    {\n        return isCreator(context.getUserReference());\n    }\n\n    /**\n     * @deprecated use {@link #isCreator(DocumentReference)} instead\n     */\n    @Deprecated\n    public boolean isCreator(String username)\n    {\n        if (username.equals(XWikiRightService.GUEST_USER_FULLNAME)) {\n            return false;\n        }\n\n        return username.equals(getCreator());\n    }\n\n    public boolean isCreator(DocumentReference username)\n    {\n        if (username == null) {\n            return false;\n        }\n\n        return username.equals(getCreatorReference());\n    }\n\n    public boolean isCurrentUserPage(XWikiContext context)\n    {\n        DocumentReference userReference = context.getUserReference();\n        if (userReference == null) {\n            return false;\n        }\n\n        return userReference.equals(getDocumentReference());\n    }\n\n    public boolean isCurrentLocalUserPage(XWikiContext context)\n    {\n        final DocumentReference userRef = context.getUserReference();\n        return userRef != null && userRef.equals(this.getDocumentReference());\n    }\n\n    public void resetArchive(XWikiContext context) throws XWikiException\n    {\n        boolean hasVersioning = context.getWiki().hasVersioning(context);\n        if (hasVersioning) {\n            WikiReference currentWiki = context.getWikiReference();\n            try {\n                context.setWikiReference(getDocumentReference().getWikiReference());\n\n                getVersioningStore(context).resetRCSArchive(this, true, context);\n            } finally {\n                context.setWikiReference(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(XWikiContext context) throws XWikiException\n    {\n        // Read info in object\n        ObjectAddForm form = new ObjectAddForm();\n        form.setRequest(context.getRequest());\n        form.readRequest();\n\n        EntityReference classReference = getXClassEntityReferenceResolver().resolve(form.getClassName(),\n            EntityType.DOCUMENT, getDocumentReference());\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        baseclass.fromMap(form.getObject(LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference))),\n            object);\n\n        return object;\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(classReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(addXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(resolveClassReference(className), pref, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", num, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, int num, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", num, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        String newPrefix =\n            prefix + LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference)) + \"_\" + num;\n        baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), object);\n\n        return object;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(resolveClassReference(className), prefix, num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        int nb;\n        BaseObject oldobject = getXObject(absoluteClassReference, num);\n        if (oldobject == null) {\n            nb = createXObject(classReference, context);\n            oldobject = getXObject(absoluteClassReference, nb);\n        } else {\n            nb = oldobject.getNumber();\n        }\n        BaseClass baseclass = oldobject.getXClass(context);\n        String newPrefix = prefix + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\" + nb;\n        BaseObject newobject =\n            (BaseObject) baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), oldobject);\n        newobject.setNumber(oldobject.getNumber());\n        newobject.setGuid(oldobject.getGuid());\n        setXObject(nb, newobject);\n\n        return newobject;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), prefix,\n            num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(updateXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), pref,\n            context);\n    }\n\n    public boolean isAdvancedContent()\n    {\n        String[] matches = { \"<%\", \"#set\", \"#include\", \"#if\", \"public class\", \"/* Advanced content */\",\n        \"## Advanced content\", \"/* Programmatic content */\", \"## Programmatic content\" };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        if (HTML_TAG_PATTERN.matcher(content2).find()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean isProgrammaticContent()\n    {\n        String[] matches = { \"<%\", \"\\\\$xwiki.xWiki\", \"$xcontext.context\", \"$doc.document\", \"$xwiki.getXWiki()\",\n        \"$xcontext.getContext()\", \"$doc.getDocument()\", \"WithProgrammingRights(\", \"/* Programmatic content */\",\n        \"## Programmatic content\", \"$xwiki.search(\", \"$xwiki.createUser\", \"$xwiki.createNewWiki\",\n        \"$xwiki.addToAllGroup\", \"$xwiki.sendMessage\", \"$xwiki.copyDocument\", \"$xwiki.copyWikiWeb\",\n        \"$xwiki.copySpaceBetweenWikis\", \"$xwiki.parseGroovyFromString\", \"$doc.toXML()\", \"$doc.toXMLDocument()\", };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObject(BaseObject object)\n    {\n        List<BaseObject> objects = this.xObjects.get(object.getXClassReference());\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Sometimes the object vector is wrongly indexed, meaning that objects are not at the right position\n        // Check if the right object is in place\n        int objectPosition = object.getNumber();\n        if (objectPosition < objects.size()) {\n            BaseObject storedObject = objects.get(objectPosition);\n            if (storedObject == null || !storedObject.equals(object)) {\n                // Try to find the correct position\n                objectPosition = objects.indexOf(object);\n            }\n        } else {\n            // The object position is greater than the array, that's invalid!\n            objectPosition = -1;\n        }\n        // If the object is not in the document, simply ignore this request\n        if (objectPosition < 0) {\n            return false;\n        }\n        // We don't remove objects, but set null in their place, so that the object number corresponds to its position\n        // in the vector\n        objects.set(objectPosition, null);\n        // Schedule the object for removal from the storage\n        addXObjectToRemove(object);\n\n        return true;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @deprecated use {@link #removeXObject(com.xpn.xwiki.objects.BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObject(BaseObject object)\n    {\n        return removeXObject(object);\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param classReference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Schedule the object for removal from the storage\n        for (BaseObject object : objects) {\n            if (object != null) {\n                addXObjectToRemove(object);\n            }\n        }\n        // Empty the vector, retaining its size\n        int currentSize = objects.size();\n        objects.clear();\n        for (int i = 0; i < currentSize; i++) {\n            objects.add(null);\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param reference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 5.0M1\n     */\n    public boolean removeXObjects(EntityReference reference)\n    {\n        return removeXObjects(\n            getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param className The class name of the objects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @deprecated use {@link #removeXObjects(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObjects(String className)\n    {\n        return removeXObjects(resolveClassReference(className));\n    }\n\n    /**\n     * Get the top sections contained in the document.\n     * <p>\n     * The section are filtered by xwiki.section.depth property on the maximum depth of the sections to return. This\n     * method is usually used to get \"editable\" sections.\n     *\n     * @return the sections in the current document\n     */\n    public List<DocumentSection> getSections() throws XWikiException\n    {\n        if (is10Syntax()) {\n            return getSections10();\n        } else {\n            List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            int sectionNumber = 1;\n            for (HeaderBlock header : headers) {\n                // put -1 as index since there is no way to get the position of the header in the source\n                int documentSectionIndex = -1;\n\n                // Need to do the same thing than 1.0 content here\n                String documentSectionLevel = StringUtils.repeat(\"1.\", header.getLevel().getAsInt() - 1) + \"1\";\n\n                DocumentSection docSection = new DocumentSection(sectionNumber++, documentSectionIndex,\n                    documentSectionLevel, renderXDOM(new XDOM(header.getChildren()), getSyntax()));\n                splitSections.add(docSection);\n            }\n\n            return splitSections;\n        }\n    }\n\n    /**\n     * Get XWiki context from execution context.\n     *\n     * @return the XWiki context for the current thread\n     */\n    private XWikiContext getXWikiContext()\n    {\n        Provider<XWikiContext> xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n\n        if (xcontextProvider != null) {\n            return xcontextProvider.get();\n        }\n\n        return null;\n    }\n\n    /**\n     * Filter the headers from a document XDOM based on xwiki.section.depth property from xwiki.cfg file.\n     *\n     * @return the filtered headers\n     */\n    private List<HeaderBlock> getFilteredHeaders()\n    {\n        List<HeaderBlock> filteredHeaders = new ArrayList<HeaderBlock>();\n\n        // Get the maximum header level\n        int sectionDepth = 2;\n        XWikiContext context = getXWikiContext();\n        if (context != null) {\n            sectionDepth = (int) context.getWiki().getSectionEditingDepth();\n        }\n\n        // Get the headers.\n        //\n        // Note that we need to only take into account SectionBlock that are children of other SectionBlocks so that\n        // we are in sync with the section editing buttons added in xwiki.js. Being able to section edit any heading is\n        // too complex. For example if you have (in XWiki Syntax 2.0):\n        // = Heading1 =\n        // para1\n        // == Heading2 ==\n        // para2\n        // (((\n        // == Heading3 ==\n        // para3\n        // (((\n        // == Heading4 ==\n        // para4\n        // )))\n        // )))\n        // == Heading5 ==\n        // para5\n        //\n        // Then if we were to support editing \"Heading4\", its content would be:\n        // para4\n        // )))\n        // )))\n        //\n        // Which obviously is not correct...\n\n        final XDOM xdom = getXDOM();\n        if (!xdom.getChildren().isEmpty()) {\n            Block currentBlock = xdom.getChildren().get(0);\n            while (currentBlock != null) {\n                if (currentBlock instanceof SectionBlock) {\n                    // The next children block is a HeaderBlock but we check to be on the safe side...\n                    Block nextChildrenBlock = currentBlock.getChildren().get(0);\n                    if (nextChildrenBlock instanceof HeaderBlock) {\n                        HeaderBlock headerBlock = (HeaderBlock) nextChildrenBlock;\n                        if (headerBlock.getLevel().getAsInt() <= sectionDepth) {\n                            filteredHeaders.add(headerBlock);\n                        }\n                    }\n                    currentBlock = nextChildrenBlock;\n                } else {\n                    Block nextSibling = currentBlock.getNextSibling();\n                    if (nextSibling == null) {\n                        currentBlock = currentBlock.getParent();\n                        while (currentBlock != null) {\n                            if (currentBlock.getNextSibling() != null) {\n                                currentBlock = currentBlock.getNextSibling();\n                                break;\n                            }\n                            currentBlock = currentBlock.getParent();\n                        }\n                    } else {\n                        currentBlock = nextSibling;\n                    }\n                }\n            }\n        }\n\n        return filteredHeaders;\n    }\n\n    /**\n     * @return the sections in the current document\n     */\n    private List<DocumentSection> getSections10()\n    {\n        // Pattern to match the title. Matches only level 1 and level 2 headings.\n        Pattern headingPattern = Pattern.compile(\"^[ \\\\t]*+(1(\\\\.1){0,1}+)[ \\\\t]++(.++)$\", Pattern.MULTILINE);\n        Matcher matcher = headingPattern.matcher(getContent());\n        List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n        int sectionNumber = 0;\n        // find title to split\n        while (matcher.find()) {\n            ++sectionNumber;\n            String sectionLevel = matcher.group(1);\n            String sectionTitle = matcher.group(3);\n            int sectionIndex = matcher.start();\n            // Initialize a documentSection object.\n            DocumentSection docSection = new DocumentSection(sectionNumber, sectionIndex, sectionLevel, sectionTitle);\n            // Add the document section to list.\n            splitSections.add(docSection);\n        }\n\n        return splitSections;\n    }\n\n    /**\n     * Return a Document section with parameter is sectionNumber.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return\n     * @throws XWikiException error when extracting sections from document\n     */\n    public DocumentSection getDocumentSection(int sectionNumber) throws XWikiException\n    {\n        // return a document section according to section number\n        return getSections().get(sectionNumber - 1);\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section or null if the section can't be found.\n     * @throws XWikiException error when trying to extract section content\n     */\n    public String getContentOfSection(int sectionNumber) throws XWikiException\n    {\n        String content = null;\n\n        if (is10Syntax()) {\n            content = getContentOfSection10(sectionNumber);\n        } else {\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            if (headers.size() >= sectionNumber) {\n                SectionBlock section = headers.get(sectionNumber - 1).getSection();\n                content = renderXDOM(new XDOM(Collections.<Block>singletonList(section)), getSyntax());\n            }\n        }\n\n        return content;\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section\n     * @throws XWikiException error when trying to extract section content\n     */\n    private String getContentOfSection10(int sectionNumber) throws XWikiException\n    {\n        List<DocumentSection> splitSections = getSections();\n        int indexEnd = 0;\n        // get current section\n        DocumentSection section = splitSections.get(sectionNumber - 1);\n        int indexStart = section.getSectionIndex();\n        String sectionLevel = section.getSectionLevel();\n        // Determine where this section ends, which is at the start of the next section of the\n        // same or a higher level.\n        for (int i = sectionNumber; i < splitSections.size(); i++) {\n            DocumentSection nextSection = splitSections.get(i);\n            String nextLevel = nextSection.getSectionLevel();\n            if (sectionLevel.equals(nextLevel) || sectionLevel.length() > nextLevel.length()) {\n                indexEnd = nextSection.getSectionIndex();\n                break;\n            }\n        }\n        String sectionContent = null;\n        if (indexStart < 0) {\n            indexStart = 0;\n        }\n\n        if (indexEnd == 0) {\n            sectionContent = getContent().substring(indexStart);\n        } else {\n            sectionContent = getContent().substring(indexStart, indexEnd);\n        }\n\n        return sectionContent;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (starting at 1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating content\n     */\n    public String updateDocumentSection(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        String content;\n        if (is10Syntax()) {\n            content = updateDocumentSection10(sectionNumber, newSectionContent);\n        } else {\n            // Get the current section block\n            HeaderBlock header = getFilteredHeaders().get(sectionNumber - 1);\n\n            XDOM xdom = (XDOM) header.getRoot();\n\n            // newSectionContent -> Blocks\n            List<Block> blocks = parseContent(newSectionContent).getChildren();\n            int sectionLevel = header.getLevel().getAsInt();\n            for (int level = 1; level < sectionLevel && blocks.size() == 1\n                && blocks.get(0) instanceof SectionBlock; ++level) {\n                blocks = blocks.get(0).getChildren();\n            }\n\n            // replace old current SectionBlock with new Blocks\n            Block section = header.getSection();\n            section.getParent().replaceChild(blocks, section);\n\n            // render back XDOM to document's content syntax\n            content = renderXDOM(xdom, getSyntax());\n        }\n\n        return content;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating document content with section content\n     */\n    private String updateDocumentSection10(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        StringBuilder newContent = new StringBuilder();\n        // get document section that will be edited\n        DocumentSection docSection = getDocumentSection(sectionNumber);\n        int numberOfSections = getSections().size();\n        int indexSection = docSection.getSectionIndex();\n        if (numberOfSections == 1) {\n            // there is only a sections in document\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else if (sectionNumber == numberOfSections) {\n            // edit lastest section that doesn't contain subtitle\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else {\n            String sectionLevel = docSection.getSectionLevel();\n            int nextSectionIndex = 0;\n            // get index of next section\n            for (int i = sectionNumber; i < numberOfSections; i++) {\n                DocumentSection nextSection = getDocumentSection(i + 1); // get next section\n                String nextSectionLevel = nextSection.getSectionLevel();\n                if (sectionLevel.equals(nextSectionLevel)) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                } else if (sectionLevel.length() > nextSectionLevel.length()) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                }\n            }\n\n            if (nextSectionIndex == 0) {// edit the last section\n                newContent = newContent.append(getContent().substring(0, indexSection)).append(newSectionContent);\n                return newContent.toString();\n            } else {\n                String contentAfter = getContent().substring(nextSectionIndex);\n                String contentBegin = getContent().substring(0, indexSection);\n                newContent = newContent.append(contentBegin).append(newSectionContent).append(contentAfter);\n            }\n\n            return newContent.toString();\n        }\n    }\n\n    /**\n     * Computes a document hash, taking into account all document data: content, objects, attachments, metadata... TODO:\n     * cache the hash value, update only on modification.\n     */\n    public String getVersionHashCode(XWikiContext context)\n    {\n        MessageDigest md5 = null;\n\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException ex) {\n            LOGGER.error(\"Cannot create MD5 object\", ex);\n            return hashCode() + \"\";\n        }\n\n        try {\n            String valueBeforeMD5 = toXML(true, false, true, false, context);\n            md5.update(valueBeforeMD5.getBytes());\n\n            byte[] array = md5.digest();\n            StringBuilder sb = new StringBuilder();\n            for (byte element : array) {\n                int b = element & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n\n            return sb.toString();\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while computing document hash\", ex);\n        }\n\n        return hashCode() + \"\";\n    }\n\n    public static String getInternalPropertyName(String propname, XWikiContext context)\n    {\n        ContextualLocalizationManager localizationManager = Utils.getComponent(ContextualLocalizationManager.class);\n        String cpropname = StringUtils.capitalize(propname);\n\n        return localizationManager == null ? cpropname : localizationManager.getTranslationPlain(cpropname);\n    }\n\n    public String getInternalProperty(String propname)\n    {\n        String methodName = \"get\" + StringUtils.capitalize(propname);\n        try {\n            Method method = getClass().getDeclaredMethod(methodName, (Class[]) null);\n            return (String) method.invoke(this, (Object[]) null);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getCustomClass()\n    {\n        if (this.customClass == null) {\n            return \"\";\n        }\n\n        return this.customClass;\n    }\n\n    public void setCustomClass(String customClass)\n    {\n        this.customClass = customClass;\n        setMetaDataDirty(true);\n    }\n\n    public void setValidationScript(String validationScript)\n    {\n        this.validationScript = validationScript;\n\n        setMetaDataDirty(true);\n    }\n\n    public String getValidationScript()\n    {\n        if (this.validationScript == null) {\n            return \"\";\n        } else {\n            return this.validationScript;\n        }\n    }\n\n    public String getComment()\n    {\n        if (this.comment == null) {\n            return \"\";\n        }\n\n        return this.comment;\n    }\n\n    public void setComment(String comment)\n    {\n        this.comment = comment;\n    }\n\n    public boolean isMinorEdit()\n    {\n        return this.isMinorEdit;\n    }\n\n    public void setMinorEdit(boolean isMinor)\n    {\n        this.isMinorEdit = isMinor;\n    }\n\n    // methods for easy table update. It is need only for hibernate.\n    // when hibernate update old database without minorEdit field, hibernate will create field with\n    // null in despite of notnull in hbm.\n    // (http://opensource.atlassian.com/projects/hibernate/browse/HB-1151)\n    // so minorEdit will be null for old documents. But hibernate can't convert null to boolean.\n    // so we need convert Boolean to boolean\n    protected Boolean getMinorEdit1()\n    {\n        return Boolean.valueOf(isMinorEdit());\n    }\n\n    protected void setMinorEdit1(Boolean isMinor)\n    {\n        this.isMinorEdit = (isMinor != null && isMinor.booleanValue());\n    }\n\n    /**\n     * Create, add and return a new object with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public BaseObject newXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        int nb = createXObject(classReference, context);\n        return getXObject(resolveClassReference(classReference), nb);\n    }\n\n    /**\n     * @deprecated use {@link #newXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject newObject(String className, XWikiContext context) throws XWikiException\n    {\n        return newXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseObject getXObject(DocumentReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.4M1\n     */\n    public BaseObject getXObject(EntityReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject getObject(String className, boolean create, XWikiContext context)\n    {\n        return getXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), create,\n            context);\n    }\n\n    public boolean validate(XWikiContext context) throws XWikiException\n    {\n        return validate(null, context);\n    }\n\n    public boolean validate(String[] classNames, XWikiContext context) throws XWikiException\n    {\n        boolean isValid = true;\n        if ((classNames == null) || (classNames.length == 0)) {\n            for (DocumentReference classReference : getXObjects().keySet()) {\n                BaseClass bclass = context.getWiki().getXClass(classReference, context);\n                List<BaseObject> objects = getXObjects(classReference);\n                for (BaseObject obj : objects) {\n                    if (obj != null) {\n                        isValid &= bclass.validateObject(obj, context);\n                    }\n                }\n            }\n        } else {\n            for (String className : classNames) {\n                List<BaseObject> objects = getXObjects(getCurrentMixedDocumentReferenceResolver().resolve(className));\n                if (objects != null) {\n                    for (BaseObject obj : objects) {\n                        if (obj != null) {\n                            BaseClass bclass = obj.getXClass(context);\n                            isValid &= bclass.validateObject(obj, context);\n                        }\n                    }\n                }\n            }\n        }\n\n        String validationScript = \"\";\n        XWikiRequest req = context.getRequest();\n        if (req != null) {\n            validationScript = req.get(\"xvalidation\");\n        }\n\n        if ((validationScript == null) || (validationScript.trim().equals(\"\"))) {\n            validationScript = getValidationScript();\n        }\n\n        if ((validationScript != null) && (!validationScript.trim().equals(\"\"))) {\n            isValid &= executeValidationScript(context, validationScript);\n        }\n\n        return isValid;\n    }\n\n    public static void backupContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // The XWiki Context isn't recreated when the Execution Context is cloned so we have to backup some of its data.\n        // Backup the current document on the XWiki Context.\n        backup.put(\"doc\", context.getDoc());\n\n        backup.put(\"cdoc\", context.get(\"cdoc\"));\n        backup.put(\"tdoc\", context.get(\"tdoc\"));\n\n        // Backup the secure document\n        backup.put(CKEY_SDOC, context.get(CKEY_SDOC));\n\n        // Clone the Execution Context to provide isolation. The clone will have a new Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        try {\n            execution.pushContext(Utils.getComponent(ExecutionContextManager.class).clone(execution.getContext()));\n        } catch (ExecutionContextException e) {\n            throw new RuntimeException(\"Failed to clone the Execution Context\", e);\n        }\n\n        // Bridge with old XWiki Context, required for legacy code.\n        execution.getContext().setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, context);\n    }\n\n    public static void restoreContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // Restore the Execution Context. This will also restore the previous Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        execution.popContext();\n\n        // Restore the current document on the XWiki Context.\n        context.setDoc((XWikiDocument) backup.get(\"doc\"));\n\n        context.put(\"cdoc\", backup.get(\"cdoc\"));\n        context.put(\"tdoc\", backup.get(\"tdoc\"));\n\n        // Restore the secure document\n        context.put(CKEY_SDOC, backup.get(CKEY_SDOC));\n    }\n\n    public void setAsContextDoc(XWikiContext context)\n    {\n        context.setDoc(this);\n        context.remove(\"cdoc\");\n        context.remove(\"tdoc\");\n\n        // Get rid of secure document (so that it fallback on context document)\n        context.remove(CKEY_SDOC);\n    }\n\n    /**\n     * @return the String representation of the previous version of this document or null if this is the first version.\n     */\n    public String getPreviousVersion()\n    {\n        XWikiDocumentArchive archive = loadDocumentArchive();\n        if (archive != null) {\n            Version prevVersion = archive.getPrevVersion(getRCSVersion());\n            if (prevVersion != null) {\n                return prevVersion.toString();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString()\n    {\n        return getFullName();\n    }\n\n    /**\n     * Indicates whether the document should be 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @param hidden The new value of the {@link #hidden} property.\n     */\n    public void setHidden(Boolean hidden)\n    {\n        if (hidden == null) {\n            this.hidden = false;\n        } else {\n            this.hidden = hidden;\n        }\n    }\n\n    /**\n     * Indicates whether the document is 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @return <code>true</code> if the document is hidden and does not appear among the results of\n     *         {@link com.xpn.xwiki.api.XWiki#searchDocuments(String)}, <code>false</code> otherwise.\n     */\n    public Boolean isHidden()\n    {\n        return this.hidden;\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntaxId the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(String targetSyntaxId, XWikiContext context) throws XWikiException\n    {\n        try {\n            convertSyntax(Syntax.valueOf(targetSyntaxId), context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntaxId + \"]\", e);\n        }\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntax the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        // convert content\n        setContent(performSyntaxConversion(getContent(), getDocumentReference(), getSyntax(), targetSyntax));\n\n        // convert objects\n        Map<DocumentReference, List<BaseObject>> objectsByClass = getXObjects();\n\n        for (List<BaseObject> objects : objectsByClass.values()) {\n            for (BaseObject bobject : objects) {\n                if (bobject != null) {\n                    BaseClass bclass = bobject.getXClass(context);\n                    for (Object fieldClass : bclass.getProperties()) {\n                        if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                            TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                            PropertyInterface field = bobject.getField(textAreaClass.getName());\n\n                            // Make sure the field is the right type (might happen while a document is being migrated)\n                            if (field instanceof LargeStringProperty) {\n                                LargeStringProperty largeField = (LargeStringProperty) field;\n\n                                largeField.setValue(performSyntaxConversion(largeField.getValue(),\n                                    getDocumentReference(), getSyntax(), targetSyntax));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // change syntax\n        setSyntax(targetSyntax);\n    }\n\n    /**\n     * NOTE: This method caches the XDOM and returns a clone that can be safely modified.\n     *\n     * @return the XDOM corresponding to the document's string content\n     */\n    @Override\n    public XDOM getXDOM()\n    {\n        if (this.xdomCache == null) {\n            try {\n                this.xdomCache = parseContent(getContent());\n            } catch (XWikiException e) {\n                ErrorBlockGenerator errorBlockGenerator = Utils.getComponent(ErrorBlockGenerator.class);\n                return new XDOM(errorBlockGenerator.generateErrorBlocks(false, TM_FAILEDDOCUMENTPARSE,\n                    \"Failed to parse document content\", null, e));\n            }\n        }\n\n        return this.xdomCache.clone();\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax()\n    {\n        return is10Syntax(getSyntaxId());\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax(String syntaxId)\n    {\n        return Syntax.XWIKI_1_0.toIdString().equalsIgnoreCase(syntaxId);\n    }\n\n    private void init(DocumentReference reference)\n    {\n        // if the passed reference is null consider it points to the default reference\n        if (reference == null) {\n            setDocumentReference(\n                Utils.<Provider<DocumentReference>>getComponent(DocumentReference.TYPE_PROVIDER).get());\n        } else {\n            setDocumentReference(reference);\n        }\n\n        this.updateDate = new Date();\n        this.updateDate.setTime((this.updateDate.getTime() / 1000) * 1000);\n        this.contentUpdateDate = new Date();\n        this.contentUpdateDate.setTime((this.contentUpdateDate.getTime() / 1000) * 1000);\n        this.creationDate = new Date();\n        this.creationDate.setTime((this.creationDate.getTime() / 1000) * 1000);\n        this.content = \"\";\n        this.format = \"\";\n        this.locale = Locale.ROOT;\n        this.defaultLocale = Locale.ROOT;\n        this.customClass = \"\";\n        this.comment = \"\";\n\n        // Note: As there's no notion of an Empty document we don't set the original document\n        // field. Thus getOriginalDocument() may return null.\n    }\n\n    private boolean executeValidationScript(XWikiContext context, String validationScript)\n    {\n        try {\n            ContextualAuthorizationManager authorization = Utils.getComponent(ContextualAuthorizationManager.class);\n            DocumentReference validationScriptReference =\n                getCurrentDocumentReferenceResolver().resolve(validationScript, getDocumentReference());\n\n            // Make sure target document is allowed to execute Groovy\n            // TODO: this check should probably be right in XWiki#parseGroovyFromPage\n            authorization.checkAccess(Right.PROGRAM, validationScriptReference);\n\n            XWikiValidationInterface validObject =\n                (XWikiValidationInterface) context.getWiki().parseGroovyFromPage(validationScript, context);\n\n            return validObject.validateDocument(this, context);\n        } catch (Throwable e) {\n            XWikiValidationStatus.addExceptionToContext(getFullName(), \"\", e, context);\n            return false;\n        }\n    }\n\n    /**\n     * Convert the passed content from the passed syntax to the passed new syntax.\n     *\n     * @param content the content to convert\n     * @param source the reference to where the content comes from (eg document reference)\n     * @param currentSyntaxId the syntax of the current content to convert\n     * @param targetSyntax the new syntax after the conversion\n     * @return the converted content in the new syntax\n     * @throws XWikiException if an exception occurred during the conversion process\n     * @since 2.4M2\n     */\n    private static String performSyntaxConversion(String content, DocumentReference source, Syntax currentSyntaxId,\n        Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            XDOM dom = parseContent(currentSyntaxId, content, source);\n            return performSyntaxConversion(dom, targetSyntax, null);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    /**\n     * Convert the passed content from the passed syntax to the passed new syntax.\n     *\n     * @param content the XDOM content to convert, the XDOM can be modified during the transformation\n     * @param targetSyntax the new syntax after the conversion\n     * @param txContext the context when Transformation are executed or null if transformation shouldn't be executed\n     * @return the converted content in the new syntax\n     * @throws XWikiException if an exception occurred during the conversion process\n     * @since 2.4M2\n     */\n    private static String performSyntaxConversion(XDOM content, Syntax targetSyntax, TransformationContext txContext)\n        throws XWikiException\n    {\n        try {\n            if (txContext != null) {\n                // Transform XDOM\n                TransformationManager transformations = Utils.getComponent(TransformationManager.class);\n                if (txContext.getXDOM() == null) {\n                    txContext.setXDOM(content);\n                }\n                try {\n                    transformations.performTransformations(content, txContext);\n                } catch (TransformationException te) {\n                    // An error happened during one of the transformations. Since the error has been logged\n                    // continue\n                    // TODO: We should have a visual clue for the user in the future to let him know something\n                    // didn't work as expected.\n                }\n            }\n\n            // Render XDOM\n            return renderXDOM(content, targetSyntax);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    /**\n     * Render provided XDOM into content of the provided syntax identifier.\n     *\n     * @param content the XDOM content to render\n     * @param targetSyntax the syntax identifier of the rendered content\n     * @return the rendered content\n     * @throws XWikiException if an exception occurred during the rendering process\n     */\n    protected static String renderXDOM(XDOM content, Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            BlockRenderer renderer = Utils.getComponent(BlockRenderer.class, targetSyntax.toIdString());\n            WikiPrinter printer = new DefaultWikiPrinter();\n            renderer.render(content, printer);\n            return printer.toString();\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to render document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    private XDOM parseContent(String content) throws XWikiException\n    {\n        return parseContent(getSyntax(), content, getDocumentReference());\n    }\n\n    /**\n     * @param source the reference to where the content comes from (eg document reference)\n     */\n    private static XDOM parseContent(Syntax syntax, String content, DocumentReference source) throws XWikiException\n    {\n        ContentParser parser = Utils.getComponent(ContentParser.class);\n\n        try {\n            return parser.parse(content, syntax, source);\n        } catch (MissingParserException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to find a parser for syntax [\" + syntax.toIdString() + \"]\", e);\n        } catch (ParseException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to parse content of syntax [\" + syntax.toIdString() + \"]\", e);\n        }\n    }\n\n    /**\n     * If there's no parser available for the specified syntax default to the XWiki 2.1 syntax.\n     */\n    private Syntax getDefaultDocumentSyntax()\n    {\n        Syntax syntax = Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n\n        if (syntax == null || (!Utils.getComponentManager().hasComponent(Parser.class, syntax.toIdString())\n            && !Syntax.XWIKI_2_1.equals(syntax))) {\n            LOGGER.warn(\"Failed to find parser for the default syntax [{}]. Defaulting to xwiki/2.1 syntax.\", syntax);\n            syntax = Syntax.XWIKI_2_1;\n        }\n\n        return syntax;\n    }\n\n    /**\n     * Backward-compatibility method to use in order to resolve a class reference passed as a String into a\n     * DocumentReference proper.\n     *\n     * @return the resolved class reference but using this document's wiki if the passed String doesn't specify a wiki,\n     *         the \"XWiki\" space if the passed String doesn't specify a space and this document's page if the passed\n     *         String doesn't specify a page.\n     */\n    public DocumentReference resolveClassReference(String documentName)\n    {\n        DocumentReference defaultReference = new DocumentReference(getDocumentReference().getWikiReference().getName(),\n            XWiki.SYSTEM_SPACE, getDocumentReference().getName());\n        return getExplicitDocumentReferenceResolver().resolve(documentName, defaultReference);\n    }\n\n    /**\n     * Transforms a XClass reference relative to this document into an absolute reference.\n     */\n    private DocumentReference resolveClassReference(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return (DocumentReference) reference;\n        } else if (reference instanceof LocalDocumentReference) {\n            return new DocumentReference((LocalDocumentReference) reference, getDocumentReference().getWikiReference());\n        } else {\n            DocumentReference defaultReference =\n                new DocumentReference(getDocumentReference().getWikiReference().getName(), XWiki.SYSTEM_SPACE,\n                    getDocumentReference().getName());\n            return getExplicitReferenceDocumentReferenceResolver().resolve(reference, defaultReference);\n        }\n    }\n\n    /**\n     * Return the reference of the parent document as it stored and passed to\n     * {@link #setParentReference(EntityReference)}.\n     * <p>\n     * You should use {@link #getParentReference()} reference if you want the complete parent reference.\n     *\n     * @return the relative parent reference\n     * @since 2.2.3\n     */\n    public EntityReference getRelativeParentReference()\n    {\n        return this.parentReference;\n    }\n\n    private BaseObject prepareXObject(EntityReference classReference)\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject bobject = getXObject(absoluteClassReference);\n        if (bobject == null) {\n            bobject = new BaseObject();\n            bobject.setXClassReference(classReference);\n\n            addXObject(bobject);\n        }\n        bobject.setDocumentReference(getDocumentReference());\n        setMetaDataDirty(true);\n        return bobject;\n    }\n\n    /**\n     * Apply a 3 ways merge on the current document based on provided previous and new version of the document.\n     * <p>\n     * All 3 documents are supposed to have the same document reference and language already since that's what makes\n     * them uniques.\n     *\n     * @param previousDocument the previous version of the document\n     * @param newDocument the next version of the document\n     * @param configuration the configuration of the merge indicates how to deal with some conflicts use cases, etc.\n     * @param context the XWiki context\n     * @return a repport of what happen during the merge (errors, etc.)\n     * @since 3.2M1\n     * @deprecated use {@link MergeManager#mergeDocument(DocumentModelBridge, DocumentModelBridge, DocumentModelBridge,\n     *  MergeConfiguration)} instead\n     */\n    @Deprecated(since = \"11.8RC1\")\n    public MergeResult merge(XWikiDocument previousDocument, XWikiDocument newDocument,\n        MergeConfiguration configuration, XWikiContext context)\n    {\n        MergeManager mergeManager = Utils.getComponent(MergeManager.class);\n        MergeDocumentResult mergeDocumentResult =\n            mergeManager.mergeDocument(previousDocument, newDocument, this, configuration);\n\n        MergeResult mergeResult = new MergeResult();\n        mergeResult.getLog().addAll(mergeDocumentResult.getLog());\n        mergeResult.setModified(mergeResult.isModified() || mergeDocumentResult.isModified());\n\n        if (!configuration.isProvidedVersionsModifiables())\n        {\n            this.apply((XWikiDocument) mergeDocumentResult.getMergeResult());\n        }\n\n        return mergeResult;\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change anything related to version management and document\n     * identifier.\n     * <p>\n     * Important note: this method does not take care of attachments contents related operations and only remove\n     * attachments which need to be removed from the list. For memory handling reasons all attachments contents related\n     * operations should be done elsewhere.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document)\n    {\n        return apply(document, true);\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change everything related to version management and\n     * document identifier.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document, boolean clean)\n    {\n        boolean modified = false;\n\n        // /////////////////////////////////\n        // Document\n\n        if (!StringUtils.equals(getContent(), document.getContent())) {\n            setContent(document.getContent());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getSyntax(), document.getSyntax())) {\n            setSyntax(document.getSyntax());\n            modified = true;\n        }\n\n        if (ObjectUtils.notEqual(getDefaultLocale(), document.getDefaultLocale())) {\n            setDefaultLocale(document.getDefaultLocale());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getTitle(), document.getTitle())) {\n            setTitle(document.getTitle());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getDefaultTemplate(), document.getDefaultTemplate())) {\n            setDefaultTemplate(document.getDefaultTemplate());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getRelativeParentReference(), document.getRelativeParentReference())) {\n            setParentReference(document.getRelativeParentReference());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getCustomClass(), document.getCustomClass())) {\n            setCustomClass(document.getCustomClass());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getValidationScript(), document.getValidationScript())) {\n            setValidationScript(document.getValidationScript());\n            modified = true;\n        }\n\n        if (isHidden() != document.isHidden()) {\n            setHidden(document.isHidden());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // XObjects\n\n        if (clean) {\n            // Delete objects that don't exist anymore\n            for (List<BaseObject> objects : getXObjects().values()) {\n                // Duplicate the list since we are potentially going to modify it\n                for (BaseObject originalObj : new ArrayList<BaseObject>(objects)) {\n                    if (originalObj != null) {\n                        BaseObject newObj =\n                            document.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                        if (newObj == null) {\n                            // The object was deleted\n                            removeXObject(originalObj);\n                            modified = true;\n                        }\n                    }\n                }\n            }\n        }\n        // Add new objects or update existing objects\n        for (List<BaseObject> objects : document.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                if (newObj != null) {\n                    BaseObject originalObj = getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // The object added or modified\n                        setXObject(newObj.getNumber(), newObj);\n                        modified = true;\n                    } else {\n                        // The object added or modified\n                        modified |= originalObj.apply(newObj, clean);\n                    }\n                }\n            }\n        }\n\n        // /////////////////////////////////\n        // XClass\n\n        modified |= getXClass().apply(document.getXClass(), clean);\n        if (ObjectUtils.notEqual(getXClassXML(), document.getXClassXML())) {\n            setXClassXML(document.getXClassXML());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // Attachments\n\n        if (clean) {\n            // Delete attachments that don't exist anymore\n            for (XWikiAttachment attachment : new ArrayList<XWikiAttachment>(getAttachmentList())) {\n                if (document.getAttachment(attachment.getFilename()) == null) {\n                    removeAttachment(attachment);\n                }\n            }\n        }\n        // Add new attachments or update existing attachments\n        for (XWikiAttachment attachment : document.getAttachmentList()) {\n            XWikiAttachment originalAttachment = getAttachment(attachment.getFilename());\n            if (originalAttachment == null) {\n                addAttachment(attachment);\n            } else {\n                originalAttachment.apply(attachment);\n            }\n        }\n\n        return modified;\n    }\n\n    private XWikiAttachmentStoreInterface resolveXWikiAttachmentStoreInterface(String storeType, XWikiContext xcontext)\n    {\n        XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(storeType);\n\n        if (store != null) {\n            return store;\n        }\n\n        return xcontext.getWiki().getDefaultAttachmentContentStore();\n    }\n\n    private XWikiAttachmentStoreInterface getXWikiAttachmentStoreInterface(String storeType)\n    {\n        if (storeType != null && !storeType.equals(XWikiHibernateAttachmentStore.HINT)) {\n            try {\n                return Utils.getContextComponentManager().getInstance(XWikiAttachmentStoreInterface.class, storeType);\n            } catch (ComponentLookupException e) {\n                LOGGER.warn(\"Can't find attachment content store for type [{}]\", storeType, e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Compute and return the maximum authorized length for the full name (i.e. the serialized reference of the\n     * document) based on the current store limitation.\n     *\n     * @return the maximum authorized length for a document full name.\n     * @since 11.4RC1\n     */\n    public int getLocalReferenceMaxLength()\n    {\n        return getStore().getLimitSize(this.getXWikiContext(), this.getClass(), \"fullName\");\n    }\n\n    @Override\n    public DocumentAuthors getAuthors()\n    {\n        return this.authors;\n    }\n\n    /**\n     * This getter has been created for hibernate in order to properly fill the DB field, it's not meant to be used\n     * for other purpose. For getting the displayed author, rely on {@link #getAuthors()}.\n     *\n     * @return the serialization of the displayed author reference.\n     */\n    private String getOriginalMetadataAuthorReference()\n    {\n        if (this.getAuthors().getOriginalMetadataAuthor() == null\n            || this.getAuthors().getOriginalMetadataAuthor() == GuestUserReference.INSTANCE) {\n            return \"\";\n        } else {\n            return userReferenceToString(this.getAuthors().getOriginalMetadataAuthor());\n        }\n    }\n\n    /**\n     * This setter has been created for hibernate in order to properly create the XWikiDocument instance with the\n     * displayed author set, it's not meant to be used for other purpose.\n     *\n     * @param serializedUserReference the serialization of the displayed author reference.\n     */\n    private void setOriginalMetadataAuthorReference(String serializedUserReference)\n    {\n        if (!StringUtils.isEmpty(serializedUserReference)) {\n            UserReference userReference = userStringToUserReference(serializedUserReference);\n            this.authors.setOriginalMetadataAuthor(userReference);\n        }\n    }\n\n    /**\n     * Make sure any document metadata which may depend on configuration is initialized to its default value.\n     * \n     * @since 14.8RC1\n     * @since 14.4.4\n     * @since 13.10.10\n     */\n    @Unstable\n    public void initialize()\n    {\n        // There is no syntax by default in a new document and the default one is retrieved from the configuration\n        setSyntax(getSyntax());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.mockito.Mock;\nimport org.mockito.stubbing.Answer;\nimport org.xwiki.context.Execution;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.rendering.configuration.ExtendedRenderingConfiguration;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.test.LogLevel;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.junit5.LogCaptureExtension;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.velocity.VelocityEngine;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link XWikiDocument}.\n *\n * @version $Id$\n */\n@OldcoreTest\n@AllComponents\npublic class XWikiDocumentTest\n{\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    private static final String DOCWIKI = \"Wiki\";\n\n    private static final String DOCSPACE = \"Space\";\n\n    private static final String DOCNAME = \"Page\";\n\n    private static final String CLASSNAME = DOCSPACE + \".\" + DOCNAME;\n\n    private static final DocumentReference CLASS_REFERENCE = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n\n    private XWikiDocument document;\n\n    private XWikiDocument translatedDocument;\n\n    @Mock\n    private XWikiMessageTool xWikiMessageTool;\n\n    @Mock\n    private XWikiRightService xWikiRightService;\n\n    @Mock\n    private XWiki xWiki;\n\n    private XWikiStoreInterface xWikiStoreInterface;\n\n    private VelocityManager velocityManager;\n\n    private BaseClass baseClass;\n\n    private BaseObject baseObject;\n\n    private BaseObject baseObject2;\n\n    @RegisterExtension\n    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.WARN);\n\n    @BeforeEach\n    protected void setUp() throws Exception\n    {\n        XWikiVersioningStoreInterface mockXWikiVersioningStore =\n            this.componentManager.registerMockComponent(XWikiVersioningStoreInterface.class);\n        this.xWikiStoreInterface = this.componentManager.registerMockComponent(XWikiStoreInterface.class);\n        this.velocityManager = this.componentManager.registerMockComponent(VelocityManager.class);\n        VelocityEngine mockVelocityEngine = this.componentManager.registerMockComponent(VelocityEngine.class);\n        this.componentManager.registerMockComponent(ExtendedRenderingConfiguration.class);\n\n        when(velocityManager.getVelocityEngine()).thenReturn(mockVelocityEngine);\n\n        Answer<Boolean> invocationVelocity = invocationOnMock -> {\n            // Output the given text without changes.\n            StringWriter writer = invocationOnMock.getArgument(0);\n            String text = invocationOnMock.getArgument(2);\n            writer.append(text);\n            return true;\n        };\n        when(mockVelocityEngine.evaluate(any(), any(), any(), any(String.class))).then(invocationVelocity);\n\n        DocumentReference documentReference = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n        this.document = new XWikiDocument(documentReference);\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n        this.document.setLanguage(\"en\");\n        this.document.setDefaultLanguage(\"en\");\n        this.document.setNew(false);\n\n        this.translatedDocument = new XWikiDocument();\n        this.translatedDocument.setSyntax(Syntax.XWIKI_2_0);\n        this.translatedDocument.setLanguage(\"fr\");\n        this.translatedDocument.setNew(false);\n\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);\n        when(mockXWikiVersioningStore.getXWikiDocumentArchive(any(), any())).thenReturn(null);\n\n        this.document.setStore(xWikiStoreInterface);\n\n        when(this.xWikiMessageTool.get(any())).thenReturn(\"message\");\n        when(this.xWikiRightService.hasProgrammingRights(any())).thenReturn(true);\n\n        when(this.xWiki.getVersioningStore()).thenReturn(mockXWikiVersioningStore);\n        when(this.xWiki.getStore()).thenReturn(xWikiStoreInterface);\n        when(this.xWiki.getDocument(any(DocumentReference.class), any())).thenReturn(this.document);\n        when(this.xWiki.getDocumentReference(any(XWikiRequest.class), any())).thenReturn(documentReference);\n        when(this.xWiki.getDocumentReference(any(EntityReference.class), any()))\n            .then(i -> new DocumentReference(i.getArgument(0)));\n        when(this.xWiki.getLanguagePreference(any())).thenReturn(\"en\");\n        when(this.xWiki.getSectionEditingDepth()).thenReturn(2L);\n        when(this.xWiki.getRightService()).thenReturn(this.xWikiRightService);\n        when(this.xWiki.exists(any(DocumentReference.class), any())).thenReturn(false);\n        when(this.xWiki.evaluateTemplate(any(), any())).thenReturn(\"\");\n\n        this.oldcore.getXWikiContext().setWiki(this.xWiki);\n        this.oldcore.getXWikiContext().put(\"msg\", this.xWikiMessageTool);\n\n        this.baseClass = this.document.getXClass();\n        this.baseClass.addTextField(\"string\", \"String\", 30);\n        this.baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        this.baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) this.baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        this.baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        this.baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        this.baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        this.baseClass.addStaticListField(\"stringlist\", \"StringList\", \"value1, value2\");\n\n        when(this.xWiki.getClass(any(), any())).thenReturn(this.baseClass);\n        when(this.xWiki.getXClass(any(), any())).thenReturn(this.baseClass);\n\n        this.baseObject = this.document.newObject(CLASSNAME, this.oldcore.getXWikiContext());\n        this.baseObject.setStringValue(\"string\", \"string\");\n        this.baseObject.setLargeStringValue(\"area\", \"area\");\n        this.baseObject.setStringValue(\"passwd\", \"passwd\");\n        this.baseObject.setIntValue(\"boolean\", 1);\n        this.baseObject.setIntValue(\"int\", 42);\n        this.baseObject.setStringListValue(\"stringlist\", Arrays.asList(\"VALUE1\", \"VALUE2\"));\n\n        this.baseObject2 = this.baseObject.clone();\n        this.document.addXObject(this.baseObject2);\n\n        when(xWikiStoreInterface.search(anyString(), anyInt(), anyInt(), any())).thenReturn(new ArrayList<>());\n    }\n\n    @Test\n    public void getUniqueLinkedPages10() throws XWikiException\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        when(xWiki.exists(any(DocumentReference.class), any())).thenReturn(true);\n\n        this.document.setContent(\"[TargetPage][TargetLabel>TargetPage][TargetSpace.TargetPage]\"\n            + \"[TargetLabel>TargetSpace.TargetPage?param=value#anchor][http://externallink][mailto:mailto][label>]\");\n\n        Set<String> linkedPages = this.document.getUniqueLinkedPages(this.oldcore.getXWikiContext());\n\n        assertEquals(new HashSet<>(Arrays.asList(\"TargetPage\", \"TargetSpace.TargetPage\")), new HashSet<>(linkedPages));\n    }\n\n    @Test\n    public void getUniqueLinkedPages20()\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        this.document.setContent(\"[[TargetPage]][[TargetLabel>>TargetPage]][[TargetSpace.TargetPage]]\"\n            + \"[[TargetLabel>>TargetSpace.TargetPage?param=value#anchor]][[http://externallink]][[mailto:mailto]]\"\n            + \"[[]][[#anchor]][[?param=value]][[targetwiki:TargetSpace.TargetPage]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        Set<String> linkedPages = this.document.getUniqueLinkedPages(this.oldcore.getXWikiContext());\n\n        assertEquals(new LinkedHashSet<>(Arrays.asList(\"Space.TargetPage.WebHome\",\n            \"TargetSpace.TargetPage.WebHome\", \"targetwiki:TargetSpace.TargetPage.WebHome\")), linkedPages);\n    }\n\n    @Test\n    public void getUniqueLinkedPages21() throws Exception\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.document.setContent(\"\"\n            + \"[[TargetPage]]\"\n            + \"[[TargetLabel>>TargetPage]]\"\n            + \"[[TargetSpace.TargetPage]]\"\n            + \"[[http://externallink]]\"\n            + \"[[mailto:mailto]]\"\n            + \"[[]]\"\n            + \"[[targetwiki:TargetSpace.TargetPage]]\"\n            + \"[[page:OtherPage]]\"\n            + \"[[attach:AttachSpace.AttachDocument@attachment.ext]]\"\n            + \"[[attach:attachment.ext]]\"\n            + \"[[pageAttach:OtherPage/attachment.ext]]\"\n            + \"image:ImageSpace.ImageDocument@image.png image:image.png\");\n        this.baseObject.setLargeStringValue(\"area\", \"[[TargetPage]][[ObjectTargetPage]]\");\n\n        // Simulate that \"OtherPage.WebHome\" exists\n        doReturn(new DocumentReference(\"Wiki\", \"OtherPage\", \"WebHome\")).when(this.xWiki)\n            .getDocumentReference(new PageReference(\"Wiki\", \"OtherPage\"), this.oldcore.getXWikiContext());\n\n        Set<String> linkedPages = this.document.getUniqueLinkedPages(this.oldcore.getXWikiContext());\n\n        assertEquals(\n            new LinkedHashSet<>(Arrays.asList(\n                \"Space.TargetPage.WebHome\",\n                \"TargetSpace.TargetPage.WebHome\",\n                \"targetwiki:TargetSpace.TargetPage.WebHome\",\n                \"OtherPage.WebHome\",\n                \"AttachSpace.AttachDocument.WebHome\",\n                \"ImageSpace.ImageDocument.WebHome\",\n                \"Space.ObjectTargetPage.WebHome\"\n            )), linkedPages);\n    }\n\n    @Test\n    public void getUniqueWikiLinkedPages() throws XWikiException\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        this.document.setContent(\"[[TargetPage]][[TargetLabel>>TargetPage]][[TargetSpace.TargetPage]]\"\n            + \"[[TargetLabel>>TargetSpace.TargetPage?param=value#anchor]][[http://externallink]][[mailto:mailto]]\"\n            + \"[[]][[#anchor]][[?param=value]][[targetwiki:TargetSpace.TargetPage]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        Set<XWikiLink> linkedPages = this.document.getUniqueWikiLinkedPages(this.oldcore.getXWikiContext());\n        Set<XWikiLink> expectedLinkedPages = new LinkedHashSet<>();\n        XWikiLink xWikiLink = new XWikiLink();\n        xWikiLink.setDocId(this.document.getId());\n        xWikiLink.setFullName(DOCSPACE + \".\" + DOCNAME);\n        xWikiLink.setLink(\"Space.TargetPage.WebHome\");\n        expectedLinkedPages.add(xWikiLink);\n\n        xWikiLink = new XWikiLink();\n        xWikiLink.setDocId(this.document.getId());\n        xWikiLink.setFullName(DOCSPACE + \".\" + DOCNAME);\n        xWikiLink.setLink(\"TargetSpace.TargetPage.WebHome\");\n        expectedLinkedPages.add(xWikiLink);\n\n        xWikiLink = new XWikiLink();\n        xWikiLink.setDocId(this.document.getId());\n        xWikiLink.setFullName(DOCSPACE + \".\" + DOCNAME);\n        xWikiLink.setLink(\"targetwiki:TargetSpace.TargetPage.WebHome\");\n        expectedLinkedPages.add(xWikiLink);\n\n        assertEquals(expectedLinkedPages, linkedPages);\n    }\n\n    @Test\n    public void getSections10() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"1 header 1\\nheader 1 content\\n\" + \"1.1 header 2\\nheader 2 content\");\n\n        List<DocumentSection> headers = this.document.getSections();\n\n        assertEquals(2, headers.size());\n\n        DocumentSection header1 = headers.get(0);\n        DocumentSection header2 = headers.get(1);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(23, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(51, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    @Test\n    public void getSections() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        List<DocumentSection> headers = this.document.getSections();\n\n        assertEquals(2, headers.size());\n\n        DocumentSection header1 = headers.get(0);\n        DocumentSection header2 = headers.get(1);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(-1, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(-1, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    @Test\n    public void getDocumentSection10() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"1 header 1\\nheader 1 content\\n\" + \"1.1 header 2\\nheader 2 content\");\n\n        DocumentSection header1 = this.document.getDocumentSection(1);\n        DocumentSection header2 = this.document.getDocumentSection(2);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(23, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(51, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    @Test\n    public void getDocumentSection() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        DocumentSection header1 = this.document.getDocumentSection(1);\n        DocumentSection header2 = this.document.getDocumentSection(2);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(-1, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(-1, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    /**\n     * Verify that if we have sections nested in groups, they are not taken into account when computing document\n     * sections by number. See <a href=\"https://jira.xwiki.org/browse/XWIKI-6195\">XWIKI-6195</a>.\n     *\n     * @since 5.0M1\n     */\n    @Test\n    public void getDocumentSectionWhenSectionInGroups() throws XWikiException\n    {\n        this.document.setContent(\n            \"= Heading1 =\\n\" + \"para1\\n\" + \"== Heading2 ==\\n\" + \"para2\\n\" + \"(((\\n\" + \"== Heading3 ==\\n\" + \"para3\\n\"\n                + \"(((\\n\" + \"== Heading4 ==\\n\" + \"para4\\n\" + \")))\\n\" + \")))\\n\" + \"== Heading5 ==\\n\" + \"para5\\n\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        DocumentSection section = this.document.getDocumentSection(3);\n        assertEquals(\"Heading5\", section.getSectionTitle());\n    }\n\n    @Test\n    public void getContentOfSection10() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"1 header 1\\nheader 1 content\\n\" + \"1.1 header 2\\nheader 2 content\");\n\n        String content1 = this.document.getContentOfSection(1);\n        String content2 = this.document.getContentOfSection(2);\n\n        assertEquals(\"1 header 1\\nheader 1 content\\n1.1 header 2\\nheader 2 content\", content1);\n        assertEquals(\"1.1 header 2\\nheader 2 content\", content2);\n    }\n\n    @Test\n    public void getContentOfSection() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\\n\"\n                + \"=== header 3===\\nheader 3 content\\n\" + \"== header 4==\\nheader 4 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        String content1 = this.document.getContentOfSection(1);\n        String content2 = this.document.getContentOfSection(2);\n        String content3 = this.document.getContentOfSection(3);\n\n        assertEquals(\"= header 1 =\\n\\nheader 1 content\\n\\n== header 2 ==\\n\\nheader 2 content\\n\\n\"\n            + \"=== header 3 ===\\n\\nheader 3 content\\n\\n== header 4 ==\\n\\nheader 4 content\", content1);\n        assertEquals(\"== header 2 ==\\n\\nheader 2 content\\n\\n=== header 3 ===\\n\\nheader 3 content\", content2);\n        assertEquals(\"== header 4 ==\\n\\nheader 4 content\", content3);\n\n        // Validate that third level header is not skipped anymore\n        when(this.xWiki.getSectionEditingDepth()).thenReturn(3L);\n\n        content3 = this.document.getContentOfSection(3);\n        String content4 = this.document.getContentOfSection(4);\n\n        assertEquals(\"=== header 3 ===\\n\\nheader 3 content\", content3);\n        assertEquals(\"== header 4 ==\\n\\nheader 4 content\", content4);\n    }\n\n    @Test\n    public void sectionSplit10() throws XWikiException\n    {\n        List<DocumentSection> sections;\n        // Simple test\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\n            \"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\" + \"Content of second section\\n\",\n            this.document.getContentOfSection(1));\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        assertEquals(\"1.1 Subsection 2\\nContent of second section\\n\", this.document.getContentOfSection(2));\n        assertEquals(3, sections.get(2).getSectionNumber());\n        assertEquals(80, sections.get(2).getSectionIndex());\n        assertEquals(\"1 Section 3\\nContent of section 3\", this.document.getContentOfSection(3));\n        // Test comments don't break the section editing\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"## 1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(2, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\"1\", sections.get(1).getSectionLevel());\n        assertEquals(2, sections.get(1).getSectionNumber());\n        assertEquals(83, sections.get(1).getSectionIndex());\n        // Test spaces are ignored\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"   1.1    Subsection 2  \\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Subsection 2  \", sections.get(1).getSectionTitle());\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        // Test lower headings are ignored\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1.1 Lower subsection\\n\"\n            + \"This content is not important\\n\" + \"   1.1    Subsection 2  \\n\" + \"Content of second section\\n\"\n            + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\"Subsection 2  \", sections.get(1).getSectionTitle());\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        // Test blank lines are preserved\n        this.document\n            .setContent(\"\\n\\n1 Section 1\\n\\n\\n\" + \"Content of first section\\n\\n\\n\" + \"   1.1    Subsection 2  \\n\\n\"\n                + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(2, sections.get(0).getSectionIndex());\n        assertEquals(\"Subsection 2  \", sections.get(1).getSectionTitle());\n        assertEquals(43, sections.get(1).getSectionIndex());\n    }\n\n    @Test\n    public void updateDocumentSection10() throws XWikiException\n    {\n        List<DocumentSection> sections;\n        // Fill the document\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        String content = this.document.updateDocumentSection(3, \"1 Section 3\\n\" + \"Modified content of section 3\");\n        assertEquals(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Modified content of section 3\", content);\n        this.document.setContent(content);\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\n            \"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\" + \"Content of second section\\n\",\n            this.document.getContentOfSection(1));\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        assertEquals(\"1.1 Subsection 2\\nContent of second section\\n\", this.document.getContentOfSection(2));\n        assertEquals(3, sections.get(2).getSectionNumber());\n        assertEquals(80, sections.get(2).getSectionIndex());\n        assertEquals(\"1 Section 3\\nModified content of section 3\", this.document.getContentOfSection(3));\n    }\n\n    @Test\n    public void updateDocumentSection() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        // Modify section content\n        String content1 = this.document.updateDocumentSection(2, \"== header 2==\\nmodified header 2 content\");\n\n        assertEquals(\n            \"content not in section\\n\\n= header 1 =\\n\\nheader 1 content\\n\\n== header 2 ==\\n\\nmodified header 2 content\",\n            content1);\n\n        String content2 = this.document.updateDocumentSection(1,\n            \"= header 1 =\\n\\nmodified also header 1 content\\n\\n== header 2 ==\\n\\nheader 2 content\");\n\n        assertEquals(\n            \"content not in section\\n\\n= header 1 =\\n\\nmodified also header 1 content\\n\\n== header 2 ==\\n\\nheader 2 content\",\n            content2);\n\n        // Remove a section\n        String content3 = this.document.updateDocumentSection(2, \"\");\n\n        assertEquals(\"content not in section\\n\\n= header 1 =\\n\\nheader 1 content\", content3);\n    }\n\n    @Test\n    public void display()\n    {\n        when(this.xWiki.getCurrentContentSyntaxId(any())).thenReturn(\"xwiki/2.0\");\n\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\n            \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}<input size='30' id='Space.Page_0_string' value='string' name='Space.Page_0_string' type='text'/>{{/html}}\",\n            this.document.display(\"string\", \"edit\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"string\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        this.baseObject.setStringValue(\"string\", \"1 & 2\");\n\n        assertEquals(\"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}1 &#38; 2{{/html}}\",\n            this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        this.baseObject.setStringValue(\"string\", \"1 < 2\");\n\n        assertEquals(\"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}1 &#60; 2{{/html}}\",\n            this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        this.baseObject.setStringValue(\"string\", \"1 > 2\");\n\n        assertEquals(\"1 > 2\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}<p>area</p>{{/html}}\",\n            this.document.display(\"area\", \"view\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void display1020()\n    {\n        when(this.xWiki.getCurrentContentSyntaxId(any(), any())).thenReturn(\"xwiki/1.0\");\n\n        XWikiDocument doc10 = new XWikiDocument();\n        doc10.setSyntax(Syntax.XWIKI_1_0);\n        this.oldcore.getXWikiContext().setDoc(doc10);\n\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\"string\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n        assertEquals(\n            \"{pre}<input size='30' id='Space.Page_0_string' value='string' name='Space.Page_0_string' type='text'/>{/pre}\",\n            this.document.display(\"string\", \"edit\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>area</p>\", this.document.display(\"area\", \"view\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void displayTemplate20()\n    {\n        when(this.xWiki.getCurrentContentSyntaxId(any())).thenReturn(\"xwiki/2.0\");\n\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", false);\n\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\"string\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n        assertEquals(\n            \"<input size='30' id='Space.Page_0_string' value='string' name='Space.Page_0_string' type='text'/>\",\n            this.document.display(\"string\", \"edit\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>area</p>\", this.document.display(\"area\", \"view\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void convertSyntax() throws XWikiException\n    {\n        this.document.setSyntax(Syntax.HTML_4_01);\n        this.document.setContent(\"<p>content not in section</p>\" + \"<h1>header 1</h1><p>header 1 content</p>\"\n            + \"<h2>header 2</h2><p>header 2 content</p>\");\n        this.baseObject.setLargeStringValue(\"area\",\n            \"<p>object content not in section</p>\" + \"<h1>object header 1</h1><p>object header 1 content</p>\"\n                + \"<h2>object header 2</h2><p>object header 2 content</p>\");\n        this.baseObject.setLargeStringValue(\"puretextarea\",\n            \"<p>object content not in section</p>\" + \"<h1>object header 1</h1><p>object header 1 content</p>\"\n                + \"<h2>object header 2</h2><p>object header 2 content</p>\");\n\n        this.document.convertSyntax(\"xwiki/2.0\", this.oldcore.getXWikiContext());\n\n        assertEquals(\"content not in section\\n\\n\" + \"= header 1 =\\n\\nheader 1 content\\n\\n\"\n            + \"== header 2 ==\\n\\nheader 2 content\", this.document.getContent());\n        assertEquals(\"object content not in section\\n\\n\" + \"= object header 1 =\\n\\nobject header 1 content\\n\\n\"\n            + \"== object header 2 ==\\n\\nobject header 2 content\", this.baseObject.getStringValue(\"area\"));\n        assertEquals(\n            \"<p>object content not in section</p>\" + \"<h1>object header 1</h1><p>object header 1 content</p>\"\n                + \"<h2>object header 2</h2><p>object header 2 content</p>\",\n            this.baseObject.getStringValue(\"puretextarea\"));\n        assertEquals(\"xwiki/2.0\", this.document.getSyntaxId());\n    }\n\n    @Test\n    public void getRenderedContent() throws XWikiException\n    {\n        this.document.setContent(\"**bold**\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\"<p><strong>bold</strong></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n\n        this.translatedDocument = new XWikiDocument(this.document.getDocumentReference(), Locale.FRENCH);\n        this.translatedDocument.setContent(\"//italic//\");\n        this.translatedDocument.setSyntax(Syntax.XWIKI_1_0);\n        this.translatedDocument.setNew(false);\n\n        when(this.xWiki.getLanguagePreference(any())).thenReturn(Locale.FRENCH.toString());\n        when(this.xWiki.getDocument(eq(\n            new DocumentReference(this.translatedDocument.getDocumentReference(), this.translatedDocument.getLocale())),\n            any())).thenReturn(this.translatedDocument);\n\n        assertEquals(\"<p><em>italic</em></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentWithSourceSyntax()\n    {\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n\n        assertEquals(\"<p><strong>bold</strong></p>\",\n            this.document.getRenderedContent(\"**bold**\", \"xwiki/2.0\", this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Validate rename does not crash when the document has 1.0 syntax (it does not support everything but it does not\n     * crash).\n     */\n    @Test\n    public void rename10() throws XWikiException\n    {\n        this.document.setContent(\"[pageinsamespace]\");\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n        DocumentReference targetReference = new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\");\n        XWikiDocument targetDocument = this.document.duplicate(targetReference);\n\n        when(this.xWiki.copyDocument(any(), any(), any())).thenReturn(true);\n        when(this.xWiki.getDocument(eq(targetReference), any())).thenReturn(targetDocument);\n\n        this.document.rename(new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\"),\n            Collections.emptyList(), Collections.emptyList(),\n            this.oldcore.getXWikiContext());\n\n        // Test links\n        assertEquals(\"[pageinsamespace]\", this.document.getContent());\n    }\n\n    /**\n     * @see \"XWIKI-7515: 'getIncludedPages' in class com.xpn.xwiki.api.Document threw java.lang.NullPointerException\"\n     */\n    @Test\n    public void getIncludedPages()\n    {\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n\n        this.document.setContent(\"no include\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"bad {{include/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"good deprecated {{include document=\\\"Foo.Bar\\\"/}}\");\n        assertEquals(Arrays.asList(\"Foo.Bar\"), this.document.getIncludedPages(this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"good {{include reference=\\\"One.Two\\\"/}}\");\n        assertEquals(Arrays.asList(\"One.Two\"), this.document.getIncludedPages(this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"bad recursive {{include reference=\\\"\\\"/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"bad recursive {{include reference=\\\"\" + DOCNAME + \"\\\"/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"bad recursive {{include reference=\\\"\" + DOCSPACE + \".\" + DOCNAME + \"\\\"/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n    }\n\n    /**\n     * XWIKI-8025: XWikiDocument#backup/restoreContext doesn't update the reference to the Velocity context stored on\n     * the XWiki context\n     */\n    @Test\n    public void backupRestoreContextUpdatesVContext() throws Exception\n    {\n        final Execution execution = this.oldcore.getMocker().getInstance(Execution.class);\n\n        when(this.velocityManager.getVelocityContext())\n            .then(invocationOnMock -> execution.getContext().getProperty(\"velocityContext\"));\n\n        VelocityContext oldVelocityContext = new VelocityContext();\n        execution.getContext().setProperty(\"velocityContext\", oldVelocityContext);\n\n        Map<String, Object> backup = new HashMap<>();\n        XWikiDocument.backupContext(backup, this.oldcore.getXWikiContext());\n\n        VelocityContext newVelocityContext = (VelocityContext) execution.getContext().getProperty(\"velocityContext\");\n        assertNotNull(newVelocityContext);\n        assertNotSame(oldVelocityContext, newVelocityContext);\n        assertSame(newVelocityContext, this.oldcore.getXWikiContext().get(\"vcontext\"));\n\n        XWikiDocument.restoreContext(backup, this.oldcore.getXWikiContext());\n\n        assertSame(oldVelocityContext, execution.getContext().getProperty(\"velocityContext\"));\n        assertSame(oldVelocityContext, this.oldcore.getXWikiContext().get(\"vcontext\"));\n    }\n\n    @Test\n    public void getIntValue()\n    {\n        assertEquals(42, this.document.getIntValue(CLASS_REFERENCE, \"int\", 99));\n        assertEquals(42, this.document.getIntValue(CLASS_REFERENCE, \"int\"));\n\n        assertEquals(0, this.document.getIntValue(CLASS_REFERENCE, \"foo\"));\n        assertEquals(99, this.document.getIntValue(CLASS_REFERENCE, \"foo\", 99));\n\n        assertEquals(0, this.document.getIntValue(new DocumentReference(\"foo\", \"bar\", \"bla\"), \"foo\"));\n        assertEquals(99, this.document.getIntValue(new DocumentReference(\"foo\", \"bar\", \"bla\"), \"foo\", 99));\n    }\n\n    @Test\n    void getAttachment() throws Exception\n    {\n        this.document.setAttachment(\"file.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNotNull(this.document.getAttachment(\"file.txt\"));\n    }\n    \n    @Test\n    void getAttachmentWithExtension() throws Exception\n    {\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file.txt.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNotNull(this.document.getAttachment(\"file.txt\"));\n    }\n\n    @Test\n    void getExactAttachment() throws Exception\n    {\n        this.document.setAttachment(\"file.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNotNull(this.document.getExactAttachment(\"file.txt\"));\n    }\n\n    @Test\n    void getExactAttachmentWithExtension() throws Exception\n    {\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file.txt.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNull(this.document.getExactAttachment(\"file.txt\"));\n    }\n\n    /**\n     * Validate that an attachment with the same name less the extension as an existing attachment does not override it.\n     */\n    @Test\n    void setAttachment() throws Exception\n    {\n        this.document.setAttachment(\"file.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        List<XWikiAttachment> attachmentList = this.document.getAttachmentList();\n        assertEquals(2, attachmentList.size());\n        assertEquals(\"file.txt\", attachmentList.get(1).getFilename());\n        assertEquals(\"file\", attachmentList.get(0).getFilename());\n    }\n\n    /*\n     * Test for checking that cloneInternal doesn't replace the XWikiDocumentArchive by an empty document archive,\n     * and to ensure that the versioningStore is properly called when using\n     * XWikiDocument#getDocumentArchive(XWikiContext).\n     */\n    @Test\n    void getDocumentArchiveAfterClone() throws XWikiException\n    {\n        XWikiContext context = this.oldcore.getXWikiContext();\n        XWikiVersioningStoreInterface versioningStore =\n            this.document.getVersioningStore(context);\n        when(versioningStore.getXWikiDocumentArchive(any(), any())).then(invocationOnMock -> {\n            XWikiDocument doc = invocationOnMock.getArgument(0);\n            if (doc.getDocumentArchive() != null) {\n                return doc.getDocumentArchive();\n            } else {\n                return mock(XWikiDocumentArchive.class);\n            }\n        });\n        assertSame(versioningStore, document.getVersioningStore(context));\n        assertNull(this.document.getDocumentArchive());\n        XWikiDocumentArchive documentArchive = this.document.getDocumentArchive(context);\n        assertNotNull(documentArchive);\n        assertNotNull(this.document.getDocumentArchive());\n\n        XWikiDocument cloneDoc = document.clone();\n        assertNull(cloneDoc.getDocumentArchive());\n        XWikiDocumentArchive cloneArchive = cloneDoc.getDocumentArchive(context);\n        verify(versioningStore).getXWikiDocumentArchive(\n            argThat(givenDoc -> givenDoc != XWikiDocumentTest.this.document), eq(context));\n        assertNotNull(cloneArchive);\n        assertNotSame(cloneArchive, documentArchive);\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.lang.ref.SoftReference;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.inject.Provider;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.ObjectUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.dom.DOMDocument;\nimport org.dom4j.io.DocumentResult;\nimport org.dom4j.io.OutputFormat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.Diff;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.Revision;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.suigeneris.jrcs.util.ToString;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContextException;\nimport org.xwiki.context.ExecutionContextManager;\nimport org.xwiki.display.internal.DocumentDisplayer;\nimport org.xwiki.display.internal.DocumentDisplayerParameters;\nimport org.xwiki.filter.input.DefaultInputStreamInputSource;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.filter.input.StringInputSource;\nimport org.xwiki.filter.instance.input.DocumentInstanceInputProperties;\nimport org.xwiki.filter.instance.output.DocumentInstanceOutputProperties;\nimport org.xwiki.filter.output.DefaultOutputStreamOutputTarget;\nimport org.xwiki.filter.output.DefaultWriterOutputTarget;\nimport org.xwiki.filter.output.OutputTarget;\nimport org.xwiki.filter.xar.input.XARInputProperties;\nimport org.xwiki.filter.xar.output.XAROutputProperties;\nimport org.xwiki.filter.xml.output.DefaultResultOutputTarget;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.link.LinkException;\nimport org.xwiki.link.LinkStore;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.document.DefaultDocumentAuthors;\nimport org.xwiki.model.internal.reference.DefaultSymbolScheme;\nimport org.xwiki.model.internal.reference.EntityReferenceFactory;\nimport org.xwiki.model.internal.reference.LocalStringEntityReferenceSerializer;\nimport org.xwiki.model.internal.reference.LocalUidStringEntityReferenceSerializer;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectPropertyReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.ObjectReferenceResolver;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.MacroBlock;\nimport org.xwiki.rendering.block.SectionBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.block.match.MacroBlockMatcher;\nimport org.xwiki.rendering.internal.parser.LinkParser;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.parser.ContentParser;\nimport org.xwiki.rendering.parser.MissingParserException;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.parser.Parser;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.renderer.printer.DefaultWikiPrinter;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxRegistry;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationException;\nimport org.xwiki.rendering.transformation.TransformationManager;\nimport org.xwiki.rendering.util.ErrorBlockGenerator;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.store.TemporaryAttachmentSessionsManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.store.merge.MergeManager;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.xar.internal.model.XarDocumentModel;\nimport org.xwiki.xml.XMLUtils;\nimport org.xwiki.xml.html.HTMLUtils;\n\nimport com.xpn.xwiki.CoreConfiguration;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.criteria.impl.RevisionCriteria;\nimport com.xpn.xwiki.doc.merge.MergeConfiguration;\nimport com.xpn.xwiki.doc.merge.MergeResult;\nimport com.xpn.xwiki.doc.rcs.XWikiRCSNodeInfo;\nimport com.xpn.xwiki.internal.cache.rendering.RenderingCache;\nimport com.xpn.xwiki.internal.doc.BaseObjects;\nimport com.xpn.xwiki.internal.doc.XWikiAttachmentList;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterUtils;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.xml.DOMXMLWriter;\nimport com.xpn.xwiki.internal.xml.XMLWriter;\nimport com.xpn.xwiki.objects.BaseCollection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseObjectReference;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.LargeStringProperty;\nimport com.xpn.xwiki.objects.ListProperty;\nimport com.xpn.xwiki.objects.ObjectDiff;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.ListClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.classes.StaticListClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateAttachmentStore;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.validation.XWikiValidationInterface;\nimport com.xpn.xwiki.validation.XWikiValidationStatus;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.ObjectAddForm;\nimport com.xpn.xwiki.web.ObjectPolicyType;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiRequest;\n\npublic class XWikiDocument implements DocumentModelBridge, Cloneable\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiDocument.class);\n\n    private static final String TM_FAILEDDOCUMENTPARSE = \"core.document.error.failedParse\";\n\n    private static final String CLOSE_HTML_MACRO = \"{{/html}}\";\n\n    /**\n     * An attachment waiting to be deleted at next document save.\n     *\n     * @version $Id$\n     * @since 5.2M1\n     */\n    public static class XWikiAttachmentToRemove\n    {\n        /**\n         * @see #getAttachment()\n         */\n        private XWikiAttachment attachment;\n\n        /**\n         * @see #isToRecycleBin()\n         */\n        private boolean toRecycleBin;\n\n        /**\n         * @param attachment the attachment to delete\n         * @param toRecycleBin true of the attachment should be moved to the recycle bin\n         */\n        public XWikiAttachmentToRemove(XWikiAttachment attachment, boolean toRecycleBin)\n        {\n            this.attachment = attachment;\n            this.toRecycleBin = toRecycleBin;\n        }\n\n        /**\n         * @return the attachment to delete\n         */\n        public XWikiAttachment getAttachment()\n        {\n            return this.attachment;\n        }\n\n        /**\n         * @return true of the attachment should be moved to the recycle bin\n         */\n        public boolean isToRecycleBin()\n        {\n            return this.toRecycleBin;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return this.attachment.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (obj instanceof XWikiAttachmentToRemove) {\n                return this.attachment.equals(((XWikiAttachmentToRemove) obj).getAttachment());\n            }\n\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return this.attachment.toString();\n        }\n    }\n\n    /**\n     * Regex Pattern to recognize if there's HTML code in a XWiki page.\n     */\n    private static final Pattern HTML_TAG_PATTERN = Pattern.compile(\n        \"</?+(html|img|a|i|br?|embed|script|form|input|textarea|object|font|li|[dou]l|table|center|hr|p) ?([^>]*+)>\");\n\n    public static final EntityReference COMMENTSCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"XWikiComments\");\n\n    public static final EntityReference SHEETCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"SheetClass\");\n\n    public static final int HAS_ATTACHMENTS = 1;\n\n    public static final int HAS_OBJECTS = 2;\n\n    public static final int HAS_CLASS = 4;\n\n    /**\n     * The name of the key in the XWikiContext which contains the document used to check for programming rights.\n     */\n    public static final String CKEY_SDOC = \"sdoc\";\n\n    /**\n     * Separator string between database name and space name.\n     */\n    public static final String DB_SPACE_SEP = \":\";\n\n    /**\n     * Separator string between space name and page name.\n     */\n    public static final String SPACE_NAME_SEP = \".\";\n\n    private static final LocalStringEntityReferenceSerializer LOCAL_REFERENCE_SERIALIZER =\n        new LocalStringEntityReferenceSerializer(new DefaultSymbolScheme());\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks.\n     */\n    private static DocumentReferenceResolver<String> getCurrentDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<ResourceReference> getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class, ResourceReference.class));\n    }\n\n    private static EntityReferenceResolver<String> getXClassEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"xclass\");\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private static DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to resolve parent references in the way they are stored externally (database, xml, etc), ie relative or\n     * absolute.\n     */\n    private static EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static ObjectReferenceResolver<EntityReference> getCurrentReferenceObjectReferenceResolver()\n    {\n        return Utils.getComponent(ObjectReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to convert a syntax defined as String into a Syntax object.\n     */\n    private static SyntaxRegistry getSyntaxRegistry()\n    {\n        return Utils.getComponent(SyntaxRegistry.class);\n    }\n\n    /**\n     * Used to retrieve backlinks from an XDOM.\n     */\n    private static LinkParser getLinkParser() {\n        return Utils.getComponent(LinkParser.class);\n    }\n\n    /**\n     * @return the user module configuration, used for instance to determine where users are stored\n     */\n    private static UserConfiguration getUserConfiguration()\n    {\n        return Utils.getComponent(UserConfiguration.class);\n    }\n\n    private String title;\n\n    /**\n     * Reference to this document's parent.\n     * <p>\n     * Note that we're saving the parent reference as a relative reference instead of an absolute one because We want\n     * the ability (for example) to create a parent reference relative to the current space or wiki so that a copy of\n     * this XWikiDocument object would retain that relativity. This is for example useful when copying a Wiki into\n     * another Wiki so that the copied XWikiDcoument's parent reference points to the new wiki.\n     */\n    private EntityReference parentReference;\n\n    private DocumentReference documentReference;\n\n    private String content;\n\n    private String meta;\n\n    private String format;\n\n    private String customClass;\n\n    private Date contentUpdateDate;\n\n    private Date updateDate;\n\n    private Date creationDate;\n\n    protected Version version;\n\n    private long id = 0;\n\n    private boolean mostRecent = true;\n\n    private boolean isNew = true;\n\n    /**\n     * The reference to the document that is the template for the current document.\n     *\n     * @todo this field is not used yet since it's not currently saved in the database.\n     */\n    private DocumentReference templateDocumentReference;\n\n    private Locale locale;\n\n    private Locale defaultLocale;\n\n    /**\n     * Indicates whether the document is 'hidden', meaning that it should not be returned in public search results.\n     * WARNING: this is a temporary hack until the new data model is designed and implemented. No code should rely on or\n     * use this property, since it will be replaced with a generic metadata.\n     */\n    private boolean hidden = false;\n\n    /**\n     * Comment on the latest modification.\n     */\n    private String comment;\n\n    /**\n     * Wiki syntax supported by this document. This is used to support different syntaxes inside the same wiki. For\n     * example a page can use the MediaWiki 1.0 syntax while another one uses the XWiki 2.1 syntax.\n     */\n    private Syntax syntax;\n\n    /**\n     * Is latest modification a minor edit.\n     */\n    private boolean isMinorEdit = false;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isContentDirty = true;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isMetaDataDirty = true;\n\n    private int elements = HAS_OBJECTS | HAS_ATTACHMENTS;\n\n    // Meta Data\n    private BaseClass xClass;\n\n    private String xClassXML;\n\n    /**\n     * Map holding document objects indexed by XClass references (i.e. Document References since a XClass reference\n     * points to a document). The preserve index ordering (consistent sorted order for output to XML, rendering in\n     * velocity, etc.)\n     */\n    private Map<DocumentReference, BaseObjects> xObjects = new ConcurrentSkipListMap<>();\n\n    /**\n     * The publicly exposed Map.\n     */\n    private Map<DocumentReference, List<BaseObject>> publicXObjects = new Map<DocumentReference, List<BaseObject>>()\n    {\n        @Override\n        public List<BaseObject> put(DocumentReference key, List<BaseObject> value)\n        {\n            // Makes sure to always insert BaseObjects\n            return xObjects.put(key, value instanceof BaseObjects ? (BaseObjects) value : new BaseObjects(value));\n        }\n\n        @Override\n        public void putAll(Map<? extends DocumentReference, ? extends List<BaseObject>> m)\n        {\n            m.forEach(this::put);\n        }\n\n        @Override\n        public int size()\n        {\n            return xObjects.size();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return xObjects.isEmpty();\n        }\n\n        @Override\n        public boolean containsKey(Object key)\n        {\n            return xObjects.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(Object value)\n        {\n            return xObjects.containsValue(value);\n        }\n\n        @Override\n        public List<BaseObject> get(Object key)\n        {\n            return xObjects.get(key);\n        }\n\n        @Override\n        public List<BaseObject> remove(Object key)\n        {\n            return xObjects.remove(key);\n        }\n\n        @Override\n        public void clear()\n        {\n            xObjects.clear();            \n        }\n\n        @Override\n        public Set<DocumentReference> keySet()\n        {\n            return xObjects.keySet();\n        }\n\n        @Override\n        public Collection<List<BaseObject>> values()\n        {\n            return (Collection) xObjects.values();\n        }\n\n        @Override\n        public Set<Entry<DocumentReference, List<BaseObject>>> entrySet()\n        {\n            return (Set) xObjects.entrySet();\n        }\n    };\n\n    private final XWikiAttachmentList attachmentList = new XWikiAttachmentList(XWikiDocument.this);\n\n    // Caching\n    private boolean fromCache = false;\n\n    private List<BaseObject> xObjectsToRemove = new ArrayList<BaseObject>();\n\n    private List<XWikiAttachmentToRemove> attachmentsToRemove = new ArrayList<XWikiAttachmentToRemove>();\n\n    /**\n     * The view template (vm file) to use. When not set the default view template is used.\n     *\n     * @see com.xpn.xwiki.web.ViewAction#render(XWikiContext)\n     */\n    private String defaultTemplate;\n\n    private String validationScript;\n\n    private Object wikiNode;\n\n    /**\n     * We are using a SoftReference which will allow the archive to be discarded by the Garbage collector as long as the\n     * context is closed (usually during the request)\n     */\n    private SoftReference<XWikiDocumentArchive> archive;\n\n    private XWikiStoreInterface store;\n\n    /**\n     * @see #getOriginalDocument()\n     */\n    private XWikiDocument originalDocument;\n\n    /**\n     * Used to display the title and the content of this document. Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private DocumentDisplayer documentDisplayer;\n\n    /**\n     * @see #getDefaultEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * @see #getExplicitDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<String> explicitDocumentReferenceResolver;\n\n    /**\n     * @see #getExplicitReferenceDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<EntityReference> explicitReferenceDocumentReferenceResolver;\n\n    /**\n     * @see #getPageReferenceResolver()\n     */\n    private PageReferenceResolver<EntityReference> pageReferenceResolver;\n\n    /**\n     * @see #getUidStringEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> uidStringEntityReferenceSerializer;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private JobProgressManager progress;\n\n    private ContextualLocalizationManager localization;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private EntityReferenceFactory entityReferenceFactory;\n\n    /**\n     * The document structure expressed as a tree of Block objects. We store it for performance reasons since parsing is\n     * a costly operation that we don't want to repeat whenever some code ask for the XDOM information.\n     */\n    private XDOM xdomCache;\n\n    /**\n     * Use to store rendered documents in #getRenderedContent(). Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private RenderingCache renderingCache;\n\n    /**\n     * Cache the parent reference resolved as an absolute reference for improved performance (so that we don't have to\n     * resolve the relative reference every time getParentReference() is called.\n     */\n    private DocumentReference parentReferenceCache;\n\n    /**\n     * Cache the document reference with locale resolved kept for improved performance (so that we don't have to resolve\n     * it every time getPageReference() is called.\n     */\n    private DocumentReference documentReferenceWithLocaleCache;\n\n    /**\n     * Cache the page reference resolved kept for improved performance (so that we don't have to resolve it every time\n     * getPageReference() is called.\n     */\n    private PageReference pageReferenceCache;\n\n    /**\n     * Cache the page reference with locale resolved kept for improved performance (so that we don't have to resolve it\n     * every time getPageReference() is called.\n     */\n    private PageReference pageReferenceWithLocaleCache;\n\n    /**\n     * @see #getKey()\n     */\n    private String keyCache;\n\n    /**\n     * @see #getLocalKey()\n     */\n    private String localKeyCache;\n\n    private RenderingContext renderingContext;\n\n    /**\n     * @see #getAuthors()\n     */\n    private final DefaultDocumentAuthors authors = new DefaultDocumentAuthors(this);\n\n    /**\n     * Create a document for the given reference, with the {@link Locale#ROOT} even if the reference contains a locale.\n     * If you want to create a document for another locale, use {@link #XWikiDocument(DocumentReference, Locale)}.\n     * @since 2.2M1\n     */\n    public XWikiDocument(DocumentReference reference)\n    {\n        init(reference);\n    }\n\n    /**\n     * @since 6.2\n     */\n    public XWikiDocument(DocumentReference reference, Locale locale)\n    {\n        init(reference);\n\n        this.locale = locale;\n    }\n\n    /**\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument()\n    {\n        this(null);\n    }\n\n    /**\n     * Constructor that specifies the local document identifier: space name, document name. {@link #setDatabase(String)}\n     * must be called afterwards to specify the wiki name.\n     *\n     * @param space the space this document belongs to\n     * @param name the name of the document\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String space, String name)\n    {\n        this(null, space, name);\n    }\n\n    /**\n     * Constructor that specifies the full document identifier: wiki name, space name, document name.\n     *\n     * @param wiki The wiki this document belongs to.\n     * @param space The space this document belongs to.\n     * @param name The name of the document (can contain either the page name or the space and page name)\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String wiki, String space, String name)\n    {\n        // We allow to specify the space in the name (eg name = \"space.page\"). In this case the passed space is\n        // ignored.\n\n        // Build an entity reference that will serve as a current context reference against which to resolve if the\n        // passed name doesn't contain a space.\n        EntityReference contextReference = null;\n        if (!StringUtils.isEmpty(space)) {\n            contextReference = new EntityReference(space, EntityType.SPACE);\n        }\n\n        DocumentReference reference = getCurrentDocumentReferenceResolver().resolve(name, contextReference);\n\n        if (!StringUtils.isEmpty(wiki)) {\n            reference = reference.replaceParent(reference.getWikiReference(), new WikiReference(wiki));\n        }\n\n        init(reference);\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference.\n     */\n    private DocumentReferenceResolver<String> getExplicitDocumentReferenceResolver()\n    {\n        if (this.explicitDocumentReferenceResolver == null) {\n            this.explicitDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"explicit\");\n        }\n\n        return this.explicitDocumentReferenceResolver;\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private DocumentReferenceResolver<EntityReference> getExplicitReferenceDocumentReferenceResolver()\n    {\n        if (this.explicitReferenceDocumentReferenceResolver == null) {\n            this.explicitReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"explicit\");\n        }\n\n        return this.explicitReferenceDocumentReferenceResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getPageReferenceResolver()\n    {\n        if (this.pageReferenceResolver == null) {\n            this.pageReferenceResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE);\n        }\n\n        return this.pageReferenceResolver;\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    /**\n     * Used to compute document identifier.\n     */\n    private EntityReferenceSerializer<String> getUidStringEntityReferenceSerializer()\n    {\n        if (this.uidStringEntityReferenceSerializer == null) {\n            this.uidStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"uid\");\n        }\n\n        return this.uidStringEntityReferenceSerializer;\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private EntityReferenceFactory getEntityReferenceFactory()\n    {\n        if (this.entityReferenceFactory == null && Utils.getRootComponentManager() != null) {\n            try {\n                this.entityReferenceFactory = Utils.getRootComponentManager().getInstance(EntityReferenceFactory.class);\n            } catch (ComponentLookupException e) {\n                // Not a big deal\n            }\n        }\n\n        return this.entityReferenceFactory;\n    }\n\n    private <E extends EntityReference> E intern(E reference)\n    {\n        EntityReferenceFactory factory = getEntityReferenceFactory();\n\n        return factory != null ? factory.getReference(reference) : reference;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    private UserReferenceSerializer<DocumentReference> getUserReferenceDocumentReferenceSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceResolver<DocumentReference> getUserReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceStringSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING);\n    }\n\n    private UserReferenceResolver<String> getUserReferenceStringResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_STRING);\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceCompactWikiSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING, \"compactwiki/document\");\n    }\n\n    private LinkStore getLinkStore()\n    {\n        return Utils.getComponent(LinkStore.class);        \n    }\n\n    public XWikiStoreInterface getStore(XWikiContext context)\n    {\n        return context.getWiki().getStore();\n    }\n\n    /**\n     * @deprecated use {@link XWiki#getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public XWikiAttachmentStoreInterface getAttachmentStore(XWikiContext context)\n    {\n        return context.getWiki().getAttachmentStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore(XWikiContext context)\n    {\n        return context.getWiki().getVersioningStore();\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    /**\n     * Helper to produce and cache a local uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (in a wiki) (5:space4:name2:lg)\n     */\n    private String getLocalKey()\n    {\n        if (this.localKeyCache == null) {\n            this.localKeyCache =\n                LocalUidStringEntityReferenceSerializer.INSTANCE.serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.localKeyCache;\n    }\n\n    /**\n     * Helper to produce and cache a uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (8:wikiname5:space4:name2:lg or 8:wikiname5:space4:name)\n     * @since 4.0M1\n     */\n    public String getKey()\n    {\n        if (this.keyCache == null) {\n            this.keyCache = getUidStringEntityReferenceSerializer().serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.keyCache;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int) Util.getHash(getLocalKey());\n    }\n\n    /**\n     * @return the unique id used to represent the document, as a number. This id is technical and is equivalent to the\n     *         Document Reference + the language of the Document. This technical id should only be used for the storage\n     *         layer and all user APIs should instead use Document Reference and language as they are model-related\n     *         while the id isn't (it's purely technical).\n     */\n    public long getId()\n    {\n        // TODO: Ensure uniqueness of the generated id\n        // The implementation doesn't guarantee a unique id since it uses a hashing method which never guarantee\n        // uniqueness. However, the hash algorithm is really unlikely to collide in a given wiki. This needs to be\n        // fixed to produce a real unique id since otherwise we can have clashes in the database.\n\n        // Note: We don't use the wiki name in the document id's computation. The main historical reason is so\n        // that all things saved in a given wiki's database are always stored relative to that wiki so that\n        // changing that wiki's name is simpler.\n\n        this.id = Util.getHash(getLocalKey());\n\n        return this.id;\n    }\n\n    /**\n     * @see #getId()\n     */\n    public void setId(long id)\n    {\n        this.id = id;\n    }\n\n    /**\n     * Return the full local space reference. For example a document located in sub-space <code>space11</code> of space\n     * <code>space1</code> will return <code>space1.space11</code>.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the local reference the space of the document as String\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getSpace()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference());\n    }\n\n    /**\n     * Set the full local space reference.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @see #getSpace()\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setSpace(String spaces)\n    {\n        if (spaces != null) {\n            DocumentReference reference = getDocumentReference();\n            EntityReference spaceReference = getRelativeEntityReferenceResolver().resolve(spaces, EntityType.SPACE);\n            spaceReference = spaceReference.appendParent(getDocumentReference().getWikiReference());\n            setDocumentReferenceInternal(\n                new DocumentReference(reference.getName(), new SpaceReference(spaceReference)));\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the name of the space of the document\n     * @see #getSpace()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    public String getWeb()\n    {\n        return getSpace();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated\n    public void setWeb(String space)\n    {\n        setSpace(space);\n    }\n\n    @Override\n    public String getVersion()\n    {\n        return getRCSVersion().toString();\n    }\n\n    public void setVersion(String version)\n    {\n        if (!StringUtils.isEmpty(version)) {\n            this.version = new Version(version);\n        }\n    }\n\n    public Version getRCSVersion()\n    {\n        if (this.version == null) {\n            return new Version(\"1.1\");\n        }\n        return this.version;\n    }\n\n    public void setRCSVersion(Version version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * @return the copy of this XWikiDocument instance before any modification was made to it. This copy is used for\n     *         finding out differences made to this document (useful for example to send the correct notifications to\n     *         document change listeners).\n     */\n    @Override\n    public XWikiDocument getOriginalDocument()\n    {\n        return this.originalDocument;\n    }\n\n    /**\n     * @param originalDocument the original document representing this document instance before any change was made to\n     *            it, prior to the last time it was saved\n     * @see #getOriginalDocument()\n     */\n    public void setOriginalDocument(XWikiDocument originalDocument)\n    {\n        this.originalDocument = originalDocument;\n    }\n\n    /**\n     * @return the parent reference or null if the parent is not set\n     * @since 2.2M1\n     */\n    public DocumentReference getParentReference()\n    {\n        // Ensure we always return absolute document references for the parent since we always want well-constructed\n        // references and since we store the parent reference as relative internally.\n        if (this.parentReferenceCache == null && getRelativeParentReference() != null) {\n            this.parentReferenceCache = intern(getExplicitReferenceDocumentReferenceResolver()\n                .resolve(getRelativeParentReference(), getDocumentReference()));\n        }\n\n        return this.parentReferenceCache;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the parent reference stored in the database, which is relative to this document, or an empty string (\"\")\n     *         if the parent is not set\n     * @see #getParentReference()\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getParent()\n    {\n        String parentReferenceAsString;\n        if (getParentReference() != null) {\n            parentReferenceAsString = getDefaultEntityReferenceSerializer().serialize(getRelativeParentReference());\n        } else {\n            parentReferenceAsString = \"\";\n        }\n        return parentReferenceAsString;\n    }\n\n    /**\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument getParentDoc()\n    {\n        return new XWikiDocument(getParentReference());\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setParentReference(EntityReference parentReference)\n    {\n        if (!Objects.equals(getRelativeParentReference(), parentReference)) {\n            this.parentReference = intern(parentReference);\n\n            // Clean the absolute parent reference cache to rebuild it next time getParentReference is called.\n            this.parentReferenceCache = null;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @param parent the reference of the parent relative to the document\n     * @deprecated use {@link #setParentReference(EntityReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setParent(String parent)\n    {\n        // If the passed parent is an empty string we also need to set the reference to null. The reason is that\n        // in the database we store \"\" when the parent is empty and thus when Hibernate loads this class it'll call\n        // setParent with \"\" if the parent had not been set when saved.\n        if (StringUtils.isEmpty(parent)) {\n            setParentReference((EntityReference) null);\n        } else {\n            setParentReference(getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT));\n        }\n    }\n\n    @Override\n    public String getContent()\n    {\n        return this.content;\n    }\n\n    public void setContent(String content)\n    {\n        if (content == null) {\n            content = \"\";\n        }\n\n        boolean notEqual = !content.equals(this.content);\n\n        this.content = content;\n\n        if (notEqual) {\n            // invalidate parsed xdom\n            this.xdomCache = null;\n            setContentDirty(true);\n            setWikiNode(null);\n        }\n    }\n\n    public void setContent(XDOM content) throws XWikiException\n    {\n        setContent(renderXDOM(content, getSyntax()));\n    }\n\n    /**\n     * @return the default rendering cache\n     */\n    private RenderingCache getRenderingCache()\n    {\n        if (this.renderingCache == null) {\n            this.renderingCache = Utils.getComponent((Type) RenderingCache.class);\n        }\n        return this.renderingCache;\n    }\n\n    /**\n     * @return the configured document displayer\n     */\n    private DocumentDisplayer getDocumentDisplayer()\n    {\n        if (this.documentDisplayer == null) {\n            this.documentDisplayer = Utils.getComponent((Type) DocumentDisplayer.class, \"configured\");\n        }\n        return this.documentDisplayer;\n    }\n\n    private Syntax getOutputSyntax()\n    {\n        return getRenderingContext().getTargetSyntax();\n    }\n\n    /**\n     * Parse, execute and render the document.\n     * \n     * @param targetSyntax the syntax to use to render the document\n     * @param executionContextIsolated see {@link DocumentDisplayerParameters#isExecutionContextIsolated()}\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see\n     *            {@link DocumentDisplayerParameters#isTransformationContextRestricted()}\n     * @param translate get translated content of the document\n     * @return the result of the document execution rendered in the passed syntax\n     * @throws XWikiException when failing to display the document\n     */\n    private String display(Syntax targetSyntax, boolean executionContextIsolated, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, boolean translate) throws XWikiException\n    {\n        // Note: We are currently duplicating code from getRendered signature because some calling\n        // code is expecting that the rendering will happen in the calling document's context and not in this\n        // document's context. For example this is true for the Admin page, see\n        // https://jira.xwiki.org/browse/XWIKI-4274 for more details.\n\n        getProgress().startStep(this, \"document.progress.render\", \"Render document [{}] in syntax [{}]\",\n            getDocumentReference(), targetSyntax);\n\n        try {\n            getProgress().pushLevelProgress(3, getDocumentReference());\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.translatedcontent\",\n                \"Get translated content\");\n\n            XWikiContext xcontext = getXWikiContext();\n\n            XWikiDocument tdoc = translate ? getTranslatedDocument(xcontext) : this;\n            String translatedContent = tdoc.getContent();\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.cache\",\n                \"Try to get content from the cache\");\n\n            String renderedContent = getRenderingCache().getRenderedContent(tdoc.getDocumentReferenceWithLocale(),\n                translatedContent, xcontext);\n\n            if (renderedContent == null) {\n                getProgress().startStep(getDocumentReference(), \"document.progress.render.execute\", \"Execute content\");\n\n                // Configure display\n                DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n                parameters.setExecutionContextIsolated(executionContextIsolated);\n                parameters.setTransformationContextIsolated(transformationContextIsolated);\n                parameters.setTransformationContextRestricted(transformationContextRestricted);\n                // Render the translated content (matching the current language) using this document's syntax.\n                parameters.setContentTranslated(tdoc != this);\n                parameters.setTargetSyntax(targetSyntax);\n\n                // Execute display\n                XDOM contentXDOM = getDocumentDisplayer().display(this, parameters);\n\n                // Render the result\n                renderedContent = renderXDOM(contentXDOM, targetSyntax);\n\n                getRenderingCache().setRenderedContent(getDocumentReference(), translatedContent, renderedContent,\n                    xcontext);\n            }\n\n            return renderedContent;\n        } finally {\n            getProgress().popLevelProgress(getDocumentReference());\n            getProgress().endStep(this);\n        }\n    }\n\n    public String getRenderedContent(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, context);\n    }\n\n    /**\n     * @since 8.4RC1\n     */\n    public String getRenderedContent(boolean transformationContextIsolated, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), transformationContextIsolated, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), restricted, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, false, context, false);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(Syntax targetSyntax, boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, restricted, context, false);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     * The translations are retrieved if they exist and based on XWiki preferences\n     * (see {@link #getTranslatedDocument(XWikiContext)}).\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    public String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated, XWikiContext context)\n        throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, transformationContextIsolated, false, context, true);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     *\n     * @param targetSyntax the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @param retrieveTranslation if true retrieve the translation of the document according to the preferences (see\n     *  {@link #getTranslatedDocument(XWikiContext)}). If false, render the current document.\n     * @return the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    private String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, XWikiContext context, boolean retrieveTranslation)\n        throws XWikiException\n    {\n        // Make sure the context secure document is the current document so that it's executed with its own\n        // rights\n        Object currentSdoc = context.get(\"sdoc\");\n        try {\n            XWikiDocument sdoc;\n\n            if (retrieveTranslation) {\n                sdoc = getTranslatedDocument(context);\n            } else {\n                sdoc = this;\n            }\n            context.put(\"sdoc\", sdoc);\n\n            return display(targetSyntax, false, transformationContextIsolated, transformationContextRestricted,\n                retrieveTranslation);\n        } finally {\n            context.put(\"sdoc\", currentSdoc);\n        }\n    }\n\n    public String getRenderedContent(XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 1.6M1\n     */\n    public String getRenderedContent(String text, String syntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            sDocument, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 2.0M3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, restrictedTransformationContext, null, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, XWikiContext context)\n    {\n        try {\n            return getRenderedContent(text, Syntax.valueOf(sourceSyntaxId), Syntax.valueOf(targetSyntaxId),\n                restrictedTransformationContext, sDocument, true, context);\n        } catch (ParseException e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        }\n\n        return \"\";\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, XWikiDocument sDocument, boolean isolated,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), false, sDocument, isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 14.10\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), restrictedTransformationContext, sDocument,\n            isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, Syntax targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        Map<String, Object> backup = null;\n\n        getProgress().startStep(this, \"document.progress.renderText\",\n            \"Execute content [{}] in the context of document [{}]\",\n            StringUtils.substring(text, 0, 100) + (text.length() >= 100 ? \"...\" : \"\"), getDocumentReference());\n\n        XWikiDocument currentSDocument = (XWikiDocument) context.get(CKEY_SDOC);\n        try {\n            // We have to render the given text in the context of this document. Check if this document is already\n            // on the context (same Java object reference). We don't check if the document references are equal\n            // because this document can have temporary changes that are not present on the context document even if\n            // it has the same document reference.\n            if (isolated && context.getDoc() != this) {\n                backup = new HashMap<>();\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute the document with the right of the provided sdocument's author\n            if (sDocument != null) {\n                context.put(CKEY_SDOC, sDocument);\n            }\n\n            // Reuse this document's reference so that the Velocity macro name-space is computed based on it.\n            XWikiDocument fakeDocument = new XWikiDocument(getDocumentReference());\n            fakeDocument.setSyntax(sourceSyntaxId);\n            fakeDocument.setContent(text);\n\n            // We don't let displayer take care of the context isolation because we don't want the fake document to be\n            // context document\n            return fakeDocument.display(targetSyntaxId, false, isolated, restrictedTransformationContext,\n                false);\n        } catch (Exception e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        } finally {\n            if (backup != null) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDocument);\n\n            getProgress().endStep(this);\n        }\n\n        return \"\";\n    }\n\n    public String getEscapedContent(XWikiContext context) throws XWikiException\n    {\n        return XMLUtils.escape(getTranslatedContent(context));\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getName()\n    {\n        return getDocumentReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setName(String name)\n    {\n        if (name != null) {\n            DocumentReference reference = getDocumentReference();\n            // TODO: ensure that other parameters are copied properly\n            setDocumentReferenceInternal(\n                new DocumentReference(name, new SpaceReference(reference.getParent()), reference.getLocale()));\n        }\n    }\n\n    @Override\n    public DocumentReference getDocumentReference()\n    {\n        return this.documentReference;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReference()\n    {\n        if (this.pageReferenceCache == null) {\n            this.pageReferenceCache = intern(getPageReferenceResolver().resolve(getDocumentReference()));\n        }\n\n        return this.pageReferenceCache;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} including the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReferenceWithLocale()\n    {\n        if (this.pageReferenceWithLocaleCache == null) {\n            this.pageReferenceWithLocaleCache = intern(new PageReference(getPageReference(), getLocale()));\n        }\n\n        return this.pageReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the {@link DocumentReference} of the document also containing the document {@link Locale}\n     * @since 5.3M2\n     */\n    public DocumentReference getDocumentReferenceWithLocale()\n    {\n        if (this.documentReferenceWithLocaleCache == null) {\n            this.documentReferenceWithLocaleCache = intern(new DocumentReference(this.documentReference, getLocale()));\n        }\n\n        return this.documentReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the document's space + page name (eg \"space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getFullName()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference());\n    }\n\n    /**\n     * @return the docoument's wiki + space + page name (eg \"wiki:space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getPrefixedFullName()\n    {\n        return getDefaultEntityReferenceSerializer().serialize(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated don't change the reference of a document once it's been constructed. Instead you can\n     *             clone the doc, rename it or copy it.\n     */\n    @Deprecated(since = \"2.2.3\")\n    public void setDocumentReference(DocumentReference reference)\n    {\n        // Don't allow setting a null reference for now, ie. don't do anything to preserve backward compatibility\n        // with previous behavior (i.e. {@link #setFullName}.\n        if (reference != null) {\n            // Retro compatibility, make sure <code>this.documentReference</code> does not contain the Locale (for now)\n            DocumentReference referenceWithoutLocale =\n                reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference;\n\n            if (!referenceWithoutLocale.equals(getDocumentReference())) {\n                setDocumentReferenceInternal(referenceWithoutLocale);\n            }\n        }\n    }\n\n    private void setDocumentReferenceInternal(DocumentReference reference)\n    {\n        this.documentReference = intern(reference);\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.parentReferenceCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String name)\n    {\n        setFullName(name, null);\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String fullName, XWikiContext context)\n    {\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors and to be\n        // consistent with {@link #setName} and {@link #setSpace}.\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            setDocumentReference(getCurrentMixedDocumentReferenceResolver().resolve(fullName));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getWikiName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getWikiName()\n    {\n        return getDatabase();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getSpaceName()\n    {\n        return this.getSpace();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getPageName()\n    {\n        return this.getName();\n    }\n\n    @Override\n    public String getTitle()\n    {\n        return (this.title != null) ? this.title : \"\";\n    }\n\n    /**\n     * Get the rendered version of the document title. The title is extracted and then Velocity is applied on it and\n     * it's then rendered using the passed Syntax. The following logic is used to extract the title:\n     * <ul>\n     * <li>If a Sheet is specified for the document and this Sheet document contains a non empty title then it's\n     * used</li>\n     * <li>If not and the document's title is specified then it's used</li>\n     * <li>If not and if the title compatibility mode is turned on ({@code xwiki.title.compatibility=1} in\n     * {@code xwiki.cfg}) then an attempt is made to extract the title from the first heading found in the document's\n     * content</li>\n     * <li>If not, then at last resort the page name is returned</li>\n     * </ul>\n     *\n     * @param outputSyntax the syntax to render to; this is not taken into account for XWiki 1.0 syntax\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(Syntax outputSyntax, XWikiContext context)\n    {\n        DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n        parameters.setTitleDisplayed(true);\n        parameters.setExecutionContextIsolated(true);\n        parameters.setTargetSyntax(outputSyntax);\n        try {\n            XDOM titleXDOM = getDocumentDisplayer().display(this, parameters);\n            return renderXDOM(titleXDOM, outputSyntax);\n        } catch (Exception e) {\n            // We've failed to extract the Document's title or to render it. We log an error but we use the page name\n            // as the returned title in order to not generate errors in lots of places in the wiki (e.g. Activity\n            // Stream, menus, etc). The title is used in a lots of places...\n            LOGGER.error(\"Failed to render title for [{}]\", getDocumentReference(), e);\n            return getDocumentReference().getName();\n        }\n    }\n\n    /**\n     * Similar to {@link #getRenderedTitle(Syntax, XWikiContext)} but the output Syntax used is XHTML 1.0 unless the\n     * current skin defines another output Syntax in which case it's the one used.\n     *\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(XWikiContext context)\n    {\n        return getRenderedTitle(getOutputSyntax(), context);\n    }\n\n    public void setTitle(String title)\n    {\n        if (title != null && !title.equals(this.title)) {\n            // Document titles usually contain velocity script, so it is not enough to set the metadata dirty, since we\n            // want to content author to be updated for programming or script rights to be updated.\n            setContentDirty(true);\n        }\n        this.title = title;\n    }\n\n    public String getFormat()\n    {\n        return this.format != null ? this.format : \"\";\n    }\n\n    public void setFormat(String format)\n    {\n        if (!format.equals(this.format)) {\n            this.format = format;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link DocumentReference}\n     * @return the user as {@link DocumentReference}\n     */\n    private DocumentReference userStringToReference(String userString)\n    {\n        DocumentReference userReference;\n\n        if (StringUtils.isEmpty(userString)) {\n            userReference = null;\n        } else {\n            userReference = getExplicitReferenceDocumentReferenceResolver().resolve(\n                getXClassEntityReferenceResolver().resolve(userString, EntityType.DOCUMENT), getDocumentReference());\n\n            if (userReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                userReference = null;\n            }\n        }\n\n        return userReference;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(DocumentReference userReference)\n    {\n        String userString;\n\n        if (userReference != null) {\n            userString = getCompactWikiEntityReferenceSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            userString = XWikiRightService.GUEST_USER_FULLNAME;\n        }\n\n        return userString;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(UserReference userReference)\n    {\n        // The user API is missing the concept of relative user references ATM so we're forced to check where the users\n        // are stored in order to make sure user references stored in the database are relative.\n        // See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            // Users are stored as documents. We want the user references that are stored in the database to be relative\n            // as much as possible (because it makes the content portable). For this we omit the wiki reference when the\n            // user (profile document) reference is from the same wiki as this document.\n            return getUserReferenceCompactWikiSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            return getUserReferenceStringSerializer().serialize(userReference);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link UserReference}\n     * @return the user as {@link UserReference}\n     */\n    private UserReference userStringToUserReference(String userString)\n    {\n        // The user API is missing the concept of relative user references ATM so if we want to resolve (partial) user\n        // references that were stored in the database relative to this document then we need to check where the users\n        // are stored. See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            return getUserReferenceStringResolver().resolve(userString, getDocumentReference().getWikiReference());\n        } else {\n            return getUserReferenceStringResolver().resolve(userString);\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getEffectiveMetadataAuthor()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getAuthorReference()\n    {\n        UserReference effectiveMetadataAuthor = getAuthors().getEffectiveMetadataAuthor();\n        if (this.getAuthors().getEffectiveMetadataAuthor() != null\n            && effectiveMetadataAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(effectiveMetadataAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setEffectiveMetadataAuthor(UserReference)}\n     * instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setAuthorReference(DocumentReference authorReference)\n    {\n        if (authorReference == null) {\n            this.authors.setEffectiveMetadataAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (authorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(authorReference);\n            this.authors.setEffectiveMetadataAuthor(user);\n            // We also set the original metadata author for backward compatibility.\n            this.authors.setOriginalMetadataAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated since 3.0M3 use {@link #getAuthorReference()} instead\n     */\n    @Deprecated\n    public String getAuthor()\n    {\n        return userReferenceToString(getAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setAuthor(String author)\n    {\n        setAuthorReference(userStringToReference(author));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getContentAuthor()} instead\n     */\n    @Override\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getContentAuthorReference()\n    {\n        UserReference contentAuthor = this.getAuthors().getContentAuthor();\n        if (contentAuthor != null && contentAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(contentAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setContentAuthor(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setContentAuthorReference(DocumentReference contentAuthorReference)\n    {\n        if (contentAuthorReference == null) {\n            this.authors.setContentAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (contentAuthorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(contentAuthorReference);\n            this.authors.setContentAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getContentAuthorReference()} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public String getContentAuthor()\n    {\n        return userReferenceToString(getContentAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setContentAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setContentAuthor(String contentAuthor)\n    {\n        setContentAuthorReference(userStringToReference(contentAuthor));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getCreator()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getCreatorReference()\n    {\n        UserReference creator = this.getAuthors().getCreator();\n        if (creator != null && creator != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(creator);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setCreator(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setCreatorReference(DocumentReference creatorReference)\n    {\n        if (creatorReference == null) {\n            this.authors.setCreator(GuestUserReference.INSTANCE);\n        } else {\n            if (creatorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(creatorReference);\n            this.authors.setCreator(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getCreatorReference()} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public String getCreator()\n    {\n        return userReferenceToString(getCreatorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setCreatorReference} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public void setCreator(String creator)\n    {\n        setCreatorReference(userStringToReference(creator));\n    }\n\n    @Override\n    public Date getDate()\n    {\n        if (this.updateDate == null) {\n            return new Date();\n        } else {\n            return this.updateDate;\n        }\n    }\n\n    public void setDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.updateDate))) {\n            setMetaDataDirty(true);\n        }\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.updateDate = date;\n    }\n\n    @Override\n    public Date getCreationDate()\n    {\n        if (this.creationDate == null) {\n            return new Date();\n        } else {\n            return this.creationDate;\n        }\n    }\n\n    public void setCreationDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.creationDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.creationDate = date;\n    }\n\n    public Date getContentUpdateDate()\n    {\n        if (this.contentUpdateDate == null) {\n            return new Date();\n        } else {\n            return this.contentUpdateDate;\n        }\n    }\n\n    public void setContentUpdateDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.contentUpdateDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.contentUpdateDate = date;\n    }\n\n    public String getMeta()\n    {\n        return this.meta;\n    }\n\n    public void setMeta(String meta)\n    {\n        if (meta == null) {\n            if (this.meta != null) {\n                setMetaDataDirty(true);\n            }\n        } else if (!meta.equals(this.meta)) {\n            setMetaDataDirty(true);\n        }\n        this.meta = meta;\n    }\n\n    public void appendMeta(String meta)\n    {\n        StringBuilder buf = new StringBuilder(this.meta);\n        buf.append(meta);\n        buf.append(\"\\n\");\n        this.meta = buf.toString();\n        setMetaDataDirty(true);\n    }\n\n    public boolean isContentDirty()\n    {\n        return this.isContentDirty;\n    }\n\n    /**\n     * Increment the current document version.\n     * This method will use {@link #getNextVersion(Version, boolean)} to compute the new version.\n     */\n    public void incrementVersion()\n    {\n        this.version = getNextVersion(this.version, isMinorEdit());\n    }\n\n    /**\n     * This method computes the next version and returns it, but won't change the current version.\n     * In order to change the current version, see {@link #incrementVersion()}.\n     *\n     * @param version the based version from which to compute the next one.\n     * @param minorEdit true means it's a minor edition.\n     * @return the new version computed based on the current one.\n     * @since 11.2RC1\n     */\n    public static Version getNextVersion(Version version, boolean minorEdit)\n    {\n        if (version == null) {\n            return new Version(\"1.1\");\n        }\n        if (minorEdit) {\n            return version.next();\n        } else {\n            return version.getBranchPoint().next().newBranch(1);\n        }\n    }\n\n    public void setContentDirty(boolean contentDirty)\n    {\n        this.isContentDirty = contentDirty;\n    }\n\n    public boolean isMetaDataDirty()\n    {\n        return this.isMetaDataDirty;\n    }\n\n    public void setMetaDataDirty(boolean metaDataDirty)\n    {\n        this.isMetaDataDirty = metaDataDirty;\n    }\n\n    public String getAttachmentURL(String filename, XWikiContext context)\n    {\n        return getAttachmentURL(filename, \"download\", context);\n    }\n\n    public String getAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        return getAttachmentURL(filename, action, null, context);\n    }\n\n    public String getExternalAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createAttachmentURL(filename, getSpace(), getName(), action, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getAttachmentURL(String filename, String action, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentURL(new AttachmentReference(filename, this.getDocumentReference()),\n            action, querystring, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, XWikiContext context)\n    {\n        return getAttachmentRevisionURL(filename, revision, null, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentRevisionURL(new AttachmentReference(filename, getDocumentReference()),\n            revision, querystring, context);\n    }\n\n    /**\n     * @param action the action, see the {@code struts-config.xml} file for a list of all existing action names\n     * @param params the URL query string\n     * @param redirect true if the URL is going to be used in {@link HttpServletResponse#sendRedirect(String)}\n     * @param context the XWiki context\n     * @return the URL\n     */\n    public String getURL(String action, String params, boolean redirect, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, params, null, getDatabase(), context);\n\n        if (redirect && isRedirectAbsolute(context)) {\n            if (url == null) {\n                return null;\n            } else {\n                return url.toString();\n            }\n        } else {\n            return context.getURLFactory().getURL(url, context);\n        }\n    }\n\n    private boolean isRedirectAbsolute(XWikiContext context)\n    {\n        return StringUtils.equals(\"1\", context.getWiki().Param(\"xwiki.redirect.absoluteurl\"));\n    }\n\n    public String getURL(String action, boolean redirect, XWikiContext context)\n    {\n        return getURL(action, null, redirect, context);\n    }\n\n    public String getURL(String action, XWikiContext context)\n    {\n        return getURL(action, false, context);\n    }\n\n    public String getURL(String action, String querystring, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, querystring, null, getDatabase(), context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getURL(String action, String querystring, String anchor, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createURL(getSpace(), getName(), action, querystring, anchor, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getExternalURL(String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, null, null, getDatabase(),\n            context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String action, String querystring, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, querystring, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getParentURL(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getParentReference());\n        URL url = context.getURLFactory().createURL(doc.getSpace(), doc.getName(), \"view\", null, null, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public XWikiDocumentArchive getDocumentArchive(XWikiContext context) throws XWikiException\n    {\n        loadArchive(context);\n        return getDocumentArchive();\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClassName the name of the custom {@link com.xpn.xwiki.api.Document} class of the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(String customClassName, XWikiContext context)\n    {\n        if (!((customClassName == null) || (customClassName.equals(\"\")))) {\n            try {\n                return newDocument(Class.forName(customClassName), context);\n            } catch (ClassNotFoundException e) {\n                LOGGER.error(\"Failed to get java Class object from class name\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClass the custom {@link com.xpn.xwiki.api.Document} class the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(Class<?> customClass, XWikiContext context)\n    {\n        if (customClass != null) {\n            try {\n                Class<?>[] classes = new Class[] { XWikiDocument.class, XWikiContext.class };\n                Object[] args = new Object[] { this, context };\n\n                return (com.xpn.xwiki.api.Document) customClass.getConstructor(classes).newInstance(args);\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to create a custom Document object\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    public com.xpn.xwiki.api.Document newDocument(XWikiContext context)\n    {\n        String customClass = getCustomClass();\n        return newDocument(customClass, context);\n    }\n\n    public void loadArchive(XWikiContext context) throws XWikiException\n    {\n        if ((this.archive == null || this.archive.get() == null)) {\n            XWikiDocumentArchive arch;\n            // A document not comming from the database cannot have an archive stored in the database\n            if (this.isNew()) {\n                arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            } else {\n                arch = getVersioningStore(context).getXWikiDocumentArchive(this, context);\n            }\n            // We are using a SoftReference which will allow the archive to be\n            // discarded by the Garbage collector as long as the context is closed (usually during\n            // the request)\n            this.archive = new SoftReference<>(arch);\n        }\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, null is\n     *         returned.\n     */\n    public XWikiDocumentArchive getDocumentArchive()\n    {\n        // If there is a soft reference, return it.\n        if (this.archive != null) {\n            return this.archive.get();\n        }\n        // Some APIs are expecting the archive to be null for loading it\n        // (e.g. VersioningStore#loadXWikiDocumentArchive), so it's better to keep it null than to return an\n        // empty archive which would never be populated.\n        return null;\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, we get it using\n     *         the current context. If there is an exception, null is returned.\n     */\n    public XWikiDocumentArchive loadDocumentArchive()\n    {\n        XWikiDocumentArchive arch = getDocumentArchive();\n        if (arch != null) {\n            return arch;\n        }\n\n        // A document not comming from the database cannot have an archive stored in the database\n        if (this.isNew()) {\n            arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            setDocumentArchive(arch);\n            return arch;\n        }\n\n        XWikiContext xcontext = getXWikiContext();\n\n        try {\n            arch = getVersioningStore(xcontext).getXWikiDocumentArchive(this, xcontext);\n\n            // Put a copy of the archive in the soft reference for later use if needed.\n            setDocumentArchive(arch);\n\n            return arch;\n        } catch (Exception e) {\n            // VersioningStore.getXWikiDocumentArchive may throw an XWikiException, and xcontext or VersioningStore\n            // may be null (tests)\n            // To maintain the behavior of this method we can't throw an exception.\n            // Formerly, null was returned if there was no SoftReference.\n            LOGGER.warn(\"Could not get document archive\", e);\n            return null;\n        }\n    }\n\n    public void setDocumentArchive(XWikiDocumentArchive arch)\n    {\n        // We are using a SoftReference which will allow the archive to be\n        // discarded by the Garbage collector as long as the context is closed (usually during the\n        // request)\n        if (arch != null) {\n            this.archive = new SoftReference<XWikiDocumentArchive>(arch);\n        } else {\n            // Some APIs are expecting the archive to be null for loading it\n            // (e.g. VersioningStore#loadXWikiDocumentArchive), so we allow setting it back to null.\n            this.archive = null;\n        }\n    }\n\n    public void setDocumentArchive(String sarch) throws XWikiException\n    {\n        XWikiDocumentArchive xda = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n        xda.setArchive(sarch);\n        setDocumentArchive(xda);\n    }\n\n    public Version[] getRevisions(XWikiContext context) throws XWikiException\n    {\n        return getVersioningStore(context).getXWikiDocVersions(this, context);\n    }\n\n    public String[] getRecentRevisions(int nb, XWikiContext context) throws XWikiException\n    {\n        try {\n            Version[] revisions = getVersioningStore(context).getXWikiDocVersions(this, context);\n            int length = nb;\n            // 0 means all revisions\n            if (nb == 0) {\n                length = revisions.length;\n            }\n\n            if (revisions.length < length) {\n                length = revisions.length;\n            }\n\n            String[] recentrevs = new String[length];\n            for (int i = 1; i <= length; i++) {\n                recentrevs[i - 1] = revisions[revisions.length - i].toString();\n            }\n            return recentrevs;\n        } catch (Exception e) {\n            return new String[0];\n        }\n    }\n\n    /**\n     * Get document versions matching criterias like author, minimum creation date, etc.\n     *\n     * @param criteria criteria used to match versions\n     * @return a list of matching versions\n     */\n    public List<String> getRevisions(RevisionCriteria criteria, XWikiContext context) throws XWikiException\n    {\n        List<String> results = new ArrayList<String>();\n\n        Version[] revisions = getRevisions(context);\n\n        XWikiRCSNodeInfo nextNodeinfo = null;\n        XWikiRCSNodeInfo nodeinfo;\n        for (Version revision : revisions) {\n            nodeinfo = nextNodeinfo;\n            nextNodeinfo = getRevisionInfo(revision.toString(), context);\n\n            if (nodeinfo == null) {\n                continue;\n            }\n\n            // Minor/Major version matching\n            if (criteria.getIncludeMinorVersions() || !nextNodeinfo.isMinorEdit()) {\n                // Author matching\n                if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                    // Date range matching\n                    Date versionDate = nodeinfo.getDate();\n                    if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                        results.add(nodeinfo.getVersion().toString());\n                    }\n                }\n            }\n        }\n\n        nodeinfo = nextNodeinfo;\n        if (nodeinfo != null) {\n            if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                // Date range matching\n                Date versionDate = nodeinfo.getDate();\n                if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                    results.add(nodeinfo.getVersion().toString());\n                }\n            }\n        }\n\n        return criteria.getRange().subList(results);\n    }\n\n    public XWikiRCSNodeInfo getRevisionInfo(String version, XWikiContext context) throws XWikiException\n    {\n        return getDocumentArchive(context).getNode(new Version(version));\n    }\n\n    /**\n     * @return Is this version the most recent one. False if and only if there are newer versions of this document in\n     *         the database.\n     */\n    public boolean isMostRecent()\n    {\n        return this.mostRecent;\n    }\n\n    /**\n     * must not be used unless in store system.\n     *\n     * @param mostRecent - mark document as most recent.\n     */\n    public void setMostRecent(boolean mostRecent)\n    {\n        this.mostRecent = mostRecent;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseClass getXClass()\n    {\n        if (this.xClass == null) {\n            BaseClass emptyClass = new BaseClass();\n            // Make sure not to cause any false document versions if this document is saved.\n            emptyClass.setDirty(false);\n\n            this.setXClass(emptyClass);\n        }\n        return this.xClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClass(BaseClass xwikiClass)\n    {\n        xwikiClass.setOwnerDocument(this);\n\n        this.xClass = xwikiClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public Map<DocumentReference, List<BaseObject>> getXObjects()\n    {\n        return (Map) this.publicXObjects;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(Map<DocumentReference, List<BaseObject>> objects)\n    {\n        if (objects == null) {\n            // Make sure we don`t set a null objects map since we assume everywhere that it is not null when using it.\n            objects = new HashMap<>();\n        }\n\n        boolean isDirty = false;\n\n        for (List<BaseObject> objList : objects.values()) {\n            for (BaseObject obj : objList) {\n                obj.setOwnerDocument(this);\n                isDirty = true;\n            }\n        }\n\n        // This operation resulted in marking the current document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n\n        // Replace the current objects with the provided ones.\n        Map<DocumentReference, BaseObjects> objectsCopy = new ConcurrentSkipListMap<>();\n        objects.forEach((k, v) -> objectsCopy.put(k, new BaseObjects(v)));\n        this.xObjects = objectsCopy;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @deprecated use {@link #getXObject()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getxWikiObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public List<BaseClass> getXClasses(XWikiContext context)\n    {\n        List<BaseClass> list = new ArrayList<BaseClass>();\n\n        // getXObjects() is a TreeMap, with elements sorted by className reference\n        for (DocumentReference classReference : getXObjects().keySet()) {\n            BaseClass bclass = null;\n            List<BaseObject> objects = getXObjects(classReference);\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        break;\n                    }\n                }\n            }\n            if (bclass != null) {\n                list.add(bclass);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Create and add a new object to the document with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the index of teh newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public int createXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject object = BaseClass.newCustomClassInstance(absoluteClassReference, context);\n        object.setOwnerDocument(this);\n        object.setXClassReference(classReference);\n        BaseObjects objects = this.xObjects.get(absoluteClassReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(absoluteClassReference, objects);\n        }\n        objects.add(object);\n        int nb = objects.size() - 1;\n        object.setNumber(nb);\n        setMetaDataDirty(true);\n        return nb;\n    }\n\n    /**\n     * @deprecated use {@link #createXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int createNewObject(String className, XWikiContext context) throws XWikiException\n    {\n        return createXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public int getXObjectSize(DocumentReference classReference)\n    {\n        try {\n            return getXObjects().get(classReference).size();\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n\n    /**\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public int getXObjectSize(EntityReference classReference)\n    {\n        return getXObjectSize(resolveClassReference(classReference));\n    }\n\n    /**\n     * @deprecated use {@link #getXObjectSize(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int getObjectNumbers(String className)\n    {\n        return getXObjectSize(resolveClassReference(className));\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the given class reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param classReference the reference of the xclass for which to retrieve the xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *          or an empty list.\n     * @since 2.2M1\n     */\n    public List<BaseObject> getXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> xobjects = null;\n\n        if (classReference != null) {\n            xobjects = getXObjects().get(classReference);\n        }\n\n        return xobjects != null ? xobjects : Collections.emptyList();\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the class reference corresponding to the resolution of the\n     * given entity reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param reference the reference that is resolved to an xclass for retrieving the corresponding xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *           or an empty list.\n     * @since 3.3M1\n     */\n    public List<BaseObject> getXObjects(EntityReference reference)\n    {\n        if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObjects(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * @deprecated use {@link #getXObjects(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public Vector<BaseObject> getObjects(String className)\n    {\n        List<BaseObject> result = this.xObjects.get(resolveClassReference(className));\n        return result == null ? null : new Vector<BaseObject>(result);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(DocumentReference classReference, List<BaseObject> objects)\n    {\n        // Remove existing objects\n        List<BaseObject> existingbjects = this.xObjects.get(classReference);\n        if (existingbjects != null) {\n            existingbjects.clear();\n        }\n\n        for (BaseObject obj : objects) {\n            obj.setOwnerDocument(this);\n        }\n\n        // Add new objects\n        this.xObjects.put(classReference, new BaseObjects(objects));\n\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @since 3.3M1\n     */\n    public BaseObject getXObject(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        } else if (reference.getType() == EntityType.OBJECT) {\n            // object reference\n            return getXObject(getCurrentReferenceObjectReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference)\n    {\n        BaseObject result = null;\n        List<BaseObject> objects = getXObjects().get(classReference);\n        if (objects != null) {\n            for (BaseObject object : objects) {\n                if (object != null) {\n                    result = object;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get an object of this document based on its reference.\n     *\n     * @param objectReference the reference of the object\n     * @return the XWiki object\n     * @since 3.2M1\n     */\n    public BaseObject getXObject(ObjectReference objectReference)\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        return baseObjectReference.getObjectNumber() == null ? this.getXObject(baseObjectReference.getXClassReference())\n            : getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber());\n    }\n\n    /**\n     * Get or create an object of this document based on its reference.\n     *\n     * @param objectReference The reference of the object.\n     * @param create If the object shall be created if missing.\n     * @param context The XWiki context for creating the object.\n     * @return The found or created objected.\n     * @throws XWikiException If object creation failed.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public BaseObject getXObject(ObjectReference objectReference, boolean create, XWikiContext context)\n        throws XWikiException\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        if (baseObjectReference.getObjectNumber() == null) {\n            return getXObject(baseObjectReference.getXClassReference(), create, context);\n        } else {\n            return getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber(), create,\n                context);\n        }\n    }\n\n    /**\n     * Convert the given {@link ObjectReference} into a {@link BaseObjectReference}.\n     */\n    private BaseObjectReference getBaseObjectReference(ObjectReference objectReference)\n    {\n        if (objectReference instanceof BaseObjectReference) {\n            return (BaseObjectReference) objectReference;\n        } else {\n            return new BaseObjectReference(objectReference);\n        }\n    }\n\n    /**\n     * Get an object property of this document based on its reference.\n     *\n     * @param objectPropertyReference the reference of the object property\n     * @return the object property\n     * @since 3.2M3\n     */\n    public BaseProperty<ObjectPropertyReference> getXObjectProperty(ObjectPropertyReference objectPropertyReference)\n    {\n        BaseObject object = getXObject((ObjectReference) objectPropertyReference.getParent());\n\n        if (object != null) {\n            return (BaseProperty<ObjectPropertyReference>) object.getField(objectPropertyReference.getName());\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className)\n    {\n        return getXObject(resolveClassReference(className));\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, int nb)\n    {\n        List<BaseObject> objects = getXObjects().get(classReference);\n\n        if (objects != null && objects.size() > nb) {\n            return objects.get(nb);\n        }\n\n        return null;\n    }\n\n    /**\n     * Get an xobject with the passed xclass at the passed location.\n     * <p>\n     * If <code>create</code> is true and the is no xobject at the passed located, it's created.\n     *\n     * @param classReference the xlcass of the object to retrieve\n     * @param number the location of the xobject\n     * @param create if true the xobject is created when it does not exist\n     * @param xcontext the XWiki context\n     * @return a {@link BaseObject} stored at passed location\n     * @throws XWikiException when failing to create new xobject instance\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public BaseObject getXObject(EntityReference classReference, int number, boolean create, XWikiContext xcontext)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n\n        BaseObject xobject = getXObject(absoluteClassReference, number);\n\n        if (xobject == null && create) {\n            xobject = BaseClass.newCustomClassInstance(absoluteClassReference, xcontext);\n\n            setXObject(number, xobject);\n        }\n\n        return xobject;\n    }\n\n    /**\n     * @since 4.1M1\n     */\n    public BaseObject getXObject(EntityReference classReference, int nb)\n    {\n        return getXObject(\n            getCurrentReferenceDocumentReferenceResolver().resolve(classReference, getDocumentReference()), nb);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, int)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, int nb)\n    {\n        return getXObject(resolveClassReference(className), nb);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value)\n    {\n        return getXObject(classReference, key, value, false);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value)\n    {\n        return getObject(className, key, value, false);\n    }\n\n    /**\n     * @return 6.3M1\n     */\n    public BaseObject getXObject(EntityReference reference, String key, String value, boolean failover)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference, key, value, failover);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()),\n                key, value, failover);\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value, boolean failover)\n    {\n        try {\n            if (value == null) {\n                if (failover) {\n                    return getXObject(classReference);\n                } else {\n                    return null;\n                }\n            }\n\n            List<BaseObject> objects = getXObjects().get(classReference);\n            if ((objects == null) || (objects.size() == 0)) {\n                return null;\n            }\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    if (value.equals(obj.getStringValue(key))) {\n                        return obj;\n                    }\n                }\n            }\n\n            if (failover) {\n                return getXObject(classReference);\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            if (failover) {\n                return getXObject(classReference);\n            }\n\n            LOGGER.warn(\"Exception while accessing objects for document [{}]: {}\", getDocumentReference(),\n                e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String, boolean)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value, boolean failover)\n    {\n        return getXObject(resolveClassReference(className), key, value, failover);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated\n    public void addXObject(DocumentReference classReference, BaseObject object)\n    {\n        List<BaseObject> vobj = this.xObjects.get(classReference);\n        if (vobj == null) {\n            setXObject(classReference, 0, object);\n        } else {\n            setXObject(classReference, vobj.size(), object);\n        }\n    }\n\n    /**\n     * Add the object to the document.\n     *\n     * @param object the xobject to add\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void addXObject(BaseObject object)\n    {\n        object.setOwnerDocument(this);\n\n        List<BaseObject> vobj = this.xObjects.get(object.getXClassReference());\n        if (vobj == null) {\n            setXObject(0, object);\n        } else {\n            setXObject(vobj.size(), object);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void addObject(String className, BaseObject object)\n    {\n        addXObject(resolveClassReference(className), object);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #setXObject(int, BaseObject)} instead\n     */\n    @Deprecated\n    public void setXObject(DocumentReference classReference, int nb, BaseObject object)\n    {\n        if (object != null) {\n            object.setOwnerDocument(this);\n            object.setNumber(nb);\n        }\n\n        BaseObjects objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(classReference, objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Replaces the object at the specified position and for the specified object's xclass.\n     *\n     * @param nb index of the element to replace\n     * @param object the xobject to insert\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void setXObject(int nb, BaseObject object)\n    {\n        object.setOwnerDocument(this);\n        object.setNumber(nb);\n\n        BaseObjects objects = this.xObjects.get(object.getXClassReference());\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(object.getXClassReference(), objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #setXObject(DocumentReference, int, BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setObject(String className, int nb, BaseObject object)\n    {\n        setXObject(resolveClassReference(className), nb, object);\n    }\n\n    /**\n     * @return true if the document is a new one (i.e. it has never been saved) or false otherwise\n     */\n    public boolean isNew()\n    {\n        return this.isNew;\n    }\n\n    public void setNew(boolean aNew)\n    {\n        this.isNew = aNew;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXClass(XWikiDocument templatedoc)\n    {\n        BaseClass bclass = getXClass();\n        BaseClass tbclass = templatedoc.getXClass();\n        if (tbclass != null) {\n            if (bclass == null) {\n                setXClass(tbclass.clone());\n            } else {\n                getXClass().merge(tbclass.clone());\n            }\n        }\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #mergeXClass(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiClass(XWikiDocument templatedoc)\n    {\n        mergeXClass(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXObjects(XWikiDocument templateDoc)\n    {\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templateDoc.getXObjects().entrySet()) {\n            // Documents can't have objects of types defined in a different wiki so we make sure the class reference\n            // matches this document's wiki.\n            DocumentReference classReference = entry.getKey().replaceParent(entry.getKey().getWikiReference(),\n                getDocumentReference().getWikiReference());\n            // Copy the objects from the template document only if this document doesn't have them already.\n            //\n            // Note: this might be a bit misleading since it will not add objects from the template if some objects of\n            // that class already exist in the current document.\n            if (getXObjectSize(classReference) == 0) {\n                for (BaseObject object : entry.getValue()) {\n                    if (object != null) {\n                        addXObject(object.duplicate());\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #mergeXObjects(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiObjects(XWikiDocument templatedoc)\n    {\n        mergeXObjects(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void cloneXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, true);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void duplicateXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, false);\n    }\n\n    /**\n     * Copy specified document objects into current document.\n     *\n     * @param templatedoc the document to copy\n     * @param keepsIdentity if true it does an exact java copy, otherwise it duplicate objects with the new document\n     *            name (and new class names)\n     */\n    private void cloneXObjects(XWikiDocument templatedoc, boolean keepsIdentity)\n    {\n        // clean map\n        this.xObjects.clear();\n\n        // fill map\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templatedoc.getXObjects().entrySet()) {\n            List<BaseObject> tobjects = entry.getValue();\n\n            // clone and insert xobjects\n            for (BaseObject otherObject : tobjects) {\n                if (otherObject != null) {\n                    if (keepsIdentity) {\n                        addXObject(otherObject.clone());\n                    } else {\n                        BaseObject newObject = otherObject.duplicate(getDocumentReference());\n                        setXObject(newObject.getNumber(), newObject);\n                    }\n                } else if (keepsIdentity) {\n                    // set null object to make sure to have exactly the same thing when cloning a document\n                    addXObject(entry.getKey(), null);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public DocumentReference getTemplateDocumentReference()\n    {\n        return this.templateDocumentReference;\n    }\n\n    /**\n     * @deprecated use {@link #getTemplateDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getTemplate()\n    {\n        String templateReferenceAsString;\n        DocumentReference templateDocumentReference = getTemplateDocumentReference();\n        if (templateDocumentReference != null) {\n            templateReferenceAsString = LOCAL_REFERENCE_SERIALIZER.serialize(templateDocumentReference);\n        } else {\n            templateReferenceAsString = \"\";\n        }\n        return templateReferenceAsString;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setTemplateDocumentReference(DocumentReference templateDocumentReference)\n    {\n        if (!Objects.equals(getTemplateDocumentReference(), templateDocumentReference)) {\n            this.templateDocumentReference = templateDocumentReference;\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #setTemplateDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setTemplate(String template)\n    {\n        DocumentReference templateReference = null;\n        if (!StringUtils.isEmpty(template)) {\n            templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n        }\n        setTemplateDocumentReference(templateReference);\n    }\n\n    public String displayPrettyName(String fieldname, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayPrettyName(fieldname, showMandatory, before, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayPrettyName(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, BaseObject obj,\n        XWikiContext context)\n    {\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String dprettyName = \"\";\n            if (showMandatory) {\n                dprettyName = context.getWiki().addMandatory(context);\n            }\n            if (before) {\n                return dprettyName + pclass.getPrettyName(context);\n            } else {\n                return pclass.getPrettyName(context) + dprettyName;\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayTooltip(fieldname, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String tooltip = pclass.getTooltip(context);\n            if ((tooltip != null) && (!tooltip.trim().equals(\"\"))) {\n                String img = \"<img src=\\\"\" + context.getWiki().getSkinFile(\"info.gif\", context)\n                    + \"\\\" class=\\\"tooltip_image\\\" align=\\\"middle\\\" />\";\n                result = context.getWiki().addTooltip(img, tooltip, context);\n            }\n        } catch (Exception e) {\n\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n\n            result = display(fieldname, object, context);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to display field [\" + fieldname + \"] of document [\"\n                + getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) + \"]\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String type = null;\n        try {\n            type = (String) context.get(\"display\");\n        } catch (Exception e) {\n        }\n\n        if (type == null) {\n            type = \"view\";\n        }\n\n        return display(fieldname, type, obj, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, XWikiContext context)\n    {\n        return display(fieldname, mode, \"\", context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, BaseObject obj, boolean isolated, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param prefix the prefix to add in the field identifier in edit display for example\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, String prefix, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            if (object == null) {\n                return \"\";\n            } else {\n                return display(fieldname, mode, prefix, object, context);\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, String wrappingSyntaxId, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, wrappingSyntaxId, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, boolean isolated,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj,\n            context.getWiki().getCurrentContentSyntaxId(getSyntaxId(), context), isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, wrappingSyntaxId, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html or { which could be part of an XWiki\n            // macro syntax since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId)\n                && (HTMLUtils.containsElementText(result) || result.indexOf(\"{\") != -1))\n            {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                // Escape closing HTML macro syntax.\n                int startIndex = 0;\n                // Start searching at the last match to avoid scanning the whole string again.\n                while ((startIndex = result.indexOf(CLOSE_HTML_MACRO, startIndex)) != -1) {\n                    result.replace(startIndex, startIndex + 2, \"&#123;&#123;\");\n                }\n                result.append(CLOSE_HTML_MACRO);\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, XWikiContext context)\n    {\n        return displayForm(classReference, header, format, true, context);\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, XWikiContext context)\n    {\n        return displayForm(className, header, format, true, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, boolean linebreak,\n        XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (format.endsWith(\"\\\\n\")) {\n            linebreak = true;\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        VelocityContext vcontext;\n        try {\n            vcontext = getVelocityContextFactory().createContext();\n        } catch (XWikiVelocityException e) {\n            LOGGER.error(\"Failed to create a standard VelocityContext\", e);\n\n            vcontext = new XWikiVelocityContext();\n        }\n\n        for (String propertyName : bclass.getPropertyList()) {\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            vcontext.put(pclass.getName(), pclass.getPrettyName());\n        }\n        result.append(evaluate(header, context.getDoc().getPrefixedFullName(), vcontext, context));\n        if (linebreak) {\n            result.append(\"\\n\");\n        }\n\n        // display each line\n        for (int i = 0; i < objects.size(); i++) {\n            vcontext.put(\"id\", Integer.valueOf(i + 1));\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                for (String name : bclass.getPropertyList()) {\n                    vcontext.put(name, display(name, object, context));\n                }\n                result.append(evaluate(format, context.getDoc().getPrefixedFullName(), vcontext, context));\n                if (linebreak) {\n                    result.append(\"\\n\");\n                }\n            }\n        }\n        return result.toString();\n    }\n\n    private String evaluate(String content, String name, VelocityContext vcontext, XWikiContext context)\n    {\n        StringWriter writer = new StringWriter();\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, name, content);\n            return writer.toString();\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}]\", name, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, boolean linebreak, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), header, format, linebreak, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (objects == null) {\n            return \"\";\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        result.append(\"{table}\\n\");\n        boolean first = true;\n        for (String propertyName : bclass.getPropertyList()) {\n            if (first == true) {\n                first = false;\n            } else {\n                result.append(\"|\");\n            }\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            result.append(pclass.getPrettyName());\n        }\n        result.append(\"\\n\");\n        for (int i = 0; i < objects.size(); i++) {\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                first = true;\n                for (String propertyName : bclass.getPropertyList()) {\n                    if (first == true) {\n                        first = false;\n                    } else {\n                        result.append(\"|\");\n                    }\n                    String data = display(propertyName, object, context);\n                    data = data.trim();\n                    data = data.replaceAll(\"\\n\", \" \");\n                    if (data.length() == 0) {\n                        result.append(\"&nbsp;\");\n                    } else {\n                        result.append(data);\n                    }\n                }\n                result.append(\"\\n\");\n            }\n        }\n        result.append(\"{table}\\n\");\n        return result.toString();\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), context);\n    }\n\n    public boolean isFromCache()\n    {\n        return this.fromCache;\n    }\n\n    public void setFromCache(boolean fromCache)\n    {\n        this.fromCache = fromCache;\n    }\n\n    public void readDocMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String defaultLanguage = eform.getDefaultLanguage();\n        if (defaultLanguage != null) {\n            setDefaultLanguage(defaultLanguage);\n        }\n\n        String defaultTemplate = eform.getDefaultTemplate();\n        if (defaultTemplate != null) {\n            setDefaultTemplate(defaultTemplate);\n        }\n\n        String creator = eform.getCreator();\n        if ((creator != null) && (!creator.equals(getCreator()))) {\n            if ((getCreatorReference().equals(context.getUserReference()))\n                || (context.getWiki().getRightService().hasAdminRights(context))) {\n                setCreator(creator);\n            }\n        }\n\n        String parent = eform.getParent();\n        if (parent != null) {\n            setParent(parent);\n        }\n\n        // Read the comment from the form\n        String comment = eform.getComment();\n        if (comment != null) {\n            setComment(comment);\n        }\n\n        // Read the minor edit checkbox from the form\n        setMinorEdit(eform.isMinorEdit());\n\n        String tags = eform.getTags();\n        if (!StringUtils.isEmpty(tags)) {\n            setTags(tags, context);\n        }\n\n        // Set the Syntax id if defined\n        String syntaxId = eform.getSyntaxId();\n        if (syntaxId != null) {\n            setSyntax(resolveSyntax(syntaxId));\n        }\n\n        // Read the hidden checkbox from the form\n        if (eform.getHidden() != null) {\n            setHidden(\"1\".equals(eform.getHidden()));\n        }\n    }\n\n    private Syntax resolveSyntax(String syntaxId)\n    {\n        Syntax syntax;\n        try {\n            syntax = getSyntaxRegistry().resolveSyntax(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntax();\n            LOGGER.warn(\"Failed to set syntax [{}] for [{}], setting syntax [{}] instead.\", syntaxId,\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()), syntax.toIdString(), e);\n        }\n        return syntax;\n    }\n\n    /**\n     * add tags to the document.\n     */\n    public void setTags(String tagsStr, XWikiContext context) throws XWikiException\n    {\n        BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n        StaticListClass tagProp = (StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS);\n\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS, true, context);\n\n        tags.safeput(XWikiConstant.TAG_CLASS_PROP_TAGS, tagProp.fromString(tagsStr));\n\n        setMetaDataDirty(true);\n    }\n\n    public String getTags(XWikiContext context)\n    {\n        ListProperty prop = (ListProperty) getTagProperty(context);\n\n        // I don't know why we need to XML-escape the list of tags but for backwards compatibility we need to keep doing\n        // this. When this method was added it was using ListProperty#getTextValue() which used to return\n        // ListProperty#toFormString() before we fixed it to return the unescaped value because we need to save the raw\n        // value in the database and ListProperty#getTextValue() is called when the list property is saved.\n        return prop != null ? prop.toFormString() : \"\";\n    }\n\n    public List<String> getTagsList(XWikiContext context)\n    {\n        List<String> tagList = null;\n\n        BaseProperty prop = getTagProperty(context);\n        if (prop != null) {\n            tagList = (List<String>) prop.getValue();\n        }\n\n        return tagList;\n    }\n\n    private BaseProperty getTagProperty(XWikiContext context)\n    {\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS);\n\n        return tags != null ? ((BaseProperty) tags.safeget(XWikiConstant.TAG_CLASS_PROP_TAGS)) : null;\n    }\n\n    public List<String> getTagsPossibleValues(XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n            String possibleValues =\n                ((StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS)).getValues();\n\n            return ListClass.getListFromString(possibleValues);\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to get tag class\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    public void readTranslationMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String content = eform.getContent();\n        if (content != null) {\n            // Cleanup in case we use HTMLAREA\n            // content = context.getUtil().substitute(\"s/<br class=\\\\\\\"htmlarea\\\\\\\"\\\\/>/\\\\r\\\\n/g\",\n            // content);\n            content = context.getUtil().substitute(\"s/<br class=\\\"htmlarea\\\" \\\\/>/\\r\\n/g\", content);\n            setContent(content);\n        }\n        String title = eform.getTitle();\n        if (title != null) {\n            setTitle(title);\n        }\n    }\n\n    /**\n     * Updates properties of existing objects with the values from the given form.\n     *\n     * @param eform The form to read the values from\n     * @param context The context used for getting the classes of objects\n     * @throws XWikiException On errors\n     */\n    public void readObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        for (DocumentReference reference : getXObjects().keySet()) {\n            List<BaseObject> oldObjects = getXObjects(reference);\n            BaseObjects newObjects = new BaseObjects();\n            while (newObjects.size() < oldObjects.size()) {\n                newObjects.add(null);\n            }\n            for (int i = 0; i < oldObjects.size(); i++) {\n                BaseObject oldobject = oldObjects.get(i);\n                if (oldobject != null) {\n                    BaseClass baseclass = oldobject.getXClass(context);\n                    BaseObject newobject = (BaseObject) baseclass.fromMap(\n                        eform.getObject(\n                            LOCAL_REFERENCE_SERIALIZER.serialize(baseclass.getDocumentReference()) + \"_\" + i),\n                        oldobject);\n                    newobject.setNumber(oldobject.getNumber());\n                    newobject.setGuid(oldobject.getGuid());\n                    newobject.setOwnerDocument(this);\n                    newObjects.set(newobject.getNumber(), newobject);\n                }\n            }\n            getXObjects().put(reference, newObjects);\n        }\n    }\n\n    /**\n     * Create and/or update objects in a document given a list of HTTP parameters of the form {@code\n     * <spacename>.<classname>_<number>_<propertyname>}. If the object already exists, the field is replaced by the\n     * given value. If the object doesn't exist in the document, it is created and the property {@code <propertyname>}\n     * is initialized with the given value.\n     *\n     * @param eform is form information that contains all the query parameters\n     * @param context\n     * @throws XWikiException\n     * @since 7.1M1\n     */\n    public void readObjectsFromFormUpdateOrCreate(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        Map<String, SortedMap<Integer, Map<String, String[]>>> updateOrCreateMap = eform.getUpdateOrCreateMap();\n        for (Entry<String, SortedMap<Integer, Map<String, String[]>>> requestClassEntries : updateOrCreateMap\n            .entrySet()) {\n            String className = requestClassEntries.getKey();\n            DocumentReference requestClassReference = getCurrentDocumentReferenceResolver().resolve(className);\n\n            SortedMap<Integer, Map<String, String[]>> requestObjectMap = requestClassEntries.getValue();\n            for (Entry<Integer, Map<String, String[]>> requestObjectEntry : requestObjectMap.entrySet()) {\n                Integer requestObjectNumber = requestObjectEntry.getKey();\n                Map<String, String[]> requestObjectPropertyMap = requestObjectEntry.getValue();\n                List<String> properties = new ArrayList<>(requestObjectPropertyMap.keySet());\n                try {\n                    BaseClass xClass = context.getWiki().getDocument(requestClassReference, context).getXClass();\n\n                    // clean-up the properties that do not belong to the xclass\n                    for (String property : properties) {\n                        if (!xClass.getPropertyList().contains(property)) {\n                            requestObjectPropertyMap.remove(property);\n                        }\n                    }\n                } catch (XWikiException e) {\n                    // If the class page cannot be found, skip entirely the property update\n                    LOGGER.warn(\"Failed to load document [{}], ignoring properties update [{}]. Reason: [{}]\",\n                        requestClassReference, StringUtils.join(properties, \",\"),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    continue;\n                }\n\n                if (!requestObjectPropertyMap.isEmpty()) {\n                    BaseObject oldObject = getXObject(requestClassReference, requestObjectNumber, true, context);\n                    BaseClass baseClass = oldObject.getXClass(context);\n                    BaseObject newObject = (BaseObject) baseClass.fromMap(requestObjectPropertyMap, oldObject);\n                    newObject.setNumber(oldObject.getNumber());\n                    newObject.setGuid(oldObject.getGuid());\n                    newObject.setOwnerDocument(this);\n                    setXObject(requestObjectNumber, newObject);\n                }\n            }\n        }\n    }\n\n    public void readFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        readDocMetaFromForm(eform, context);\n        readTranslationMetaFromForm(eform, context);\n\n        readAddedUpdatedAndRemovedObjectsFromForm(eform, context);\n        readTemporaryUploadedFiles(eform);\n    }\n\n    private TemporaryAttachmentSessionsManager getTemporaryAttachmentManager()\n    {\n        return Utils.getComponent(TemporaryAttachmentSessionsManager.class);\n    }\n\n    /**\n     * Read the list of attachment that should be added from {@link EditForm#getTemporaryUploadedFiles()} and attach\n     * them to the current document if they can be found in the {@link TemporaryAttachmentSessionsManager}.\n     *\n     * @param editForm the form from which to read the list of files.\n     * @since 14.3RC1\n     */\n    @Unstable\n    public void readTemporaryUploadedFiles(EditForm editForm)\n    {\n        getTemporaryAttachmentManager().attachTemporaryAttachmentsInDocument(this, editForm.getTemporaryUploadedFiles());\n    }\n\n    /**\n     * Adds objects, applies property updates and removes objects as specified in the form.\n     *\n     * @param eform The form from which the values shall be read.\n     * @param context The XWiki context.\n     * @throws XWikiException If an error occurs.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public void readAddedUpdatedAndRemovedObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        // We add the new objects that have been submitted in the form, before filling them with their values.\n        Map<String, List<Integer>> objectsToAdd = eform.getObjectsToAdd();\n        for (String className : objectsToAdd.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToAdd.get(className);\n            for (Integer classId : classIds) {\n                // we ensure that the object has not been added yet, for example because of the update or create.\n                getXObject(classReference, classId, true, context);\n            }\n        }\n\n        ObjectPolicyType objectPolicy = eform.getObjectPolicy();\n        if (objectPolicy == null || objectPolicy.equals(ObjectPolicyType.UPDATE)) {\n            readObjectsFromForm(eform, context);\n        } else if (objectPolicy.equals(ObjectPolicyType.UPDATE_OR_CREATE)) {\n            readObjectsFromFormUpdateOrCreate(eform, context);\n        }\n\n        // remove xobjects\n        Map<String, List<Integer>> objectsToRemove = eform.getObjectsToRemove();\n        for (String className : objectsToRemove.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToRemove.get(className);\n            for (Integer classId : classIds) {\n                BaseObject xObject = getXObject(classReference, classId);\n                if (xObject != null) {\n                    removeXObject(xObject);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void readFromTemplate(DocumentReference templateDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        if (templateDocumentReference != null) {\n            String content = getContent();\n            if (!content.equals(\"\\n\") && !content.equals(\"\") && !isNew()) {\n                Object[] args = { getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY,\n                    \"Cannot add a template to document {0} because it already has content\", null, args);\n            } else {\n                XWiki xwiki = context.getWiki();\n                XWikiDocument templatedoc = xwiki.getDocument(templateDocumentReference, context);\n                if (templatedoc.isNew()) {\n                    Object[] args = { getDefaultEntityReferenceSerializer().serialize(templateDocumentReference),\n                    getCompactEntityReferenceSerializer().serialize(getDocumentReference()) };\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_APP_TEMPLATE_DOES_NOT_EXIST,\n                        \"Template document {0} does not exist when adding to document {1}\", null, args);\n                } else {\n                    setTemplateDocumentReference(templateDocumentReference);\n                    setTitle(templatedoc.getTitle());\n                    setContent(templatedoc.getContent());\n\n                    // Set the new document syntax as the syntax of the template since the template content\n                    // is copied into the new document\n                    setSyntax(templatedoc.getSyntax());\n\n                    // If the parent is not set in the current document set the template parent as the parent.\n                    if (getParentReference() == null) {\n                        setParentReference(templatedoc.getRelativeParentReference());\n                    }\n\n                    if (isNew()) {\n                        // We might have received the objects from the cache and the template objects might have been\n                        // copied already we need to remove them\n                        setXObjects(new TreeMap<DocumentReference, List<BaseObject>>());\n                    }\n                    // Merge the external objects.\n                    // Currently the choice is not to merge the base class and object because it is not the preferred\n                    // way of using external classes and objects.\n                    mergeXObjects(templatedoc);\n\n                    // Copy the attachments from the template document, but don't overwrite existing attachments because\n                    // the user can add attachments from the WYSIWYG editor before the save button is clicked (and thus\n                    // before the template is applied).\n                    copyAttachments(templatedoc, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * Use the document passed as parameter as the new identity for the current document.\n     *\n     * @param document the document containing the new identity\n     */\n    public void clone(XWikiDocument document)\n    {\n        this.id = document.id;\n\n        setDocumentReference(document.getDocumentReference());\n        setRCSVersion(document.getRCSVersion());\n        setDocumentArchive(document.getDocumentArchive());\n        setAuthorReference(document.getAuthorReference());\n        setContentAuthorReference(document.getContentAuthorReference());\n        setContent(document.getContent());\n        setCreationDate(document.getCreationDate());\n        setDate(document.getDate());\n        setCustomClass(document.getCustomClass());\n        setContentUpdateDate(document.getContentUpdateDate());\n        setTitle(document.getTitle());\n        setFormat(document.getFormat());\n        setFromCache(document.isFromCache());\n        setElements(document.getElements());\n        setMeta(document.getMeta());\n        setMostRecent(document.isMostRecent());\n        setNew(document.isNew());\n        setStore(document.getStore());\n        setTemplateDocumentReference(document.getTemplateDocumentReference());\n        setParentReference(document.getRelativeParentReference());\n        setCreatorReference(document.getCreatorReference());\n        setDefaultLocale(document.getDefaultLocale());\n        setDefaultTemplate(document.getDefaultTemplate());\n        setValidationScript(document.getValidationScript());\n        setLocale(document.getLocale());\n        setXClass(document.getXClass().clone());\n        setXClassXML(document.getXClassXML());\n        setComment(document.getComment());\n        setMinorEdit(document.isMinorEdit());\n        setSyntax(document.getSyntax());\n        setHidden(document.isHidden());\n\n        cloneXObjects(document);\n        cloneAttachments(document);\n\n        setContentDirty(document.isContentDirty());\n        setMetaDataDirty(document.isMetaDataDirty());\n\n        this.elements = document.elements;\n\n        this.originalDocument = document.originalDocument;\n    }\n\n    @Override\n    public XWikiDocument clone()\n    {\n        return cloneInternal(getDocumentReference(), true, false);\n    }\n\n    /**\n     * Duplicate this document and give it a new name.\n     *\n     * @since 2.2.3\n     */\n    public XWikiDocument duplicate(DocumentReference newDocumentReference)\n    {\n        return cloneInternal(newDocumentReference, false, false);\n    }\n\n    private void cloneDocumentArchive(XWikiDocument originalDocument) throws XWikiException\n    {\n        XWikiDocumentArchive documentArchive = originalDocument.getDocumentArchive();\n        if (documentArchive != null) {\n            this.setDocumentArchive(documentArchive.clone(this.getId(), getXWikiContext()));\n        }\n    }\n\n    private XWikiDocument cloneInternal(DocumentReference newDocumentReference,\n        boolean keepsIdentity,\n        boolean cloneArchive)\n    {\n        XWikiDocument doc = null;\n\n        try {\n            Constructor<? extends XWikiDocument> constructor = getClass().getConstructor(DocumentReference.class);\n            doc = constructor.newInstance(newDocumentReference);\n\n            // Make sure the coordinate of the document is fully accurate before any other manipulation\n            doc.setLocale(getLocale());\n\n            // use version field instead of getRCSVersion because it returns \"1.1\" if version==null.\n            doc.version = this.version;\n            doc.id = this.id;\n            if (cloneArchive) {\n                doc.cloneDocumentArchive(this);\n            } else {\n                // Without this explicit initialization, it is possible for the archive to be incorrectly initialized.\n                // For instance, with the archive of the cloned document.\n                // Here we guarantee that further calls of APIs to get the archive will properly populate the data.\n                doc.setDocumentArchive((XWikiDocumentArchive) null);\n            }\n            doc.getAuthors().copyAuthors(getAuthors());\n            doc.setContent(getContent());\n            doc.setCreationDate(getCreationDate());\n            doc.setDate(getDate());\n            doc.setCustomClass(getCustomClass());\n            doc.setContentUpdateDate(getContentUpdateDate());\n            doc.setTitle(getTitle());\n            doc.setFormat(getFormat());\n            doc.setFromCache(isFromCache());\n            doc.setElements(getElements());\n            doc.setMeta(getMeta());\n            doc.setMostRecent(isMostRecent());\n            doc.setNew(isNew());\n            doc.setStore(getStore());\n            doc.setTemplateDocumentReference(getTemplateDocumentReference());\n            doc.setParentReference(getRelativeParentReference());\n            doc.setDefaultLocale(getDefaultLocale());\n            doc.setDefaultTemplate(getDefaultTemplate());\n            doc.setValidationScript(getValidationScript());\n            doc.setComment(getComment());\n            doc.setMinorEdit(isMinorEdit());\n            doc.setSyntax(getSyntax());\n            doc.setHidden(isHidden());\n\n            if (this.xClass != null) {\n                doc.setXClass(this.xClass.clone());\n            }\n\n            if (keepsIdentity) {\n                doc.setXClassXML(getXClassXML());\n                doc.cloneXObjects(this);\n                doc.cloneAttachments(this);\n            } else {\n                doc.getXClass().setCustomMapping(null);\n                doc.duplicateXObjects(this);\n                doc.copyAttachments(this);\n            }\n\n            doc.setContentDirty(isContentDirty());\n            doc.setMetaDataDirty(isMetaDataDirty());\n\n            doc.elements = this.elements;\n\n            doc.originalDocument = this.originalDocument;\n        } catch (Exception e) {\n            // This should not happen\n            LOGGER.error(\"Exception while cloning document\", e);\n        }\n        return doc;\n    }\n\n    /**\n     * Clone attachments from another document. This implementation expects that this document is the same as the other\n     * document and thus attachments will be saved in the database in the same place as the ones which they are cloning.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    private void cloneAttachments(final XWikiDocument sourceDocument)\n    {\n        this.getAttachmentList().clear();\n        for (XWikiAttachment attach : sourceDocument.getAttachmentList()) {\n            XWikiAttachment newAttach = (XWikiAttachment) attach.clone();\n\n            setAttachment(newAttach);\n        }\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    public void copyAttachments(XWikiDocument sourceDocument)\n    {\n        copyAttachments(sourceDocument, true);\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     * @param overwrite whether to overwrite the existing attachments or not\n     * @since 8.4.6\n     * @since 9.6RC1\n     */\n    private void copyAttachments(XWikiDocument sourceDocument, boolean overwrite)\n    {\n        if (overwrite) {\n            // Note: when clearing the attachment list, we automatically mark the document's metadata as dirty.\n            getAttachmentList().clear();\n        }\n\n        for (XWikiAttachment attachment : sourceDocument.getAttachmentList()) {\n            if (overwrite || this.getAttachment(attachment.getFilename()) == null) {\n                try {\n                    copyAttachment(attachment, true);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"Cannot copy attachment [{}] from [{}] to [{}]. Root cause is [{}].\",\n                        attachment.getFilename(), sourceDocument.getDocumentReference(), this.getDocumentReference(),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    // Skip this attachment because we cannot load its content.\n                    continue;\n                }\n            }\n        }\n    }\n\n    /**\n     * Copies the given attachment to this document.\n     * \n     * @param attachment the source attachment to be copied to this document\n     * @param reset whether to reset or not the attachment meta data that is specific to the source (version, author,\n     *            date)\n     * @throws XWikiException if loading the content of the given attachment fails\n     */\n    private void copyAttachment(XWikiAttachment attachment, boolean reset) throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n        XWikiAttachment newAttachment = attachment.clone();\n\n        // Make sure we copy the attachment content also, not just its meta data. For this we need to load\n        // the attachment content from the source document. Note that the owner document will be overwritten\n        // below when we call setAttachment().\n        newAttachment.setDoc(attachment.getDoc(), false);\n        newAttachment.loadAttachmentContent(xcontext);\n        // We need to set the content of the attachment to be dirty because the dirty bit is used to signal\n        // that there is a reason to save the copied attachment, otherwise the copied attachment will be\n        // empty since the original attachment content is not modified in this operation.\n        newAttachment.getAttachment_content().setContentDirty(true);\n\n        if (reset) {\n            // Reset the meta data that is specific to the original attachment (version, author, date).\n            newAttachment.setRCSVersion(null);\n            newAttachment.setAuthorReference(xcontext.getUserReference());\n            newAttachment.setDate(new Date());\n        }\n\n        // Add the attachment copy to the list of attachments of this document.\n        setAttachment(newAttachment);\n    }\n\n    /**\n     * Load attachment content from database.\n     *\n     * @param context the XWiki context\n     * @throws XWikiException when failing to load attachments\n     * @since 5.3M2\n     */\n    public void loadAttachmentsContent(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n        }\n    }\n\n    /**\n     * Same as {@link #loadAttachmentContent(XWikiAttachment, XWikiContext)} but in some context we don't really care if\n     * an attachment content could not be loaded (we are going to overwrite or ignore it).\n     * \n     * @param context the XWiki context\n     * @since 10.1RC1\n     */\n    public void loadAttachmentsContentSafe(XWikiContext context)\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            try {\n                attachment.loadAttachmentContent(context);\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Failed to load attachment [{}]: {}\", attachment.getReference(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n    }\n\n    public void loadAttachments(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n            attachment.loadArchive(context);\n        }\n    }\n\n    @Override\n    public boolean equals(Object object)\n    {\n        // Same Java object, they sure are equal\n        if (this == object) {\n            return true;\n        }\n\n        // Reference/language (document identifier)\n\n        XWikiDocument doc = (XWikiDocument) object;\n        if (!getDocumentReference().equals(doc.getDocumentReference())) {\n            return false;\n        }\n\n        if (!getDefaultLocale().equals(doc.getDefaultLocale())) {\n            return false;\n        }\n\n        if (!getLocale().equals(doc.getLocale())) {\n            return false;\n        }\n\n        if (getTranslation() != doc.getTranslation()) {\n            return false;\n        }\n\n        // Authors\n\n        if (ObjectUtils.notEqual(getAuthorReference(), doc.getAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getContentAuthorReference(), doc.getContentAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getCreatorReference(), doc.getCreatorReference())) {\n            return false;\n        }\n\n        // Version\n\n        if (!getVersion().equals(doc.getVersion())) {\n            return false;\n        }\n\n        if (getDate().getTime() != doc.getDate().getTime()) {\n            return false;\n        }\n\n        if (getContentUpdateDate().getTime() != doc.getContentUpdateDate().getTime()) {\n            return false;\n        }\n\n        if (getCreationDate().getTime() != doc.getCreationDate().getTime()) {\n            return false;\n        }\n\n        if (!getComment().equals(doc.getComment())) {\n            return false;\n        }\n\n        if (isMinorEdit() != doc.isMinorEdit()) {\n            return false;\n        }\n\n        // Datas\n\n        if (!equalsData(doc)) {\n            return false;\n        }\n\n        // We consider that 2 documents are still equal even when they have different original\n        // documents (see getOriginalDocument() for more details as to what is an original\n        // document).\n\n        return true;\n    }\n\n    /**\n     * Same as {@link #equals(Object)} but only for actual datas of the document.\n     * <p>\n     * The goal being to compare two versions of the same document this method skip every version/reference/author\n     * related information. For example it allows to compare a document comming from a another wiki and easily check if\n     * thoses actually are the same thing whatever the plumbing differences.\n     *\n     * @param otherDocument the document to compare\n     * @return true if bith documents have the same datas\n     * @since 4.1.1\n     */\n    public boolean equalsData(XWikiDocument otherDocument)\n    {\n        // Same Java object, they sure are equal\n        if (this == otherDocument) {\n            return true;\n        }\n\n        if (ObjectUtils.notEqual(getParentReference(), otherDocument.getParentReference())) {\n            return false;\n        }\n\n        if (!getFormat().equals(otherDocument.getFormat())) {\n            return false;\n        }\n\n        if (!getTitle().equals(otherDocument.getTitle())) {\n            return false;\n        }\n\n        if (!getContent().equals(otherDocument.getContent())) {\n            return false;\n        }\n\n        if (!getDefaultTemplate().equals(otherDocument.getDefaultTemplate())) {\n            return false;\n        }\n\n        if (!getValidationScript().equals(otherDocument.getValidationScript())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getSyntax(), otherDocument.getSyntax())) {\n            return false;\n        }\n\n        if (isHidden() != otherDocument.isHidden()) {\n            return false;\n        }\n\n        // XClass\n\n        if (!getXClass().equals(otherDocument.getXClass())) {\n            return false;\n        }\n\n        // XObjects\n\n        Set<DocumentReference> myObjectClassReferences = getXObjects().keySet();\n        Set<DocumentReference> otherObjectClassReferences = otherDocument.getXObjects().keySet();\n        if (!myObjectClassReferences.equals(otherObjectClassReferences)) {\n            return false;\n        }\n\n        for (DocumentReference reference : myObjectClassReferences) {\n            List<BaseObject> myObjects = getXObjects(reference);\n            List<BaseObject> otherObjects = otherDocument.getXObjects(reference);\n            if (myObjects.size() != otherObjects.size()) {\n                return false;\n            }\n            for (int i = 0; i < myObjects.size(); i++) {\n                if ((myObjects.get(i) == null && otherObjects.get(i) != null)\n                    || (myObjects.get(i) != null && otherObjects.get(i) == null)) {\n                    return false;\n                }\n                if (myObjects.get(i) == null && otherObjects.get(i) == null) {\n                    continue;\n                }\n                if (!myObjects.get(i).equals(otherObjects.get(i))) {\n                    return false;\n                }\n            }\n        }\n\n        // Attachments\n        List<XWikiAttachment> attachments = getAttachmentList();\n        List<XWikiAttachment> otherAttachments = otherDocument.getAttachmentList();\n        if (attachments.size() != otherAttachments.size()) {\n            return false;\n        }\n        for (XWikiAttachment attachment : attachments) {\n            XWikiAttachment otherAttachment = otherDocument.getAttachment(attachment.getFilename());\n            try {\n                if (otherAttachment == null || !attachment.equalsData(otherAttachment, null)) {\n                    return false;\n                }\n            } catch (XWikiException e) {\n                throw new RuntimeException(\n                    String.format(\"Failed to compare attachments with reference [%s]\", attachment.getReference()), e);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Retrieve the document in the current context language as an XML string. The rendrered document content and all\n     * XObjects are included. Document attachments and archived versions are excluded. You should prefer\n     * toXML(OutputStream, true, true, false, false, XWikiContext)} or toXML(com.xpn.xwiki.util.XMLWriter, true, true,\n     * false, false, XWikiContext) on the translated document when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document in the current context language\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String getXMLContent(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(context);\n        return tdoc.toXML(true, true, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObject are included. Rendered content, attachments and archived\n     * version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObjects attachments and archived version are included. Rendered\n     * content is excluded. You should prefer toXML(OutputStream, true, false, true, true, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, true, true, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toFullXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, true, true, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. All XObjects and attachments are\n     * included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param zipname the name of the new entry to create\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, String zipname, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        ZipEntry zipentry = new ZipEntry(zipname);\n        zos.putNextEntry(zipentry);\n        toXML(zos, true, false, true, withVersions, context);\n        zos.closeEntry();\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects and attachments are included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.2M2\")\n    public void addToZip(ZipOutputStream zos, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        String zipname =\n            getDocumentReference().getLastSpaceReference().getName() + \"/\" + getDocumentReference().getName();\n        String language = getLanguage();\n        if (!StringUtils.isEmpty(language)) {\n            zipname += \".\" + language;\n        }\n        addToZip(zos, zipname, withVersions, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects, attachments and archived versions are included. Rendered content is\n     * excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, XWikiContext context) throws XWikiException, IOException\n    {\n        addToZip(zos, true, context);\n    }\n\n    /**\n     * Serialize the document to an XML string. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an errors occurs during wiki operations\n     */\n    public String toXML(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        StringWriter writer = new StringWriter();\n\n        toXML(new DefaultWriterOutputTarget(writer), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        return writer.toString();\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. All XObject are included. Rendered content, attachments and\n     * archived version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(XWikiContext context) throws XWikiException\n    {\n        return toXMLDocument(true, false, false, false, context);\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        Document doc = new DOMDocument();\n        DOMXMLWriter wr = new DOMXMLWriter(doc, new OutputFormat(\"\", true, context.getWiki().getEncoding()));\n\n        try {\n            toXML(wr, bWithObjects, bWithRendering, bWithAttachmentContent, bWithVersions, context);\n            return doc;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Serialize the document to a {@link com.xpn.xwiki.internal.xml.XMLWriter}.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void toXML(XMLWriter wr, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        // IMPORTANT: we don't use directly XMLWriter's SAX apis here because it's not really working well\n        DocumentResult domResult = new DocumentResult();\n\n        toXML(new DefaultResultOutputTarget(domResult), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        wr.write(domResult.getDocument().getRootElement());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     */\n    public void toXML(OutputStream out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        toXML(new DefaultOutputStreamOutputTarget(out), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param out the output where to write the XML\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param format true if the XML should be formated\n     * @param encoding the encoding to use to write the XML\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 9.0RC1\n     */\n    public void toXML(OutputTarget out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, boolean format, String encoding) throws XWikiException\n    {\n        // Input\n        DocumentInstanceInputProperties documentProperties = new DocumentInstanceInputProperties();\n        documentProperties.setWithWikiObjects(bWithObjects);\n        documentProperties.setWithWikiDocumentContentHTML(bWithRendering);\n        documentProperties.setWithWikiAttachmentsContent(bWithAttachmentContent);\n        documentProperties.setWithJRCSRevisions(bWithVersions);\n        documentProperties.setWithRevisions(false);\n\n        // Output\n        XAROutputProperties xarProperties = new XAROutputProperties();\n        xarProperties.setPreserveVersion(bWithVersions);\n        xarProperties.setEncoding(encoding);\n        xarProperties.setFormat(format);\n        xarProperties.setTarget(out);\n\n        toXML(documentProperties, xarProperties);\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param xarProperties the configuration of the output filter\n     * @param documentProperties the configuration of the input filter\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 13.8RC1\n     */\n    public void toXML(DocumentInstanceInputProperties documentProperties, XAROutputProperties xarProperties)\n        throws XWikiException\n    {\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).exportEntity(this, xarProperties.getTarget(),\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_DOC_EXPORT,\n                \"Error serializing XML\", e, null);\n        }\n    }\n\n    protected String encodedXMLStringAsUTF8(String xmlString)\n    {\n        if (xmlString == null) {\n            return \"\";\n        }\n\n        int length = xmlString.length();\n        char character;\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            character = xmlString.charAt(i);\n            switch (character) {\n                case '&':\n                    result.append(\"&amp;\");\n                    break;\n                case '\"':\n                    result.append(\"&quot;\");\n                    break;\n                case '<':\n                    result.append(\"&lt;\");\n                    break;\n                case '>':\n                    result.append(\"&gt;\");\n                    break;\n                case '\\n':\n                    result.append(\"\\n\");\n                    break;\n                case '\\r':\n                    result.append(\"\\r\");\n                    break;\n                case '\\t':\n                    result.append(\"\\t\");\n                    break;\n                default:\n                    if (character < 0x20) {\n                    } else if (character > 0x7F) {\n                        result.append(\"&#x\");\n                        result.append(Integer.toHexString(character).toUpperCase());\n                        result.append(\";\");\n                    } else {\n                        result.append(character);\n                    }\n                    break;\n            }\n        }\n\n        return result.toString();\n    }\n\n    protected String getElement(Element docel, String name)\n    {\n        Element el = docel.element(name);\n        if (el == null) {\n            return \"\";\n        } else {\n            return el.getText();\n        }\n    }\n\n    public void fromXML(String xml) throws XWikiException\n    {\n        fromXML(xml, false);\n    }\n\n    public void fromXML(InputStream is) throws XWikiException\n    {\n        fromXML(is, false);\n    }\n\n    public void fromXML(InputSource source, boolean withArchive) throws XWikiException\n    {\n        // Output\n        DocumentInstanceOutputProperties documentProperties = new DocumentInstanceOutputProperties();\n        XWikiContext xcontext = getXWikiContext();\n        if (xcontext != null) {\n            documentProperties.setDefaultReference(getXWikiContext().getWikiReference());\n        }\n\n        // Input\n        XARInputProperties xarProperties = new XARInputProperties();\n        xarProperties.setWithHistory(withArchive);\n\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).importEntity(XWikiDocument.class, this, source,\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // We have been reading from XML so the document does not need a new version when saved\n        setMetaDataDirty(false);\n        setContentDirty(false);\n    }\n\n    public void fromXML(String source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new StringInputSource(source), withArchive);\n    }\n\n    public void fromXML(InputStream source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new DefaultInputStreamInputSource(source), withArchive);\n    }\n\n    /**\n     * @deprecated use {@link #fromXML(InputStream)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void fromXML(Document domdoc, boolean withArchive) throws XWikiException\n    {\n        // Serialize the Document (could not find a way to convert a dom4j Document into a usable StAX source)\n        StringWriter writer = new StringWriter();\n        try {\n            org.dom4j.io.XMLWriter domWriter = new org.dom4j.io.XMLWriter(writer);\n            domWriter.write(domdoc);\n            domWriter.flush();\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // Actually parse the XML\n        fromXML(writer.toString(), withArchive);\n    }\n\n    /**\n     * Check if provided xml document is a wiki document.\n     *\n     * @param domdoc the xml document.\n     * @return true if provided xml document is a wiki document.\n     */\n    public static boolean containsXMLWikiDocument(Document domdoc)\n    {\n        return domdoc.getRootElement().getName().equals(XarDocumentModel.ELEMENT_DOCUMENT);\n    }\n\n    public void setAttachmentList(List<XWikiAttachment> list)\n    {\n        // For backwards compatibility reasons (and in general), we need to allow callers to do something like\n        // setAttachmentList(getAttachmentList())\n        if (this.attachmentList != list) {\n            this.attachmentList.clear();\n            this.attachmentList.addAll(list);\n        }\n    }\n\n    public List<XWikiAttachment> getAttachmentList()\n    {\n        return this.attachmentList;\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(XWikiContext context) throws XWikiException\n    {\n        saveAllAttachments(true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(boolean updateParent, boolean transaction, XWikiContext context)\n        throws XWikiException\n    {\n        for (XWikiAttachment attachment : this.attachmentList) {\n            saveAttachmentContent(attachment, false, transaction, context);\n        }\n\n        // Save the document\n        if (updateParent) {\n            context.getWiki().saveDocument(this, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentsContent(List<XWikiAttachment> attachments, XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : attachments) {\n            saveAttachmentContent(attachment, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        saveAttachmentContent(attachment, true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, boolean updateParent, boolean transaction,\n        XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            // Save the attachment\n            XWikiAttachmentStoreInterface store =\n                resolveXWikiAttachmentStoreInterface(attachment.getContentStore(), context);\n            store.saveAttachmentContent(attachment, false, context, transaction);\n\n            // We need to make sure there is a version upgrade\n            setMetaDataDirty(true);\n\n            // Save the document\n            if (updateParent) {\n                context.getWiki().saveDocument(this, context);\n            }\n        } catch (OutOfMemoryError e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_JAVA_HEAP_SPACE,\n                \"Out Of Memory Exception\");\n        } finally {\n            if (currentWiki != null) {\n                context.setWikiId(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link XWikiAttachment#loadContent(XWikiContext)}\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public void loadAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        String database = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            attachment.loadAttachmentContent(context);\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n        }\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     * <p>\n     * The attachment will be move to recycle bin.\n     *\n     * @param attachment the attachment to remove\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachment)\n    {\n        return removeAttachment(attachment, true);\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     *\n     * @param attachmentToRemove the attachment to remove\n     * @param toRecycleBin indicate if the attachment should be moved to recycle bin\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachmentToRemove, boolean toRecycleBin)\n    {\n        if (this.attachmentList.remove(attachmentToRemove)) {\n            this.attachmentsToRemove.add(new XWikiAttachmentToRemove(attachmentToRemove, toRecycleBin));\n            setMetaDataDirty(true);\n        } else {\n            attachmentToRemove = null;\n        }\n        return attachmentToRemove;\n    }\n\n    /**\n     * @return the attachment planned for removal\n     */\n    public List<XWikiAttachmentToRemove> getAttachmentsToRemove()\n    {\n        return this.attachmentsToRemove;\n    }\n\n    /**\n     * Clear the list of attachments planned for removal.\n     */\n    public void clearAttachmentsToRemove()\n    {\n        this.attachmentsToRemove.clear();\n    }\n\n    /**\n     * Get the wiki document references pointing to this document.\n     * <p>\n     * Theses links are stored in the Solr search core when the document is indexed. You can use \"backlinks\" in\n     * XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable links storage in the database.\n     * <p>\n     * Since 14.8RC1, this method return all backlinked documents and not just those located in the context wiki.\n     *\n     * @param context the XWiki context.\n     * @return the found wiki document references\n     * @throws XWikiException error when getting pages names from database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getBackLinkedReferences(XWikiContext context) throws XWikiException\n    {\n        Set<EntityReference> references;\n        try {\n            references = getLinkStore().resolveBackLinkedEntities(getDocumentReference());\n        } catch (LinkException e) {\n            throw new XWikiException(\"Failed to load backlinks for reference [\" + getDocumentReference() + \"]\", e);\n        }\n\n        Set<DocumentReference> documentReferences = new HashSet<>(references.size());\n        for (EntityReference entityReference : references) {\n            // Resolve the DOCUMENT reference\n            DocumentReference linkReference = context.getWiki().getDocumentReference(entityReference, context);\n\n            // Retro compatibility: remove the locale as it's what is expected of #getBackLinkedReferences(XWikicontext)\n            if (linkReference.getLocale() != null) {\n                linkReference = new DocumentReference(linkReference, (Locale) null);\n            }\n\n            // Add the reference\n            documentReferences.add(linkReference);\n        }\n\n        return new ArrayList<>(documentReferences);\n    }\n\n    /**\n     * @deprecated use {@link #getBackLinkedReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getBackLinkedPages(XWikiContext context) throws XWikiException\n    {\n        List<DocumentReference> references = getBackLinkedReferences(context);\n\n        EntityReferenceSerializer<String> serializer = getCompactWikiEntityReferenceSerializer();\n\n        List<String> documentNames = new ArrayList<>(references.size());\n        for (DocumentReference reference : references) {\n            // Serialize the reference\n            documentNames.add(serializer.serialize(reference));\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Get a list of unique links from this document to others documents.\n     * <ul>\n     * <li>xwiki/1.0 content: get the unique links associated to document from database. This is stored when the\n     * document is saved. You can use \"backlinks\" in XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable\n     * links storage in the database.</li>\n     * <li>Other content: call {@link #getUniqueLinkedPages(XWikiContext)} and generate the List.</li>\n     * </ul>\n     *\n     * @param context the XWiki context\n     * @return the found wiki links.\n     * @throws XWikiException error when getting links from database when xwiki/1.0 content.\n     * @since 1.9M2\n     */\n    public Set<XWikiLink> getUniqueWikiLinkedPages(XWikiContext context) throws XWikiException\n    {\n        Set<XWikiLink> links;\n\n        // We don't handle the links the same way in 1.0 syntax for retro-compatibility reason\n        // So here we explicitly get the link from the DB instead of looking inside the document.\n        if (is10Syntax()) {\n            links = new LinkedHashSet<>(getStore(context).loadLinks(getId(), context, true));\n        } else {\n            Set<String> linkedPages = getUniqueLinkedPages(context);\n            links = new LinkedHashSet<>(linkedPages.size());\n            for (String linkedPage : linkedPages) {\n                XWikiLink wikiLink = new XWikiLink();\n\n                wikiLink.setDocId(getId());\n                wikiLink.setFullName(LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n                wikiLink.setLink(linkedPage);\n\n                links.add(wikiLink);\n            }\n        }\n\n        return links;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) wiki links (pointing to wiki page) from this\n     * xwiki/1.0 document's content to others documents.\n     *\n     * @param context the XWiki context.\n     * @return the document references for linked pages, if null an error append.\n     * @since 1.9M2\n     */\n    private Set<DocumentReference> getUniqueLinkedPages10(XWikiContext context)\n    {\n        Set<DocumentReference> pageNames;\n\n        try {\n            List<String> list = context.getUtil().getUniqueMatches(getContent(), \"\\\\[(.*?)\\\\]\", 1);\n            pageNames = new HashSet<DocumentReference>(list.size());\n\n            DocumentReference currentDocumentReference = getDocumentReference();\n            for (String name : list) {\n                int i1 = name.indexOf('>');\n                if (i1 != -1) {\n                    name = name.substring(i1 + 1);\n                }\n                i1 = name.indexOf(\"&gt;\");\n                if (i1 != -1) {\n                    name = name.substring(i1 + 4);\n                }\n                i1 = name.indexOf('#');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n                i1 = name.indexOf('?');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n\n                // Let's get rid of anything that's not a real link\n                if (name.trim().equals(\"\") || (name.indexOf('$') != -1) || (name.indexOf(\"://\") != -1)\n                    || (name.indexOf('\"') != -1) || (name.indexOf('\\'') != -1) || (name.indexOf(\"..\") != -1)\n                    || (name.indexOf(':') != -1) || (name.indexOf('=') != -1)) {\n                    continue;\n                }\n\n                // generate the link\n                String newname = StringUtils.replace(Util.noaccents(name), \" \", \"\");\n\n                // If it is a local link let's add the space\n                if (newname.indexOf('.') == -1) {\n                    newname = getSpace() + \".\" + name;\n                }\n                if (context.getWiki().exists(newname, context)) {\n                    name = newname;\n                } else {\n                    // If it is a local link let's add the space\n                    if (name.indexOf('.') == -1) {\n                        name = getSpace() + \".\" + name;\n                    }\n                }\n\n                // If the reference is empty, the link is an autolink\n                if (!StringUtils.isEmpty(name)) {\n                    // The reference may not have the space or even document specified (in case of an empty\n                    // string)\n                    // Thus we need to find the fully qualified document name\n                    DocumentReference documentReference = getCurrentDocumentReferenceResolver().resolve(name);\n\n                    // Verify that the link is not an autolink (i.e. a link to the current document)\n                    if (!documentReference.equals(currentDocumentReference)) {\n                        pageNames.add(documentReference);\n                    }\n                }\n            }\n\n            return pageNames;\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to get linked documents\", e);\n\n            return null;\n        }\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to entities specified in the passed {@code entityTypes} map (the keys represent\n     * the entity references that will be returned).\n     *\n     * @param context the XWiki context\n     * @param entityTypes the mapping of the types of references to return (and their corresponding resource types)\n     * @return the serialized entity references, and null if an error happened\n     * @since 14.2RC1\n     */\n    private Set<EntityReference> getUniqueLinkedEntityReferences(XWikiContext context,\n        Map<EntityType, Set<ResourceType>> entityTypes)\n    {\n        Set<EntityReference> references;\n\n        XWikiDocument contextDoc = context.getDoc();\n        WikiReference contextWikiReference = context.getWikiReference();\n\n        try {\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiReference(getDocumentReference().getWikiReference());\n\n            if (is10Syntax()) {\n                references = (Set) getUniqueLinkedPages10(context);\n            } else {\n                references = new LinkedHashSet<>();\n\n                // Document content\n                XDOM dom = getXDOM();\n                getUniqueLinkedEntityReferences(dom, entityTypes, references);\n\n                // XObjects\n                for (List<BaseObject> xobjects : getXObjects().values()) {\n                    xobjects.stream()\n                        .forEach(xobject -> getUniqueLinkedEntityReferences(xobject, entityTypes, references, context));\n                }\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiReference(contextWikiReference);\n        }\n\n        return references;\n    }\n\n    private void getUniqueLinkedEntityReferences(BaseObject xobject, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references, XWikiContext xcontext)\n    {\n        if (xobject == null) {\n            return;\n        }\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n\n        for (Object fieldClass : xclass.getProperties()) {\n            // Wiki content stored in xobjects\n            if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                PropertyInterface field = xobject.getField(textAreaClass.getName());\n\n                // Make sure the field is the right type (might happen while a document is being migrated)\n                if (field instanceof LargeStringProperty) {\n                    LargeStringProperty largeField = (LargeStringProperty) field;\n\n                    try {\n                        XDOM dom = parseContent(getSyntax(), largeField.getValue(), getDocumentReference());\n                        getUniqueLinkedEntityReferences(dom, entityTypes, references);\n                    } catch (XWikiException e) {\n                        LOGGER.warn(\"Failed to extract links from xobject property [{}], skipping it. Error: {}\",\n                            largeField.getReference(), ExceptionUtils.getRootCauseMessage(e));\n                    }\n                }\n            }\n        }\n    }\n\n    private void getUniqueLinkedEntityReferences(XDOM dom, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references)\n    {\n        Set<EntityReference> uniqueLinkedEntityReferences =\n            getLinkParser().getUniqueLinkedEntityReferences(dom, entityTypes, getDocumentReference());\n        references.addAll(uniqueLinkedEntityReferences);\n    }\n\n    private Set<DocumentReference> toDocumentReferenceSet(Collection<? extends EntityReference> entityReferences,\n        DocumentReference baseReference)\n    {\n        Set<DocumentReference> documentReferences = new LinkedHashSet<>(entityReferences.size());\n\n        for (EntityReference entityRefefence : entityReferences) {\n            documentReferences.add(getCurrentReferenceDocumentReferenceResolver().resolve(entityRefefence,\n                EntityType.DOCUMENT, baseReference));\n        }\n\n        return documentReferences;\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to documents (either using a Document Reference or a Page Reference).\n     *\n     * @param context the XWiki context\n     * @return the serialized entity references, and null if an error happened\n     * @since 1.9M2\n     */\n    public Set<String> getUniqueLinkedPages(XWikiContext context)\n    {\n        // Only return document references.\n        Set<EntityReference> references = getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT,\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE,\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n        Set<String> documentNames = new LinkedHashSet<>(references.size());\n\n        XWikiDocument contextDoc = context.getDoc();\n        String contextWiki = context.getWikiId();\n        EntityReferenceSerializer<String> serializer;\n\n        try {\n            // Specify the right context information for using the compact wiki serializer properly\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiId(getDocumentReference().getWikiReference().getName());\n\n            // for retro-compatibility reason we don't use the same serializer for 1.0 syntax.\n            if (is10Syntax()) {\n                serializer = getCompactEntityReferenceSerializer();\n            } else {\n                serializer = getCompactWikiEntityReferenceSerializer();\n            }\n\n            for (EntityReference reference : references) {\n                // Get the reference of the document\n                DocumentReference linkDocumentReference = context.getWiki().getDocumentReference(reference, context);\n\n                // Serialize the reference\n                documentNames.add(serializer.serialize(linkDocumentReference));\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiId(contextWiki);\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) entity references pointed by wiki links (pointing\n     * to wiki document or attachments) for the current context document.\n     *\n     * @param context the XWiki context\n     * @return the entity references pointing to either document or attachments. If {@code null}, an error happened\n     * @since 14.2RC1\n     */\n    @Unstable\n    public Set<EntityReference> getUniqueLinkedEntities(XWikiContext context)\n    {\n        // Return both document and attachment references.\n        // Note that we return PAGE and PAGE_ATTACHMENT since it's not possible to convert them to DOCUMENT and\n        // ATTACHMENT since there's no way of knowing (without querying the DB) if they point to a terminal page or\n        // a non-terminal one (and thus the conversion would be wrong).\n        return getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE),\n            EntityType.ATTACHMENT, Set.of(\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE_ATTACHMENT, Set.of(\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     * {@link #getChildren(int, int, com.xpn.xwiki.XWikiContext)}\n     *\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(XWikiContext context) throws XWikiException\n    {\n        return getChildrenReferences(0, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(XWikiContext context) throws XWikiException\n    {\n        return getChildren(0, 0, context);\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     *\n     * @param nb The number of results to return.\n     * @param start The number of results to skip before we begin returning results.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return the list of document references\n     * @throws XWikiException If there's an error querying the database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        // Use cases:\n        // - the parent document reference saved in the database matches the reference of this document, in its fully\n        // serialized form (eg \"wiki:space.page\"). Note that this is normally not required since the wiki part\n        // isn't saved in the database when it matches the current wiki.\n        // - the parent document reference saved in the database matches the reference of this document, in its\n        // serialized form without the wiki part (eg \"space.page\"). The reason we don't need to specify the wiki\n        // part is because document parents saved in the database don't have the wiki part specified when it matches\n        // the current wiki.\n        // - the parent document reference saved in the database matches the page name part of this document's\n        // reference (eg \"page\") and the parent document's space is the same as this document's space.\n        List<DocumentReference> children = new ArrayList<DocumentReference>();\n\n        try {\n            Query query = getStore().getQueryManager()\n                .createQuery(\"select distinct doc.fullName from XWikiDocument doc where \"\n                    + \"doc.parent=:prefixedFullName or doc.parent=:fullName or (doc.parent=:name and doc.space=:space)\",\n                    Query.XWQL);\n            query.addFilter(Utils.getComponent(QueryFilter.class, \"hidden\"));\n            query.bindValue(\"prefixedFullName\",\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()));\n            query.bindValue(\"fullName\", LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n            query.bindValue(\"name\", getDocumentReference().getName());\n            query.bindValue(\"space\",\n                LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference()));\n            query.setLimit(nb).setOffset(start);\n\n            List<String> queryResults = query.execute();\n            WikiReference wikiReference = this.getDocumentReference().getWikiReference();\n            for (String fullName : queryResults) {\n                children.add(getCurrentDocumentReferenceResolver().resolve(fullName, wikiReference));\n            }\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to retrieve children for document [%s]\", this.getDocumentReference()), e);\n        }\n\n        return children;\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        List<String> childrenNames = new ArrayList<String>();\n        for (DocumentReference reference : getChildrenReferences(nb, start, context)) {\n            childrenNames.add(LOCAL_REFERENCE_SERIALIZER.serialize(reference));\n        }\n        return childrenNames;\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public void renameProperties(DocumentReference classReference, Map<String, String> fieldsToRename)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            return;\n        }\n\n        boolean isDirty = false;\n        for (BaseObject bobject : objects) {\n            if (bobject == null) {\n                continue;\n            }\n            for (Map.Entry<String, String> entry : fieldsToRename.entrySet()) {\n                String origname = entry.getKey();\n                String newname = entry.getValue();\n                BaseProperty origprop = (BaseProperty) bobject.safeget(origname);\n                if (origprop != null) {\n                    BaseProperty prop = origprop.clone();\n                    bobject.removeField(origname);\n                    prop.setName(newname);\n                    bobject.addField(newname, prop);\n\n                    isDirty = true;\n                }\n            }\n        }\n\n        // If at least one property was renamed, mark the document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #renameProperties(DocumentReference, Map)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void renameProperties(String className, Map<String, String> fieldsToRename)\n    {\n        renameProperties(resolveClassReference(className), fieldsToRename);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void addXObjectToRemove(BaseObject object)\n    {\n        getXObjectsToRemove().add(object);\n        object.setOwnerDocument(null);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Automatically add objects present in the old version, but not in the current document, to the list of objects\n     * marked for removal from the database.\n     *\n     * @param previousVersion the version of the document present in the database\n     * @since 3.3M2\n     */\n    public void addXObjectsToRemoveFromVersion(XWikiDocument previousVersion)\n    {\n        if (previousVersion == null) {\n            return;\n        }\n        for (List<BaseObject> objects : previousVersion.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                if (originalObj != null) {\n                    BaseObject newObj = getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    if (newObj == null) {\n                        // The object was deleted.\n                        this.addXObjectToRemove(originalObj);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectToRemove(BaseObject)} )} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void addObjectsToRemove(BaseObject object)\n    {\n        addXObjectToRemove(object);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List<BaseObject> getXObjectsToRemove()\n    {\n        return this.xObjectsToRemove;\n    }\n\n    /**\n     * @deprecated use {@link #getObjectsToRemove()} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public ArrayList<BaseObject> getObjectsToRemove()\n    {\n        return (ArrayList<BaseObject>) getXObjectsToRemove();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjectsToRemove(List<BaseObject> objectsToRemove)\n    {\n        this.xObjectsToRemove = objectsToRemove;\n        setMetaDataDirty(true);\n    }\n\n    public List<String> getIncludedPages(XWikiContext context)\n    {\n        try {\n            return getIncludedPagesInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we return an empty list of included pages. We don't want to fail by throwing an\n            // exception since it'll lead to several errors in the UI (such as in the Information Panel in edit mode).\n            LOGGER.error(\"Failed to get included pages for [{}]\", getDocumentReference(), e);\n            return Collections.emptyList();\n        }\n    }\n\n    private List<String> getIncludedPagesInternal(XWikiContext context)\n    {\n        if (is10Syntax()) {\n            return getIncludedPagesForXWiki10Syntax(getContent(), context);\n        } else {\n            // Find all include macros listed on the page\n            XDOM dom = getXDOM();\n\n            List<String> result = new ArrayList<String>();\n            List<MacroBlock> macroBlocks =\n                dom.getBlocks(new ClassBlockMatcher(MacroBlock.class), Block.Axes.DESCENDANT);\n            for (MacroBlock macroBlock : macroBlocks) {\n                // - Add each document pointed to by the include macro\n                // - Also add all the included pages found in the velocity macro when using the deprecated #include*\n                // macros\n                // This should be removed when we fully drop support for the XWiki Syntax 1.0 but for now we want to\n                // play nice with people migrating from 1.0 to 2.0 syntax\n\n                if (macroBlock.getId().equalsIgnoreCase(\"include\") || macroBlock.getId().equalsIgnoreCase(\"display\")) {\n                    String documentName = macroBlock.getParameters().get(\"reference\");\n                    if (StringUtils.isEmpty(documentName)) {\n                        documentName = macroBlock.getParameters().get(\"document\");\n                        if (StringUtils.isEmpty(documentName)) {\n                            continue;\n                        }\n                    }\n\n                    DocumentReference documentReference =\n                        getExplicitDocumentReferenceResolver().resolve(documentName, getDocumentReference());\n                    if (this.getDocumentReference().equals(documentReference)) {\n                        // Skip auto-includes since they are not allowed anyway.\n                        continue;\n                    }\n\n                    documentName = LOCAL_REFERENCE_SERIALIZER.serialize(documentReference);\n\n                    result.add(documentName);\n                } else if (macroBlock.getId().equalsIgnoreCase(\"velocity\")\n                    && !StringUtils.isEmpty(macroBlock.getContent())) {\n                    // Try to find matching content inside each velocity macro\n                    result.addAll(getIncludedPagesForXWiki10Syntax(macroBlock.getContent(), context));\n                }\n            }\n\n            return result;\n        }\n    }\n\n    private List<String> getIncludedPagesForXWiki10Syntax(String content, XWikiContext context)\n    {\n        try {\n            String pattern = \"#include(Topic|InContext|Form|Macros|parseGroovyFromPage)\\\\([\\\"'](.*?)[\\\"']\\\\)\";\n            List<String> list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, getSpace() + \".\" + name);\n                }\n            }\n\n            return list;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to extract include target from provided content [\" + content + \"]\", e);\n\n            return null;\n        }\n    }\n\n    public List<String> getIncludedMacros(XWikiContext context)\n    {\n        return context.getWiki().getIncludedMacros(getSpace(), getContent(), context);\n    }\n\n    public String displayRendered(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n        throws XWikiException\n    {\n        String result = pclass.displayView(pclass.getName(), prefix, object, context);\n        return getRenderedContent(result, Syntax.XWIKI_1_0.toIdString(), context);\n    }\n\n    public String displayView(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayView(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayEdit(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayEdit(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayHidden(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayHidden(pclass.getName(), prefix, object, context);\n    }\n\n    /**\n     * Return the first attachment of the attachment list either exactly matching the provided filename or that matches \n     * the provided filename with a n arbitrary extension (i.e., filename.ext). To get only attachments that exactly\n     * matches the provided filename use {@link #getExactAttachment(String)}.\n     * \n     * @param filename the file name of the attachment with or without the extension\n     * @return the {@link XWikiAttachment} corresponding to the file name, null if none can be found\n     * @see #getExactAttachment(String) \n     */\n    public XWikiAttachment getAttachment(String filename)\n    {\n        XWikiAttachment output = this.attachmentList.getByFilename(filename);\n        if (output != null) {\n            return output;\n        }\n\n        for (XWikiAttachment attach : getAttachmentList()) {\n            if (attach.getFilename().startsWith(filename + \".\")) {\n                return attach;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Return the attachment that exactly matches the provided file. To also get the first attachment that matches the\n     * provided filename with an arbitrary extension use {@link #getAttachment(String)}.\n     *\n     * @param filename the file name of the attachment\n     * @return the {@link XWikiAttachment} exactly corresponding to the file name, null if none can be found\n     * @since 14.1RC1\n     * @since 13.10.3\n     */\n    public XWikiAttachment getExactAttachment(String filename)\n    {\n        return this.attachmentList.getByFilename(filename);\n    }\n\n    /**\n     * Add passed attachment to the document.\n     *\n     * @param attachment the attachment to add\n     * @since 5.3M2\n     * @deprecated use {@link #setAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public void addAttachment(XWikiAttachment attachment)\n    {\n        setAttachment(attachment);\n    }\n\n    /**\n     * Insert passed attachment in the document and return any pre-existing attachment with the same name.\n     * \n     * @param attachment the attachment to insert in the document\n     * @return the attachment replaced by the passed attachment\n     * @since 9.10RC1\n     */\n    public XWikiAttachment setAttachment(XWikiAttachment attachment)\n    {\n        return this.attachmentList.set(attachment);\n    }\n\n    /**\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiAttachment addAttachment(String fileName, byte[] content, XWikiContext context) throws XWikiException\n    {\n        try {\n            return setAttachment(fileName, new ByteArrayInputStream(content != null ? content : new byte[0]), context);\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to set Attachment content\", e);\n        }\n    }\n\n    /**\n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws XWikiException never sent\n     * @throws IOException when failing to read the passed content\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public XWikiAttachment addAttachment(String fileName, InputStream content, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        return setAttachment(fileName, content, context);\n    }\n\n    /**\n     * Create or update attachment with the passed name with the passed content.\n     * \n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws IOException when failing to read the passed content\n     * @since 9.10rc1\n     */\n    public XWikiAttachment setAttachment(String fileName, InputStream content, XWikiContext context) throws IOException\n    {\n        int i = fileName.indexOf('\\\\');\n        if (i == -1) {\n            i = fileName.indexOf('/');\n        }\n\n        String filename = fileName.substring(i + 1);\n\n        XWikiAttachment attachment = getExactAttachment(filename);\n        if (attachment == null) {\n            attachment = new XWikiAttachment(this, filename);\n\n            // Add the attachment in the current doc\n            setAttachment(attachment);\n        }\n\n        attachment.setContent(content);\n        attachment.setAuthorReference(context.getUserReference());\n\n        return attachment;\n    }\n\n    public BaseObject getFirstObject(String fieldname)\n    {\n        // Keeping this function with context null for compatibility reasons.\n        // It should not be used, since it would miss properties which are only defined in the class\n        // and not present in the object because the object was not updated\n        return getFirstObject(fieldname, null);\n    }\n\n    public BaseObject getFirstObject(String fieldname, XWikiContext context)\n    {\n        Collection<List<BaseObject>> objectscoll = getXObjects().values();\n        if (objectscoll == null) {\n            return null;\n        }\n\n        for (List<BaseObject> objects : objectscoll) {\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    BaseClass bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        Set<String> set = bclass.getPropertyList();\n                        if ((set != null) && set.contains(fieldname)) {\n                            return obj;\n                        }\n                    }\n                    Set<String> set = obj.getPropertyList();\n                    if ((set != null) && set.contains(fieldname)) {\n                        return obj;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setProperty(EntityReference classReference, String fieldName, BaseProperty value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.safeput(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setProperty(EntityReference, String, BaseProperty)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setProperty(String className, String fieldName, BaseProperty value)\n    {\n        setProperty(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName)\n    {\n        return getIntValue(classReference, fieldName, 0);\n    }\n\n    /**\n     * Retrieve the int value of the given property of the first object of the given class.\n     *\n     * @param classReference the reference of the object to find\n     * @param fieldName the property to get the value from\n     * @param defaultValue the default value to return if the object doesn't exist, or if the property is not set\n     * @return the retrieved value or the default value.\n     * @since 11.9RC1\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName, int defaultValue)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return defaultValue;\n        }\n\n        return obj.getIntValue(fieldName, defaultValue);\n    }\n\n    /**\n     * @deprecated use {@link #getIntValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public int getIntValue(String className, String fieldName)\n    {\n        return getIntValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public long getLongValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return 0;\n        }\n\n        return obj.getLongValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getLongValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public long getLongValue(String className, String fieldName)\n    {\n        return getLongValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 6.2M1\n     */\n    public String getStringValue(EntityReference classReference, String fieldName)\n    {\n        return getStringValue(resolveClassReference(classReference), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public String getStringValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return \"\";\n        }\n\n        String result = obj.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getStringValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public String getStringValue(String className, String fieldName)\n    {\n        return getStringValue(resolveClassReference(className), fieldName);\n    }\n\n    public int getIntValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getIntValue(fieldName);\n        }\n    }\n\n    public long getLongValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getLongValue(fieldName);\n        }\n    }\n\n    public String getStringValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return \"\";\n        }\n\n        String result = object.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringValue(String className, String fieldName, String value)\n    {\n        setStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List getListValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return new ArrayList();\n        }\n\n        return obj.getListValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getListValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List getListValue(String className, String fieldName)\n    {\n        return getListValue(resolveClassReference(className), fieldName);\n    }\n\n    public List getListValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return new ArrayList();\n        }\n\n        return object.getListValue(fieldName);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringListValue(String className, String fieldName, List value)\n    {\n        setStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setDBStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setDBStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setDBStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setDBStringListValue(String className, String fieldName, List value)\n    {\n        setDBStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setLargeStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setLargeStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setLargeStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setLargeStringValue(String className, String fieldName, String value)\n    {\n        setLargeStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setIntValue(EntityReference classReference, String fieldName, int value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setIntValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setIntValue(EntityReference, String, int)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setIntValue(String className, String fieldName, int value)\n    {\n        setIntValue(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getDatabase()\n    {\n        return getDocumentReference().getWikiReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setDatabase(String database)\n    {\n        if (database != null) {\n            DocumentReference reference = getDocumentReference();\n            WikiReference wiki = reference.getWikiReference();\n            WikiReference newWiki = new WikiReference(database);\n            if (!newWiki.equals(wiki)) {\n                setDocumentReferenceInternal(reference.replaceParent(wiki, newWiki));\n            }\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getLanguage()\n    {\n        return getLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setLanguage(String language)\n    {\n        setLocale(LocaleUtils.toLocale(Util.normalizeLanguage(language), Locale.ROOT));\n    }\n\n    /**\n     * @return the locale of the document\n     */\n    public Locale getLocale()\n    {\n        return this.locale != null ? this.locale : Locale.ROOT;\n    }\n\n    /**\n     * @param locale the locale of the document\n     */\n    public void setLocale(Locale locale)\n    {\n        this.locale = locale;\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDefaultLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getDefaultLanguage()\n    {\n        return getDefaultLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setDefaultLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setDefaultLanguage(String defaultLanguage)\n    {\n        setDefaultLocale(LocaleUtils.toLocale(defaultLanguage, Locale.ROOT));\n    }\n\n    public Locale getDefaultLocale()\n    {\n        return this.defaultLocale != null ? this.defaultLocale : Locale.ROOT;\n    }\n\n    public void setDefaultLocale(Locale defaultLocale)\n    {\n        this.defaultLocale = defaultLocale;\n\n        setMetaDataDirty(true);\n    }\n\n    public int getTranslation()\n    {\n        return getLocale().equals(Locale.ROOT) ? 0 : 1;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's called by Hibernate when loading a XWikiDocument.\n     *\n     * @deprecated stored in the database to speedup some queries (really ?) but in {@link XWikiDocument}\n     *             it's calculated based on the document locale\n     */\n    @Deprecated(since = \"5.4.6\")\n    public void setTranslation(int translation)\n    {\n        // Do nothing\n    }\n\n    public String getTranslatedContent(XWikiContext context) throws XWikiException\n    {\n        String language = context.getWiki().getLanguagePreference(context);\n\n        return getTranslatedContent(language, context);\n    }\n\n    public String getTranslatedContent(String locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(locale, context);\n        return tdoc.getContent();\n    }\n\n    public XWikiDocument getTranslatedDocument(XWikiContext context) throws XWikiException\n    {\n        String locale = context.getWiki().getLanguagePreference(context);\n        return getTranslatedDocument(locale, context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param language the language of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     * @deprecated use {@link #getTranslatedDocument(Locale, XWikiContext)} insead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public XWikiDocument getTranslatedDocument(String language, XWikiContext context) throws XWikiException\n    {\n        return getTranslatedDocument(LocaleUtils.toLocale(language, Locale.ROOT), context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param locale the locale of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     */\n    public XWikiDocument getTranslatedDocument(Locale locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = this;\n\n        if (locale != null && !locale.equals(Locale.ROOT) && !locale.equals(getDefaultLocale())) {\n            try {\n                tdoc = context.getWiki().getDocument(new DocumentReference(getDocumentReference(), locale), context);\n\n                if (!tdoc.isNew()) {\n                    return tdoc;\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Error when loading document {} for locale {}\", getDocumentReference(), locale, e);\n            }\n\n            tdoc = getTranslatedDocument(LocaleUtils.getParentLocale(locale), context);\n        }\n\n        return tdoc;\n    }\n\n    /**\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage(XWikiContext context) throws XWikiException\n    {\n        return getRealLanguage();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getRealLanguage()\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Override\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage()\n    {\n        String lang = getLanguage();\n        if (lang.equals(\"\")) {\n            return getDefaultLanguage();\n        } else {\n            return lang;\n        }\n    }\n\n    /**\n     * @return the actual locale of the document\n     */\n    public Locale getRealLocale()\n    {\n        Locale locale = getLocale();\n        if (locale.equals(Locale.ROOT)) {\n            locale = getDefaultLocale();\n        }\n\n        return locale;\n    }\n\n    /**\n     * @deprecated use {@link #getTranslationLocales(XWikiContext)} instead\n     */\n    @Deprecated(since = \"5.1M2\")\n    public List<String> getTranslationList(XWikiContext context) throws XWikiException\n    {\n        // in few cases like accessing a deleted document, the store might be null.\n        if (getStore() != null) {\n            return getStore().getTranslationList(this, context);\n        } else {\n            return Collections.emptyList();\n        }\n\n    }\n\n    /**\n     * The locales of the translation of this document (the default locale is not included).\n     *\n     * @param context the XWiki context\n     * @return the locales of the translations\n     * @throws XWikiException if retriving the translations from the database failed\n     */\n    public List<Locale> getTranslationLocales(XWikiContext context) throws XWikiException\n    {\n        List<String> translations = getTranslationList(context);\n\n        List<Locale> locales = new ArrayList<Locale>(translations.size());\n        for (String translationString : translations) {\n            locales.add(LocaleUtils.toLocale(translationString));\n        }\n\n        return locales;\n    }\n\n    public List<Delta> getXMLDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.toXML(context)), ToString.stringToArray(toDoc.toXML(context))));\n    }\n\n    public List<Delta> getContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.getContent()), ToString.stringToArray(toDoc.getContent())));\n    }\n\n    public List<Delta> getContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n        if (fromDoc == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", fromRev,\n                    this.getDocumentReference()));\n        }\n        if (toRev == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", toRev,\n                    this.getDocumentReference()));\n        }\n        return getContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n        return getContentDiff(revdoc, this, context);\n    }\n\n    public List<Delta> getLastChanges(XWikiContext context) throws XWikiException, DifferentiationFailedException\n    {\n        Version version = getRCSVersion();\n        try {\n            String prev = getDocumentArchive(context).getPrevVersion(version).toString();\n            XWikiDocument prevDoc = context.getWiki().getDocument(this, prev, context);\n\n            return getDeltas(\n                Diff.diff(ToString.stringToArray(prevDoc.getContent()), ToString.stringToArray(getContent())));\n        } catch (Exception ex) {\n            LOGGER.debug(\"Exception getting differences from previous version: \" + ex.getMessage());\n        }\n\n        return new ArrayList<Delta>();\n    }\n\n    public List<Delta> getRenderedContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        String originalContent = fromDoc.getRenderedContent(context);\n        String newContent = toDoc.getRenderedContent(context);\n\n        return getDeltas(Diff.diff(ToString.stringToArray(originalContent), ToString.stringToArray(newContent)));\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getRenderedContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getRenderedContentDiff(revdoc, this, context);\n    }\n\n    protected List<Delta> getDeltas(Revision rev)\n    {\n        List<Delta> list = new ArrayList<Delta>();\n        for (int i = 0; i < rev.size(); i++) {\n            list.add(rev.getDelta(i));\n        }\n\n        return list;\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, String toRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getMetaDataDiff(fromDoc, toDoc, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getMetaDataDiff(revdoc, this, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException\n    {\n        List<MetaDataDiff> list = new ArrayList<MetaDataDiff>();\n\n        if (fromDoc == null || toDoc == null) {\n            return list;\n        }\n\n        if (!fromDoc.getTitle().equals(toDoc.getTitle())) {\n            list.add(new MetaDataDiff(\"title\", fromDoc.getTitle(), toDoc.getTitle()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getRelativeParentReference(), toDoc.getRelativeParentReference())) {\n            list.add(new MetaDataDiff(\"parent\", fromDoc.getParent(), toDoc.getParent()));\n        }\n\n        UserReference fromDocOriginalAuthor = fromDoc.getAuthors().getOriginalMetadataAuthor();\n        UserReference toDocOriginalAuthor = toDoc.getAuthors().getOriginalMetadataAuthor();\n        if (ObjectUtils.notEqual(fromDocOriginalAuthor, toDocOriginalAuthor)) {\n            list.add(new MetaDataDiff(\"author\", userReferenceToString(fromDocOriginalAuthor),\n                userReferenceToString(toDocOriginalAuthor)));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDocumentReference(), toDoc.getDocumentReference())) {\n            list.add(new MetaDataDiff(\"reference\", fromDoc.getDocumentReference(), toDoc.getDocumentReference()));\n        }\n\n        if (!fromDoc.getSpace().equals(toDoc.getSpace())) {\n            list.add(new MetaDataDiff(\"web\", fromDoc.getSpace(), toDoc.getSpace()));\n        }\n\n        if (!fromDoc.getName().equals(toDoc.getName())) {\n            list.add(new MetaDataDiff(\"name\", fromDoc.getName(), toDoc.getName()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getLocale(), toDoc.getLocale())) {\n            list.add(new MetaDataDiff(\"language\", fromDoc.getLanguage(), toDoc.getLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDefaultLocale(), toDoc.getDefaultLocale())) {\n            list.add(new MetaDataDiff(\"defaultLanguage\", fromDoc.getDefaultLanguage(), toDoc.getDefaultLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getSyntax(), toDoc.getSyntax())) {\n            list.add(new MetaDataDiff(\"syntax\", fromDoc.getSyntax(), toDoc.getSyntax()));\n        }\n\n        if (fromDoc.isHidden() != toDoc.isHidden()) {\n            list.add(new MetaDataDiff(\"hidden\", fromDoc.isHidden(), toDoc.isHidden()));\n        }\n\n        return list;\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getObjectDiff(fromDoc, toDoc, context);\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getObjectDiff(revdoc, this, context);\n    }\n\n    /**\n     * Return the object differences between two document versions. There is no hard requirement on the order of the two\n     * versions, but the results are semantically correct only if the two versions are given in the right order.\n     *\n     * @param fromDoc The old ('before') version of the document.\n     * @param toDoc The new ('after') version of the document.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return The object differences. The returned list's elements are other lists, one for each changed object. The\n     *         inner lists contain {@link ObjectDiff} elements, one object for each changed property of the object.\n     *         Additionally, if the object was added or removed, then the first entry in the list will be an\n     *         \"object-added\" or \"object-removed\" marker.\n     */\n    public List<List<ObjectDiff>> getObjectDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n\n        // Since objects could have been deleted or added, we iterate on both the old and the new\n        // object collections.\n        // First, iterate over the old objects.\n        for (List<BaseObject> objects : fromDoc.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (originalObj != null) {\n                    BaseObject newObj = toDoc.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    List<ObjectDiff> dlist;\n                    if (newObj == null) {\n                        // The object was deleted.\n                        dlist = new BaseObject().getDiff(originalObj, context);\n                        ObjectDiff deleteMarker =\n                            new ObjectDiff(originalObj.getXClassReference(), originalObj.getNumber(),\n                                originalObj.getGuid(), ObjectDiff.ACTION_OBJECTREMOVED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, deleteMarker);\n                    } else {\n                        // The object exists in both versions, but might have been changed.\n                        dlist = newObj.getDiff(originalObj, context);\n                    }\n                    if (!dlist.isEmpty()) {\n                        difflist.add(dlist);\n                    }\n                }\n            }\n        }\n\n        // Second, iterate over the objects which are only in the new version.\n        for (List<BaseObject> objects : toDoc.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (newObj != null) {\n                    BaseObject originalObj = fromDoc.getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // TODO: Refactor this so that getDiff() accepts null Object as input.\n                        // Only consider added objects, the other case was treated above.\n                        originalObj = new BaseObject();\n                        originalObj.setXClassReference(newObj.getRelativeXClassReference());\n                        originalObj.setNumber(newObj.getNumber());\n                        originalObj.setGuid(newObj.getGuid());\n                        List<ObjectDiff> dlist = newObj.getDiff(originalObj, context);\n                        ObjectDiff addMarker = new ObjectDiff(newObj.getXClassReference(), newObj.getNumber(),\n                            newObj.getGuid(), ObjectDiff.ACTION_OBJECTADDED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, addMarker);\n                        if (!dlist.isEmpty()) {\n                            difflist.add(dlist);\n                        }\n                    }\n                }\n            }\n        }\n\n        return difflist;\n    }\n\n    public List<List<ObjectDiff>> getClassDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n        BaseClass oldClass = fromDoc.getXClass();\n        BaseClass newClass = toDoc.getXClass();\n\n        if ((newClass == null) && (oldClass == null)) {\n            return difflist;\n        }\n\n        List<ObjectDiff> dlist = newClass.getDiff(oldClass, context);\n        if (!dlist.isEmpty()) {\n            difflist.add(dlist);\n        }\n\n        return difflist;\n    }\n\n    /**\n     * @param fromDoc\n     * @param toDoc\n     * @param context\n     * @return\n     */\n    public List<AttachmentDiff> getAttachmentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<AttachmentDiff> difflist = new ArrayList<AttachmentDiff>();\n        for (XWikiAttachment origAttach : fromDoc.getAttachmentList()) {\n            String fileName = origAttach.getFilename();\n            XWikiAttachment newAttach = toDoc.getAttachment(fileName);\n            origAttach = retrieveDeletedAttachment(fromDoc, origAttach, context);\n            if (newAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.DELETE, origAttach, newAttach));\n            } else {\n                newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n                try {\n                    if (!origAttach.equalsData(newAttach, context)) {\n                        difflist\n                            .add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.CHANGE, origAttach, newAttach));\n                    }\n                } catch (XWikiException e) {\n                    LOGGER.error(\"Failed to compare attachments [{}] and [{}]\", origAttach.getReference(),\n                        newAttach.getReference(), e);\n                }\n            }\n        }\n\n        for (XWikiAttachment newAttach : toDoc.getAttachmentList()) {\n            String fileName = newAttach.getFilename();\n            XWikiAttachment origAttach = fromDoc.getAttachment(fileName);\n            newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n            if (origAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.INSERT, origAttach, newAttach));\n            }\n        }\n\n        return difflist;\n    }\n\n    private XWikiAttachment retrieveDeletedAttachment(XWikiDocument doc, XWikiAttachment attachment,\n        XWikiContext context)\n    {\n        XWikiAttachment result = null;\n\n        InputStream is = null;\n        try {\n            is = attachment.getContentInputStream(context);\n            if (is == null) {\n                AttachmentRecycleBinStore attachmentRecycleBinStore = context.getWiki().getAttachmentRecycleBinStore();\n                List<DeletedAttachment> allDeletedAttachments =\n                    attachmentRecycleBinStore.getAllDeletedAttachments(doc, context, true);\n\n                for (DeletedAttachment deletedAttachment : allDeletedAttachments) {\n                    XWikiAttachment restoredAttachment = deletedAttachment.restoreAttachment();\n                    if (restoredAttachment.getDate().before(attachment.getDate())) {\n                        break;\n                    }\n                    result = restoredAttachment;\n                }\n\n                if (result != null) {\n                    if (!Objects.equals(attachment.getVersion(), result.getVersion())) {\n                        result = result.getAttachmentRevision(attachment.getVersion(), context);\n                    }\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Error while trying to load deleted attachment [{}] for doc [{}]\", attachment, doc, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException ex) {\n\n                }\n            }\n        }\n\n        if (result == null) {\n            result = attachment;\n        } else {\n            result.setDoc(doc);\n        }\n        return result;\n    }\n\n    /**\n     * Rename the current document and all the backlinks leading to it. Will also change parent field in all documents\n     * which list the document we are renaming as their parent.\n     * <p>\n     * See {@link #rename(DocumentReference, List, List, XWikiContext)} for more details.\n     *\n     * @param newDocumentReference the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, getBackLinkedReferences(context), context);\n    }\n\n    /**\n     * Rename the current document and all the links pointing to it in the list of passed backlink documents. The\n     * renaming algorithm takes into account the fact that there are several ways to write a link to a given page and\n     * all those forms need to be renamed. For example the following links all point to the same page:\n     * <ul>\n     * <li>[Page]</li>\n     * <li>[Page?param=1]</li>\n     * <li>[currentwiki:Page]</li>\n     * <li>[CurrentSpace.Page]</li>\n     * <li>[currentwiki:CurrentSpace.Page]</li>\n     * </ul>\n     * <p>\n     * Note: links without a space are renamed with the space added and all documents which have the document being\n     * renamed as parent have their parent field set to \"currentwiki:CurrentSpace.Page\".\n     * </p>\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, backlinkDocumentReferences, getChildrenReferences(context), context);\n    }\n\n    /**\n     * Same as {@link #rename(DocumentReference, List, XWikiContext)} but the list of documents having the current\n     * document as their parent is passed in parameter.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context) throws XWikiException\n    {\n        // TODO: Do all this in a single DB transaction as otherwise the state will be unknown if\n        // something fails in the middle...\n\n        // TODO: Why do we verify if the document has just been created and not been saved.\n        // If the user is trying to rename to the same name... In that case, simply exits for efficiency.\n        if (isNew() || getDocumentReference().equals(newDocumentReference)) {\n            return;\n        }\n        context.getWiki().renameByCopyAndDelete(this,\n            newDocumentReference,\n            backlinkDocumentReferences,\n            childDocumentReferences, context);\n    }\n\n    /**\n     * Clone a document and change its reference.\n     *\n     * @param newDocumentReference the new reference of the cloned document.\n     * @param context the current context.\n     * @return a clone of the current document with a new reference.\n     * @throws XWikiException in case of problem during the clone operation.\n     * @since 12.5RC1\n     */\n    public XWikiDocument cloneRename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        loadAttachments(context);\n        loadArchive(context);\n        return this.cloneInternal(newDocumentReference, true, true);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        return copyDocument(newDocumentReference, true, context);\n    }\n\n    /**\n     * @since 14.3RC1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, boolean cloneArchive, XWikiContext context)\n        throws XWikiException\n    {\n        loadAttachments(context);\n        if (cloneArchive) {\n            loadArchive(context);\n        }\n\n        XWikiDocument newdoc = cloneInternal(newDocumentReference, false, cloneArchive);\n\n        // If the copied document has a title set to the original page name then set the new title to be the new page\n        // name.\n        if (StringUtils.equals(newdoc.getTitle(), getPrettyName(this.getDocumentReference()))) {\n            newdoc.setTitle(getPrettyName(newDocumentReference));\n        }\n\n        newdoc.setOriginalDocument(null);\n        newdoc.setContentDirty(true);\n        newdoc.setNew(true);\n\n        return newdoc;\n    }\n\n    /**\n     * Avoid the technical \"WebHome\" name.\n     *\n     * @param documentReference a document reference\n     * @return the last space name if the document is the home of a space, the document name otherwise\n     */\n    private String getPrettyName(DocumentReference documentReference)\n    {\n        EntityReferenceProvider defaultEntityReferenceProvider = Utils.getComponent(EntityReferenceProvider.class);\n        if (defaultEntityReferenceProvider.getDefaultReference(documentReference.getType()).getName()\n            .equals(documentReference.getName())) {\n            return documentReference.getLastSpaceReference().getName();\n        }\n        return documentReference.getName();\n    }\n\n    /**\n     * @deprecated use {@link #copyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument copyDocument(String newDocumentName, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), context);\n    }\n\n    public XWikiLock getLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock theLock = getStore(context).loadLock(getId(), context, true);\n        if (theLock != null) {\n            int timeout = context.getWiki().getXWikiPreferenceAsInt(\"lock_Timeout\", 30 * 60, context);\n            if (theLock.getDate().getTime() + timeout * 1000 < new Date().getTime()) {\n                getStore(context).deleteLock(theLock, context, true);\n                theLock = null;\n            }\n        }\n\n        return theLock;\n    }\n\n    public void setLock(String userName, XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = new XWikiLock(getId(), userName);\n        getStore(context).saveLock(lock, context, true);\n    }\n\n    public void removeLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = getStore(context).loadLock(getId(), context, true);\n        if (lock != null) {\n            getStore(context).deleteLock(lock, context, true);\n        }\n    }\n\n    public void insertText(String text, String marker, XWikiContext context) throws XWikiException\n    {\n        setContent(StringUtils.replaceOnce(getContent(), marker, text + marker));\n        context.getWiki().saveDocument(this, context);\n    }\n\n    public Object getWikiNode()\n    {\n        return this.wikiNode;\n    }\n\n    public void setWikiNode(Object wikiNode)\n    {\n        this.wikiNode = wikiNode;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String getXClassXML()\n    {\n        return this.xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #getXClassXML()} instead as Hibernate uses this through reflection. It cannot be\n     *             removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getxWikiClassXML()\n    {\n        return getXClassXML();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClassXML(String xClassXML)\n    {\n        this.xClassXML = xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #setXClassXML(String)} ()} instead as Hibernate uses this through reflection. It\n     *             cannot be removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setxWikiClassXML(String xClassXML)\n    {\n        setXClassXML(xClassXML);\n    }\n\n    public int getElements()\n    {\n        return this.elements;\n    }\n\n    public void setElements(int elements)\n    {\n        this.elements = elements;\n    }\n\n    public void setElement(int element, boolean toggle)\n    {\n        if (toggle) {\n            this.elements = this.elements | element;\n        } else {\n            this.elements = this.elements & (~element);\n        }\n    }\n\n    public boolean hasElement(int element)\n    {\n        return ((this.elements & element) == element);\n    }\n\n    /**\n     * Gets the default edit mode for this document. An edit mode (other than the default \"edit\") can be enforced by\n     * creating an {@code XWiki.EditModeClass} object in the current document, with the appropriate value for the\n     * defaultEditMode property, or by adding this object in a sheet included by the document. This function also falls\n     * back on the old {@code SheetClass}, deprecated since 3.1M2, which can be attached to included documents to\n     * specify that the current document should be edited inline.\n     *\n     * @return the default edit mode for this document (\"edit\" or \"inline\" usually)\n     * @param context the context of the request for this document\n     * @throws XWikiException since XWiki 6.3M1 it's not used anymore and \"edit\" is returned in case of error, with an\n     *             error log\n     */\n    public String getDefaultEditMode(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getDefaultEditModeInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we default to the \"edit\" mode. We don't want to fail by throwing an exception\n            // since it'll lead to several errors in the UI (such as when evaluating contentview.vm for example).\n            LOGGER.error(\"Failed to get the default edit mode for [{}]\", getDocumentReference(), e);\n            return \"edit\";\n        }\n    }\n\n    private String getDefaultEditModeInternal(XWikiContext context) throws XWikiException\n    {\n        String editModeProperty = \"defaultEditMode\";\n        DocumentReference editModeClass =\n            getCurrentReferenceDocumentReferenceResolver().resolve(XWikiConstant.EDIT_MODE_CLASS);\n        // check if the current document has any edit mode class object attached to it, and read the edit mode from it\n        BaseObject editModeObject = this.getXObject(editModeClass);\n        if (editModeObject != null) {\n            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n            if (StringUtils.isEmpty(defaultEditMode)) {\n                return \"edit\";\n            } else {\n                return defaultEditMode;\n            }\n        }\n        // otherwise look for included documents\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        if (is10Syntax()) {\n            if (getContent().indexOf(\"includeForm(\") != -1) {\n                return \"inline\";\n            }\n        } else {\n            // Algorithm: look in all include macros and for all document included check if one of them\n            // has an EditModeClass object attached to it, or a SheetClass object (deprecated since 3.1M2) attached to\n            // it. If so then the edit mode is inline.\n\n            // Find all include macros and extract the document names\n            // TODO: Is there a good way not to hardcode the macro name? The macro itself shouldn't know\n            // its own name since it's a deployment time concern.\n            for (Block macroBlock : getXDOM().getBlocks(new MacroBlockMatcher(\"include\"), Axes.CHILD)) {\n                // Find the document reference to include by checking the macro's \"reference\" parameter.\n                // For backward-compatibility we also check for a \"document\" parameter since this is the parameter name\n                // that was used prior to XWiki 3.4M1 when the \"reference\" one was introduced and thus when the\n                // \"document\" one was deprecated.\n                String includedDocumentReference = macroBlock.getParameter(\"reference\");\n                if (includedDocumentReference == null) {\n                    includedDocumentReference = macroBlock.getParameter(\"document\");\n                }\n                if (includedDocumentReference != null) {\n                    // Resolve the document name into a valid Reference\n                    DocumentReference documentReference =\n                        getCurrentMixedDocumentReferenceResolver().resolve(includedDocumentReference);\n                    XWikiDocument includedDocument = xwiki.getDocument(documentReference, context);\n                    if (!includedDocument.isNew()) {\n                        // get the edit mode object, first the new class and then the deprecated class if new class\n                        // is not found\n                        editModeObject = includedDocument.getXObject(editModeClass);\n                        if (editModeObject == null) {\n                            editModeObject = includedDocument.getXObject(SHEETCLASS_REFERENCE);\n                        }\n                        if (editModeObject != null) {\n                            // Use the user-defined default edit mode if set.\n                            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n                            if (StringUtils.isBlank(defaultEditMode)) {\n                                // TODO: maybe here the real value should be returned if the object is edit mode class,\n                                // and inline only if the object is sheetclass\n                                return \"inline\";\n                            } else {\n                                return defaultEditMode;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return \"edit\";\n    }\n\n    public String getDefaultEditURL(XWikiContext context) throws XWikiException\n    {\n        String editMode = getDefaultEditMode(context);\n\n        if (\"inline\".equals(editMode)) {\n            return getEditURL(\"inline\", \"\", context);\n        } else {\n            com.xpn.xwiki.XWiki xwiki = context.getWiki();\n            String editor = xwiki.getEditorPreference(context);\n            return getEditURL(\"edit\", editor, context);\n        }\n    }\n\n    public String getEditURL(String action, String mode, XWikiContext context) throws XWikiException\n    {\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        String language = \"\";\n        XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n        String realLang = tdoc.getRealLanguage(context);\n        if ((xwiki.isMultiLingual(context) == true) && (!realLang.equals(\"\"))) {\n            language = realLang;\n        }\n\n        return getEditURL(action, mode, language, context);\n    }\n\n    public String getEditURL(String action, String mode, String language, XWikiContext context)\n    {\n        StringBuilder editparams = new StringBuilder();\n        if (!mode.equals(\"\")) {\n            editparams.append(\"xpage=\");\n            editparams.append(mode);\n        }\n\n        if (!language.equals(\"\")) {\n            if (!mode.equals(\"\")) {\n                editparams.append(\"&\");\n            }\n            editparams.append(\"language=\");\n            editparams.append(language);\n        }\n\n        return getURL(action, editparams.toString(), context);\n    }\n\n    public String getDefaultTemplate()\n    {\n        if (this.defaultTemplate == null) {\n            return \"\";\n        } else {\n            return this.defaultTemplate;\n        }\n    }\n\n    public void setDefaultTemplate(String defaultTemplate)\n    {\n        this.defaultTemplate = defaultTemplate;\n\n        setMetaDataDirty(true);\n    }\n\n    public Vector<BaseObject> getComments()\n    {\n        return getComments(true);\n    }\n\n    /**\n     * @return the syntax of the document\n     * @since 2.3M1\n     */\n    @Override\n    public Syntax getSyntax()\n    {\n        // Can't be initialized in the XWikiDocument constructor because #getDefaultDocumentSyntax() need to create a\n        // XWikiDocument object to get preferences from wiki preferences pages and would thus generate an infinite loop\n        if (isNew() && this.syntax == null) {\n            this.syntax = getDefaultDocumentSyntax();\n        }\n\n        return this.syntax;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     * </p>\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getSyntaxId()\n     * @deprecated use {link #getSyntax()} instead\n     */\n    @Override\n    @Deprecated(since = \"2.3M1\")\n    public String getSyntaxId()\n    {\n        return getSyntax().toIdString();\n    }\n\n    /**\n     * @param syntax the new syntax to set for this document\n     * @see #getSyntax()\n     * @since 2.3M1\n     */\n    public void setSyntax(Syntax syntax)\n    {\n        if (ObjectUtils.notEqual(this.syntax, syntax)) {\n            this.syntax = syntax;\n            // invalidate parsed xdom\n            this.xdomCache = null;\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @param syntaxId the new syntax id to set (e.g. {@code xwiki/2.0}, {@code xwiki/2.1}, etc)\n     * @see #getSyntaxId()\n     * @deprecated use {link #setSyntax(Syntax)} instead\n     */\n    @Deprecated(since = \"2.3M1\")\n    public void setSyntaxId(String syntaxId)\n    {\n        Syntax syntax;\n\n        // In order to preserve backward-compatibility with previous versions of XWiki in which the notion of Syntax Id\n        // did not exist, we check the passed syntaxId parameter. Since this parameter comes from the database (it's\n        // called automatically by Hibernate) it can be NULL or empty. In this case we consider the document is in\n        // syntax/1.0 syntax.\n        if (StringUtils.isBlank(syntaxId)) {\n            syntax = Syntax.XWIKI_1_0;\n        } else {\n            syntax = resolveSyntax(syntaxId);\n        }\n\n        setSyntax(syntax);\n    }\n\n    public Vector<BaseObject> getComments(boolean asc)\n    {\n        List<BaseObject> list = getXObjects(COMMENTSCLASS_REFERENCE);\n        if (list == null) {\n            return null;\n        } else if (asc) {\n            return new Vector<BaseObject>(list);\n        } else {\n            Vector<BaseObject> newlist = new Vector<BaseObject>();\n            for (int i = list.size() - 1; i >= 0; i--) {\n                newlist.add(list.get(i));\n            }\n            return newlist;\n        }\n    }\n\n    public boolean isCurrentUserCreator(XWikiContext context)\n    {\n        return isCreator(context.getUserReference());\n    }\n\n    /**\n     * @deprecated use {@link #isCreator(DocumentReference)} instead\n     */\n    @Deprecated\n    public boolean isCreator(String username)\n    {\n        if (username.equals(XWikiRightService.GUEST_USER_FULLNAME)) {\n            return false;\n        }\n\n        return username.equals(getCreator());\n    }\n\n    public boolean isCreator(DocumentReference username)\n    {\n        if (username == null) {\n            return false;\n        }\n\n        return username.equals(getCreatorReference());\n    }\n\n    public boolean isCurrentUserPage(XWikiContext context)\n    {\n        DocumentReference userReference = context.getUserReference();\n        if (userReference == null) {\n            return false;\n        }\n\n        return userReference.equals(getDocumentReference());\n    }\n\n    public boolean isCurrentLocalUserPage(XWikiContext context)\n    {\n        final DocumentReference userRef = context.getUserReference();\n        return userRef != null && userRef.equals(this.getDocumentReference());\n    }\n\n    public void resetArchive(XWikiContext context) throws XWikiException\n    {\n        boolean hasVersioning = context.getWiki().hasVersioning(context);\n        if (hasVersioning) {\n            WikiReference currentWiki = context.getWikiReference();\n            try {\n                context.setWikiReference(getDocumentReference().getWikiReference());\n\n                getVersioningStore(context).resetRCSArchive(this, true, context);\n            } finally {\n                context.setWikiReference(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(XWikiContext context) throws XWikiException\n    {\n        // Read info in object\n        ObjectAddForm form = new ObjectAddForm();\n        form.setRequest(context.getRequest());\n        form.readRequest();\n\n        EntityReference classReference = getXClassEntityReferenceResolver().resolve(form.getClassName(),\n            EntityType.DOCUMENT, getDocumentReference());\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        baseclass.fromMap(form.getObject(LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference))),\n            object);\n\n        return object;\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(classReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(addXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(resolveClassReference(className), pref, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", num, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, int num, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", num, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        String newPrefix =\n            prefix + LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference)) + \"_\" + num;\n        baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), object);\n\n        return object;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(resolveClassReference(className), prefix, num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        int nb;\n        BaseObject oldobject = getXObject(absoluteClassReference, num);\n        if (oldobject == null) {\n            nb = createXObject(classReference, context);\n            oldobject = getXObject(absoluteClassReference, nb);\n        } else {\n            nb = oldobject.getNumber();\n        }\n        BaseClass baseclass = oldobject.getXClass(context);\n        String newPrefix = prefix + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\" + nb;\n        BaseObject newobject =\n            (BaseObject) baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), oldobject);\n        newobject.setNumber(oldobject.getNumber());\n        newobject.setGuid(oldobject.getGuid());\n        setXObject(nb, newobject);\n\n        return newobject;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), prefix,\n            num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(updateXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), pref,\n            context);\n    }\n\n    public boolean isAdvancedContent()\n    {\n        String[] matches = { \"<%\", \"#set\", \"#include\", \"#if\", \"public class\", \"/* Advanced content */\",\n        \"## Advanced content\", \"/* Programmatic content */\", \"## Programmatic content\" };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        if (HTML_TAG_PATTERN.matcher(content2).find()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean isProgrammaticContent()\n    {\n        String[] matches = { \"<%\", \"\\\\$xwiki.xWiki\", \"$xcontext.context\", \"$doc.document\", \"$xwiki.getXWiki()\",\n        \"$xcontext.getContext()\", \"$doc.getDocument()\", \"WithProgrammingRights(\", \"/* Programmatic content */\",\n        \"## Programmatic content\", \"$xwiki.search(\", \"$xwiki.createUser\", \"$xwiki.createNewWiki\",\n        \"$xwiki.addToAllGroup\", \"$xwiki.sendMessage\", \"$xwiki.copyDocument\", \"$xwiki.copyWikiWeb\",\n        \"$xwiki.copySpaceBetweenWikis\", \"$xwiki.parseGroovyFromString\", \"$doc.toXML()\", \"$doc.toXMLDocument()\", };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObject(BaseObject object)\n    {\n        List<BaseObject> objects = this.xObjects.get(object.getXClassReference());\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Sometimes the object vector is wrongly indexed, meaning that objects are not at the right position\n        // Check if the right object is in place\n        int objectPosition = object.getNumber();\n        if (objectPosition < objects.size()) {\n            BaseObject storedObject = objects.get(objectPosition);\n            if (storedObject == null || !storedObject.equals(object)) {\n                // Try to find the correct position\n                objectPosition = objects.indexOf(object);\n            }\n        } else {\n            // The object position is greater than the array, that's invalid!\n            objectPosition = -1;\n        }\n        // If the object is not in the document, simply ignore this request\n        if (objectPosition < 0) {\n            return false;\n        }\n        // We don't remove objects, but set null in their place, so that the object number corresponds to its position\n        // in the vector\n        objects.set(objectPosition, null);\n        // Schedule the object for removal from the storage\n        addXObjectToRemove(object);\n\n        return true;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @deprecated use {@link #removeXObject(com.xpn.xwiki.objects.BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObject(BaseObject object)\n    {\n        return removeXObject(object);\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param classReference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Schedule the object for removal from the storage\n        for (BaseObject object : objects) {\n            if (object != null) {\n                addXObjectToRemove(object);\n            }\n        }\n        // Empty the vector, retaining its size\n        int currentSize = objects.size();\n        objects.clear();\n        for (int i = 0; i < currentSize; i++) {\n            objects.add(null);\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param reference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 5.0M1\n     */\n    public boolean removeXObjects(EntityReference reference)\n    {\n        return removeXObjects(\n            getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param className The class name of the objects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @deprecated use {@link #removeXObjects(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObjects(String className)\n    {\n        return removeXObjects(resolveClassReference(className));\n    }\n\n    /**\n     * Get the top sections contained in the document.\n     * <p>\n     * The section are filtered by xwiki.section.depth property on the maximum depth of the sections to return. This\n     * method is usually used to get \"editable\" sections.\n     *\n     * @return the sections in the current document\n     */\n    public List<DocumentSection> getSections() throws XWikiException\n    {\n        if (is10Syntax()) {\n            return getSections10();\n        } else {\n            List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            int sectionNumber = 1;\n            for (HeaderBlock header : headers) {\n                // put -1 as index since there is no way to get the position of the header in the source\n                int documentSectionIndex = -1;\n\n                // Need to do the same thing than 1.0 content here\n                String documentSectionLevel = StringUtils.repeat(\"1.\", header.getLevel().getAsInt() - 1) + \"1\";\n\n                DocumentSection docSection = new DocumentSection(sectionNumber++, documentSectionIndex,\n                    documentSectionLevel, renderXDOM(new XDOM(header.getChildren()), getSyntax()));\n                splitSections.add(docSection);\n            }\n\n            return splitSections;\n        }\n    }\n\n    /**\n     * Get XWiki context from execution context.\n     *\n     * @return the XWiki context for the current thread\n     */\n    private XWikiContext getXWikiContext()\n    {\n        Provider<XWikiContext> xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n\n        if (xcontextProvider != null) {\n            return xcontextProvider.get();\n        }\n\n        return null;\n    }\n\n    /**\n     * Filter the headers from a document XDOM based on xwiki.section.depth property from xwiki.cfg file.\n     *\n     * @return the filtered headers\n     */\n    private List<HeaderBlock> getFilteredHeaders()\n    {\n        List<HeaderBlock> filteredHeaders = new ArrayList<HeaderBlock>();\n\n        // Get the maximum header level\n        int sectionDepth = 2;\n        XWikiContext context = getXWikiContext();\n        if (context != null) {\n            sectionDepth = (int) context.getWiki().getSectionEditingDepth();\n        }\n\n        // Get the headers.\n        //\n        // Note that we need to only take into account SectionBlock that are children of other SectionBlocks so that\n        // we are in sync with the section editing buttons added in xwiki.js. Being able to section edit any heading is\n        // too complex. For example if you have (in XWiki Syntax 2.0):\n        // = Heading1 =\n        // para1\n        // == Heading2 ==\n        // para2\n        // (((\n        // == Heading3 ==\n        // para3\n        // (((\n        // == Heading4 ==\n        // para4\n        // )))\n        // )))\n        // == Heading5 ==\n        // para5\n        //\n        // Then if we were to support editing \"Heading4\", its content would be:\n        // para4\n        // )))\n        // )))\n        //\n        // Which obviously is not correct...\n\n        final XDOM xdom = getXDOM();\n        if (!xdom.getChildren().isEmpty()) {\n            Block currentBlock = xdom.getChildren().get(0);\n            while (currentBlock != null) {\n                if (currentBlock instanceof SectionBlock) {\n                    // The next children block is a HeaderBlock but we check to be on the safe side...\n                    Block nextChildrenBlock = currentBlock.getChildren().get(0);\n                    if (nextChildrenBlock instanceof HeaderBlock) {\n                        HeaderBlock headerBlock = (HeaderBlock) nextChildrenBlock;\n                        if (headerBlock.getLevel().getAsInt() <= sectionDepth) {\n                            filteredHeaders.add(headerBlock);\n                        }\n                    }\n                    currentBlock = nextChildrenBlock;\n                } else {\n                    Block nextSibling = currentBlock.getNextSibling();\n                    if (nextSibling == null) {\n                        currentBlock = currentBlock.getParent();\n                        while (currentBlock != null) {\n                            if (currentBlock.getNextSibling() != null) {\n                                currentBlock = currentBlock.getNextSibling();\n                                break;\n                            }\n                            currentBlock = currentBlock.getParent();\n                        }\n                    } else {\n                        currentBlock = nextSibling;\n                    }\n                }\n            }\n        }\n\n        return filteredHeaders;\n    }\n\n    /**\n     * @return the sections in the current document\n     */\n    private List<DocumentSection> getSections10()\n    {\n        // Pattern to match the title. Matches only level 1 and level 2 headings.\n        Pattern headingPattern = Pattern.compile(\"^[ \\\\t]*+(1(\\\\.1){0,1}+)[ \\\\t]++(.++)$\", Pattern.MULTILINE);\n        Matcher matcher = headingPattern.matcher(getContent());\n        List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n        int sectionNumber = 0;\n        // find title to split\n        while (matcher.find()) {\n            ++sectionNumber;\n            String sectionLevel = matcher.group(1);\n            String sectionTitle = matcher.group(3);\n            int sectionIndex = matcher.start();\n            // Initialize a documentSection object.\n            DocumentSection docSection = new DocumentSection(sectionNumber, sectionIndex, sectionLevel, sectionTitle);\n            // Add the document section to list.\n            splitSections.add(docSection);\n        }\n\n        return splitSections;\n    }\n\n    /**\n     * Return a Document section with parameter is sectionNumber.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return\n     * @throws XWikiException error when extracting sections from document\n     */\n    public DocumentSection getDocumentSection(int sectionNumber) throws XWikiException\n    {\n        // return a document section according to section number\n        return getSections().get(sectionNumber - 1);\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section or null if the section can't be found.\n     * @throws XWikiException error when trying to extract section content\n     */\n    public String getContentOfSection(int sectionNumber) throws XWikiException\n    {\n        String content = null;\n\n        if (is10Syntax()) {\n            content = getContentOfSection10(sectionNumber);\n        } else {\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            if (headers.size() >= sectionNumber) {\n                SectionBlock section = headers.get(sectionNumber - 1).getSection();\n                content = renderXDOM(new XDOM(Collections.<Block>singletonList(section)), getSyntax());\n            }\n        }\n\n        return content;\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section\n     * @throws XWikiException error when trying to extract section content\n     */\n    private String getContentOfSection10(int sectionNumber) throws XWikiException\n    {\n        List<DocumentSection> splitSections = getSections();\n        int indexEnd = 0;\n        // get current section\n        DocumentSection section = splitSections.get(sectionNumber - 1);\n        int indexStart = section.getSectionIndex();\n        String sectionLevel = section.getSectionLevel();\n        // Determine where this section ends, which is at the start of the next section of the\n        // same or a higher level.\n        for (int i = sectionNumber; i < splitSections.size(); i++) {\n            DocumentSection nextSection = splitSections.get(i);\n            String nextLevel = nextSection.getSectionLevel();\n            if (sectionLevel.equals(nextLevel) || sectionLevel.length() > nextLevel.length()) {\n                indexEnd = nextSection.getSectionIndex();\n                break;\n            }\n        }\n        String sectionContent = null;\n        if (indexStart < 0) {\n            indexStart = 0;\n        }\n\n        if (indexEnd == 0) {\n            sectionContent = getContent().substring(indexStart);\n        } else {\n            sectionContent = getContent().substring(indexStart, indexEnd);\n        }\n\n        return sectionContent;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (starting at 1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating content\n     */\n    public String updateDocumentSection(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        String content;\n        if (is10Syntax()) {\n            content = updateDocumentSection10(sectionNumber, newSectionContent);\n        } else {\n            // Get the current section block\n            HeaderBlock header = getFilteredHeaders().get(sectionNumber - 1);\n\n            XDOM xdom = (XDOM) header.getRoot();\n\n            // newSectionContent -> Blocks\n            List<Block> blocks = parseContent(newSectionContent).getChildren();\n            int sectionLevel = header.getLevel().getAsInt();\n            for (int level = 1; level < sectionLevel && blocks.size() == 1\n                && blocks.get(0) instanceof SectionBlock; ++level) {\n                blocks = blocks.get(0).getChildren();\n            }\n\n            // replace old current SectionBlock with new Blocks\n            Block section = header.getSection();\n            section.getParent().replaceChild(blocks, section);\n\n            // render back XDOM to document's content syntax\n            content = renderXDOM(xdom, getSyntax());\n        }\n\n        return content;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating document content with section content\n     */\n    private String updateDocumentSection10(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        StringBuilder newContent = new StringBuilder();\n        // get document section that will be edited\n        DocumentSection docSection = getDocumentSection(sectionNumber);\n        int numberOfSections = getSections().size();\n        int indexSection = docSection.getSectionIndex();\n        if (numberOfSections == 1) {\n            // there is only a sections in document\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else if (sectionNumber == numberOfSections) {\n            // edit lastest section that doesn't contain subtitle\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else {\n            String sectionLevel = docSection.getSectionLevel();\n            int nextSectionIndex = 0;\n            // get index of next section\n            for (int i = sectionNumber; i < numberOfSections; i++) {\n                DocumentSection nextSection = getDocumentSection(i + 1); // get next section\n                String nextSectionLevel = nextSection.getSectionLevel();\n                if (sectionLevel.equals(nextSectionLevel)) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                } else if (sectionLevel.length() > nextSectionLevel.length()) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                }\n            }\n\n            if (nextSectionIndex == 0) {// edit the last section\n                newContent = newContent.append(getContent().substring(0, indexSection)).append(newSectionContent);\n                return newContent.toString();\n            } else {\n                String contentAfter = getContent().substring(nextSectionIndex);\n                String contentBegin = getContent().substring(0, indexSection);\n                newContent = newContent.append(contentBegin).append(newSectionContent).append(contentAfter);\n            }\n\n            return newContent.toString();\n        }\n    }\n\n    /**\n     * Computes a document hash, taking into account all document data: content, objects, attachments, metadata... TODO:\n     * cache the hash value, update only on modification.\n     */\n    public String getVersionHashCode(XWikiContext context)\n    {\n        MessageDigest md5 = null;\n\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException ex) {\n            LOGGER.error(\"Cannot create MD5 object\", ex);\n            return hashCode() + \"\";\n        }\n\n        try {\n            String valueBeforeMD5 = toXML(true, false, true, false, context);\n            md5.update(valueBeforeMD5.getBytes());\n\n            byte[] array = md5.digest();\n            StringBuilder sb = new StringBuilder();\n            for (byte element : array) {\n                int b = element & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n\n            return sb.toString();\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while computing document hash\", ex);\n        }\n\n        return hashCode() + \"\";\n    }\n\n    public static String getInternalPropertyName(String propname, XWikiContext context)\n    {\n        ContextualLocalizationManager localizationManager = Utils.getComponent(ContextualLocalizationManager.class);\n        String cpropname = StringUtils.capitalize(propname);\n\n        return localizationManager == null ? cpropname : localizationManager.getTranslationPlain(cpropname);\n    }\n\n    public String getInternalProperty(String propname)\n    {\n        String methodName = \"get\" + StringUtils.capitalize(propname);\n        try {\n            Method method = getClass().getDeclaredMethod(methodName, (Class[]) null);\n            return (String) method.invoke(this, (Object[]) null);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getCustomClass()\n    {\n        if (this.customClass == null) {\n            return \"\";\n        }\n\n        return this.customClass;\n    }\n\n    public void setCustomClass(String customClass)\n    {\n        this.customClass = customClass;\n        setMetaDataDirty(true);\n    }\n\n    public void setValidationScript(String validationScript)\n    {\n        this.validationScript = validationScript;\n\n        setMetaDataDirty(true);\n    }\n\n    public String getValidationScript()\n    {\n        if (this.validationScript == null) {\n            return \"\";\n        } else {\n            return this.validationScript;\n        }\n    }\n\n    public String getComment()\n    {\n        if (this.comment == null) {\n            return \"\";\n        }\n\n        return this.comment;\n    }\n\n    public void setComment(String comment)\n    {\n        this.comment = comment;\n    }\n\n    public boolean isMinorEdit()\n    {\n        return this.isMinorEdit;\n    }\n\n    public void setMinorEdit(boolean isMinor)\n    {\n        this.isMinorEdit = isMinor;\n    }\n\n    // methods for easy table update. It is need only for hibernate.\n    // when hibernate update old database without minorEdit field, hibernate will create field with\n    // null in despite of notnull in hbm.\n    // (http://opensource.atlassian.com/projects/hibernate/browse/HB-1151)\n    // so minorEdit will be null for old documents. But hibernate can't convert null to boolean.\n    // so we need convert Boolean to boolean\n    protected Boolean getMinorEdit1()\n    {\n        return Boolean.valueOf(isMinorEdit());\n    }\n\n    protected void setMinorEdit1(Boolean isMinor)\n    {\n        this.isMinorEdit = (isMinor != null && isMinor.booleanValue());\n    }\n\n    /**\n     * Create, add and return a new object with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public BaseObject newXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        int nb = createXObject(classReference, context);\n        return getXObject(resolveClassReference(classReference), nb);\n    }\n\n    /**\n     * @deprecated use {@link #newXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject newObject(String className, XWikiContext context) throws XWikiException\n    {\n        return newXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseObject getXObject(DocumentReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.4M1\n     */\n    public BaseObject getXObject(EntityReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject getObject(String className, boolean create, XWikiContext context)\n    {\n        return getXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), create,\n            context);\n    }\n\n    public boolean validate(XWikiContext context) throws XWikiException\n    {\n        return validate(null, context);\n    }\n\n    public boolean validate(String[] classNames, XWikiContext context) throws XWikiException\n    {\n        boolean isValid = true;\n        if ((classNames == null) || (classNames.length == 0)) {\n            for (DocumentReference classReference : getXObjects().keySet()) {\n                BaseClass bclass = context.getWiki().getXClass(classReference, context);\n                List<BaseObject> objects = getXObjects(classReference);\n                for (BaseObject obj : objects) {\n                    if (obj != null) {\n                        isValid &= bclass.validateObject(obj, context);\n                    }\n                }\n            }\n        } else {\n            for (String className : classNames) {\n                List<BaseObject> objects = getXObjects(getCurrentMixedDocumentReferenceResolver().resolve(className));\n                if (objects != null) {\n                    for (BaseObject obj : objects) {\n                        if (obj != null) {\n                            BaseClass bclass = obj.getXClass(context);\n                            isValid &= bclass.validateObject(obj, context);\n                        }\n                    }\n                }\n            }\n        }\n\n        String validationScript = \"\";\n        XWikiRequest req = context.getRequest();\n        if (req != null) {\n            validationScript = req.get(\"xvalidation\");\n        }\n\n        if ((validationScript == null) || (validationScript.trim().equals(\"\"))) {\n            validationScript = getValidationScript();\n        }\n\n        if ((validationScript != null) && (!validationScript.trim().equals(\"\"))) {\n            isValid &= executeValidationScript(context, validationScript);\n        }\n\n        return isValid;\n    }\n\n    public static void backupContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // The XWiki Context isn't recreated when the Execution Context is cloned so we have to backup some of its data.\n        // Backup the current document on the XWiki Context.\n        backup.put(\"doc\", context.getDoc());\n\n        backup.put(\"cdoc\", context.get(\"cdoc\"));\n        backup.put(\"tdoc\", context.get(\"tdoc\"));\n\n        // Backup the secure document\n        backup.put(CKEY_SDOC, context.get(CKEY_SDOC));\n\n        // Clone the Execution Context to provide isolation. The clone will have a new Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        try {\n            execution.pushContext(Utils.getComponent(ExecutionContextManager.class).clone(execution.getContext()));\n        } catch (ExecutionContextException e) {\n            throw new RuntimeException(\"Failed to clone the Execution Context\", e);\n        }\n\n        // Bridge with old XWiki Context, required for legacy code.\n        execution.getContext().setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, context);\n    }\n\n    public static void restoreContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // Restore the Execution Context. This will also restore the previous Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        execution.popContext();\n\n        // Restore the current document on the XWiki Context.\n        context.setDoc((XWikiDocument) backup.get(\"doc\"));\n\n        context.put(\"cdoc\", backup.get(\"cdoc\"));\n        context.put(\"tdoc\", backup.get(\"tdoc\"));\n\n        // Restore the secure document\n        context.put(CKEY_SDOC, backup.get(CKEY_SDOC));\n    }\n\n    public void setAsContextDoc(XWikiContext context)\n    {\n        context.setDoc(this);\n        context.remove(\"cdoc\");\n        context.remove(\"tdoc\");\n\n        // Get rid of secure document (so that it fallback on context document)\n        context.remove(CKEY_SDOC);\n    }\n\n    /**\n     * @return the String representation of the previous version of this document or null if this is the first version.\n     */\n    public String getPreviousVersion()\n    {\n        XWikiDocumentArchive archive = loadDocumentArchive();\n        if (archive != null) {\n            Version prevVersion = archive.getPrevVersion(getRCSVersion());\n            if (prevVersion != null) {\n                return prevVersion.toString();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString()\n    {\n        return getFullName();\n    }\n\n    /**\n     * Indicates whether the document should be 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @param hidden The new value of the {@link #hidden} property.\n     */\n    public void setHidden(Boolean hidden)\n    {\n        if (hidden == null) {\n            this.hidden = false;\n        } else {\n            this.hidden = hidden;\n        }\n    }\n\n    /**\n     * Indicates whether the document is 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @return <code>true</code> if the document is hidden and does not appear among the results of\n     *         {@link com.xpn.xwiki.api.XWiki#searchDocuments(String)}, <code>false</code> otherwise.\n     */\n    public Boolean isHidden()\n    {\n        return this.hidden;\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntaxId the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(String targetSyntaxId, XWikiContext context) throws XWikiException\n    {\n        try {\n            convertSyntax(Syntax.valueOf(targetSyntaxId), context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntaxId + \"]\", e);\n        }\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntax the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        // convert content\n        setContent(performSyntaxConversion(getContent(), getDocumentReference(), getSyntax(), targetSyntax));\n\n        // convert objects\n        Map<DocumentReference, List<BaseObject>> objectsByClass = getXObjects();\n\n        for (List<BaseObject> objects : objectsByClass.values()) {\n            for (BaseObject bobject : objects) {\n                if (bobject != null) {\n                    BaseClass bclass = bobject.getXClass(context);\n                    for (Object fieldClass : bclass.getProperties()) {\n                        if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                            TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                            PropertyInterface field = bobject.getField(textAreaClass.getName());\n\n                            // Make sure the field is the right type (might happen while a document is being migrated)\n                            if (field instanceof LargeStringProperty) {\n                                LargeStringProperty largeField = (LargeStringProperty) field;\n\n                                largeField.setValue(performSyntaxConversion(largeField.getValue(),\n                                    getDocumentReference(), getSyntax(), targetSyntax));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // change syntax\n        setSyntax(targetSyntax);\n    }\n\n    /**\n     * NOTE: This method caches the XDOM and returns a clone that can be safely modified.\n     *\n     * @return the XDOM corresponding to the document's string content\n     */\n    @Override\n    public XDOM getXDOM()\n    {\n        if (this.xdomCache == null) {\n            try {\n                this.xdomCache = parseContent(getContent());\n            } catch (XWikiException e) {\n                ErrorBlockGenerator errorBlockGenerator = Utils.getComponent(ErrorBlockGenerator.class);\n                return new XDOM(errorBlockGenerator.generateErrorBlocks(false, TM_FAILEDDOCUMENTPARSE,\n                    \"Failed to parse document content\", null, e));\n            }\n        }\n\n        return this.xdomCache.clone();\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax()\n    {\n        return is10Syntax(getSyntaxId());\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax(String syntaxId)\n    {\n        return Syntax.XWIKI_1_0.toIdString().equalsIgnoreCase(syntaxId);\n    }\n\n    private void init(DocumentReference reference)\n    {\n        // if the passed reference is null consider it points to the default reference\n        if (reference == null) {\n            setDocumentReference(\n                Utils.<Provider<DocumentReference>>getComponent(DocumentReference.TYPE_PROVIDER).get());\n        } else {\n            setDocumentReference(reference);\n        }\n\n        this.updateDate = new Date();\n        this.updateDate.setTime((this.updateDate.getTime() / 1000) * 1000);\n        this.contentUpdateDate = new Date();\n        this.contentUpdateDate.setTime((this.contentUpdateDate.getTime() / 1000) * 1000);\n        this.creationDate = new Date();\n        this.creationDate.setTime((this.creationDate.getTime() / 1000) * 1000);\n        this.content = \"\";\n        this.format = \"\";\n        this.locale = Locale.ROOT;\n        this.defaultLocale = Locale.ROOT;\n        this.customClass = \"\";\n        this.comment = \"\";\n\n        // Note: As there's no notion of an Empty document we don't set the original document\n        // field. Thus getOriginalDocument() may return null.\n    }\n\n    private boolean executeValidationScript(XWikiContext context, String validationScript)\n    {\n        try {\n            ContextualAuthorizationManager authorization = Utils.getComponent(ContextualAuthorizationManager.class);\n            DocumentReference validationScriptReference =\n                getCurrentDocumentReferenceResolver().resolve(validationScript, getDocumentReference());\n\n            // Make sure target document is allowed to execute Groovy\n            // TODO: this check should probably be right in XWiki#parseGroovyFromPage\n            authorization.checkAccess(Right.PROGRAM, validationScriptReference);\n\n            XWikiValidationInterface validObject =\n                (XWikiValidationInterface) context.getWiki().parseGroovyFromPage(validationScript, context);\n\n            return validObject.validateDocument(this, context);\n        } catch (Throwable e) {\n            XWikiValidationStatus.addExceptionToContext(getFullName(), \"\", e, context);\n            return false;\n        }\n    }\n\n    /**\n     * Convert the passed content from the passed syntax to the passed new syntax.\n     *\n     * @param content the content to convert\n     * @param source the reference to where the content comes from (eg document reference)\n     * @param currentSyntaxId the syntax of the current content to convert\n     * @param targetSyntax the new syntax after the conversion\n     * @return the converted content in the new syntax\n     * @throws XWikiException if an exception occurred during the conversion process\n     * @since 2.4M2\n     */\n    private static String performSyntaxConversion(String content, DocumentReference source, Syntax currentSyntaxId,\n        Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            XDOM dom = parseContent(currentSyntaxId, content, source);\n            return performSyntaxConversion(dom, targetSyntax, null);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    /**\n     * Convert the passed content from the passed syntax to the passed new syntax.\n     *\n     * @param content the XDOM content to convert, the XDOM can be modified during the transformation\n     * @param targetSyntax the new syntax after the conversion\n     * @param txContext the context when Transformation are executed or null if transformation shouldn't be executed\n     * @return the converted content in the new syntax\n     * @throws XWikiException if an exception occurred during the conversion process\n     * @since 2.4M2\n     */\n    private static String performSyntaxConversion(XDOM content, Syntax targetSyntax, TransformationContext txContext)\n        throws XWikiException\n    {\n        try {\n            if (txContext != null) {\n                // Transform XDOM\n                TransformationManager transformations = Utils.getComponent(TransformationManager.class);\n                if (txContext.getXDOM() == null) {\n                    txContext.setXDOM(content);\n                }\n                try {\n                    transformations.performTransformations(content, txContext);\n                } catch (TransformationException te) {\n                    // An error happened during one of the transformations. Since the error has been logged\n                    // continue\n                    // TODO: We should have a visual clue for the user in the future to let him know something\n                    // didn't work as expected.\n                }\n            }\n\n            // Render XDOM\n            return renderXDOM(content, targetSyntax);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    /**\n     * Render provided XDOM into content of the provided syntax identifier.\n     *\n     * @param content the XDOM content to render\n     * @param targetSyntax the syntax identifier of the rendered content\n     * @return the rendered content\n     * @throws XWikiException if an exception occurred during the rendering process\n     */\n    protected static String renderXDOM(XDOM content, Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            BlockRenderer renderer = Utils.getComponent(BlockRenderer.class, targetSyntax.toIdString());\n            WikiPrinter printer = new DefaultWikiPrinter();\n            renderer.render(content, printer);\n            return printer.toString();\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to render document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    private XDOM parseContent(String content) throws XWikiException\n    {\n        return parseContent(getSyntax(), content, getDocumentReference());\n    }\n\n    /**\n     * @param source the reference to where the content comes from (eg document reference)\n     */\n    private static XDOM parseContent(Syntax syntax, String content, DocumentReference source) throws XWikiException\n    {\n        ContentParser parser = Utils.getComponent(ContentParser.class);\n\n        try {\n            return parser.parse(content, syntax, source);\n        } catch (MissingParserException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to find a parser for syntax [\" + syntax.toIdString() + \"]\", e);\n        } catch (ParseException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to parse content of syntax [\" + syntax.toIdString() + \"]\", e);\n        }\n    }\n\n    /**\n     * If there's no parser available for the specified syntax default to the XWiki 2.1 syntax.\n     */\n    private Syntax getDefaultDocumentSyntax()\n    {\n        Syntax syntax = Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n\n        if (syntax == null || (!Utils.getComponentManager().hasComponent(Parser.class, syntax.toIdString())\n            && !Syntax.XWIKI_2_1.equals(syntax))) {\n            LOGGER.warn(\"Failed to find parser for the default syntax [{}]. Defaulting to xwiki/2.1 syntax.\", syntax);\n            syntax = Syntax.XWIKI_2_1;\n        }\n\n        return syntax;\n    }\n\n    /**\n     * Backward-compatibility method to use in order to resolve a class reference passed as a String into a\n     * DocumentReference proper.\n     *\n     * @return the resolved class reference but using this document's wiki if the passed String doesn't specify a wiki,\n     *         the \"XWiki\" space if the passed String doesn't specify a space and this document's page if the passed\n     *         String doesn't specify a page.\n     */\n    public DocumentReference resolveClassReference(String documentName)\n    {\n        DocumentReference defaultReference = new DocumentReference(getDocumentReference().getWikiReference().getName(),\n            XWiki.SYSTEM_SPACE, getDocumentReference().getName());\n        return getExplicitDocumentReferenceResolver().resolve(documentName, defaultReference);\n    }\n\n    /**\n     * Transforms a XClass reference relative to this document into an absolute reference.\n     */\n    private DocumentReference resolveClassReference(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return (DocumentReference) reference;\n        } else if (reference instanceof LocalDocumentReference) {\n            return new DocumentReference((LocalDocumentReference) reference, getDocumentReference().getWikiReference());\n        } else {\n            DocumentReference defaultReference =\n                new DocumentReference(getDocumentReference().getWikiReference().getName(), XWiki.SYSTEM_SPACE,\n                    getDocumentReference().getName());\n            return getExplicitReferenceDocumentReferenceResolver().resolve(reference, defaultReference);\n        }\n    }\n\n    /**\n     * Return the reference of the parent document as it stored and passed to\n     * {@link #setParentReference(EntityReference)}.\n     * <p>\n     * You should use {@link #getParentReference()} reference if you want the complete parent reference.\n     *\n     * @return the relative parent reference\n     * @since 2.2.3\n     */\n    public EntityReference getRelativeParentReference()\n    {\n        return this.parentReference;\n    }\n\n    private BaseObject prepareXObject(EntityReference classReference)\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject bobject = getXObject(absoluteClassReference);\n        if (bobject == null) {\n            bobject = new BaseObject();\n            bobject.setXClassReference(classReference);\n\n            addXObject(bobject);\n        }\n        bobject.setDocumentReference(getDocumentReference());\n        setMetaDataDirty(true);\n        return bobject;\n    }\n\n    /**\n     * Apply a 3 ways merge on the current document based on provided previous and new version of the document.\n     * <p>\n     * All 3 documents are supposed to have the same document reference and language already since that's what makes\n     * them uniques.\n     *\n     * @param previousDocument the previous version of the document\n     * @param newDocument the next version of the document\n     * @param configuration the configuration of the merge indicates how to deal with some conflicts use cases, etc.\n     * @param context the XWiki context\n     * @return a repport of what happen during the merge (errors, etc.)\n     * @since 3.2M1\n     * @deprecated use {@link MergeManager#mergeDocument(DocumentModelBridge, DocumentModelBridge, DocumentModelBridge,\n     *  MergeConfiguration)} instead\n     */\n    @Deprecated(since = \"11.8RC1\")\n    public MergeResult merge(XWikiDocument previousDocument, XWikiDocument newDocument,\n        MergeConfiguration configuration, XWikiContext context)\n    {\n        MergeManager mergeManager = Utils.getComponent(MergeManager.class);\n        MergeDocumentResult mergeDocumentResult =\n            mergeManager.mergeDocument(previousDocument, newDocument, this, configuration);\n\n        MergeResult mergeResult = new MergeResult();\n        mergeResult.getLog().addAll(mergeDocumentResult.getLog());\n        mergeResult.setModified(mergeResult.isModified() || mergeDocumentResult.isModified());\n\n        if (!configuration.isProvidedVersionsModifiables())\n        {\n            this.apply((XWikiDocument) mergeDocumentResult.getMergeResult());\n        }\n\n        return mergeResult;\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change anything related to version management and document\n     * identifier.\n     * <p>\n     * Important note: this method does not take care of attachments contents related operations and only remove\n     * attachments which need to be removed from the list. For memory handling reasons all attachments contents related\n     * operations should be done elsewhere.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document)\n    {\n        return apply(document, true);\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change everything related to version management and\n     * document identifier.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document, boolean clean)\n    {\n        boolean modified = false;\n\n        // /////////////////////////////////\n        // Document\n\n        if (!StringUtils.equals(getContent(), document.getContent())) {\n            setContent(document.getContent());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getSyntax(), document.getSyntax())) {\n            setSyntax(document.getSyntax());\n            modified = true;\n        }\n\n        if (ObjectUtils.notEqual(getDefaultLocale(), document.getDefaultLocale())) {\n            setDefaultLocale(document.getDefaultLocale());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getTitle(), document.getTitle())) {\n            setTitle(document.getTitle());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getDefaultTemplate(), document.getDefaultTemplate())) {\n            setDefaultTemplate(document.getDefaultTemplate());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getRelativeParentReference(), document.getRelativeParentReference())) {\n            setParentReference(document.getRelativeParentReference());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getCustomClass(), document.getCustomClass())) {\n            setCustomClass(document.getCustomClass());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getValidationScript(), document.getValidationScript())) {\n            setValidationScript(document.getValidationScript());\n            modified = true;\n        }\n\n        if (isHidden() != document.isHidden()) {\n            setHidden(document.isHidden());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // XObjects\n\n        if (clean) {\n            // Delete objects that don't exist anymore\n            for (List<BaseObject> objects : getXObjects().values()) {\n                // Duplicate the list since we are potentially going to modify it\n                for (BaseObject originalObj : new ArrayList<BaseObject>(objects)) {\n                    if (originalObj != null) {\n                        BaseObject newObj =\n                            document.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                        if (newObj == null) {\n                            // The object was deleted\n                            removeXObject(originalObj);\n                            modified = true;\n                        }\n                    }\n                }\n            }\n        }\n        // Add new objects or update existing objects\n        for (List<BaseObject> objects : document.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                if (newObj != null) {\n                    BaseObject originalObj = getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // The object added or modified\n                        setXObject(newObj.getNumber(), newObj);\n                        modified = true;\n                    } else {\n                        // The object added or modified\n                        modified |= originalObj.apply(newObj, clean);\n                    }\n                }\n            }\n        }\n\n        // /////////////////////////////////\n        // XClass\n\n        modified |= getXClass().apply(document.getXClass(), clean);\n        if (ObjectUtils.notEqual(getXClassXML(), document.getXClassXML())) {\n            setXClassXML(document.getXClassXML());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // Attachments\n\n        if (clean) {\n            // Delete attachments that don't exist anymore\n            for (XWikiAttachment attachment : new ArrayList<XWikiAttachment>(getAttachmentList())) {\n                if (document.getAttachment(attachment.getFilename()) == null) {\n                    removeAttachment(attachment);\n                }\n            }\n        }\n        // Add new attachments or update existing attachments\n        for (XWikiAttachment attachment : document.getAttachmentList()) {\n            XWikiAttachment originalAttachment = getAttachment(attachment.getFilename());\n            if (originalAttachment == null) {\n                addAttachment(attachment);\n            } else {\n                originalAttachment.apply(attachment);\n            }\n        }\n\n        return modified;\n    }\n\n    private XWikiAttachmentStoreInterface resolveXWikiAttachmentStoreInterface(String storeType, XWikiContext xcontext)\n    {\n        XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(storeType);\n\n        if (store != null) {\n            return store;\n        }\n\n        return xcontext.getWiki().getDefaultAttachmentContentStore();\n    }\n\n    private XWikiAttachmentStoreInterface getXWikiAttachmentStoreInterface(String storeType)\n    {\n        if (storeType != null && !storeType.equals(XWikiHibernateAttachmentStore.HINT)) {\n            try {\n                return Utils.getContextComponentManager().getInstance(XWikiAttachmentStoreInterface.class, storeType);\n            } catch (ComponentLookupException e) {\n                LOGGER.warn(\"Can't find attachment content store for type [{}]\", storeType, e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Compute and return the maximum authorized length for the full name (i.e. the serialized reference of the\n     * document) based on the current store limitation.\n     *\n     * @return the maximum authorized length for a document full name.\n     * @since 11.4RC1\n     */\n    public int getLocalReferenceMaxLength()\n    {\n        return getStore().getLimitSize(this.getXWikiContext(), this.getClass(), \"fullName\");\n    }\n\n    @Override\n    public DocumentAuthors getAuthors()\n    {\n        return this.authors;\n    }\n\n    /**\n     * This getter has been created for hibernate in order to properly fill the DB field, it's not meant to be used\n     * for other purpose. For getting the displayed author, rely on {@link #getAuthors()}.\n     *\n     * @return the serialization of the displayed author reference.\n     */\n    private String getOriginalMetadataAuthorReference()\n    {\n        if (this.getAuthors().getOriginalMetadataAuthor() == null\n            || this.getAuthors().getOriginalMetadataAuthor() == GuestUserReference.INSTANCE) {\n            return \"\";\n        } else {\n            return userReferenceToString(this.getAuthors().getOriginalMetadataAuthor());\n        }\n    }\n\n    /**\n     * This setter has been created for hibernate in order to properly create the XWikiDocument instance with the\n     * displayed author set, it's not meant to be used for other purpose.\n     *\n     * @param serializedUserReference the serialization of the displayed author reference.\n     */\n    private void setOriginalMetadataAuthorReference(String serializedUserReference)\n    {\n        if (!StringUtils.isEmpty(serializedUserReference)) {\n            UserReference userReference = userStringToUserReference(serializedUserReference);\n            this.authors.setOriginalMetadataAuthor(userReference);\n        }\n    }\n\n    /**\n     * Make sure any document metadata which may depend on configuration is initialized to its default value.\n     * \n     * @since 14.8RC1\n     * @since 14.4.4\n     * @since 13.10.10\n     */\n    @Unstable\n    public void initialize()\n    {\n        // There is no syntax by default in a new document and the default one is retrieved from the configuration\n        setSyntax(getSyntax());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.mockito.Mock;\nimport org.mockito.stubbing.Answer;\nimport org.xwiki.context.Execution;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.rendering.configuration.ExtendedRenderingConfiguration;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.test.LogLevel;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.junit5.LogCaptureExtension;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.velocity.VelocityEngine;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyBoolean;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link XWikiDocument}.\n *\n * @version $Id$\n */\n@OldcoreTest\n@AllComponents\npublic class XWikiDocumentTest\n{\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    private static final String DOCWIKI = \"Wiki\";\n\n    private static final String DOCSPACE = \"Space\";\n\n    private static final String DOCNAME = \"Page\";\n\n    private static final String CLASSNAME = DOCSPACE + \".\" + DOCNAME;\n\n    private static final DocumentReference CLASS_REFERENCE = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n\n    private XWikiDocument document;\n\n    private XWikiDocument translatedDocument;\n\n    @Mock\n    private XWikiMessageTool xWikiMessageTool;\n\n    @Mock\n    private XWikiRightService xWikiRightService;\n\n    @Mock\n    private XWiki xWiki;\n\n    private XWikiStoreInterface xWikiStoreInterface;\n\n    private VelocityManager velocityManager;\n\n    private BaseClass baseClass;\n\n    private BaseObject baseObject;\n\n    private BaseObject baseObject2;\n\n    @RegisterExtension\n    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.WARN);\n\n    @BeforeEach\n    protected void setUp() throws Exception\n    {\n        XWikiVersioningStoreInterface mockXWikiVersioningStore =\n            this.componentManager.registerMockComponent(XWikiVersioningStoreInterface.class);\n        this.xWikiStoreInterface = this.componentManager.registerMockComponent(XWikiStoreInterface.class);\n        this.velocityManager = this.componentManager.registerMockComponent(VelocityManager.class);\n        VelocityEngine mockVelocityEngine = this.componentManager.registerMockComponent(VelocityEngine.class);\n        this.componentManager.registerMockComponent(ExtendedRenderingConfiguration.class);\n\n        when(velocityManager.getVelocityEngine()).thenReturn(mockVelocityEngine);\n\n        Answer<Boolean> invocationVelocity = invocationOnMock -> {\n            // Output the given text without changes.\n            StringWriter writer = invocationOnMock.getArgument(0);\n            String text = invocationOnMock.getArgument(2);\n            writer.append(text);\n            return true;\n        };\n        when(mockVelocityEngine.evaluate(any(), any(), any(), any(String.class))).then(invocationVelocity);\n\n        DocumentReference documentReference = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n        this.document = new XWikiDocument(documentReference);\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n        this.document.setLanguage(\"en\");\n        this.document.setDefaultLanguage(\"en\");\n        this.document.setNew(false);\n\n        this.translatedDocument = new XWikiDocument();\n        this.translatedDocument.setSyntax(Syntax.XWIKI_2_0);\n        this.translatedDocument.setLanguage(\"fr\");\n        this.translatedDocument.setNew(false);\n\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);\n        when(mockXWikiVersioningStore.getXWikiDocumentArchive(any(), any())).thenReturn(null);\n\n        this.document.setStore(xWikiStoreInterface);\n\n        when(this.xWikiMessageTool.get(any())).thenReturn(\"message\");\n        when(this.xWikiRightService.hasProgrammingRights(any())).thenReturn(true);\n\n        when(this.xWiki.getVersioningStore()).thenReturn(mockXWikiVersioningStore);\n        when(this.xWiki.getStore()).thenReturn(xWikiStoreInterface);\n        when(this.xWiki.getDocument(any(DocumentReference.class), any())).thenReturn(this.document);\n        when(this.xWiki.getDocumentReference(any(XWikiRequest.class), any())).thenReturn(documentReference);\n        when(this.xWiki.getDocumentReference(any(EntityReference.class), any()))\n            .then(i -> new DocumentReference(i.getArgument(0)));\n        when(this.xWiki.getLanguagePreference(any())).thenReturn(\"en\");\n        when(this.xWiki.getSectionEditingDepth()).thenReturn(2L);\n        when(this.xWiki.getRightService()).thenReturn(this.xWikiRightService);\n        when(this.xWiki.exists(any(DocumentReference.class), any())).thenReturn(false);\n        when(this.xWiki.evaluateTemplate(any(), any())).thenReturn(\"\");\n\n        this.oldcore.getXWikiContext().setWiki(this.xWiki);\n        this.oldcore.getXWikiContext().put(\"msg\", this.xWikiMessageTool);\n\n        this.baseClass = this.document.getXClass();\n        this.baseClass.addTextField(\"string\", \"String\", 30);\n        this.baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        this.baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) this.baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        this.baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        this.baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        this.baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        this.baseClass.addStaticListField(\"stringlist\", \"StringList\", \"value1, value2\");\n\n        when(this.xWiki.getClass(any(), any())).thenReturn(this.baseClass);\n        when(this.xWiki.getXClass(any(), any())).thenReturn(this.baseClass);\n\n        this.baseObject = this.document.newObject(CLASSNAME, this.oldcore.getXWikiContext());\n        this.baseObject.setStringValue(\"string\", \"string\");\n        this.baseObject.setLargeStringValue(\"area\", \"area\");\n        this.baseObject.setStringValue(\"passwd\", \"passwd\");\n        this.baseObject.setIntValue(\"boolean\", 1);\n        this.baseObject.setIntValue(\"int\", 42);\n        this.baseObject.setStringListValue(\"stringlist\", Arrays.asList(\"VALUE1\", \"VALUE2\"));\n\n        this.baseObject2 = this.baseObject.clone();\n        this.document.addXObject(this.baseObject2);\n\n        when(xWikiStoreInterface.search(anyString(), anyInt(), anyInt(), any())).thenReturn(new ArrayList<>());\n    }\n\n    @Test\n    public void getUniqueLinkedPages10() throws XWikiException\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        when(xWiki.exists(any(DocumentReference.class), any())).thenReturn(true);\n\n        this.document.setContent(\"[TargetPage][TargetLabel>TargetPage][TargetSpace.TargetPage]\"\n            + \"[TargetLabel>TargetSpace.TargetPage?param=value#anchor][http://externallink][mailto:mailto][label>]\");\n\n        Set<String> linkedPages = this.document.getUniqueLinkedPages(this.oldcore.getXWikiContext());\n\n        assertEquals(new HashSet<>(Arrays.asList(\"TargetPage\", \"TargetSpace.TargetPage\")), new HashSet<>(linkedPages));\n    }\n\n    @Test\n    public void getUniqueLinkedPages20()\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        this.document.setContent(\"[[TargetPage]][[TargetLabel>>TargetPage]][[TargetSpace.TargetPage]]\"\n            + \"[[TargetLabel>>TargetSpace.TargetPage?param=value#anchor]][[http://externallink]][[mailto:mailto]]\"\n            + \"[[]][[#anchor]][[?param=value]][[targetwiki:TargetSpace.TargetPage]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        Set<String> linkedPages = this.document.getUniqueLinkedPages(this.oldcore.getXWikiContext());\n\n        assertEquals(new LinkedHashSet<>(Arrays.asList(\"Space.TargetPage.WebHome\",\n            \"TargetSpace.TargetPage.WebHome\", \"targetwiki:TargetSpace.TargetPage.WebHome\")), linkedPages);\n    }\n\n    @Test\n    public void getUniqueLinkedPages21() throws Exception\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.document.setContent(\"\"\n            + \"[[TargetPage]]\"\n            + \"[[TargetLabel>>TargetPage]]\"\n            + \"[[TargetSpace.TargetPage]]\"\n            + \"[[http://externallink]]\"\n            + \"[[mailto:mailto]]\"\n            + \"[[]]\"\n            + \"[[targetwiki:TargetSpace.TargetPage]]\"\n            + \"[[page:OtherPage]]\"\n            + \"[[attach:AttachSpace.AttachDocument@attachment.ext]]\"\n            + \"[[attach:attachment.ext]]\"\n            + \"[[pageAttach:OtherPage/attachment.ext]]\"\n            + \"image:ImageSpace.ImageDocument@image.png image:image.png\");\n        this.baseObject.setLargeStringValue(\"area\", \"[[TargetPage]][[ObjectTargetPage]]\");\n\n        // Simulate that \"OtherPage.WebHome\" exists\n        doReturn(new DocumentReference(\"Wiki\", \"OtherPage\", \"WebHome\")).when(this.xWiki)\n            .getDocumentReference(new PageReference(\"Wiki\", \"OtherPage\"), this.oldcore.getXWikiContext());\n\n        Set<String> linkedPages = this.document.getUniqueLinkedPages(this.oldcore.getXWikiContext());\n\n        assertEquals(\n            new LinkedHashSet<>(Arrays.asList(\n                \"Space.TargetPage.WebHome\",\n                \"TargetSpace.TargetPage.WebHome\",\n                \"targetwiki:TargetSpace.TargetPage.WebHome\",\n                \"OtherPage.WebHome\",\n                \"AttachSpace.AttachDocument.WebHome\",\n                \"ImageSpace.ImageDocument.WebHome\",\n                \"Space.ObjectTargetPage.WebHome\"\n            )), linkedPages);\n    }\n\n    @Test\n    public void getUniqueWikiLinkedPages() throws XWikiException\n    {\n        XWikiDocument contextDocument =\n            new XWikiDocument(new DocumentReference(\"contextdocwiki\", \"contextdocspace\", \"contextdocpage\"));\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        this.document.setContent(\"[[TargetPage]][[TargetLabel>>TargetPage]][[TargetSpace.TargetPage]]\"\n            + \"[[TargetLabel>>TargetSpace.TargetPage?param=value#anchor]][[http://externallink]][[mailto:mailto]]\"\n            + \"[[]][[#anchor]][[?param=value]][[targetwiki:TargetSpace.TargetPage]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        Set<XWikiLink> linkedPages = this.document.getUniqueWikiLinkedPages(this.oldcore.getXWikiContext());\n        Set<XWikiLink> expectedLinkedPages = new LinkedHashSet<>();\n        XWikiLink xWikiLink = new XWikiLink();\n        xWikiLink.setDocId(this.document.getId());\n        xWikiLink.setFullName(DOCSPACE + \".\" + DOCNAME);\n        xWikiLink.setLink(\"Space.TargetPage.WebHome\");\n        expectedLinkedPages.add(xWikiLink);\n\n        xWikiLink = new XWikiLink();\n        xWikiLink.setDocId(this.document.getId());\n        xWikiLink.setFullName(DOCSPACE + \".\" + DOCNAME);\n        xWikiLink.setLink(\"TargetSpace.TargetPage.WebHome\");\n        expectedLinkedPages.add(xWikiLink);\n\n        xWikiLink = new XWikiLink();\n        xWikiLink.setDocId(this.document.getId());\n        xWikiLink.setFullName(DOCSPACE + \".\" + DOCNAME);\n        xWikiLink.setLink(\"targetwiki:TargetSpace.TargetPage.WebHome\");\n        expectedLinkedPages.add(xWikiLink);\n\n        assertEquals(expectedLinkedPages, linkedPages);\n    }\n\n    @Test\n    public void getSections10() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"1 header 1\\nheader 1 content\\n\" + \"1.1 header 2\\nheader 2 content\");\n\n        List<DocumentSection> headers = this.document.getSections();\n\n        assertEquals(2, headers.size());\n\n        DocumentSection header1 = headers.get(0);\n        DocumentSection header2 = headers.get(1);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(23, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(51, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    @Test\n    public void getSections() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        List<DocumentSection> headers = this.document.getSections();\n\n        assertEquals(2, headers.size());\n\n        DocumentSection header1 = headers.get(0);\n        DocumentSection header2 = headers.get(1);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(-1, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(-1, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    @Test\n    public void getDocumentSection10() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"1 header 1\\nheader 1 content\\n\" + \"1.1 header 2\\nheader 2 content\");\n\n        DocumentSection header1 = this.document.getDocumentSection(1);\n        DocumentSection header2 = this.document.getDocumentSection(2);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(23, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(51, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    @Test\n    public void getDocumentSection() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        DocumentSection header1 = this.document.getDocumentSection(1);\n        DocumentSection header2 = this.document.getDocumentSection(2);\n\n        assertEquals(\"header 1\", header1.getSectionTitle());\n        assertEquals(-1, header1.getSectionIndex());\n        assertEquals(1, header1.getSectionNumber());\n        assertEquals(\"1\", header1.getSectionLevel());\n        assertEquals(\"header 2\", header2.getSectionTitle());\n        assertEquals(-1, header2.getSectionIndex());\n        assertEquals(2, header2.getSectionNumber());\n        assertEquals(\"1.1\", header2.getSectionLevel());\n    }\n\n    /**\n     * Verify that if we have sections nested in groups, they are not taken into account when computing document\n     * sections by number. See <a href=\"https://jira.xwiki.org/browse/XWIKI-6195\">XWIKI-6195</a>.\n     *\n     * @since 5.0M1\n     */\n    @Test\n    public void getDocumentSectionWhenSectionInGroups() throws XWikiException\n    {\n        this.document.setContent(\n            \"= Heading1 =\\n\" + \"para1\\n\" + \"== Heading2 ==\\n\" + \"para2\\n\" + \"(((\\n\" + \"== Heading3 ==\\n\" + \"para3\\n\"\n                + \"(((\\n\" + \"== Heading4 ==\\n\" + \"para4\\n\" + \")))\\n\" + \")))\\n\" + \"== Heading5 ==\\n\" + \"para5\\n\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        DocumentSection section = this.document.getDocumentSection(3);\n        assertEquals(\"Heading5\", section.getSectionTitle());\n    }\n\n    @Test\n    public void getContentOfSection10() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"1 header 1\\nheader 1 content\\n\" + \"1.1 header 2\\nheader 2 content\");\n\n        String content1 = this.document.getContentOfSection(1);\n        String content2 = this.document.getContentOfSection(2);\n\n        assertEquals(\"1 header 1\\nheader 1 content\\n1.1 header 2\\nheader 2 content\", content1);\n        assertEquals(\"1.1 header 2\\nheader 2 content\", content2);\n    }\n\n    @Test\n    public void getContentOfSection() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\\n\"\n                + \"=== header 3===\\nheader 3 content\\n\" + \"== header 4==\\nheader 4 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        String content1 = this.document.getContentOfSection(1);\n        String content2 = this.document.getContentOfSection(2);\n        String content3 = this.document.getContentOfSection(3);\n\n        assertEquals(\"= header 1 =\\n\\nheader 1 content\\n\\n== header 2 ==\\n\\nheader 2 content\\n\\n\"\n            + \"=== header 3 ===\\n\\nheader 3 content\\n\\n== header 4 ==\\n\\nheader 4 content\", content1);\n        assertEquals(\"== header 2 ==\\n\\nheader 2 content\\n\\n=== header 3 ===\\n\\nheader 3 content\", content2);\n        assertEquals(\"== header 4 ==\\n\\nheader 4 content\", content3);\n\n        // Validate that third level header is not skipped anymore\n        when(this.xWiki.getSectionEditingDepth()).thenReturn(3L);\n\n        content3 = this.document.getContentOfSection(3);\n        String content4 = this.document.getContentOfSection(4);\n\n        assertEquals(\"=== header 3 ===\\n\\nheader 3 content\", content3);\n        assertEquals(\"== header 4 ==\\n\\nheader 4 content\", content4);\n    }\n\n    @Test\n    public void sectionSplit10() throws XWikiException\n    {\n        List<DocumentSection> sections;\n        // Simple test\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\n            \"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\" + \"Content of second section\\n\",\n            this.document.getContentOfSection(1));\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        assertEquals(\"1.1 Subsection 2\\nContent of second section\\n\", this.document.getContentOfSection(2));\n        assertEquals(3, sections.get(2).getSectionNumber());\n        assertEquals(80, sections.get(2).getSectionIndex());\n        assertEquals(\"1 Section 3\\nContent of section 3\", this.document.getContentOfSection(3));\n        // Test comments don't break the section editing\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"## 1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(2, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\"1\", sections.get(1).getSectionLevel());\n        assertEquals(2, sections.get(1).getSectionNumber());\n        assertEquals(83, sections.get(1).getSectionIndex());\n        // Test spaces are ignored\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"   1.1    Subsection 2  \\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Subsection 2  \", sections.get(1).getSectionTitle());\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        // Test lower headings are ignored\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1.1 Lower subsection\\n\"\n            + \"This content is not important\\n\" + \"   1.1    Subsection 2  \\n\" + \"Content of second section\\n\"\n            + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\"Subsection 2  \", sections.get(1).getSectionTitle());\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        // Test blank lines are preserved\n        this.document\n            .setContent(\"\\n\\n1 Section 1\\n\\n\\n\" + \"Content of first section\\n\\n\\n\" + \"   1.1    Subsection 2  \\n\\n\"\n                + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(2, sections.get(0).getSectionIndex());\n        assertEquals(\"Subsection 2  \", sections.get(1).getSectionTitle());\n        assertEquals(43, sections.get(1).getSectionIndex());\n    }\n\n    @Test\n    public void updateDocumentSection10() throws XWikiException\n    {\n        List<DocumentSection> sections;\n        // Fill the document\n        this.document.setContent(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Content of section 3\");\n        String content = this.document.updateDocumentSection(3, \"1 Section 3\\n\" + \"Modified content of section 3\");\n        assertEquals(\"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\"\n            + \"Content of second section\\n\" + \"1 Section 3\\n\" + \"Modified content of section 3\", content);\n        this.document.setContent(content);\n        sections = this.document.getSections();\n        assertEquals(3, sections.size());\n        assertEquals(\"Section 1\", sections.get(0).getSectionTitle());\n        assertEquals(\n            \"1 Section 1\\n\" + \"Content of first section\\n\" + \"1.1 Subsection 2\\n\" + \"Content of second section\\n\",\n            this.document.getContentOfSection(1));\n        assertEquals(\"1.1\", sections.get(1).getSectionLevel());\n        assertEquals(\"1.1 Subsection 2\\nContent of second section\\n\", this.document.getContentOfSection(2));\n        assertEquals(3, sections.get(2).getSectionNumber());\n        assertEquals(80, sections.get(2).getSectionIndex());\n        assertEquals(\"1 Section 3\\nModified content of section 3\", this.document.getContentOfSection(3));\n    }\n\n    @Test\n    public void updateDocumentSection() throws XWikiException\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        // Modify section content\n        String content1 = this.document.updateDocumentSection(2, \"== header 2==\\nmodified header 2 content\");\n\n        assertEquals(\n            \"content not in section\\n\\n= header 1 =\\n\\nheader 1 content\\n\\n== header 2 ==\\n\\nmodified header 2 content\",\n            content1);\n\n        String content2 = this.document.updateDocumentSection(1,\n            \"= header 1 =\\n\\nmodified also header 1 content\\n\\n== header 2 ==\\n\\nheader 2 content\");\n\n        assertEquals(\n            \"content not in section\\n\\n= header 1 =\\n\\nmodified also header 1 content\\n\\n== header 2 ==\\n\\nheader 2 content\",\n            content2);\n\n        // Remove a section\n        String content3 = this.document.updateDocumentSection(2, \"\");\n\n        assertEquals(\"content not in section\\n\\n= header 1 =\\n\\nheader 1 content\", content3);\n    }\n\n    @Test\n    public void display()\n    {\n        when(this.xWiki.getCurrentContentSyntaxId(any())).thenReturn(\"xwiki/2.0\");\n\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\n            \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}<input size='30' id='Space.Page_0_string' value='string' name='Space.Page_0_string' type='text'/>{{/html}}\",\n            this.document.display(\"string\", \"edit\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"string\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        this.baseObject.setStringValue(\"string\", \"1 & 2\");\n\n        assertEquals(\"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}1 &#38; 2{{/html}}\",\n            this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        this.baseObject.setStringValue(\"string\", \"1 < 2\");\n\n        assertEquals(\"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}1 &#60; 2{{/html}}\",\n            this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        this.baseObject.setStringValue(\"string\", \"1 > 2\");\n\n        assertEquals(\"1 > 2\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}<p>area</p>{{/html}}\",\n            this.document.display(\"area\", \"view\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void display1020()\n    {\n        when(this.xWiki.getCurrentContentSyntaxId(any(), any())).thenReturn(\"xwiki/1.0\");\n\n        XWikiDocument doc10 = new XWikiDocument();\n        doc10.setSyntax(Syntax.XWIKI_1_0);\n        this.oldcore.getXWikiContext().setDoc(doc10);\n\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\"string\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n        assertEquals(\n            \"{pre}<input size='30' id='Space.Page_0_string' value='string' name='Space.Page_0_string' type='text'/>{/pre}\",\n            this.document.display(\"string\", \"edit\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>area</p>\", this.document.display(\"area\", \"view\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void displayTemplate20()\n    {\n        when(this.xWiki.getCurrentContentSyntaxId(any())).thenReturn(\"xwiki/2.0\");\n\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", false);\n\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\"string\", this.document.display(\"string\", \"view\", this.oldcore.getXWikiContext()));\n        assertEquals(\n            \"<input size='30' id='Space.Page_0_string' value='string' name='Space.Page_0_string' type='text'/>\",\n            this.document.display(\"string\", \"edit\", this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>area</p>\", this.document.display(\"area\", \"view\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    void displayEscapesClosingHTMLMacro()\n    {\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);\n        when(this.xWiki.getCurrentContentSyntaxId(any())).thenReturn(\"xwiki/2.1\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        BaseObject object = mock(BaseObject.class);\n        when(object.getOwnerDocument()).thenReturn(this.document);\n\n        BaseClass xClass = mock(BaseClass.class);\n        when(object.getXClass(any())).thenReturn(xClass);\n        PropertyClass propertyInterface = mock(PropertyClass.class);\n        when(xClass.get(\"mock\")).thenReturn(propertyInterface);\n        doAnswer(call -> {\n            call.getArgument(0, StringBuffer.class).append(\"{{/html}}content{{/html}}\");\n            return null;\n        }).when(propertyInterface).displayView(any(StringBuffer.class), eq(\"mock\"), any(String.class), eq(object),\n            anyBoolean(), any(XWikiContext.class));\n\n        assertEquals(\"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}&#123;&#123;/html}}content&#123;&#123;/html}}{{/html}}\",\n            this.document.display(\"mock\", \"view\", object, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void convertSyntax() throws XWikiException\n    {\n        this.document.setSyntax(Syntax.HTML_4_01);\n        this.document.setContent(\"<p>content not in section</p>\" + \"<h1>header 1</h1><p>header 1 content</p>\"\n            + \"<h2>header 2</h2><p>header 2 content</p>\");\n        this.baseObject.setLargeStringValue(\"area\",\n            \"<p>object content not in section</p>\" + \"<h1>object header 1</h1><p>object header 1 content</p>\"\n                + \"<h2>object header 2</h2><p>object header 2 content</p>\");\n        this.baseObject.setLargeStringValue(\"puretextarea\",\n            \"<p>object content not in section</p>\" + \"<h1>object header 1</h1><p>object header 1 content</p>\"\n                + \"<h2>object header 2</h2><p>object header 2 content</p>\");\n\n        this.document.convertSyntax(\"xwiki/2.0\", this.oldcore.getXWikiContext());\n\n        assertEquals(\"content not in section\\n\\n\" + \"= header 1 =\\n\\nheader 1 content\\n\\n\"\n            + \"== header 2 ==\\n\\nheader 2 content\", this.document.getContent());\n        assertEquals(\"object content not in section\\n\\n\" + \"= object header 1 =\\n\\nobject header 1 content\\n\\n\"\n            + \"== object header 2 ==\\n\\nobject header 2 content\", this.baseObject.getStringValue(\"area\"));\n        assertEquals(\n            \"<p>object content not in section</p>\" + \"<h1>object header 1</h1><p>object header 1 content</p>\"\n                + \"<h2>object header 2</h2><p>object header 2 content</p>\",\n            this.baseObject.getStringValue(\"puretextarea\"));\n        assertEquals(\"xwiki/2.0\", this.document.getSyntaxId());\n    }\n\n    @Test\n    public void getRenderedContent() throws XWikiException\n    {\n        this.document.setContent(\"**bold**\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        assertEquals(\"<p><strong>bold</strong></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n\n        this.translatedDocument = new XWikiDocument(this.document.getDocumentReference(), Locale.FRENCH);\n        this.translatedDocument.setContent(\"//italic//\");\n        this.translatedDocument.setSyntax(Syntax.XWIKI_1_0);\n        this.translatedDocument.setNew(false);\n\n        when(this.xWiki.getLanguagePreference(any())).thenReturn(Locale.FRENCH.toString());\n        when(this.xWiki.getDocument(eq(\n            new DocumentReference(this.translatedDocument.getDocumentReference(), this.translatedDocument.getLocale())),\n            any())).thenReturn(this.translatedDocument);\n\n        assertEquals(\"<p><em>italic</em></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentWithSourceSyntax()\n    {\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n\n        assertEquals(\"<p><strong>bold</strong></p>\",\n            this.document.getRenderedContent(\"**bold**\", \"xwiki/2.0\", this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Validate rename does not crash when the document has 1.0 syntax (it does not support everything but it does not\n     * crash).\n     */\n    @Test\n    public void rename10() throws XWikiException\n    {\n        this.document.setContent(\"[pageinsamespace]\");\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n        DocumentReference targetReference = new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\");\n        XWikiDocument targetDocument = this.document.duplicate(targetReference);\n\n        when(this.xWiki.copyDocument(any(), any(), any())).thenReturn(true);\n        when(this.xWiki.getDocument(eq(targetReference), any())).thenReturn(targetDocument);\n\n        this.document.rename(new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\"),\n            Collections.emptyList(), Collections.emptyList(),\n            this.oldcore.getXWikiContext());\n\n        // Test links\n        assertEquals(\"[pageinsamespace]\", this.document.getContent());\n    }\n\n    /**\n     * @see \"XWIKI-7515: 'getIncludedPages' in class com.xpn.xwiki.api.Document threw java.lang.NullPointerException\"\n     */\n    @Test\n    public void getIncludedPages()\n    {\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n\n        this.document.setContent(\"no include\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"bad {{include/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"good deprecated {{include document=\\\"Foo.Bar\\\"/}}\");\n        assertEquals(Arrays.asList(\"Foo.Bar\"), this.document.getIncludedPages(this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"good {{include reference=\\\"One.Two\\\"/}}\");\n        assertEquals(Arrays.asList(\"One.Two\"), this.document.getIncludedPages(this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"bad recursive {{include reference=\\\"\\\"/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"bad recursive {{include reference=\\\"\" + DOCNAME + \"\\\"/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n\n        this.document.setContent(\"bad recursive {{include reference=\\\"\" + DOCSPACE + \".\" + DOCNAME + \"\\\"/}}\");\n        assertTrue(this.document.getIncludedPages(this.oldcore.getXWikiContext()).isEmpty());\n    }\n\n    /**\n     * XWIKI-8025: XWikiDocument#backup/restoreContext doesn't update the reference to the Velocity context stored on\n     * the XWiki context\n     */\n    @Test\n    public void backupRestoreContextUpdatesVContext() throws Exception\n    {\n        final Execution execution = this.oldcore.getMocker().getInstance(Execution.class);\n\n        when(this.velocityManager.getVelocityContext())\n            .then(invocationOnMock -> execution.getContext().getProperty(\"velocityContext\"));\n\n        VelocityContext oldVelocityContext = new VelocityContext();\n        execution.getContext().setProperty(\"velocityContext\", oldVelocityContext);\n\n        Map<String, Object> backup = new HashMap<>();\n        XWikiDocument.backupContext(backup, this.oldcore.getXWikiContext());\n\n        VelocityContext newVelocityContext = (VelocityContext) execution.getContext().getProperty(\"velocityContext\");\n        assertNotNull(newVelocityContext);\n        assertNotSame(oldVelocityContext, newVelocityContext);\n        assertSame(newVelocityContext, this.oldcore.getXWikiContext().get(\"vcontext\"));\n\n        XWikiDocument.restoreContext(backup, this.oldcore.getXWikiContext());\n\n        assertSame(oldVelocityContext, execution.getContext().getProperty(\"velocityContext\"));\n        assertSame(oldVelocityContext, this.oldcore.getXWikiContext().get(\"vcontext\"));\n    }\n\n    @Test\n    public void getIntValue()\n    {\n        assertEquals(42, this.document.getIntValue(CLASS_REFERENCE, \"int\", 99));\n        assertEquals(42, this.document.getIntValue(CLASS_REFERENCE, \"int\"));\n\n        assertEquals(0, this.document.getIntValue(CLASS_REFERENCE, \"foo\"));\n        assertEquals(99, this.document.getIntValue(CLASS_REFERENCE, \"foo\", 99));\n\n        assertEquals(0, this.document.getIntValue(new DocumentReference(\"foo\", \"bar\", \"bla\"), \"foo\"));\n        assertEquals(99, this.document.getIntValue(new DocumentReference(\"foo\", \"bar\", \"bla\"), \"foo\", 99));\n    }\n\n    @Test\n    void getAttachment() throws Exception\n    {\n        this.document.setAttachment(\"file.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNotNull(this.document.getAttachment(\"file.txt\"));\n    }\n    \n    @Test\n    void getAttachmentWithExtension() throws Exception\n    {\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file.txt.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNotNull(this.document.getAttachment(\"file.txt\"));\n    }\n\n    @Test\n    void getExactAttachment() throws Exception\n    {\n        this.document.setAttachment(\"file.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNotNull(this.document.getExactAttachment(\"file.txt\"));\n    }\n\n    @Test\n    void getExactAttachmentWithExtension() throws Exception\n    {\n        this.document.setAttachment(\"file2.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file.txt.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        assertNull(this.document.getExactAttachment(\"file.txt\"));\n    }\n\n    /**\n     * Validate that an attachment with the same name less the extension as an existing attachment does not override it.\n     */\n    @Test\n    void setAttachment() throws Exception\n    {\n        this.document.setAttachment(\"file.txt\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        this.document.setAttachment(\"file\", IOUtils.toInputStream(\"\", Charset.defaultCharset()),\n            this.oldcore.getXWikiContext());\n        List<XWikiAttachment> attachmentList = this.document.getAttachmentList();\n        assertEquals(2, attachmentList.size());\n        assertEquals(\"file.txt\", attachmentList.get(1).getFilename());\n        assertEquals(\"file\", attachmentList.get(0).getFilename());\n    }\n\n    /*\n     * Test for checking that cloneInternal doesn't replace the XWikiDocumentArchive by an empty document archive,\n     * and to ensure that the versioningStore is properly called when using\n     * XWikiDocument#getDocumentArchive(XWikiContext).\n     */\n    @Test\n    void getDocumentArchiveAfterClone() throws XWikiException\n    {\n        XWikiContext context = this.oldcore.getXWikiContext();\n        XWikiVersioningStoreInterface versioningStore =\n            this.document.getVersioningStore(context);\n        when(versioningStore.getXWikiDocumentArchive(any(), any())).then(invocationOnMock -> {\n            XWikiDocument doc = invocationOnMock.getArgument(0);\n            if (doc.getDocumentArchive() != null) {\n                return doc.getDocumentArchive();\n            } else {\n                return mock(XWikiDocumentArchive.class);\n            }\n        });\n        assertSame(versioningStore, document.getVersioningStore(context));\n        assertNull(this.document.getDocumentArchive());\n        XWikiDocumentArchive documentArchive = this.document.getDocumentArchive(context);\n        assertNotNull(documentArchive);\n        assertNotNull(this.document.getDocumentArchive());\n\n        XWikiDocument cloneDoc = document.clone();\n        assertNull(cloneDoc.getDocumentArchive());\n        XWikiDocumentArchive cloneArchive = cloneDoc.getDocumentArchive(context);\n        verify(versioningStore).getXWikiDocumentArchive(\n            argThat(givenDoc -> givenDoc != XWikiDocumentTest.this.document), eq(context));\n        assertNotNull(cloneArchive);\n        assertNotSame(cloneArchive, documentArchive);\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/doc/XWikiDocumentTest.java"], "buggy_code_start_loc": [222, 61], "buggy_code_end_loc": [3892, 650], "fixing_code_start_loc": [223, 62], "fixing_code_end_loc": [3903, 678], "type": "CWE-74", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Any user who can edit their own user profile can execute arbitrary script macros including Groovy and Python macros that allow remote code execution including unrestricted read and write access to all wiki contents. The same vulnerability can also be exploited in other contexts where the `display` method on a document is used to display a field with wiki syntax, for example in applications created using `App Within Minutes`. This has been patched in XWiki 13.10.11, 14.4.8, 14.10.2 and 15.0RC1. There is no workaround apart from upgrading.", "other": {"cve": {"id": "CVE-2023-29523", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-19T00:15:08.987", "lastModified": "2023-05-01T16:31:27.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Any user who can edit their own user profile can execute arbitrary script macros including Groovy and Python macros that allow remote code execution including unrestricted read and write access to all wiki contents. The same vulnerability can also be exploited in other contexts where the `display` method on a document is used to display a field with wiki syntax, for example in applications created using `App Within Minutes`. This has been patched in XWiki 13.10.11, 14.4.8, 14.10.2 and 15.0RC1. There is no workaround apart from upgrading."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.10.11", "matchCriteriaId": "A3CD7FFB-D491-4B7D-839D-D567B0C00E59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0", "versionEndExcluding": "14.4.8", "matchCriteriaId": "AD2B185D-F8A6-49EB-B485-744F234B8730"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.5", "versionEndExcluding": "14.10.2", "matchCriteriaId": "E472CD99-824B-4235-B9AB-2740FB40F601"}]}]}], "references": [{"url": "https://extensions.xwiki.org/xwiki/bin/view/Extension/App%20Within%20Minutes%20Application", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/xwiki/xwiki-platform/commit/0d547181389f7941e53291af940966413823f61c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-x764-ff8r-9hpx", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-20327", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/0d547181389f7941e53291af940966413823f61c"}}