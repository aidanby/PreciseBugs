{"buggy_code": ["/*\n *\n * Copyright (C) 2011 Novell Inc.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 as published by\n * the Free Software Foundation.\n */\n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/cred.h>\n#include \"overlayfs.h\"\n\nvoid ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}\n\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}\n\n/* caller holds i_mutex on workdir */\nstatic struct dentry *ovl_whiteout(struct dentry *workdir,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *whiteout;\n\tstruct inode *wdir = workdir->d_inode;\n\n\twhiteout = ovl_lookup_temp(workdir, dentry);\n\tif (IS_ERR(whiteout))\n\t\treturn whiteout;\n\n\terr = ovl_do_whiteout(wdir, whiteout);\n\tif (err) {\n\t\tdput(whiteout);\n\t\twhiteout = ERR_PTR(err);\n\t}\n\n\treturn whiteout;\n}\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}\n\nstatic int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}\n\nstatic void ovl_remove_opaque(struct dentry *upperdentry)\n{\n\tint err;\n\n\terr = ovl_do_removexattr(upperdentry, OVL_XATTR_OPAQUE);\n\tif (err) {\n\t\tpr_warn(\"overlayfs: failed to remove opaque from '%s' (%i)\\n\",\n\t\t\tupperdentry->d_name.name, err);\n\t}\n}\n\nstatic int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t struct kstat *stat)\n{\n\tint err;\n\tenum ovl_path_type type;\n\tstruct path realpath;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\terr = vfs_getattr(&realpath, stat);\n\tif (err)\n\t\treturn err;\n\n\tstat->dev = dentry->d_sb->s_dev;\n\tstat->ino = dentry->d_inode->i_ino;\n\n\t/*\n\t * It's probably not worth it to count subdirs to get the\n\t * correct link count.  nlink=1 seems to pacify 'find' and\n\t * other utilities.\n\t */\n\tif (OVL_TYPE_MERGE(type))\n\t\tstat->nlink = 1;\n\n\treturn 0;\n}\n\nstatic int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct kstat *stat, const char *link,\n\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\n\tnewdentry = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t   dentry->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\terr = ovl_create_real(udir, newdentry, stat, link, hardlink, false);\n\tif (err)\n\t\tgoto out_dput;\n\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tinode_unlock(udir);\n\treturn err;\n}\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}\n\nstatic struct dentry *ovl_clear_empty(struct dentry *dentry,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct path upperpath;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir;\n\tstruct kstat stat;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn ERR_PTR(-EROFS);\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tovl_path_upper(dentry, &upperpath);\n\terr = vfs_getattr(&upperpath, &stat);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!S_ISDIR(stat.mode))\n\t\tgoto out_unlock;\n\tupper = upperpath.dentry;\n\tif (upper->d_parent->d_inode != udir)\n\t\tgoto out_unlock;\n\n\topaquedir = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(opaquedir);\n\tif (IS_ERR(opaquedir))\n\t\tgoto out_unlock;\n\n\terr = ovl_create_real(wdir, opaquedir, &stat, NULL, NULL, true);\n\tif (err)\n\t\tgoto out_dput;\n\n\terr = ovl_copy_xattr(upper, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_set_opaque(opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tinode_lock(opaquedir->d_inode);\n\terr = ovl_set_attr(opaquedir, &stat);\n\tinode_unlock(opaquedir->d_inode);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, opaquedir, udir, upper, RENAME_EXCHANGE);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_cleanup_whiteouts(upper, list);\n\tovl_cleanup(wdir, upper);\n\tunlock_rename(workdir, upperdir);\n\n\t/* dentry's upper doesn't match now, get rid of it */\n\td_drop(dentry);\n\n\treturn opaquedir;\n\nout_cleanup:\n\tovl_cleanup(wdir, opaquedir);\nout_dput:\n\tdput(opaquedir);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}\n\nstatic int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\n\t\t\t\t    struct kstat *stat, const char *link,\n\t\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_dput;\n\n\terr = ovl_create_real(wdir, newdentry, stat, link, hardlink, true);\n\tif (err)\n\t\tgoto out_dput2;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper,\n\t\t\t\t    RENAME_EXCHANGE);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\tovl_cleanup(wdir, upper);\n\t} else {\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput2:\n\tdput(upper);\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out_dput2;\n}\n\nstatic int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}\n\nstatic int ovl_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFREG, 0, NULL);\n}\n\nstatic int ovl_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFDIR, 0, NULL);\n}\n\nstatic int ovl_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\t/* Don't allow creation of \"whiteout\" on overlay */\n\tif (S_ISCHR(mode) && rdev == WHITEOUT_DEV)\n\t\treturn -EPERM;\n\n\treturn ovl_create_object(dentry, mode, rdev, NULL);\n}\n\nstatic int ovl_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *link)\n{\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\n}\n\nstatic int ovl_link(struct dentry *old, struct inode *newdir,\n\t\t    struct dentry *new)\n{\n\tint err;\n\tstruct dentry *upper;\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tupper = ovl_dentry_upper(old);\n\terr = ovl_create_or_link(new, upper->d_inode->i_mode, 0, NULL, upper);\n\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\treturn err;\n}\n\nstatic int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *whiteout;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\tif (is_dir) {\n\t\tif (OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {\n\t\t\topaquedir = ovl_check_empty_and_clear(dentry);\n\t\t\terr = PTR_ERR(opaquedir);\n\t\t\tif (IS_ERR(opaquedir))\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tLIST_HEAD(list);\n\n\t\t\t/*\n\t\t\t * When removing an empty opaque directory, then it\n\t\t\t * makes no sense to replace it with an exact replica of\n\t\t\t * itself.  But emptiness still needs to be checked.\n\t\t\t */\n\t\t\terr = ovl_check_empty_dir(dentry, &list);\n\t\t\tovl_cache_free(&list);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out_dput;\n\n\twhiteout = ovl_whiteout(workdir, dentry);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\tgoto out_unlock;\n\n\tupper = ovl_dentry_upper(dentry);\n\tif (!upper) {\n\t\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t       dentry->d_name.len);\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR(upper))\n\t\t\tgoto kill_whiteout;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, 0);\n\t\tdput(upper);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (opaquedir)\n\t\t\tupper = opaquedir;\n\t\terr = -ESTALE;\n\t\tif (upper->d_parent != upperdir)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tflags |= RENAME_EXCHANGE;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, flags);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tovl_cleanup(wdir, upper);\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\nout_d_drop:\n\td_drop(dentry);\n\tdput(whiteout);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_dput:\n\tdput(opaquedir);\nout:\n\treturn err;\n\nkill_whiteout:\n\tovl_cleanup(wdir, whiteout);\n\tgoto out_d_drop;\n}\n\nstatic int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\t/* Don't let d_delete() think it can reset d_inode */\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\n\t/*\n\t * Keeping this dentry hashed would mean having to release\n\t * upperpath/lowerpath, which could only be done if we are the\n\t * sole user of this dentry.  Too tricky...  Just unhash for\n\t * now.\n\t */\n\tif (!err)\n\t\td_drop(dentry);\n\tinode_unlock(dir);\n\n\treturn err;\n}\n\nstatic inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}\n\nstatic int ovl_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, false);\n}\n\nstatic int ovl_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, true);\n}\n\nstatic int ovl_rename2(struct inode *olddir, struct dentry *old,\n\t\t       struct inode *newdir, struct dentry *new,\n\t\t       unsigned int flags)\n{\n\tint err;\n\tenum ovl_path_type old_type;\n\tenum ovl_path_type new_type;\n\tstruct dentry *old_upperdir;\n\tstruct dentry *new_upperdir;\n\tstruct dentry *olddentry;\n\tstruct dentry *newdentry;\n\tstruct dentry *trap;\n\tbool old_opaque;\n\tbool new_opaque;\n\tbool new_create = false;\n\tbool cleanup_whiteout = false;\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\n\tbool is_dir = d_is_dir(old);\n\tbool new_is_dir = false;\n\tstruct dentry *opaquedir = NULL;\n\tconst struct cred *old_cred = NULL;\n\tstruct cred *override_cred = NULL;\n\n\terr = -EINVAL;\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\n\t\tgoto out;\n\n\tflags &= ~RENAME_NOREPLACE;\n\n\terr = ovl_check_sticky(old);\n\tif (err)\n\t\tgoto out;\n\n\t/* Don't copy up directory trees */\n\told_type = ovl_path_type(old);\n\terr = -EXDEV;\n\tif (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir)\n\t\tgoto out;\n\n\tif (new->d_inode) {\n\t\terr = ovl_check_sticky(new);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (d_is_dir(new))\n\t\t\tnew_is_dir = true;\n\n\t\tnew_type = ovl_path_type(new);\n\t\terr = -EXDEV;\n\t\tif (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir)\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tif (!OVL_TYPE_UPPER(new_type) && !OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_lower(old)->d_inode ==\n\t\t\t    ovl_dentry_lower(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (OVL_TYPE_UPPER(new_type) && OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_upper(old)->d_inode ==\n\t\t\t    ovl_dentry_upper(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (ovl_dentry_is_opaque(new))\n\t\t\tnew_type = __OVL_PATH_UPPER;\n\t\telse\n\t\t\tnew_type = __OVL_PATH_UPPER | __OVL_PATH_PURE;\n\t}\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\tif (!overwrite) {\n\t\terr = ovl_copy_up(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t}\n\n\told_opaque = !OVL_TYPE_PURE_UPPER(old_type);\n\tnew_opaque = !OVL_TYPE_PURE_UPPER(new_type);\n\n\tif (old_opaque || new_opaque) {\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\t}\n\n\tif (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) {\n\t\topaquedir = ovl_check_empty_and_clear(new);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir)) {\n\t\t\topaquedir = NULL;\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\tif (overwrite) {\n\t\tif (old_opaque) {\n\t\t\tif (new->d_inode || !new_opaque) {\n\t\t\t\t/* Whiteout source */\n\t\t\t\tflags |= RENAME_WHITEOUT;\n\t\t\t} else {\n\t\t\t\t/* Switch whiteouts */\n\t\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\t}\n\t\t} else if (is_dir && !new->d_inode && new_opaque) {\n\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\tcleanup_whiteout = true;\n\t\t}\n\t}\n\n\told_upperdir = ovl_dentry_upper(old->d_parent);\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\n\n\ttrap = lock_rename(new_upperdir, old_upperdir);\n\n\tolddentry = ovl_dentry_upper(old);\n\tnewdentry = ovl_dentry_upper(new);\n\tif (newdentry) {\n\t\tif (opaquedir) {\n\t\t\tnewdentry = opaquedir;\n\t\t\topaquedir = NULL;\n\t\t} else {\n\t\t\tdget(newdentry);\n\t\t}\n\t} else {\n\t\tnew_create = true;\n\t\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n\t\t\t\t\t   new->d_name.len);\n\t\terr = PTR_ERR(newdentry);\n\t\tif (IS_ERR(newdentry))\n\t\t\tgoto out_unlock;\n\t}\n\n\terr = -ESTALE;\n\tif (olddentry->d_parent != old_upperdir)\n\t\tgoto out_dput;\n\tif (newdentry->d_parent != new_upperdir)\n\t\tgoto out_dput;\n\tif (olddentry == trap)\n\t\tgoto out_dput;\n\tif (newdentry == trap)\n\t\tgoto out_dput;\n\n\tif (is_dir && !old_opaque && new_opaque) {\n\t\terr = ovl_set_opaque(olddentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\tif (!overwrite && new_is_dir && old_opaque && !new_opaque) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\tif (old_opaque || new_opaque) {\n\t\terr = ovl_do_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t    new_upperdir->d_inode, newdentry,\n\t\t\t\t    flags);\n\t} else {\n\t\t/* No debug for the plain case */\n\t\tBUG_ON(flags & ~RENAME_EXCHANGE);\n\t\terr = vfs_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t new_upperdir->d_inode, newdentry,\n\t\t\t\t NULL, flags);\n\t}\n\n\tif (err) {\n\t\tif (is_dir && !old_opaque && new_opaque)\n\t\t\tovl_remove_opaque(olddentry);\n\t\tif (!overwrite && new_is_dir && old_opaque && !new_opaque)\n\t\t\tovl_remove_opaque(newdentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (is_dir && old_opaque && !new_opaque)\n\t\tovl_remove_opaque(olddentry);\n\tif (!overwrite && new_is_dir && !old_opaque && new_opaque)\n\t\tovl_remove_opaque(newdentry);\n\n\t/*\n\t * Old dentry now lives in different location. Dentries in\n\t * lowerstack are stale. We cannot drop them here because\n\t * access to them is lockless. This could be only pure upper\n\t * or opaque directory - numlower is zero. Or upper non-dir\n\t * entry - its pureness is tracked by flag opaque.\n\t */\n\tif (old_opaque != new_opaque) {\n\t\tovl_dentry_set_opaque(old, new_opaque);\n\t\tif (!overwrite)\n\t\t\tovl_dentry_set_opaque(new, old_opaque);\n\t}\n\n\tif (cleanup_whiteout)\n\t\tovl_cleanup(old_upperdir->d_inode, newdentry);\n\n\tovl_dentry_version_inc(old->d_parent);\n\tovl_dentry_version_inc(new->d_parent);\n\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(new_upperdir, old_upperdir);\nout_revert_creds:\n\tif (old_opaque || new_opaque) {\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\tdput(opaquedir);\n\treturn err;\n}\n\nconst struct inode_operations ovl_dir_inode_operations = {\n\t.lookup\t\t= ovl_lookup,\n\t.mkdir\t\t= ovl_mkdir,\n\t.symlink\t= ovl_symlink,\n\t.unlink\t\t= ovl_unlink,\n\t.rmdir\t\t= ovl_rmdir,\n\t.rename2\t= ovl_rename2,\n\t.link\t\t= ovl_link,\n\t.setattr\t= ovl_setattr,\n\t.create\t\t= ovl_create,\n\t.mknod\t\t= ovl_mknod,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_dir_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};\n"], "fixing_code": ["/*\n *\n * Copyright (C) 2011 Novell Inc.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 as published by\n * the Free Software Foundation.\n */\n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/cred.h>\n#include \"overlayfs.h\"\n\nvoid ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}\n\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}\n\n/* caller holds i_mutex on workdir */\nstatic struct dentry *ovl_whiteout(struct dentry *workdir,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *whiteout;\n\tstruct inode *wdir = workdir->d_inode;\n\n\twhiteout = ovl_lookup_temp(workdir, dentry);\n\tif (IS_ERR(whiteout))\n\t\treturn whiteout;\n\n\terr = ovl_do_whiteout(wdir, whiteout);\n\tif (err) {\n\t\tdput(whiteout);\n\t\twhiteout = ERR_PTR(err);\n\t}\n\n\treturn whiteout;\n}\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}\n\nstatic int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}\n\nstatic void ovl_remove_opaque(struct dentry *upperdentry)\n{\n\tint err;\n\n\terr = ovl_do_removexattr(upperdentry, OVL_XATTR_OPAQUE);\n\tif (err) {\n\t\tpr_warn(\"overlayfs: failed to remove opaque from '%s' (%i)\\n\",\n\t\t\tupperdentry->d_name.name, err);\n\t}\n}\n\nstatic int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t struct kstat *stat)\n{\n\tint err;\n\tenum ovl_path_type type;\n\tstruct path realpath;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\terr = vfs_getattr(&realpath, stat);\n\tif (err)\n\t\treturn err;\n\n\tstat->dev = dentry->d_sb->s_dev;\n\tstat->ino = dentry->d_inode->i_ino;\n\n\t/*\n\t * It's probably not worth it to count subdirs to get the\n\t * correct link count.  nlink=1 seems to pacify 'find' and\n\t * other utilities.\n\t */\n\tif (OVL_TYPE_MERGE(type))\n\t\tstat->nlink = 1;\n\n\treturn 0;\n}\n\nstatic int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct kstat *stat, const char *link,\n\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\n\tnewdentry = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t   dentry->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\terr = ovl_create_real(udir, newdentry, stat, link, hardlink, false);\n\tif (err)\n\t\tgoto out_dput;\n\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tinode_unlock(udir);\n\treturn err;\n}\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}\n\nstatic struct dentry *ovl_clear_empty(struct dentry *dentry,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct path upperpath;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir;\n\tstruct kstat stat;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn ERR_PTR(-EROFS);\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tovl_path_upper(dentry, &upperpath);\n\terr = vfs_getattr(&upperpath, &stat);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!S_ISDIR(stat.mode))\n\t\tgoto out_unlock;\n\tupper = upperpath.dentry;\n\tif (upper->d_parent->d_inode != udir)\n\t\tgoto out_unlock;\n\n\topaquedir = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(opaquedir);\n\tif (IS_ERR(opaquedir))\n\t\tgoto out_unlock;\n\n\terr = ovl_create_real(wdir, opaquedir, &stat, NULL, NULL, true);\n\tif (err)\n\t\tgoto out_dput;\n\n\terr = ovl_copy_xattr(upper, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_set_opaque(opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tinode_lock(opaquedir->d_inode);\n\terr = ovl_set_attr(opaquedir, &stat);\n\tinode_unlock(opaquedir->d_inode);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, opaquedir, udir, upper, RENAME_EXCHANGE);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_cleanup_whiteouts(upper, list);\n\tovl_cleanup(wdir, upper);\n\tunlock_rename(workdir, upperdir);\n\n\t/* dentry's upper doesn't match now, get rid of it */\n\td_drop(dentry);\n\n\treturn opaquedir;\n\nout_cleanup:\n\tovl_cleanup(wdir, opaquedir);\nout_dput:\n\tdput(opaquedir);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}\n\nstatic int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\n\t\t\t\t    struct kstat *stat, const char *link,\n\t\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_dput;\n\n\terr = ovl_create_real(wdir, newdentry, stat, link, hardlink, true);\n\tif (err)\n\t\tgoto out_dput2;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper,\n\t\t\t\t    RENAME_EXCHANGE);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\tovl_cleanup(wdir, upper);\n\t} else {\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput2:\n\tdput(upper);\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out_dput2;\n}\n\nstatic int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}\n\nstatic int ovl_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFREG, 0, NULL);\n}\n\nstatic int ovl_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFDIR, 0, NULL);\n}\n\nstatic int ovl_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\t/* Don't allow creation of \"whiteout\" on overlay */\n\tif (S_ISCHR(mode) && rdev == WHITEOUT_DEV)\n\t\treturn -EPERM;\n\n\treturn ovl_create_object(dentry, mode, rdev, NULL);\n}\n\nstatic int ovl_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *link)\n{\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\n}\n\nstatic int ovl_link(struct dentry *old, struct inode *newdir,\n\t\t    struct dentry *new)\n{\n\tint err;\n\tstruct dentry *upper;\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tupper = ovl_dentry_upper(old);\n\terr = ovl_create_or_link(new, upper->d_inode->i_mode, 0, NULL, upper);\n\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\treturn err;\n}\n\nstatic int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *whiteout;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\tif (is_dir) {\n\t\tif (OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {\n\t\t\topaquedir = ovl_check_empty_and_clear(dentry);\n\t\t\terr = PTR_ERR(opaquedir);\n\t\t\tif (IS_ERR(opaquedir))\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tLIST_HEAD(list);\n\n\t\t\t/*\n\t\t\t * When removing an empty opaque directory, then it\n\t\t\t * makes no sense to replace it with an exact replica of\n\t\t\t * itself.  But emptiness still needs to be checked.\n\t\t\t */\n\t\t\terr = ovl_check_empty_dir(dentry, &list);\n\t\t\tovl_cache_free(&list);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out_dput;\n\n\twhiteout = ovl_whiteout(workdir, dentry);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\tgoto out_unlock;\n\n\tupper = ovl_dentry_upper(dentry);\n\tif (!upper) {\n\t\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t       dentry->d_name.len);\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR(upper))\n\t\t\tgoto kill_whiteout;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, 0);\n\t\tdput(upper);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (opaquedir)\n\t\t\tupper = opaquedir;\n\t\terr = -ESTALE;\n\t\tif (upper->d_parent != upperdir)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tflags |= RENAME_EXCHANGE;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, flags);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tovl_cleanup(wdir, upper);\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\nout_d_drop:\n\td_drop(dentry);\n\tdput(whiteout);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_dput:\n\tdput(opaquedir);\nout:\n\treturn err;\n\nkill_whiteout:\n\tovl_cleanup(wdir, whiteout);\n\tgoto out_d_drop;\n}\n\nstatic int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tint err;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (upper == ovl_dentry_upper(dentry)) {\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\tdput(upper);\n\n\t/*\n\t * Keeping this dentry hashed would mean having to release\n\t * upperpath/lowerpath, which could only be done if we are the\n\t * sole user of this dentry.  Too tricky...  Just unhash for\n\t * now.\n\t */\n\tif (!err)\n\t\td_drop(dentry);\nout_unlock:\n\tinode_unlock(dir);\n\n\treturn err;\n}\n\nstatic inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}\n\nstatic int ovl_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, false);\n}\n\nstatic int ovl_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, true);\n}\n\nstatic int ovl_rename2(struct inode *olddir, struct dentry *old,\n\t\t       struct inode *newdir, struct dentry *new,\n\t\t       unsigned int flags)\n{\n\tint err;\n\tenum ovl_path_type old_type;\n\tenum ovl_path_type new_type;\n\tstruct dentry *old_upperdir;\n\tstruct dentry *new_upperdir;\n\tstruct dentry *olddentry;\n\tstruct dentry *newdentry;\n\tstruct dentry *trap;\n\tbool old_opaque;\n\tbool new_opaque;\n\tbool new_create = false;\n\tbool cleanup_whiteout = false;\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\n\tbool is_dir = d_is_dir(old);\n\tbool new_is_dir = false;\n\tstruct dentry *opaquedir = NULL;\n\tconst struct cred *old_cred = NULL;\n\tstruct cred *override_cred = NULL;\n\n\terr = -EINVAL;\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\n\t\tgoto out;\n\n\tflags &= ~RENAME_NOREPLACE;\n\n\terr = ovl_check_sticky(old);\n\tif (err)\n\t\tgoto out;\n\n\t/* Don't copy up directory trees */\n\told_type = ovl_path_type(old);\n\terr = -EXDEV;\n\tif (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir)\n\t\tgoto out;\n\n\tif (new->d_inode) {\n\t\terr = ovl_check_sticky(new);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (d_is_dir(new))\n\t\t\tnew_is_dir = true;\n\n\t\tnew_type = ovl_path_type(new);\n\t\terr = -EXDEV;\n\t\tif (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir)\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tif (!OVL_TYPE_UPPER(new_type) && !OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_lower(old)->d_inode ==\n\t\t\t    ovl_dentry_lower(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (OVL_TYPE_UPPER(new_type) && OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_upper(old)->d_inode ==\n\t\t\t    ovl_dentry_upper(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (ovl_dentry_is_opaque(new))\n\t\t\tnew_type = __OVL_PATH_UPPER;\n\t\telse\n\t\t\tnew_type = __OVL_PATH_UPPER | __OVL_PATH_PURE;\n\t}\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\tif (!overwrite) {\n\t\terr = ovl_copy_up(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t}\n\n\told_opaque = !OVL_TYPE_PURE_UPPER(old_type);\n\tnew_opaque = !OVL_TYPE_PURE_UPPER(new_type);\n\n\tif (old_opaque || new_opaque) {\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\t}\n\n\tif (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) {\n\t\topaquedir = ovl_check_empty_and_clear(new);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir)) {\n\t\t\topaquedir = NULL;\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\tif (overwrite) {\n\t\tif (old_opaque) {\n\t\t\tif (new->d_inode || !new_opaque) {\n\t\t\t\t/* Whiteout source */\n\t\t\t\tflags |= RENAME_WHITEOUT;\n\t\t\t} else {\n\t\t\t\t/* Switch whiteouts */\n\t\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\t}\n\t\t} else if (is_dir && !new->d_inode && new_opaque) {\n\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\tcleanup_whiteout = true;\n\t\t}\n\t}\n\n\told_upperdir = ovl_dentry_upper(old->d_parent);\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\n\n\ttrap = lock_rename(new_upperdir, old_upperdir);\n\n\n\tolddentry = lookup_one_len(old->d_name.name, old_upperdir,\n\t\t\t\t   old->d_name.len);\n\terr = PTR_ERR(olddentry);\n\tif (IS_ERR(olddentry))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (olddentry != ovl_dentry_upper(old))\n\t\tgoto out_dput_old;\n\n\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n\t\t\t\t   new->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_dput_old;\n\n\terr = -ESTALE;\n\tif (ovl_dentry_upper(new)) {\n\t\tif (opaquedir) {\n\t\t\tif (newdentry != opaquedir)\n\t\t\t\tgoto out_dput;\n\t\t} else {\n\t\t\tif (newdentry != ovl_dentry_upper(new))\n\t\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tnew_create = true;\n\t\tif (!d_is_negative(newdentry) &&\n\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))\n\t\t\tgoto out_dput;\n\t}\n\n\tif (olddentry == trap)\n\t\tgoto out_dput;\n\tif (newdentry == trap)\n\t\tgoto out_dput;\n\n\tif (is_dir && !old_opaque && new_opaque) {\n\t\terr = ovl_set_opaque(olddentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\tif (!overwrite && new_is_dir && old_opaque && !new_opaque) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\tif (old_opaque || new_opaque) {\n\t\terr = ovl_do_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t    new_upperdir->d_inode, newdentry,\n\t\t\t\t    flags);\n\t} else {\n\t\t/* No debug for the plain case */\n\t\tBUG_ON(flags & ~RENAME_EXCHANGE);\n\t\terr = vfs_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t new_upperdir->d_inode, newdentry,\n\t\t\t\t NULL, flags);\n\t}\n\n\tif (err) {\n\t\tif (is_dir && !old_opaque && new_opaque)\n\t\t\tovl_remove_opaque(olddentry);\n\t\tif (!overwrite && new_is_dir && old_opaque && !new_opaque)\n\t\t\tovl_remove_opaque(newdentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (is_dir && old_opaque && !new_opaque)\n\t\tovl_remove_opaque(olddentry);\n\tif (!overwrite && new_is_dir && !old_opaque && new_opaque)\n\t\tovl_remove_opaque(newdentry);\n\n\t/*\n\t * Old dentry now lives in different location. Dentries in\n\t * lowerstack are stale. We cannot drop them here because\n\t * access to them is lockless. This could be only pure upper\n\t * or opaque directory - numlower is zero. Or upper non-dir\n\t * entry - its pureness is tracked by flag opaque.\n\t */\n\tif (old_opaque != new_opaque) {\n\t\tovl_dentry_set_opaque(old, new_opaque);\n\t\tif (!overwrite)\n\t\t\tovl_dentry_set_opaque(new, old_opaque);\n\t}\n\n\tif (cleanup_whiteout)\n\t\tovl_cleanup(old_upperdir->d_inode, newdentry);\n\n\tovl_dentry_version_inc(old->d_parent);\n\tovl_dentry_version_inc(new->d_parent);\n\nout_dput:\n\tdput(newdentry);\nout_dput_old:\n\tdput(olddentry);\nout_unlock:\n\tunlock_rename(new_upperdir, old_upperdir);\nout_revert_creds:\n\tif (old_opaque || new_opaque) {\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\tdput(opaquedir);\n\treturn err;\n}\n\nconst struct inode_operations ovl_dir_inode_operations = {\n\t.lookup\t\t= ovl_lookup,\n\t.mkdir\t\t= ovl_mkdir,\n\t.symlink\t= ovl_symlink,\n\t.unlink\t\t= ovl_unlink,\n\t.rmdir\t\t= ovl_rmdir,\n\t.rename2\t= ovl_rename2,\n\t.link\t\t= ovl_link,\n\t.setattr\t= ovl_setattr,\n\t.create\t\t= ovl_create,\n\t.mknod\t\t= ovl_mknod,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_dir_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};\n"], "filenames": ["fs/overlayfs/dir.c"], "buggy_code_start_loc": [599], "buggy_code_end_loc": [927], "fixing_code_start_loc": [599], "fixing_code_end_loc": [945], "type": "CWE-20", "message": "fs/overlayfs/dir.c in the OverlayFS filesystem implementation in the Linux kernel before 4.6 does not properly verify the upper dentry before proceeding with unlink and rename system-call processing, which allows local users to cause a denial of service (system crash) via a rename system call that specifies a self-hardlink.", "other": {"cve": {"id": "CVE-2016-6197", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-06T20:59:12.067", "lastModified": "2019-12-27T16:08:47.953", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/overlayfs/dir.c in the OverlayFS filesystem implementation in the Linux kernel before 4.6 does not properly verify the upper dentry before proceeding with unlink and rename system-call processing, which allows local users to cause a denial of service (system crash) via a rename system call that specifies a self-hardlink."}, {"lang": "es", "value": "fs/overlayfs/dir.c en la implementaci\u00f3n del sistema de archivos OverlayFS en el kernel de Linux en versiones anteriores a 4.6 no verifica adecuadamente la dentry superior antes de proceder con el procesamiento de desconexi\u00f3n y cambio de nombre de llamadas al sistema, lo que permite a usuarios locales provocar una denegaci\u00f3n del servicio (ca\u00edda de sistema) a trav\u00e9s de una llamada al sistema cambiada de nombre que especifica un self-hardlink."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:*:*:*:*:*:*:*", "matchCriteriaId": "CC7A498A-A669-4C42-8134-86103C799D13"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.7", "matchCriteriaId": "02606D90-EB6B-45DE-B022-6E5783BD64FA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:vm_server:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "4BA58099-26F7-4B01-B9FC-275F012FE9C6"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=11f3710417d026ea2f4fcf362d866342c5274185", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1847.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1875.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/11/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/ovmbulletinjul2016-3090546.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/91709", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1036273", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-3070-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-3070-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-3070-3", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-3070-4", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1355650", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185"}}