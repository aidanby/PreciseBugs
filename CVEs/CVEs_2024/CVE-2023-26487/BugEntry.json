{"buggy_code": ["import intersect from './intersect';\nimport { Bounds } from 'vega-scenegraph';\n\n/**\n * Appends a new point to the lasso\n * \n * @param {*} lasso the lasso in pixel space\n * @param {*} x the x coordinate in pixel space\n * @param {*} y the y coordinate in pixel space\n * @param {*} minDist the minimum distance, in pixels, that thenew point needs to be apart from the last point\n * @returns a new array containing the lasso with the new point\n */\nexport function lassoAppend(lasso, x, y, minDist = 5) {\n    const last = lasso[lasso.length - 1];\n\n    // Add point to lasso if distance to last point exceed minDist or its the first point\n    if (last === undefined || Math.sqrt(((last[0] - x) ** 2) + ((last[1] - y) ** 2)) > minDist) {\n        lasso.push([x, y]);\n\n        return [...lasso];\n    }\n\n    return lasso;\n}\n\n\n/**\n * Generates a svg path command which draws a lasso\n * \n * @param {*} lasso the lasso in pixel space in the form [[x,y], [x,y], ...]\n * @returns the svg path command that draws the lasso\n */\nexport function lassoPath(lasso) {\n    return (lasso ?? []).reduce((svg, [x, y], i) => {\n        return svg += i == 0\n            ? `M ${x},${y} `\n            : i === lasso.length - 1\n                ? ' Z'\n                : `L ${x},${y} `;\n    }, '');\n}\n\n\n\n/**\n * Inverts the lasso from pixel space to an array of vega scenegraph tuples\n * \n * @param {*} data the dataset\n * @param {*} pixelLasso the lasso in pixel space, [[x,y], [x,y], ...]\n * @param {*} unit the unit where the lasso is defined\n * \n * @returns an array of vega scenegraph tuples\n */\nexport function intersectLasso(markname, pixelLasso, unit) {\n    const { x, y, mark } = unit;\n\n    const bb = new Bounds().set(\n        Number.MAX_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER,\n        Number.MIN_SAFE_INTEGER,\n        Number.MIN_SAFE_INTEGER\n    );\n\n    // Get bounding box around lasso\n    for (const [px, py] of pixelLasso) {\n        if (px < bb.x1) bb.x1 = px;\n        if (px > bb.x2) bb.x2 = px;\n        if (py < bb.y1) bb.y1 = py;\n        if (py > bb.y2) bb.y2 = py;\n    }\n\n    // Translate bb against unit coordinates\n    bb.translate(x, y);\n\n    const intersection = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]],\n        markname,\n        mark);\n\n    // Check every point against the lasso\n    return intersection.filter(tuple => pointInPolygon(tuple.x, tuple.y, pixelLasso));\n}\n\n\n\n/**\n * Performs a test if a point is inside a polygon based on the idea from\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n * \n * This method will not need the same start/end point since it wraps around the edges of the array\n * \n * @param {*} test a point to test against\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\n * @returns true if the point lies inside the polygon, false otherwise\n */\nfunction pointInPolygon(testx, testy, polygon) {\n    let intersections = 0;\n\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const [prevX, prevY] = polygon[j];\n        const [x, y] = polygon[i];\n\n        // count intersections\n        if (((y > testy) != (prevY > testy)) && (testx < (prevX - x) * (testy - y) / (prevY - y) + x)) {\n            intersections++;\n        }\n    }\n\n    // point is in polygon if intersection count is odd\n    return intersections & 1;\n}\n"], "fixing_code": ["import intersect from './intersect';\nimport {Bounds} from 'vega-scenegraph';\nimport {array} from 'vega-util';\n\n/**\n * Appends a new point to the lasso\n *\n * @param {*} lasso the lasso in pixel space\n * @param {*} x the x coordinate in pixel space\n * @param {*} y the y coordinate in pixel space\n * @param {*} minDist the minimum distance, in pixels, that thenew point needs to be apart from the last point\n * @returns a new array containing the lasso with the new point\n */\nexport function lassoAppend(lasso, x, y, minDist = 5) {\n  lasso = array(lasso);\n  const last = lasso[lasso.length - 1];\n\n  // Add point to lasso if its the first point or distance to last point exceed minDist\n  return (last === undefined || Math.sqrt(((last[0] - x) ** 2) + ((last[1] - y) ** 2)) > minDist)\n  ? [...lasso, [x, y]]\n  : lasso;\n}\n\n\n/**\n * Generates a svg path command which draws a lasso\n *\n * @param {*} lasso the lasso in pixel space in the form [[x,y], [x,y], ...]\n * @returns the svg path command that draws the lasso\n */\nexport function lassoPath(lasso) {\n  return array(lasso).reduce((svg, [x, y], i) => {\n  return svg += i == 0\n    ? `M ${x},${y} `\n    : i === lasso.length - 1\n    ? ' Z'\n    : `L ${x},${y} `;\n  }, '');\n}\n\n\n\n/**\n * Inverts the lasso from pixel space to an array of vega scenegraph tuples\n *\n * @param {*} data the dataset\n * @param {*} pixelLasso the lasso in pixel space, [[x,y], [x,y], ...]\n * @param {*} unit the unit where the lasso is defined\n *\n * @returns an array of vega scenegraph tuples\n */\nexport function intersectLasso(markname, pixelLasso, unit) {\n  const { x, y, mark } = unit;\n\n  const bb = new Bounds().set(\n    Number.MAX_SAFE_INTEGER,\n    Number.MAX_SAFE_INTEGER,\n    Number.MIN_SAFE_INTEGER,\n    Number.MIN_SAFE_INTEGER\n  );\n\n  // Get bounding box around lasso\n  for (const [px, py] of pixelLasso) {\n    if (px < bb.x1) bb.x1 = px;\n    if (px > bb.x2) bb.x2 = px;\n    if (py < bb.y1) bb.y1 = py;\n    if (py > bb.y2) bb.y2 = py;\n  }\n\n  // Translate bb against unit coordinates\n  bb.translate(x, y);\n\n  const intersection = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]],\n    markname,\n    mark);\n\n  // Check every point against the lasso\n  return intersection.filter(tuple => pointInPolygon(tuple.x, tuple.y, pixelLasso));\n}\n\n\n\n/**\n * Performs a test if a point is inside a polygon based on the idea from\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n *\n * This method will not need the same start/end point since it wraps around the edges of the array\n *\n * @param {*} test a point to test against\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\n * @returns true if the point lies inside the polygon, false otherwise\n */\nfunction pointInPolygon(testx, testy, polygon) {\n  let intersections = 0;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [prevX, prevY] = polygon[j];\n    const [x, y] = polygon[i];\n\n    // count intersections\n    if (((y > testy) != (prevY > testy)) && (testx < (prevX - x) * (testy - y) / (prevY - y) + x)) {\n      intersections++;\n    }\n  }\n\n  // point is in polygon if intersection count is odd\n  return intersections & 1;\n}\n"], "filenames": ["packages/vega-functions/src/functions/lasso.js"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [110], "fixing_code_start_loc": [2], "fixing_code_end_loc": [108], "type": "CWE-79", "message": "Vega is a visualization grammar, a declarative format for creating, saving, and sharing interactive visualization designs.`lassoAppend' function accepts 3 arguments and internally invokes `push` function on the 1st argument specifying array consisting of 2nd and 3rd arguments as `push` call argument. The type of the 1st argument is supposed to be an array, but it's not enforced. This makes it possible to specify any object with a `push` function as the 1st argument, `push` function can be set to any function that can be access via `event.view` (no all such functions can be exploited due to invalid context or signature, but some can, e.g. `console.log`). The issue is that`lassoAppend` doesn't enforce proper types of its arguments. This issue opens various XSS vectors, but exact impact and severity depends on the environment (e.g. Core JS `setImmediate` polyfill basically allows `eval`-like functionality). This issue was patched in 5.23.0.", "other": {"cve": {"id": "CVE-2023-26487", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-04T00:15:15.563", "lastModified": "2023-03-09T20:31:31.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vega is a visualization grammar, a declarative format for creating, saving, and sharing interactive visualization designs.`lassoAppend' function accepts 3 arguments and internally invokes `push` function on the 1st argument specifying array consisting of 2nd and 3rd arguments as `push` call argument. The type of the 1st argument is supposed to be an array, but it's not enforced. This makes it possible to specify any object with a `push` function as the 1st argument, `push` function can be set to any function that can be access via `event.view` (no all such functions can be exploited due to invalid context or signature, but some can, e.g. `console.log`). The issue is that`lassoAppend` doesn't enforce proper types of its arguments. This issue opens various XSS vectors, but exact impact and severity depends on the environment (e.g. Core JS `setImmediate` polyfill basically allows `eval`-like functionality). This issue was patched in 5.23.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vega-functions_project:vega-functions:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.13.1", "matchCriteriaId": "573B200A-A938-460B-8B95-3F4E2B98E15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vega_project:vega:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.23.0", "matchCriteriaId": "FDAFA09A-097A-45DB-9E8F-B8ED261D0550"}]}]}], "references": [{"url": "https://github.com/vega/vega/commit/01adb034f24727d3bb321bbbb6696a7f4cd91689", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vega/vega/releases/tag/v5.23.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/vega/vega/security/advisories/GHSA-w5m3-xh75-mp55", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vega/vega/commit/01adb034f24727d3bb321bbbb6696a7f4cd91689"}}