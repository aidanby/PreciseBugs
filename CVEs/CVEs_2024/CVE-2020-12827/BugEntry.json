{"buggy_code": ["import { find, get, identity, map, omit, reduce, isObject, each } from 'lodash'\nimport path from 'path'\nimport juice from 'juice'\nimport { html as htmlBeautify } from 'js-beautify'\nimport { minify as htmlMinify } from 'html-minifier'\n\nimport MJMLParser from 'mjml-parser-xml'\nimport MJMLValidator from 'mjml-validator'\nimport { handleMjml3 } from 'mjml-migrate'\n\nimport components, { initComponent, registerComponent } from './components'\n\nimport suffixCssClasses from './helpers/suffixCssClasses'\nimport mergeOutlookConditionnals from './helpers/mergeOutlookConditionnals'\nimport minifyOutlookConditionnals from './helpers/minifyOutlookConditionnals'\nimport defaultSkeleton from './helpers/skeleton'\nimport { initializeType } from './types/type'\n\nimport handleMjmlConfig, {\n  readMjmlConfig,\n  handleMjmlConfigComponents,\n} from './helpers/mjmlconfig'\n\nclass ValidationError extends Error {\n  constructor(message, errors) {\n    super(message)\n\n    this.errors = errors\n  }\n}\n\nexport default function mjml2html(mjml, options = {}) {\n  let content = ''\n  let errors = []\n\n  if (typeof options.skeleton === 'string') {\n    /* eslint-disable global-require */\n    /* eslint-disable import/no-dynamic-require */\n    options.skeleton = require(options.skeleton.charAt(0) === '.'\n      ? path.resolve(process.cwd(), options.skeleton)\n      : options.skeleton)\n    /* eslint-enable global-require */\n    /* eslint-enable import/no-dynamic-require */\n  }\n\n  let packages = {}\n  let confOptions = {}\n  let mjmlConfigOptions = {}\n  let error = null\n  let componentRootPath = null\n\n  if (options.useMjmlConfigOptions || options.mjmlConfigPath) {\n    const mjmlConfigContent = readMjmlConfig(options.mjmlConfigPath)\n\n    ;({\n      mjmlConfig: { packages, options: confOptions },\n      componentRootPath,\n      error,\n    } = mjmlConfigContent)\n\n    if (options.useMjmlConfigOptions) {\n      mjmlConfigOptions = confOptions\n    }\n  }\n\n  // if mjmlConfigPath is specified then we need to register components it on each call\n  if (!error && options.mjmlConfigPath) {\n    handleMjmlConfigComponents(packages, componentRootPath, registerComponent)\n  }\n\n  const {\n    beautify = false,\n    fonts = {\n      'Open Sans':\n        'https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,700',\n      'Droid Sans':\n        'https://fonts.googleapis.com/css?family=Droid+Sans:300,400,500,700',\n      Lato: 'https://fonts.googleapis.com/css?family=Lato:300,400,500,700',\n      Roboto: 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700',\n      Ubuntu: 'https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700',\n    },\n    keepComments,\n    minify = false,\n    minifyOptions = {},\n    juiceOptions = {},\n    juicePreserveTags = null,\n    skeleton = defaultSkeleton,\n    validationLevel = 'soft',\n    filePath = '.',\n    actualPath = '.',\n    noMigrateWarn = false,\n    preprocessors,\n  } = {\n    ...mjmlConfigOptions,\n    ...options,\n  }\n\n  if (typeof mjml === 'string') {\n    mjml = MJMLParser(mjml, {\n      keepComments,\n      components,\n      filePath,\n      actualPath,\n      preprocessors,\n    })\n  }\n\n  mjml = handleMjml3(mjml, { noMigrateWarn })\n\n  const globalDatas = {\n    backgroundColor: '',\n    breakpoint: '480px',\n    classes: {},\n    classesDefault: {},\n    defaultAttributes: {},\n    fonts,\n    inlineStyle: [],\n    headStyle: {},\n    componentsHeadStyle: [],\n    headRaw: [],\n    mediaQueries: {},\n    preview: '',\n    style: [],\n    title: '',\n    forceOWADesktop: get(mjml, 'attributes.owa', 'mobile') === 'desktop',\n    lang: get(mjml, 'attributes.lang'),\n  }\n\n  const validatorOptions = {\n    components,\n    initializeType,\n  }\n\n  switch (validationLevel) {\n    case 'skip':\n      break\n\n    case 'strict':\n      errors = MJMLValidator(mjml, validatorOptions)\n\n      if (errors.length > 0) {\n        throw new ValidationError(\n          `ValidationError: \\n ${errors\n            .map(e => e.formattedMessage)\n            .join('\\n')}`,\n          errors,\n        )\n      }\n      break\n\n    case 'soft':\n    default:\n      errors = MJMLValidator(mjml, validatorOptions)\n      break\n  }\n\n  const mjBody = find(mjml.children, { tagName: 'mj-body' })\n  const mjHead = find(mjml.children, { tagName: 'mj-head' })\n\n  const processing = (node, context, parseMJML = identity) => {\n    if (!node) {\n      return\n    }\n\n    const component = initComponent({\n      name: node.tagName,\n      initialDatas: {\n        ...parseMJML(node),\n        context,\n      },\n    })\n\n    if (component !== null) {\n      if ('handler' in component) {\n        return component.handler() // eslint-disable-line consistent-return\n      }\n\n      if ('render' in component) {\n        return component.render() // eslint-disable-line consistent-return\n      }\n    }\n  }\n  \n\n  const applyAttributes = mjml => {\n    const parse = (mjml, parentMjClass = '') => {\n      const { attributes, tagName, children } = mjml\n      const classes = get(mjml.attributes, 'mj-class', '').split(' ')\n      const attributesClasses = reduce(\n        classes,\n        (acc, value) => {\n          const mjClassValues = globalDatas.classes[value]\n          let multipleClasses = {}\n          if (acc['css-class'] && get(mjClassValues, 'css-class')) {\n            multipleClasses = {\n              'css-class': `${acc['css-class']} ${mjClassValues['css-class']}`,\n            }\n          }\n\n          return {\n            ...acc,\n            ...mjClassValues,\n            ...multipleClasses,\n          }\n        },\n        {},\n      )\n\n      const defaultAttributesForClasses = reduce(\n        parentMjClass.split(' '),\n        (acc, value) => ({\n          ...acc,\n          ...get(globalDatas.classesDefault, `${value}.${tagName}`),\n        }),\n        {},\n      )\n      const nextParentMjClass = get(attributes, 'mj-class', parentMjClass)\n\n      return {\n        ...mjml,\n        attributes: {\n          ...globalDatas.defaultAttributes[tagName],\n          ...attributesClasses,\n          ...defaultAttributesForClasses,\n          ...omit(attributes, ['mj-class']),\n        },\n        globalAttributes: {\n          ...globalDatas.defaultAttributes['mj-all'],\n        },\n        children: map(children, mjml => parse(mjml, nextParentMjClass)),\n      }\n    }\n\n    return parse(mjml)\n  }\n\n  const bodyHelpers = {\n    addMediaQuery(className, { parsedWidth, unit }) {\n      globalDatas.mediaQueries[\n        className\n      ] = `{ width:${parsedWidth}${unit} !important; max-width: ${parsedWidth}${unit}; }`\n    },\n    addHeadStyle(identifier, headStyle) {\n      globalDatas.headStyle[identifier] = headStyle\n    },\n    addComponentHeadSyle(headStyle) {\n      globalDatas.componentsHeadStyle.push(headStyle)\n    },\n    setBackgroundColor: color => {\n      globalDatas.backgroundColor = color\n    },\n    processing: (node, context) => processing(node, context, applyAttributes),\n  }\n\n  const headHelpers = {\n    add(attr, ...params) {\n      if (Array.isArray(globalDatas[attr])) {\n        globalDatas[attr].push(...params)\n      } else if (Object.prototype.hasOwnProperty.call(globalDatas, attr)) {\n        if (params.length > 1) {\n          if (isObject(globalDatas[attr][params[0]])) {\n            globalDatas[attr][params[0]] = {\n              ...globalDatas[attr][params[0]],\n              ...params[1],\n            }\n          } else {\n            globalDatas[attr][params[0]] = params[1]\n          }\n        } else {\n          globalDatas[attr] = params[0]\n        }\n      } else {\n        throw Error(\n          `An mj-head element add an unkown head attribute : ${attr} with params ${\n            Array.isArray(params) ? params.join('') : params\n          }`,\n        )\n      }\n    },\n  }\n\n  globalDatas.headRaw = processing(mjHead, headHelpers)\n\n  content = processing(mjBody, bodyHelpers, applyAttributes)\n\n  if (minify && minify !== 'false') {\n    content = minifyOutlookConditionnals(content)\n  }\n\n  content = skeleton({\n    content,\n    ...globalDatas,\n  })\n\n  if (globalDatas.inlineStyle.length > 0) {\n    if (juicePreserveTags) {\n      each(juicePreserveTags, (val, key) => {\n        juice.codeBlocks[key] = val\n      })\n    }\n\n    content = juice(content, {\n      applyStyleTags: false,\n      extraCss: globalDatas.inlineStyle.join(''),\n      insertPreservedExtraCss: false,\n      removeStyleTags: false,\n      ...juiceOptions,\n    })\n  }\n\n  content =\n    beautify && beautify !== 'false'\n      ? htmlBeautify(content, {\n          indent_size: 2,\n          wrap_attributes_indent_size: 2,\n          max_preserve_newline: 0,\n          preserve_newlines: false,\n        })\n      : content\n\n  if (minify && minify !== 'false') {\n    content = htmlMinify(content, {\n      collapseWhitespace: true,\n      minifyCSS: false,\n      caseSensitive: true,\n      removeEmptyAttributes: true,\n      ...minifyOptions,\n    })\n  }\n\n  content = mergeOutlookConditionnals(content)\n\n  return {\n    html: content,\n    errors,\n  }\n}\n\nhandleMjmlConfig(process.cwd(), registerComponent)\n\nexport {\n  components,\n  initComponent,\n  registerComponent,\n  suffixCssClasses,\n  handleMjmlConfig,\n  initializeType,\n}\n\nexport { BodyComponent, HeadComponent } from './createComponent'\n"], "fixing_code": ["import { find, get, identity, map, omit, reduce, isObject, each } from 'lodash'\nimport path from 'path'\nimport juice from 'juice'\nimport { html as htmlBeautify } from 'js-beautify'\nimport { minify as htmlMinify } from 'html-minifier'\n\nimport MJMLParser from 'mjml-parser-xml'\nimport MJMLValidator from 'mjml-validator'\nimport { handleMjml3 } from 'mjml-migrate'\n\nimport components, { initComponent, registerComponent } from './components'\n\nimport suffixCssClasses from './helpers/suffixCssClasses'\nimport mergeOutlookConditionnals from './helpers/mergeOutlookConditionnals'\nimport minifyOutlookConditionnals from './helpers/minifyOutlookConditionnals'\nimport defaultSkeleton from './helpers/skeleton'\nimport { initializeType } from './types/type'\n\nimport handleMjmlConfig, {\n  readMjmlConfig,\n  handleMjmlConfigComponents,\n} from './helpers/mjmlconfig'\n\nclass ValidationError extends Error {\n  constructor(message, errors) {\n    super(message)\n\n    this.errors = errors\n  }\n}\n\nexport default function mjml2html(mjml, options = {}) {\n  let content = ''\n  let errors = []\n\n  if (typeof options.skeleton === 'string') {\n    /* eslint-disable global-require */\n    /* eslint-disable import/no-dynamic-require */\n    options.skeleton = require(options.skeleton.charAt(0) === '.'\n      ? path.resolve(process.cwd(), options.skeleton)\n      : options.skeleton)\n    /* eslint-enable global-require */\n    /* eslint-enable import/no-dynamic-require */\n  }\n\n  let packages = {}\n  let confOptions = {}\n  let mjmlConfigOptions = {}\n  let error = null\n  let componentRootPath = null\n\n  if (options.useMjmlConfigOptions || options.mjmlConfigPath) {\n    const mjmlConfigContent = readMjmlConfig(options.mjmlConfigPath)\n\n    ;({\n      mjmlConfig: { packages, options: confOptions },\n      componentRootPath,\n      error,\n    } = mjmlConfigContent)\n\n    if (options.useMjmlConfigOptions) {\n      mjmlConfigOptions = confOptions\n    }\n  }\n\n  // if mjmlConfigPath is specified then we need to register components it on each call\n  if (!error && options.mjmlConfigPath) {\n    handleMjmlConfigComponents(packages, componentRootPath, registerComponent)\n  }\n\n  const {\n    beautify = false,\n    fonts = {\n      'Open Sans':\n        'https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,700',\n      'Droid Sans':\n        'https://fonts.googleapis.com/css?family=Droid+Sans:300,400,500,700',\n      Lato: 'https://fonts.googleapis.com/css?family=Lato:300,400,500,700',\n      Roboto: 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700',\n      Ubuntu: 'https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700',\n    },\n    keepComments,\n    minify = false,\n    minifyOptions = {},\n    ignoreIncludes = false,\n    juiceOptions = {},\n    juicePreserveTags = null,\n    skeleton = defaultSkeleton,\n    validationLevel = 'soft',\n    filePath = '.',\n    actualPath = '.',\n    noMigrateWarn = false,\n    preprocessors,\n  } = {\n    ...mjmlConfigOptions,\n    ...options,\n  }\n\n  if (typeof mjml === 'string') {\n    mjml = MJMLParser(mjml, {\n      keepComments,\n      components,\n      filePath,\n      actualPath,\n      preprocessors,\n      ignoreIncludes,\n    })\n  }\n\n  mjml = handleMjml3(mjml, { noMigrateWarn })\n\n  const globalDatas = {\n    backgroundColor: '',\n    breakpoint: '480px',\n    classes: {},\n    classesDefault: {},\n    defaultAttributes: {},\n    fonts,\n    inlineStyle: [],\n    headStyle: {},\n    componentsHeadStyle: [],\n    headRaw: [],\n    mediaQueries: {},\n    preview: '',\n    style: [],\n    title: '',\n    forceOWADesktop: get(mjml, 'attributes.owa', 'mobile') === 'desktop',\n    lang: get(mjml, 'attributes.lang'),\n  }\n\n  const validatorOptions = {\n    components,\n    initializeType,\n  }\n\n  switch (validationLevel) {\n    case 'skip':\n      break\n\n    case 'strict':\n      errors = MJMLValidator(mjml, validatorOptions)\n\n      if (errors.length > 0) {\n        throw new ValidationError(\n          `ValidationError: \\n ${errors\n            .map(e => e.formattedMessage)\n            .join('\\n')}`,\n          errors,\n        )\n      }\n      break\n\n    case 'soft':\n    default:\n      errors = MJMLValidator(mjml, validatorOptions)\n      break\n  }\n\n  const mjBody = find(mjml.children, { tagName: 'mj-body' })\n  const mjHead = find(mjml.children, { tagName: 'mj-head' })\n\n  const processing = (node, context, parseMJML = identity) => {\n    if (!node) {\n      return\n    }\n\n    const component = initComponent({\n      name: node.tagName,\n      initialDatas: {\n        ...parseMJML(node),\n        context,\n      },\n    })\n\n    if (component !== null) {\n      if ('handler' in component) {\n        return component.handler() // eslint-disable-line consistent-return\n      }\n\n      if ('render' in component) {\n        return component.render() // eslint-disable-line consistent-return\n      }\n    }\n  }\n  \n\n  const applyAttributes = mjml => {\n    const parse = (mjml, parentMjClass = '') => {\n      const { attributes, tagName, children } = mjml\n      const classes = get(mjml.attributes, 'mj-class', '').split(' ')\n      const attributesClasses = reduce(\n        classes,\n        (acc, value) => {\n          const mjClassValues = globalDatas.classes[value]\n          let multipleClasses = {}\n          if (acc['css-class'] && get(mjClassValues, 'css-class')) {\n            multipleClasses = {\n              'css-class': `${acc['css-class']} ${mjClassValues['css-class']}`,\n            }\n          }\n\n          return {\n            ...acc,\n            ...mjClassValues,\n            ...multipleClasses,\n          }\n        },\n        {},\n      )\n\n      const defaultAttributesForClasses = reduce(\n        parentMjClass.split(' '),\n        (acc, value) => ({\n          ...acc,\n          ...get(globalDatas.classesDefault, `${value}.${tagName}`),\n        }),\n        {},\n      )\n      const nextParentMjClass = get(attributes, 'mj-class', parentMjClass)\n\n      return {\n        ...mjml,\n        attributes: {\n          ...globalDatas.defaultAttributes[tagName],\n          ...attributesClasses,\n          ...defaultAttributesForClasses,\n          ...omit(attributes, ['mj-class']),\n        },\n        globalAttributes: {\n          ...globalDatas.defaultAttributes['mj-all'],\n        },\n        children: map(children, mjml => parse(mjml, nextParentMjClass)),\n      }\n    }\n\n    return parse(mjml)\n  }\n\n  const bodyHelpers = {\n    addMediaQuery(className, { parsedWidth, unit }) {\n      globalDatas.mediaQueries[\n        className\n      ] = `{ width:${parsedWidth}${unit} !important; max-width: ${parsedWidth}${unit}; }`\n    },\n    addHeadStyle(identifier, headStyle) {\n      globalDatas.headStyle[identifier] = headStyle\n    },\n    addComponentHeadSyle(headStyle) {\n      globalDatas.componentsHeadStyle.push(headStyle)\n    },\n    setBackgroundColor: color => {\n      globalDatas.backgroundColor = color\n    },\n    processing: (node, context) => processing(node, context, applyAttributes),\n  }\n\n  const headHelpers = {\n    add(attr, ...params) {\n      if (Array.isArray(globalDatas[attr])) {\n        globalDatas[attr].push(...params)\n      } else if (Object.prototype.hasOwnProperty.call(globalDatas, attr)) {\n        if (params.length > 1) {\n          if (isObject(globalDatas[attr][params[0]])) {\n            globalDatas[attr][params[0]] = {\n              ...globalDatas[attr][params[0]],\n              ...params[1],\n            }\n          } else {\n            globalDatas[attr][params[0]] = params[1]\n          }\n        } else {\n          globalDatas[attr] = params[0]\n        }\n      } else {\n        throw Error(\n          `An mj-head element add an unkown head attribute : ${attr} with params ${\n            Array.isArray(params) ? params.join('') : params\n          }`,\n        )\n      }\n    },\n  }\n\n  globalDatas.headRaw = processing(mjHead, headHelpers)\n\n  content = processing(mjBody, bodyHelpers, applyAttributes)\n\n  if (minify && minify !== 'false') {\n    content = minifyOutlookConditionnals(content)\n  }\n\n  content = skeleton({\n    content,\n    ...globalDatas,\n  })\n\n  if (globalDatas.inlineStyle.length > 0) {\n    if (juicePreserveTags) {\n      each(juicePreserveTags, (val, key) => {\n        juice.codeBlocks[key] = val\n      })\n    }\n\n    content = juice(content, {\n      applyStyleTags: false,\n      extraCss: globalDatas.inlineStyle.join(''),\n      insertPreservedExtraCss: false,\n      removeStyleTags: false,\n      ...juiceOptions,\n    })\n  }\n\n  content =\n    beautify && beautify !== 'false'\n      ? htmlBeautify(content, {\n          indent_size: 2,\n          wrap_attributes_indent_size: 2,\n          max_preserve_newline: 0,\n          preserve_newlines: false,\n        })\n      : content\n\n  if (minify && minify !== 'false') {\n    content = htmlMinify(content, {\n      collapseWhitespace: true,\n      minifyCSS: false,\n      caseSensitive: true,\n      removeEmptyAttributes: true,\n      ...minifyOptions,\n    })\n  }\n\n  content = mergeOutlookConditionnals(content)\n\n  return {\n    html: content,\n    errors,\n  }\n}\n\nhandleMjmlConfig(process.cwd(), registerComponent)\n\nexport {\n  components,\n  initComponent,\n  registerComponent,\n  suffixCssClasses,\n  handleMjmlConfig,\n  initializeType,\n}\n\nexport { BodyComponent, HeadComponent } from './createComponent'\n"], "filenames": ["packages/mjml-core/src/index.js"], "buggy_code_start_loc": [84], "buggy_code_end_loc": [104], "fixing_code_start_loc": [85], "fixing_code_end_loc": [107], "type": "CWE-22", "message": "MJML prior to 4.6.3 contains a path traversal vulnerability when processing the mj-include directive within an MJML document.", "other": {"cve": {"id": "CVE-2020-12827", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T14:15:10.523", "lastModified": "2020-06-23T00:09:53.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MJML prior to 4.6.3 contains a path traversal vulnerability when processing the mj-include directive within an MJML document."}, {"lang": "es", "value": "MJML versiones anteriores a 4.6.3, contiene una vulnerabilidad de salto de ruta cuando se procesa una directiva mj-include dentro de un documento de MJML"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mjml:mjml:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.6.3", "matchCriteriaId": "06CC7F7C-8C28-4583-B3AE-F4B921C22613"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/158111/MJML-4.6.2-Path-Traversal.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2020/Jun/23", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/mjmlio/mjml/commit/30e29ed2cdaec8684d60a6d12ea07b611c765a12", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mjmlio/mjml/releases/tag/v4.6.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://mjml.io/community", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://rcesecurity.com", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://twitter.com/mjmlio", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mjmlio/mjml/commit/30e29ed2cdaec8684d60a6d12ea07b611c765a12"}}