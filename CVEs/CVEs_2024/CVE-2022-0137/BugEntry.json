{"buggy_code": ["# Changes in HTMLDOC v1.9.14\n\n- BMP image support is now deprecated and will be removed in a future\n  release of HTMLDOC.\n- Fixed a potential stack overflow bug with GIF images.\n- Fixed the PDF creation date (Issue #455)\n- Fixed a potential stack overflow bug with BMP images (Issue #456)\n- Fixed a compile issue when libpng was not available (Issue #458)\n\n\n# Changes in HTMLDOC v1.9.13\n\n- Now install a 32x32 icon for Linux (Issue #432)\n- Fixed an issue with large values for roman numerals and letters in headings\n  (Issue #433)\n- Fixed a crash bug when a HTML comment contains an invalid nul character\n  (Issue #439)\n- Fixed a crash bug with bogus BMP images (Issue #444)\n- Fixed a potential heap overflow bug with bogus GIF images (Issue #451)\n- Fixed a potential stack overflow bug with bogus BMP images (Issue #453)\n\n\n# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed crash bugs for books (Issue #412, Issue #414)\n- Fixed a number-up crash bug (Issue #413)\n- Fixed JPEG error handling (Issue #415)\n- Fixed crash bugs with bogus table attributes (Issue #416, Issue #417)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed a crash bug with empty titles (Issue #425)\n- Fixed crash bugs with bogus text (Issue #426, Issue #429, Issue #430,\n  Issue #431)\n- Fixed some issues reported by Coverity.\n- Removed the bundled libjpeg, libpng, and zlib.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * Image handling routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9\u00a02011-2021 by Michael R Sweet.\n * Copyright \u00a9\u00a01997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include <setjmp.h>\n\n#ifdef HAVE_LIBJPEG\nextern \"C\" {\t\t/* Workaround for JPEG header problems... */\n#  include <jpeglib.h>\t/* JPEG/JFIF image definitions */\n}\n#endif // HAVE_JPEG\n\n#ifdef HAVE_LIBPNG\n#  include <png.h>\t/* Portable Network Graphics (PNG) definitions */\n#endif // HAVE_LIBPNG\n\n\n/*\n * GIF definitions...\n */\n\n#define GIF_INTERLACE\t0x40\n#define GIF_COLORMAP\t0x80\n\ntypedef uchar\tgif_cmap_t[256][3];\n\n\n/*\n * BMP definitions...\n */\n\n#ifndef BI_RGB\n#  define BI_RGB       0             /* No compression - straight BGR data */\n#  define BI_RLE8      1             /* 8-bit run-length compression */\n#  define BI_RLE4      2             /* 4-bit run-length compression */\n#  define BI_BITFIELDS 3             /* RGB bitmap with RGB masks */\n#endif /* !BI_RGB */\n\n\n/*\n * Local globals...\n */\n\nstatic size_t\tnum_images = 0,\t\t/* Number of images in cache */\n\t\talloc_images = 0;\t/* Allocated images */\nstatic image_t\t**images = NULL;\t/* Images in cache */\nstatic int\tgif_eof = 0;\t\t/* Did we hit EOF? */\n\n\n/*\n * Local functions...\n */\n\nstatic int\tgif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,\n\t\t              int *gray);\nstatic int\tgif_get_block(FILE *fp, uchar *buffer);\nstatic int\tgif_get_code (FILE *fp, int code_size, int first_time);\nstatic int\tgif_read_image(FILE *fp, image_t *img, gif_cmap_t cmap,\n\t\t               int interlace, int transparent);\nstatic int\tgif_read_lzw(FILE *fp, int first_time, int input_code_size);\n\nstatic int\timage_compare(image_t **img1, image_t **img2);\nstatic int\timage_load_bmp(image_t *img, FILE *fp, int gray, int load_data);\nstatic int\timage_load_gif(image_t *img, FILE *fp, int gray, int load_data);\n\n#ifdef HAVE_LIBJPEG\nstatic int\timage_load_jpeg(image_t *img, FILE *fp, int gray, int load_data);\nstatic void\tjpeg_error_handler(j_common_ptr);\n#endif // HAVE_LIBJPEG\n\n#ifdef HAVE_LIBPNG\nstatic int\timage_load_png(image_t *img, FILE *fp, int gray, int load_data);\n#endif // HAVE_LIBPNG\n\nstatic void\timage_need_mask(image_t *img, int scaling = 1);\nstatic void\timage_set_mask(image_t *img, int x, int y, uchar alpha = 0);\n\nstatic int\t\tread_long(FILE *fp);\nstatic unsigned short\tread_word(FILE *fp);\nstatic unsigned int\tread_dword(FILE *fp);\n\n\n/*\n * 'gif_read_cmap()' - Read the colormap from a GIF file...\n */\n\nstatic int\t\t\t\t/* O  - 0 on success, -1 on error */\ngif_read_cmap(FILE       *fp,\t\t/* I  - File to read from */\n  \t      int        ncolors,\t/* I  - Number of colors */\n\t      gif_cmap_t cmap,\t\t/* IO - Colormap array */\n\t      int        *gray)\t\t/* IO - 1 = grayscale */\n{\n  int\ti;\t\t\t\t/* Looping var */\n\n\n /*\n  * Read the colormap...\n  */\n\n  if (fread(cmap, 3, (size_t)ncolors, fp) < (size_t)ncolors)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF colormap: %s\", strerror(errno));\n    return (-1);\n  }\n\n /*\n  * Check to see if the colormap is a grayscale ramp...\n  */\n\n  for (i = 0; i < ncolors; i ++)\n    if (cmap[i][0] != cmap[i][1] || cmap[i][1] != cmap[i][2])\n      break;\n\n  if (i == ncolors)\n  {\n    *gray = 1;\n    return (0);\n  }\n\n /*\n  * If this needs to be a grayscale image, convert the RGB values to\n  * luminance values...\n  */\n\n  if (*gray)\n    for (i = 0; i < ncolors; i ++)\n      cmap[i][0] = (cmap[i][0] * 31 + cmap[i][1] * 61 + cmap[i][2] * 8) / 100;\n\n  return (0);\n}\n\n\n/*\n * 'gif_get_block()' - Read a GIF data block...\n */\n\nstatic int\t\t\t/* O - Number characters read */\ngif_get_block(FILE  *fp,\t/* I - File to read from */\n\t      uchar *buf)\t/* I - Input buffer */\n{\n  int\tcount;\t\t\t/* Number of character to read */\n\n\n /*\n  * Read the count byte followed by the data from the file...\n  */\n\n  if ((count = getc(fp)) == EOF)\n  {\n    gif_eof = 1;\n    return (-1);\n  }\n  else if (count == 0)\n    gif_eof = 1;\n  else if (fread(buf, 1, (size_t)count, fp) < (size_t)count)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF block of %d bytes: %s\", count,\n                   strerror(errno));\n    gif_eof = 1;\n    return (-1);\n  }\n  else\n    gif_eof = 0;\n\n  return (count);\n}\n\n\n/*\n * 'gif_get_code()' - Get a LZW code from the file...\n */\n\nstatic int\t\t\t/* O - LZW code */\ngif_get_code(FILE *fp,\t\t/* I - File to read from */\n\t     int  code_size,\t/* I - Size of code in bits */\n\t     int  first_time)\t/* I - 1 = first time, 0 = not first time */\n{\n  unsigned\t\ti, j,\t\t/* Looping vars */\n\t\t\tret;\t\t/* Return value */\n  int\t\t\tcount;\t\t/* Number of bytes read */\n  static uchar\t\tbuf[280];\t/* Input buffer */\n  static unsigned\tcurbit,\t\t/* Current bit */\n\t\t\tlastbit,\t/* Last bit in buffer */\n\t\t\tdone,\t\t/* Done with this buffer? */\n\t\t\tlast_byte;\t/* Last byte in buffer */\n  static unsigned\tbits[8] =\t/* Bit masks for codes */\n\t\t\t{\n\t\t\t  0x01, 0x02, 0x04, 0x08,\n\t\t\t  0x10, 0x20, 0x40, 0x80\n\t\t\t};\n\n\n  if (first_time)\n  {\n   /*\n    * Just initialize the input buffer...\n    */\n\n    curbit    = 0;\n    lastbit   = 0;\n    last_byte = 0;\n    done      = 0;\n\n    return (0);\n  }\n\n  if ((curbit + (unsigned)code_size) >= lastbit)\n  {\n   /*\n    * Don't have enough bits to hold the code...\n    */\n\n    if (done)\n    {\n      progress_error(HD_ERROR_READ_ERROR,\n                     \"Not enough data left to read GIF compression code.\");\n      return (-1);\t/* Sorry, no more... */\n    }\n\n   /*\n    * Move last two bytes to front of buffer...\n    */\n\n    if (last_byte > 1)\n    {\n      buf[0]    = buf[last_byte - 2];\n      buf[1]    = buf[last_byte - 1];\n      last_byte = 2;\n    }\n    else if (last_byte == 1)\n    {\n      buf[0]    = buf[last_byte - 1];\n      last_byte = 1;\n    }\n\n   /*\n    * Read in another buffer...\n    */\n\n    if ((count = gif_get_block (fp, buf + last_byte)) <= 0)\n    {\n     /*\n      * Whoops, no more data!\n      */\n\n      done = 1;\n      return (-1);\n    }\n\n   /*\n    * Update buffer state...\n    */\n\n    curbit    = (curbit - lastbit) + 8 * last_byte;\n    last_byte += (unsigned)count;\n    lastbit   = last_byte * 8;\n  }\n\n  for (ret = 0, i = curbit + (unsigned)code_size - 1, j = (unsigned)code_size;\n       j > 0;\n       i --, j --)\n    ret = (ret << 1) | ((buf[i / 8] & bits[i & 7]) != 0);\n\n  curbit += (unsigned)code_size;\n\n  return (int)ret;\n}\n\n\n/*\n * 'gif_read_image()' - Read a GIF image stream...\n */\n\nstatic int\t\t\t\t/* I - 0 = success, -1 = failure */\ngif_read_image(FILE       *fp,\t\t/* I - Input file */\n\t       image_t    *img,\t\t/* I - Image pointer */\n\t       gif_cmap_t cmap,\t\t/* I - Colormap */\n\t       int        interlace,\t/* I - Non-zero = interlaced image */\n\t       int        transparent)\t/* I - Transparent color */\n{\n  uchar\t\tcode_size,\t\t/* Code size */\n\t\t*temp;\t\t\t/* Current pixel */\n  int\t\txpos,\t\t\t/* Current X position */\n\t\typos,\t\t\t/* Current Y position */\n\t\tpass;\t\t\t/* Current pass */\n  int\t\tpixel;\t\t\t/* Current pixel */\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n\n\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n\n  temp = img->pixels;\n\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n\n    if (ypos >= img->height)\n      break;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'gif_read_lzw()' - Read a byte from the LZW stream...\n */\n\nstatic int\t\t\t\t/* I - Byte from stream */\ngif_read_lzw(FILE *fp,\t\t\t/* I - File to read from */\n\t     int  first_time,\t\t/* I - 1 = first time, 0 = not first time */\n \t     int  input_code_size)\t/* I - Code size in bits */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tcode,\t\t\t/* Current code */\n\t\tincode;\t\t\t/* Input code */\n  static short\tfresh = 0,\t\t/* 1 = empty buffers */\n\t\tcode_size = 0,\t\t/* Current code size */\n\t\tset_code_size = 0,\t/* Initial code size set */\n\t\tmax_code = 0,\t\t/* Maximum code used */\n\t\tmax_code_size = 0,\t/* Maximum code size */\n\t\tfirstcode = 0,\t\t/* First code read */\n\t\toldcode = 0,\t\t/* Last code read */\n\t\tclear_code = 0,\t\t/* Clear code for LZW input */\n\t\tend_code = 0,\t\t/* End code for LZW input */\n\t\ttable[2][4096],\t\t/* String table */\n\t\tstack[8192],\t\t/* Output stack */\n\t\t*sp = stack;\t\t/* Current stack pointer */\n\n\n  if (first_time)\n  {\n   /*\n    * Setup LZW state...\n    */\n\n    set_code_size = (short)input_code_size;\n    code_size     = set_code_size + 1;\n    clear_code    = (short)(1 << set_code_size);\n    end_code      = clear_code + 1;\n    max_code_size = 2 * clear_code;\n    max_code      = clear_code + 2;\n\n   /*\n    * Initialize input buffers...\n    */\n\n    gif_get_code(fp, 0, 1);\n\n   /*\n    * Wipe the decompressor table...\n    */\n\n    fresh = 1;\n\n    for (i = 0; i < clear_code; i ++)\n    {\n      table[0][i] = 0;\n      table[1][i] = (short)i;\n    }\n\n    for (; i < 4096; i ++)\n      table[0][i] = table[1][0] = 0;\n\n    sp = stack;\n\n    return (0);\n  }\n  else if (fresh)\n  {\n    fresh = 0;\n\n    do\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n    while (firstcode == clear_code);\n\n    return (firstcode);\n  }\n\n  if (sp > stack)\n    return (*--sp);\n\n  while ((code = gif_get_code (fp, code_size, 0)) >= 0)\n  {\n    if (code == clear_code)\n    {\n      for (i = 0; i < clear_code; i ++)\n      {\n\ttable[0][i] = 0;\n\ttable[1][i] = (short)i;\n      }\n\n      for (; i < 4096; i ++)\n\ttable[0][i] = table[1][i] = 0;\n\n      code_size     = set_code_size + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      sp = stack;\n\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n\n      return (firstcode);\n    }\n    else if (code == end_code)\n    {\n      uchar\tbuf[260];\n\n\n      if (!gif_eof)\n        while (gif_get_block(fp, buf) > 0);\n\n      return (-2);\n    }\n\n    incode = code;\n\n    if (code >= max_code)\n    {\n      *sp++ = firstcode;\n      code  = oldcode;\n    }\n\n    while (code >= clear_code)\n    {\n      *sp++ = table[1][code];\n      if (code == table[0][code])\n\treturn (255);\n\n      code = table[0][code];\n    }\n\n    *sp++ = firstcode = table[1][code];\n    code  = max_code;\n\n    if (code < 4096)\n    {\n      table[0][code] = oldcode;\n      table[1][code] = firstcode;\n      max_code ++;\n\n      if (max_code >= max_code_size && max_code_size < 4096)\n      {\n\tmax_code_size *= 2;\n\tcode_size ++;\n      }\n    }\n\n    oldcode = (short)incode;\n\n    if (sp > stack)\n      return (*--sp);\n  }\n\n  return (code);\n}\n\n\n/*\n * 'image_compare()' - Compare two image filenames...\n */\n\nstatic int\t\t\t/* O - Result of comparison */\nimage_compare(image_t **img1,\t/* I - First image */\n              image_t **img2)\t/* I - Second image */\n{\n#ifdef WIN32\n  return (strcasecmp((*img1)->filename, (*img2)->filename));\n#else\n  return (strcmp((*img1)->filename, (*img2)->filename));\n#endif /* WIN32 */\n}\n\n\n/*\n * 'image_copy()' - Copy image files to the destination directory...\n */\n\nvoid\nimage_copy(const char *src,\t\t/* I - Source file */\n           const char *realsrc,\t\t/* I - Real source file */\n           const char *destpath)\t/* I - Destination path */\n{\n  char\t\tdest[255];\t\t/* Destination file */\n  FILE\t\t*in, *out;\t\t/* Input/output files */\n  uchar\t\tbuffer[8192];\t\t/* Data buffer */\n  int\t\tnbytes;\t\t\t/* Number of bytes in buffer */\n\n\n  if (!src || !realsrc || !destpath)\n    return;\n\n /*\n  * Figure out the destination filename...\n  */\n\n  if (!strcmp(destpath, \".\"))\n    strlcpy(dest, file_basename(src), sizeof(dest));\n  else\n    snprintf(dest, sizeof(dest), \"%s/%s\", destpath, file_basename(src));\n\n  if (!strcmp(dest, realsrc))\n    return;\n\n /*\n  * Open files and copy...\n  */\n\n  if ((in = fopen(realsrc, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to open \\\"%s\\\" - %s\",\n                   realsrc, strerror(errno));\n    return;\n  }\n\n  if ((out = fopen(dest, \"wb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to create \\\"%s\\\" - %s\",\n                   dest, strerror(errno));\n    fclose(in);\n    return;\n  }\n\n  while ((nbytes = fread(buffer, 1, sizeof(buffer), in)) > 0)\n    fwrite(buffer, 1, (size_t)nbytes, out);\n\n  progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n  fclose(in);\n  fclose(out);\n}\n\n\n/*\n * 'image_find()' - Find an image file in memory...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_find(const char *filename,/* I - Name of image file */\n           int        load_data)/* I - 1 = load image data */\n{\n  image_t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match;\t/* Matching image */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL)\n    {\n      if (load_data && !(*match)->pixels)\n        return (image_load((*match)->filename, (*match)->depth == 1, 1));\n      else\n        return (*match);\n    }\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'image_flush_cache()' - Flush the image cache...\n */\n\nvoid\nimage_flush_cache(void)\n{\n  size_t\ti;\t\t\t/* Looping var */\n\n\n /*\n  * Free the memory used by each image...\n  */\n\n  for (i = 0; i < num_images; i ++)\n  {\n    if (images[i]->mask)\n      free(images[i]->mask);\n\n    if (images[i]->pixels)\n      free(images[i]->pixels);\n\n    free(images[i]);\n  }\n\n  if (alloc_images)\n  {\n    free(images);\n\n    alloc_images = 0;\n  }\n\n  num_images = 0;\n}\n\n\n/*\n * 'image_getlist()' - Get the list of images that are loaded.\n */\n\nint\t\t\t\t/* O - Number of images in array */\nimage_getlist(image_t ***ptrs)\t/* O - Pointer to images array */\n{\n  *ptrs = images;\n  return (num_images);\n}\n\n\n/*\n * 'image_load()' - Load an image file from disk...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_load(const char *filename,/* I - Name of image file */\n           int        gray,\t/* I - 0 = color, 1 = grayscale */\n           int        load_data)/* I - 1 = load image data, 0 = just info */\n{\n#ifdef DEBUG\n  int\t\ti;\t\t/* Looping var */\n#endif // DEBUG\n  FILE\t\t*fp;\t\t/* File pointer */\n  uchar\t\theader[16];\t/* First 16 bytes of file */\n  image_t\t*img,\t\t/* New image buffer */\n\t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match,\t/* Matching image */\n\t\t**temp;\t\t/* Temporary array pointer */\n  int\t\tstatus;\t\t/* Status of load... */\n  const char\t*realname;\t/* Real filename */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n  DEBUG_printf((\"image_load(filename=\\\"%s\\\", gray=%d, load_data=%d)\\n\",\n                filename, gray, load_data));\n  DEBUG_printf((\"Path = \\\"%s\\\"\\n\", Path));\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL && (!load_data || (*match)->pixels))\n    {\n      (*match)->use ++;\n      return (*match);\n    }\n  }\n  else\n    match = NULL;\n\n /*\n  * Figure out the file type...\n  */\n\n  if ((realname = file_find(Path, filename)) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to find image file \\\"%s\\\"!\", filename);\n    return (NULL);\n  }\n\n  if ((fp = fopen(realname, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open image file \\\"%s\\\" (%s) for reading!\",\n\t\t   filename, realname);\n    return (NULL);\n  }\n\n  if (fread(header, 1, sizeof(header), fp) == 0)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read image file \\\"%s\\\"!\", filename);\n    fclose(fp);\n    return (NULL);\n  }\n\n#ifdef DEBUG\n  printf(\"Header for \\\"%s\\\" (%s): \\\"\", filename, realname);\n\n  for (i = 0; i < (int)sizeof(header); i ++)\n    if (header[i] < ' ' || header[i] >= 127)\n      printf(\"\\\\x%02X\", header[i]);\n    else\n      putchar(header[i]);\n\n  puts(\"\\\"\\n\");\n\n  printf(\"match = %p\\n\", (void *)match);\n#endif // DEBUG\n\n  rewind(fp);\n\n  // See if the images array needs to be resized...\n  if (!match)\n  {\n    if (num_images >= alloc_images)\n    {\n      // Yes...\n      alloc_images += ALLOC_FILES;\n\n      if (num_images == 0)\n\ttemp = (image_t **)malloc(sizeof(image_t *) * alloc_images);\n      else\n\ttemp = (image_t **)realloc(images, sizeof(image_t *) * alloc_images);\n\n      if (temp == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n\t               \"Unable to allocate memory for %d images - %s\",\n                       (int)alloc_images, strerror(errno));\n\tfclose(fp);\n\treturn (NULL);\n      }\n\n      images = temp;\n    }\n\n    // Allocate memory...\n    img = (image_t *)calloc(sizeof(image_t), 1);\n\n    if (img == NULL)\n    {\n      progress_error(HD_ERROR_READ_ERROR, \"Unable to allocate memory for \\\"%s\\\"\",\n                     filename);\n      fclose(fp);\n      return (NULL);\n    }\n\n    images[num_images] = img;\n\n    strlcpy(img->filename, filename, sizeof(img->filename));\n    img->use = 1;\n  }\n  else\n    img = *match;\n\n  // Load the image as appropriate...\n  if (memcmp(header, \"GIF87a\", 6) == 0 ||\n      memcmp(header, \"GIF89a\", 6) == 0)\n    status = image_load_gif(img,  fp, gray, load_data);\n  else if (memcmp(header, \"BM\", 2) == 0)\n    status = image_load_bmp(img, fp, gray, load_data);\n#ifdef HAVE_LIBPNG\n  else if (memcmp(header, \"\\211PNG\", 4) == 0)\n    status = image_load_png(img, fp, gray, load_data);\n#endif // HAVE_LIBPNG\n#ifdef HAVE_LIBJPEG\n  else if (memcmp(header, \"\\377\\330\\377\", 3) == 0)\n    status = image_load_jpeg(img, fp, gray, load_data);\n#endif // HAVE_LIBJPEG\n  else\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"Unknown image file format for \\\"%s\\\".\",\n                   file_rlookup(filename));\n    fclose(fp);\n    free(img);\n    return (NULL);\n  }\n\n  fclose(fp);\n\n  if (status)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to load image file \\\"%s\\\"!\",\n                   file_rlookup(filename));\n    if (!match)\n      free(img);\n    return (NULL);\n  }\n\n  if (!match)\n  {\n    num_images ++;\n    if (num_images > 1)\n      qsort(images, num_images, sizeof(image_t *),\n            (int (*)(const void *, const void *))image_compare);\n  }\n\n  return (img);\n}\n\n\n/*\n * 'image_load_bmp()' - Read a BMP image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_bmp(image_t *img,\t/* I - Image to load into */\n               FILE    *fp,\t/* I - File to read from */\n\t       int     gray,\t/* I - Grayscale image? */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\tinfo_size,\t/* Size of info header */\n\t\tdepth,\t\t/* Depth of image (bits) */\n\t\tcompression,\t/* Type of compression */\n\t\tcolors_used,\t/* Number of colors used */\n\t\tx, y,\t\t/* Looping vars */\n\t\tcolor,\t\t/* Color of RLE pixel */\n\t\tcount,\t\t/* Number of times to repeat */\n\t\ttemp,\t\t/* Temporary color */\n\t\talign;\t\t/* Alignment bytes */\n  uchar\t\tbit,\t\t/* Bit in image */\n\t\tbyte;\t\t/* Byte in image */\n  uchar\t\t*ptr;\t\t/* Pointer into pixels */\n  uchar\t\tcolormap[256][4];/* Colormap */\n\n\n  // Get the header...\n  getc(fp);\t\t\t/* Skip \"BM\" sync chars */\n  getc(fp);\n  read_dword(fp);\t\t/* Skip size */\n  read_word(fp);\t\t/* Skip reserved stuff */\n  read_word(fp);\n  read_dword(fp);\n\n  // Then the bitmap information...\n  info_size        = (int)read_dword(fp);\n  img->width       = read_long(fp);\n  img->height      = read_long(fp);\n  read_word(fp);\n  depth            = read_word(fp);\n  compression      = (int)read_dword(fp);\n  read_dword(fp);\n  read_long(fp);\n  read_long(fp);\n  colors_used      = (int)read_dword(fp);\n  read_dword(fp);\n\n  if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192 || info_size < 0)\n    return (-1);\n\n  if (info_size > 40)\n  {\n    for (info_size -= 40; info_size > 0; info_size --)\n      getc(fp);\n  }\n\n  // Get colormap...\n  if (colors_used == 0 && depth <= 8)\n    colors_used = 1 << depth;\n  else if (colors_used < 0 || colors_used > 256)\n    return (-1);\n\n  fread(colormap, (size_t)colors_used, 4, fp);\n\n  // Setup image and buffers...\n  img->depth = gray ? 1 : 3;\n\n  // If this image is indexed and we are writing an encrypted PDF file, bump the use count so\n  // we create an image object (Acrobat 6 bug workaround)\n  if (depth <= 8 && Encryption)\n    img->use ++;\n\n  // Return now if we only need the dimensions...\n  if (!load_data)\n    return (0);\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n  if (img->pixels == NULL)\n    return (-1);\n\n  if (gray && depth <= 8)\n  {\n    // Convert colormap to grayscale...\n    for (color = colors_used - 1; color >= 0; color --)\n      colormap[color][0] = (colormap[color][2] * 31 +\n                            colormap[color][1] * 61 +\n                            colormap[color][0] * 8) / 100;\n  }\n\n  // Read the image data...\n  color = 0;\n  count = 0;\n  align = 0;\n  byte  = 0;\n  temp  = 0;\n\n  for (y = img->height - 1; y >= 0; y --)\n  {\n    ptr = img->pixels + y * img->width * img->depth;\n\n    switch (depth)\n    {\n      case 1 : /* Bitmap */\n          for (x = img->width, bit = 128; x > 0; x --)\n\t  {\n\t    if (bit == 128)\n\t      byte = (uchar)getc(fp);\n\n\t    if (byte & bit)\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[1][2];\n\t\t*ptr++ = colormap[1][1];\n              }\n\n\t      *ptr++ = colormap[1][0];\n\t    }\n\t    else\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[0][2];\n\t\t*ptr++ = colormap[0][1];\n\t      }\n\n\t      *ptr++ = colormap[0][0];\n\t    }\n\n\t    if (bit > 1)\n\t      bit >>= 1;\n\t    else\n\t      bit = 128;\n\t  }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = (img->width + 7) / 8; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n\n      case 4 : /* 16-color */\n          for (x = img->width, bit = 0xf0; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE4 && count == 0)\n\t    {\n\t      count = 2;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = ((4 - (count & 3)) / 2) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n\t    count --;\n\n            if (bit == 0xf0)\n\t    {\n              if (color < 0)\n\t\ttemp = getc(fp) & 255;\n\t      else\n\t\ttemp = color;\n\n             /*\n\t      * Copy the color value...\n\t      */\n\n              if (!gray)\n\t      {\n\t\t*ptr++ = colormap[temp >> 4][2];\n\t\t*ptr++ = colormap[temp >> 4][1];\n              }\n\n\t      *ptr++ = colormap[temp >> 4][0];\n\t      bit    = 0x0f;\n            }\n\t    else\n\t    {\n             /*\n\t      * Copy the color value...\n\t      */\n\n\t      if (!gray)\n\t      {\n\t        *ptr++ = colormap[temp & 15][2];\n\t        *ptr++ = colormap[temp & 15][1];\n\t      }\n\n\t      *ptr++ = colormap[temp & 15][0];\n\t      bit    = 0xf0;\n\t    }\n\t  }\n          break;\n\n      case 8 : /* 256-color */\n          for (x = img->width; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE8)\n\t    {\n\t      count = 1;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = (2 - (count & 1)) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n            if (color < 0)\n\t      temp = getc(fp);\n\t    else\n\t      temp = color;\n\n            count --;\n\n           /*\n\t    * Copy the color value...\n\t    */\n\n            if (!gray)\n\t    {\n\t      *ptr++ = colormap[temp][2];\n\t      *ptr++ = colormap[temp][1];\n\t    }\n\n\t    *ptr++ = colormap[temp][0];\n\t  }\n          break;\n\n      case 24 : /* 24-bit RGB */\n          if (gray)\n\t  {\n            for (x = img->width; x > 0; x --)\n\t    {\n\t      temp = getc(fp) * 8;\n\t      temp += getc(fp) * 61;\n\t      temp += getc(fp) * 31;\n\t      *ptr++ = (uchar)(temp / 100);\n\t    }\n\t  }\n\t  else\n\t  {\n            for (x = img->width; x > 0; x --, ptr += 3)\n\t    {\n\t      ptr[2] = (uchar)getc(fp);\n\t      ptr[1] = (uchar)getc(fp);\n\t      ptr[0] = (uchar)getc(fp);\n\t    }\n          }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = img->width * 3; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n    }\n  }\n\n  return (0);\n}\n\n\n/*\n * 'image_load_gif()' - Load a GIF image file...\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_gif(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to load from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  uchar\t\tbuf[1024];\t/* Input buffer */\n  gif_cmap_t\tcmap;\t\t/* Colormap */\n  int\t\tncolors,\t/* Bits per pixel */\n\t\ttransparent;\t/* Transparent color index */\n\n\n /*\n  * Read the header; we already know it is a GIF file...\n  */\n\n  fread(buf, 13, 1, fp);\n\n  img->width  = (buf[7] << 8) | buf[6];\n  img->height = (buf[9] << 8) | buf[8];\n  ncolors     = 2 << (buf[10] & 0x07);\n\n  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n    return (-1);\n\n  // If we are writing an encrypted PDF file, bump the use count so we create\n  // an image object (Acrobat 6 bug workaround)\n  if (Encryption)\n    img->use ++;\n\n  if (buf[10] & GIF_COLORMAP)\n    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n      return (-1);\n\n  transparent = -1;\n\n  while (1)\n  {\n    switch (getc(fp))\n    {\n      case ';' :\t/* End of image */\n          return (-1);\t\t/* Early end of file */\n\n      case '!' :\t/* Extension record */\n          buf[0] = (uchar)getc(fp);\n          if (buf[0] == 0xf9)\t/* Graphic Control Extension */\n          {\n            gif_get_block(fp, buf);\n            if (buf[0] & 1)\t/* Get transparent color index */\n              transparent = buf[3];\n          }\n\n          while (gif_get_block(fp, buf) != 0);\n          break;\n\n      case ',' :\t/* Image data */\n          fread(buf, 9, 1, fp);\n\n          if (buf[8] & GIF_COLORMAP)\n          {\n            ncolors = 2 << (buf[8] & 0x07);\n\n\t    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n\t      return (-1);\n\t  }\n\n          if (transparent >= 0)\n          {\n           /*\n            * Map transparent color to background color...\n            */\n\n            if (BodyColor[0])\n\t    {\n\t      float rgb[3]; /* RGB color */\n\n\n\t      get_color((uchar *)BodyColor, rgb);\n\n\t      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);\n\t      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);\n\t      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);\n\t    }\n\t    else\n\t    {\n\t      cmap[transparent][0] = 255;\n              cmap[transparent][1] = 255;\n              cmap[transparent][2] = 255;\n\t    }\n\n           /*\n\t    * Allocate a mask image...\n\t    */\n\n            image_need_mask(img);\n\t  }\n\n          img->width  = (buf[5] << 8) | buf[4];\n          img->height = (buf[7] << 8) | buf[6];\n          img->depth  = gray ? 1 : 3;\n\n\t  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n\t    return (-1);\n\n\t  if (!load_data)\n\t    return (0);\n\n          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n          if (img->pixels == NULL)\n            return (-1);\n\n\t  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));\n    }\n  }\n}\n\n\n#ifdef HAVE_LIBJPEG\ntypedef struct hd_jpeg_err_s\t// JPEG error manager extension\n{\n  struct jpeg_error_mgr\tjerr;\t// JPEG error manager information\n  jmp_buf\tretbuf;\t\t// setjmp() return buffer\n  char\t\tmessage[JMSG_LENGTH_MAX];\n\t\t\t\t// Last error message\n} hd_jpeg_err_t;\n\n\n/*\n * 'image_load_jpeg()' - Load a JPEG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_jpeg(image_t *img,\t/* I - Image pointer */\n                FILE    *fp,\t/* I - File to load from */\n                int     gray,\t/* I - 0 = color, 1 = grayscale */\n                int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  struct jpeg_decompress_struct\tcinfo;\t\t/* Decompressor info */\n  hd_jpeg_err_t\t\t\tjerr;\t\t// JPEG error handler\nJSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n\n\n  jpeg_std_error(&jerr.jerr);\n  jerr.jerr.error_exit = jpeg_error_handler;\n\n  if (setjmp(jerr.retbuf))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"%s (%s)\", jerr.message,  file_rlookup(img->filename));\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  cinfo.err = (struct jpeg_error_mgr *)&jerr;\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, fp);\n  jpeg_read_header(&cinfo, (boolean)1);\n\n  cinfo.quantize_colors = FALSE;\n\n  if (gray || cinfo.num_components == 1)\n  {\n    cinfo.out_color_space      = JCS_GRAYSCALE;\n    cinfo.out_color_components = 1;\n    cinfo.output_components    = 1;\n  }\n  else if (cinfo.num_components != 3)\n  {\n    jpeg_destroy_decompress(&cinfo);\n\n    progress_error(HD_ERROR_BAD_FORMAT,\n                   \"CMYK JPEG files are not supported! (%s)\",\n\t\t   file_rlookup(img->filename));\n    return (-1);\n  }\n  else\n  {\n    cinfo.out_color_space      = JCS_RGB;\n    cinfo.out_color_components = 3;\n    cinfo.output_components    = 3;\n  }\n\n  jpeg_calc_output_dimensions(&cinfo);\n\n  img->width  = (int)cinfo.output_width;\n  img->height = (int)cinfo.output_height;\n  img->depth  = (int)cinfo.output_components;\n\n  if (!load_data)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (0);\n  }\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n\n  if (img->pixels == NULL)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  jpeg_start_decompress(&cinfo);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = (JSAMPROW)(img->pixels + (size_t)cinfo.output_scanline * (size_t)cinfo.output_width * (size_t)cinfo.output_components);\n    jpeg_read_scanlines(&cinfo, &row, (JDIMENSION)1);\n  }\n\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  return (0);\n}\n#endif // HAVE_LIBJPEG\n\n\n#ifdef HAVE_LIBPNG\n/*\n * 'image_load_png()' - Load a PNG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_png(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to read from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  png_structp\tpp;\t\t/* PNG read pointer */\n  png_infop\tinfo;\t\t/* PNG info pointers */\n  int\t\tdepth;\t\t/* Input image depth */\n  png_bytep\t*rows;\t\t/* PNG row pointers */\n  uchar\t\t*inptr,\t\t/* Input pixels */\n\t\t*outptr;\t/* Output pixels */\n  int\t\tcolor_type,\t/* PNG color mode */\n\t\tbit_depth;\t/* PNG bit depth */\n\n\n /*\n  * Setup the PNG data structures...\n  */\n\n  pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n  if (!pp)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG file: %s\",\n                   strerror(errno));\n    return (-1);\n  }\n\n  info = png_create_info_struct(pp);\n  if (!info)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG info: %s\",\n                   strerror(errno));\n\n    png_destroy_read_struct(&pp, NULL, NULL);\n\n    return (-1);\n  }\n\n  rows = NULL;\n\n  if (setjmp(png_jmpbuf(pp)))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"PNG file contains errors!\");\n\n    png_destroy_read_struct(&pp, &info, NULL);\n\n    if (img != NULL && img->pixels != NULL)\n      free(img->pixels);\n\n    if (rows != NULL)\n      free(rows);\n\n    return (-1);\n  }\n\n /*\n  * Initialize the PNG read \"engine\"...\n  */\n\n  png_init_io(pp, fp);\n\n#  if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n  // Don't throw errors with \"invalid\" sRGB profiles produced by Adobe apps.\n  png_set_option(pp, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#  endif // PNG_SKIP_sRGB_CHECK_PROFILE && PNG_SET_OPTION_SUPPORTED\n\n /*\n  * Get the image dimensions and convert to grayscale or RGB...\n  */\n\n  png_read_info(pp, info);\n\n  bit_depth  = png_get_bit_depth(pp, info);\n  color_type = png_get_color_type(pp, info);\n\n  if (png_get_valid(pp, info, PNG_INFO_tRNS))\n  {\n    png_set_tRNS_to_alpha(pp);\n    color_type |= PNG_COLOR_MASK_ALPHA;\n  }\n\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n  {\n    png_set_palette_to_rgb(pp);\n\n    // If we are writing an encrypted PDF file, bump the use count so we create\n    // an image object (Acrobat 6 bug workaround)\n    if (Encryption)\n      img->use ++;\n  }\n  else if (!(color_type & PNG_COLOR_MASK_COLOR) && bit_depth < 8)\n  {\n    png_set_expand_gray_1_2_4_to_8(pp);\n  }\n  else if (bit_depth == 16)\n  {\n#  if PNG_LIBPNG_VER >= 10504\n    png_set_scale_16(pp);\n#  else\n    png_set_strip_16(pp);\n#  endif // PNG_LIBPNG_VER >= 10504\n  }\n\n  if (color_type & PNG_COLOR_MASK_COLOR)\n  {\n    depth      = 3;\n    img->depth = gray ? 1 : 3;\n  }\n  else\n  {\n    depth      = 1;\n    img->depth = 1;\n  }\n\n  img->width  = (int)png_get_image_width(pp, info);\n  img->height = (int)png_get_image_height(pp, info);\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n    if ((PSLevel == 0 && PDFVersion >= 14) || PSLevel == 3)\n      image_need_mask(img, 8);\n    else if (PSLevel == 0 && PDFVersion == 13)\n      image_need_mask(img, 2);\n    else\n      image_need_mask(img);\n\n    depth ++;\n  }\n\n#  ifdef DEBUG\n  printf(\"bit_depth=%d, color_type=0x%04x, depth=%d, img->width=%d, img->height=%d, img->depth=%d\\n\", bit_depth, color_type, depth, img->width, img->height, img->depth);\n  if (color_type & PNG_COLOR_MASK_COLOR)\n    puts(\"    COLOR\");\n  else\n    puts(\"    GRAYSCALE\");\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n    puts(\"    ALPHA\");\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n    puts(\"    PALETTE\");\n#  endif // DEBUG\n\n  if (!load_data)\n  {\n    png_destroy_read_struct(&pp, &info, NULL);\n    return (0);\n  }\n\n  img->pixels = (uchar *)calloc(1,(size_t)(img->width * img->height * depth));\n\n /*\n  * Allocate pointers...\n  */\n\n  rows = (png_bytep *)calloc(png_get_image_height(pp, info), sizeof(png_bytep));\n\n  for (i = 0; i < (int)png_get_image_height(pp, info); i ++)\n    rows[i] = img->pixels + i * img->width * depth;\n\n /*\n  * Read the image, handling interlacing as needed...\n  */\n\n  for (i = png_set_interlace_handling(pp); i > 0; i --)\n    png_read_rows(pp, rows, NULL, (png_uint_32)img->height);\n\n /*\n  * Generate the alpha mask as necessary...\n  */\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n#  ifdef DEBUG\n    for (inptr = img->pixels, i = 0; i < img->height; i ++)\n    {\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        switch (depth)\n\t{\n\t  case 2 :\n\t      printf(\" %02X%02X\", inptr[0], inptr[1]);\n\t      break;\n\t  case 4 :\n\t      printf(\" %02X%02X%02X%02X\", inptr[0], inptr[1], inptr[2], inptr[3]);\n\t      break;\n\t}\n\n      putchar('\\n');\n    }\n#  endif // DEBUG\n\n    for (inptr = img->pixels + depth - 1, i = 0; i < img->height; i ++)\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        image_set_mask(img, j, i, *inptr);\n  }\n\n /*\n  * Reformat the data as necessary for the reader...\n  */\n\n  if (gray && (color_type & PNG_COLOR_MASK_COLOR))\n  {\n   /*\n    * Grayscale output needed...\n    */\n\n    for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n         i > 0;\n         inptr += depth, outptr ++, i --)\n      *outptr = (31 * inptr[0] + 61 * inptr[1] + 8 * inptr[2]) / 100;\n  }\n  else if (img->depth != depth)\n  {\n   /*\n    * Remove alpha from final array...\n    */\n\n    if (depth == 4)\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n      {\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n      }\n    }\n    else\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n        *outptr++ = *inptr++;\n    }\n  }\n\n /*\n  * Free memory and return...\n  */\n\n  free(rows);\n\n  png_read_end(pp, info);\n  png_destroy_read_struct(&pp, &info, NULL);\n\n  return (0);\n}\n#endif // HAVE_LIBPNG\n\n\n/*\n * 'image_need_mask()' - Allocate memory for the image mask...\n */\n\nstatic void\nimage_need_mask(image_t *img,\t\t/* I - Image to add mask to */\n                int     scaling)\t/* I - Scaling for mask image */\n{\n  size_t\tsize;\t\t\t/* Byte size of mask image */\n\n\n  if (img == NULL || img->mask != NULL)\n    return;\n\n /*\n  * Figure out the size of the mask image, and then allocate and set all the\n  * bits needed...\n  */\n\n  img->maskscale = scaling;\n\n  if (scaling == 8)\n  {\n    // Alpha image\n    img->maskwidth = img->width;\n    size           = (size_t)(img->width * img->height);\n  }\n  else\n  {\n    // Alpha mask\n    img->maskwidth = (img->width * scaling + 7) / 8;\n    size           = (size_t)(img->maskwidth * img->height * scaling + 1);\n  }\n\n  img->mask = (uchar *)calloc(size, 1);\n}\n\n\n/*\n * 'image_set_mask()' - Set a bit in the image mask.\n */\n\nstatic void\nimage_set_mask(image_t *img,\t/* I - Image to operate on */\n               int     x,\t/* I - X coordinate */\n               int     y,\t/* I - Y coordinate */\n\t       uchar   alpha)\t/* I - Alpha value */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  uchar\t\t*maskptr;\t/* Pointer into mask image */\n  static uchar\tmasks[8] =\t/* Masks for each bit */\n\t\t{\n\t\t  0x80, 0x40, 0x20, 0x10,\n\t\t  0x08, 0x04, 0x02, 0x01\n\t\t};\n  static uchar\tdither[4][4] = // Simple 4x4 clustered-dot dither\n\t\t{\n\t\t  { 0,  2,  15, 6 },\n\t\t  { 4,  12, 9,  11 },\n\t\t  { 14, 7,  1,  3 },\n\t\t  { 8,  10, 5,  13 }\n\t        };\n\n\n  if (img == NULL || img->mask == NULL || x < 0 || x >= img->width ||\n      y < 0 || y > img->height)\n    return;\n\n  if (img->maskscale == 8)\n  {\n    // Store the alpha value directly...\n    if (PSLevel)\n      img->mask[y * img->maskwidth + x] = 255 - alpha;\n    else\n      img->mask[y * img->maskwidth + x] = alpha;\n  }\n  else\n  {\n    // Store an alpha mask...\n    x *= img->maskscale;\n    y *= img->maskscale;\n    alpha >>= 4;\n\n    for (i = 0; i < img->maskscale; i ++, y ++, x -= img->maskscale)\n      for (j = 0; j < img->maskscale; j ++, x ++)\n      {\n\tmaskptr  = img->mask + y * img->maskwidth + x / 8;\n\tif (alpha <= dither[x & 3][y & 3])\n\t  *maskptr |= masks[x & 7];\n      }\n  }\n}\n\n\n/*\n * 'image_unload()' - Unload an image from memory.\n */\n\nvoid\nimage_unload(image_t *img)\t// I - Image\n{\n  if (!img)\n    return;\n\n  if (!img->use || !img->pixels)\n    return;\n\n  if (img->obj)\n    img->use = 0;\n  else\n    img->use --;\n\n  if (img->use)\n    return;\n\n  free(img->pixels);\n  img->pixels = NULL;\n}\n\n\n#ifdef HAVE_LIBJPEG\n/*\n * 'jpeg_error_handler()' - Handle JPEG errors by not exiting.\n */\n\nstatic void\njpeg_error_handler(j_common_ptr p)\t// Common JPEG data\n{\n  hd_jpeg_err_t\t*jerr = (hd_jpeg_err_t *)p->err;\n\t\t\t\t\t// JPEG error handler\n\n\n  // Save the error message in the string buffer...\n  (jerr->jerr.format_message)(p, jerr->message);\n\n  // Return to the point we called setjmp()...\n  longjmp(jerr->retbuf, 1);\n}\n#endif // HAVE_LIBJPEG\n\n\n/*\n * 'read_word()' - Read a 16-bit unsigned integer.\n */\n\nstatic unsigned short     /* O - 16-bit unsigned integer */\nread_word(FILE *fp)       /* I - File to read from */\n{\n  unsigned char b0, b1; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n\n  return (unsigned short)((b1 << 8) | b0);\n}\n\n\n/*\n * 'read_dword()' - Read a 32-bit unsigned integer.\n */\n\nstatic unsigned int               /* O - 32-bit unsigned integer */\nread_dword(FILE *fp)              /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return (unsigned)((((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n\n\n/*\n * 'read_long()' - Read a 32-bit signed integer.\n */\n\nstatic int                        /* O - 32-bit signed integer */\nread_long(FILE *fp)               /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return ((int)(((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n"], "fixing_code": ["# Changes in HTMLDOC v1.9.15\n\n- Fixed a potential heap overflow bug with GIF images (Issue #461)\n\n\n# Changes in HTMLDOC v1.9.14\n\n- BMP image support is now deprecated and will be removed in a future\n  release of HTMLDOC.\n- Fixed a potential stack overflow bug with GIF images.\n- Fixed the PDF creation date (Issue #455)\n- Fixed a potential stack overflow bug with BMP images (Issue #456)\n- Fixed a compile issue when libpng was not available (Issue #458)\n\n\n# Changes in HTMLDOC v1.9.13\n\n- Now install a 32x32 icon for Linux (Issue #432)\n- Fixed an issue with large values for roman numerals and letters in headings\n  (Issue #433)\n- Fixed a crash bug when a HTML comment contains an invalid nul character\n  (Issue #439)\n- Fixed a crash bug with bogus BMP images (Issue #444)\n- Fixed a potential heap overflow bug with bogus GIF images (Issue #451)\n- Fixed a potential stack overflow bug with bogus BMP images (Issue #453)\n\n\n# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed crash bugs for books (Issue #412, Issue #414)\n- Fixed a number-up crash bug (Issue #413)\n- Fixed JPEG error handling (Issue #415)\n- Fixed crash bugs with bogus table attributes (Issue #416, Issue #417)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed a crash bug with empty titles (Issue #425)\n- Fixed crash bugs with bogus text (Issue #426, Issue #429, Issue #430,\n  Issue #431)\n- Fixed some issues reported by Coverity.\n- Removed the bundled libjpeg, libpng, and zlib.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * Image handling routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9\u00a02011-2021 by Michael R Sweet.\n * Copyright \u00a9\u00a01997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include <setjmp.h>\n\n#ifdef HAVE_LIBJPEG\nextern \"C\" {\t\t/* Workaround for JPEG header problems... */\n#  include <jpeglib.h>\t/* JPEG/JFIF image definitions */\n}\n#endif // HAVE_JPEG\n\n#ifdef HAVE_LIBPNG\n#  include <png.h>\t/* Portable Network Graphics (PNG) definitions */\n#endif // HAVE_LIBPNG\n\n\n/*\n * GIF definitions...\n */\n\n#define GIF_INTERLACE\t0x40\n#define GIF_COLORMAP\t0x80\n\ntypedef uchar\tgif_cmap_t[256][3];\n\n\n/*\n * BMP definitions...\n */\n\n#ifndef BI_RGB\n#  define BI_RGB       0             /* No compression - straight BGR data */\n#  define BI_RLE8      1             /* 8-bit run-length compression */\n#  define BI_RLE4      2             /* 4-bit run-length compression */\n#  define BI_BITFIELDS 3             /* RGB bitmap with RGB masks */\n#endif /* !BI_RGB */\n\n\n/*\n * Local globals...\n */\n\nstatic size_t\tnum_images = 0,\t\t/* Number of images in cache */\n\t\talloc_images = 0;\t/* Allocated images */\nstatic image_t\t**images = NULL;\t/* Images in cache */\nstatic int\tgif_eof = 0;\t\t/* Did we hit EOF? */\n\n\n/*\n * Local functions...\n */\n\nstatic int\tgif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,\n\t\t              int *gray);\nstatic int\tgif_get_block(FILE *fp, uchar *buffer);\nstatic int\tgif_get_code (FILE *fp, int code_size, int first_time);\nstatic int\tgif_read_image(FILE *fp, image_t *img, gif_cmap_t cmap,\n\t\t               int interlace, int transparent);\nstatic int\tgif_read_lzw(FILE *fp, int first_time, int input_code_size);\n\nstatic int\timage_compare(image_t **img1, image_t **img2);\nstatic int\timage_load_bmp(image_t *img, FILE *fp, int gray, int load_data);\nstatic int\timage_load_gif(image_t *img, FILE *fp, int gray, int load_data);\n\n#ifdef HAVE_LIBJPEG\nstatic int\timage_load_jpeg(image_t *img, FILE *fp, int gray, int load_data);\nstatic void\tjpeg_error_handler(j_common_ptr);\n#endif // HAVE_LIBJPEG\n\n#ifdef HAVE_LIBPNG\nstatic int\timage_load_png(image_t *img, FILE *fp, int gray, int load_data);\n#endif // HAVE_LIBPNG\n\nstatic void\timage_need_mask(image_t *img, int scaling = 1);\nstatic void\timage_set_mask(image_t *img, int x, int y, uchar alpha = 0);\n\nstatic int\t\tread_long(FILE *fp);\nstatic unsigned short\tread_word(FILE *fp);\nstatic unsigned int\tread_dword(FILE *fp);\n\n\n/*\n * 'gif_read_cmap()' - Read the colormap from a GIF file...\n */\n\nstatic int\t\t\t\t/* O  - 0 on success, -1 on error */\ngif_read_cmap(FILE       *fp,\t\t/* I  - File to read from */\n  \t      int        ncolors,\t/* I  - Number of colors */\n\t      gif_cmap_t cmap,\t\t/* IO - Colormap array */\n\t      int        *gray)\t\t/* IO - 1 = grayscale */\n{\n  int\ti;\t\t\t\t/* Looping var */\n\n\n /*\n  * Read the colormap...\n  */\n\n  if (fread(cmap, 3, (size_t)ncolors, fp) < (size_t)ncolors)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF colormap: %s\", strerror(errno));\n    return (-1);\n  }\n\n /*\n  * Check to see if the colormap is a grayscale ramp...\n  */\n\n  for (i = 0; i < ncolors; i ++)\n    if (cmap[i][0] != cmap[i][1] || cmap[i][1] != cmap[i][2])\n      break;\n\n  if (i == ncolors)\n  {\n    *gray = 1;\n    return (0);\n  }\n\n /*\n  * If this needs to be a grayscale image, convert the RGB values to\n  * luminance values...\n  */\n\n  if (*gray)\n    for (i = 0; i < ncolors; i ++)\n      cmap[i][0] = (cmap[i][0] * 31 + cmap[i][1] * 61 + cmap[i][2] * 8) / 100;\n\n  return (0);\n}\n\n\n/*\n * 'gif_get_block()' - Read a GIF data block...\n */\n\nstatic int\t\t\t/* O - Number characters read */\ngif_get_block(FILE  *fp,\t/* I - File to read from */\n\t      uchar *buf)\t/* I - Input buffer */\n{\n  int\tcount;\t\t\t/* Number of character to read */\n\n\n /*\n  * Read the count byte followed by the data from the file...\n  */\n\n  if ((count = getc(fp)) == EOF)\n  {\n    gif_eof = 1;\n    return (-1);\n  }\n  else if (count == 0)\n    gif_eof = 1;\n  else if (fread(buf, 1, (size_t)count, fp) < (size_t)count)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF block of %d bytes: %s\", count,\n                   strerror(errno));\n    gif_eof = 1;\n    return (-1);\n  }\n  else\n    gif_eof = 0;\n\n  return (count);\n}\n\n\n/*\n * 'gif_get_code()' - Get a LZW code from the file...\n */\n\nstatic int\t\t\t/* O - LZW code */\ngif_get_code(FILE *fp,\t\t/* I - File to read from */\n\t     int  code_size,\t/* I - Size of code in bits */\n\t     int  first_time)\t/* I - 1 = first time, 0 = not first time */\n{\n  unsigned\t\ti, j,\t\t/* Looping vars */\n\t\t\tret;\t\t/* Return value */\n  int\t\t\tcount;\t\t/* Number of bytes read */\n  static uchar\t\tbuf[280];\t/* Input buffer */\n  static unsigned\tcurbit,\t\t/* Current bit */\n\t\t\tlastbit,\t/* Last bit in buffer */\n\t\t\tdone,\t\t/* Done with this buffer? */\n\t\t\tlast_byte;\t/* Last byte in buffer */\n  static unsigned\tbits[8] =\t/* Bit masks for codes */\n\t\t\t{\n\t\t\t  0x01, 0x02, 0x04, 0x08,\n\t\t\t  0x10, 0x20, 0x40, 0x80\n\t\t\t};\n\n\n  if (first_time)\n  {\n   /*\n    * Just initialize the input buffer...\n    */\n\n    curbit    = 0;\n    lastbit   = 0;\n    last_byte = 0;\n    done      = 0;\n\n    return (0);\n  }\n\n  if ((curbit + (unsigned)code_size) >= lastbit)\n  {\n   /*\n    * Don't have enough bits to hold the code...\n    */\n\n    if (done)\n    {\n      progress_error(HD_ERROR_READ_ERROR,\n                     \"Not enough data left to read GIF compression code.\");\n      return (-1);\t/* Sorry, no more... */\n    }\n\n   /*\n    * Move last two bytes to front of buffer...\n    */\n\n    if (last_byte > 1)\n    {\n      buf[0]    = buf[last_byte - 2];\n      buf[1]    = buf[last_byte - 1];\n      last_byte = 2;\n    }\n    else if (last_byte == 1)\n    {\n      buf[0]    = buf[last_byte - 1];\n      last_byte = 1;\n    }\n\n   /*\n    * Read in another buffer...\n    */\n\n    if ((count = gif_get_block (fp, buf + last_byte)) <= 0)\n    {\n     /*\n      * Whoops, no more data!\n      */\n\n      done = 1;\n      return (-1);\n    }\n\n   /*\n    * Update buffer state...\n    */\n\n    curbit    = (curbit - lastbit) + 8 * last_byte;\n    last_byte += (unsigned)count;\n    lastbit   = last_byte * 8;\n  }\n\n  for (ret = 0, i = curbit + (unsigned)code_size - 1, j = (unsigned)code_size;\n       j > 0;\n       i --, j --)\n    ret = (ret << 1) | ((buf[i / 8] & bits[i & 7]) != 0);\n\n  curbit += (unsigned)code_size;\n\n  return (int)ret;\n}\n\n\n/*\n * 'gif_read_image()' - Read a GIF image stream...\n */\n\nstatic int\t\t\t\t/* I - 0 = success, -1 = failure */\ngif_read_image(FILE       *fp,\t\t/* I - Input file */\n\t       image_t    *img,\t\t/* I - Image pointer */\n\t       gif_cmap_t cmap,\t\t/* I - Colormap */\n\t       int        interlace,\t/* I - Non-zero = interlaced image */\n\t       int        transparent)\t/* I - Transparent color */\n{\n  uchar\t\tcode_size,\t\t/* Code size */\n\t\t*temp;\t\t\t/* Current pixel */\n  int\t\txpos,\t\t\t/* Current X position */\n\t\typos,\t\t\t/* Current Y position */\n\t\tpass;\t\t\t/* Current pass */\n  int\t\tpixel;\t\t\t/* Current pixel */\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n\n\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n\n  temp = img->pixels;\n\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n\n    if (ypos >= img->height)\n      break;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'gif_read_lzw()' - Read a byte from the LZW stream...\n */\n\nstatic int\t\t\t\t/* I - Byte from stream */\ngif_read_lzw(FILE *fp,\t\t\t/* I - File to read from */\n\t     int  first_time,\t\t/* I - 1 = first time, 0 = not first time */\n \t     int  input_code_size)\t/* I - Code size in bits */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tcode,\t\t\t/* Current code */\n\t\tincode;\t\t\t/* Input code */\n  static short\tfresh = 0,\t\t/* 1 = empty buffers */\n\t\tcode_size = 0,\t\t/* Current code size */\n\t\tset_code_size = 0,\t/* Initial code size set */\n\t\tmax_code = 0,\t\t/* Maximum code used */\n\t\tmax_code_size = 0,\t/* Maximum code size */\n\t\tfirstcode = 0,\t\t/* First code read */\n\t\toldcode = 0,\t\t/* Last code read */\n\t\tclear_code = 0,\t\t/* Clear code for LZW input */\n\t\tend_code = 0,\t\t/* End code for LZW input */\n\t\ttable[2][4096],\t\t/* String table */\n\t\tstack[8192],\t\t/* Output stack */\n\t\t*sp = stack;\t\t/* Current stack pointer */\n\n\n  if (first_time)\n  {\n   /*\n    * Setup LZW state...\n    */\n\n    set_code_size = (short)input_code_size;\n    code_size     = set_code_size + 1;\n    clear_code    = (short)(1 << set_code_size);\n    end_code      = clear_code + 1;\n    max_code_size = 2 * clear_code;\n    max_code      = clear_code + 2;\n\n   /*\n    * Initialize input buffers...\n    */\n\n    gif_get_code(fp, 0, 1);\n\n   /*\n    * Wipe the decompressor table...\n    */\n\n    fresh = 1;\n\n    for (i = 0; i < clear_code; i ++)\n    {\n      table[0][i] = 0;\n      table[1][i] = (short)i;\n    }\n\n    for (; i < 4096; i ++)\n      table[0][i] = table[1][0] = 0;\n\n    sp = stack;\n\n    return (0);\n  }\n  else if (fresh)\n  {\n    fresh = 0;\n\n    do\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n    while (firstcode == clear_code);\n\n    return (firstcode);\n  }\n\n  if (sp > stack)\n    return (*--sp);\n\n  while ((code = gif_get_code (fp, code_size, 0)) >= 0)\n  {\n    if (code == clear_code)\n    {\n      for (i = 0; i < clear_code; i ++)\n      {\n\ttable[0][i] = 0;\n\ttable[1][i] = (short)i;\n      }\n\n      for (; i < 4096; i ++)\n\ttable[0][i] = table[1][i] = 0;\n\n      code_size     = set_code_size + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      sp = stack;\n\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n\n      return (firstcode);\n    }\n    else if (code == end_code)\n    {\n      uchar\tbuf[260];\n\n\n      if (!gif_eof)\n        while (gif_get_block(fp, buf) > 0);\n\n      return (-2);\n    }\n\n    incode = code;\n\n    if (code >= max_code)\n    {\n      *sp++ = firstcode;\n      code  = oldcode;\n    }\n\n    while (code >= clear_code)\n    {\n      *sp++ = table[1][code];\n      if (code == table[0][code])\n\treturn (255);\n\n      code = table[0][code];\n    }\n\n    *sp++ = firstcode = table[1][code];\n    code  = max_code;\n\n    if (code < 4096)\n    {\n      table[0][code] = oldcode;\n      table[1][code] = firstcode;\n      max_code ++;\n\n      if (max_code >= max_code_size && max_code_size < 4096)\n      {\n\tmax_code_size *= 2;\n\tcode_size ++;\n      }\n    }\n\n    oldcode = (short)incode;\n\n    if (sp > stack)\n      return (*--sp);\n  }\n\n  return (code);\n}\n\n\n/*\n * 'image_compare()' - Compare two image filenames...\n */\n\nstatic int\t\t\t/* O - Result of comparison */\nimage_compare(image_t **img1,\t/* I - First image */\n              image_t **img2)\t/* I - Second image */\n{\n#ifdef WIN32\n  return (strcasecmp((*img1)->filename, (*img2)->filename));\n#else\n  return (strcmp((*img1)->filename, (*img2)->filename));\n#endif /* WIN32 */\n}\n\n\n/*\n * 'image_copy()' - Copy image files to the destination directory...\n */\n\nvoid\nimage_copy(const char *src,\t\t/* I - Source file */\n           const char *realsrc,\t\t/* I - Real source file */\n           const char *destpath)\t/* I - Destination path */\n{\n  char\t\tdest[255];\t\t/* Destination file */\n  FILE\t\t*in, *out;\t\t/* Input/output files */\n  uchar\t\tbuffer[8192];\t\t/* Data buffer */\n  int\t\tnbytes;\t\t\t/* Number of bytes in buffer */\n\n\n  if (!src || !realsrc || !destpath)\n    return;\n\n /*\n  * Figure out the destination filename...\n  */\n\n  if (!strcmp(destpath, \".\"))\n    strlcpy(dest, file_basename(src), sizeof(dest));\n  else\n    snprintf(dest, sizeof(dest), \"%s/%s\", destpath, file_basename(src));\n\n  if (!strcmp(dest, realsrc))\n    return;\n\n /*\n  * Open files and copy...\n  */\n\n  if ((in = fopen(realsrc, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to open \\\"%s\\\" - %s\",\n                   realsrc, strerror(errno));\n    return;\n  }\n\n  if ((out = fopen(dest, \"wb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to create \\\"%s\\\" - %s\",\n                   dest, strerror(errno));\n    fclose(in);\n    return;\n  }\n\n  while ((nbytes = fread(buffer, 1, sizeof(buffer), in)) > 0)\n    fwrite(buffer, 1, (size_t)nbytes, out);\n\n  progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n  fclose(in);\n  fclose(out);\n}\n\n\n/*\n * 'image_find()' - Find an image file in memory...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_find(const char *filename,/* I - Name of image file */\n           int        load_data)/* I - 1 = load image data */\n{\n  image_t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match;\t/* Matching image */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL)\n    {\n      if (load_data && !(*match)->pixels)\n        return (image_load((*match)->filename, (*match)->depth == 1, 1));\n      else\n        return (*match);\n    }\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'image_flush_cache()' - Flush the image cache...\n */\n\nvoid\nimage_flush_cache(void)\n{\n  size_t\ti;\t\t\t/* Looping var */\n\n\n /*\n  * Free the memory used by each image...\n  */\n\n  for (i = 0; i < num_images; i ++)\n  {\n    if (images[i]->mask)\n      free(images[i]->mask);\n\n    if (images[i]->pixels)\n      free(images[i]->pixels);\n\n    free(images[i]);\n  }\n\n  if (alloc_images)\n  {\n    free(images);\n\n    alloc_images = 0;\n  }\n\n  num_images = 0;\n}\n\n\n/*\n * 'image_getlist()' - Get the list of images that are loaded.\n */\n\nint\t\t\t\t/* O - Number of images in array */\nimage_getlist(image_t ***ptrs)\t/* O - Pointer to images array */\n{\n  *ptrs = images;\n  return (num_images);\n}\n\n\n/*\n * 'image_load()' - Load an image file from disk...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_load(const char *filename,/* I - Name of image file */\n           int        gray,\t/* I - 0 = color, 1 = grayscale */\n           int        load_data)/* I - 1 = load image data, 0 = just info */\n{\n#ifdef DEBUG\n  int\t\ti;\t\t/* Looping var */\n#endif // DEBUG\n  FILE\t\t*fp;\t\t/* File pointer */\n  uchar\t\theader[16];\t/* First 16 bytes of file */\n  image_t\t*img,\t\t/* New image buffer */\n\t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match,\t/* Matching image */\n\t\t**temp;\t\t/* Temporary array pointer */\n  int\t\tstatus;\t\t/* Status of load... */\n  const char\t*realname;\t/* Real filename */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n  DEBUG_printf((\"image_load(filename=\\\"%s\\\", gray=%d, load_data=%d)\\n\",\n                filename, gray, load_data));\n  DEBUG_printf((\"Path = \\\"%s\\\"\\n\", Path));\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL && (!load_data || (*match)->pixels))\n    {\n      (*match)->use ++;\n      return (*match);\n    }\n  }\n  else\n    match = NULL;\n\n /*\n  * Figure out the file type...\n  */\n\n  if ((realname = file_find(Path, filename)) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to find image file \\\"%s\\\"!\", filename);\n    return (NULL);\n  }\n\n  if ((fp = fopen(realname, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open image file \\\"%s\\\" (%s) for reading!\",\n\t\t   filename, realname);\n    return (NULL);\n  }\n\n  if (fread(header, 1, sizeof(header), fp) == 0)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read image file \\\"%s\\\"!\", filename);\n    fclose(fp);\n    return (NULL);\n  }\n\n#ifdef DEBUG\n  printf(\"Header for \\\"%s\\\" (%s): \\\"\", filename, realname);\n\n  for (i = 0; i < (int)sizeof(header); i ++)\n    if (header[i] < ' ' || header[i] >= 127)\n      printf(\"\\\\x%02X\", header[i]);\n    else\n      putchar(header[i]);\n\n  puts(\"\\\"\\n\");\n\n  printf(\"match = %p\\n\", (void *)match);\n#endif // DEBUG\n\n  rewind(fp);\n\n  // See if the images array needs to be resized...\n  if (!match)\n  {\n    if (num_images >= alloc_images)\n    {\n      // Yes...\n      alloc_images += ALLOC_FILES;\n\n      if (num_images == 0)\n\ttemp = (image_t **)malloc(sizeof(image_t *) * alloc_images);\n      else\n\ttemp = (image_t **)realloc(images, sizeof(image_t *) * alloc_images);\n\n      if (temp == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n\t               \"Unable to allocate memory for %d images - %s\",\n                       (int)alloc_images, strerror(errno));\n\tfclose(fp);\n\treturn (NULL);\n      }\n\n      images = temp;\n    }\n\n    // Allocate memory...\n    img = (image_t *)calloc(sizeof(image_t), 1);\n\n    if (img == NULL)\n    {\n      progress_error(HD_ERROR_READ_ERROR, \"Unable to allocate memory for \\\"%s\\\"\",\n                     filename);\n      fclose(fp);\n      return (NULL);\n    }\n\n    images[num_images] = img;\n\n    strlcpy(img->filename, filename, sizeof(img->filename));\n    img->use = 1;\n  }\n  else\n    img = *match;\n\n  // Load the image as appropriate...\n  if (memcmp(header, \"GIF87a\", 6) == 0 ||\n      memcmp(header, \"GIF89a\", 6) == 0)\n    status = image_load_gif(img,  fp, gray, load_data);\n  else if (memcmp(header, \"BM\", 2) == 0)\n    status = image_load_bmp(img, fp, gray, load_data);\n#ifdef HAVE_LIBPNG\n  else if (memcmp(header, \"\\211PNG\", 4) == 0)\n    status = image_load_png(img, fp, gray, load_data);\n#endif // HAVE_LIBPNG\n#ifdef HAVE_LIBJPEG\n  else if (memcmp(header, \"\\377\\330\\377\", 3) == 0)\n    status = image_load_jpeg(img, fp, gray, load_data);\n#endif // HAVE_LIBJPEG\n  else\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"Unknown image file format for \\\"%s\\\".\",\n                   file_rlookup(filename));\n    fclose(fp);\n    free(img);\n    return (NULL);\n  }\n\n  fclose(fp);\n\n  if (status)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to load image file \\\"%s\\\"!\",\n                   file_rlookup(filename));\n    if (!match)\n      free(img);\n    return (NULL);\n  }\n\n  if (!match)\n  {\n    num_images ++;\n    if (num_images > 1)\n      qsort(images, num_images, sizeof(image_t *),\n            (int (*)(const void *, const void *))image_compare);\n  }\n\n  return (img);\n}\n\n\n/*\n * 'image_load_bmp()' - Read a BMP image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_bmp(image_t *img,\t/* I - Image to load into */\n               FILE    *fp,\t/* I - File to read from */\n\t       int     gray,\t/* I - Grayscale image? */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\tinfo_size,\t/* Size of info header */\n\t\tdepth,\t\t/* Depth of image (bits) */\n\t\tcompression,\t/* Type of compression */\n\t\tcolors_used,\t/* Number of colors used */\n\t\tx, y,\t\t/* Looping vars */\n\t\tcolor,\t\t/* Color of RLE pixel */\n\t\tcount,\t\t/* Number of times to repeat */\n\t\ttemp,\t\t/* Temporary color */\n\t\talign;\t\t/* Alignment bytes */\n  uchar\t\tbit,\t\t/* Bit in image */\n\t\tbyte;\t\t/* Byte in image */\n  uchar\t\t*ptr;\t\t/* Pointer into pixels */\n  uchar\t\tcolormap[256][4];/* Colormap */\n\n\n  // Get the header...\n  getc(fp);\t\t\t/* Skip \"BM\" sync chars */\n  getc(fp);\n  read_dword(fp);\t\t/* Skip size */\n  read_word(fp);\t\t/* Skip reserved stuff */\n  read_word(fp);\n  read_dword(fp);\n\n  // Then the bitmap information...\n  info_size        = (int)read_dword(fp);\n  img->width       = read_long(fp);\n  img->height      = read_long(fp);\n  read_word(fp);\n  depth            = read_word(fp);\n  compression      = (int)read_dword(fp);\n  read_dword(fp);\n  read_long(fp);\n  read_long(fp);\n  colors_used      = (int)read_dword(fp);\n  read_dword(fp);\n\n  if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192 || info_size < 0)\n    return (-1);\n\n  if (info_size > 40)\n  {\n    for (info_size -= 40; info_size > 0; info_size --)\n      getc(fp);\n  }\n\n  // Get colormap...\n  if (colors_used == 0 && depth <= 8)\n    colors_used = 1 << depth;\n  else if (colors_used < 0 || colors_used > 256)\n    return (-1);\n\n  fread(colormap, (size_t)colors_used, 4, fp);\n\n  // Setup image and buffers...\n  img->depth = gray ? 1 : 3;\n\n  // If this image is indexed and we are writing an encrypted PDF file, bump the use count so\n  // we create an image object (Acrobat 6 bug workaround)\n  if (depth <= 8 && Encryption)\n    img->use ++;\n\n  // Return now if we only need the dimensions...\n  if (!load_data)\n    return (0);\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n  if (img->pixels == NULL)\n    return (-1);\n\n  if (gray && depth <= 8)\n  {\n    // Convert colormap to grayscale...\n    for (color = colors_used - 1; color >= 0; color --)\n      colormap[color][0] = (colormap[color][2] * 31 +\n                            colormap[color][1] * 61 +\n                            colormap[color][0] * 8) / 100;\n  }\n\n  // Read the image data...\n  color = 0;\n  count = 0;\n  align = 0;\n  byte  = 0;\n  temp  = 0;\n\n  for (y = img->height - 1; y >= 0; y --)\n  {\n    ptr = img->pixels + y * img->width * img->depth;\n\n    switch (depth)\n    {\n      case 1 : /* Bitmap */\n          for (x = img->width, bit = 128; x > 0; x --)\n\t  {\n\t    if (bit == 128)\n\t      byte = (uchar)getc(fp);\n\n\t    if (byte & bit)\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[1][2];\n\t\t*ptr++ = colormap[1][1];\n              }\n\n\t      *ptr++ = colormap[1][0];\n\t    }\n\t    else\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[0][2];\n\t\t*ptr++ = colormap[0][1];\n\t      }\n\n\t      *ptr++ = colormap[0][0];\n\t    }\n\n\t    if (bit > 1)\n\t      bit >>= 1;\n\t    else\n\t      bit = 128;\n\t  }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = (img->width + 7) / 8; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n\n      case 4 : /* 16-color */\n          for (x = img->width, bit = 0xf0; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE4 && count == 0)\n\t    {\n\t      count = 2;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = ((4 - (count & 3)) / 2) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n\t    count --;\n\n            if (bit == 0xf0)\n\t    {\n              if (color < 0)\n\t\ttemp = getc(fp) & 255;\n\t      else\n\t\ttemp = color;\n\n             /*\n\t      * Copy the color value...\n\t      */\n\n              if (!gray)\n\t      {\n\t\t*ptr++ = colormap[temp >> 4][2];\n\t\t*ptr++ = colormap[temp >> 4][1];\n              }\n\n\t      *ptr++ = colormap[temp >> 4][0];\n\t      bit    = 0x0f;\n            }\n\t    else\n\t    {\n             /*\n\t      * Copy the color value...\n\t      */\n\n\t      if (!gray)\n\t      {\n\t        *ptr++ = colormap[temp & 15][2];\n\t        *ptr++ = colormap[temp & 15][1];\n\t      }\n\n\t      *ptr++ = colormap[temp & 15][0];\n\t      bit    = 0xf0;\n\t    }\n\t  }\n          break;\n\n      case 8 : /* 256-color */\n          for (x = img->width; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE8)\n\t    {\n\t      count = 1;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = (2 - (count & 1)) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n            if (color < 0)\n\t      temp = getc(fp);\n\t    else\n\t      temp = color;\n\n            count --;\n\n           /*\n\t    * Copy the color value...\n\t    */\n\n            if (!gray)\n\t    {\n\t      *ptr++ = colormap[temp][2];\n\t      *ptr++ = colormap[temp][1];\n\t    }\n\n\t    *ptr++ = colormap[temp][0];\n\t  }\n          break;\n\n      case 24 : /* 24-bit RGB */\n          if (gray)\n\t  {\n            for (x = img->width; x > 0; x --)\n\t    {\n\t      temp = getc(fp) * 8;\n\t      temp += getc(fp) * 61;\n\t      temp += getc(fp) * 31;\n\t      *ptr++ = (uchar)(temp / 100);\n\t    }\n\t  }\n\t  else\n\t  {\n            for (x = img->width; x > 0; x --, ptr += 3)\n\t    {\n\t      ptr[2] = (uchar)getc(fp);\n\t      ptr[1] = (uchar)getc(fp);\n\t      ptr[0] = (uchar)getc(fp);\n\t    }\n          }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = img->width * 3; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n    }\n  }\n\n  return (0);\n}\n\n\n/*\n * 'image_load_gif()' - Load a GIF image file...\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_gif(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to load from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  uchar\t\tbuf[1024];\t/* Input buffer */\n  gif_cmap_t\tcmap;\t\t/* Colormap */\n  int\t\tncolors,\t/* Bits per pixel */\n\t\ttransparent;\t/* Transparent color index */\n\n\n /*\n  * Read the header; we already know it is a GIF file...\n  */\n\n  fread(buf, 13, 1, fp);\n\n  img->width  = (buf[7] << 8) | buf[6];\n  img->height = (buf[9] << 8) | buf[8];\n  ncolors     = 2 << (buf[10] & 0x07);\n\n  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n    return (-1);\n\n  // If we are writing an encrypted PDF file, bump the use count so we create\n  // an image object (Acrobat 6 bug workaround)\n  if (Encryption)\n    img->use ++;\n\n  if (buf[10] & GIF_COLORMAP)\n    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n      return (-1);\n\n  transparent = -1;\n\n  while (1)\n  {\n    switch (getc(fp))\n    {\n      case ';' :\t/* End of image */\n          return (-1);\t\t/* Early end of file */\n\n      case '!' :\t/* Extension record */\n          buf[0] = (uchar)getc(fp);\n          if (buf[0] == 0xf9)\t/* Graphic Control Extension */\n          {\n            gif_get_block(fp, buf);\n            if (buf[0] & 1)\t/* Get transparent color index */\n              transparent = buf[3];\n          }\n\n          while (gif_get_block(fp, buf) != 0);\n          break;\n\n      case ',' :\t/* Image data */\n          fread(buf, 9, 1, fp);\n\n          if (buf[8] & GIF_COLORMAP)\n          {\n            ncolors = 2 << (buf[8] & 0x07);\n\n\t    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n\t      return (-1);\n\t  }\n\n          img->width  = (buf[5] << 8) | buf[4];\n          img->height = (buf[7] << 8) | buf[6];\n          img->depth  = gray ? 1 : 3;\n\n\t  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n\t    return (-1);\n\n          if (transparent >= 0)\n          {\n           /*\n            * Map transparent color to background color...\n            */\n\n            if (BodyColor[0])\n\t    {\n\t      float rgb[3]; /* RGB color */\n\n\n\t      get_color((uchar *)BodyColor, rgb);\n\n\t      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);\n\t      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);\n\t      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);\n\t    }\n\t    else\n\t    {\n\t      cmap[transparent][0] = 255;\n              cmap[transparent][1] = 255;\n              cmap[transparent][2] = 255;\n\t    }\n\n           /*\n\t    * Allocate a mask image...\n\t    */\n\n            image_need_mask(img);\n\t  }\n\n\t  if (!load_data)\n\t    return (0);\n\n          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n          if (img->pixels == NULL)\n            return (-1);\n\n\t  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));\n    }\n  }\n}\n\n\n#ifdef HAVE_LIBJPEG\ntypedef struct hd_jpeg_err_s\t// JPEG error manager extension\n{\n  struct jpeg_error_mgr\tjerr;\t// JPEG error manager information\n  jmp_buf\tretbuf;\t\t// setjmp() return buffer\n  char\t\tmessage[JMSG_LENGTH_MAX];\n\t\t\t\t// Last error message\n} hd_jpeg_err_t;\n\n\n/*\n * 'image_load_jpeg()' - Load a JPEG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_jpeg(image_t *img,\t/* I - Image pointer */\n                FILE    *fp,\t/* I - File to load from */\n                int     gray,\t/* I - 0 = color, 1 = grayscale */\n                int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  struct jpeg_decompress_struct\tcinfo;\t\t/* Decompressor info */\n  hd_jpeg_err_t\t\t\tjerr;\t\t// JPEG error handler\nJSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n\n\n  jpeg_std_error(&jerr.jerr);\n  jerr.jerr.error_exit = jpeg_error_handler;\n\n  if (setjmp(jerr.retbuf))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"%s (%s)\", jerr.message,  file_rlookup(img->filename));\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  cinfo.err = (struct jpeg_error_mgr *)&jerr;\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, fp);\n  jpeg_read_header(&cinfo, (boolean)1);\n\n  cinfo.quantize_colors = FALSE;\n\n  if (gray || cinfo.num_components == 1)\n  {\n    cinfo.out_color_space      = JCS_GRAYSCALE;\n    cinfo.out_color_components = 1;\n    cinfo.output_components    = 1;\n  }\n  else if (cinfo.num_components != 3)\n  {\n    jpeg_destroy_decompress(&cinfo);\n\n    progress_error(HD_ERROR_BAD_FORMAT,\n                   \"CMYK JPEG files are not supported! (%s)\",\n\t\t   file_rlookup(img->filename));\n    return (-1);\n  }\n  else\n  {\n    cinfo.out_color_space      = JCS_RGB;\n    cinfo.out_color_components = 3;\n    cinfo.output_components    = 3;\n  }\n\n  jpeg_calc_output_dimensions(&cinfo);\n\n  img->width  = (int)cinfo.output_width;\n  img->height = (int)cinfo.output_height;\n  img->depth  = (int)cinfo.output_components;\n\n  if (!load_data)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (0);\n  }\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n\n  if (img->pixels == NULL)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  jpeg_start_decompress(&cinfo);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = (JSAMPROW)(img->pixels + (size_t)cinfo.output_scanline * (size_t)cinfo.output_width * (size_t)cinfo.output_components);\n    jpeg_read_scanlines(&cinfo, &row, (JDIMENSION)1);\n  }\n\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  return (0);\n}\n#endif // HAVE_LIBJPEG\n\n\n#ifdef HAVE_LIBPNG\n/*\n * 'image_load_png()' - Load a PNG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_png(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to read from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  png_structp\tpp;\t\t/* PNG read pointer */\n  png_infop\tinfo;\t\t/* PNG info pointers */\n  int\t\tdepth;\t\t/* Input image depth */\n  png_bytep\t*rows;\t\t/* PNG row pointers */\n  uchar\t\t*inptr,\t\t/* Input pixels */\n\t\t*outptr;\t/* Output pixels */\n  int\t\tcolor_type,\t/* PNG color mode */\n\t\tbit_depth;\t/* PNG bit depth */\n\n\n /*\n  * Setup the PNG data structures...\n  */\n\n  pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n  if (!pp)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG file: %s\",\n                   strerror(errno));\n    return (-1);\n  }\n\n  info = png_create_info_struct(pp);\n  if (!info)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG info: %s\",\n                   strerror(errno));\n\n    png_destroy_read_struct(&pp, NULL, NULL);\n\n    return (-1);\n  }\n\n  rows = NULL;\n\n  if (setjmp(png_jmpbuf(pp)))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"PNG file contains errors!\");\n\n    png_destroy_read_struct(&pp, &info, NULL);\n\n    if (img != NULL && img->pixels != NULL)\n      free(img->pixels);\n\n    if (rows != NULL)\n      free(rows);\n\n    return (-1);\n  }\n\n /*\n  * Initialize the PNG read \"engine\"...\n  */\n\n  png_init_io(pp, fp);\n\n#  if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n  // Don't throw errors with \"invalid\" sRGB profiles produced by Adobe apps.\n  png_set_option(pp, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#  endif // PNG_SKIP_sRGB_CHECK_PROFILE && PNG_SET_OPTION_SUPPORTED\n\n /*\n  * Get the image dimensions and convert to grayscale or RGB...\n  */\n\n  png_read_info(pp, info);\n\n  bit_depth  = png_get_bit_depth(pp, info);\n  color_type = png_get_color_type(pp, info);\n\n  if (png_get_valid(pp, info, PNG_INFO_tRNS))\n  {\n    png_set_tRNS_to_alpha(pp);\n    color_type |= PNG_COLOR_MASK_ALPHA;\n  }\n\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n  {\n    png_set_palette_to_rgb(pp);\n\n    // If we are writing an encrypted PDF file, bump the use count so we create\n    // an image object (Acrobat 6 bug workaround)\n    if (Encryption)\n      img->use ++;\n  }\n  else if (!(color_type & PNG_COLOR_MASK_COLOR) && bit_depth < 8)\n  {\n    png_set_expand_gray_1_2_4_to_8(pp);\n  }\n  else if (bit_depth == 16)\n  {\n#  if PNG_LIBPNG_VER >= 10504\n    png_set_scale_16(pp);\n#  else\n    png_set_strip_16(pp);\n#  endif // PNG_LIBPNG_VER >= 10504\n  }\n\n  if (color_type & PNG_COLOR_MASK_COLOR)\n  {\n    depth      = 3;\n    img->depth = gray ? 1 : 3;\n  }\n  else\n  {\n    depth      = 1;\n    img->depth = 1;\n  }\n\n  img->width  = (int)png_get_image_width(pp, info);\n  img->height = (int)png_get_image_height(pp, info);\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n    if ((PSLevel == 0 && PDFVersion >= 14) || PSLevel == 3)\n      image_need_mask(img, 8);\n    else if (PSLevel == 0 && PDFVersion == 13)\n      image_need_mask(img, 2);\n    else\n      image_need_mask(img);\n\n    depth ++;\n  }\n\n#  ifdef DEBUG\n  printf(\"bit_depth=%d, color_type=0x%04x, depth=%d, img->width=%d, img->height=%d, img->depth=%d\\n\", bit_depth, color_type, depth, img->width, img->height, img->depth);\n  if (color_type & PNG_COLOR_MASK_COLOR)\n    puts(\"    COLOR\");\n  else\n    puts(\"    GRAYSCALE\");\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n    puts(\"    ALPHA\");\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n    puts(\"    PALETTE\");\n#  endif // DEBUG\n\n  if (!load_data)\n  {\n    png_destroy_read_struct(&pp, &info, NULL);\n    return (0);\n  }\n\n  img->pixels = (uchar *)calloc(1,(size_t)(img->width * img->height * depth));\n\n /*\n  * Allocate pointers...\n  */\n\n  rows = (png_bytep *)calloc(png_get_image_height(pp, info), sizeof(png_bytep));\n\n  for (i = 0; i < (int)png_get_image_height(pp, info); i ++)\n    rows[i] = img->pixels + i * img->width * depth;\n\n /*\n  * Read the image, handling interlacing as needed...\n  */\n\n  for (i = png_set_interlace_handling(pp); i > 0; i --)\n    png_read_rows(pp, rows, NULL, (png_uint_32)img->height);\n\n /*\n  * Generate the alpha mask as necessary...\n  */\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n#  ifdef DEBUG\n    for (inptr = img->pixels, i = 0; i < img->height; i ++)\n    {\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        switch (depth)\n\t{\n\t  case 2 :\n\t      printf(\" %02X%02X\", inptr[0], inptr[1]);\n\t      break;\n\t  case 4 :\n\t      printf(\" %02X%02X%02X%02X\", inptr[0], inptr[1], inptr[2], inptr[3]);\n\t      break;\n\t}\n\n      putchar('\\n');\n    }\n#  endif // DEBUG\n\n    for (inptr = img->pixels + depth - 1, i = 0; i < img->height; i ++)\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        image_set_mask(img, j, i, *inptr);\n  }\n\n /*\n  * Reformat the data as necessary for the reader...\n  */\n\n  if (gray && (color_type & PNG_COLOR_MASK_COLOR))\n  {\n   /*\n    * Grayscale output needed...\n    */\n\n    for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n         i > 0;\n         inptr += depth, outptr ++, i --)\n      *outptr = (31 * inptr[0] + 61 * inptr[1] + 8 * inptr[2]) / 100;\n  }\n  else if (img->depth != depth)\n  {\n   /*\n    * Remove alpha from final array...\n    */\n\n    if (depth == 4)\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n      {\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n      }\n    }\n    else\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n        *outptr++ = *inptr++;\n    }\n  }\n\n /*\n  * Free memory and return...\n  */\n\n  free(rows);\n\n  png_read_end(pp, info);\n  png_destroy_read_struct(&pp, &info, NULL);\n\n  return (0);\n}\n#endif // HAVE_LIBPNG\n\n\n/*\n * 'image_need_mask()' - Allocate memory for the image mask...\n */\n\nstatic void\nimage_need_mask(image_t *img,\t\t/* I - Image to add mask to */\n                int     scaling)\t/* I - Scaling for mask image */\n{\n  size_t\tsize;\t\t\t/* Byte size of mask image */\n\n\n  if (img == NULL || img->mask != NULL)\n    return;\n\n /*\n  * Figure out the size of the mask image, and then allocate and set all the\n  * bits needed...\n  */\n\n  img->maskscale = scaling;\n\n  if (scaling == 8)\n  {\n    // Alpha image\n    img->maskwidth = img->width;\n    size           = (size_t)(img->width * img->height);\n  }\n  else\n  {\n    // Alpha mask\n    img->maskwidth = (img->width * scaling + 7) / 8;\n    size           = (size_t)(img->maskwidth * img->height * scaling + 1);\n  }\n\n  img->mask = (uchar *)calloc(size, 1);\n}\n\n\n/*\n * 'image_set_mask()' - Set a bit in the image mask.\n */\n\nstatic void\nimage_set_mask(image_t *img,\t/* I - Image to operate on */\n               int     x,\t/* I - X coordinate */\n               int     y,\t/* I - Y coordinate */\n\t       uchar   alpha)\t/* I - Alpha value */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  uchar\t\t*maskptr;\t/* Pointer into mask image */\n  static uchar\tmasks[8] =\t/* Masks for each bit */\n\t\t{\n\t\t  0x80, 0x40, 0x20, 0x10,\n\t\t  0x08, 0x04, 0x02, 0x01\n\t\t};\n  static uchar\tdither[4][4] = // Simple 4x4 clustered-dot dither\n\t\t{\n\t\t  { 0,  2,  15, 6 },\n\t\t  { 4,  12, 9,  11 },\n\t\t  { 14, 7,  1,  3 },\n\t\t  { 8,  10, 5,  13 }\n\t        };\n\n\n  if (img == NULL || img->mask == NULL || x < 0 || x >= img->width ||\n      y < 0 || y >= img->height)\n    return;\n\n  if (img->maskscale == 8)\n  {\n    // Store the alpha value directly...\n    if (PSLevel)\n      img->mask[y * img->maskwidth + x] = 255 - alpha;\n    else\n      img->mask[y * img->maskwidth + x] = alpha;\n  }\n  else\n  {\n    // Store an alpha mask...\n    x *= img->maskscale;\n    y *= img->maskscale;\n    alpha >>= 4;\n\n    for (i = 0; i < img->maskscale; i ++, y ++, x -= img->maskscale)\n      for (j = 0; j < img->maskscale; j ++, x ++)\n      {\n\tmaskptr  = img->mask + y * img->maskwidth + x / 8;\n\tif (alpha <= dither[x & 3][y & 3])\n\t  *maskptr |= masks[x & 7];\n      }\n  }\n}\n\n\n/*\n * 'image_unload()' - Unload an image from memory.\n */\n\nvoid\nimage_unload(image_t *img)\t// I - Image\n{\n  if (!img)\n    return;\n\n  if (!img->use || !img->pixels)\n    return;\n\n  if (img->obj)\n    img->use = 0;\n  else\n    img->use --;\n\n  if (img->use)\n    return;\n\n  free(img->pixels);\n  img->pixels = NULL;\n}\n\n\n#ifdef HAVE_LIBJPEG\n/*\n * 'jpeg_error_handler()' - Handle JPEG errors by not exiting.\n */\n\nstatic void\njpeg_error_handler(j_common_ptr p)\t// Common JPEG data\n{\n  hd_jpeg_err_t\t*jerr = (hd_jpeg_err_t *)p->err;\n\t\t\t\t\t// JPEG error handler\n\n\n  // Save the error message in the string buffer...\n  (jerr->jerr.format_message)(p, jerr->message);\n\n  // Return to the point we called setjmp()...\n  longjmp(jerr->retbuf, 1);\n}\n#endif // HAVE_LIBJPEG\n\n\n/*\n * 'read_word()' - Read a 16-bit unsigned integer.\n */\n\nstatic unsigned short     /* O - 16-bit unsigned integer */\nread_word(FILE *fp)       /* I - File to read from */\n{\n  unsigned char b0, b1; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n\n  return (unsigned short)((b1 << 8) | b0);\n}\n\n\n/*\n * 'read_dword()' - Read a 32-bit unsigned integer.\n */\n\nstatic unsigned int               /* O - 32-bit unsigned integer */\nread_dword(FILE *fp)              /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return (unsigned)((((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n\n\n/*\n * 'read_long()' - Read a 32-bit signed integer.\n */\n\nstatic int                        /* O - 32-bit signed integer */\nread_long(FILE *fp)               /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return ((int)(((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n"], "filenames": ["CHANGES.md", "htmldoc/image.cxx"], "buggy_code_start_loc": [0, 1314], "buggy_code_end_loc": [0, 1788], "fixing_code_start_loc": [1, 1315], "fixing_code_end_loc": [6, 1788], "type": "CWE-787", "message": "A heap buffer overflow in image_set_mask function of HTMLDOC before 1.9.15 allows an attacker to write outside the buffer boundaries.", "other": {"cve": {"id": "CVE-2022-0137", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2022-11-14T18:15:15.903", "lastModified": "2023-02-02T18:31:13.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap buffer overflow in image_set_mask function of HTMLDOC before 1.9.15 allows an attacker to write outside the buffer boundaries."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:htmldoc_project:htmldoc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.15", "matchCriteriaId": "76FBE339-551C-4C28-B91E-6E18D158C9C7"}]}]}], "references": [{"url": "https://github.com/michaelrsweet/htmldoc/commit/71fe87878c9cbc3db429f5e5c70f28e4b3d96e3b", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/htmldoc/issues/461", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelrsweet/htmldoc/commit/71fe87878c9cbc3db429f5e5c70f28e4b3d96e3b"}}