{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/*macro used for table gf_realloc - we allocate much more than needed in order to keep the number of\ngf_realloc low, which greatly impacts performances for large files*/\n#define ALLOC_INC(a) {\\\n\t\tu32 new_a = ((a<10) ? 100 : (a*3)/2);\\\n\t\tif (new_a < a) return GF_OUT_OF_MEM;\\\n\t\ta = new_a;\\\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n//adds a DTS in the table and get the sample number of this new sample\n//we could return an error if a sample with the same DTS already exists\n//but this is not true for QT or MJ2K, only for MP4...\n//we assume the authoring tool tries to create a compliant MP4 file.\nGF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_packed_samples)\n{\n\tu32 i, j, sampNum;\n\tu64 *DTSs, curDTS;\n\tBool inserted;\n\tGF_SttsEntry *ent;\n\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\t//reset the reading cache when adding a sample\n\tstts->r_FirstSampleInEntry = 0;\n\n\t*sampleNumber = 0;\n\tif (!nb_packed_samples)\n\t\tnb_packed_samples=1;\n\n\t//if we don't have an entry, that's the first one...\n\tif (!stts->nb_entries) {\n\t\t//assert the first DTS is 0. If not, that will break the whole file\n\t\tif (DTS) return GF_BAD_PARAM;\n\t\tstts->alloc_size = 1;\n\t\tstts->nb_entries = 1;\n\t\tstts->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tstts->entries[0].sampleCount = nb_packed_samples;\n\t\tstts->entries[0].sampleDelta = (nb_packed_samples>1) ? 0 : LastAUDefDuration;\n\t\t(*sampleNumber) = 1;\n\t\tstts->w_currentSampleNum = nb_packed_samples;\n\t\treturn GF_OK;\n\t}\n\t//check the last DTS - we allow 0-duration samples (same DTS)\n\tif (DTS >= stts->w_LastDTS) {\n\t\tu32 nb_extra = 0;\n\t\tent = &stts->entries[stts->nb_entries-1];\n\t\tif (!ent->sampleDelta && (ent->sampleCount>1)) {\n\t\t\tent->sampleDelta = (u32) ( DTS / ent->sampleCount);\n\t\t\tstts->w_LastDTS = DTS - ent->sampleDelta;\n\t\t}\n\t\t//OK, we're adding at the end\n\t\tif ((DTS == stts->w_LastDTS + ent->sampleDelta)\n\t\t\t//for raw audio, consider (dts==last_dts) and (dts==last_dts+2*delta) as sample append to cope with\n\t\t\t//timescale vs samplerate precision\n\t\t\t|| ((nb_packed_samples>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))\n\t\t) {\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n\t\t\tent->sampleCount += nb_packed_samples;\n\t\t\tstts->w_currentSampleNum += nb_packed_samples;\n\t\t\tstts->w_LastDTS = DTS + ent->sampleDelta * (nb_packed_samples-1);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (ent->sampleCount == 1) {\n\t\t\t//FIXME - we need more tests with timed text\n#if 0\n\t\t\tif (stts->w_LastDTS)\n\t\t\t\tent->sampleDelta += (u32) (DTS - stts->w_LastDTS);\n\t\t\telse\n\t\t\t\tent->sampleDelta = (u32) DTS;\n#else\n\t\t\t//use this one and adjust...\n\t\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n#endif\n\n\t\t\tent->sampleCount ++;\n\t\t\t//little opt, merge last entry with previous one if same delta\n\t\t\tif ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {\n\t\t\t\tstts->entries[stts->nb_entries-2].sampleCount += ent->sampleCount;\n\t\t\t\tstts->nb_entries--;\n\t\t\t}\n\t\t\tstts->w_currentSampleNum ++;\n\t\t\tstts->w_LastDTS = DTS;\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we definitely need to split the entry ;)\n\t\tent->sampleCount --;\n\n\t\tif (nb_packed_samples>1)\n\t\t\tnb_extra = 1;\n\n\t\tif (stts->alloc_size <= stts->nb_entries + nb_extra) {\n\t\t\tALLOC_INC(stts->alloc_size);\n\t\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t\t}\n\n\t\tif (nb_extra)\n\t\t\tnb_extra = stts->entries[stts->nb_entries-1].sampleDelta;\n\n\t\tent = &stts->entries[stts->nb_entries];\n\t\tstts->nb_entries++;\n\n\t\tif (nb_packed_samples==1) {\n\t\t\tent->sampleCount = 2;\n\t\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n\t\t\tstts->w_LastDTS = DTS;\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum+1;\n\t\t\tstts->w_currentSampleNum += 1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tent->sampleCount = 1;\n\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n\n\t\tent = &stts->entries[stts->nb_entries];\n\t\tstts->nb_entries++;\n\n\t\tent->sampleCount = nb_packed_samples;\n\t\tent->sampleDelta = nb_extra;\n\t\tstts->w_LastDTS = DTS;\n\t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n\t\tstts->w_currentSampleNum += nb_packed_samples;\n\t\treturn GF_OK;\n\t}\n\n\n\t//unpack the DTSs and locate new sample...\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount+2) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\tcurDTS = 0;\n\tsampNum = 0;\n\tent = NULL;\n\tinserted = 0;\n\tfor (i=0; i<stts->nb_entries; i++) {\n\t\tent = & stts->entries[i];\n\t\tfor (j = 0; j<ent->sampleCount; j++) {\n\t\t\tif (!inserted && (curDTS > DTS)) {\n\t\t\t\tDTSs[sampNum] = DTS;\n\t\t\t\tsampNum++;\n\t\t\t\t*sampleNumber = sampNum;\n\t\t\t\tinserted = 1;\n\t\t\t}\n\t\t\tDTSs[sampNum] = curDTS;\n\t\t\tcurDTS += ent->sampleDelta;\n\t\t\tsampNum ++;\n\t\t}\n\t}\n\tif (!inserted) {\n\t\tgf_free(DTSs);\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t/*we will at most insert 3 new entries*/\n\tif (stts->nb_entries+3 >= stts->alloc_size) {\n\t\tstts->alloc_size += 3;\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size - stts->nb_entries) );\n\t}\n\n\t/*repack the DTSs*/\n\tj=0;\n\tstts->nb_entries = 1;\n\tstts->entries[0].sampleCount = 1;\n\tstts->entries[0].sampleDelta = (u32) DTSs[1] /* - (DTS[0] which is 0)*/;\n\tfor (i=1; i<stbl->SampleSize->sampleCount+1; i++) {\n\t\tif (i == stbl->SampleSize->sampleCount) {\n\t\t\t//and by default, our last sample has the same delta as the prev\n\t\t\tstts->entries[j].sampleCount++;\n\t\t} else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {\n\t\t\tstts->entries[j].sampleCount ++;\n\t\t} else {\n\t\t\tstts->nb_entries ++;\n\t\t\tj++;\n\t\t\tstts->entries[j].sampleCount = 1;\n\t\t\tstts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);\n\t\t}\n\t}\n\tgf_free(DTSs);\n\n\t//reset the cache to the end\n\tstts->w_currentSampleNum = stbl->SampleSize->sampleCount + 1;\n\treturn GF_OK;\n}\n\nGF_Err AddCompositionOffset(GF_CompositionOffsetBox *ctts, s32 offset)\n{\n\tif (!ctts) return GF_BAD_PARAM;\n\n\tif (ctts->nb_entries && (ctts->entries[ctts->nb_entries-1].decodingOffset==offset)) {\n\t\tctts->entries[ctts->nb_entries-1].sampleCount++;\n\t} else {\n\t\tif (ctts->alloc_size==ctts->nb_entries) {\n\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t}\n\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\n\t\tctts->entries[ctts->nb_entries].decodingOffset = offset;\n\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\tctts->nb_entries++;\n\t}\n\tif (offset<0) ctts->version=1;\n\tctts->w_LastSampleNumber++;\n\treturn GF_OK;\n}\n\n//adds a CTS offset for a new sample\nGF_Err stbl_AddCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset)\n{\n\tu32 i, j, sampNum, *CTSs;\n\n\tGF_CompositionOffsetBox *ctts = stbl->CompositionOffset;\n\n\t/*in unpack mode we're sure to have 1 ctts entry per sample*/\n\tif (ctts->unpack_mode) {\n\t\tif (ctts->nb_entries==ctts->alloc_size) {\n\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size - ctts->nb_entries) );\n\t\t}\n\t\tctts->entries[ctts->nb_entries].decodingOffset = offset;\n\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\tctts->nb_entries++;\n\t\tctts->w_LastSampleNumber++;\n\t\tif (offset<0) ctts->version=1;\n\t\treturn GF_OK;\n\t}\n\t//check if we're working in order...\n\tif (ctts->w_LastSampleNumber < sampleNumber) {\n\t\t//add some 0 till we get to the sample\n\t\twhile (ctts->w_LastSampleNumber + 1 != sampleNumber) {\n\t\t\tGF_Err e = AddCompositionOffset(ctts, 0);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn AddCompositionOffset(ctts, offset);\n\t}\n\n\t//NOPE we are inserting a sample...\n\tCTSs = (u32*)gf_malloc(sizeof(u32) * (stbl->SampleSize->sampleCount+1) );\n\tif (!CTSs) return GF_OUT_OF_MEM;\n\tsampNum = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tfor (j = 0; j<ctts->entries[i].sampleCount; j++) {\n\t\t\tif (sampNum > stbl->SampleSize->sampleCount) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Too many CTS Offset entries for %d samples\\n\", stbl->SampleSize->sampleCount ));\n\t\t\t\tgf_free(CTSs);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif (sampNum+1==sampleNumber) {\n\t\t\t\tCTSs[sampNum] = offset;\n\t\t\t\tsampNum ++;\n\t\t\t}\n\t\t\tCTSs[sampNum] = ctts->entries[i].decodingOffset;\n\t\t\tsampNum ++;\n\t\t}\n\t}\n\n\t/*we will at most add 2 new entries (splitting of an existing one)*/\n\tif (ctts->nb_entries+2>=ctts->alloc_size) {\n\t\tctts->alloc_size += 2;\n\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t}\n\n\tctts->entries[0].sampleCount = 1;\n\tctts->entries[0].decodingOffset = CTSs[0];\n\tctts->nb_entries = 1;\n\tj=0;\n\tfor (i=1; i<stbl->SampleSize->sampleCount + 1; i++) {\n\t\tif (CTSs[i]==ctts->entries[j].decodingOffset) {\n\t\t\tctts->entries[j].sampleCount++;\n\t\t} else {\n\t\t\tj++;\n\t\t\tctts->nb_entries++;\n\t\t\tctts->entries[j].sampleCount = 1;\n\t\t\tctts->entries[j].decodingOffset = CTSs[i];\n\t\t}\n\t}\n\tgf_free(CTSs);\n\n\tif (offset<0) ctts->version=1;\n\n\t/*we've inserted a sample, therefore the last sample (n) has now number n+1\n\twe cannot use SampleCount because we have probably skipped some samples\n\t(we're calling AddCTS only if the sample has a offset !!!)*/\n\tctts->w_LastSampleNumber += 1;\n\treturn GF_OK;\n}\n\nGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts)\n{\n\tu32 i, j;\n\n\tif (!ctts->unpack_mode) return GF_OK;\n\tctts->unpack_mode = 0;\n\n\tj=0;\n\tfor (i=1; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset==ctts->entries[j].decodingOffset) {\n\t\t\tctts->entries[j].sampleCount++;\n\t\t} else {\n\t\t\tj++;\n\t\t\tctts->entries[j].sampleCount = 1;\n\t\t\tctts->entries[j].decodingOffset = ctts->entries[i].decodingOffset;\n\t\t}\n\t}\n\tctts->nb_entries=j+1;\n\t/*note we don't realloc*/\n\treturn GF_OK;\n}\n\nGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl)\n{\n\tGF_DttsEntry *packed;\n\tu32 i, j, count;\n\tGF_CompositionOffsetBox *ctts;\n\tctts = stbl->CompositionOffset;\n\tif (!ctts || ctts->unpack_mode) return GF_OK;\n\tctts->unpack_mode = 1;\n\n\tpacked = ctts->entries;\n\tcount = ctts->nb_entries;\n\tctts->entries = NULL;\n\tctts->nb_entries = 0;\n\tctts->alloc_size = 0;\n\tfor (i=0; i<count; i++) {\n\t\tfor (j=0; j<packed[i].sampleCount; j++) {\n\t\t\tif (ctts->nb_entries == ctts->alloc_size) {\n\t\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\n\t\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t\t}\n\t\t\tctts->entries[ctts->nb_entries].decodingOffset = packed[i].decodingOffset;\n\t\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\t\tctts->nb_entries++;\n\t\t}\n\t}\n\tgf_free(packed);\n\n\twhile (stbl->SampleSize->sampleCount > ctts->nb_entries) {\n\t\tif (ctts->nb_entries == ctts->alloc_size) {\n\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t}\n\t\tctts->entries[ctts->nb_entries].decodingOffset = 0;\n\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\tctts->nb_entries++;\n\t}\n\treturn GF_OK;\n}\n\n//add size\nGF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples)\n{\n\tu32 i, k;\n\tu32 *newSizes;\n\tif (!stsz /*|| !size */ || !sampleNumber) return GF_BAD_PARAM;\n\n\tif (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM;\n\n\tif (!nb_pack_samples) nb_pack_samples = 1;\n\telse if (nb_pack_samples>1)\n\t\tsize /= nb_pack_samples;\n\n\t//all samples have the same size\n\tif (stsz->sizes == NULL) {\n\t\t//1 first sample added in NON COMPACT MODE\n\t\tif (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) {\n\t\t\tstsz->sampleCount = nb_pack_samples;\n\t\t\tstsz->sampleSize = size;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//2- sample has the same size\n\t\tif (stsz->sampleSize == size) {\n\t\t\tstsz->sampleCount += nb_pack_samples;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (nb_pack_samples>1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Inserting packed samples with different sizes is not yet supported\\n\" ));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\t//3- no, need to alloc a size table\n\t\tstsz->sizes = (u32*)gf_malloc(sizeof(u32) * (stsz->sampleCount + 1));\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tstsz->alloc_size = stsz->sampleCount + 1;\n\n\t\tk = 0;\n\t\tfor (i = 0 ; i < stsz->sampleCount; i++) {\n\t\t\tif (i + 1 == sampleNumber) {\n\t\t\t\tstsz->sizes[i + k] = size;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tstsz->sizes[i+k] = stsz->sampleSize;\n\t\t}\n\t\t//this if we append a new sample\n\t\tif (stsz->sampleCount + 1 == sampleNumber) {\n\t\t\tstsz->sizes[stsz->sampleCount] = size;\n\t\t}\n\t\tstsz->sampleSize = 0;\n\t\tstsz->sampleCount++;\n\t\treturn GF_OK;\n\t}\n\n\n\t/*append*/\n\tif (stsz->sampleCount + 1 == sampleNumber) {\n\t\tif (!stsz->alloc_size) stsz->alloc_size = stsz->sampleCount;\n\t\tif (stsz->sampleCount == stsz->alloc_size) {\n\t\t\tALLOC_INC(stsz->alloc_size);\n\t\t\tstsz->sizes = gf_realloc(stsz->sizes, sizeof(u32)*(stsz->alloc_size) );\n\t\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stsz->sizes[stsz->sampleCount], 0, sizeof(u32)*(stsz->alloc_size - stsz->sampleCount) );\n\t\t}\n\t\tstsz->sizes[stsz->sampleCount] = size;\n\t} else {\n\t\tnewSizes = (u32*)gf_malloc(sizeof(u32)*(1 + stsz->sampleCount) );\n\t\tif (!newSizes) return GF_OUT_OF_MEM;\n\t\tk = 0;\n\t\tfor (i = 0; i < stsz->sampleCount; i++) {\n\t\t\tif (i + 1 == sampleNumber) {\n\t\t\t\tnewSizes[i + k] = size;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tnewSizes[i + k] = stsz->sizes[i];\n\t\t}\n\t\tgf_free(stsz->sizes);\n\t\tstsz->sizes = newSizes;\n\t\tstsz->alloc_size = 1 + stsz->sampleCount;\n\t}\n\tstsz->sampleCount++;\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_AddRAP(GF_SyncSampleBox *stss, u32 sampleNumber)\n{\n\tu32 i, k;\n\tu32 *newNumbers;\n\n\tif (!stss || !sampleNumber) return GF_BAD_PARAM;\n\n\tif (stss->sampleNumbers == NULL) {\n\t\tALLOC_INC(stss->alloc_size);\n\t\tstss->sampleNumbers = (u32*)gf_malloc(sizeof(u32)*stss->alloc_size);\n\t\tif (!stss->sampleNumbers) return GF_OUT_OF_MEM;\n\t\tstss->sampleNumbers[0] = sampleNumber;\n\t\tstss->nb_entries = 1;\n\t\treturn GF_OK;\n\t}\n\n\tif (stss->sampleNumbers[stss->nb_entries-1] == sampleNumber) return GF_OK;\n\n\tif (stss->sampleNumbers[stss->nb_entries-1] < sampleNumber) {\n\t\tif (stss->nb_entries==stss->alloc_size) {\n\t\t\tALLOC_INC(stss->alloc_size);\n\t\t\tstss->sampleNumbers = gf_realloc(stss->sampleNumbers, sizeof(u32) * stss->alloc_size);\n\t\t\tif (!stss->sampleNumbers) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stss->sampleNumbers[stss->nb_entries], 0, sizeof(u32) * (stss->alloc_size-stss->nb_entries) );\n\t\t}\n\t\tstss->sampleNumbers[stss->nb_entries] = sampleNumber;\n\t} else {\n\t\tnewNumbers = (u32*)gf_malloc(sizeof(u32) * (stss->nb_entries + 1));\n\t\tif (!newNumbers) return GF_OUT_OF_MEM;\n\t\t//the table is in increasing order of sampleNumber\n\t\tk = 0;\n\t\tfor (i = 0; i < stss->nb_entries; i++) {\n\t\t\tif (stss->sampleNumbers[i] >= sampleNumber) {\n\t\t\t\tnewNumbers[i + k] = sampleNumber;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tnewNumbers[i + k] = stss->sampleNumbers[i] + k;\n\t\t}\n\t\tgf_free(stss->sampleNumbers);\n\t\tstss->sampleNumbers = newNumbers;\n\t\tstss->alloc_size = stss->nb_entries+1;\n\t}\n\t//update our list\n\tstss->nb_entries ++;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AddRedundant(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tGF_SampleDependencyTypeBox *sdtp;\n\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\tif (sdtp->sampleCount + 1 < sampleNumber) {\n\t\tu32 missed = sampleNumber-1 - sdtp->sampleCount;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount+missed) );\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t\tsdtp->sample_alloc = sdtp->sampleCount+missed;\n\t\tmemset(&sdtp->sample_info[sdtp->sampleCount], 0, sizeof(u8) * missed );\n\t\twhile (missed) {\n\t\t\tGF_ISOSAPType isRAP;\n\t\t\tif (stbl->SyncSample) stbl_GetSampleRAP(stbl->SyncSample, sdtp->sampleCount+1, &isRAP, NULL, NULL);\n\t\t\telse isRAP = 1;\n\t\t\tsdtp->sample_info[sdtp->sampleCount] = isRAP ? 0x20 : 0;\n\t\t\tsdtp->sampleCount++;\n\t\t\tmissed--;\n\t\t}\n\t}\n\n\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount + 1));\n\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\tsdtp->sample_alloc = sdtp->sampleCount+1;\n\tif (sdtp->sampleCount < sampleNumber) {\n\t\tsdtp->sample_info[sdtp->sampleCount] = 0x29;\n\t} else {\n\t\tu32 snum = sampleNumber-1;\n\t\tmemmove(sdtp->sample_info+snum+1, sdtp->sample_info+snum, sizeof(u8) * (sdtp->sampleCount - snum) );\n\t\tsdtp->sample_info[snum] = 0x29;\n\t}\n\t//update our list\n\tsdtp->sampleCount ++;\n\treturn GF_OK;\n}\n\nGF_Err stbl_SetDependencyType(GF_SampleTableBox *stbl, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_SampleDependencyTypeBox *sdtp;\n\tu32 flags;\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\n\tflags = 0;\n\tflags |= isLeading << 6;\n\tflags |= dependsOn << 4;\n\tflags |= dependedOn << 2;\n\tflags |= redundant;\n\n\tif (sdtp->sampleCount < sampleNumber) {\n\t\tu32 i;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * sampleNumber);\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t\tsdtp->sample_alloc = sampleNumber;\n\n\t\tfor (i=sdtp->sampleCount; i<sampleNumber; i++) {\n\t\t\tsdtp->sample_info[i] = 0;\n\t\t}\n\t\tsdtp->sampleCount = sampleNumber;\n\t}\n\tsdtp->sample_info[sampleNumber-1] = flags;\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err stbl_AddDependencyType(GF_SampleTableBox *stbl, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tu32 flags;\n\tGF_SampleDependencyTypeBox *sdtp;\n\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\tif (sdtp->sampleCount + 1 < sampleNumber) {\n\t\tu32 missed = sampleNumber-1 - sdtp->sampleCount;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount+missed) );\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t\tsdtp->sample_alloc = sdtp->sampleCount+missed;\n\t\tmemset(&sdtp->sample_info[sdtp->sampleCount], 0, sizeof(u8) * missed );\n\t\twhile (missed) {\n\t\t\tGF_ISOSAPType isRAP;\n\t\t\tif (stbl->SyncSample) stbl_GetSampleRAP(stbl->SyncSample, sdtp->sampleCount+1, &isRAP, NULL, NULL);\n\t\t\telse isRAP = 1;\n\t\t\tsdtp->sample_info[sdtp->sampleCount] = isRAP ? (2<<4) : 0;\n\t\t\tif (isRAP) {\n\t\t\t\tsdtp->sample_info[sdtp->sampleCount] = 0;\n\n\t\t\t}\n\t\t\tsdtp->sampleCount++;\n\t\t\tmissed--;\n\t\t}\n\t}\n\n\tflags = 0;\n\tflags |= isLeading << 6;\n\tflags |= dependsOn << 4;\n\tflags |= dependedOn << 2;\n\tflags |= redundant;\n\n\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount + 1));\n\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\tsdtp->sample_alloc = sdtp->sampleCount + 1;\n\tif (sdtp->sampleCount < sampleNumber) {\n\t\tsdtp->sample_info[sdtp->sampleCount] = flags;\n\t} else {\n\t\tu32 snum = sampleNumber-1;\n\t\tmemmove(sdtp->sample_info+snum+1, sdtp->sample_info+snum, sizeof(u8) * (sdtp->sampleCount - snum) );\n\t\tsdtp->sample_info[snum] = flags;\n\t}\n\t//update our list\n\tsdtp->sampleCount ++;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err stbl_AppendDependencyType(GF_SampleTableBox *stbl, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_SampleDependencyTypeBox *sdtp;\n\tu32 flags;\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\n\tflags = 0;\n\tflags |= isLeading << 6;\n\tflags |= dependsOn << 4;\n\tflags |= dependedOn << 2;\n\tflags |= redundant;\n\n\tif (sdtp->sampleCount >= sdtp->sample_alloc) {\n\t\tALLOC_INC(sdtp->sample_alloc);\n\t\tif (sdtp->sampleCount >= sdtp->sample_alloc) sdtp->sample_alloc = sdtp->sampleCount+1;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * sdtp->sample_alloc);\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t}\n\tsdtp->sample_info[sdtp->sampleCount] = flags;\n\tsdtp->sampleCount ++;\n\treturn GF_OK;\n}\n\n//this function is always called in INCREASING order of shadow sample numbers\nGF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber)\n{\n\tGF_StshEntry *ent;\n\tu32 i, count;\n\tcount = gf_list_count(stsh->entries);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i);\n\t\tif (ent->shadowedSampleNumber == shadowNumber) {\n\t\t\tent->syncSampleNumber = sampleNumber;\n\t\t\treturn GF_OK;\n\t\t} else if (ent->shadowedSampleNumber > shadowNumber) break;\n\t}\n\tent = (GF_StshEntry*)gf_malloc(sizeof(GF_StshEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->shadowedSampleNumber = shadowNumber;\n\tent->syncSampleNumber = sampleNumber;\n\tif (i == gf_list_count(stsh->entries)) {\n\t\treturn gf_list_add(stsh->entries, ent);\n\t} else {\n\t\treturn gf_list_insert(stsh->entries, ent, i ? i-1 : 0);\n\t}\n}\n\n//used in edit/write, where sampleNumber == chunkNumber\nGF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_ChunkOffsetBox *stco;\n\tGF_SampleToChunkBox *stsc;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\tu32 i, k, *newOff, new_chunk_idx=0;\n\tu64 *newLarge;\n\ts32 insert_idx = -1;\n\n\tstbl = mdia->information->sampleTable;\n\tstsc = stbl->SampleToChunk;\n\n//\tif (stsc->w_lastSampleNumber + 1 < sampleNumber ) return GF_BAD_PARAM;\n\tif (!nb_pack_samples)\n\t\tnb_pack_samples = 1;\n\n\tif (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {\n\t\tif (!stsc->alloc_size) stsc->alloc_size = 1;\n\t\tALLOC_INC(stsc->alloc_size);\n\t\tstsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);\n\t\tif (!stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) );\n\t}\n\tif (sampleNumber == stsc->w_lastSampleNumber + 1) {\n\t\tent = &stsc->entries[stsc->nb_entries];\n\t\tstsc->w_lastChunkNumber ++;\n\t\tent->firstChunk = stsc->w_lastChunkNumber;\n\t\tif (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;\n\n\t\tnew_chunk_idx = stsc->w_lastChunkNumber;\n\t\tstsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;\n\t\tstsc->nb_entries += 1;\n\t} else {\n\t\tu32 cur_samp = 1;\n\t\tu32 samples_in_next_entry = 0;\n\t\tu32 next_entry_first_chunk = 1;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tu32 nb_chunks = 1;\n\t\t\tent = &stsc->entries[i];\n\t\t\tif (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk;\n\t\t\tfor (k=0; k<nb_chunks; k++) {\n\t\t\t\tif ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) {\n\t\t\t\t\tinsert_idx = i;\n\t\t\t\t\t//stsc entry has samples before inserted sample, split\n\t\t\t\t\tif (sampleNumber>cur_samp) {\n\t\t\t\t\t\tsamples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp);\n\t\t\t\t\t\tent->samplesPerChunk = sampleNumber-cur_samp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_samp += ent->samplesPerChunk;\n\t\t\t\tnext_entry_first_chunk++;\n\t\t\t}\n\t\t\tif (insert_idx>=0) break;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (samples_in_next_entry) {\n\t\t\tmemmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1));\n\t\t\t//copy over original entry\n\t\t\tent = &stsc->entries[insert_idx];\n\t\t\tstsc->entries[insert_idx+2] = *ent;\n\t\t\tstsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;\n\t\t\tstsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;\n\n\t\t\t//setup new entry\n\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\n\t\t\tstsc->nb_entries += 2;\n\t\t} else {\n\t\t\tif (insert_idx<0) {\n\t\t\t\tent = &stsc->entries[stsc->nb_entries];\n\t\t\t\tinsert_idx = stsc->nb_entries;\n\t\t\t} else {\n\t\t\t\tmemmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx));\n\t\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\t}\n\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\t\t\tstsc->nb_entries += 1;\n\t\t}\n\t\tnew_chunk_idx = next_entry_first_chunk;\n\t}\n\tent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;\n\tent->sampleDescriptionIndex = StreamDescIndex;\n\tent->samplesPerChunk = nb_pack_samples;\n\tent->nextChunk = ent->firstChunk+1;\n\n\t//OK, now if we've inserted a chunk, update the sample to chunk info...\n\tif (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) {\n\t\tif (stsc->nb_entries)\n\t\t\tstsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;\n\n\t\tstbl->SampleToChunk->currentIndex = stsc->nb_entries-1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber;\n\t\t//write - edit mode: sample number = chunk number\n\t\tstbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t} else {\n\t\t/*offset remaining entries*/\n\t\tfor (i = insert_idx+1; i<stsc->nb_entries+1; i++) {\n\t\t\tstsc->entries[i].firstChunk++;\n\t\t\tif (i+1<stsc->nb_entries)\n\t\t\t\tstsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk;\n\t\t}\n\t}\n\n\t//add the offset to the chunk...\n\t//and we change our offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t//if the new offset is a large one, we have to rewrite our table entry by entry (32->64 bit conv)...\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tk = 0;\n\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\tif (i + 1 == new_chunk_idx) {\n\t\t\t\t\tco64->offsets[i] = offset;\n\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t\tco64->offsets[i+k] = (u64) stco->offsets[i];\n\t\t\t}\n\t\t\tif (!k) co64->offsets[co64->nb_entries - 1] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t} else {\n\t\t\t//no, we can use this one.\n\t\t\tif (new_chunk_idx > stco->nb_entries) {\n\t\t\t\tif (!stco->alloc_size) stco->alloc_size = stco->nb_entries;\n\t\t\t\tif (stco->nb_entries == stco->alloc_size) {\n\t\t\t\t\tALLOC_INC(stco->alloc_size);\n\t\t\t\t\tstco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size);\n\t\t\t\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) );\n\t\t\t\t}\n\t\t\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\t\t\tstco->nb_entries += 1;\n\t\t\t} else {\n\t\t\t\t//nope. we're inserting\n\t\t\t\tnewOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1));\n\t\t\t\tif (!newOff) return GF_OUT_OF_MEM;\n\t\t\t\tk=0;\n\t\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\t\tnewOff[i] = (u32) offset;\n\t\t\t\t\t\tk=1;\n\t\t\t\t\t}\n\t\t\t\t\tnewOff[i+k] = stco->offsets[i];\n\t\t\t\t}\n\t\t\t\tgf_free(stco->offsets);\n\t\t\t\tstco->offsets = newOff;\n\t\t\t\tstco->nb_entries ++;\n\t\t\t\tstco->alloc_size = stco->nb_entries;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t//use large offset...\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (sampleNumber > co64->nb_entries) {\n\t\t\tif (!co64->alloc_size) co64->alloc_size = co64->nb_entries;\n\t\t\tif (co64->nb_entries == co64->alloc_size) {\n\t\t\t\tALLOC_INC(co64->alloc_size);\n\t\t\t\tco64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size);\n\t\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\t\tmemset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) );\n\t\t\t}\n\t\t\tco64->offsets[co64->nb_entries] = offset;\n\t\t\tco64->nb_entries += 1;\n\t\t} else {\n\t\t\t//nope. we're inserting\n\t\t\tnewLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1));\n\t\t\tif (!newLarge) return GF_OUT_OF_MEM;\n\t\t\tk=0;\n\t\t\tfor (i=0; i<co64->nb_entries; i++) {\n\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\tnewLarge[i] = offset;\n\t\t\t\t\tk=1;\n\t\t\t\t}\n\t\t\t\tnewLarge[i+k] = co64->offsets[i];\n\t\t\t}\n\t\t\tgf_free(co64->offsets);\n\t\t\tco64->offsets = newLarge;\n\t\t\tco64->nb_entries++;\n\t\t\tco64->alloc_size++;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_SetChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u64 offset)\n{\n\tGF_StscEntry *ent;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_SampleTableBox *stbl = mdia->information->sampleTable;\n\n\tif (!sampleNumber || !stbl) return GF_BAD_PARAM;\n\n\tent = &stbl->SampleToChunk->entries[sampleNumber - 1];\n\n\t//we edit our entry if self contained\n\tif (Media_IsSelfContained(mdia, ent->sampleDescriptionIndex))\n\t\tent->isEdited = 1;\n\n\t//and we change our offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t//if the new offset is a large one, we have to rewrite our table...\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = ((GF_ChunkOffsetBox *)stbl->ChunkOffset)->nb_entries;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64)*co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<co64->nb_entries; i++) {\n\t\t\t\tco64->offsets[i] = (u64) ((GF_ChunkOffsetBox *)stbl->ChunkOffset)->offsets[i];\n\t\t\t}\n\t\t\tco64->offsets[ent->firstChunk - 1] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t((GF_ChunkOffsetBox *)stbl->ChunkOffset)->offsets[ent->firstChunk - 1] = (u32) offset;\n\t} else {\n\t\t((GF_ChunkLargeOffsetBox *)stbl->ChunkOffset)->offsets[ent->firstChunk - 1] = offset;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_SetSampleCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset)\n{\n\tGF_CompositionOffsetBox *ctts = stbl->CompositionOffset;\n\n\tassert(ctts->unpack_mode);\n\n\t//if we're setting the CTS of a sample we've skipped...\n\tif (ctts->w_LastSampleNumber < sampleNumber) {\n\t\t//add some 0 till we get to the sample\n\t\twhile (ctts->w_LastSampleNumber + 1 != sampleNumber) {\n\t\t\tGF_Err e = AddCompositionOffset(ctts, 0);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn AddCompositionOffset(ctts, offset);\n\t}\n\tif (offset<0) ctts->version=1;\n\tctts->entries[sampleNumber-1].decodingOffset = offset;\n\treturn GF_OK;\n}\n\nGF_Err stbl_SetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 size)\n{\n\tu32 i;\n\tif (!SampleNumber || (stsz->sampleCount < SampleNumber)) return GF_BAD_PARAM;\n\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sampleSize == size) return GF_OK;\n\t\tif (stsz->sampleCount == 1) {\n\t\t\tstsz->sampleSize = size;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//nope, we have to rewrite a table\n\t\tstsz->sizes = (u32*)gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<stsz->sampleCount; i++) stsz->sizes[i] = stsz->sampleSize;\n\t\tstsz->sampleSize = 0;\n\t}\n\tstsz->sizes[SampleNumber - 1] = size;\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_SetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, u8 isRAP)\n{\n\tu32 i;\n\n\t//check if we have already a sync sample\n\tfor (i = 0; i < stss->nb_entries; i++) {\n\n\t\tif (stss->sampleNumbers[i] < SampleNumber) continue;\n\t\telse if (stss->sampleNumbers[i] > SampleNumber) break;\n\n\t\t/*found our sample number*/\n\t\tif (isRAP) return GF_OK;\n\t\t/*remove it...*/\n\t\tif (i+1 < stss->nb_entries)\n\t\t\tmemmove(stss->sampleNumbers + i, stss->sampleNumbers + i + 1, sizeof(u32) * (stss->nb_entries - i - 1));\n\t\tstss->nb_entries--;\n\t\treturn GF_OK;\n\t}\n\t//we need to insert a RAP somewhere if RAP ...\n\tif (!isRAP) return GF_OK;\n\tif (stss->nb_entries==stss->alloc_size) {\n\t\tALLOC_INC(stss->alloc_size);\n\t\tstss->sampleNumbers = gf_realloc(stss->sampleNumbers, sizeof(u32)*stss->alloc_size);\n\t\tif (!stss->sampleNumbers) return GF_OUT_OF_MEM;\n\t\tmemset(&stss->sampleNumbers[stss->nb_entries], 0, sizeof(u32)*(stss->alloc_size - stss->nb_entries) );\n\t}\n\n\tif (i+1 < stss->nb_entries)\n\t\tmemmove(stss->sampleNumbers + i + 1, stss->sampleNumbers + i, sizeof(u32) * (stss->nb_entries - i - 1));\n\tstss->sampleNumbers[i] = SampleNumber;\n\tstss->nb_entries ++;\n\treturn GF_OK;\n}\n\nGF_Err stbl_SetRedundant(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tif (stbl->SampleDep->sampleCount < sampleNumber) {\n\t\treturn stbl_AddRedundant(stbl, sampleNumber);\n\t} else {\n\t\tstbl->SampleDep->sample_info[sampleNumber-1] = 0x29;\n\t\treturn GF_OK;\n\t}\n}\n\nGF_Err stbl_SetSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 syncSample)\n{\n\tu32 i, count;\n\tGF_StshEntry *ent;\n\n\tcount = gf_list_count(stsh->entries);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i);\n\t\tif (ent->shadowedSampleNumber == sampleNumber) {\n\t\t\tent->syncSampleNumber = syncSample;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ent->shadowedSampleNumber > sampleNumber) break;\n\t}\n\t//we need a new one...\n\tent = (GF_StshEntry*)gf_malloc(sizeof(GF_StshEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->shadowedSampleNumber = sampleNumber;\n\tent->syncSampleNumber = syncSample;\n\t//insert or append ?\n\tif (i == gf_list_count(stsh->entries)) {\n\t\t//don't update the cache ...\n\t\treturn gf_list_add(stsh->entries, ent);\n\t} else {\n\t\t//update the cache\n\t\tstsh->r_LastEntryIndex = i;\n\t\tstsh->r_LastFoundSample = sampleNumber;\n\t\treturn gf_list_insert(stsh->entries, ent, i);\n\t}\n}\n\n\n//always called before removing the sample from SampleSize\nGF_Err stbl_RemoveDTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples, u32 LastAUDefDuration)\n{\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\n\tif ((nb_samples>1) && (sampleNumber>1)) return GF_BAD_PARAM;\n\n\tstts = stbl->TimeToSample;\n\n\t//we're removing the only sample: empty the sample table\n\tif (stbl->SampleSize->sampleCount == 1) {\n\t\tstts->nb_entries = 0;\n\t\tstts->r_FirstSampleInEntry = stts->r_currentEntryIndex = 0;\n\t\tstts->r_CurrentDTS = 0;\n\t\treturn GF_OK;\n\t}\n\t//we're removing the last sample\n\tif ((nb_samples==1) && (sampleNumber == stbl->SampleSize->sampleCount)) {\n\t\tent = &stts->entries[stts->nb_entries-1];\n\t\tent->sampleCount--;\n\t\tif (!ent->sampleCount) stts->nb_entries--;\n\t} else {\n\t\tu64 *DTSs, curDTS;\n\t\tu32 i, j, k, sampNum;\n\t\tu32 tot_samples, nb_written=0;\n\t\t//unpack the DTSs...\n\t\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount - 1));\n\t\tif (!DTSs) return GF_OUT_OF_MEM;\n\t\tmemset(DTSs, 0, sizeof(u64) * (stbl->SampleSize->sampleCount - 1) );\n\n\t\tcurDTS = 0;\n\t\tsampNum = 0;\n\t\tent = NULL;\n\t\tk=0;\n\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = & stts->entries[i];\n\t\t\tfor (j=0; j<ent->sampleCount; j++) {\n\t\t\t\tif (nb_samples==1) {\n\t\t\t\t\tif (sampNum == sampleNumber - 1) {\n\t\t\t\t\t\tk=1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDTSs[sampNum-k] = curDTS;\n\t\t\t\t\t}\n\t\t\t\t} else if (sampNum >= nb_samples) {\n\t\t\t\t\tDTSs[sampNum - nb_samples] = curDTS;\n\t\t\t\t\tnb_written++;\n\t\t\t\t}\n\t\t\t\tcurDTS += ent->sampleDelta;\n\t\t\t\tsampNum ++;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_samples>1) {\n\t\t\tassert(sampNum == stbl->SampleSize->sampleCount);\n\t\t\tassert(nb_written + nb_samples == stbl->SampleSize->sampleCount);\n\t\t}\n\t\tj=0;\n\n\t\tif (nb_samples==1) {\n\t\t\ttot_samples = stbl->SampleSize->sampleCount - 1;\n\t\t} else {\n\t\t\ttot_samples = stbl->SampleSize->sampleCount - nb_samples;\n\t\t}\n\t\tif (tot_samples) {\n\t\t\tsampNum = 1;\n\t\t\tstts->nb_entries = 1;\n\t\t\tstts->entries[0].sampleCount = 1;\n\t\t\tif (stbl->SampleSize->sampleCount == 2) {\n\t\t\t\tstts->entries[0].sampleDelta = LastAUDefDuration;\n\t\t\t} else {\n\t\t\t\tstts->entries[0].sampleDelta = (u32) DTSs[1] /*- DTSs[0]*/;\n\t\t\t}\n\t\t} else {\n\t\t\tsampNum = 0;\n\t\t\tstts->nb_entries = 0;\n\t\t}\n\n\t\tfor (i=1; i<tot_samples; i++) {\n\t\t\tif (i+1 == tot_samples) {\n\t\t\t\t//and by default, our last sample has the same delta as the prev\n\t\t\t\tstts->entries[j].sampleCount++;\n\t\t\t\tsampNum ++;\n\t\t\t} else if (DTSs[i+1] - DTSs[i] == stts->entries[j].sampleDelta) {\n\t\t\t\tstts->entries[j].sampleCount += 1;\n\t\t\t\tsampNum ++;\n\t\t\t} else {\n\t\t\t\tstts->nb_entries++;\n\t\t\t\tif (j+1==stts->alloc_size) {\n\t\t\t\t\tstts->alloc_size++;\n\t\t\t\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry) * stts->alloc_size);\n\t\t\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tstts->entries[j].sampleCount = 1;\n\t\t\t\tstts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);\n\t\t\t\tassert(stts->entries[j].sampleDelta);\n\t\t\t\tsampNum ++;\n\t\t\t}\n\t\t}\n\t\tstts->w_LastDTS = tot_samples ? DTSs[tot_samples - 1] : 0;\n\t\tgf_free(DTSs);\n\t\tassert(sampNum == tot_samples);\n\t\tassert(sampNum + nb_samples == stbl->SampleSize->sampleCount);\n\t}\n\n\t//reset write the cache to the end\n\tstts->w_currentSampleNum = stbl->SampleSize->sampleCount - nb_samples;\n\t//reset read the cache to the beginning\n\tstts->r_FirstSampleInEntry = stts->r_currentEntryIndex = 0;\n\tstts->r_CurrentDTS = 0;\n\treturn GF_OK;\n}\n\n\n//always called before removing the sample from SampleSize\nGF_Err stbl_RemoveCTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples)\n{\n\tGF_CompositionOffsetBox *ctts = stbl->CompositionOffset;\n\tif (!ctts) return GF_OK;\n\n\tassert(ctts->unpack_mode);\n\tif ((nb_samples>1) && (sampleNumber>1)) return GF_BAD_PARAM;\n\n\t//last one...\n\tif (stbl->SampleSize->sampleCount == 1) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) ctts);\n\t\tstbl->CompositionOffset = NULL;\n\t\treturn GF_OK;\n\t}\n\n\t//the number of entries is NOT ALWAYS the number of samples !\n\t//instead, use the cache\n\t//first case, we're removing a sample that was not added yet\n\tif (sampleNumber > ctts->w_LastSampleNumber) return GF_OK;\n\n\tif (nb_samples==1) {\n\t\tassert(ctts->nb_entries);\n\t\tmemmove(&ctts->entries[sampleNumber-1], &ctts->entries[sampleNumber], sizeof(GF_DttsEntry)* (ctts->nb_entries-sampleNumber) );\n\t\tctts->nb_entries--;\n\t} else {\n\t\tmemmove(&ctts->entries[0], &ctts->entries[nb_samples], sizeof(GF_DttsEntry)* (ctts->nb_entries-nb_samples) );\n\t\tctts->nb_entries -= nb_samples;\n\t}\n\tctts->w_LastSampleNumber -= nb_samples;\n\tassert(ctts->w_LastSampleNumber >= ctts->nb_entries);\n\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveSize(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples)\n{\n\tGF_SampleSizeBox *stsz = stbl->SampleSize;\n\n\tif ((nb_samples>1) && (sampleNumber>1)) return GF_BAD_PARAM;\n\t//last sample\n\tif (stsz->sampleCount == 1) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = NULL;\n\t\tstsz->sampleCount = 0;\n\t\treturn GF_OK;\n\t}\n\t//one single size\n\tif (stsz->sampleSize) {\n\t\tstsz->sampleCount -= nb_samples;\n\t\treturn GF_OK;\n\t}\n\tif (nb_samples==1) {\n\t\tif (sampleNumber < stsz->sampleCount)\n\t\t\tmemmove(stsz->sizes + sampleNumber - 1, stsz->sizes + sampleNumber, sizeof(u32) * (stsz->sampleCount - sampleNumber));\n\t} else {\n\t\tif (nb_samples < stsz->sampleCount)\n\t\t\tmemmove(stsz->sizes, stsz->sizes + nb_samples, sizeof(u32) * (stsz->sampleCount - nb_samples));\n\t}\n\tstsz->sampleCount -= nb_samples;\n\treturn GF_OK;\n}\n\n//always called after removing the sample from SampleSize\nGF_Err stbl_RemoveChunk(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *stsc = stbl->SampleToChunk;\n\n\tif ((nb_samples>1) && (sampleNumber>1))\n\t\treturn GF_BAD_PARAM;\n\t\n\t//raw audio or constant sample size and dur\n\tif (stsc->nb_entries < stbl->SampleSize->sampleCount) {\n\t\tif (sampleNumber==stbl->SampleSize->sampleCount+1) {\n\t\t\tGF_StscEntry *ent = &stsc->entries[stsc->nb_entries-1];\n\t\t\tif (ent->samplesPerChunk)\n\t\t\t\tent->samplesPerChunk--;\n\t\t\tif (!ent->samplesPerChunk) {\n\t\t\t\tstsc->nb_entries--;\n\n\t\t\t\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\t\t\t((GF_ChunkOffsetBox *)stbl->ChunkOffset)->nb_entries --;\n\t\t\t\t} else {\n\t\t\t\t\t((GF_ChunkLargeOffsetBox *)stbl->ChunkOffset)->nb_entries --;\n\t\t\t\t}\n\t\t\t\tif (stsc->nb_entries) {\n\t\t\t\t\tent = &stsc->entries[stsc->nb_entries-1];\n\t\t\t\t\tent->nextChunk --;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] removing sample in middle of track not supported for constant size and duration samples\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\t//remove the entry in SampleToChunk (1 <-> 1 in edit mode)\n\tif (nb_samples==1) {\n\t\tmemmove(&stsc->entries[sampleNumber-1], &stsc->entries[sampleNumber], sizeof(GF_StscEntry)*(stsc->nb_entries-sampleNumber));\n\t\tstsc->nb_entries--;\n\n\t\t//update the firstchunk info\n\t\tfor (i=sampleNumber-1; i < stsc->nb_entries; i++) {\n\t\t\tassert(stsc->entries[i].firstChunk >= 1);\n\t\t\tstsc->entries[i].firstChunk -= 1;\n\t\t\tif (stsc->entries[i].nextChunk) {\n\t\t\t\tassert(stsc->entries[i].nextChunk >= 1);\n\t\t\t\tstsc->entries[i].nextChunk -= 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmemmove(&stsc->entries[0], &stsc->entries[nb_samples], sizeof(GF_StscEntry)*(stsc->nb_entries-nb_samples));\n\t\tstsc->nb_entries -= nb_samples;\n\n\t\t//update the firstchunk info\n\t\tfor (i=0; i < stsc->nb_entries; i++) {\n\t\t\tstsc->entries[i].firstChunk = i+1;\n\t\t\tstsc->entries[i].nextChunk = (stsc->nb_entries==i+1) ? 0 : i+2;\n\t\t}\n\t}\n\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size - stsc->nb_entries) );\n\n\t//update the cache\n\tstsc->firstSampleInCurrentChunk = 1;\n\tstsc->currentIndex = 0;\n\tstsc->currentChunk = 1;\n\tstsc->ghostNumber = 1;\n\n\t//realloc the chunk offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (!stbl->SampleSize->sampleCount) {\n\t\t\tgf_free(stco->offsets);\n\t\t\tstco->offsets = NULL;\n\t\t\tstco->nb_entries = 0;\n\t\t\tstco->alloc_size = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tassert(stco->nb_entries - nb_samples == stbl->SampleSize->sampleCount);\n\t\tif (nb_samples==1) {\n\t\t\tmemmove(&stco->offsets[sampleNumber-1], &stco->offsets[sampleNumber], sizeof(u32) * (stco->nb_entries - sampleNumber) );\n\t\t} else {\n\t\t\tmemmove(&stco->offsets[0], &stco->offsets[nb_samples], sizeof(u32) * (stco->nb_entries - nb_samples) );\n\t\t}\n\t\tstco->nb_entries -= nb_samples;\n\t} else {\n\t\tGF_ChunkLargeOffsetBox *co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (!stbl->SampleSize->sampleCount) {\n\t\t\tgf_free(co64->offsets);\n\t\t\tco64->offsets = NULL;\n\t\t\tco64->nb_entries = 0;\n\t\t\tco64->alloc_size = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tassert(co64->nb_entries - nb_samples == stbl->SampleSize->sampleCount);\n\t\tif (nb_samples==1) {\n\t\t\tmemmove(&co64->offsets[sampleNumber-1], &co64->offsets[sampleNumber], sizeof(u64) * (co64->nb_entries - sampleNumber) );\n\t\t} else {\n\t\t\tmemmove(&co64->offsets[0], &co64->offsets[nb_samples], sizeof(u64) * (co64->nb_entries - nb_samples) );\n\t\t}\n\t\tco64->nb_entries -= nb_samples;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_RemoveRAP(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tu32 i;\n\n\tGF_SyncSampleBox *stss = stbl->SyncSample;\n\tif (!stss) return GF_OK;\n\n\t//we remove the only one around...\n\tif (stss->nb_entries == 1) {\n\t\tif (stss->sampleNumbers[0] != sampleNumber) return GF_OK;\n\t\t//free our numbers but don't delete (all samples are NON-sync\n\t\tgf_free(stss->sampleNumbers);\n\t\tstss->sampleNumbers = NULL;\n\t\tstss->r_LastSampleIndex = stss->r_LastSyncSample = 0;\n\t\tstss->alloc_size = stss->nb_entries = 0;\n\t\treturn GF_OK;\n\t}\n\n\tfor (i=0; i<stss->nb_entries; i++) {\n\t\t//found the sample\n\t\tif (sampleNumber == stss->sampleNumbers[i]) {\n\t\t\tmemmove(&stss->sampleNumbers[i], &stss->sampleNumbers[i+1], sizeof(u32)* (stss->nb_entries-i-1) );\n\t\t\tstss->nb_entries--;\n\t\t}\n\n\t\tif (sampleNumber < stss->sampleNumbers[i]) {\n\t\t\tassert(stss->sampleNumbers[i]);\n\t\t\tstss->sampleNumbers[i]--;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveRedundant(GF_SampleTableBox *stbl, u32 SampleNumber, u32 nb_samples)\n{\n\tu32 i;\n\n\tif (!stbl->SampleDep) return GF_OK;\n\tif (stbl->SampleDep->sampleCount < SampleNumber) return GF_BAD_PARAM;\n\tif ((nb_samples>1) && (SampleNumber>1)) return GF_BAD_PARAM;\n\n\tif (nb_samples==1) {\n\t\ti = stbl->SampleDep->sampleCount - SampleNumber;\n\t\tif (i) memmove(&stbl->SampleDep->sample_info[SampleNumber-1], & stbl->SampleDep->sample_info[SampleNumber], sizeof(u8)*i);\n\t\tstbl->SampleDep->sample_info = (u8*)gf_realloc(stbl->SampleDep->sample_info, sizeof(u8) * (stbl->SampleDep->sampleCount-1));\n\t\tif (!stbl->SampleDep->sample_info) return GF_OUT_OF_MEM;\n\t\tstbl->SampleDep->sample_alloc = stbl->SampleDep->sampleCount-1;\n\t\tstbl->SampleDep->sampleCount-=1;\n\t} else {\n\t\tmemmove(&stbl->SampleDep->sample_info[0], &stbl->SampleDep->sample_info[nb_samples], sizeof(u8) * (stbl->SampleDep->sampleCount - nb_samples) );\n\t\tstbl->SampleDep->sampleCount -= nb_samples;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveShadow(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tu32 i;\n\tGF_ShadowSyncBox *stsh;\n\tGF_StshEntry *ent;\n\tif (!stbl->ShadowSync) return GF_OK;\n\tstsh = stbl->ShadowSync;\n\n\t//we loop for the whole chain cause the spec doesn't say if we can have several\n\t//shadows for 1 sample...\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(stsh->entries, &i))) {\n\t\tif (ent->shadowedSampleNumber == sampleNumber) {\n\t\t\ti--;\n\t\t\tgf_list_rem(stsh->entries, i);\n\t\t}\n\t}\n\t//reset the cache\n\tstsh->r_LastEntryIndex = 0;\n\tstsh->r_LastFoundSample = 0;\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_SetPaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber, u8 bits)\n{\n\tu8 *p;\n\t//make sure the sample is a good one\n\tif (SampleNumber > stbl->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//create the table\n\tif (!stbl->PaddingBits) {\n\t\tstbl->PaddingBits = (GF_PaddingBitsBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_PADB);\n\t\tif (!stbl->PaddingBits) return GF_OUT_OF_MEM;\n\t}\n\n\t//alloc\n\tif (!stbl->PaddingBits->padbits || !stbl->PaddingBits->SampleCount) {\n\t\tstbl->PaddingBits->SampleCount = stbl->SampleSize->sampleCount;\n\t\tstbl->PaddingBits->padbits = (u8*)gf_malloc(sizeof(u8)*stbl->PaddingBits->SampleCount);\n\t\tif (!stbl->PaddingBits->padbits) return GF_OUT_OF_MEM;\n\t\tmemset(stbl->PaddingBits->padbits, 0, sizeof(u8)*stbl->PaddingBits->SampleCount);\n\t}\n\t//realloc (this is needed in case n out of k samples get padding added)\n\tif (stbl->PaddingBits->SampleCount < stbl->SampleSize->sampleCount) {\n\t\tp = (u8*)gf_malloc(sizeof(u8) * stbl->SampleSize->sampleCount);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\t//set everything to 0\n\t\tmemset(p, 0, stbl->SampleSize->sampleCount);\n\t\t//copy our previous table\n\t\tmemcpy(p, stbl->PaddingBits->padbits, stbl->PaddingBits->SampleCount);\n\t\tgf_free(stbl->PaddingBits->padbits);\n\t\tstbl->PaddingBits->padbits = p;\n\t\tstbl->PaddingBits->SampleCount = stbl->SampleSize->sampleCount;\n\t}\n\tstbl->PaddingBits->padbits[SampleNumber-1] = bits;\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemovePaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber)\n{\n\tu8 *p;\n\tu32 i, k;\n\n\tif (!stbl->PaddingBits) return GF_OK;\n\tif (stbl->PaddingBits->SampleCount < SampleNumber) return GF_BAD_PARAM;\n\n\t//last sample - remove the table\n\tif (stbl->PaddingBits->SampleCount == 1) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->PaddingBits);\n\t\tstbl->PaddingBits = NULL;\n\t\treturn GF_OK;\n\t}\n\n\t//reallocate and check size by the way...\n\tp = (u8 *)gf_malloc(sizeof(u8) * (stbl->PaddingBits->SampleCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\n\tk=0;\n\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\tif (i+1 != SampleNumber) {\n\t\t\tp[k] = stbl->PaddingBits->padbits[i];\n\t\t\tk++;\n\t\t}\n\t}\n\n\tstbl->PaddingBits->SampleCount -= 1;\n\tgf_free(stbl->PaddingBits->padbits);\n\tstbl->PaddingBits->padbits = p;\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveSubSample(GF_SampleTableBox *stbl, u32 SampleNumber)\n{\n\tu32 i, count, j, subs_count, prev_sample, delta=0;\n\n\tif (! stbl->sub_samples) return GF_OK;\n\tsubs_count = gf_list_count(stbl->sub_samples);\n\tfor (j=0; j<subs_count; j++) {\n\t\tGF_SubSampleInformationBox *subs = gf_list_get(stbl->sub_samples, j);\n\t\tif (! subs->Samples) continue;\n\n\t\tprev_sample = 0;\n\t\tcount = gf_list_count(subs->Samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleInfoEntry *e = gf_list_get(subs->Samples, i);\n\t\t\tprev_sample += e->sample_delta;\n\t\t\tif (prev_sample==SampleNumber) {\n\t\t\t\tgf_list_rem(subs->Samples, i);\n\t\t\t\twhile (gf_list_count(e->SubSamples)) {\n\t\t\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_list_get(e->SubSamples, 0);\n\t\t\t\t\tgf_free(pSubSamp);\n\t\t\t\t\tgf_list_rem(e->SubSamples, 0);\n\t\t\t\t}\n\t\t\t\tgf_list_del(e->SubSamples);\n\t\t\t\tgf_free(e);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tdelta=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te->sample_delta+=delta;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_RemoveSampleGroup(GF_SampleTableBox *stbl, u32 SampleNumber)\n{\n\tu32 i, k, count, prev_sample;\n\n\tif (!stbl->sampleGroups) return GF_OK;\n\n\tcount = gf_list_count(stbl->sampleGroups);\n\tprev_sample = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *e = gf_list_get(stbl->sampleGroups, i);\n\t\tfor (k=0; k<e->entry_count; k++) {\n\t\t\tif ((SampleNumber>prev_sample) && (SampleNumber <= prev_sample + e->sample_entries[k].sample_count) ) {\n\t\t\t\te->sample_entries[k].sample_count--;\n\t\t\t\tif (!e->sample_entries[k].sample_count) {\n\t\t\t\t\tmemmove(&e->sample_entries[k], &e->sample_entries[k+1], sizeof(GF_SampleGroupEntry) * (e->entry_count-k-1));\n\t\t\t\t\te->entry_count--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!e->entry_count) {\n\t\t\tgf_list_rem(stbl->sampleGroups, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) e);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_SampleSizeAppend(GF_SampleSizeBox *stsz, u32 data_size)\n{\n\tu32 i;\n\tif (!stsz || !stsz->sampleCount) return GF_BAD_PARAM;\n\n\t//we must realloc our table\n\tif (stsz->sampleSize) {\n\t\tstsz->sizes = (u32*)gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<stsz->sampleCount; i++) stsz->sizes[i] = stsz->sampleSize;\n\t\tstsz->sampleSize = 0;\n\t}\n\tif (!stsz->sizes) {\n\t\tstsz->sampleSize = data_size;\n\t} else {\n\t\tu32 single_size;\n\t\tstsz->sizes[stsz->sampleCount-1] += data_size;\n\n\t\tsingle_size = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (stsz->sizes[i] != single_size) {\n\t\t\t\tsingle_size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (single_size) {\n\t\t\tstsz->sampleSize = single_size;\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}\n\n\n\nGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tu32 i;\n\t\n\t//we may have to convert the table...\n\tif (stbl->ChunkOffset->type==GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\n\t\tif (offset>0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tif (co64->nb_entries<=stco->nb_entries) return GF_OUT_OF_MEM;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<stco->nb_entries; i++) co64->offsets[i] = stco->offsets[i];\n\t\t\tco64->offsets[i] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we're fine\n\t\tstco->alloc_size = stco->nb_entries + 1;\n\t\tif (stco->alloc_size < stco->nb_entries + 1) return GF_OUT_OF_MEM;\n\t\tstco->offsets = gf_realloc(stco->offsets, sizeof(u32)*stco->alloc_size);\n\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\tstco->nb_entries += 1;\n\t\treturn GF_OK;\n\t}\n\n\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\tco64->alloc_size = co64->nb_entries+1;\n\tif (co64->alloc_size < co64->nb_entries + 1) return GF_OUT_OF_MEM;\n\n\tco64->offsets = gf_realloc(co64->offsets, sizeof(u64)*co64->alloc_size);\n\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\tco64->offsets[co64->nb_entries] = offset;\n\tco64->alloc_size = co64->nb_entries;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk)\n{\n\tu32 nextChunk;\n\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\tGF_StscEntry *ent;\n\n\tnextChunk = ((GF_ChunkOffsetBox *) stbl->ChunkOffset)->nb_entries;\n\n\tif (stsc->nb_entries) {\n\t\tent = &stsc->entries[stsc->nb_entries-1];\n\t\t//good we can use this one\n\t\tif ( (ent->sampleDescriptionIndex == DescIndex) && (ent->samplesPerChunk==samplesInChunk))\n\t\t\treturn GF_OK;\n\n\t\t//set the next chunk btw ...\n\t\tent->nextChunk = nextChunk;\n\t}\n\tif (stsc->nb_entries==stsc->alloc_size) {\n\t\tALLOC_INC(stsc->alloc_size);\n\t\tstsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);\n\t\tif (!stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size - stsc->nb_entries) );\n\t}\n\t//ok we need a new entry - this assumes this function is called AFTER AppendChunk\n\tent = &stsc->entries[stsc->nb_entries];\n\tent->firstChunk = nextChunk;\n\tent->sampleDescriptionIndex = DescIndex;\n\tent->samplesPerChunk = samplesInChunk;\n\tent->isEdited = 0;\n\tstsc->nb_entries++;\n\treturn GF_OK;\n}\n\n//called AFTER AddSize\nGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap)\n{\n\tu32 i;\n\n\t//no sync table\n\tif (!stbl->SyncSample) {\n\t\t//all samples RAP - no table\n\t\tif (isRap) return GF_OK;\n\n\t\t//nope, create one\n\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\tstbl->SyncSample->sampleNumbers = (u32*)gf_malloc(sizeof(u32) * (stbl->SampleSize->sampleCount-1));\n\t\t\tif (!stbl->SyncSample->sampleNumbers) return GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount-1; i++)\n\t\t\t\tstbl->SyncSample->sampleNumbers[i] = i+1;\n\n\t\t}\n\t\tstbl->SyncSample->nb_entries = stbl->SampleSize->sampleCount-1;\n\t\tstbl->SyncSample->alloc_size = stbl->SyncSample->nb_entries;\n\t\treturn GF_OK;\n\t}\n\tif (!isRap) return GF_OK;\n\n\tif (stbl->SyncSample->alloc_size == stbl->SyncSample->nb_entries) {\n\t\tALLOC_INC(stbl->SyncSample->alloc_size);\n\t\tstbl->SyncSample->sampleNumbers = (u32*) gf_realloc(stbl->SyncSample->sampleNumbers, sizeof(u32) * stbl->SyncSample->alloc_size);\n\t\tif (!stbl->SyncSample->sampleNumbers) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SyncSample->sampleNumbers[stbl->SyncSample->nb_entries], 0, sizeof(u32) * (stbl->SyncSample->alloc_size-stbl->SyncSample->nb_entries) );\n\t}\n\tstbl->SyncSample->sampleNumbers[stbl->SyncSample->nb_entries] = stbl->SampleSize->sampleCount;\n\tstbl->SyncSample->nb_entries += 1;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendTrafMap(GF_SampleTableBox *stbl, Bool is_seg_start, u64 seg_start_offset, u64 frag_start_offset, u8 *moof_template, u32 moof_template_size, u64 sidx_start, u64 sidx_end)\n{\n\tGF_TrafToSampleMap *tmap;\n\tGF_TrafMapEntry *tmap_ent;\n\tif (!stbl->traf_map) {\n\t\t//nope, create one\n\t\tGF_SAFEALLOC(stbl->traf_map, GF_TrafToSampleMap);\n\t\tif (!stbl->traf_map) return GF_OUT_OF_MEM;\n\t}\n\ttmap = stbl->traf_map;\n\tif (tmap->nb_entries >= stbl->SampleSize->sampleCount) {\n\t\tu32 i;\n\t\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\t\tif (tmap->frag_starts[i].moof_template)\n\t\t\t\tgf_free(tmap->frag_starts[i].moof_template);\n\t\t}\n\t\tmemset(tmap->frag_starts, 0, sizeof(GF_TrafMapEntry)*tmap->nb_alloc);\n\t\ttmap->nb_entries = 0;\n\t}\n\n\tif (tmap->nb_entries + 1 > tmap->nb_alloc) {\n\t\ttmap->nb_alloc++;\n\t\ttmap->frag_starts = gf_realloc(tmap->frag_starts, sizeof(GF_TrafMapEntry) * tmap->nb_alloc);\n\t\tif (!tmap->frag_starts) return GF_OUT_OF_MEM;\n\t}\n\ttmap_ent = &tmap->frag_starts[tmap->nb_entries];\n\ttmap->nb_entries += 1;\n\n\tmemset(tmap_ent, 0, sizeof(GF_TrafMapEntry));\n\ttmap_ent->sample_num = stbl->SampleSize->sampleCount;\n\ttmap_ent->moof_template = moof_template;\n\ttmap_ent->moof_template_size = moof_template_size;\n\ttmap_ent->moof_start = frag_start_offset;\n\ttmap_ent->sidx_start = sidx_start;\n\ttmap_ent->sidx_end = sidx_end;\n\tif (is_seg_start)\n\t\ttmap_ent->seg_start_plus_one = 1 + seg_start_offset;\n\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding)\n{\n\tif (!stbl->PaddingBits) {\n\t\tstbl->PaddingBits = (GF_PaddingBitsBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_PADB);\n\t\tif (!stbl->PaddingBits) return GF_OUT_OF_MEM;\n\t}\n\tstbl->PaddingBits->padbits = (u8*)gf_realloc(stbl->PaddingBits->padbits, sizeof(u8) * stbl->SampleSize->sampleCount);\n\tif (!stbl->PaddingBits->padbits) return GF_OUT_OF_MEM;\n\tstbl->PaddingBits->padbits[stbl->SampleSize->sampleCount-1] = padding;\n\tstbl->PaddingBits->SampleCount = stbl->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 offset)\n{\n\tGF_CompositionOffsetBox *ctts;\n\n\tif (!stbl->CompositionOffset) {\n\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t}\n\tctts = stbl->CompositionOffset;\n\tctts->w_LastSampleNumber ++;\n\n\tif (!ctts->unpack_mode && ctts->nb_entries && (ctts->entries[ctts->nb_entries-1].decodingOffset == offset) ) {\n\t\tctts->entries[ctts->nb_entries-1].sampleCount++;\n\t\treturn GF_OK;\n\t}\n\tif (ctts->nb_entries==ctts->alloc_size) {\n\t\tALLOC_INC(ctts->alloc_size);\n\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t}\n\tctts->entries[ctts->nb_entries].decodingOffset = offset;\n\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\tctts->nb_entries++;\n\tif (offset<0) ctts->version=1;\n\n\tif (ABS(offset) > ctts->max_ts_delta) ctts->max_ts_delta = ABS(offset);\n\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority)\n{\n\tif (!stbl->DegradationPriority) {\n\t\tstbl->DegradationPriority = (GF_DegradationPriorityBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STDP);\n\t\tif (!stbl->DegradationPriority) return GF_OUT_OF_MEM;\n\t}\n\n\tstbl->DegradationPriority->priorities = (u16 *)gf_realloc(stbl->DegradationPriority->priorities, sizeof(u16) * stbl->SampleSize->sampleCount);\n\tif (!stbl->DegradationPriority->priorities) return GF_OUT_OF_MEM;\n\tstbl->DegradationPriority->priorities[stbl->SampleSize->sampleCount-1] = DegradationPriority;\n\tstbl->DegradationPriority->nb_entries = stbl->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err stbl_AppendDepType(GF_SampleTableBox *stbl, u32 DepType)\n{\n\tif (!stbl->SampleDep) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tstbl->SampleDep->sample_info = (u8*)gf_realloc(stbl->SampleDep->sample_info, sizeof(u8)*stbl->SampleSize->sampleCount );\n\tif (!stbl->SampleDep->sample_info) return GF_OUT_OF_MEM;\n\tstbl->SampleDep->sample_alloc = stbl->SampleSize->sampleCount;\n\tstbl->SampleDep->sample_info[stbl->SampleDep->sampleCount] = DepType;\n\tstbl->SampleDep->sampleCount = stbl->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n#endif\n\n\n\n\n//This functions unpack the offset for easy editing, eg each sample\n//is contained in one chunk...\nGF_Err stbl_UnpackOffsets(GF_SampleTableBox *stbl)\n{\n\tGF_Err e;\n\tu32 i, chunkNumber, sampleDescIndex;\n\tu64 dataOffset;\n\tGF_StscEntry *ent;\n\tGF_ChunkOffsetBox *stco_tmp;\n\tGF_ChunkLargeOffsetBox *co64_tmp;\n\tGF_SampleToChunkBox *stsc_tmp;\n\n\tif (!stbl) return GF_ISOM_INVALID_FILE;\n\n\t//we should have none of the mandatory boxes (allowed in the spec)\n\tif (!stbl->ChunkOffset && !stbl->SampleDescription && !stbl->SampleSize && !stbl->SampleToChunk && !stbl->TimeToSample)\n\t\treturn GF_OK;\n\t/*empty track (just created)*/\n\tif (!stbl->SampleToChunk && !stbl->TimeToSample) return GF_OK;\n\n\t//or all the mandatory ones ...\n\tif (!stbl->ChunkOffset || !stbl->SampleDescription || !stbl->SampleSize || !stbl->SampleToChunk || !stbl->TimeToSample)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//do we need to unpack? Not if we have only one sample per chunk.\n\tif (stbl->SampleSize->sampleCount == stbl->SampleToChunk->nb_entries) return GF_OK;\n\n\t//check the offset type and create a new table...\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tco64_tmp = NULL;\n\t\tstco_tmp = (GF_ChunkOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\tif (!stco_tmp) return GF_OUT_OF_MEM;\n\t\tstco_tmp->nb_entries = stbl->SampleSize->sampleCount;\n\t\tstco_tmp->offsets = (u32*)gf_malloc(stco_tmp->nb_entries * sizeof(u32));\n\t\tif (!stco_tmp->offsets) {\n\t\t\tgf_isom_box_del((GF_Box*)stco_tmp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tstco_tmp->alloc_size = stco_tmp->nb_entries;\n\t} else if (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tstco_tmp = NULL;\n\t\tco64_tmp = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\tif (!co64_tmp) return GF_OUT_OF_MEM;\n\t\tco64_tmp->nb_entries = stbl->SampleSize->sampleCount;\n\t\tco64_tmp->offsets = (u64*)gf_malloc(co64_tmp->nb_entries * sizeof(u64));\n\t\tif (!co64_tmp->offsets) {\n\t\t\tgf_isom_box_del((GF_Box*)co64_tmp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tco64_tmp->alloc_size = co64_tmp->nb_entries;\n\t} else {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//create a new SampleToChunk table\n\tstsc_tmp = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\tif (!stsc_tmp) return GF_OUT_OF_MEM;\n\n\tstsc_tmp->nb_entries = stsc_tmp->alloc_size = stbl->SampleSize->sampleCount;\n\tstsc_tmp->entries = gf_malloc(sizeof(GF_StscEntry)*stsc_tmp->nb_entries);\n\tif (!stsc_tmp->entries) return GF_OUT_OF_MEM;\n\t//set write cache to last sample before unpack\n\tstsc_tmp->w_lastSampleNumber = stbl->SampleSize->sampleCount;\n\tstsc_tmp->w_lastChunkNumber = stbl->SampleSize->sampleCount;\n\n\t//OK write our two tables...\n\tent = NULL;\n\tfor (i = 0; i < stbl->SampleSize->sampleCount; i++) {\n\t\t//get the data info for the sample\n\t\te = stbl_GetSampleInfos(stbl, i+1, &dataOffset, &chunkNumber, &sampleDescIndex, NULL);\n\t\tif (e) goto err_exit;\n\t\tent = &stsc_tmp->entries[i];\n\t\tent->isEdited = 0;\n\t\tent->sampleDescriptionIndex = sampleDescIndex;\n\t\t//here's the trick: each sample is in ONE chunk\n\t\tent->firstChunk = i+1;\n\t\tent->nextChunk = i+2;\n\t\tent->samplesPerChunk = 1;\n\t\tif (stco_tmp) {\n\t\t\tstco_tmp->offsets[i] = (u32) dataOffset;\n\t\t} else {\n\t\t\tco64_tmp->offsets[i] = dataOffset;\n\t\t}\n\t}\n\t//close the list\n\tif (ent) ent->nextChunk = 0;\n\n\n\t//done, remove our previous tables\n\tgf_list_del_item(stbl->child_boxes, stbl->ChunkOffset);\n\tgf_list_del_item(stbl->child_boxes, stbl->SampleToChunk);\n\tgf_isom_box_del(stbl->ChunkOffset);\n\tgf_isom_box_del((GF_Box *)stbl->SampleToChunk);\n\t//and set these ones...\n\tif (stco_tmp) {\n\t\tstbl->ChunkOffset = (GF_Box *)stco_tmp;\n\t} else {\n\t\tstbl->ChunkOffset = (GF_Box *)co64_tmp;\n\t}\n\tstbl->SampleToChunk = stsc_tmp;\n\tgf_list_add(stbl->child_boxes, stbl->ChunkOffset);\n\tgf_list_add(stbl->child_boxes, stbl->SampleToChunk);\n\n\tstbl->SampleToChunk->currentIndex = 0;\n\tstbl->SampleToChunk->currentChunk = 0;\n\tstbl->SampleToChunk->firstSampleInCurrentChunk = 0;\n\treturn GF_OK;\n\nerr_exit:\n\tif (stco_tmp) gf_isom_box_del((GF_Box *) stco_tmp);\n\tif (co64_tmp) gf_isom_box_del((GF_Box *) co64_tmp);\n\tif (stsc_tmp) gf_isom_box_del((GF_Box *) stsc_tmp);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nstatic GFINLINE GF_Err stbl_AddOffset(GF_SampleTableBox *stbl, GF_Box **old_stco, u64 offset)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tu32 i;\n\n\tif ((*old_stco)->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *) *old_stco;\n\t\t//if dataOffset is bigger than 0xFFFFFFFF, move to LARGE offset\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\ts32 prev_pos = gf_list_find(stbl->child_boxes, *old_stco);\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(co64->nb_entries * sizeof(u64));\n\t\t\tif (!co64->offsets) {\n\t\t\t\tgf_isom_box_del((GF_Box *)co64);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tfor (i = 0; i< co64->nb_entries - 1; i++) {\n\t\t\t\tco64->offsets[i] = (u64) stco->offsets[i];\n\t\t\t}\n\t\t\tco64->offsets[i] = offset;\n\t\t\t//delete the box...\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, *old_stco);\n\t\t\t*old_stco = (GF_Box *)co64;\n\n\t\t\tassert (stbl->child_boxes);\n\t\t\t//register new box only if old one was registered\n\t\t\tif (prev_pos>=0)\n\t\t\t\tgf_list_insert(stbl->child_boxes, *old_stco, prev_pos);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//OK, stick with regular...\n\t\tif (stco->nb_entries==stco->alloc_size) {\n\t\t\tALLOC_INC(stco->alloc_size);\n\t\t\tstco->offsets = (u32*)gf_realloc(stco->offsets, stco->alloc_size * sizeof(u32));\n\t\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stco->offsets[stco->nb_entries], 0, (stco->alloc_size - stco->nb_entries) * sizeof(u32));\n\t\t}\n\n\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\tstco->nb_entries += 1;\n\t} else {\n\t\t//this is a large offset\n\t\tco64 = (GF_ChunkLargeOffsetBox *) *old_stco;\n\t\tif (co64->nb_entries==co64->alloc_size) {\n\t\t\tALLOC_INC(co64->alloc_size);\n\t\t\tco64->offsets = (u64*)gf_realloc(co64->offsets, co64->alloc_size * sizeof(u64));\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tmemset(&co64->offsets[co64->nb_entries], 0, (co64->alloc_size - co64->nb_entries) * sizeof(u64) );\n\t\t}\n\t\tco64->offsets[co64->nb_entries] = offset;\n\t\tco64->nb_entries += 1;\n\t}\n\treturn GF_OK;\n}\n\n//This function packs the offset after easy editing, eg samples\n//are re-arranged in chunks according to the chunkOffsets\n//NOTE: this has to be called once interleaving or whatever is done and\n//the final MDAT is written!!!\nGF_Err stbl_SetChunkAndOffset(GF_SampleTableBox *stbl, u32 sampleNumber, u32 StreamDescIndex, GF_SampleToChunkBox *the_stsc, GF_Box **the_stco, u64 data_offset, Bool forceNewChunk, u32 nb_samp)\n{\n\tGF_Err e;\n\tu8 newChunk;\n\tGF_StscEntry *newEnt, *cur_ent;\n\n\tif (!stbl) return GF_ISOM_INVALID_FILE;\n\n\tnewChunk = 0;\n\t//do we need a new chunk ??? For that, we need\n\t//1 - make sure this sample data is contiguous to the prev one\n\n\t//force new chunk is set during writing (flat / interleaved)\n\t//it is set to 1 when data is not contiguous in the media (eg, interleaving)\n\t//when writing flat files, it is never used\n\tif (forceNewChunk) newChunk = 1;\n\n\tcur_ent = NULL;\n\t//2 - make sure we have the table inited (i=0)\n\tif (! the_stsc->entries) {\n\t\tnewChunk = 1;\n\t} else {\n\t\tcur_ent = &the_stsc->entries[the_stsc->nb_entries - 1];\n\t\t//3 - make sure we do not exceed the MaxSamplesPerChunk and we have the same descIndex\n\t\tif (StreamDescIndex != cur_ent->sampleDescriptionIndex)\n\t\t\tnewChunk = 1;\n\t\tif (stbl->MaxSamplePerChunk && cur_ent->samplesPerChunk >= stbl->MaxSamplePerChunk)\n\t\t\tnewChunk = 1;\n\t}\n\n\t//no need for a new chunk\n\tif (!newChunk) {\n\t\tcur_ent->samplesPerChunk += nb_samp;\n\t\treturn GF_OK;\n\t}\n\n\t//OK, we have to create a new chunk...\n\t//check if we can remove the current sampleToChunk entry (same properties)\n\tif (the_stsc->nb_entries > 1) {\n\t\tGF_StscEntry *ent = &the_stsc->entries[the_stsc->nb_entries - 2];\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tif ( (ent->sampleDescriptionIndex == cur_ent->sampleDescriptionIndex)\n\t\t        && (ent->samplesPerChunk == cur_ent->samplesPerChunk)\n\t\t   ) {\n\t\t\t//OK, it's the same SampleToChunk, so delete it\n\t\t\tent->nextChunk = cur_ent->firstChunk;\n\t\t\tthe_stsc->nb_entries--;\n\t\t}\n\t}\n\n\t//add our offset\n\te = stbl_AddOffset(stbl, the_stco, data_offset);\n\tif (e) return e;\n\n\tif (the_stsc->nb_entries==the_stsc->alloc_size) {\n\t\tALLOC_INC(the_stsc->alloc_size);\n\t\tthe_stsc->entries = gf_realloc(the_stsc->entries, sizeof(GF_StscEntry)*the_stsc->alloc_size);\n\t\tif (!the_stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&the_stsc->entries[the_stsc->nb_entries], 0, sizeof(GF_StscEntry)*(the_stsc->alloc_size-the_stsc->nb_entries));\n\t}\n\t//create a new entry (could be the first one, BTW)\n\tnewEnt = &the_stsc->entries[the_stsc->nb_entries];\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\n\t//get the first chunk value\n\tif ((*the_stco)->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tnewEnt->firstChunk = ((GF_ChunkOffsetBox *) (*the_stco) )->nb_entries;\n\t} else {\n\t\tnewEnt->firstChunk = ((GF_ChunkLargeOffsetBox *) (*the_stco) )->nb_entries;\n\t}\n\tnewEnt->sampleDescriptionIndex = StreamDescIndex;\n\tnewEnt->samplesPerChunk = nb_samp;\n\tnewEnt->nextChunk = 0;\n\t//if we already have an entry, adjust its next chunk to point to our new chunk\n\tif (the_stsc->nb_entries)\n\t\tthe_stsc->entries[the_stsc->nb_entries-1].nextChunk = newEnt->firstChunk;\n\tthe_stsc->nb_entries++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_refresh_size_info(GF_ISOFile *file, u32 trackNumber)\n{\n\tu32 i, size;\n\tGF_TrackBox *trak;\n\tGF_SampleSizeBox *stsz;\n\ttrak = gf_isom_get_track_from_file(file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (stsz->sampleSize || !stsz->sampleCount) return GF_OK;\n\n\tsize = stsz->sizes[0];\n\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\tif (stsz->sizes[i] != size) {\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (size) {\n\t\tgf_free(stsz->sizes);\n\t\tstsz->sizes = NULL;\n\t\tstsz->sampleSize = size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/*macro used for table gf_realloc - we allocate much more than needed in order to keep the number of\ngf_realloc low, which greatly impacts performances for large files*/\n#define ALLOC_INC(a) {\\\n\t\tu32 new_a = ((a<10) ? 100 : (a*3)/2);\\\n\t\tif (new_a < a) return GF_OUT_OF_MEM;\\\n\t\ta = new_a;\\\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\n#define CHECK_PACK(_e) \\\n\tif (!nb_pack) nb_pack = 1; \\\n\telse if ((s32) nb_pack < 0) { \\\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Too many samples %u in packed sample\\n\", nb_pack)); \\\n\t\treturn _e; \\\n\t}\n\n\n//adds a DTS in the table and get the sample number of this new sample\n//we could return an error if a sample with the same DTS already exists\n//but this is not true for QT or MJ2K, only for MP4...\n//we assume the authoring tool tries to create a compliant MP4 file.\nGF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_pack)\n{\n\tu32 i, j, sampNum;\n\tu64 *DTSs, curDTS;\n\tBool inserted;\n\tGF_SttsEntry *ent;\n\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\t//reset the reading cache when adding a sample\n\tstts->r_FirstSampleInEntry = 0;\n\n\t*sampleNumber = 0;\n\n\tCHECK_PACK(GF_BAD_PARAM)\n\n\n\t//if we don't have an entry, that's the first one...\n\tif (!stts->nb_entries) {\n\t\t//assert the first DTS is 0. If not, that will break the whole file\n\t\tif (DTS) return GF_BAD_PARAM;\n\t\tstts->alloc_size = 1;\n\t\tstts->nb_entries = 1;\n\t\tstts->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tstts->entries[0].sampleCount = nb_pack;\n\t\tstts->entries[0].sampleDelta = (nb_pack>1) ? 0 : LastAUDefDuration;\n\t\t(*sampleNumber) = 1;\n\t\tstts->w_currentSampleNum = nb_pack;\n\t\treturn GF_OK;\n\t}\n\t//check the last DTS - we allow 0-duration samples (same DTS)\n\tif (DTS >= stts->w_LastDTS) {\n\t\tu32 nb_extra = 0;\n\t\tent = &stts->entries[stts->nb_entries-1];\n\t\tif (!ent->sampleDelta && (ent->sampleCount>1)) {\n\t\t\tent->sampleDelta = (u32) ( DTS / ent->sampleCount);\n\t\t\tstts->w_LastDTS = DTS - ent->sampleDelta;\n\t\t}\n\t\t//OK, we're adding at the end\n\t\tif ((DTS == stts->w_LastDTS + ent->sampleDelta)\n\t\t\t//for raw audio, consider (dts==last_dts) and (dts==last_dts+2*delta) as sample append to cope with\n\t\t\t//timescale vs samplerate precision\n\t\t\t|| ((nb_pack>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))\n\t\t) {\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n\t\t\tent->sampleCount += nb_pack;\n\t\t\tstts->w_currentSampleNum += nb_pack;\n\t\t\tstts->w_LastDTS = DTS + ent->sampleDelta * (nb_pack-1);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (ent->sampleCount == 1) {\n\t\t\t//FIXME - we need more tests with timed text\n#if 0\n\t\t\tif (stts->w_LastDTS)\n\t\t\t\tent->sampleDelta += (u32) (DTS - stts->w_LastDTS);\n\t\t\telse\n\t\t\t\tent->sampleDelta = (u32) DTS;\n#else\n\t\t\t//use this one and adjust...\n\t\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n#endif\n\n\t\t\tent->sampleCount ++;\n\t\t\t//little opt, merge last entry with previous one if same delta\n\t\t\tif ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {\n\t\t\t\tstts->entries[stts->nb_entries-2].sampleCount += ent->sampleCount;\n\t\t\t\tstts->nb_entries--;\n\t\t\t}\n\t\t\tstts->w_currentSampleNum ++;\n\t\t\tstts->w_LastDTS = DTS;\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we definitely need to split the entry ;)\n\t\tent->sampleCount --;\n\n\t\tif (nb_pack>1)\n\t\t\tnb_extra = 1;\n\n\t\tif (stts->alloc_size <= stts->nb_entries + nb_extra) {\n\t\t\tALLOC_INC(stts->alloc_size);\n\t\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t\t}\n\n\t\tif (nb_extra)\n\t\t\tnb_extra = stts->entries[stts->nb_entries-1].sampleDelta;\n\n\t\tent = &stts->entries[stts->nb_entries];\n\t\tstts->nb_entries++;\n\n\t\tif (nb_pack==1) {\n\t\t\tent->sampleCount = 2;\n\t\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n\t\t\tstts->w_LastDTS = DTS;\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum+1;\n\t\t\tstts->w_currentSampleNum += 1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tent->sampleCount = 1;\n\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n\n\t\tent = &stts->entries[stts->nb_entries];\n\t\tstts->nb_entries++;\n\n\t\tent->sampleCount = nb_pack;\n\t\tent->sampleDelta = nb_extra;\n\t\tstts->w_LastDTS = DTS;\n\t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n\t\tstts->w_currentSampleNum += nb_pack;\n\t\treturn GF_OK;\n\t}\n\n\n\t//unpack the DTSs and locate new sample...\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount+2) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\tcurDTS = 0;\n\tsampNum = 0;\n\tent = NULL;\n\tinserted = 0;\n\tfor (i=0; i<stts->nb_entries; i++) {\n\t\tent = & stts->entries[i];\n\t\tfor (j = 0; j<ent->sampleCount; j++) {\n\t\t\tif (!inserted && (curDTS > DTS)) {\n\t\t\t\tDTSs[sampNum] = DTS;\n\t\t\t\tsampNum++;\n\t\t\t\t*sampleNumber = sampNum;\n\t\t\t\tinserted = 1;\n\t\t\t}\n\t\t\tDTSs[sampNum] = curDTS;\n\t\t\tcurDTS += ent->sampleDelta;\n\t\t\tsampNum ++;\n\t\t}\n\t}\n\tif (!inserted) {\n\t\tgf_free(DTSs);\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t/*we will at most insert 3 new entries*/\n\tif (stts->nb_entries+3 >= stts->alloc_size) {\n\t\tstts->alloc_size += 3;\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size - stts->nb_entries) );\n\t}\n\n\t/*repack the DTSs*/\n\tj=0;\n\tstts->nb_entries = 1;\n\tstts->entries[0].sampleCount = 1;\n\tstts->entries[0].sampleDelta = (u32) DTSs[1] /* - (DTS[0] which is 0)*/;\n\tfor (i=1; i<stbl->SampleSize->sampleCount+1; i++) {\n\t\tif (i == stbl->SampleSize->sampleCount) {\n\t\t\t//and by default, our last sample has the same delta as the prev\n\t\t\tstts->entries[j].sampleCount++;\n\t\t} else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {\n\t\t\tstts->entries[j].sampleCount ++;\n\t\t} else {\n\t\t\tstts->nb_entries ++;\n\t\t\tj++;\n\t\t\tstts->entries[j].sampleCount = 1;\n\t\t\tstts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);\n\t\t}\n\t}\n\tgf_free(DTSs);\n\n\t//reset the cache to the end\n\tstts->w_currentSampleNum = stbl->SampleSize->sampleCount + 1;\n\treturn GF_OK;\n}\n\nGF_Err AddCompositionOffset(GF_CompositionOffsetBox *ctts, s32 offset)\n{\n\tif (!ctts) return GF_BAD_PARAM;\n\n\tif (ctts->nb_entries && (ctts->entries[ctts->nb_entries-1].decodingOffset==offset)) {\n\t\tctts->entries[ctts->nb_entries-1].sampleCount++;\n\t} else {\n\t\tif (ctts->alloc_size==ctts->nb_entries) {\n\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t}\n\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\n\t\tctts->entries[ctts->nb_entries].decodingOffset = offset;\n\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\tctts->nb_entries++;\n\t}\n\tif (offset<0) ctts->version=1;\n\tctts->w_LastSampleNumber++;\n\treturn GF_OK;\n}\n\n//adds a CTS offset for a new sample\nGF_Err stbl_AddCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset)\n{\n\tu32 i, j, sampNum, *CTSs;\n\n\tGF_CompositionOffsetBox *ctts = stbl->CompositionOffset;\n\n\t/*in unpack mode we're sure to have 1 ctts entry per sample*/\n\tif (ctts->unpack_mode) {\n\t\tif (ctts->nb_entries==ctts->alloc_size) {\n\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size - ctts->nb_entries) );\n\t\t}\n\t\tctts->entries[ctts->nb_entries].decodingOffset = offset;\n\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\tctts->nb_entries++;\n\t\tctts->w_LastSampleNumber++;\n\t\tif (offset<0) ctts->version=1;\n\t\treturn GF_OK;\n\t}\n\t//check if we're working in order...\n\tif (ctts->w_LastSampleNumber < sampleNumber) {\n\t\t//add some 0 till we get to the sample\n\t\twhile (ctts->w_LastSampleNumber + 1 != sampleNumber) {\n\t\t\tGF_Err e = AddCompositionOffset(ctts, 0);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn AddCompositionOffset(ctts, offset);\n\t}\n\n\t//NOPE we are inserting a sample...\n\tCTSs = (u32*)gf_malloc(sizeof(u32) * (stbl->SampleSize->sampleCount+1) );\n\tif (!CTSs) return GF_OUT_OF_MEM;\n\tsampNum = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tfor (j = 0; j<ctts->entries[i].sampleCount; j++) {\n\t\t\tif (sampNum > stbl->SampleSize->sampleCount) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Too many CTS Offset entries for %d samples\\n\", stbl->SampleSize->sampleCount ));\n\t\t\t\tgf_free(CTSs);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif (sampNum+1==sampleNumber) {\n\t\t\t\tCTSs[sampNum] = offset;\n\t\t\t\tsampNum ++;\n\t\t\t}\n\t\t\tCTSs[sampNum] = ctts->entries[i].decodingOffset;\n\t\t\tsampNum ++;\n\t\t}\n\t}\n\n\t/*we will at most add 2 new entries (splitting of an existing one)*/\n\tif (ctts->nb_entries+2>=ctts->alloc_size) {\n\t\tctts->alloc_size += 2;\n\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t}\n\n\tctts->entries[0].sampleCount = 1;\n\tctts->entries[0].decodingOffset = CTSs[0];\n\tctts->nb_entries = 1;\n\tj=0;\n\tfor (i=1; i<stbl->SampleSize->sampleCount + 1; i++) {\n\t\tif (CTSs[i]==ctts->entries[j].decodingOffset) {\n\t\t\tctts->entries[j].sampleCount++;\n\t\t} else {\n\t\t\tj++;\n\t\t\tctts->nb_entries++;\n\t\t\tctts->entries[j].sampleCount = 1;\n\t\t\tctts->entries[j].decodingOffset = CTSs[i];\n\t\t}\n\t}\n\tgf_free(CTSs);\n\n\tif (offset<0) ctts->version=1;\n\n\t/*we've inserted a sample, therefore the last sample (n) has now number n+1\n\twe cannot use SampleCount because we have probably skipped some samples\n\t(we're calling AddCTS only if the sample has a offset !!!)*/\n\tctts->w_LastSampleNumber += 1;\n\treturn GF_OK;\n}\n\nGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts)\n{\n\tu32 i, j;\n\n\tif (!ctts->unpack_mode) return GF_OK;\n\tctts->unpack_mode = 0;\n\n\tj=0;\n\tfor (i=1; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset==ctts->entries[j].decodingOffset) {\n\t\t\tctts->entries[j].sampleCount++;\n\t\t} else {\n\t\t\tj++;\n\t\t\tctts->entries[j].sampleCount = 1;\n\t\t\tctts->entries[j].decodingOffset = ctts->entries[i].decodingOffset;\n\t\t}\n\t}\n\tctts->nb_entries=j+1;\n\t/*note we don't realloc*/\n\treturn GF_OK;\n}\n\nGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl)\n{\n\tGF_DttsEntry *packed;\n\tu32 i, j, count;\n\tGF_CompositionOffsetBox *ctts;\n\tctts = stbl->CompositionOffset;\n\tif (!ctts || ctts->unpack_mode) return GF_OK;\n\tctts->unpack_mode = 1;\n\n\tpacked = ctts->entries;\n\tcount = ctts->nb_entries;\n\tctts->entries = NULL;\n\tctts->nb_entries = 0;\n\tctts->alloc_size = 0;\n\tfor (i=0; i<count; i++) {\n\t\tfor (j=0; j<packed[i].sampleCount; j++) {\n\t\t\tif (ctts->nb_entries == ctts->alloc_size) {\n\t\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\n\t\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t\t}\n\t\t\tctts->entries[ctts->nb_entries].decodingOffset = packed[i].decodingOffset;\n\t\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\t\tctts->nb_entries++;\n\t\t}\n\t}\n\tgf_free(packed);\n\n\twhile (stbl->SampleSize->sampleCount > ctts->nb_entries) {\n\t\tif (ctts->nb_entries == ctts->alloc_size) {\n\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t}\n\t\tctts->entries[ctts->nb_entries].decodingOffset = 0;\n\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\tctts->nb_entries++;\n\t}\n\treturn GF_OK;\n}\n\n//add size\nGF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack)\n{\n\tu32 i, k;\n\tu32 *newSizes;\n\tif (!stsz /*|| !size */ || !sampleNumber) return GF_BAD_PARAM;\n\n\tif (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM;\n\n\tCHECK_PACK(GF_BAD_PARAM)\n\n\tif (nb_pack>1)\n\t\tsize /= nb_pack;\n\n\n\t//all samples have the same size\n\tif (stsz->sizes == NULL) {\n\t\t//1 first sample added in NON COMPACT MODE\n\t\tif (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) {\n\t\t\tstsz->sampleCount = nb_pack;\n\t\t\tstsz->sampleSize = size;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//2- sample has the same size\n\t\tif (stsz->sampleSize == size) {\n\t\t\tstsz->sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (nb_pack>1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Inserting packed samples with different sizes is not yet supported\\n\" ));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\t//3- no, need to alloc a size table\n\t\tstsz->sizes = (u32*)gf_malloc(sizeof(u32) * (stsz->sampleCount + 1));\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tstsz->alloc_size = stsz->sampleCount + 1;\n\n\t\tk = 0;\n\t\tfor (i = 0 ; i < stsz->sampleCount; i++) {\n\t\t\tif (i + 1 == sampleNumber) {\n\t\t\t\tstsz->sizes[i + k] = size;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tstsz->sizes[i+k] = stsz->sampleSize;\n\t\t}\n\t\t//this if we append a new sample\n\t\tif (stsz->sampleCount + 1 == sampleNumber) {\n\t\t\tstsz->sizes[stsz->sampleCount] = size;\n\t\t}\n\t\tstsz->sampleSize = 0;\n\t\tstsz->sampleCount++;\n\t\treturn GF_OK;\n\t}\n\n\n\t/*append*/\n\tif (stsz->sampleCount + 1 == sampleNumber) {\n\t\tif (!stsz->alloc_size) stsz->alloc_size = stsz->sampleCount;\n\t\tif (stsz->sampleCount == stsz->alloc_size) {\n\t\t\tALLOC_INC(stsz->alloc_size);\n\t\t\tstsz->sizes = gf_realloc(stsz->sizes, sizeof(u32)*(stsz->alloc_size) );\n\t\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stsz->sizes[stsz->sampleCount], 0, sizeof(u32)*(stsz->alloc_size - stsz->sampleCount) );\n\t\t}\n\t\tstsz->sizes[stsz->sampleCount] = size;\n\t} else {\n\t\tnewSizes = (u32*)gf_malloc(sizeof(u32)*(1 + stsz->sampleCount) );\n\t\tif (!newSizes) return GF_OUT_OF_MEM;\n\t\tk = 0;\n\t\tfor (i = 0; i < stsz->sampleCount; i++) {\n\t\t\tif (i + 1 == sampleNumber) {\n\t\t\t\tnewSizes[i + k] = size;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tnewSizes[i + k] = stsz->sizes[i];\n\t\t}\n\t\tgf_free(stsz->sizes);\n\t\tstsz->sizes = newSizes;\n\t\tstsz->alloc_size = 1 + stsz->sampleCount;\n\t}\n\tstsz->sampleCount++;\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_AddRAP(GF_SyncSampleBox *stss, u32 sampleNumber)\n{\n\tu32 i, k;\n\tu32 *newNumbers;\n\n\tif (!stss || !sampleNumber) return GF_BAD_PARAM;\n\n\tif (stss->sampleNumbers == NULL) {\n\t\tALLOC_INC(stss->alloc_size);\n\t\tstss->sampleNumbers = (u32*)gf_malloc(sizeof(u32)*stss->alloc_size);\n\t\tif (!stss->sampleNumbers) return GF_OUT_OF_MEM;\n\t\tstss->sampleNumbers[0] = sampleNumber;\n\t\tstss->nb_entries = 1;\n\t\treturn GF_OK;\n\t}\n\n\tif (stss->sampleNumbers[stss->nb_entries-1] == sampleNumber) return GF_OK;\n\n\tif (stss->sampleNumbers[stss->nb_entries-1] < sampleNumber) {\n\t\tif (stss->nb_entries==stss->alloc_size) {\n\t\t\tALLOC_INC(stss->alloc_size);\n\t\t\tstss->sampleNumbers = gf_realloc(stss->sampleNumbers, sizeof(u32) * stss->alloc_size);\n\t\t\tif (!stss->sampleNumbers) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stss->sampleNumbers[stss->nb_entries], 0, sizeof(u32) * (stss->alloc_size-stss->nb_entries) );\n\t\t}\n\t\tstss->sampleNumbers[stss->nb_entries] = sampleNumber;\n\t} else {\n\t\tnewNumbers = (u32*)gf_malloc(sizeof(u32) * (stss->nb_entries + 1));\n\t\tif (!newNumbers) return GF_OUT_OF_MEM;\n\t\t//the table is in increasing order of sampleNumber\n\t\tk = 0;\n\t\tfor (i = 0; i < stss->nb_entries; i++) {\n\t\t\tif (stss->sampleNumbers[i] >= sampleNumber) {\n\t\t\t\tnewNumbers[i + k] = sampleNumber;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tnewNumbers[i + k] = stss->sampleNumbers[i] + k;\n\t\t}\n\t\tgf_free(stss->sampleNumbers);\n\t\tstss->sampleNumbers = newNumbers;\n\t\tstss->alloc_size = stss->nb_entries+1;\n\t}\n\t//update our list\n\tstss->nb_entries ++;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AddRedundant(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tGF_SampleDependencyTypeBox *sdtp;\n\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\tif (sdtp->sampleCount + 1 < sampleNumber) {\n\t\tu32 missed = sampleNumber-1 - sdtp->sampleCount;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount+missed) );\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t\tsdtp->sample_alloc = sdtp->sampleCount+missed;\n\t\tmemset(&sdtp->sample_info[sdtp->sampleCount], 0, sizeof(u8) * missed );\n\t\twhile (missed) {\n\t\t\tGF_ISOSAPType isRAP;\n\t\t\tif (stbl->SyncSample) stbl_GetSampleRAP(stbl->SyncSample, sdtp->sampleCount+1, &isRAP, NULL, NULL);\n\t\t\telse isRAP = 1;\n\t\t\tsdtp->sample_info[sdtp->sampleCount] = isRAP ? 0x20 : 0;\n\t\t\tsdtp->sampleCount++;\n\t\t\tmissed--;\n\t\t}\n\t}\n\n\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount + 1));\n\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\tsdtp->sample_alloc = sdtp->sampleCount+1;\n\tif (sdtp->sampleCount < sampleNumber) {\n\t\tsdtp->sample_info[sdtp->sampleCount] = 0x29;\n\t} else {\n\t\tu32 snum = sampleNumber-1;\n\t\tmemmove(sdtp->sample_info+snum+1, sdtp->sample_info+snum, sizeof(u8) * (sdtp->sampleCount - snum) );\n\t\tsdtp->sample_info[snum] = 0x29;\n\t}\n\t//update our list\n\tsdtp->sampleCount ++;\n\treturn GF_OK;\n}\n\nGF_Err stbl_SetDependencyType(GF_SampleTableBox *stbl, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_SampleDependencyTypeBox *sdtp;\n\tu32 flags;\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\n\tflags = 0;\n\tflags |= isLeading << 6;\n\tflags |= dependsOn << 4;\n\tflags |= dependedOn << 2;\n\tflags |= redundant;\n\n\tif (sdtp->sampleCount < sampleNumber) {\n\t\tu32 i;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * sampleNumber);\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t\tsdtp->sample_alloc = sampleNumber;\n\n\t\tfor (i=sdtp->sampleCount; i<sampleNumber; i++) {\n\t\t\tsdtp->sample_info[i] = 0;\n\t\t}\n\t\tsdtp->sampleCount = sampleNumber;\n\t}\n\tsdtp->sample_info[sampleNumber-1] = flags;\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err stbl_AddDependencyType(GF_SampleTableBox *stbl, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tu32 flags;\n\tGF_SampleDependencyTypeBox *sdtp;\n\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\tif (sdtp->sampleCount + 1 < sampleNumber) {\n\t\tu32 missed = sampleNumber-1 - sdtp->sampleCount;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount+missed) );\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t\tsdtp->sample_alloc = sdtp->sampleCount+missed;\n\t\tmemset(&sdtp->sample_info[sdtp->sampleCount], 0, sizeof(u8) * missed );\n\t\twhile (missed) {\n\t\t\tGF_ISOSAPType isRAP;\n\t\t\tif (stbl->SyncSample) stbl_GetSampleRAP(stbl->SyncSample, sdtp->sampleCount+1, &isRAP, NULL, NULL);\n\t\t\telse isRAP = 1;\n\t\t\tsdtp->sample_info[sdtp->sampleCount] = isRAP ? (2<<4) : 0;\n\t\t\tif (isRAP) {\n\t\t\t\tsdtp->sample_info[sdtp->sampleCount] = 0;\n\n\t\t\t}\n\t\t\tsdtp->sampleCount++;\n\t\t\tmissed--;\n\t\t}\n\t}\n\n\tflags = 0;\n\tflags |= isLeading << 6;\n\tflags |= dependsOn << 4;\n\tflags |= dependedOn << 2;\n\tflags |= redundant;\n\n\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * (sdtp->sampleCount + 1));\n\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\tsdtp->sample_alloc = sdtp->sampleCount + 1;\n\tif (sdtp->sampleCount < sampleNumber) {\n\t\tsdtp->sample_info[sdtp->sampleCount] = flags;\n\t} else {\n\t\tu32 snum = sampleNumber-1;\n\t\tmemmove(sdtp->sample_info+snum+1, sdtp->sample_info+snum, sizeof(u8) * (sdtp->sampleCount - snum) );\n\t\tsdtp->sample_info[snum] = flags;\n\t}\n\t//update our list\n\tsdtp->sampleCount ++;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err stbl_AppendDependencyType(GF_SampleTableBox *stbl, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_SampleDependencyTypeBox *sdtp;\n\tu32 flags;\n\tif (stbl->SampleDep == NULL) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tsdtp = stbl->SampleDep;\n\n\tflags = 0;\n\tflags |= isLeading << 6;\n\tflags |= dependsOn << 4;\n\tflags |= dependedOn << 2;\n\tflags |= redundant;\n\n\tif (sdtp->sampleCount >= sdtp->sample_alloc) {\n\t\tALLOC_INC(sdtp->sample_alloc);\n\t\tif (sdtp->sampleCount >= sdtp->sample_alloc) sdtp->sample_alloc = sdtp->sampleCount+1;\n\t\tsdtp->sample_info = (u8*) gf_realloc(sdtp->sample_info, sizeof(u8) * sdtp->sample_alloc);\n\t\tif (!sdtp->sample_info) return GF_OUT_OF_MEM;\n\t}\n\tsdtp->sample_info[sdtp->sampleCount] = flags;\n\tsdtp->sampleCount ++;\n\treturn GF_OK;\n}\n\n//this function is always called in INCREASING order of shadow sample numbers\nGF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber)\n{\n\tGF_StshEntry *ent;\n\tu32 i, count;\n\tcount = gf_list_count(stsh->entries);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i);\n\t\tif (ent->shadowedSampleNumber == shadowNumber) {\n\t\t\tent->syncSampleNumber = sampleNumber;\n\t\t\treturn GF_OK;\n\t\t} else if (ent->shadowedSampleNumber > shadowNumber) break;\n\t}\n\tent = (GF_StshEntry*)gf_malloc(sizeof(GF_StshEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->shadowedSampleNumber = shadowNumber;\n\tent->syncSampleNumber = sampleNumber;\n\tif (i == gf_list_count(stsh->entries)) {\n\t\treturn gf_list_add(stsh->entries, ent);\n\t} else {\n\t\treturn gf_list_insert(stsh->entries, ent, i ? i-1 : 0);\n\t}\n}\n\n//used in edit/write, where sampleNumber == chunkNumber\nGF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_ChunkOffsetBox *stco;\n\tGF_SampleToChunkBox *stsc;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\tu32 i, k, *newOff, new_chunk_idx=0;\n\tu64 *newLarge;\n\ts32 insert_idx = -1;\n\n\tstbl = mdia->information->sampleTable;\n\tstsc = stbl->SampleToChunk;\n\n//\tif (stsc->w_lastSampleNumber + 1 < sampleNumber ) return GF_BAD_PARAM;\n\tCHECK_PACK(GF_BAD_PARAM)\n\n\tif (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {\n\t\tif (!stsc->alloc_size) stsc->alloc_size = 1;\n\t\tALLOC_INC(stsc->alloc_size);\n\t\tstsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);\n\t\tif (!stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) );\n\t}\n\tif (sampleNumber == stsc->w_lastSampleNumber + 1) {\n\t\tent = &stsc->entries[stsc->nb_entries];\n\t\tstsc->w_lastChunkNumber ++;\n\t\tent->firstChunk = stsc->w_lastChunkNumber;\n\t\tif (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;\n\n\t\tnew_chunk_idx = stsc->w_lastChunkNumber;\n\t\tstsc->w_lastSampleNumber = sampleNumber + nb_pack-1;\n\t\tstsc->nb_entries += 1;\n\t} else {\n\t\tu32 cur_samp = 1;\n\t\tu32 samples_in_next_entry = 0;\n\t\tu32 next_entry_first_chunk = 1;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tu32 nb_chunks = 1;\n\t\t\tent = &stsc->entries[i];\n\t\t\tif (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk;\n\t\t\tfor (k=0; k<nb_chunks; k++) {\n\t\t\t\tif ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) {\n\t\t\t\t\tinsert_idx = i;\n\t\t\t\t\t//stsc entry has samples before inserted sample, split\n\t\t\t\t\tif (sampleNumber>cur_samp) {\n\t\t\t\t\t\tsamples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp);\n\t\t\t\t\t\tent->samplesPerChunk = sampleNumber-cur_samp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_samp += ent->samplesPerChunk;\n\t\t\t\tnext_entry_first_chunk++;\n\t\t\t}\n\t\t\tif (insert_idx>=0) break;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (samples_in_next_entry) {\n\t\t\tmemmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1));\n\t\t\t//copy over original entry\n\t\t\tent = &stsc->entries[insert_idx];\n\t\t\tstsc->entries[insert_idx+2] = *ent;\n\t\t\tstsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;\n\t\t\tstsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;\n\n\t\t\t//setup new entry\n\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\n\t\t\tstsc->nb_entries += 2;\n\t\t} else {\n\t\t\tif (insert_idx<0) {\n\t\t\t\tent = &stsc->entries[stsc->nb_entries];\n\t\t\t\tinsert_idx = stsc->nb_entries;\n\t\t\t} else {\n\t\t\t\tmemmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx));\n\t\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\t}\n\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\t\t\tstsc->nb_entries += 1;\n\t\t}\n\t\tnew_chunk_idx = next_entry_first_chunk;\n\t}\n\tent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;\n\tent->sampleDescriptionIndex = StreamDescIndex;\n\tent->samplesPerChunk = nb_pack;\n\tent->nextChunk = ent->firstChunk+1;\n\n\t//OK, now if we've inserted a chunk, update the sample to chunk info...\n\tif (sampleNumber + nb_pack - 1 == stsc->w_lastSampleNumber) {\n\t\tif (stsc->nb_entries)\n\t\t\tstsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;\n\n\t\tstbl->SampleToChunk->currentIndex = stsc->nb_entries-1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber;\n\t\t//write - edit mode: sample number = chunk number\n\t\tstbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t} else {\n\t\t/*offset remaining entries*/\n\t\tfor (i = insert_idx+1; i<stsc->nb_entries+1; i++) {\n\t\t\tstsc->entries[i].firstChunk++;\n\t\t\tif (i+1<stsc->nb_entries)\n\t\t\t\tstsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk;\n\t\t}\n\t}\n\n\t//add the offset to the chunk...\n\t//and we change our offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t//if the new offset is a large one, we have to rewrite our table entry by entry (32->64 bit conv)...\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tk = 0;\n\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\tif (i + 1 == new_chunk_idx) {\n\t\t\t\t\tco64->offsets[i] = offset;\n\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t\tco64->offsets[i+k] = (u64) stco->offsets[i];\n\t\t\t}\n\t\t\tif (!k) co64->offsets[co64->nb_entries - 1] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t} else {\n\t\t\t//no, we can use this one.\n\t\t\tif (new_chunk_idx > stco->nb_entries) {\n\t\t\t\tif (!stco->alloc_size) stco->alloc_size = stco->nb_entries;\n\t\t\t\tif (stco->nb_entries == stco->alloc_size) {\n\t\t\t\t\tALLOC_INC(stco->alloc_size);\n\t\t\t\t\tstco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size);\n\t\t\t\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) );\n\t\t\t\t}\n\t\t\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\t\t\tstco->nb_entries += 1;\n\t\t\t} else {\n\t\t\t\t//nope. we're inserting\n\t\t\t\tnewOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1));\n\t\t\t\tif (!newOff) return GF_OUT_OF_MEM;\n\t\t\t\tk=0;\n\t\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\t\tnewOff[i] = (u32) offset;\n\t\t\t\t\t\tk=1;\n\t\t\t\t\t}\n\t\t\t\t\tnewOff[i+k] = stco->offsets[i];\n\t\t\t\t}\n\t\t\t\tgf_free(stco->offsets);\n\t\t\t\tstco->offsets = newOff;\n\t\t\t\tstco->nb_entries ++;\n\t\t\t\tstco->alloc_size = stco->nb_entries;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t//use large offset...\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (sampleNumber > co64->nb_entries) {\n\t\t\tif (!co64->alloc_size) co64->alloc_size = co64->nb_entries;\n\t\t\tif (co64->nb_entries == co64->alloc_size) {\n\t\t\t\tALLOC_INC(co64->alloc_size);\n\t\t\t\tco64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size);\n\t\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\t\tmemset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) );\n\t\t\t}\n\t\t\tco64->offsets[co64->nb_entries] = offset;\n\t\t\tco64->nb_entries += 1;\n\t\t} else {\n\t\t\t//nope. we're inserting\n\t\t\tnewLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1));\n\t\t\tif (!newLarge) return GF_OUT_OF_MEM;\n\t\t\tk=0;\n\t\t\tfor (i=0; i<co64->nb_entries; i++) {\n\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\tnewLarge[i] = offset;\n\t\t\t\t\tk=1;\n\t\t\t\t}\n\t\t\t\tnewLarge[i+k] = co64->offsets[i];\n\t\t\t}\n\t\t\tgf_free(co64->offsets);\n\t\t\tco64->offsets = newLarge;\n\t\t\tco64->nb_entries++;\n\t\t\tco64->alloc_size++;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_SetChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u64 offset)\n{\n\tGF_StscEntry *ent;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_SampleTableBox *stbl = mdia->information->sampleTable;\n\n\tif (!sampleNumber || !stbl) return GF_BAD_PARAM;\n\n\tent = &stbl->SampleToChunk->entries[sampleNumber - 1];\n\n\t//we edit our entry if self contained\n\tif (Media_IsSelfContained(mdia, ent->sampleDescriptionIndex))\n\t\tent->isEdited = 1;\n\n\t//and we change our offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t//if the new offset is a large one, we have to rewrite our table...\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = ((GF_ChunkOffsetBox *)stbl->ChunkOffset)->nb_entries;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64)*co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<co64->nb_entries; i++) {\n\t\t\t\tco64->offsets[i] = (u64) ((GF_ChunkOffsetBox *)stbl->ChunkOffset)->offsets[i];\n\t\t\t}\n\t\t\tco64->offsets[ent->firstChunk - 1] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t((GF_ChunkOffsetBox *)stbl->ChunkOffset)->offsets[ent->firstChunk - 1] = (u32) offset;\n\t} else {\n\t\t((GF_ChunkLargeOffsetBox *)stbl->ChunkOffset)->offsets[ent->firstChunk - 1] = offset;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_SetSampleCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset)\n{\n\tGF_CompositionOffsetBox *ctts = stbl->CompositionOffset;\n\n\tassert(ctts->unpack_mode);\n\n\t//if we're setting the CTS of a sample we've skipped...\n\tif (ctts->w_LastSampleNumber < sampleNumber) {\n\t\t//add some 0 till we get to the sample\n\t\twhile (ctts->w_LastSampleNumber + 1 != sampleNumber) {\n\t\t\tGF_Err e = AddCompositionOffset(ctts, 0);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn AddCompositionOffset(ctts, offset);\n\t}\n\tif (offset<0) ctts->version=1;\n\tctts->entries[sampleNumber-1].decodingOffset = offset;\n\treturn GF_OK;\n}\n\nGF_Err stbl_SetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 size)\n{\n\tu32 i;\n\tif (!SampleNumber || (stsz->sampleCount < SampleNumber)) return GF_BAD_PARAM;\n\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sampleSize == size) return GF_OK;\n\t\tif (stsz->sampleCount == 1) {\n\t\t\tstsz->sampleSize = size;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//nope, we have to rewrite a table\n\t\tstsz->sizes = (u32*)gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<stsz->sampleCount; i++) stsz->sizes[i] = stsz->sampleSize;\n\t\tstsz->sampleSize = 0;\n\t}\n\tstsz->sizes[SampleNumber - 1] = size;\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_SetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, u8 isRAP)\n{\n\tu32 i;\n\n\t//check if we have already a sync sample\n\tfor (i = 0; i < stss->nb_entries; i++) {\n\n\t\tif (stss->sampleNumbers[i] < SampleNumber) continue;\n\t\telse if (stss->sampleNumbers[i] > SampleNumber) break;\n\n\t\t/*found our sample number*/\n\t\tif (isRAP) return GF_OK;\n\t\t/*remove it...*/\n\t\tif (i+1 < stss->nb_entries)\n\t\t\tmemmove(stss->sampleNumbers + i, stss->sampleNumbers + i + 1, sizeof(u32) * (stss->nb_entries - i - 1));\n\t\tstss->nb_entries--;\n\t\treturn GF_OK;\n\t}\n\t//we need to insert a RAP somewhere if RAP ...\n\tif (!isRAP) return GF_OK;\n\tif (stss->nb_entries==stss->alloc_size) {\n\t\tALLOC_INC(stss->alloc_size);\n\t\tstss->sampleNumbers = gf_realloc(stss->sampleNumbers, sizeof(u32)*stss->alloc_size);\n\t\tif (!stss->sampleNumbers) return GF_OUT_OF_MEM;\n\t\tmemset(&stss->sampleNumbers[stss->nb_entries], 0, sizeof(u32)*(stss->alloc_size - stss->nb_entries) );\n\t}\n\n\tif (i+1 < stss->nb_entries)\n\t\tmemmove(stss->sampleNumbers + i + 1, stss->sampleNumbers + i, sizeof(u32) * (stss->nb_entries - i - 1));\n\tstss->sampleNumbers[i] = SampleNumber;\n\tstss->nb_entries ++;\n\treturn GF_OK;\n}\n\nGF_Err stbl_SetRedundant(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tif (stbl->SampleDep->sampleCount < sampleNumber) {\n\t\treturn stbl_AddRedundant(stbl, sampleNumber);\n\t} else {\n\t\tstbl->SampleDep->sample_info[sampleNumber-1] = 0x29;\n\t\treturn GF_OK;\n\t}\n}\n\nGF_Err stbl_SetSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 syncSample)\n{\n\tu32 i, count;\n\tGF_StshEntry *ent;\n\n\tcount = gf_list_count(stsh->entries);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i);\n\t\tif (ent->shadowedSampleNumber == sampleNumber) {\n\t\t\tent->syncSampleNumber = syncSample;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ent->shadowedSampleNumber > sampleNumber) break;\n\t}\n\t//we need a new one...\n\tent = (GF_StshEntry*)gf_malloc(sizeof(GF_StshEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->shadowedSampleNumber = sampleNumber;\n\tent->syncSampleNumber = syncSample;\n\t//insert or append ?\n\tif (i == gf_list_count(stsh->entries)) {\n\t\t//don't update the cache ...\n\t\treturn gf_list_add(stsh->entries, ent);\n\t} else {\n\t\t//update the cache\n\t\tstsh->r_LastEntryIndex = i;\n\t\tstsh->r_LastFoundSample = sampleNumber;\n\t\treturn gf_list_insert(stsh->entries, ent, i);\n\t}\n}\n\n\n//always called before removing the sample from SampleSize\nGF_Err stbl_RemoveDTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples, u32 LastAUDefDuration)\n{\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\n\tif ((nb_samples>1) && (sampleNumber>1)) return GF_BAD_PARAM;\n\n\tstts = stbl->TimeToSample;\n\n\t//we're removing the only sample: empty the sample table\n\tif (stbl->SampleSize->sampleCount == 1) {\n\t\tstts->nb_entries = 0;\n\t\tstts->r_FirstSampleInEntry = stts->r_currentEntryIndex = 0;\n\t\tstts->r_CurrentDTS = 0;\n\t\treturn GF_OK;\n\t}\n\t//we're removing the last sample\n\tif ((nb_samples==1) && (sampleNumber == stbl->SampleSize->sampleCount)) {\n\t\tent = &stts->entries[stts->nb_entries-1];\n\t\tent->sampleCount--;\n\t\tif (!ent->sampleCount) stts->nb_entries--;\n\t} else {\n\t\tu64 *DTSs, curDTS;\n\t\tu32 i, j, k, sampNum;\n\t\tu32 tot_samples, nb_written=0;\n\t\t//unpack the DTSs...\n\t\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount - 1));\n\t\tif (!DTSs) return GF_OUT_OF_MEM;\n\t\tmemset(DTSs, 0, sizeof(u64) * (stbl->SampleSize->sampleCount - 1) );\n\n\t\tcurDTS = 0;\n\t\tsampNum = 0;\n\t\tent = NULL;\n\t\tk=0;\n\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = & stts->entries[i];\n\t\t\tfor (j=0; j<ent->sampleCount; j++) {\n\t\t\t\tif (nb_samples==1) {\n\t\t\t\t\tif (sampNum == sampleNumber - 1) {\n\t\t\t\t\t\tk=1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDTSs[sampNum-k] = curDTS;\n\t\t\t\t\t}\n\t\t\t\t} else if (sampNum >= nb_samples) {\n\t\t\t\t\tDTSs[sampNum - nb_samples] = curDTS;\n\t\t\t\t\tnb_written++;\n\t\t\t\t}\n\t\t\t\tcurDTS += ent->sampleDelta;\n\t\t\t\tsampNum ++;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_samples>1) {\n\t\t\tassert(sampNum == stbl->SampleSize->sampleCount);\n\t\t\tassert(nb_written + nb_samples == stbl->SampleSize->sampleCount);\n\t\t}\n\t\tj=0;\n\n\t\tif (nb_samples==1) {\n\t\t\ttot_samples = stbl->SampleSize->sampleCount - 1;\n\t\t} else {\n\t\t\ttot_samples = stbl->SampleSize->sampleCount - nb_samples;\n\t\t}\n\t\tif (tot_samples) {\n\t\t\tsampNum = 1;\n\t\t\tstts->nb_entries = 1;\n\t\t\tstts->entries[0].sampleCount = 1;\n\t\t\tif (stbl->SampleSize->sampleCount == 2) {\n\t\t\t\tstts->entries[0].sampleDelta = LastAUDefDuration;\n\t\t\t} else {\n\t\t\t\tstts->entries[0].sampleDelta = (u32) DTSs[1] /*- DTSs[0]*/;\n\t\t\t}\n\t\t} else {\n\t\t\tsampNum = 0;\n\t\t\tstts->nb_entries = 0;\n\t\t}\n\n\t\tfor (i=1; i<tot_samples; i++) {\n\t\t\tif (i+1 == tot_samples) {\n\t\t\t\t//and by default, our last sample has the same delta as the prev\n\t\t\t\tstts->entries[j].sampleCount++;\n\t\t\t\tsampNum ++;\n\t\t\t} else if (DTSs[i+1] - DTSs[i] == stts->entries[j].sampleDelta) {\n\t\t\t\tstts->entries[j].sampleCount += 1;\n\t\t\t\tsampNum ++;\n\t\t\t} else {\n\t\t\t\tstts->nb_entries++;\n\t\t\t\tif (j+1==stts->alloc_size) {\n\t\t\t\t\tstts->alloc_size++;\n\t\t\t\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry) * stts->alloc_size);\n\t\t\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tstts->entries[j].sampleCount = 1;\n\t\t\t\tstts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);\n\t\t\t\tassert(stts->entries[j].sampleDelta);\n\t\t\t\tsampNum ++;\n\t\t\t}\n\t\t}\n\t\tstts->w_LastDTS = tot_samples ? DTSs[tot_samples - 1] : 0;\n\t\tgf_free(DTSs);\n\t\tassert(sampNum == tot_samples);\n\t\tassert(sampNum + nb_samples == stbl->SampleSize->sampleCount);\n\t}\n\n\t//reset write the cache to the end\n\tstts->w_currentSampleNum = stbl->SampleSize->sampleCount - nb_samples;\n\t//reset read the cache to the beginning\n\tstts->r_FirstSampleInEntry = stts->r_currentEntryIndex = 0;\n\tstts->r_CurrentDTS = 0;\n\treturn GF_OK;\n}\n\n\n//always called before removing the sample from SampleSize\nGF_Err stbl_RemoveCTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples)\n{\n\tGF_CompositionOffsetBox *ctts = stbl->CompositionOffset;\n\tif (!ctts) return GF_OK;\n\n\tassert(ctts->unpack_mode);\n\tif ((nb_samples>1) && (sampleNumber>1)) return GF_BAD_PARAM;\n\n\t//last one...\n\tif (stbl->SampleSize->sampleCount == 1) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) ctts);\n\t\tstbl->CompositionOffset = NULL;\n\t\treturn GF_OK;\n\t}\n\n\t//the number of entries is NOT ALWAYS the number of samples !\n\t//instead, use the cache\n\t//first case, we're removing a sample that was not added yet\n\tif (sampleNumber > ctts->w_LastSampleNumber) return GF_OK;\n\n\tif (nb_samples==1) {\n\t\tassert(ctts->nb_entries);\n\t\tmemmove(&ctts->entries[sampleNumber-1], &ctts->entries[sampleNumber], sizeof(GF_DttsEntry)* (ctts->nb_entries-sampleNumber) );\n\t\tctts->nb_entries--;\n\t} else {\n\t\tmemmove(&ctts->entries[0], &ctts->entries[nb_samples], sizeof(GF_DttsEntry)* (ctts->nb_entries-nb_samples) );\n\t\tctts->nb_entries -= nb_samples;\n\t}\n\tctts->w_LastSampleNumber -= nb_samples;\n\tassert(ctts->w_LastSampleNumber >= ctts->nb_entries);\n\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveSize(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples)\n{\n\tGF_SampleSizeBox *stsz = stbl->SampleSize;\n\n\tif ((nb_samples>1) && (sampleNumber>1)) return GF_BAD_PARAM;\n\t//last sample\n\tif (stsz->sampleCount == 1) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = NULL;\n\t\tstsz->sampleCount = 0;\n\t\treturn GF_OK;\n\t}\n\t//one single size\n\tif (stsz->sampleSize) {\n\t\tstsz->sampleCount -= nb_samples;\n\t\treturn GF_OK;\n\t}\n\tif (nb_samples==1) {\n\t\tif (sampleNumber < stsz->sampleCount)\n\t\t\tmemmove(stsz->sizes + sampleNumber - 1, stsz->sizes + sampleNumber, sizeof(u32) * (stsz->sampleCount - sampleNumber));\n\t} else {\n\t\tif (nb_samples < stsz->sampleCount)\n\t\t\tmemmove(stsz->sizes, stsz->sizes + nb_samples, sizeof(u32) * (stsz->sampleCount - nb_samples));\n\t}\n\tstsz->sampleCount -= nb_samples;\n\treturn GF_OK;\n}\n\n//always called after removing the sample from SampleSize\nGF_Err stbl_RemoveChunk(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *stsc = stbl->SampleToChunk;\n\n\tif ((nb_samples>1) && (sampleNumber>1))\n\t\treturn GF_BAD_PARAM;\n\t\n\t//raw audio or constant sample size and dur\n\tif (stsc->nb_entries < stbl->SampleSize->sampleCount) {\n\t\tif (sampleNumber==stbl->SampleSize->sampleCount+1) {\n\t\t\tGF_StscEntry *ent = &stsc->entries[stsc->nb_entries-1];\n\t\t\tif (ent->samplesPerChunk)\n\t\t\t\tent->samplesPerChunk--;\n\t\t\tif (!ent->samplesPerChunk) {\n\t\t\t\tstsc->nb_entries--;\n\n\t\t\t\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\t\t\t((GF_ChunkOffsetBox *)stbl->ChunkOffset)->nb_entries --;\n\t\t\t\t} else {\n\t\t\t\t\t((GF_ChunkLargeOffsetBox *)stbl->ChunkOffset)->nb_entries --;\n\t\t\t\t}\n\t\t\t\tif (stsc->nb_entries) {\n\t\t\t\t\tent = &stsc->entries[stsc->nb_entries-1];\n\t\t\t\t\tent->nextChunk --;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] removing sample in middle of track not supported for constant size and duration samples\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\t//remove the entry in SampleToChunk (1 <-> 1 in edit mode)\n\tif (nb_samples==1) {\n\t\tmemmove(&stsc->entries[sampleNumber-1], &stsc->entries[sampleNumber], sizeof(GF_StscEntry)*(stsc->nb_entries-sampleNumber));\n\t\tstsc->nb_entries--;\n\n\t\t//update the firstchunk info\n\t\tfor (i=sampleNumber-1; i < stsc->nb_entries; i++) {\n\t\t\tassert(stsc->entries[i].firstChunk >= 1);\n\t\t\tstsc->entries[i].firstChunk -= 1;\n\t\t\tif (stsc->entries[i].nextChunk) {\n\t\t\t\tassert(stsc->entries[i].nextChunk >= 1);\n\t\t\t\tstsc->entries[i].nextChunk -= 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmemmove(&stsc->entries[0], &stsc->entries[nb_samples], sizeof(GF_StscEntry)*(stsc->nb_entries-nb_samples));\n\t\tstsc->nb_entries -= nb_samples;\n\n\t\t//update the firstchunk info\n\t\tfor (i=0; i < stsc->nb_entries; i++) {\n\t\t\tstsc->entries[i].firstChunk = i+1;\n\t\t\tstsc->entries[i].nextChunk = (stsc->nb_entries==i+1) ? 0 : i+2;\n\t\t}\n\t}\n\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size - stsc->nb_entries) );\n\n\t//update the cache\n\tstsc->firstSampleInCurrentChunk = 1;\n\tstsc->currentIndex = 0;\n\tstsc->currentChunk = 1;\n\tstsc->ghostNumber = 1;\n\n\t//realloc the chunk offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (!stbl->SampleSize->sampleCount) {\n\t\t\tgf_free(stco->offsets);\n\t\t\tstco->offsets = NULL;\n\t\t\tstco->nb_entries = 0;\n\t\t\tstco->alloc_size = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tassert(stco->nb_entries - nb_samples == stbl->SampleSize->sampleCount);\n\t\tif (nb_samples==1) {\n\t\t\tmemmove(&stco->offsets[sampleNumber-1], &stco->offsets[sampleNumber], sizeof(u32) * (stco->nb_entries - sampleNumber) );\n\t\t} else {\n\t\t\tmemmove(&stco->offsets[0], &stco->offsets[nb_samples], sizeof(u32) * (stco->nb_entries - nb_samples) );\n\t\t}\n\t\tstco->nb_entries -= nb_samples;\n\t} else {\n\t\tGF_ChunkLargeOffsetBox *co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (!stbl->SampleSize->sampleCount) {\n\t\t\tgf_free(co64->offsets);\n\t\t\tco64->offsets = NULL;\n\t\t\tco64->nb_entries = 0;\n\t\t\tco64->alloc_size = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tassert(co64->nb_entries - nb_samples == stbl->SampleSize->sampleCount);\n\t\tif (nb_samples==1) {\n\t\t\tmemmove(&co64->offsets[sampleNumber-1], &co64->offsets[sampleNumber], sizeof(u64) * (co64->nb_entries - sampleNumber) );\n\t\t} else {\n\t\t\tmemmove(&co64->offsets[0], &co64->offsets[nb_samples], sizeof(u64) * (co64->nb_entries - nb_samples) );\n\t\t}\n\t\tco64->nb_entries -= nb_samples;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_RemoveRAP(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tu32 i;\n\n\tGF_SyncSampleBox *stss = stbl->SyncSample;\n\tif (!stss) return GF_OK;\n\n\t//we remove the only one around...\n\tif (stss->nb_entries == 1) {\n\t\tif (stss->sampleNumbers[0] != sampleNumber) return GF_OK;\n\t\t//free our numbers but don't delete (all samples are NON-sync\n\t\tgf_free(stss->sampleNumbers);\n\t\tstss->sampleNumbers = NULL;\n\t\tstss->r_LastSampleIndex = stss->r_LastSyncSample = 0;\n\t\tstss->alloc_size = stss->nb_entries = 0;\n\t\treturn GF_OK;\n\t}\n\n\tfor (i=0; i<stss->nb_entries; i++) {\n\t\t//found the sample\n\t\tif (sampleNumber == stss->sampleNumbers[i]) {\n\t\t\tmemmove(&stss->sampleNumbers[i], &stss->sampleNumbers[i+1], sizeof(u32)* (stss->nb_entries-i-1) );\n\t\t\tstss->nb_entries--;\n\t\t}\n\n\t\tif (sampleNumber < stss->sampleNumbers[i]) {\n\t\t\tassert(stss->sampleNumbers[i]);\n\t\t\tstss->sampleNumbers[i]--;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveRedundant(GF_SampleTableBox *stbl, u32 SampleNumber, u32 nb_samples)\n{\n\tu32 i;\n\n\tif (!stbl->SampleDep) return GF_OK;\n\tif (stbl->SampleDep->sampleCount < SampleNumber) return GF_BAD_PARAM;\n\tif ((nb_samples>1) && (SampleNumber>1)) return GF_BAD_PARAM;\n\n\tif (nb_samples==1) {\n\t\ti = stbl->SampleDep->sampleCount - SampleNumber;\n\t\tif (i) memmove(&stbl->SampleDep->sample_info[SampleNumber-1], & stbl->SampleDep->sample_info[SampleNumber], sizeof(u8)*i);\n\t\tstbl->SampleDep->sample_info = (u8*)gf_realloc(stbl->SampleDep->sample_info, sizeof(u8) * (stbl->SampleDep->sampleCount-1));\n\t\tif (!stbl->SampleDep->sample_info) return GF_OUT_OF_MEM;\n\t\tstbl->SampleDep->sample_alloc = stbl->SampleDep->sampleCount-1;\n\t\tstbl->SampleDep->sampleCount-=1;\n\t} else {\n\t\tmemmove(&stbl->SampleDep->sample_info[0], &stbl->SampleDep->sample_info[nb_samples], sizeof(u8) * (stbl->SampleDep->sampleCount - nb_samples) );\n\t\tstbl->SampleDep->sampleCount -= nb_samples;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveShadow(GF_SampleTableBox *stbl, u32 sampleNumber)\n{\n\tu32 i;\n\tGF_ShadowSyncBox *stsh;\n\tGF_StshEntry *ent;\n\tif (!stbl->ShadowSync) return GF_OK;\n\tstsh = stbl->ShadowSync;\n\n\t//we loop for the whole chain cause the spec doesn't say if we can have several\n\t//shadows for 1 sample...\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(stsh->entries, &i))) {\n\t\tif (ent->shadowedSampleNumber == sampleNumber) {\n\t\t\ti--;\n\t\t\tgf_list_rem(stsh->entries, i);\n\t\t}\n\t}\n\t//reset the cache\n\tstsh->r_LastEntryIndex = 0;\n\tstsh->r_LastFoundSample = 0;\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_SetPaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber, u8 bits)\n{\n\tu8 *p;\n\t//make sure the sample is a good one\n\tif (SampleNumber > stbl->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//create the table\n\tif (!stbl->PaddingBits) {\n\t\tstbl->PaddingBits = (GF_PaddingBitsBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_PADB);\n\t\tif (!stbl->PaddingBits) return GF_OUT_OF_MEM;\n\t}\n\n\t//alloc\n\tif (!stbl->PaddingBits->padbits || !stbl->PaddingBits->SampleCount) {\n\t\tstbl->PaddingBits->SampleCount = stbl->SampleSize->sampleCount;\n\t\tstbl->PaddingBits->padbits = (u8*)gf_malloc(sizeof(u8)*stbl->PaddingBits->SampleCount);\n\t\tif (!stbl->PaddingBits->padbits) return GF_OUT_OF_MEM;\n\t\tmemset(stbl->PaddingBits->padbits, 0, sizeof(u8)*stbl->PaddingBits->SampleCount);\n\t}\n\t//realloc (this is needed in case n out of k samples get padding added)\n\tif (stbl->PaddingBits->SampleCount < stbl->SampleSize->sampleCount) {\n\t\tp = (u8*)gf_malloc(sizeof(u8) * stbl->SampleSize->sampleCount);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\t//set everything to 0\n\t\tmemset(p, 0, stbl->SampleSize->sampleCount);\n\t\t//copy our previous table\n\t\tmemcpy(p, stbl->PaddingBits->padbits, stbl->PaddingBits->SampleCount);\n\t\tgf_free(stbl->PaddingBits->padbits);\n\t\tstbl->PaddingBits->padbits = p;\n\t\tstbl->PaddingBits->SampleCount = stbl->SampleSize->sampleCount;\n\t}\n\tstbl->PaddingBits->padbits[SampleNumber-1] = bits;\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemovePaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber)\n{\n\tu8 *p;\n\tu32 i, k;\n\n\tif (!stbl->PaddingBits) return GF_OK;\n\tif (stbl->PaddingBits->SampleCount < SampleNumber) return GF_BAD_PARAM;\n\n\t//last sample - remove the table\n\tif (stbl->PaddingBits->SampleCount == 1) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->PaddingBits);\n\t\tstbl->PaddingBits = NULL;\n\t\treturn GF_OK;\n\t}\n\n\t//reallocate and check size by the way...\n\tp = (u8 *)gf_malloc(sizeof(u8) * (stbl->PaddingBits->SampleCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\n\tk=0;\n\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\tif (i+1 != SampleNumber) {\n\t\t\tp[k] = stbl->PaddingBits->padbits[i];\n\t\t\tk++;\n\t\t}\n\t}\n\n\tstbl->PaddingBits->SampleCount -= 1;\n\tgf_free(stbl->PaddingBits->padbits);\n\tstbl->PaddingBits->padbits = p;\n\treturn GF_OK;\n}\n\nGF_Err stbl_RemoveSubSample(GF_SampleTableBox *stbl, u32 SampleNumber)\n{\n\tu32 i, count, j, subs_count, prev_sample, delta=0;\n\n\tif (! stbl->sub_samples) return GF_OK;\n\tsubs_count = gf_list_count(stbl->sub_samples);\n\tfor (j=0; j<subs_count; j++) {\n\t\tGF_SubSampleInformationBox *subs = gf_list_get(stbl->sub_samples, j);\n\t\tif (! subs->Samples) continue;\n\n\t\tprev_sample = 0;\n\t\tcount = gf_list_count(subs->Samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleInfoEntry *e = gf_list_get(subs->Samples, i);\n\t\t\tprev_sample += e->sample_delta;\n\t\t\tif (prev_sample==SampleNumber) {\n\t\t\t\tgf_list_rem(subs->Samples, i);\n\t\t\t\twhile (gf_list_count(e->SubSamples)) {\n\t\t\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_list_get(e->SubSamples, 0);\n\t\t\t\t\tgf_free(pSubSamp);\n\t\t\t\t\tgf_list_rem(e->SubSamples, 0);\n\t\t\t\t}\n\t\t\t\tgf_list_del(e->SubSamples);\n\t\t\t\tgf_free(e);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tdelta=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te->sample_delta+=delta;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_RemoveSampleGroup(GF_SampleTableBox *stbl, u32 SampleNumber)\n{\n\tu32 i, k, count, prev_sample;\n\n\tif (!stbl->sampleGroups) return GF_OK;\n\n\tcount = gf_list_count(stbl->sampleGroups);\n\tprev_sample = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *e = gf_list_get(stbl->sampleGroups, i);\n\t\tfor (k=0; k<e->entry_count; k++) {\n\t\t\tif ((SampleNumber>prev_sample) && (SampleNumber <= prev_sample + e->sample_entries[k].sample_count) ) {\n\t\t\t\te->sample_entries[k].sample_count--;\n\t\t\t\tif (!e->sample_entries[k].sample_count) {\n\t\t\t\t\tmemmove(&e->sample_entries[k], &e->sample_entries[k+1], sizeof(GF_SampleGroupEntry) * (e->entry_count-k-1));\n\t\t\t\t\te->entry_count--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!e->entry_count) {\n\t\t\tgf_list_rem(stbl->sampleGroups, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) e);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_SampleSizeAppend(GF_SampleSizeBox *stsz, u32 data_size)\n{\n\tu32 i;\n\tif (!stsz || !stsz->sampleCount) return GF_BAD_PARAM;\n\n\t//we must realloc our table\n\tif (stsz->sampleSize) {\n\t\tstsz->sizes = (u32*)gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<stsz->sampleCount; i++) stsz->sizes[i] = stsz->sampleSize;\n\t\tstsz->sampleSize = 0;\n\t}\n\tif (!stsz->sizes) {\n\t\tstsz->sampleSize = data_size;\n\t} else {\n\t\tu32 single_size;\n\t\tstsz->sizes[stsz->sampleCount-1] += data_size;\n\n\t\tsingle_size = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (stsz->sizes[i] != single_size) {\n\t\t\t\tsingle_size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (single_size) {\n\t\t\tstsz->sampleSize = single_size;\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\tCHECK_PACK(GF_ISOM_INVALID_FILE)\n\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tCHECK_PACK(GF_ISOM_INVALID_FILE)\n\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size) {\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\t}\n\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}\n\n\n\nGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tu32 i;\n\t\n\t//we may have to convert the table...\n\tif (stbl->ChunkOffset->type==GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\n\t\tif (offset>0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tif (co64->nb_entries<=stco->nb_entries) return GF_OUT_OF_MEM;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<stco->nb_entries; i++) co64->offsets[i] = stco->offsets[i];\n\t\t\tco64->offsets[i] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we're fine\n\t\tstco->alloc_size = stco->nb_entries + 1;\n\t\tif (stco->alloc_size < stco->nb_entries + 1) return GF_OUT_OF_MEM;\n\t\tstco->offsets = gf_realloc(stco->offsets, sizeof(u32)*stco->alloc_size);\n\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\tstco->nb_entries += 1;\n\t\treturn GF_OK;\n\t}\n\n\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\tco64->alloc_size = co64->nb_entries+1;\n\tif (co64->alloc_size < co64->nb_entries + 1) return GF_OUT_OF_MEM;\n\n\tco64->offsets = gf_realloc(co64->offsets, sizeof(u64)*co64->alloc_size);\n\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\tco64->offsets[co64->nb_entries] = offset;\n\tco64->alloc_size = co64->nb_entries;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk)\n{\n\tu32 nextChunk;\n\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\tGF_StscEntry *ent;\n\n\tnextChunk = ((GF_ChunkOffsetBox *) stbl->ChunkOffset)->nb_entries;\n\n\tif (stsc->nb_entries) {\n\t\tent = &stsc->entries[stsc->nb_entries-1];\n\t\t//good we can use this one\n\t\tif ( (ent->sampleDescriptionIndex == DescIndex) && (ent->samplesPerChunk==samplesInChunk))\n\t\t\treturn GF_OK;\n\n\t\t//set the next chunk btw ...\n\t\tent->nextChunk = nextChunk;\n\t}\n\tif (stsc->nb_entries==stsc->alloc_size) {\n\t\tALLOC_INC(stsc->alloc_size);\n\t\tstsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);\n\t\tif (!stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size - stsc->nb_entries) );\n\t}\n\t//ok we need a new entry - this assumes this function is called AFTER AppendChunk\n\tent = &stsc->entries[stsc->nb_entries];\n\tent->firstChunk = nextChunk;\n\tent->sampleDescriptionIndex = DescIndex;\n\tent->samplesPerChunk = samplesInChunk;\n\tent->isEdited = 0;\n\tstsc->nb_entries++;\n\treturn GF_OK;\n}\n\n//called AFTER AddSize\nGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap)\n{\n\tu32 i;\n\n\t//no sync table\n\tif (!stbl->SyncSample) {\n\t\t//all samples RAP - no table\n\t\tif (isRap) return GF_OK;\n\n\t\t//nope, create one\n\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\tstbl->SyncSample->sampleNumbers = (u32*)gf_malloc(sizeof(u32) * (stbl->SampleSize->sampleCount-1));\n\t\t\tif (!stbl->SyncSample->sampleNumbers) return GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount-1; i++)\n\t\t\t\tstbl->SyncSample->sampleNumbers[i] = i+1;\n\n\t\t}\n\t\tstbl->SyncSample->nb_entries = stbl->SampleSize->sampleCount-1;\n\t\tstbl->SyncSample->alloc_size = stbl->SyncSample->nb_entries;\n\t\treturn GF_OK;\n\t}\n\tif (!isRap) return GF_OK;\n\n\tif (stbl->SyncSample->alloc_size == stbl->SyncSample->nb_entries) {\n\t\tALLOC_INC(stbl->SyncSample->alloc_size);\n\t\tstbl->SyncSample->sampleNumbers = (u32*) gf_realloc(stbl->SyncSample->sampleNumbers, sizeof(u32) * stbl->SyncSample->alloc_size);\n\t\tif (!stbl->SyncSample->sampleNumbers) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SyncSample->sampleNumbers[stbl->SyncSample->nb_entries], 0, sizeof(u32) * (stbl->SyncSample->alloc_size-stbl->SyncSample->nb_entries) );\n\t}\n\tstbl->SyncSample->sampleNumbers[stbl->SyncSample->nb_entries] = stbl->SampleSize->sampleCount;\n\tstbl->SyncSample->nb_entries += 1;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendTrafMap(GF_SampleTableBox *stbl, Bool is_seg_start, u64 seg_start_offset, u64 frag_start_offset, u8 *moof_template, u32 moof_template_size, u64 sidx_start, u64 sidx_end)\n{\n\tGF_TrafToSampleMap *tmap;\n\tGF_TrafMapEntry *tmap_ent;\n\tif (!stbl->traf_map) {\n\t\t//nope, create one\n\t\tGF_SAFEALLOC(stbl->traf_map, GF_TrafToSampleMap);\n\t\tif (!stbl->traf_map) return GF_OUT_OF_MEM;\n\t}\n\ttmap = stbl->traf_map;\n\tif (tmap->nb_entries >= stbl->SampleSize->sampleCount) {\n\t\tu32 i;\n\t\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\t\tif (tmap->frag_starts[i].moof_template)\n\t\t\t\tgf_free(tmap->frag_starts[i].moof_template);\n\t\t}\n\t\tmemset(tmap->frag_starts, 0, sizeof(GF_TrafMapEntry)*tmap->nb_alloc);\n\t\ttmap->nb_entries = 0;\n\t}\n\n\tif (tmap->nb_entries + 1 > tmap->nb_alloc) {\n\t\ttmap->nb_alloc++;\n\t\ttmap->frag_starts = gf_realloc(tmap->frag_starts, sizeof(GF_TrafMapEntry) * tmap->nb_alloc);\n\t\tif (!tmap->frag_starts) return GF_OUT_OF_MEM;\n\t}\n\ttmap_ent = &tmap->frag_starts[tmap->nb_entries];\n\ttmap->nb_entries += 1;\n\n\tmemset(tmap_ent, 0, sizeof(GF_TrafMapEntry));\n\ttmap_ent->sample_num = stbl->SampleSize->sampleCount;\n\ttmap_ent->moof_template = moof_template;\n\ttmap_ent->moof_template_size = moof_template_size;\n\ttmap_ent->moof_start = frag_start_offset;\n\ttmap_ent->sidx_start = sidx_start;\n\ttmap_ent->sidx_end = sidx_end;\n\tif (is_seg_start)\n\t\ttmap_ent->seg_start_plus_one = 1 + seg_start_offset;\n\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding)\n{\n\tif (!stbl->PaddingBits) {\n\t\tstbl->PaddingBits = (GF_PaddingBitsBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_PADB);\n\t\tif (!stbl->PaddingBits) return GF_OUT_OF_MEM;\n\t}\n\tstbl->PaddingBits->padbits = (u8*)gf_realloc(stbl->PaddingBits->padbits, sizeof(u8) * stbl->SampleSize->sampleCount);\n\tif (!stbl->PaddingBits->padbits) return GF_OUT_OF_MEM;\n\tstbl->PaddingBits->padbits[stbl->SampleSize->sampleCount-1] = padding;\n\tstbl->PaddingBits->SampleCount = stbl->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 offset)\n{\n\tGF_CompositionOffsetBox *ctts;\n\n\tif (!stbl->CompositionOffset) {\n\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t}\n\tctts = stbl->CompositionOffset;\n\tctts->w_LastSampleNumber ++;\n\n\tif (!ctts->unpack_mode && ctts->nb_entries && (ctts->entries[ctts->nb_entries-1].decodingOffset == offset) ) {\n\t\tctts->entries[ctts->nb_entries-1].sampleCount++;\n\t\treturn GF_OK;\n\t}\n\tif (ctts->nb_entries==ctts->alloc_size) {\n\t\tALLOC_INC(ctts->alloc_size);\n\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t}\n\tctts->entries[ctts->nb_entries].decodingOffset = offset;\n\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\tctts->nb_entries++;\n\tif (offset<0) ctts->version=1;\n\n\tif (ABS(offset) > ctts->max_ts_delta) ctts->max_ts_delta = ABS(offset);\n\n\treturn GF_OK;\n}\n\nGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority)\n{\n\tif (!stbl->DegradationPriority) {\n\t\tstbl->DegradationPriority = (GF_DegradationPriorityBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STDP);\n\t\tif (!stbl->DegradationPriority) return GF_OUT_OF_MEM;\n\t}\n\n\tstbl->DegradationPriority->priorities = (u16 *)gf_realloc(stbl->DegradationPriority->priorities, sizeof(u16) * stbl->SampleSize->sampleCount);\n\tif (!stbl->DegradationPriority->priorities) return GF_OUT_OF_MEM;\n\tstbl->DegradationPriority->priorities[stbl->SampleSize->sampleCount-1] = DegradationPriority;\n\tstbl->DegradationPriority->nb_entries = stbl->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err stbl_AppendDepType(GF_SampleTableBox *stbl, u32 DepType)\n{\n\tif (!stbl->SampleDep) {\n\t\tstbl->SampleDep = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\tif (!stbl->SampleDep) return GF_OUT_OF_MEM;\n\t}\n\tstbl->SampleDep->sample_info = (u8*)gf_realloc(stbl->SampleDep->sample_info, sizeof(u8)*stbl->SampleSize->sampleCount );\n\tif (!stbl->SampleDep->sample_info) return GF_OUT_OF_MEM;\n\tstbl->SampleDep->sample_alloc = stbl->SampleSize->sampleCount;\n\tstbl->SampleDep->sample_info[stbl->SampleDep->sampleCount] = DepType;\n\tstbl->SampleDep->sampleCount = stbl->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n#endif\n\n\n\n\n//This functions unpack the offset for easy editing, eg each sample\n//is contained in one chunk...\nGF_Err stbl_UnpackOffsets(GF_SampleTableBox *stbl)\n{\n\tGF_Err e;\n\tu32 i, chunkNumber, sampleDescIndex;\n\tu64 dataOffset;\n\tGF_StscEntry *ent;\n\tGF_ChunkOffsetBox *stco_tmp;\n\tGF_ChunkLargeOffsetBox *co64_tmp;\n\tGF_SampleToChunkBox *stsc_tmp;\n\n\tif (!stbl) return GF_ISOM_INVALID_FILE;\n\n\t//we should have none of the mandatory boxes (allowed in the spec)\n\tif (!stbl->ChunkOffset && !stbl->SampleDescription && !stbl->SampleSize && !stbl->SampleToChunk && !stbl->TimeToSample)\n\t\treturn GF_OK;\n\t/*empty track (just created)*/\n\tif (!stbl->SampleToChunk && !stbl->TimeToSample) return GF_OK;\n\n\t//or all the mandatory ones ...\n\tif (!stbl->ChunkOffset || !stbl->SampleDescription || !stbl->SampleSize || !stbl->SampleToChunk || !stbl->TimeToSample)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//do we need to unpack? Not if we have only one sample per chunk.\n\tif (stbl->SampleSize->sampleCount == stbl->SampleToChunk->nb_entries) return GF_OK;\n\n\t//check the offset type and create a new table...\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tco64_tmp = NULL;\n\t\tstco_tmp = (GF_ChunkOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\tif (!stco_tmp) return GF_OUT_OF_MEM;\n\t\tstco_tmp->nb_entries = stbl->SampleSize->sampleCount;\n\t\tstco_tmp->offsets = (u32*)gf_malloc(stco_tmp->nb_entries * sizeof(u32));\n\t\tif (!stco_tmp->offsets) {\n\t\t\tgf_isom_box_del((GF_Box*)stco_tmp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tstco_tmp->alloc_size = stco_tmp->nb_entries;\n\t} else if (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tstco_tmp = NULL;\n\t\tco64_tmp = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\tif (!co64_tmp) return GF_OUT_OF_MEM;\n\t\tco64_tmp->nb_entries = stbl->SampleSize->sampleCount;\n\t\tco64_tmp->offsets = (u64*)gf_malloc(co64_tmp->nb_entries * sizeof(u64));\n\t\tif (!co64_tmp->offsets) {\n\t\t\tgf_isom_box_del((GF_Box*)co64_tmp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tco64_tmp->alloc_size = co64_tmp->nb_entries;\n\t} else {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//create a new SampleToChunk table\n\tstsc_tmp = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\tif (!stsc_tmp) return GF_OUT_OF_MEM;\n\n\tstsc_tmp->nb_entries = stsc_tmp->alloc_size = stbl->SampleSize->sampleCount;\n\tstsc_tmp->entries = gf_malloc(sizeof(GF_StscEntry)*stsc_tmp->nb_entries);\n\tif (!stsc_tmp->entries) return GF_OUT_OF_MEM;\n\t//set write cache to last sample before unpack\n\tstsc_tmp->w_lastSampleNumber = stbl->SampleSize->sampleCount;\n\tstsc_tmp->w_lastChunkNumber = stbl->SampleSize->sampleCount;\n\n\t//OK write our two tables...\n\tent = NULL;\n\tfor (i = 0; i < stbl->SampleSize->sampleCount; i++) {\n\t\t//get the data info for the sample\n\t\te = stbl_GetSampleInfos(stbl, i+1, &dataOffset, &chunkNumber, &sampleDescIndex, NULL);\n\t\tif (e) goto err_exit;\n\t\tent = &stsc_tmp->entries[i];\n\t\tent->isEdited = 0;\n\t\tent->sampleDescriptionIndex = sampleDescIndex;\n\t\t//here's the trick: each sample is in ONE chunk\n\t\tent->firstChunk = i+1;\n\t\tent->nextChunk = i+2;\n\t\tent->samplesPerChunk = 1;\n\t\tif (stco_tmp) {\n\t\t\tstco_tmp->offsets[i] = (u32) dataOffset;\n\t\t} else {\n\t\t\tco64_tmp->offsets[i] = dataOffset;\n\t\t}\n\t}\n\t//close the list\n\tif (ent) ent->nextChunk = 0;\n\n\n\t//done, remove our previous tables\n\tgf_list_del_item(stbl->child_boxes, stbl->ChunkOffset);\n\tgf_list_del_item(stbl->child_boxes, stbl->SampleToChunk);\n\tgf_isom_box_del(stbl->ChunkOffset);\n\tgf_isom_box_del((GF_Box *)stbl->SampleToChunk);\n\t//and set these ones...\n\tif (stco_tmp) {\n\t\tstbl->ChunkOffset = (GF_Box *)stco_tmp;\n\t} else {\n\t\tstbl->ChunkOffset = (GF_Box *)co64_tmp;\n\t}\n\tstbl->SampleToChunk = stsc_tmp;\n\tgf_list_add(stbl->child_boxes, stbl->ChunkOffset);\n\tgf_list_add(stbl->child_boxes, stbl->SampleToChunk);\n\n\tstbl->SampleToChunk->currentIndex = 0;\n\tstbl->SampleToChunk->currentChunk = 0;\n\tstbl->SampleToChunk->firstSampleInCurrentChunk = 0;\n\treturn GF_OK;\n\nerr_exit:\n\tif (stco_tmp) gf_isom_box_del((GF_Box *) stco_tmp);\n\tif (co64_tmp) gf_isom_box_del((GF_Box *) co64_tmp);\n\tif (stsc_tmp) gf_isom_box_del((GF_Box *) stsc_tmp);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nstatic GFINLINE GF_Err stbl_AddOffset(GF_SampleTableBox *stbl, GF_Box **old_stco, u64 offset)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tu32 i;\n\n\tif ((*old_stco)->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *) *old_stco;\n\t\t//if dataOffset is bigger than 0xFFFFFFFF, move to LARGE offset\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\ts32 prev_pos = gf_list_find(stbl->child_boxes, *old_stco);\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(co64->nb_entries * sizeof(u64));\n\t\t\tif (!co64->offsets) {\n\t\t\t\tgf_isom_box_del((GF_Box *)co64);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tfor (i = 0; i< co64->nb_entries - 1; i++) {\n\t\t\t\tco64->offsets[i] = (u64) stco->offsets[i];\n\t\t\t}\n\t\t\tco64->offsets[i] = offset;\n\t\t\t//delete the box...\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, *old_stco);\n\t\t\t*old_stco = (GF_Box *)co64;\n\n\t\t\tassert (stbl->child_boxes);\n\t\t\t//register new box only if old one was registered\n\t\t\tif (prev_pos>=0)\n\t\t\t\tgf_list_insert(stbl->child_boxes, *old_stco, prev_pos);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//OK, stick with regular...\n\t\tif (stco->nb_entries==stco->alloc_size) {\n\t\t\tALLOC_INC(stco->alloc_size);\n\t\t\tstco->offsets = (u32*)gf_realloc(stco->offsets, stco->alloc_size * sizeof(u32));\n\t\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stco->offsets[stco->nb_entries], 0, (stco->alloc_size - stco->nb_entries) * sizeof(u32));\n\t\t}\n\n\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\tstco->nb_entries += 1;\n\t} else {\n\t\t//this is a large offset\n\t\tco64 = (GF_ChunkLargeOffsetBox *) *old_stco;\n\t\tif (co64->nb_entries==co64->alloc_size) {\n\t\t\tALLOC_INC(co64->alloc_size);\n\t\t\tco64->offsets = (u64*)gf_realloc(co64->offsets, co64->alloc_size * sizeof(u64));\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tmemset(&co64->offsets[co64->nb_entries], 0, (co64->alloc_size - co64->nb_entries) * sizeof(u64) );\n\t\t}\n\t\tco64->offsets[co64->nb_entries] = offset;\n\t\tco64->nb_entries += 1;\n\t}\n\treturn GF_OK;\n}\n\n//This function packs the offset after easy editing, eg samples\n//are re-arranged in chunks according to the chunkOffsets\n//NOTE: this has to be called once interleaving or whatever is done and\n//the final MDAT is written!!!\nGF_Err stbl_SetChunkAndOffset(GF_SampleTableBox *stbl, u32 sampleNumber, u32 StreamDescIndex, GF_SampleToChunkBox *the_stsc, GF_Box **the_stco, u64 data_offset, Bool forceNewChunk, u32 nb_samp)\n{\n\tGF_Err e;\n\tu8 newChunk;\n\tGF_StscEntry *newEnt, *cur_ent;\n\n\tif (!stbl) return GF_ISOM_INVALID_FILE;\n\n\tnewChunk = 0;\n\t//do we need a new chunk ??? For that, we need\n\t//1 - make sure this sample data is contiguous to the prev one\n\n\t//force new chunk is set during writing (flat / interleaved)\n\t//it is set to 1 when data is not contiguous in the media (eg, interleaving)\n\t//when writing flat files, it is never used\n\tif (forceNewChunk) newChunk = 1;\n\n\tcur_ent = NULL;\n\t//2 - make sure we have the table inited (i=0)\n\tif (! the_stsc->entries) {\n\t\tnewChunk = 1;\n\t} else {\n\t\tcur_ent = &the_stsc->entries[the_stsc->nb_entries - 1];\n\t\t//3 - make sure we do not exceed the MaxSamplesPerChunk and we have the same descIndex\n\t\tif (StreamDescIndex != cur_ent->sampleDescriptionIndex)\n\t\t\tnewChunk = 1;\n\t\tif (stbl->MaxSamplePerChunk && cur_ent->samplesPerChunk >= stbl->MaxSamplePerChunk)\n\t\t\tnewChunk = 1;\n\t}\n\n\t//no need for a new chunk\n\tif (!newChunk) {\n\t\tcur_ent->samplesPerChunk += nb_samp;\n\t\treturn GF_OK;\n\t}\n\n\t//OK, we have to create a new chunk...\n\t//check if we can remove the current sampleToChunk entry (same properties)\n\tif (the_stsc->nb_entries > 1) {\n\t\tGF_StscEntry *ent = &the_stsc->entries[the_stsc->nb_entries - 2];\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tif ( (ent->sampleDescriptionIndex == cur_ent->sampleDescriptionIndex)\n\t\t        && (ent->samplesPerChunk == cur_ent->samplesPerChunk)\n\t\t   ) {\n\t\t\t//OK, it's the same SampleToChunk, so delete it\n\t\t\tent->nextChunk = cur_ent->firstChunk;\n\t\t\tthe_stsc->nb_entries--;\n\t\t}\n\t}\n\n\t//add our offset\n\te = stbl_AddOffset(stbl, the_stco, data_offset);\n\tif (e) return e;\n\n\tif (the_stsc->nb_entries==the_stsc->alloc_size) {\n\t\tALLOC_INC(the_stsc->alloc_size);\n\t\tthe_stsc->entries = gf_realloc(the_stsc->entries, sizeof(GF_StscEntry)*the_stsc->alloc_size);\n\t\tif (!the_stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&the_stsc->entries[the_stsc->nb_entries], 0, sizeof(GF_StscEntry)*(the_stsc->alloc_size-the_stsc->nb_entries));\n\t}\n\t//create a new entry (could be the first one, BTW)\n\tnewEnt = &the_stsc->entries[the_stsc->nb_entries];\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\n\t//get the first chunk value\n\tif ((*the_stco)->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tnewEnt->firstChunk = ((GF_ChunkOffsetBox *) (*the_stco) )->nb_entries;\n\t} else {\n\t\tnewEnt->firstChunk = ((GF_ChunkLargeOffsetBox *) (*the_stco) )->nb_entries;\n\t}\n\tnewEnt->sampleDescriptionIndex = StreamDescIndex;\n\tnewEnt->samplesPerChunk = nb_samp;\n\tnewEnt->nextChunk = 0;\n\t//if we already have an entry, adjust its next chunk to point to our new chunk\n\tif (the_stsc->nb_entries)\n\t\tthe_stsc->entries[the_stsc->nb_entries-1].nextChunk = newEnt->firstChunk;\n\tthe_stsc->nb_entries++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_refresh_size_info(GF_ISOFile *file, u32 trackNumber)\n{\n\tu32 i, size;\n\tGF_TrackBox *trak;\n\tGF_SampleSizeBox *stsz;\n\ttrak = gf_isom_get_track_from_file(file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (stsz->sampleSize || !stsz->sampleCount) return GF_OK;\n\n\tsize = stsz->sizes[0];\n\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\tif (stsz->sizes[i] != size) {\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (size) {\n\t\tgf_free(stsz->sizes);\n\t\tstsz->sizes = NULL;\n\t\tstsz->sampleSize = size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/stbl_write.c"], "buggy_code_start_loc": [39], "buggy_code_end_loc": [1637], "fixing_code_start_loc": [40], "fixing_code_end_loc": [1652], "type": "CWE-120", "message": "Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.", "other": {"cve": {"id": "CVE-2021-32439", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-11T20:15:09.013", "lastModified": "2021-08-16T17:32:52.253", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la funci\u00f3n stbl_AppendSize de MP4Box en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio o ejecutar c\u00f3digo arbitrario por medio de un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/77ed81c069e10b3861d88f72e1c6be1277ee7eae", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1774", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/77ed81c069e10b3861d88f72e1c6be1277ee7eae"}}