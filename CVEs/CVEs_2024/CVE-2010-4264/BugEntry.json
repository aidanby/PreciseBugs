{"buggy_code": ["<?php if (!defined('APPLICATION')) exit();\n/*\nCopyright 2008, 2009 Vanilla Forums Inc.\nThis file is part of Garden.\nGarden is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\nGarden is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with Garden.  If not, see <http://www.gnu.org/licenses/>.\nContact Vanilla Forums Inc. at support [at] vanillaforums [dot] com\n*/\n\nclass EntryController extends Gdn_Controller {\n   \n   // Make sure the database class is loaded (class.controller.php takes care of this).\n   public $Uses = array('Database', 'Form', 'UserModel');\n\tconst UsernameError = 'Username can only contain letters, numbers, underscores, and must be between 3 and 20 characters long.';\n   \n   public function Auth($AuthenticationSchemeAlias = 'default') {\n      $this->EventArguments['AuthenticationSchemeAlias'] = $AuthenticationSchemeAlias;\n      $this->FireEvent('BeforeAuth');\n      \n      // Allow hijacking auth type\n      $AuthenticationSchemeAlias = $this->EventArguments['AuthenticationSchemeAlias'];\n      \n      try {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith($AuthenticationSchemeAlias);\n      } catch (Exception $e) {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith('default');\n      }\n      \n      // Set up controller\n      $this->View = 'auth/'.$Authenticator->GetAuthenticationSchemeAlias();\n      $this->Form->SetModel($this->UserModel);\n      $this->Form->AddHidden('ClientHour', date('G', time())); // Use the server's current hour as a default\n      $this->Form->AddHidden('Target', GetIncomingValue('Target', ''));\n\n      // Import authenticator data source\n      switch ($Authenticator->DataSourceType()) {\n         case Gdn_Authenticator::DATA_FORM:\n            $Authenticator->FetchData($this->Form);\n         break;\n         \n         case Gdn_Authenticator::DATA_REQUEST:\n         case Gdn_Authenticator::DATA_COOKIE:\n            $Authenticator->FetchData(Gdn::Request());\n         break;\n      }\n      \n      // By default, just render the view\n      $Reaction = Gdn_Authenticator::REACT_RENDER;\n      \n      // Where are we in the process? Still need to gather (render view) or are we validating?\n      $AuthenticationStep = $Authenticator->CurrentStep();\n      \n      switch ($AuthenticationStep) {\n      \n         // User is already logged in\n         case Gdn_Authenticator::MODE_REPEAT:\n            $Reaction = $Authenticator->RepeatResponse();\n         break;\n            \n         // Not enough information to perform authentication, render input form\n         case Gdn_Authenticator::MODE_GATHER:\n            $this->AddJsFile('entry.js');\n            $Reaction = $Authenticator->LoginResponse();\n\t\t\t\tif ($this->Form->IsPostBack())\n\t\t\t\t\t$this->Form->AddError('ErrorCredentials');\n         break;\n         \n         // All information is present, authenticate\n         case Gdn_Authenticator::MODE_VALIDATE:\n            \n            // Attempt to authenticate.\n            try {\n               $AuthenticationResponse = $Authenticator->Authenticate();\n               Gdn::Authenticator()->Trigger($AuthenticationResponse);\n               switch ($AuthenticationResponse) {\n                  case Gdn_Authenticator::AUTH_PERMISSION:\n                     $this->Form->AddError('ErrorPermission');\n                     $Reaction = $Authenticator->FailedResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_DENIED:\n                     $this->Form->AddError('ErrorCredentials');\n                     $Reaction = $Authenticator->FailedResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_INSUFFICIENT:\n                     // Unable to comply with auth request, more information is needed from user.\n                     $this->Form->AddError('ErrorInsufficient');\n                     $Reaction = $Authenticator->FailedResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_PARTIAL:\n                     // Partial auth completed.\n                     $Reaction = $Authenticator->PartialResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_SUCCESS:\n                  default: \n                     // Full auth completed.\n                     $UserID = $AuthenticationResponse;\n                     $Reaction = $Authenticator->SuccessResponse();\n               }\n            } catch (Exception $Ex) {\n               $this->Form->AddError($Ex);\n            }\n         break;\n         \n         case Gdn_Authenticator::MODE_NOAUTH:\n            $Reaction = Gdn_Authenticator::REACT_REDIRECT;\n         break;\n      }\n      \n      // AddActivity($AuthenticatedUserID, 'SignIn');\n      switch ($Reaction) {\n      \n         case Gdn_Authenticator::REACT_RENDER:\n            // Do nothing (render the view)\n         break;\n      \n         case Gdn_Authenticator::REACT_EXIT:\n            exit();\n         break;\n      \n         case Gdn_Authenticator::REACT_REMOTE:\n            // Let the authenticator handle generating output, using a blank slate\n            $this->_DeliveryType= DELIVERY_TYPE_VIEW;\n            \n            exit;\n         break;\n         \n         case Gdn_Authenticator::REACT_REDIRECT:\n         default:\n         \n            if (is_string($Reaction))\n               $Route = $Reaction;\n            else\n               $Route = $this->RedirectTo();\n            \n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               \n               if ($Route !== FALSE) {\n                  Redirect($Route);\n               } else {\n                  Redirect(Gdn::Router()->GetDestination('DefaultController'));\n               }\n            }\n         break;\n      }\n      \n      $this->SetData('SendWhere', \"/entry/auth/{$AuthenticationSchemeAlias}\");\n      $this->Render();\n   }\n      \n   public function Index() {\n      $this->SignIn();\n   }\n   \n   public function Password() {\n      $this->Auth('password');\n   }\n   \n   public function SignIn() {\n      $this->FireEvent(\"SignIn\");\n      $this->Auth('default');\n   }\n\n   public function SignOut($TransientKey = \"\") {\n      $SessionAuthenticator = Gdn::Session()->GetPreference('Authenticator');\n      $AuthenticationScheme = ($SessionAuthenticator) ? $SessionAuthenticator : 'default';\n\n      try {\n         $Authenticator = Gdn::Authenticator()->GetAuthenticator($AuthenticationScheme);\n      } catch (Exception $e) {\n         $Authenticator = Gdn::Authenticator()->GetAuthenticator();\n      }\n   \n      $this->FireEvent(\"SignOut\");\n      $this->Leave($AuthenticationScheme, $TransientKey);\n   }\n  \n   /** A version of signin that supports multiple authentication methods.\n    *  This method should replace EntryController::SignIn() eventually.\n    *\n    * @param string $Method\n    */\n   public function SignIn2($SelectedMethod = FALSE) {\n      // Set up the initial methods. Other methods can be added by plugins.\n      $Methods = array(\n         'password' => array('Label' => 'Vanilla', 'Url' => Url('/entry/auth/password'), 'ViewLocation' => $this->FetchViewLocation('SignIn'))\n      );\n\n      // Make sure a valid method is chosen.\n      if (!array_key_exists((string)$SelectedMethod, $Methods)) {\n         $SelectedMethod = array_shift(array_keys($Methods));\n      }\n      \n      $this->SetData('SelectedMethod', $SelectedMethod);\n      $this->SetData('Methods', $Methods);\n\n      return $this->Render();\n   }\n   \n   public function Handshake($AuthenticationSchemeAlias = 'default') {\n      \n      try {\n         // Don't show anything if handshaking not turned on by an authenticator\n   \t\tif (!Gdn::Authenticator()->CanHandshake())\n   \t\t\tthrow new Exception();\n         \n         // Try to load the authenticator\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith($AuthenticationSchemeAlias);\n         \n         // Try to grab the authenticator data\n         $Payload = $Authenticator->GetHandshake();\n         if ($Payload === FALSE) {\n            Gdn::Request()->WithURI('dashboard/entry/auth/password');\n            return Gdn::Dispatcher()->Dispatch();\n         }\n      } catch (Exception $e) {\n         Gdn::Request()->WithURI('/entry/signin');\n         return Gdn::Dispatcher()->Dispatch();\n      }\n      \n      $UserInfo = array(\n         'UserKey'      => $Authenticator->GetUserKeyFromHandshake($Payload),\n         'ConsumerKey'  => $Authenticator->GetProviderKeyFromHandshake($Payload),\n         'TokenKey'     => $Authenticator->GetTokenKeyFromHandshake($Payload),\n         'UserName'     => $Authenticator->GetUserNameFromHandshake($Payload),\n         'UserEmail'    => $Authenticator->GetUserEmailFromHandshake($Payload)\n      );\n      \n      // Manual user sync is disabled. No hand holding will occur for users.\n      $SyncScreen = C('Garden.Authenticator.SyncScreen', 'on');\n      switch ($SyncScreen) {\n         case 'on':\n         \n            $this->SyncScreen($Authenticator, $UserInfo, $Payload);\n            \n         break;\n         \n         case 'off':\n         case 'smart':\n            $UserID = $this->UserModel->Synchronize($UserInfo['UserKey'], array(\n               'Name'   => $UserInfo['UserName'],\n               'Email'  => $UserInfo['UserEmail']\n            ));\n            \n            if ($UserID > 0) {\n               // Account created successfully.\n               \n               // Finalize the link between the forum user and the foreign userkey\n               $Authenticator->Finalize($UserInfo['UserKey'], $UserID, $UserInfo['ConsumerKey'], $UserInfo['TokenKey'], $Payload);\n               \n               /// ... and redirect them appropriately\n               $Route = $this->RedirectTo();\n               if ($Route !== FALSE)\n                  Redirect($Route);\n               else\n                  Redirect('/');\n                  \n            } else {\n               // Account not created.\n               if ($SyncScreen == 'smart') {\n               \n                  $this->StatusMessage = T('There is already an account in this forum using your email address. Please create a new account, or enter the credentials for the existing account.');\n                  $this->SyncScreen($Authenticator, $UserInfo, $Payload);\n                  \n               } else {\n                  \n                  // Set the memory cookie to allow signinloopback to shortcircuit remote query.\n                  $CookiePayload = array(\n                     'Sync'   => 'Failed'\n                  );\n                  $SerializedCookiePayload = Gdn_Format::Serialize($CookiePayload);\n                  $Authenticator->Remember($UserInfo['ConsumerKey'], $SerializedCookiePayload);\n                  \n                  // This resets vanilla's internal \"where am I\" to the homepage. Needed.\n                  Gdn::Request()->WithRoute('DefaultController');\n                  $this->SelfUrl = Gdn::Request()->Path();\n                  \n                  $this->View = 'syncfailed';\n                  $this->ProviderSite = $Authenticator->GetProviderUrl();\n                  $this->Render();\n               }\n               \n            }\n         break;\n      \n      }\n   }\n   \n   public function SyncScreen($Authenticator, $UserInfo, $Payload) {\n      $this->AddJsFile('entry.js');\n      $this->View = 'handshake';\n      $this->HandshakeScheme = $Authenticator->GetAuthenticationSchemeAlias();\n      $this->Form->SetModel($this->UserModel);\n      $this->Form->AddHidden('ClientHour', date('G', time())); // Use the server's current hour as a default\n      $this->Form->AddHidden('Target', GetIncomingValue('Target', '/'));\n      \n      $PreservedKeys = array(\n         'UserKey', 'Token', 'Consumer', 'Email', 'Name', 'Gender', 'HourOffset'\n      );\n      $UserID = 0;\n      $Target = GetIncomingValue('Target', '/');\n   \n      if ($this->Form->IsPostBack() === TRUE) {\n            \n         $FormValues = $this->Form->FormValues();\n         if (ArrayValue('StopLinking', $FormValues)) {\n         \n            $Authenticator->DeleteCookie();\n            Gdn::Request()->WithRoute('DefaultController');\n            return Gdn::Dispatcher()->Dispatch();\n            \n         } elseif (ArrayValue('NewAccount', $FormValues)) {\n         \n            // Try and synchronize the user with the new username/email.\n            $FormValues['Name'] = $FormValues['NewName'];\n            $FormValues['Email'] = $FormValues['NewEmail'];\n            $UserID = $this->UserModel->Synchronize($UserInfo['UserKey'], $FormValues);\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n            \n         } else {\n   \n            // Try and sign the user in.\n            $PasswordAuthenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $PasswordAuthenticator->HookDataField('Email', 'SignInEmail');\n            $PasswordAuthenticator->HookDataField('Password', 'SignInPassword');\n            $PasswordAuthenticator->FetchData($this->Form);\n            \n            $UserID = $PasswordAuthenticator->Authenticate();\n            \n            if ($UserID < 0) {\n               $this->Form->AddError('ErrorPermission');\n            } else if ($UserID == 0) {\n               $this->Form->AddError('ErrorCredentials');\n            }\n            \n            if ($UserID > 0) {\n               $Data = $FormValues;\n               $Data['UserID'] = $UserID;\n               $Data['Email'] = ArrayValue('SignInEmail', $FormValues, '');\n               $UserID = $this->UserModel->Synchronize($UserInfo['UserKey'], $Data);\n            }\n         }\n         \n         if ($UserID > 0) {\n            // The user has been created successfully, so sign in now\n            \n            // Finalize the link between the forum user and the foreign userkey\n            $Authenticator->Finalize($UserInfo['UserKey'], $UserID, $UserInfo['ConsumerKey'], $UserInfo['TokenKey'], $Payload);\n            \n            /// ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($Route !== FALSE)\n               Redirect($Route);\n         } else {\n            // Add the hidden inputs back into the form.\n            foreach($FormValues as $Key => $Value) {\n               if (in_array($Key, $PreservedKeys))\n                  $this->Form->AddHidden($Key, $Value);\n            }\n         }\n      } else {\n         $Id = Gdn::Authenticator()->GetIdentity(TRUE);\n         if ($Id > 0) {\n            // The user is signed in so we can just go back to the homepage.\n            Redirect($Target);\n         }\n         \n         $Name = $UserInfo['UserName'];\n         $Email = $UserInfo['UserEmail'];\n         \n         // Set the defaults for a new user.\n         $this->Form->SetFormValue('NewName', $Name);\n         $this->Form->SetFormValue('NewEmail', $Email);\n         \n         // Set the default for the login.\n         $this->Form->SetFormValue('SignInEmail', $Email);\n         $this->Form->SetFormValue('Handshake', 'NEW');\n         \n         // Add the handshake data as hidden fields.\n         $this->Form->AddHidden('Name',       $Name);\n         $this->Form->AddHidden('Email',      $Email);\n         $this->Form->AddHidden('UserKey',    $UserInfo['UserKey']);\n         $this->Form->AddHidden('Token',      $UserInfo['TokenKey']);\n         $this->Form->AddHidden('Consumer',   $UserInfo['ConsumerKey']);\n         \n      }\n      \n      $this->SetData('Name', ArrayValue('Name', $this->Form->HiddenInputs));\n      $this->SetData('Email', ArrayValue('Email', $this->Form->HiddenInputs));\n      \n      $this->Render();\n   }\n   \n   /**\n    * Calls the appropriate registration method based on the configuration setting.\n    */\n   public function Register($InvitationCode = '') {\n      $this->Form->SetModel($this->UserModel);\n\n      // Define gender dropdown options\n      $this->GenderOptions = array(\n         'm' => T('Male'),\n         'f' => T('Female')\n      );\n\n      // Make sure that the hour offset for new users gets defined when their account is created\n      $this->AddJsFile('entry.js');\n         \n      $this->Form->AddHidden('ClientHour', date('G', time())); // Use the server's current hour as a default\n      $this->Form->AddHidden('Target', GetIncomingValue('Target', ''));\n\n      $RegistrationMethod = $this->_RegistrationView();\n      $this->View = $RegistrationMethod;\n      $this->$RegistrationMethod($InvitationCode);\n   }\n   \n   protected function _RegistrationView() {\n      $RegistrationMethod = Gdn::Config('Garden.Registration.Method');\n      if (!in_array($RegistrationMethod, array('Closed', 'Basic','Captcha','Approval','Invitation')))\n         $RegistrationMethod = 'Basic';\n         \n      return 'Register'.$RegistrationMethod;\n   }\n   \n   private function RegisterApproval() {\n      // If the form has been posted back...\n      if ($this->Form->IsPostBack()) {\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         $this->UserModel->Validation->ApplyRule('DiscoveryText', 'Required', 'Tell us why you want to join!');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForApproval($this->Form->FormValues()))\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n         else\n            $this->View = \"RegisterThanks\"; // Tell the user their application will be reviewed by an administrator.\n      }\n      $this->Render();\n   }\n   \n   private function RegisterBasic() {\n      if ($this->Form->IsPostBack() === TRUE) {\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForBasic($this->Form->FormValues())) {\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n         } else {\n            // The user has been created successfully, so sign in now\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($this->Form);\n            $AuthUserID = $Authenticator->Authenticate();\n            \n            // ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE)\n                  Redirect($Route);\n            }\n         }\n      }\n      $this->Render();\n   }\n   \n   private function RegisterCaptcha() {\n      include(CombinePaths(array(PATH_LIBRARY, 'vendors/recaptcha', 'functions.recaptchalib.php')));\n      if ($this->Form->IsPostBack() === TRUE) {\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForBasic($this->Form->FormValues())) {\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n            if($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->_DeliveryType = DELIVERY_TYPE_MESSAGE;\n            }\n         } else {\n            // The user has been created successfully, so sign in now\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($this->Form);\n            $AuthUserID = $Authenticator->Authenticate();\n            \n            // ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE)\n                  Redirect($Route);\n            }\n         }\n      }\n      $this->Render();\n   }\n   \n   private function RegisterClosed() {\n      $this->Render();\n   }\n   \n   private function RegisterInvitation($InvitationCode) {\n      if ($this->Form->IsPostBack() === TRUE) {\n         $this->InvitationCode = $this->Form->GetValue('InvitationCode');\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForInvite($this->Form->FormValues())) {\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n         } else {\n            // The user has been created successfully, so sign in now\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($this->Form);\n            $AuthUserID = $Authenticator->Authenticate();\n            \n            // ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE)\n                  Redirect($Route);\n            }\n         }\n      } else {\n         $this->InvitationCode = $InvitationCode;\n      }\n      $this->Render();      \n   }\n   \n   public function PasswordRequest() {\n      $this->Form->SetModel($this->UserModel);\n      if ($this->Form->IsPostBack() === TRUE) {\n\n         if ($this->Form->ValidateModel() == 0) {\n            try {\n               if (!$this->UserModel->PasswordRequest($this->Form->GetFormValue('Email', ''))) {\n                  $this->Form->AddError(\"Couldn't find an account associated with that email address.\");\n               }\n            } catch (Exception $ex) {\n               $this->Form->AddError($ex->getMessage());\n            }\n            if ($this->Form->ErrorCount() == 0) {\n               $this->Form->AddError('Success!');\n               $this->View = 'passwordrequestsent';\n            }\n         } else {\n            if ($this->Form->ErrorCount() == 0)\n               $this->Form->AddError('That email address was not found.');\n         }\n      }\n      $this->Render();\n   }\n\n   public function PasswordReset($UserID = '', $PasswordResetKey = '') {\n      if (!is_numeric($UserID)\n          || $PasswordResetKey == ''\n          || $this->UserModel->GetAttribute($UserID, 'PasswordResetKey', '') != $PasswordResetKey\n         ) $this->Form->AddError('Failed to authenticate your password reset request. Try using the reset request form again.');\n      \n      if ($this->Form->ErrorCount() == 0\n         && $this->Form->IsPostBack() === TRUE\n      ) {\n         $Password = $this->Form->GetFormValue('Password', '');\n         $Confirm = $this->Form->GetFormValue('Confirm', '');\n         if ($Password == '')\n            $this->Form->AddError('Your new password is invalid');\n         else if ($Password != $Confirm)\n            $this->Form->AddError('Your passwords did not match.');\n\n         if ($this->Form->ErrorCount() == 0) {\n            $User = $this->UserModel->PasswordReset($UserID, $Password);\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($Authenticator, array('Email' => $User->Email, 'Password' => $Password, 'RememberMe' => FALSE));\n            $AuthUserID = $Authenticator->Authenticate();\n\t\t\t\tRedirect('/');\n         }\n      }\n      $this->Render();\n   }\n\n   public function EmailConfirm($UserID = '', $EmailKey = '') {\n      if (!is_numeric($UserID) || $EmailKey != $this->UserModel->GetAttribute($UserID, 'EmailKey', '')) {\n         $this->Form->AddError(T('Couldn\\'t confirm email.',\n            'We couldn\\'t confirm your email. Check the link in the email we sent you or try sending another confirmation email.'));\n      }\n\n      if ($this->Form->ErrorCount() == 0) {\n         \n\n      }\n      $this->Render();\n   }\n\n   public function Leave($AuthenticationSchemeAlias = 'default', $TransientKey = '') {\n      $this->EventArguments['AuthenticationSchemeAlias'] = $AuthenticationSchemeAlias;\n      $this->FireEvent('BeforeLeave');\n      \n      // Allow hijacking deauth type\n      $AuthenticationSchemeAlias = $this->EventArguments['AuthenticationSchemeAlias'];\n      \n      try {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith($AuthenticationSchemeAlias);\n      } catch (Exception $e) {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith('default');\n      }\n      \n      // Only sign the user out if this is an authenticated postback! Start off pessimistic\n      $this->Leaving = FALSE;\n      $Result = Gdn_Authenticator::REACT_RENDER;\n      \n      // Build these before doing anything desctructive as they are supposed to have user context\n      $LogoutResponse = $Authenticator->LogoutResponse();\n      $LoginResponse = $Authenticator->LoginResponse();\n      \n      $AuthenticatedPostbackRequired = $Authenticator->RequireLogoutTransientKey();\n      if (!$AuthenticatedPostbackRequired || Gdn::Session()->ValidateTransientKey($TransientKey)) {\n         $Result = $Authenticator->DeAuthenticate();\n         $this->Leaving = TRUE;\n      }\n      \n      if ($Result == Gdn_Authenticator::AUTH_SUCCESS) {\n         $this->View = 'leave';\n         $Reaction = $LogoutResponse;\n      } else {\n         $this->View = 'auth/'.$Authenticator->GetAuthenticationSchemeAlias();\n         $Reaction = $LoginResponse;\n      }\n      \n      switch ($Reaction) {\n         case Gdn_Authenticator::REACT_RENDER:\n            \n         break;\n\n         case Gdn_Authenticator::REACT_EXIT:\n            exit();\n         break;\n\n         case Gdn_Authenticator::REACT_REMOTE:\n            // Render the view, but set the delivery type to VIEW\n            $this->_DeliveryType= DELIVERY_TYPE_VIEW;\n         break;\n\n         case Gdn_Authenticator::REACT_REDIRECT:\n         default:\n            // If we're just told to redirect, but not where... try to figure out somewhere that makes sense.\n            if ($Reaction == Gdn_Authenticator::REACT_REDIRECT) {\n               $Route = '/';\n               $Target = GetIncomingValue('Target', NULL);\n               if (!is_null($Target)) \n                  $Route = $Target;\n            } else {\n               $Route = $Reaction;\n            }\n            \n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE) {\n                  Redirect($Route);\n               } else {\n                  Redirect(Gdn::Router()->GetDestination('DefaultController'));\n               }\n            }\n         break;\n      }\n      \n      $this->Render();\n   }\n   \n   public function RedirectTo() {\n      $IncomingTarget = $this->Form->GetValue('Target', '');\n      return $IncomingTarget == '' ? Gdn::Router()->GetDestination('DefaultController') : $IncomingTarget;\n   }\n   \n   public function Initialize() {\n      $this->Head = new HeadModule($this);\n      $this->AddJsFile('jquery.js');\n      $this->AddJsFile('jquery.livequery.js');\n      $this->AddJsFile('jquery.form.js');\n      $this->AddJsFile('jquery.popup.js');\n      $this->AddJsFile('jquery.gardenhandleajaxform.js');\n      $this->AddJsFile('global.js');\n      \n      $this->AddCssFile('style.css');\n      parent::Initialize();\n   }\n\n}\n", "<?php if (!defined('APPLICATION')) exit();\n/*\nCopyright 2008, 2009 Vanilla Forums Inc.\nThis file is part of Garden.\nGarden is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\nGarden is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with Garden.  If not, see <http://www.gnu.org/licenses/>.\nContact Vanilla Forums Inc. at support [at] vanillaforums [dot] com\n*/\n\n/**\n * Dispatcher handles all requests.\n *\n * @author Mark O'Sullivan\n * @copyright 2003 Mark O'Sullivan\n * @license http://www.opensource.org/licenses/gpl-2.0.php GPL\n * @package Garden\n * @version @@GARDEN-VERSION@@\n * @namespace Garden.Core\n */\n\nclass Gdn_Dispatcher extends Gdn_Pluggable {\n\n   /**\n    * An array of folders within the application that are OK to search through\n    * for controllers. This property is filled by the applications array\n    * located in /conf/applications.php and included in /bootstrap.php\n    *\n    * @var array\n    */\n   private $_EnabledApplicationFolders;\n\n   /**\n    * An associative array of ApplicationName => ApplicationFolder. This\n    * property is filled by the applications array located in\n    * /conf/applications.php and included in /bootstrap.php\n    *\n    * @var array\n    */\n   private $_EnabledApplications;\n\n   /**\n    * The currently requested url (defined in _AnalyzeRequest)\n    *\n    * @var string\n    */\n   public $Request;\n\n   /**\n    * The name of the application folder that contains the controller that has\n    * been requested.\n    *\n    * @var string\n    */\n   private $_ApplicationFolder;\n\n   /**\n    * An associative collection of AssetName => Strings that will get passed\n    * into the controller once it has been instantiated.\n    *\n    * @var array\n    */\n   private $_AssetCollection;\n\n   /**\n    * The name of the controller folder that contains the controller that has\n    * been requested.\n    *\n    * @var string\n    */\n   private $_ControllerFolder;\n\n   /**\n    * The name of the controller to be dispatched.\n    *\n    * @var string\n    */\n   private $_ControllerName;\n\n   /**\n    * The method of the controller to be called.\n    *\n    * @var string\n    */\n   private $_ControllerMethod;\n\n   /**\n    * Any query string arguments supplied to the controller method.\n    *\n    * @var string\n    */\n   private $_ControllerMethodArgs = array();\n\n   /**\n    * An associative collection of variables that will get passed into the\n    * controller as properties once it has been instantiated.\n    *\n    * @var array\n    */\n   private $_PropertyCollection;\n\n   /**\n    * Defined by the url of the request: SYNDICATION_RSS, SYNDICATION_ATOM, or\n    * SYNDICATION_NONE (default).\n    *\n    * @var string\n    */\n   private $_SyndicationMethod;\n\n   /**\n    * Class constructor.\n    */\n   public function __construct() {\n      parent::__construct();\n      $this->_EnabledApplicationFolders = array();\n      $this->Request = '';\n      $this->_ApplicationFolder = '';\n      $this->_AssetCollection = array();\n      $this->_ControllerFolder = '';\n      $this->_ControllerName = '';\n      $this->_ControllerMethod = '';\n      $this->_ControllerMethodArgs = array();\n      $this->_PropertyCollection = array();\n   }\n   \n   public function Cleanup() {\n      // Destruct the db connection;\n      $Database = Gdn::Database();\n      if($Database != null)\n         $Database->CloseConnection();\n   }\n\n\n   /**\n    * Return the properly formatted controller class name.\n    */\n   public function ControllerName() {\n      return $this->_ControllerName.'Controller';\n   }\n   \n   public function Application() {\n      return $this->_ApplicationFolder;\n   }\n   \n   public function Controller() {\n      return $this->_ControllerName;\n   }\n   \n   public function ControllerMethod() {\n      return $this->_ControllerMethod;\n   }\n   \n   public function ControllerArguments() {\n      return $this->_ControllerMethodArgs;\n   }\n\n   /**\n    * Analyzes the supplied query string and decides how to dispatch the request.\n    */\n   public function Dispatch($ImportRequest = NULL, $Permanent = TRUE) {\n      if ($ImportRequest && is_string($ImportRequest))\n         $ImportRequest = Gdn_Request::Create()->FromEnvironment()->WithURI($ImportRequest);\n      \n      if (is_a($ImportRequest, 'Gdn_Request') && $Permanent) {\n         Gdn::Request($ImportRequest);\n      }\n      \n      $Request = is_a($ImportRequest, 'Gdn_Request') ? $ImportRequest : Gdn::Request();\n   \n      if (Gdn::Config('Garden.UpdateMode', FALSE)) {\n         if (!Gdn::Session()->CheckPermission('Garden.Settings.GlobalPrivs')) {\n            // Updatemode, and this user is not root admin\n            $Request->WithURI(Gdn::Router()->GetDestination('UpdateMode'));\n         }\n      }\n      \n      $this->FireEvent('BeforeDispatch');\n      $this->_AnalyzeRequest($Request);\n      \n      // Send user to login page if this is a private community\n      if (C('Garden.PrivateCommunity') && $this->ControllerName() != 'EntryController' && !Gdn::Session()->IsValid()) {\n         Redirect(Gdn::Authenticator()->SignInUrl($this->Request));\n         exit();\n      }\n         \n      /*\n      echo \"<br />Gdn::Request thinks: \".Gdn::Request()->Path();\n      echo \"<br />Gdn::Request also suggests: output=\".Gdn::Request()->OutputFormat().\", filename=\".Gdn::Request()->Filename();\n      echo '<br />Request: '.$this->Request;      \n      echo '<br />App folder: '.$this->_ApplicationFolder;\n      echo '<br />Controller folder: '.$this->_ControllerFolder;\n      echo '<br />ControllerName: '.$this->_ControllerName;\n      echo '<br />ControllerMethod: '.$this->_ControllerMethod;\n      */\n\n      $ControllerName = $this->ControllerName();\n      if ($ControllerName != '' && class_exists($ControllerName)) {\n         // Create it and call the appropriate method/action\n         $Controller = new $ControllerName();\n\n         // Pass along any assets\n         if (is_array($this->_AssetCollection)) {\n            foreach ($this->_AssetCollection as $AssetName => $Assets) {\n               foreach ($Assets as $Asset) {\n                  $Controller->AddAsset($AssetName, $Asset);\n               }\n            }\n         }\n\n         // Instantiate Imported & Uses classes\n         $Controller->GetImports();\n\n         // Pass in the syndication method\n         $Controller->SyndicationMethod = $this->_SyndicationMethod;\n\n         // Pass along the request\n         $Controller->SelfUrl = $this->Request;\n\n         // Pass along any objects\n         foreach($this->_PropertyCollection as $Name => $Mixed) {\n            $Controller->$Name = $Mixed;\n         }\n\n         // Set up a default controller method in case one isn't defined.\n         $ControllerMethod = str_replace('_', '', $this->_ControllerMethod);\n         $Controller->OriginalRequestMethod = $ControllerMethod;\n         \n         // Take enabled plugins into account, as well\n         $PluginManagerHasReplacementMethod = Gdn::PluginManager()->HasNewMethod($this->ControllerName(), $this->_ControllerMethod);\n         if (!$PluginManagerHasReplacementMethod && ($this->_ControllerMethod == '' || !method_exists($Controller, $ControllerMethod))) {\n            // Check to see if there is an 'x' version of the method.\n            if (method_exists($Controller, 'x'.$ControllerMethod)) {\n               // $PluginManagerHasReplacementMethod = TRUE;\n               $ControllerMethod = 'x'.$ControllerMethod;\n            } else {\n               if ($this->_ControllerMethod != '')\n                  array_unshift($this->_ControllerMethodArgs, $this->_ControllerMethod);\n               \n               $this->_ControllerMethod = 'Index';\n               $ControllerMethod = 'Index';\n               \n               $PluginManagerHasReplacementMethod = Gdn::PluginManager()->HasNewMethod($this->ControllerName(), $this->_ControllerMethod);\n            }\n         }\n         // Pass in the querystring values\n         $Controller->ApplicationFolder = $this->_ApplicationFolder;\n         $Controller->Application = $this->EnabledApplication();\n         $Controller->ControllerFolder = $this->_ControllerFolder;\n         $Controller->RequestMethod = $this->_ControllerMethod;\n         $Controller->RequestArgs = $this->_ControllerMethodArgs;\n         $Controller->Request = $Request;\n         $Controller->DeliveryType($Request->GetValue('DeliveryType', ''));\n         $Controller->DeliveryMethod($Request->GetValue('DeliveryMethod', ''));\n\n         // Set special controller method options for REST APIs.\n         $this->_SetControllerMethod($Controller);\n         \n         $Controller->Initialize();\n\n         // Call the requested method on the controller - error out if not defined.\n         if ($PluginManagerHasReplacementMethod || method_exists($Controller, $ControllerMethod)) {\n            // call_user_func_array is too slow!!\n            //call_user_func_array(array($Controller, $ControllerMethod), $this->_ControllerMethodArgs);\n            \n            if ($PluginManagerHasReplacementMethod) {\n              Gdn::PluginManager()->CallNewMethod($Controller, $Controller->ControllerName, $ControllerMethod);\n            } else { \n              $Args = $this->_ControllerMethodArgs;\n              $Count = count($Args);\n\n              try {\n                 call_user_func_array(array($Controller, $ControllerMethod), $Args);\n              } catch (Exception $Ex) {\n                 $Controller->RenderException($Ex);\n                 exit();\n              }\n            }\n         } else {\n            Gdn::Request()->WithRoute('Default404');\n            return $this->Dispatch();\n         }\n      }\n   }\n   \n   /**\n    * Undocumented method.\n    *\n    * @param string $EnabledApplications\n    * @todo Method EnabledApplicationFolders() and $EnabledApplications needs descriptions.\n    */\n   public function EnabledApplicationFolders($EnabledApplications = '') {\n      if ($EnabledApplications != '' && count($this->_EnabledApplicationFolders) == 0) {\n         $this->_EnabledApplications = $EnabledApplications;\n         $this->_EnabledApplicationFolders = array_values($EnabledApplications);\n      }\n      return $this->_EnabledApplicationFolders;\n   }\n\n   /**\n    * Returns the name of the enabled application based on $ApplicationFolder.\n    *\n    * @param string The application folder related to the application name you want to return.\n    */\n   public function EnabledApplication($ApplicationFolder = '') {\n      if ($ApplicationFolder == '')\n         $ApplicationFolder = $this->_ApplicationFolder;\n\n      $EnabledApplication = array_keys($this->_EnabledApplications, $ApplicationFolder);\n      $EnabledApplication = count($EnabledApplication) > 0 ? $EnabledApplication[0] : '';\n      $this->EventArguments['EnabledApplication'] = $EnabledApplication;\n      $this->FireEvent('AfterEnabledApplication');\n      return $EnabledApplication;\n   }\n\n   /**\n    * Allows the passing of a string to the controller's asset collection.\n    *\n    * @param string $AssetName The name of the asset collection to add the string to.\n    * @param mixed $Asset The string asset to be added. The asset can be one of two things.\n    * - <b>string</b>: The string will be rendered to the page.\n    * - <b>Gdn_IModule</b>: The Gdn_IModule::Render() method will be called when the asset is rendered.\n    */\n   public function PassAsset($AssetName, $Asset) {\n      $this->_AssetCollection[$AssetName][] = $Asset;\n   }\n\n   /**\n    * Allows the passing of any variable to the controller as a property.\n    *\n    * @param string $Name The name of the property to assign the variable to.\n    * @param mixed $Mixed The variable to be passed as a property of the controller.\n    */\n   public function PassProperty($Name, $Mixed) {\n      $this->_PropertyCollection[$Name] = $Mixed;\n   }\n\n   /**\n    * Parses the query string looking for supplied request parameters. Places\n    * anything useful into this object's Controller properties.\n    *\n    * @param int $FolderDepth\n    * @todo $folderDepth needs a description.\n    */\n   protected function _AnalyzeRequest(&$Request, $FolderDepth = 1) {\n      // Here is the basic format of a request:\n      // [/application]/controller[/method[.json|.xml]]/argn|argn=valn\n\n      // Here are some examples of what this method could/would receive:\n      // /application/controller/method/argn\n      // /controller/method/argn\n      // /application/controller/argn\n      // /controller/argn\n      // /controller\n\n\n      // Clear the slate\n      $this->_ApplicationFolder = '';\n      $this->_ControllerFolder = '';\n      $this->_ControllerName = '';\n      $this->_ControllerMethod = 'index';\n      $this->_ControllerMethodArgs = array();\n      $this->Request = $Request->Path();\n\n      $PathAndQuery = $Request->PathAndQuery();\n      $MatchRoute = Gdn::Router()->MatchRoute($PathAndQuery);\n\n      // We have a route. Take action.\n      if ($MatchRoute !== FALSE) {\n         switch ($MatchRoute['Type']) {\n            case 'Internal':\n               $Request->PathAndQuery($MatchRoute['FinalDestination']);\n               $this->Request = $MatchRoute['FinalDestination'];\n               break;\n\n            case 'Temporary':\n               Header( \"HTTP/1.1 302 Moved Temporarily\" );\n               Header( \"Location: \".$MatchRoute['FinalDestination'] );\n               exit();\n               break;\n\n            case 'Permanent':\n               Header( \"HTTP/1.1 301 Moved Permanently\" );\n               Header( \"Location: \".$MatchRoute['FinalDestination'] );\n               exit();\n               break;\n\n            case 'NotFound':\n               Header( \"HTTP/1.1 404 Not Found\" );\n               $this->Request = $MatchRoute['FinalDestination'];\n               break;\n         }\n      }\n\n\n      switch ($Request->OutputFormat()) {\n         case 'rss':\n            $this->_SyndicationMethod = SYNDICATION_RSS;\n            break;\n         case 'atom':\n            $this->_SyndicationMethod = SYNDICATION_ATOM;\n            break;\n         case 'default':\n         default:\n            $this->_SyndicationMethod = SYNDICATION_NONE;\n            break;\n      }\n\n      if ($this->Request == '')\n      {\n         $DefaultController = Gdn::Router()->GetRoute('DefaultController');\n         $this->Request = $DefaultController['Destination'];\n      }\n   \n      $Parts = explode('/', $this->Request);\n      $Length = count($Parts);\n      if ($Length == 1 || $FolderDepth <= 0) {\n         $FolderDepth = 0;\n         $this->_ControllerName = $Parts[0];\n         $this->_MapParts($Parts, 0);\n         $this->_FetchController(TRUE); // Throw an error if this fails because there's nothing else to check\n      } else if ($Length == 2) {\n         // Force a depth of 1 because only one of the two url parts can be a folder.\n         $FolderDepth = 1;\n      }\n      if ($FolderDepth == 2) {\n         $this->_ApplicationFolder = $Parts[0];\n         $this->_ControllerFolder = $Parts[1];\n         $this->_MapParts($Parts, 2);\n\n         if (!$this->_FetchController()) {\n            // echo '<div>Failed. AppFolder: '.$this->_ApplicationFolder.'; Cont Folder: '.$this->_ControllerFolder.'; Cont: '.$this->_ControllerName.';</div>';\n            $this->_AnalyzeRequest($Request, 1);\n         }\n\n      } else if ($FolderDepth == 1) {\n         // Try the application folder first\n         $Found = FALSE;\n         if (in_array($Parts[0], $this->EnabledApplicationFolders())) {\n            // Check to see if the first part is an application\n            $this->_ApplicationFolder = $Parts[0];\n            $this->_MapParts($Parts, 1);\n            $Found = $this->_FetchController();\n         }\n         if (!$Found) {\n            // echo '<div>Failed. AppFolder: '.$this->_ApplicationFolder.'; Cont Folder: '.$this->_ControllerFolder.'; Cont: '.$this->_ControllerName.';</div>';\n            // Check to see if the first part is a controller folder\n            $this->_ApplicationFolder = '';\n            $this->_ControllerFolder = $Parts[0];\n            $this->_MapParts($Parts, 1);\n            if (!$this->_FetchController()) {\n               // echo '<div>Failed. AppFolder: '.$this->_ApplicationFolder.'; Cont Folder: '.$this->_ControllerFolder.'; Cont: '.$this->_ControllerName.';</div>';\n               $this->_AnalyzeRequest($Request, 0);\n            }\n         }\n      }\n   }\n\n   /**\n    * Searches through the /cache/controller_mappings.php file for the requested\n    * controller. If it doesn't find it, it searches through the entire\n    * application's folders for the requested controller. If it finds the\n    * controller, it adds the mapping to /cache/controller_mappings.php so it\n    * won't need to search again. If it doesn't find the controller file\n    * anywhere, it throws a fatal error.\n    *\n    * @param boolean $ThrowErrorOnFailure\n    * @todo $ThrowErrorOnFailure needs a description.\n    */\n   private function _FetchController($ThrowErrorOnFailure = FALSE) {\n      $ControllerWhiteList = $this->EnabledApplicationFolders();\n      // Don't include it if it's already been included\n      if (!class_exists($this->ControllerName())) {\n         $PathParts = array('controllers');\n         if ($this->_ControllerFolder != '')\n            $PathParts[] = $this->_ControllerFolder;\n\n         $PathParts[] = 'class.'.strtolower($this->_ControllerName).'controller.php';\n         $ControllerFileName = CombinePaths($PathParts);\n\n         // Limit the white list to the specified application folder if it was in the request\n         if ($this->_ApplicationFolder != '' && InArrayI($this->_ApplicationFolder, $ControllerWhiteList))\n            $ControllerWhiteList = array($this->_ApplicationFolder);\n\n         $ControllerPath = Gdn_FileSystem::FindByMapping('controller', PATH_APPLICATIONS, $ControllerWhiteList, $ControllerFileName);\n         if ($ControllerPath !== FALSE) {\n            // Strip the \"Application Folder\" from the controller path (this is\n            // used by the controller for various purposes. ie. knowing which\n            // application to search in for a view file).\n            $this->_ApplicationFolder = explode(DS, str_replace(PATH_APPLICATIONS . DS, '', $ControllerPath));\n            $this->_ApplicationFolder = $this->_ApplicationFolder[0];\n            $AppControllerName = ucfirst(strtolower($this->_ApplicationFolder)).'Controller';\n\n            // Load the application's master controller\n            if (!class_exists($AppControllerName))\n               require_once(CombinePaths(array(PATH_APPLICATIONS, $this->_ApplicationFolder, 'controllers', 'class.'.strtolower($this->_ApplicationFolder).'controller.php')));\n\n            // Now load the library (no need to check for existence - couldn't\n            // have made it here if it didn't exist).\n            require_once($ControllerPath);\n         }\n      }\n      if (!class_exists($this->ControllerName())) {\n         if ($ThrowErrorOnFailure === TRUE) {\n            if (ForceBool(Gdn::Config('Garden.Debug'))) {\n               trigger_error(ErrorMessage('Controller not found: '.$this->ControllerName(), 'Dispatcher', '_FetchController'), E_USER_ERROR);\n            } else {\n               $MissingRoute = Gdn::Router()->GetRoute('Default404');\n            \n               // Return a 404 message\n               list($this->_ApplicationFolder, $this->_ControllerName, $this->_ControllerMethod) = explode('/', $MissingRoute['Destination']);\n               $ControllerFileName = CombinePaths(array('controllers', 'class.' . strtolower($this->_ControllerName) . 'controller.php'));\n               $ControllerPath = Gdn_FileSystem::FindByMapping('controller', PATH_APPLICATIONS, $ControllerWhiteList, $ControllerFileName);\n               $this->_ApplicationFolder = explode(DS, str_replace(PATH_APPLICATIONS . DS, '', $ControllerPath));\n               $this->_ApplicationFolder = $this->_ApplicationFolder[0];\n               require_once(CombinePaths(array(PATH_APPLICATIONS, $this->_ApplicationFolder, 'controllers', 'class.'.strtolower($this->_ApplicationFolder).'controller.php')));\n               require_once($ControllerPath);\n            }\n         }\n         return FALSE;\n      } else {\n         return TRUE;\n      }\n   }\n   \n   /**\n    * An internal method used to map parts of the request to various properties\n    * of this object that represent the controller, controller method, and\n    * controller method arguments.\n    *\n    * @param array $Parts An array of parts of the request.\n    * @param int $ControllerKey An integer representing the key of the controller in the $Parts array.\n    */\n   private function _MapParts($Parts, $ControllerKey) {\n      $Length = count($Parts);\n      if ($Length > $ControllerKey)\n         $this->_ControllerName = ucfirst(strtolower($Parts[$ControllerKey]));\n\n      if ($Length > $ControllerKey + 1)\n         $this->_ControllerMethod = $Parts[$ControllerKey + 1];\n\n      if ($Length > $ControllerKey + 2) {\n         for ($i = $ControllerKey + 2; $i < $Length; ++$i) {\n            if ($Parts[$i] != '')\n               $this->_ControllerMethodArgs[] = $Parts[$i];\n\n         }\n      }\n   }\n\n   /**\n    * Set up the dispatch defaults.\n    */\n   protected function _SetControllerMethod($Controller) {\n      // Start with the controller name.\n      $ControllerName = $Controller->ControllerName;\n      if (StringEndsWith($ControllerName, 'controller', TRUE))\n         $ControllerName = substr($ControllerName, 0, -10);\n\n      // Figure out the method from the api.\n      $PathParts = explode('/', trim($Controller->Request->Path(), '/'));\n\n      foreach ($PathParts as $Part) {\n         $Curr = array_shift($PathParts);\n         if (strcasecmp($Curr, $ControllerName) == 0) {\n            break;\n         }\n      }\n\n      // We've gotten rid of the controller so the next part is the method.\n      if (count($PathParts) == 0)\n         return FALSE;\n      $MethodName = array_shift($PathParts);\n      $DeliveryMethod = strstr($MethodName, '.');\n\n      if ($DeliveryMethod !== FALSE) {\n         $DeliveryMethod = strtoupper(trim($DeliveryMethod, '.'));\n         switch ($DeliveryMethod) {\n            case DELIVERY_METHOD_JSON:\n            case DELIVERY_METHOD_XML:\n               // The extension was recognized.\n               $Controller->DeliveryMethod($DeliveryMethod);\n               $MethodName = ucfirst(substr($MethodName, 0, -(strlen($DeliveryMethod) + 1)));\n               $Controller->DeliveryType(DELIVERY_TYPE_DATA);\n               $Controller->RequestMethod = $MethodName;\n               $Controller->OriginalRequestMethod = strtolower($MethodName);\n\n               if (!method_exists($Controller, $MethodName)) {\n                  throw new Exception(sprintf(T('Method does not exist: %s.'), get_class($Controller).'::'.$MethodName.'()'), 404);\n               }\n\n               $Meth = new ReflectionMethod($Controller, $MethodName);\n               $MethParams = $Meth->getParameters();\n               $Params = array();\n               $Get = array_change_key_case($Controller->Request->GetRequestArguments(Gdn_Request::INPUT_GET));\n               $MissingParams = array();\n\n               // Set all of the parameters.\n               foreach ($MethParams as $Index => $MethParam) {\n                  $ParamName = strtolower($MethParam->getName());\n\n                  if (isset($PathParts[$Index]))\n                     $Params[] = $PathParts[$Index];\n                  elseif (isset($Get[$ParamName]))\n                     $Params[] = $Get[$ParamName];\n                  elseif ($MethParam->isDefaultValueAvailable())\n                     $Params[] = $MethParam->getDefaultValue();\n                  else\n                     $MissingParams[] = \"$Index: $ParamName\";\n               }\n\n               if (count($MissingParams) > 0)\n                  throw new Exception(sprintf(T('Missing required parameters: %s.'), implode(', ', $MissingParams)), 400);\n\n               // Call the method.\n               //call_user_func_array(array($Controller, $MethodName), $Params);\n               $this->_ControllerMethodArgs = $Params;\n\n               break;\n            default:\n               return FALSE;\n         }\n      } else {\n         return FALSE;\n      }\n      return TRUE;\n   }\n}"], "fixing_code": ["<?php if (!defined('APPLICATION')) exit();\n/*\nCopyright 2008, 2009 Vanilla Forums Inc.\nThis file is part of Garden.\nGarden is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\nGarden is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with Garden.  If not, see <http://www.gnu.org/licenses/>.\nContact Vanilla Forums Inc. at support [at] vanillaforums [dot] com\n*/\n\nclass EntryController extends Gdn_Controller {\n   \n   // Make sure the database class is loaded (class.controller.php takes care of this).\n   public $Uses = array('Database', 'Form', 'UserModel');\n\tconst UsernameError = 'Username can only contain letters, numbers, underscores, and must be between 3 and 20 characters long.';\n   \n   public function Auth($AuthenticationSchemeAlias = 'default') {\n      $this->EventArguments['AuthenticationSchemeAlias'] = $AuthenticationSchemeAlias;\n      $this->FireEvent('BeforeAuth');\n      \n      // Allow hijacking auth type\n      $AuthenticationSchemeAlias = $this->EventArguments['AuthenticationSchemeAlias'];\n      \n      try {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith($AuthenticationSchemeAlias);\n      } catch (Exception $e) {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith('default');\n      }\n      \n      // Set up controller\n      $this->View = 'auth/'.$Authenticator->GetAuthenticationSchemeAlias();\n      $this->Form->SetModel($this->UserModel);\n      $this->Form->AddHidden('ClientHour', date('G', time())); // Use the server's current hour as a default\n      $this->Form->AddHidden('Target', GetIncomingValue('Target', ''));\n\n      // Import authenticator data source\n      switch ($Authenticator->DataSourceType()) {\n         case Gdn_Authenticator::DATA_FORM:\n            $Authenticator->FetchData($this->Form);\n         break;\n         \n         case Gdn_Authenticator::DATA_REQUEST:\n         case Gdn_Authenticator::DATA_COOKIE:\n            $Authenticator->FetchData(Gdn::Request());\n         break;\n      }\n      \n      // By default, just render the view\n      $Reaction = Gdn_Authenticator::REACT_RENDER;\n      \n      // Where are we in the process? Still need to gather (render view) or are we validating?\n      $AuthenticationStep = $Authenticator->CurrentStep();\n      \n      switch ($AuthenticationStep) {\n      \n         // User is already logged in\n         case Gdn_Authenticator::MODE_REPEAT:\n            $Reaction = $Authenticator->RepeatResponse();\n         break;\n            \n         // Not enough information to perform authentication, render input form\n         case Gdn_Authenticator::MODE_GATHER:\n            $this->AddJsFile('entry.js');\n            $Reaction = $Authenticator->LoginResponse();\n\t\t\t\tif ($this->Form->IsPostBack())\n\t\t\t\t\t$this->Form->AddError('ErrorCredentials');\n         break;\n         \n         // All information is present, authenticate\n         case Gdn_Authenticator::MODE_VALIDATE:\n            \n            // Attempt to authenticate.\n            try {\n               $AuthenticationResponse = $Authenticator->Authenticate();\n               Gdn::Authenticator()->Trigger($AuthenticationResponse);\n               switch ($AuthenticationResponse) {\n                  case Gdn_Authenticator::AUTH_PERMISSION:\n                     $this->Form->AddError('ErrorPermission');\n                     $Reaction = $Authenticator->FailedResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_DENIED:\n                     $this->Form->AddError('ErrorCredentials');\n                     $Reaction = $Authenticator->FailedResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_INSUFFICIENT:\n                     // Unable to comply with auth request, more information is needed from user.\n                     $this->Form->AddError('ErrorInsufficient');\n                     $Reaction = $Authenticator->FailedResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_PARTIAL:\n                     // Partial auth completed.\n                     $Reaction = $Authenticator->PartialResponse();\n                  break;\n\n                  case Gdn_Authenticator::AUTH_SUCCESS:\n                  default: \n                     // Full auth completed.\n                     $UserID = $AuthenticationResponse;\n                     $Reaction = $Authenticator->SuccessResponse();\n               }\n            } catch (Exception $Ex) {\n               $this->Form->AddError($Ex);\n            }\n         break;\n         \n         case Gdn_Authenticator::MODE_NOAUTH:\n            $Reaction = Gdn_Authenticator::REACT_REDIRECT;\n         break;\n      }\n      \n      // AddActivity($AuthenticatedUserID, 'SignIn');\n      switch ($Reaction) {\n      \n         case Gdn_Authenticator::REACT_RENDER:\n            // Do nothing (render the view)\n         break;\n      \n         case Gdn_Authenticator::REACT_EXIT:\n            exit();\n         break;\n      \n         case Gdn_Authenticator::REACT_REMOTE:\n            // Let the authenticator handle generating output, using a blank slate\n            $this->_DeliveryType= DELIVERY_TYPE_VIEW;\n            \n            exit;\n         break;\n         \n         case Gdn_Authenticator::REACT_REDIRECT:\n         default:\n         \n            if (is_string($Reaction))\n               $Route = $Reaction;\n            else\n               $Route = $this->RedirectTo();\n            \n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               \n               if ($Route !== FALSE) {\n                  Redirect($Route);\n               } else {\n                  Redirect(Gdn::Router()->GetDestination('DefaultController'));\n               }\n            }\n         break;\n      }\n      \n      $this->SetData('SendWhere', \"/entry/auth/{$AuthenticationSchemeAlias}\");\n      $this->Render();\n   }\n      \n   public function Index() {\n      $this->SignIn();\n   }\n   \n   public function Password() {\n      $this->Auth('password');\n   }\n   \n   public function SignIn() {\n      $this->FireEvent(\"SignIn\");\n      $this->Auth('default');\n   }\n\n   public function SignOut($TransientKey = \"\") {\n      $SessionAuthenticator = Gdn::Session()->GetPreference('Authenticator');\n      $AuthenticationScheme = ($SessionAuthenticator) ? $SessionAuthenticator : 'default';\n\n      try {\n         $Authenticator = Gdn::Authenticator()->GetAuthenticator($AuthenticationScheme);\n      } catch (Exception $e) {\n         $Authenticator = Gdn::Authenticator()->GetAuthenticator();\n      }\n   \n      $this->FireEvent(\"SignOut\");\n      $this->Leave($AuthenticationScheme, $TransientKey);\n   }\n  \n   /** A version of signin that supports multiple authentication methods.\n    *  This method should replace EntryController::SignIn() eventually.\n    *\n    * @param string $Method\n    */\n   public function SignIn2($SelectedMethod = FALSE) {\n      // Set up the initial methods. Other methods can be added by plugins.\n      $Methods = array(\n         'password' => array('Label' => 'Vanilla', 'Url' => Url('/entry/auth/password'), 'ViewLocation' => $this->FetchViewLocation('SignIn'))\n      );\n\n      // Make sure a valid method is chosen.\n      if (!array_key_exists((string)$SelectedMethod, $Methods)) {\n         $SelectedMethod = array_shift(array_keys($Methods));\n      }\n      \n      $this->SetData('SelectedMethod', $SelectedMethod);\n      $this->SetData('Methods', $Methods);\n\n      return $this->Render();\n   }\n   \n   public function Handshake($AuthenticationSchemeAlias = 'default') {\n      \n      try {\n         // Don't show anything if handshaking not turned on by an authenticator\n   \t\tif (!Gdn::Authenticator()->CanHandshake())\n   \t\t\tthrow new Exception();\n         \n         // Try to load the authenticator\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith($AuthenticationSchemeAlias);\n         \n         // Try to grab the authenticator data\n         $Payload = $Authenticator->GetHandshake();\n         if ($Payload === FALSE) {\n            Gdn::Request()->WithURI('dashboard/entry/auth/password');\n            return Gdn::Dispatcher()->Dispatch();\n         }\n      } catch (Exception $e) {\n         Gdn::Request()->WithURI('/entry/signin');\n         return Gdn::Dispatcher()->Dispatch();\n      }\n      \n      $UserInfo = array(\n         'UserKey'      => $Authenticator->GetUserKeyFromHandshake($Payload),\n         'ConsumerKey'  => $Authenticator->GetProviderKeyFromHandshake($Payload),\n         'TokenKey'     => $Authenticator->GetTokenKeyFromHandshake($Payload),\n         'UserName'     => $Authenticator->GetUserNameFromHandshake($Payload),\n         'UserEmail'    => $Authenticator->GetUserEmailFromHandshake($Payload)\n      );\n      \n      // Manual user sync is disabled. No hand holding will occur for users.\n      $SyncScreen = C('Garden.Authenticator.SyncScreen', 'on');\n      switch ($SyncScreen) {\n         case 'on':\n         \n            $this->SyncScreen($Authenticator, $UserInfo, $Payload);\n            \n         break;\n         \n         case 'off':\n         case 'smart':\n            $UserID = $this->UserModel->Synchronize($UserInfo['UserKey'], array(\n               'Name'   => $UserInfo['UserName'],\n               'Email'  => $UserInfo['UserEmail']\n            ));\n            \n            if ($UserID > 0) {\n               // Account created successfully.\n               \n               // Finalize the link between the forum user and the foreign userkey\n               $Authenticator->Finalize($UserInfo['UserKey'], $UserID, $UserInfo['ConsumerKey'], $UserInfo['TokenKey'], $Payload);\n               \n               /// ... and redirect them appropriately\n               $Route = $this->RedirectTo();\n               if ($Route !== FALSE)\n                  Redirect($Route);\n               else\n                  Redirect('/');\n                  \n            } else {\n               // Account not created.\n               if ($SyncScreen == 'smart') {\n               \n                  $this->StatusMessage = T('There is already an account in this forum using your email address. Please create a new account, or enter the credentials for the existing account.');\n                  $this->SyncScreen($Authenticator, $UserInfo, $Payload);\n                  \n               } else {\n                  \n                  // Set the memory cookie to allow signinloopback to shortcircuit remote query.\n                  $CookiePayload = array(\n                     'Sync'   => 'Failed'\n                  );\n                  $SerializedCookiePayload = Gdn_Format::Serialize($CookiePayload);\n                  $Authenticator->Remember($UserInfo['ConsumerKey'], $SerializedCookiePayload);\n                  \n                  // This resets vanilla's internal \"where am I\" to the homepage. Needed.\n                  Gdn::Request()->WithRoute('DefaultController');\n                  $this->SelfUrl = Url('');//Gdn::Request()->Path();\n                  \n                  $this->View = 'syncfailed';\n                  $this->ProviderSite = $Authenticator->GetProviderUrl();\n                  $this->Render();\n               }\n               \n            }\n         break;\n      \n      }\n   }\n   \n   public function SyncScreen($Authenticator, $UserInfo, $Payload) {\n      $this->AddJsFile('entry.js');\n      $this->View = 'handshake';\n      $this->HandshakeScheme = $Authenticator->GetAuthenticationSchemeAlias();\n      $this->Form->SetModel($this->UserModel);\n      $this->Form->AddHidden('ClientHour', date('G', time())); // Use the server's current hour as a default\n      $this->Form->AddHidden('Target', GetIncomingValue('Target', '/'));\n      \n      $PreservedKeys = array(\n         'UserKey', 'Token', 'Consumer', 'Email', 'Name', 'Gender', 'HourOffset'\n      );\n      $UserID = 0;\n      $Target = GetIncomingValue('Target', '/');\n   \n      if ($this->Form->IsPostBack() === TRUE) {\n            \n         $FormValues = $this->Form->FormValues();\n         if (ArrayValue('StopLinking', $FormValues)) {\n         \n            $Authenticator->DeleteCookie();\n            Gdn::Request()->WithRoute('DefaultController');\n            return Gdn::Dispatcher()->Dispatch();\n            \n         } elseif (ArrayValue('NewAccount', $FormValues)) {\n         \n            // Try and synchronize the user with the new username/email.\n            $FormValues['Name'] = $FormValues['NewName'];\n            $FormValues['Email'] = $FormValues['NewEmail'];\n            $UserID = $this->UserModel->Synchronize($UserInfo['UserKey'], $FormValues);\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n            \n         } else {\n   \n            // Try and sign the user in.\n            $PasswordAuthenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $PasswordAuthenticator->HookDataField('Email', 'SignInEmail');\n            $PasswordAuthenticator->HookDataField('Password', 'SignInPassword');\n            $PasswordAuthenticator->FetchData($this->Form);\n            \n            $UserID = $PasswordAuthenticator->Authenticate();\n            \n            if ($UserID < 0) {\n               $this->Form->AddError('ErrorPermission');\n            } else if ($UserID == 0) {\n               $this->Form->AddError('ErrorCredentials');\n            }\n            \n            if ($UserID > 0) {\n               $Data = $FormValues;\n               $Data['UserID'] = $UserID;\n               $Data['Email'] = ArrayValue('SignInEmail', $FormValues, '');\n               $UserID = $this->UserModel->Synchronize($UserInfo['UserKey'], $Data);\n            }\n         }\n         \n         if ($UserID > 0) {\n            // The user has been created successfully, so sign in now\n            \n            // Finalize the link between the forum user and the foreign userkey\n            $Authenticator->Finalize($UserInfo['UserKey'], $UserID, $UserInfo['ConsumerKey'], $UserInfo['TokenKey'], $Payload);\n            \n            /// ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($Route !== FALSE)\n               Redirect($Route);\n         } else {\n            // Add the hidden inputs back into the form.\n            foreach($FormValues as $Key => $Value) {\n               if (in_array($Key, $PreservedKeys))\n                  $this->Form->AddHidden($Key, $Value);\n            }\n         }\n      } else {\n         $Id = Gdn::Authenticator()->GetIdentity(TRUE);\n         if ($Id > 0) {\n            // The user is signed in so we can just go back to the homepage.\n            Redirect($Target);\n         }\n         \n         $Name = $UserInfo['UserName'];\n         $Email = $UserInfo['UserEmail'];\n         \n         // Set the defaults for a new user.\n         $this->Form->SetFormValue('NewName', $Name);\n         $this->Form->SetFormValue('NewEmail', $Email);\n         \n         // Set the default for the login.\n         $this->Form->SetFormValue('SignInEmail', $Email);\n         $this->Form->SetFormValue('Handshake', 'NEW');\n         \n         // Add the handshake data as hidden fields.\n         $this->Form->AddHidden('Name',       $Name);\n         $this->Form->AddHidden('Email',      $Email);\n         $this->Form->AddHidden('UserKey',    $UserInfo['UserKey']);\n         $this->Form->AddHidden('Token',      $UserInfo['TokenKey']);\n         $this->Form->AddHidden('Consumer',   $UserInfo['ConsumerKey']);\n         \n      }\n      \n      $this->SetData('Name', ArrayValue('Name', $this->Form->HiddenInputs));\n      $this->SetData('Email', ArrayValue('Email', $this->Form->HiddenInputs));\n      \n      $this->Render();\n   }\n   \n   /**\n    * Calls the appropriate registration method based on the configuration setting.\n    */\n   public function Register($InvitationCode = '') {\n      $this->Form->SetModel($this->UserModel);\n\n      // Define gender dropdown options\n      $this->GenderOptions = array(\n         'm' => T('Male'),\n         'f' => T('Female')\n      );\n\n      // Make sure that the hour offset for new users gets defined when their account is created\n      $this->AddJsFile('entry.js');\n         \n      $this->Form->AddHidden('ClientHour', date('G', time())); // Use the server's current hour as a default\n      $this->Form->AddHidden('Target', GetIncomingValue('Target', ''));\n\n      $RegistrationMethod = $this->_RegistrationView();\n      $this->View = $RegistrationMethod;\n      $this->$RegistrationMethod($InvitationCode);\n   }\n   \n   protected function _RegistrationView() {\n      $RegistrationMethod = Gdn::Config('Garden.Registration.Method');\n      if (!in_array($RegistrationMethod, array('Closed', 'Basic','Captcha','Approval','Invitation')))\n         $RegistrationMethod = 'Basic';\n         \n      return 'Register'.$RegistrationMethod;\n   }\n   \n   private function RegisterApproval() {\n      // If the form has been posted back...\n      if ($this->Form->IsPostBack()) {\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         $this->UserModel->Validation->ApplyRule('DiscoveryText', 'Required', 'Tell us why you want to join!');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForApproval($this->Form->FormValues()))\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n         else\n            $this->View = \"RegisterThanks\"; // Tell the user their application will be reviewed by an administrator.\n      }\n      $this->Render();\n   }\n   \n   private function RegisterBasic() {\n      if ($this->Form->IsPostBack() === TRUE) {\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForBasic($this->Form->FormValues())) {\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n         } else {\n            // The user has been created successfully, so sign in now\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($this->Form);\n            $AuthUserID = $Authenticator->Authenticate();\n            \n            // ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE)\n                  Redirect($Route);\n            }\n         }\n      }\n      $this->Render();\n   }\n   \n   private function RegisterCaptcha() {\n      include(CombinePaths(array(PATH_LIBRARY, 'vendors/recaptcha', 'functions.recaptchalib.php')));\n      if ($this->Form->IsPostBack() === TRUE) {\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForBasic($this->Form->FormValues())) {\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n            if($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->_DeliveryType = DELIVERY_TYPE_MESSAGE;\n            }\n         } else {\n            // The user has been created successfully, so sign in now\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($this->Form);\n            $AuthUserID = $Authenticator->Authenticate();\n            \n            // ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE)\n                  Redirect($Route);\n            }\n         }\n      }\n      $this->Render();\n   }\n   \n   private function RegisterClosed() {\n      $this->Render();\n   }\n   \n   private function RegisterInvitation($InvitationCode) {\n      if ($this->Form->IsPostBack() === TRUE) {\n         $this->InvitationCode = $this->Form->GetValue('InvitationCode');\n         // Add validation rules that are not enforced by the model\n         $this->UserModel->DefineSchema();\n         $this->UserModel->Validation->ApplyRule('Name', 'Username', self::UsernameError);\n         $this->UserModel->Validation->ApplyRule('TermsOfService', 'Required', 'You must agree to the terms of service.');\n         $this->UserModel->Validation->ApplyRule('Password', 'Required');\n         $this->UserModel->Validation->ApplyRule('Password', 'Match');\n         // $this->UserModel->Validation->ApplyRule('DateOfBirth', 'MinimumAge');\n         \n         if (!$this->UserModel->InsertForInvite($this->Form->FormValues())) {\n            $this->Form->SetValidationResults($this->UserModel->ValidationResults());\n         } else {\n            // The user has been created successfully, so sign in now\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($this->Form);\n            $AuthUserID = $Authenticator->Authenticate();\n            \n            // ... and redirect them appropriately\n            $Route = $this->RedirectTo();\n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE)\n                  Redirect($Route);\n            }\n         }\n      } else {\n         $this->InvitationCode = $InvitationCode;\n      }\n      $this->Render();      \n   }\n   \n   public function PasswordRequest() {\n      $this->Form->SetModel($this->UserModel);\n      if ($this->Form->IsPostBack() === TRUE) {\n\n         if ($this->Form->ValidateModel() == 0) {\n            try {\n               if (!$this->UserModel->PasswordRequest($this->Form->GetFormValue('Email', ''))) {\n                  $this->Form->AddError(\"Couldn't find an account associated with that email address.\");\n               }\n            } catch (Exception $ex) {\n               $this->Form->AddError($ex->getMessage());\n            }\n            if ($this->Form->ErrorCount() == 0) {\n               $this->Form->AddError('Success!');\n               $this->View = 'passwordrequestsent';\n            }\n         } else {\n            if ($this->Form->ErrorCount() == 0)\n               $this->Form->AddError('That email address was not found.');\n         }\n      }\n      $this->Render();\n   }\n\n   public function PasswordReset($UserID = '', $PasswordResetKey = '') {\n      if (!is_numeric($UserID)\n          || $PasswordResetKey == ''\n          || $this->UserModel->GetAttribute($UserID, 'PasswordResetKey', '') != $PasswordResetKey\n         ) $this->Form->AddError('Failed to authenticate your password reset request. Try using the reset request form again.');\n      \n      if ($this->Form->ErrorCount() == 0\n         && $this->Form->IsPostBack() === TRUE\n      ) {\n         $Password = $this->Form->GetFormValue('Password', '');\n         $Confirm = $this->Form->GetFormValue('Confirm', '');\n         if ($Password == '')\n            $this->Form->AddError('Your new password is invalid');\n         else if ($Password != $Confirm)\n            $this->Form->AddError('Your passwords did not match.');\n\n         if ($this->Form->ErrorCount() == 0) {\n            $User = $this->UserModel->PasswordReset($UserID, $Password);\n            $Authenticator = Gdn::Authenticator()->AuthenticateWith('password');\n            $Authenticator->FetchData($Authenticator, array('Email' => $User->Email, 'Password' => $Password, 'RememberMe' => FALSE));\n            $AuthUserID = $Authenticator->Authenticate();\n\t\t\t\tRedirect('/');\n         }\n      }\n      $this->Render();\n   }\n\n   public function EmailConfirm($UserID = '', $EmailKey = '') {\n      if (!is_numeric($UserID) || $EmailKey != $this->UserModel->GetAttribute($UserID, 'EmailKey', '')) {\n         $this->Form->AddError(T('Couldn\\'t confirm email.',\n            'We couldn\\'t confirm your email. Check the link in the email we sent you or try sending another confirmation email.'));\n      }\n\n      if ($this->Form->ErrorCount() == 0) {\n         \n\n      }\n      $this->Render();\n   }\n\n   public function Leave($AuthenticationSchemeAlias = 'default', $TransientKey = '') {\n      $this->EventArguments['AuthenticationSchemeAlias'] = $AuthenticationSchemeAlias;\n      $this->FireEvent('BeforeLeave');\n      \n      // Allow hijacking deauth type\n      $AuthenticationSchemeAlias = $this->EventArguments['AuthenticationSchemeAlias'];\n      \n      try {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith($AuthenticationSchemeAlias);\n      } catch (Exception $e) {\n         $Authenticator = Gdn::Authenticator()->AuthenticateWith('default');\n      }\n      \n      // Only sign the user out if this is an authenticated postback! Start off pessimistic\n      $this->Leaving = FALSE;\n      $Result = Gdn_Authenticator::REACT_RENDER;\n      \n      // Build these before doing anything desctructive as they are supposed to have user context\n      $LogoutResponse = $Authenticator->LogoutResponse();\n      $LoginResponse = $Authenticator->LoginResponse();\n      \n      $AuthenticatedPostbackRequired = $Authenticator->RequireLogoutTransientKey();\n      if (!$AuthenticatedPostbackRequired || Gdn::Session()->ValidateTransientKey($TransientKey)) {\n         $Result = $Authenticator->DeAuthenticate();\n         $this->Leaving = TRUE;\n      }\n      \n      if ($Result == Gdn_Authenticator::AUTH_SUCCESS) {\n         $this->View = 'leave';\n         $Reaction = $LogoutResponse;\n      } else {\n         $this->View = 'auth/'.$Authenticator->GetAuthenticationSchemeAlias();\n         $Reaction = $LoginResponse;\n      }\n      \n      switch ($Reaction) {\n         case Gdn_Authenticator::REACT_RENDER:\n            \n         break;\n\n         case Gdn_Authenticator::REACT_EXIT:\n            exit();\n         break;\n\n         case Gdn_Authenticator::REACT_REMOTE:\n            // Render the view, but set the delivery type to VIEW\n            $this->_DeliveryType= DELIVERY_TYPE_VIEW;\n         break;\n\n         case Gdn_Authenticator::REACT_REDIRECT:\n         default:\n            // If we're just told to redirect, but not where... try to figure out somewhere that makes sense.\n            if ($Reaction == Gdn_Authenticator::REACT_REDIRECT) {\n               $Route = '/';\n               $Target = GetIncomingValue('Target', NULL);\n               if (!is_null($Target)) \n                  $Route = $Target;\n            } else {\n               $Route = $Reaction;\n            }\n            \n            if ($this->_DeliveryType != DELIVERY_TYPE_ALL) {\n               $this->RedirectUrl = Url($Route);\n            } else {\n               if ($Route !== FALSE) {\n                  Redirect($Route);\n               } else {\n                  Redirect(Gdn::Router()->GetDestination('DefaultController'));\n               }\n            }\n         break;\n      }\n      \n      $this->Render();\n   }\n   \n   public function RedirectTo() {\n      $IncomingTarget = $this->Form->GetValue('Target', '');\n      return $IncomingTarget == '' ? Gdn::Router()->GetDestination('DefaultController') : $IncomingTarget;\n   }\n   \n   public function Initialize() {\n      $this->Head = new HeadModule($this);\n      $this->AddJsFile('jquery.js');\n      $this->AddJsFile('jquery.livequery.js');\n      $this->AddJsFile('jquery.form.js');\n      $this->AddJsFile('jquery.popup.js');\n      $this->AddJsFile('jquery.gardenhandleajaxform.js');\n      $this->AddJsFile('global.js');\n      \n      $this->AddCssFile('style.css');\n      parent::Initialize();\n   }\n\n}\n", "<?php if (!defined('APPLICATION')) exit();\n/*\nCopyright 2008, 2009 Vanilla Forums Inc.\nThis file is part of Garden.\nGarden is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\nGarden is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with Garden.  If not, see <http://www.gnu.org/licenses/>.\nContact Vanilla Forums Inc. at support [at] vanillaforums [dot] com\n*/\n\n/**\n * Dispatcher handles all requests.\n *\n * @author Mark O'Sullivan\n * @copyright 2003 Mark O'Sullivan\n * @license http://www.opensource.org/licenses/gpl-2.0.php GPL\n * @package Garden\n * @version @@GARDEN-VERSION@@\n * @namespace Garden.Core\n */\n\nclass Gdn_Dispatcher extends Gdn_Pluggable {\n\n   /**\n    * An array of folders within the application that are OK to search through\n    * for controllers. This property is filled by the applications array\n    * located in /conf/applications.php and included in /bootstrap.php\n    *\n    * @var array\n    */\n   private $_EnabledApplicationFolders;\n\n   /**\n    * An associative array of ApplicationName => ApplicationFolder. This\n    * property is filled by the applications array located in\n    * /conf/applications.php and included in /bootstrap.php\n    *\n    * @var array\n    */\n   private $_EnabledApplications;\n\n   /**\n    * The currently requested url (defined in _AnalyzeRequest)\n    *\n    * @var string\n    */\n   public $Request;\n\n   /**\n    * The name of the application folder that contains the controller that has\n    * been requested.\n    *\n    * @var string\n    */\n   private $_ApplicationFolder;\n\n   /**\n    * An associative collection of AssetName => Strings that will get passed\n    * into the controller once it has been instantiated.\n    *\n    * @var array\n    */\n   private $_AssetCollection;\n\n   /**\n    * The name of the controller folder that contains the controller that has\n    * been requested.\n    *\n    * @var string\n    */\n   private $_ControllerFolder;\n\n   /**\n    * The name of the controller to be dispatched.\n    *\n    * @var string\n    */\n   private $_ControllerName;\n\n   /**\n    * The method of the controller to be called.\n    *\n    * @var string\n    */\n   private $_ControllerMethod;\n\n   /**\n    * Any query string arguments supplied to the controller method.\n    *\n    * @var string\n    */\n   private $_ControllerMethodArgs = array();\n\n   /**\n    * An associative collection of variables that will get passed into the\n    * controller as properties once it has been instantiated.\n    *\n    * @var array\n    */\n   private $_PropertyCollection;\n\n   /**\n    * Defined by the url of the request: SYNDICATION_RSS, SYNDICATION_ATOM, or\n    * SYNDICATION_NONE (default).\n    *\n    * @var string\n    */\n   private $_SyndicationMethod;\n\n   /**\n    * Class constructor.\n    */\n   public function __construct() {\n      parent::__construct();\n      $this->_EnabledApplicationFolders = array();\n      $this->Request = '';\n      $this->_ApplicationFolder = '';\n      $this->_AssetCollection = array();\n      $this->_ControllerFolder = '';\n      $this->_ControllerName = '';\n      $this->_ControllerMethod = '';\n      $this->_ControllerMethodArgs = array();\n      $this->_PropertyCollection = array();\n   }\n   \n   public function Cleanup() {\n      // Destruct the db connection;\n      $Database = Gdn::Database();\n      if($Database != null)\n         $Database->CloseConnection();\n   }\n\n\n   /**\n    * Return the properly formatted controller class name.\n    */\n   public function ControllerName() {\n      return $this->_ControllerName.'Controller';\n   }\n   \n   public function Application() {\n      return $this->_ApplicationFolder;\n   }\n   \n   public function Controller() {\n      return $this->_ControllerName;\n   }\n   \n   public function ControllerMethod() {\n      return $this->_ControllerMethod;\n   }\n   \n   public function ControllerArguments() {\n      return $this->_ControllerMethodArgs;\n   }\n\n   /**\n    * Analyzes the supplied query string and decides how to dispatch the request.\n    */\n   public function Dispatch($ImportRequest = NULL, $Permanent = TRUE) {\n      if ($ImportRequest && is_string($ImportRequest))\n         $ImportRequest = Gdn_Request::Create()->FromEnvironment()->WithURI($ImportRequest);\n      \n      if (is_a($ImportRequest, 'Gdn_Request') && $Permanent) {\n         Gdn::Request($ImportRequest);\n      }\n      \n      $Request = is_a($ImportRequest, 'Gdn_Request') ? $ImportRequest : Gdn::Request();\n   \n      if (Gdn::Config('Garden.UpdateMode', FALSE)) {\n         if (!Gdn::Session()->CheckPermission('Garden.Settings.GlobalPrivs')) {\n            // Updatemode, and this user is not root admin\n            $Request->WithURI(Gdn::Router()->GetDestination('UpdateMode'));\n         }\n      }\n      \n      $this->FireEvent('BeforeDispatch');\n      $this->_AnalyzeRequest($Request);\n      \n      // Send user to login page if this is a private community\n      if (C('Garden.PrivateCommunity') && $this->ControllerName() != 'EntryController' && !Gdn::Session()->IsValid()) {\n         Redirect(Gdn::Authenticator()->SignInUrl($this->Request));\n         exit();\n      }\n         \n      /*\n      echo \"<br />Gdn::Request thinks: \".Gdn::Request()->Path();\n      echo \"<br />Gdn::Request also suggests: output=\".Gdn::Request()->OutputFormat().\", filename=\".Gdn::Request()->Filename();\n      echo '<br />Request: '.$this->Request;      \n      echo '<br />App folder: '.$this->_ApplicationFolder;\n      echo '<br />Controller folder: '.$this->_ControllerFolder;\n      echo '<br />ControllerName: '.$this->_ControllerName;\n      echo '<br />ControllerMethod: '.$this->_ControllerMethod;\n      */\n\n      $ControllerName = $this->ControllerName();\n      if ($ControllerName != '' && class_exists($ControllerName)) {\n         // Create it and call the appropriate method/action\n         $Controller = new $ControllerName();\n\n         // Pass along any assets\n         if (is_array($this->_AssetCollection)) {\n            foreach ($this->_AssetCollection as $AssetName => $Assets) {\n               foreach ($Assets as $Asset) {\n                  $Controller->AddAsset($AssetName, $Asset);\n               }\n            }\n         }\n\n         // Instantiate Imported & Uses classes\n         $Controller->GetImports();\n\n         // Pass in the syndication method\n         $Controller->SyndicationMethod = $this->_SyndicationMethod;\n\n         // Pass along the request\n         $Controller->SelfUrl = $this->Request;\n\n         // Pass along any objects\n         foreach($this->_PropertyCollection as $Name => $Mixed) {\n            $Controller->$Name = $Mixed;\n         }\n\n         // Set up a default controller method in case one isn't defined.\n         $ControllerMethod = str_replace('_', '', $this->_ControllerMethod);\n         $Controller->OriginalRequestMethod = $ControllerMethod;\n         \n         // Take enabled plugins into account, as well\n         $PluginManagerHasReplacementMethod = Gdn::PluginManager()->HasNewMethod($this->ControllerName(), $this->_ControllerMethod);\n         if (!$PluginManagerHasReplacementMethod && ($this->_ControllerMethod == '' || !method_exists($Controller, $ControllerMethod))) {\n            // Check to see if there is an 'x' version of the method.\n            if (method_exists($Controller, 'x'.$ControllerMethod)) {\n               // $PluginManagerHasReplacementMethod = TRUE;\n               $ControllerMethod = 'x'.$ControllerMethod;\n            } else {\n               if ($this->_ControllerMethod != '')\n                  array_unshift($this->_ControllerMethodArgs, $this->_ControllerMethod);\n               \n               $this->_ControllerMethod = 'Index';\n               $ControllerMethod = 'Index';\n               \n               $PluginManagerHasReplacementMethod = Gdn::PluginManager()->HasNewMethod($this->ControllerName(), $this->_ControllerMethod);\n            }\n         }\n         // Pass in the querystring values\n         $Controller->ApplicationFolder = $this->_ApplicationFolder;\n         $Controller->Application = $this->EnabledApplication();\n         $Controller->ControllerFolder = $this->_ControllerFolder;\n         $Controller->RequestMethod = $this->_ControllerMethod;\n         $Controller->RequestArgs = $this->_ControllerMethodArgs;\n         $Controller->Request = $Request;\n         $Controller->DeliveryType($Request->GetValue('DeliveryType', ''));\n         $Controller->DeliveryMethod($Request->GetValue('DeliveryMethod', ''));\n\n         // Set special controller method options for REST APIs.\n         $this->_SetControllerMethod($Controller);\n         \n         $Controller->Initialize();\n\n         // Call the requested method on the controller - error out if not defined.\n         if ($PluginManagerHasReplacementMethod || method_exists($Controller, $ControllerMethod)) {\n            // call_user_func_array is too slow!!\n            //call_user_func_array(array($Controller, $ControllerMethod), $this->_ControllerMethodArgs);\n            \n            if ($PluginManagerHasReplacementMethod) {\n              Gdn::PluginManager()->CallNewMethod($Controller, $Controller->ControllerName, $ControllerMethod);\n            } else { \n              $Args = $this->_ControllerMethodArgs;\n              $Count = count($Args);\n\n              try {\n                 call_user_func_array(array($Controller, $ControllerMethod), $Args);\n              } catch (Exception $Ex) {\n                 $Controller->RenderException($Ex);\n                 exit();\n              }\n            }\n         } else {\n            Gdn::Request()->WithRoute('Default404');\n            return $this->Dispatch();\n         }\n      }\n   }\n   \n   /**\n    * Undocumented method.\n    *\n    * @param string $EnabledApplications\n    * @todo Method EnabledApplicationFolders() and $EnabledApplications needs descriptions.\n    */\n   public function EnabledApplicationFolders($EnabledApplications = '') {\n      if ($EnabledApplications != '' && count($this->_EnabledApplicationFolders) == 0) {\n         $this->_EnabledApplications = $EnabledApplications;\n         $this->_EnabledApplicationFolders = array_values($EnabledApplications);\n      }\n      return $this->_EnabledApplicationFolders;\n   }\n\n   /**\n    * Returns the name of the enabled application based on $ApplicationFolder.\n    *\n    * @param string The application folder related to the application name you want to return.\n    */\n   public function EnabledApplication($ApplicationFolder = '') {\n      if ($ApplicationFolder == '')\n         $ApplicationFolder = $this->_ApplicationFolder;\n\n      $EnabledApplication = array_keys($this->_EnabledApplications, $ApplicationFolder);\n      $EnabledApplication = count($EnabledApplication) > 0 ? $EnabledApplication[0] : '';\n      $this->EventArguments['EnabledApplication'] = $EnabledApplication;\n      $this->FireEvent('AfterEnabledApplication');\n      return $EnabledApplication;\n   }\n\n   /**\n    * Allows the passing of a string to the controller's asset collection.\n    *\n    * @param string $AssetName The name of the asset collection to add the string to.\n    * @param mixed $Asset The string asset to be added. The asset can be one of two things.\n    * - <b>string</b>: The string will be rendered to the page.\n    * - <b>Gdn_IModule</b>: The Gdn_IModule::Render() method will be called when the asset is rendered.\n    */\n   public function PassAsset($AssetName, $Asset) {\n      $this->_AssetCollection[$AssetName][] = $Asset;\n   }\n\n   /**\n    * Allows the passing of any variable to the controller as a property.\n    *\n    * @param string $Name The name of the property to assign the variable to.\n    * @param mixed $Mixed The variable to be passed as a property of the controller.\n    */\n   public function PassProperty($Name, $Mixed) {\n      $this->_PropertyCollection[$Name] = $Mixed;\n   }\n\n   /**\n    * Parses the query string looking for supplied request parameters. Places\n    * anything useful into this object's Controller properties.\n    *\n    * @param int $FolderDepth\n    * @todo $folderDepth needs a description.\n    */\n   protected function _AnalyzeRequest(&$Request, $FolderDepth = 1) {\n      // Here is the basic format of a request:\n      // [/application]/controller[/method[.json|.xml]]/argn|argn=valn\n\n      // Here are some examples of what this method could/would receive:\n      // /application/controller/method/argn\n      // /controller/method/argn\n      // /application/controller/argn\n      // /controller/argn\n      // /controller\n\n\n      // Clear the slate\n      $this->_ApplicationFolder = '';\n      $this->_ControllerFolder = '';\n      $this->_ControllerName = '';\n      $this->_ControllerMethod = 'index';\n      $this->_ControllerMethodArgs = array();\n      $this->Request = Url('');//$Request->Path();\n\n      $PathAndQuery = $Request->PathAndQuery();\n      $MatchRoute = Gdn::Router()->MatchRoute($PathAndQuery);\n\n      // We have a route. Take action.\n      if ($MatchRoute !== FALSE) {\n         switch ($MatchRoute['Type']) {\n            case 'Internal':\n               $Request->PathAndQuery($MatchRoute['FinalDestination']);\n               $this->Request = $MatchRoute['FinalDestination'];\n               break;\n\n            case 'Temporary':\n               Header( \"HTTP/1.1 302 Moved Temporarily\" );\n               Header( \"Location: \".$MatchRoute['FinalDestination'] );\n               exit();\n               break;\n\n            case 'Permanent':\n               Header( \"HTTP/1.1 301 Moved Permanently\" );\n               Header( \"Location: \".$MatchRoute['FinalDestination'] );\n               exit();\n               break;\n\n            case 'NotFound':\n               Header( \"HTTP/1.1 404 Not Found\" );\n               $this->Request = $MatchRoute['FinalDestination'];\n               break;\n         }\n      }\n\n\n      switch ($Request->OutputFormat()) {\n         case 'rss':\n            $this->_SyndicationMethod = SYNDICATION_RSS;\n            break;\n         case 'atom':\n            $this->_SyndicationMethod = SYNDICATION_ATOM;\n            break;\n         case 'default':\n         default:\n            $this->_SyndicationMethod = SYNDICATION_NONE;\n            break;\n      }\n\n      if ($this->Request == '')\n      {\n         $DefaultController = Gdn::Router()->GetRoute('DefaultController');\n         $this->Request = $DefaultController['Destination'];\n      }\n   \n      $Parts = explode('/', $this->Request);\n      $Length = count($Parts);\n      if ($Length == 1 || $FolderDepth <= 0) {\n         $FolderDepth = 0;\n         $this->_ControllerName = $Parts[0];\n         $this->_MapParts($Parts, 0);\n         $this->_FetchController(TRUE); // Throw an error if this fails because there's nothing else to check\n      } else if ($Length == 2) {\n         // Force a depth of 1 because only one of the two url parts can be a folder.\n         $FolderDepth = 1;\n      }\n      if ($FolderDepth == 2) {\n         $this->_ApplicationFolder = $Parts[0];\n         $this->_ControllerFolder = $Parts[1];\n         $this->_MapParts($Parts, 2);\n\n         if (!$this->_FetchController()) {\n            // echo '<div>Failed. AppFolder: '.$this->_ApplicationFolder.'; Cont Folder: '.$this->_ControllerFolder.'; Cont: '.$this->_ControllerName.';</div>';\n            $this->_AnalyzeRequest($Request, 1);\n         }\n\n      } else if ($FolderDepth == 1) {\n         // Try the application folder first\n         $Found = FALSE;\n         if (in_array($Parts[0], $this->EnabledApplicationFolders())) {\n            // Check to see if the first part is an application\n            $this->_ApplicationFolder = $Parts[0];\n            $this->_MapParts($Parts, 1);\n            $Found = $this->_FetchController();\n         }\n         if (!$Found) {\n            // echo '<div>Failed. AppFolder: '.$this->_ApplicationFolder.'; Cont Folder: '.$this->_ControllerFolder.'; Cont: '.$this->_ControllerName.';</div>';\n            // Check to see if the first part is a controller folder\n            $this->_ApplicationFolder = '';\n            $this->_ControllerFolder = $Parts[0];\n            $this->_MapParts($Parts, 1);\n            if (!$this->_FetchController()) {\n               // echo '<div>Failed. AppFolder: '.$this->_ApplicationFolder.'; Cont Folder: '.$this->_ControllerFolder.'; Cont: '.$this->_ControllerName.';</div>';\n               $this->_AnalyzeRequest($Request, 0);\n            }\n         }\n      }\n   }\n\n   /**\n    * Searches through the /cache/controller_mappings.php file for the requested\n    * controller. If it doesn't find it, it searches through the entire\n    * application's folders for the requested controller. If it finds the\n    * controller, it adds the mapping to /cache/controller_mappings.php so it\n    * won't need to search again. If it doesn't find the controller file\n    * anywhere, it throws a fatal error.\n    *\n    * @param boolean $ThrowErrorOnFailure\n    * @todo $ThrowErrorOnFailure needs a description.\n    */\n   private function _FetchController($ThrowErrorOnFailure = FALSE) {\n      $ControllerWhiteList = $this->EnabledApplicationFolders();\n      // Don't include it if it's already been included\n      if (!class_exists($this->ControllerName())) {\n         $PathParts = array('controllers');\n         if ($this->_ControllerFolder != '')\n            $PathParts[] = $this->_ControllerFolder;\n\n         $PathParts[] = 'class.'.strtolower($this->_ControllerName).'controller.php';\n         $ControllerFileName = CombinePaths($PathParts);\n\n         // Limit the white list to the specified application folder if it was in the request\n         if ($this->_ApplicationFolder != '' && InArrayI($this->_ApplicationFolder, $ControllerWhiteList))\n            $ControllerWhiteList = array($this->_ApplicationFolder);\n\n         $ControllerPath = Gdn_FileSystem::FindByMapping('controller', PATH_APPLICATIONS, $ControllerWhiteList, $ControllerFileName);\n         if ($ControllerPath !== FALSE) {\n            // Strip the \"Application Folder\" from the controller path (this is\n            // used by the controller for various purposes. ie. knowing which\n            // application to search in for a view file).\n            $this->_ApplicationFolder = explode(DS, str_replace(PATH_APPLICATIONS . DS, '', $ControllerPath));\n            $this->_ApplicationFolder = $this->_ApplicationFolder[0];\n            $AppControllerName = ucfirst(strtolower($this->_ApplicationFolder)).'Controller';\n\n            // Load the application's master controller\n            if (!class_exists($AppControllerName))\n               require_once(CombinePaths(array(PATH_APPLICATIONS, $this->_ApplicationFolder, 'controllers', 'class.'.strtolower($this->_ApplicationFolder).'controller.php')));\n\n            // Now load the library (no need to check for existence - couldn't\n            // have made it here if it didn't exist).\n            require_once($ControllerPath);\n         }\n      }\n      if (!class_exists($this->ControllerName())) {\n         if ($ThrowErrorOnFailure === TRUE) {\n            if (ForceBool(Gdn::Config('Garden.Debug'))) {\n               trigger_error(ErrorMessage('Controller not found: '.$this->ControllerName(), 'Dispatcher', '_FetchController'), E_USER_ERROR);\n            } else {\n               $MissingRoute = Gdn::Router()->GetRoute('Default404');\n            \n               // Return a 404 message\n               list($this->_ApplicationFolder, $this->_ControllerName, $this->_ControllerMethod) = explode('/', $MissingRoute['Destination']);\n               $ControllerFileName = CombinePaths(array('controllers', 'class.' . strtolower($this->_ControllerName) . 'controller.php'));\n               $ControllerPath = Gdn_FileSystem::FindByMapping('controller', PATH_APPLICATIONS, $ControllerWhiteList, $ControllerFileName);\n               $this->_ApplicationFolder = explode(DS, str_replace(PATH_APPLICATIONS . DS, '', $ControllerPath));\n               $this->_ApplicationFolder = $this->_ApplicationFolder[0];\n               require_once(CombinePaths(array(PATH_APPLICATIONS, $this->_ApplicationFolder, 'controllers', 'class.'.strtolower($this->_ApplicationFolder).'controller.php')));\n               require_once($ControllerPath);\n            }\n         }\n         return FALSE;\n      } else {\n         return TRUE;\n      }\n   }\n   \n   /**\n    * An internal method used to map parts of the request to various properties\n    * of this object that represent the controller, controller method, and\n    * controller method arguments.\n    *\n    * @param array $Parts An array of parts of the request.\n    * @param int $ControllerKey An integer representing the key of the controller in the $Parts array.\n    */\n   private function _MapParts($Parts, $ControllerKey) {\n      $Length = count($Parts);\n      if ($Length > $ControllerKey)\n         $this->_ControllerName = ucfirst(strtolower($Parts[$ControllerKey]));\n\n      if ($Length > $ControllerKey + 1)\n         $this->_ControllerMethod = $Parts[$ControllerKey + 1];\n\n      if ($Length > $ControllerKey + 2) {\n         for ($i = $ControllerKey + 2; $i < $Length; ++$i) {\n            if ($Parts[$i] != '')\n               $this->_ControllerMethodArgs[] = $Parts[$i];\n\n         }\n      }\n   }\n\n   /**\n    * Set up the dispatch defaults.\n    */\n   protected function _SetControllerMethod($Controller) {\n      // Start with the controller name.\n      $ControllerName = $Controller->ControllerName;\n      if (StringEndsWith($ControllerName, 'controller', TRUE))\n         $ControllerName = substr($ControllerName, 0, -10);\n\n      // Figure out the method from the api.\n      $PathParts = explode('/', trim($Controller->Request->Path(), '/'));\n\n      foreach ($PathParts as $Part) {\n         $Curr = array_shift($PathParts);\n         if (strcasecmp($Curr, $ControllerName) == 0) {\n            break;\n         }\n      }\n\n      // We've gotten rid of the controller so the next part is the method.\n      if (count($PathParts) == 0)\n         return FALSE;\n      $MethodName = array_shift($PathParts);\n      $DeliveryMethod = strstr($MethodName, '.');\n\n      if ($DeliveryMethod !== FALSE) {\n         $DeliveryMethod = strtoupper(trim($DeliveryMethod, '.'));\n         switch ($DeliveryMethod) {\n            case DELIVERY_METHOD_JSON:\n            case DELIVERY_METHOD_XML:\n               // The extension was recognized.\n               $Controller->DeliveryMethod($DeliveryMethod);\n               $MethodName = ucfirst(substr($MethodName, 0, -(strlen($DeliveryMethod) + 1)));\n               $Controller->DeliveryType(DELIVERY_TYPE_DATA);\n               $Controller->RequestMethod = $MethodName;\n               $Controller->OriginalRequestMethod = strtolower($MethodName);\n\n               if (!method_exists($Controller, $MethodName)) {\n                  throw new Exception(sprintf(T('Method does not exist: %s.'), get_class($Controller).'::'.$MethodName.'()'), 404);\n               }\n\n               $Meth = new ReflectionMethod($Controller, $MethodName);\n               $MethParams = $Meth->getParameters();\n               $Params = array();\n               $Get = array_change_key_case($Controller->Request->GetRequestArguments(Gdn_Request::INPUT_GET));\n               $MissingParams = array();\n\n               // Set all of the parameters.\n               foreach ($MethParams as $Index => $MethParam) {\n                  $ParamName = strtolower($MethParam->getName());\n\n                  if (isset($PathParts[$Index]))\n                     $Params[] = $PathParts[$Index];\n                  elseif (isset($Get[$ParamName]))\n                     $Params[] = $Get[$ParamName];\n                  elseif ($MethParam->isDefaultValueAvailable())\n                     $Params[] = $MethParam->getDefaultValue();\n                  else\n                     $MissingParams[] = \"$Index: $ParamName\";\n               }\n\n               if (count($MissingParams) > 0)\n                  throw new Exception(sprintf(T('Missing required parameters: %s.'), implode(', ', $MissingParams)), 400);\n\n               // Call the method.\n               //call_user_func_array(array($Controller, $MethodName), $Params);\n               $this->_ControllerMethodArgs = $Params;\n\n               break;\n            default:\n               return FALSE;\n         }\n      } else {\n         return FALSE;\n      }\n      return TRUE;\n   }\n}"], "filenames": ["applications/dashboard/controllers/class.entrycontroller.php", "library/core/class.dispatcher.php"], "buggy_code_start_loc": [282, 362], "buggy_code_end_loc": [283, 363], "fixing_code_start_loc": [282, 362], "fixing_code_end_loc": [283, 363], "type": "CWE-79", "message": "It was found in vanilla forums before 2.0.10 a cross-site scripting vulnerability where a filename could contain arbitrary code to execute on the client side.", "other": {"cve": {"id": "CVE-2010-4264", "sourceIdentifier": "secalert@redhat.com", "published": "2021-06-22T14:15:08.167", "lastModified": "2021-06-25T17:14:08.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "It was found in vanilla forums before 2.0.10 a cross-site scripting vulnerability where a filename could contain arbitrary code to execute on the client side."}, {"lang": "es", "value": "Se encontr\u00f3 en vanilla forums versiones anteriores a 2.0.10, una vulnerabilidad de tipo cross-site scripting donde un nombre de archivo podr\u00eda contener c\u00f3digo arbitrario para ejecutar en el lado del cliente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vanillaforums:vanilla_forums:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.10", "matchCriteriaId": "B8DF1E29-0EE2-454C-92CA-62A3A0F0E5DA"}]}]}], "references": [{"url": "https://github.com/vanilla/vanilla/commit/4535a059e4e24ca11a2ef0b4d754f262398bcece", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://seclists.org/oss-sec/2010/q4/282", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vanilla/vanilla/commit/4535a059e4e24ca11a2ef0b4d754f262398bcece"}}