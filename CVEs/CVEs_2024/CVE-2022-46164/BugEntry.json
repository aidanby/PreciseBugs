{"buggy_code": ["'use strict';\n\nconst os = require('os');\nconst nconf = require('nconf');\nconst winston = require('winston');\nconst util = require('util');\nconst validator = require('validator');\nconst cookieParser = require('cookie-parser')(nconf.get('secret'));\n\nconst db = require('../database');\nconst user = require('../user');\nconst logger = require('../logger');\nconst plugins = require('../plugins');\nconst ratelimit = require('../middleware/ratelimit');\n\nconst Namespaces = {};\n\nconst Sockets = module.exports;\n\nSockets.init = async function (server) {\n\trequireModules();\n\n\tconst SocketIO = require('socket.io').Server;\n\tconst io = new SocketIO({\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t});\n\n\tif (nconf.get('isCluster')) {\n\t\tif (nconf.get('redis')) {\n\t\t\tconst adapter = await require('../database/redis').socketAdapter();\n\t\t\tio.adapter(adapter);\n\t\t} else {\n\t\t\twinston.warn('clustering detected, you should setup redis!');\n\t\t}\n\t}\n\n\tio.use(authorize);\n\n\tio.on('connection', onConnection);\n\n\tconst opts = {\n\t\ttransports: nconf.get('socket.io:transports') || ['polling', 'websocket'],\n\t\tcookie: false,\n\t};\n\t/*\n\t * Restrict socket.io listener to cookie domain. If none is set, infer based on url.\n\t * Production only so you don't get accidentally locked out.\n\t * Can be overridden via config (socket.io:origins)\n\t */\n\tif (process.env.NODE_ENV !== 'development' || nconf.get('socket.io:cors')) {\n\t\tconst origins = nconf.get('socket.io:origins');\n\t\topts.cors = nconf.get('socket.io:cors') || {\n\t\t\torigin: origins,\n\t\t\tmethods: ['GET', 'POST'],\n\t\t\tallowedHeaders: ['content-type'],\n\t\t};\n\t\twinston.info(`[socket.io] Restricting access to origin: ${origins}`);\n\t}\n\n\tio.listen(server, opts);\n\tSockets.server = io;\n};\n\nfunction onConnection(socket) {\n\tsocket.ip = (socket.request.headers['x-forwarded-for'] || socket.request.connection.remoteAddress || '').split(',')[0];\n\tsocket.request.ip = socket.ip;\n\tlogger.io_one(socket, socket.uid);\n\n\tonConnect(socket);\n\tsocket.onAny((event, ...args) => {\n\t\tconst payload = { data: [event].concat(args) };\n\t\tconst als = require('../als');\n\t\tals.run({ uid: socket.uid }, onMessage, socket, payload);\n\t});\n\n\tsocket.on('disconnect', () => {\n\t\tonDisconnect(socket);\n\t});\n}\n\nfunction onDisconnect(socket) {\n\trequire('./uploads').clear(socket.id);\n\tplugins.hooks.fire('action:sockets.disconnect', { socket: socket });\n}\n\nasync function onConnect(socket) {\n\ttry {\n\t\tawait validateSession(socket, '[[error:invalid-session]]');\n\t} catch (e) {\n\t\tif (e.message === '[[error:invalid-session]]') {\n\t\t\tsocket.emit('event:invalid_session');\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (socket.uid) {\n\t\tsocket.join(`uid_${socket.uid}`);\n\t\tsocket.join('online_users');\n\t} else {\n\t\tsocket.join('online_guests');\n\t}\n\n\tsocket.join(`sess_${socket.request.signedCookies[nconf.get('sessionKey')]}`);\n\tsocket.emit('checkSession', socket.uid);\n\tsocket.emit('setHostname', os.hostname());\n\tplugins.hooks.fire('action:sockets.connect', { socket: socket });\n}\n\nasync function onMessage(socket, payload) {\n\tif (!payload.data.length) {\n\t\treturn winston.warn('[socket.io] Empty payload');\n\t}\n\n\tconst eventName = payload.data[0];\n\tconst params = typeof payload.data[1] === 'function' ? {} : payload.data[1];\n\tconst callback = typeof payload.data[payload.data.length - 1] === 'function' ? payload.data[payload.data.length - 1] : function () {};\n\n\tif (!eventName) {\n\t\treturn winston.warn('[socket.io] Empty method name');\n\t}\n\n\tconst parts = eventName.toString().split('.');\n\tconst namespace = parts[0];\n\tconst methodToCall = parts.reduce((prev, cur) => {\n\t\tif (prev !== null && prev[cur]) {\n\t\t\treturn prev[cur];\n\t\t}\n\t\treturn null;\n\t}, Namespaces);\n\n\tif (!methodToCall || typeof methodToCall !== 'function') {\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\twinston.warn(`[socket.io] Unrecognized message: ${eventName}`);\n\t\t}\n\t\tconst escapedName = validator.escape(String(eventName));\n\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t}\n\n\tsocket.previousEvents = socket.previousEvents || [];\n\tsocket.previousEvents.push(eventName);\n\tif (socket.previousEvents.length > 20) {\n\t\tsocket.previousEvents.shift();\n\t}\n\n\tif (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {\n\t\twinston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n\t\treturn socket.disconnect();\n\t}\n\n\ttry {\n\t\tawait checkMaintenance(socket);\n\t\tawait validateSession(socket, '[[error:revalidate-failure]]');\n\n\t\tif (Namespaces[namespace].before) {\n\t\t\tawait Namespaces[namespace].before(socket, eventName, params);\n\t\t}\n\n\t\tif (methodToCall.constructor && methodToCall.constructor.name === 'AsyncFunction') {\n\t\t\tconst result = await methodToCall(socket, params);\n\t\t\tcallback(null, result);\n\t\t} else {\n\t\t\tmethodToCall(socket, params, (err, result) => {\n\t\t\t\tcallback(err ? { message: err.message } : null, result);\n\t\t\t});\n\t\t}\n\t} catch (err) {\n\t\twinston.error(`${eventName}\\n${err.stack ? err.stack : err.message}`);\n\t\tcallback({ message: err.message });\n\t}\n}\n\nfunction requireModules() {\n\tconst modules = [\n\t\t'admin', 'categories', 'groups', 'meta', 'modules',\n\t\t'notifications', 'plugins', 'posts', 'topics', 'user',\n\t\t'blacklist', 'uploads',\n\t];\n\n\tmodules.forEach((module) => {\n\t\tNamespaces[module] = require(`./${module}`);\n\t});\n}\n\nasync function checkMaintenance(socket) {\n\tconst meta = require('../meta');\n\tif (!meta.config.maintenanceMode) {\n\t\treturn;\n\t}\n\tconst isAdmin = await user.isAdministrator(socket.uid);\n\tif (isAdmin) {\n\t\treturn;\n\t}\n\tconst validator = require('validator');\n\tthrow new Error(`[[pages:maintenance.text, ${validator.escape(String(meta.config.title || 'NodeBB'))}]]`);\n}\n\nconst getSessionAsync = util.promisify(\n\t(sid, callback) => db.sessionStore.get(sid, (err, sessionObj) => callback(err, sessionObj || null))\n);\n\nasync function validateSession(socket, errorMsg) {\n\tconst req = socket.request;\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: req.signedCookies ? req.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: req,\n\t});\n\n\tif (!sessionId) {\n\t\treturn;\n\t}\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (!sessionData) {\n\t\tthrow new Error(errorMsg);\n\t}\n\n\tawait plugins.hooks.fire('static:sockets.validateSession', {\n\t\treq: req,\n\t\tsocket: socket,\n\t\tsession: sessionData,\n\t});\n}\n\nconst cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));\n\nasync function authorize(socket, callback) {\n\tconst { request } = socket;\n\n\tif (!request) {\n\t\treturn callback(new Error('[[error:not-authorized]]'));\n\t}\n\n\tawait cookieParserAsync(request);\n\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: request.signedCookies ? request.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: request,\n\t});\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (sessionData && sessionData.passport && sessionData.passport.user) {\n\t\trequest.session = sessionData;\n\t\tsocket.uid = parseInt(sessionData.passport.user, 10);\n\t} else {\n\t\tsocket.uid = 0;\n\t}\n\trequest.uid = socket.uid;\n\tcallback();\n}\n\nSockets.in = function (room) {\n\treturn Sockets.server && Sockets.server.in(room);\n};\n\nSockets.getUserSocketCount = function (uid) {\n\treturn Sockets.getCountInRoom(`uid_${uid}`);\n};\n\nSockets.getCountInRoom = function (room) {\n\tif (!Sockets.server) {\n\t\treturn 0;\n\t}\n\tconst roomMap = Sockets.server.sockets.adapter.rooms.get(room);\n\treturn roomMap ? roomMap.size : 0;\n};\n\nSockets.warnDeprecated = (socket, replacement) => {\n\tif (socket.previousEvents && socket.emit) {\n\t\tsocket.emit('event:deprecated_call', {\n\t\t\teventName: socket.previousEvents[socket.previousEvents.length - 1],\n\t\t\treplacement: replacement,\n\t\t});\n\t}\n\twinston.warn(`[deprecated]\\n ${new Error('-').stack.split('\\n').slice(2, 5).join('\\n')}\\n     use ${replacement}`);\n};\n"], "fixing_code": ["'use strict';\n\nconst os = require('os');\nconst nconf = require('nconf');\nconst winston = require('winston');\nconst util = require('util');\nconst validator = require('validator');\nconst cookieParser = require('cookie-parser')(nconf.get('secret'));\n\nconst db = require('../database');\nconst user = require('../user');\nconst logger = require('../logger');\nconst plugins = require('../plugins');\nconst ratelimit = require('../middleware/ratelimit');\n\nconst Namespaces = Object.create(null);\n\nconst Sockets = module.exports;\n\nSockets.init = async function (server) {\n\trequireModules();\n\n\tconst SocketIO = require('socket.io').Server;\n\tconst io = new SocketIO({\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t});\n\n\tif (nconf.get('isCluster')) {\n\t\tif (nconf.get('redis')) {\n\t\t\tconst adapter = await require('../database/redis').socketAdapter();\n\t\t\tio.adapter(adapter);\n\t\t} else {\n\t\t\twinston.warn('clustering detected, you should setup redis!');\n\t\t}\n\t}\n\n\tio.use(authorize);\n\n\tio.on('connection', onConnection);\n\n\tconst opts = {\n\t\ttransports: nconf.get('socket.io:transports') || ['polling', 'websocket'],\n\t\tcookie: false,\n\t};\n\t/*\n\t * Restrict socket.io listener to cookie domain. If none is set, infer based on url.\n\t * Production only so you don't get accidentally locked out.\n\t * Can be overridden via config (socket.io:origins)\n\t */\n\tif (process.env.NODE_ENV !== 'development' || nconf.get('socket.io:cors')) {\n\t\tconst origins = nconf.get('socket.io:origins');\n\t\topts.cors = nconf.get('socket.io:cors') || {\n\t\t\torigin: origins,\n\t\t\tmethods: ['GET', 'POST'],\n\t\t\tallowedHeaders: ['content-type'],\n\t\t};\n\t\twinston.info(`[socket.io] Restricting access to origin: ${origins}`);\n\t}\n\n\tio.listen(server, opts);\n\tSockets.server = io;\n};\n\nfunction onConnection(socket) {\n\tsocket.ip = (socket.request.headers['x-forwarded-for'] || socket.request.connection.remoteAddress || '').split(',')[0];\n\tsocket.request.ip = socket.ip;\n\tlogger.io_one(socket, socket.uid);\n\n\tonConnect(socket);\n\tsocket.onAny((event, ...args) => {\n\t\tconst payload = { data: [event].concat(args) };\n\t\tconst als = require('../als');\n\t\tals.run({ uid: socket.uid }, onMessage, socket, payload);\n\t});\n\n\tsocket.on('disconnect', () => {\n\t\tonDisconnect(socket);\n\t});\n}\n\nfunction onDisconnect(socket) {\n\trequire('./uploads').clear(socket.id);\n\tplugins.hooks.fire('action:sockets.disconnect', { socket: socket });\n}\n\nasync function onConnect(socket) {\n\ttry {\n\t\tawait validateSession(socket, '[[error:invalid-session]]');\n\t} catch (e) {\n\t\tif (e.message === '[[error:invalid-session]]') {\n\t\t\tsocket.emit('event:invalid_session');\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (socket.uid) {\n\t\tsocket.join(`uid_${socket.uid}`);\n\t\tsocket.join('online_users');\n\t} else {\n\t\tsocket.join('online_guests');\n\t}\n\n\tsocket.join(`sess_${socket.request.signedCookies[nconf.get('sessionKey')]}`);\n\tsocket.emit('checkSession', socket.uid);\n\tsocket.emit('setHostname', os.hostname());\n\tplugins.hooks.fire('action:sockets.connect', { socket: socket });\n}\n\nasync function onMessage(socket, payload) {\n\tif (!payload.data.length) {\n\t\treturn winston.warn('[socket.io] Empty payload');\n\t}\n\n\tconst eventName = payload.data[0];\n\tconst params = typeof payload.data[1] === 'function' ? {} : payload.data[1];\n\tconst callback = typeof payload.data[payload.data.length - 1] === 'function' ? payload.data[payload.data.length - 1] : function () {};\n\n\tif (!eventName) {\n\t\treturn winston.warn('[socket.io] Empty method name');\n\t}\n\n\tconst parts = eventName.toString().split('.');\n\tconst namespace = parts[0];\n\tconst methodToCall = parts.reduce((prev, cur) => {\n\t\tif (prev !== null && prev[cur]) {\n\t\t\treturn prev[cur];\n\t\t}\n\t\treturn null;\n\t}, Namespaces);\n\n\tif (!methodToCall || typeof methodToCall !== 'function') {\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\twinston.warn(`[socket.io] Unrecognized message: ${eventName}`);\n\t\t}\n\t\tconst escapedName = validator.escape(String(eventName));\n\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t}\n\n\tsocket.previousEvents = socket.previousEvents || [];\n\tsocket.previousEvents.push(eventName);\n\tif (socket.previousEvents.length > 20) {\n\t\tsocket.previousEvents.shift();\n\t}\n\n\tif (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {\n\t\twinston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n\t\treturn socket.disconnect();\n\t}\n\n\ttry {\n\t\tawait checkMaintenance(socket);\n\t\tawait validateSession(socket, '[[error:revalidate-failure]]');\n\n\t\tif (Namespaces[namespace].before) {\n\t\t\tawait Namespaces[namespace].before(socket, eventName, params);\n\t\t}\n\n\t\tif (methodToCall.constructor && methodToCall.constructor.name === 'AsyncFunction') {\n\t\t\tconst result = await methodToCall(socket, params);\n\t\t\tcallback(null, result);\n\t\t} else {\n\t\t\tmethodToCall(socket, params, (err, result) => {\n\t\t\t\tcallback(err ? { message: err.message } : null, result);\n\t\t\t});\n\t\t}\n\t} catch (err) {\n\t\twinston.error(`${eventName}\\n${err.stack ? err.stack : err.message}`);\n\t\tcallback({ message: err.message });\n\t}\n}\n\nfunction requireModules() {\n\tconst modules = [\n\t\t'admin', 'categories', 'groups', 'meta', 'modules',\n\t\t'notifications', 'plugins', 'posts', 'topics', 'user',\n\t\t'blacklist', 'uploads',\n\t];\n\n\tmodules.forEach((module) => {\n\t\tNamespaces[module] = require(`./${module}`);\n\t});\n}\n\nasync function checkMaintenance(socket) {\n\tconst meta = require('../meta');\n\tif (!meta.config.maintenanceMode) {\n\t\treturn;\n\t}\n\tconst isAdmin = await user.isAdministrator(socket.uid);\n\tif (isAdmin) {\n\t\treturn;\n\t}\n\tconst validator = require('validator');\n\tthrow new Error(`[[pages:maintenance.text, ${validator.escape(String(meta.config.title || 'NodeBB'))}]]`);\n}\n\nconst getSessionAsync = util.promisify(\n\t(sid, callback) => db.sessionStore.get(sid, (err, sessionObj) => callback(err, sessionObj || null))\n);\n\nasync function validateSession(socket, errorMsg) {\n\tconst req = socket.request;\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: req.signedCookies ? req.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: req,\n\t});\n\n\tif (!sessionId) {\n\t\treturn;\n\t}\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (!sessionData) {\n\t\tthrow new Error(errorMsg);\n\t}\n\n\tawait plugins.hooks.fire('static:sockets.validateSession', {\n\t\treq: req,\n\t\tsocket: socket,\n\t\tsession: sessionData,\n\t});\n}\n\nconst cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));\n\nasync function authorize(socket, callback) {\n\tconst { request } = socket;\n\n\tif (!request) {\n\t\treturn callback(new Error('[[error:not-authorized]]'));\n\t}\n\n\tawait cookieParserAsync(request);\n\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: request.signedCookies ? request.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: request,\n\t});\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (sessionData && sessionData.passport && sessionData.passport.user) {\n\t\trequest.session = sessionData;\n\t\tsocket.uid = parseInt(sessionData.passport.user, 10);\n\t} else {\n\t\tsocket.uid = 0;\n\t}\n\trequest.uid = socket.uid;\n\tcallback();\n}\n\nSockets.in = function (room) {\n\treturn Sockets.server && Sockets.server.in(room);\n};\n\nSockets.getUserSocketCount = function (uid) {\n\treturn Sockets.getCountInRoom(`uid_${uid}`);\n};\n\nSockets.getCountInRoom = function (room) {\n\tif (!Sockets.server) {\n\t\treturn 0;\n\t}\n\tconst roomMap = Sockets.server.sockets.adapter.rooms.get(room);\n\treturn roomMap ? roomMap.size : 0;\n};\n\nSockets.warnDeprecated = (socket, replacement) => {\n\tif (socket.previousEvents && socket.emit) {\n\t\tsocket.emit('event:deprecated_call', {\n\t\t\teventName: socket.previousEvents[socket.previousEvents.length - 1],\n\t\t\treplacement: replacement,\n\t\t});\n\t}\n\twinston.warn(`[deprecated]\\n ${new Error('-').stack.split('\\n').slice(2, 5).join('\\n')}\\n     use ${replacement}`);\n};\n"], "filenames": ["src/socket.io/index.js"], "buggy_code_start_loc": [16], "buggy_code_end_loc": [17], "fixing_code_start_loc": [16], "fixing_code_end_loc": [17], "type": "CWE-665", "message": "NodeBB is an open source Node.js based forum software. Due to a plain object with a prototype being used in socket.io message handling a specially crafted payload can be used to impersonate other users and takeover accounts. This vulnerability has been patched in version 2.6.1. Users are advised to upgrade. Users unable to upgrade may cherry-pick commit `48d143921753914da45926cca6370a92ed0c46b8` into their codebase to patch the exploit.", "other": {"cve": {"id": "CVE-2022-46164", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-05T21:15:10.443", "lastModified": "2022-12-07T04:49:30.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NodeBB is an open source Node.js based forum software. Due to a plain object with a prototype being used in socket.io message handling a specially crafted payload can be used to impersonate other users and takeover accounts. This vulnerability has been patched in version 2.6.1. Users are advised to upgrade. Users unable to upgrade may cherry-pick commit `48d143921753914da45926cca6370a92ed0c46b8` into their codebase to patch the exploit."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.4, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.1", "matchCriteriaId": "ACBD3E19-5D50-4C0F-9CDA-AE5A240AF776"}]}]}], "references": [{"url": "https://github.com/NodeBB/NodeBB/commit/48d143921753914da45926cca6370a92ed0c46b8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/security/advisories/GHSA-rf3g-v8p5-p675", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/48d143921753914da45926cca6370a92ed0c46b8"}}