{"buggy_code": ["/*\n * Generic ABC parser.\n *\n * This file is part of abcm2ps.\n *\n * Copyright (C) 1998-2020 Jean-Fran\u00e7ois Moine (http://moinejf.free.fr)\n * Adapted from abc2ps, Copyright (C) 1996-1998 Michael Methfessel\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"abcm2ps.h\"\n\n/* global values */\nint severity;\t\t\t/* error severity */\n\nstatic int ulen;\t\t/* unit note length set by M: or L: */\nstatic short meter;\t\t/* upper value of time sig for n-plets */\nstatic unsigned char microscale; /* current microtone scale */\nstatic signed char vover;\t/* voice overlay (1: single bar, -1: multi-bar */\nstatic char lyric_started;\t/* lyric started */\nstatic char *gchord;\t\t/* guitar chord */\nstatic struct decos dc;\t\t/* decorations */\nstatic struct SYMBOL *deco_start; /* 1st note of the line for d: / s: */\nstatic struct SYMBOL *deco_cont; /* current symbol when d: / s: continuation */\n\nstatic int g_abc_vers, g_ulen, g_microscale;\nstatic char g_char_tb[128];\nstatic char *g_deco_tb[128];\t\t/* global decoration names */\nstatic unsigned short g_micro_tb[MAXMICRO]; /* global microtone values */\n\nstatic char *abc_fn;\t\t/* current source file name */\nstatic int linenum;\t\t/* current source line number */\nstatic int colnum;\t\t/* current source column number */\nstatic char *abc_line;\t\t/* line being parsed */\nstatic struct SYMBOL *last_sym;\t/* last symbol for errors */\n\nstatic short nvoice;\t\t/* number of voices (0..n-1) */\nstruct VOICE_S *curvoice;\t/* current voice while parsing */\n\nstruct parse parse;\n\n/* char table for note line parsing */\n#define CHAR_BAD 0\n#define CHAR_IGN 1\n#define CHAR_NOTE 2\n#define CHAR_GR_ST 3\n#define CHAR_DECO 4\n#define CHAR_GCHORD 5\n#define CHAR_BSLASH 6\n#define CHAR_OBRA 7\n#define CHAR_BAR 8\n#define CHAR_OPAR 9\n#define CHAR_VOV 10\n#define CHAR_SPAC 11\n#define CHAR_MINUS 12\n#define CHAR_CPAR 13\n#define CHAR_BRHY 14\n#define CHAR_DECOS 15\n#define CHAR_SLASH 16\n#define CHAR_GR_EN 17\n#define CHAR_LINEBREAK 18\nstatic char char_tb[256] = {\n\t0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t/* 00 - 07 */\n\t0, CHAR_SPAC, CHAR_LINEBREAK, 0, 0, 0, 0, 0,\t/* 08 - 0f */\n\t0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t/* 10 - 17 */\n\t0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t/* 18 - 1f */\n\tCHAR_SPAC, CHAR_DECOS, CHAR_GCHORD, CHAR_BAD,\t/* (sp) ! \" # */\n\tCHAR_BAD, CHAR_BAD, CHAR_VOV, CHAR_BAD, \t/* $ % & ' */\n\tCHAR_OPAR, CHAR_CPAR, CHAR_BAD, CHAR_DECOS, \t/* ( ) * + */\n\tCHAR_BAD, CHAR_MINUS, CHAR_DECO, CHAR_SLASH, \t/* , - . / */\n\tCHAR_BAD, CHAR_BAD, CHAR_BAD, CHAR_BAD, \t/* 0 1 2 3 */\n\tCHAR_BAD, CHAR_BAD, CHAR_BAD, CHAR_BAD, \t/* 4 5 6 7 */\n\tCHAR_BAD, CHAR_BAD, CHAR_BAR, CHAR_BAD, \t/* 8 9 : ; */\n\tCHAR_BRHY, CHAR_NOTE, CHAR_BRHY, CHAR_BAD, \t/* < = > ? */\n\tCHAR_BAD, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* @ A B C */\n\tCHAR_NOTE, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* D E F G */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* H I J K */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* L M N O */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* P Q R S */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* T U V W */\n\tCHAR_NOTE, CHAR_DECO, CHAR_NOTE, CHAR_OBRA, \t/* X Y Z [ */\n\tCHAR_BSLASH, CHAR_BAR, CHAR_NOTE, CHAR_NOTE, \t/* \\ ] ^ _ */\n\tCHAR_IGN, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* ` a b c */\n\tCHAR_NOTE, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* d e f g */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* h i j k */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* l m n o */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* p q r s */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* t u v w */\n\tCHAR_NOTE, CHAR_NOTE, CHAR_NOTE, CHAR_GR_ST, \t/* x y z { */\n\tCHAR_BAR, CHAR_GR_EN, CHAR_DECO, CHAR_BAD, \t/* | } ~ (del) */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 80 - 8f */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 90 - 9f */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* a0 - af */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* b0 - bf */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* c0 - cf */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* d0 - df */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* e0 - ef */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* f0 - ff */\n};\n\nstatic const char all_notes[] = \"CDEFGABcdefgab\";\n\nstatic int parse_info(char *p);\nstatic char *parse_gchord(char *p);\nstatic int parse_line(char *p);\nstatic char *parse_note(char *p,\n\t\t\tint flags);\nstatic void syntax(char *msg, char *q);\nstatic void vover_new(void);\n\n/* -- abcMIDI like errors -- */\nstatic void print_error(char *s, int col)\n{\n\tif (col >= 0)\n\t\tfprintf(stderr, \"%s:%d:%d: error: %s\\n\", abc_fn, linenum, col, s);\n\telse\n\t\tfprintf(stderr, \"%s:%d: error: %s\\n\", abc_fn, linenum, s);\n}\n\n/* -- new symbol -- */\nstatic struct SYMBOL *abc_new(int type, char *text)\n{\n\tstruct SYMBOL *s;\n\n\ts = getarena(sizeof(struct SYMBOL));\n\tmemset(s, 0, sizeof(struct SYMBOL));\n\tif (text) {\n\t\ts->text = getarena(strlen(text) + 1);\n\t\tstrcpy(s->text, text);\n\t}\n\tif (!parse.last_sym) {\n\t\tparse.first_sym = s;\n\t} else {\n\t\tif ((s->abc_next = parse.last_sym->abc_next) != NULL)\n\t\t\ts->abc_next->abc_prev = s;\n\t\tparse.last_sym->abc_next = s;\n\t\ts->abc_prev = parse.last_sym;\n\t}\n\tlast_sym = parse.last_sym = s;\n\ts->abc_type = type;\n\ts->state = parse.abc_state;\n\ts->fn = abc_fn;\n\ts->linenum = linenum;\n\ts->colnum = colnum;\n\treturn s;\n}\n\n/* -- parse an ABC line -- */\nvoid abc_parse(char *p, char *fname, int ln)\n{\n\tabc_fn = fname;\n\tlinenum = ln;\n\tabc_line = p;\n\n\t/* parse the music line */\n\tswitch (parse_line(p)) {\n\tcase 2:\t\t\t\t/* start of tune (X:) */\n\t\tg_abc_vers = parse.abc_vers;\n\t\tg_ulen = ulen;\n\t\tg_microscale = microscale;\n\n\t\tmeter = 2;\n\t\tmemcpy(g_char_tb, char_tb, sizeof g_char_tb);\n\t\tmemcpy(g_deco_tb, parse.deco_tb, sizeof g_deco_tb);\n\t\tmemcpy(g_micro_tb, parse.micro_tb, sizeof g_micro_tb);\n\t\tbreak;\n\tcase 1:\t\t\t\t/* end of tune */\n\t\tif (parse.first_sym) {\n\t\t\tdo_tune();\n\t\t\tparse.first_sym = parse.last_sym = NULL;\n\t\t}\n\t\tparse.abc_state = ABC_S_GLOBAL;\n\t\tparse.abc_vers = g_abc_vers;\n\t\tulen = g_ulen;\n\t\tmicroscale = g_microscale;\n\t\tmemcpy(char_tb, g_char_tb, sizeof g_char_tb);\n\t\tmemcpy(parse.deco_tb, g_deco_tb, sizeof parse.deco_tb);\n\t\tmemcpy(parse.micro_tb, g_micro_tb, sizeof parse.micro_tb);\n\t\tlvlarena(0);\n\t\tif (dc.n > 0)\n\t\t\tsyntax(\"Decoration without symbol\", 0);\n\t\tdc.n = 0;\n\t\tbreak;\n\t}\n}\n\n/* treat the end of file */\nvoid abc_eof(void)\n{\n//\tif (parse.abc_state == ABC_S_HEAD)\n//\t\tseverity = 1;\n\tdo_tune();\n\tparse.first_sym = parse.last_sym = NULL;\n\tif (parse.abc_state != ABC_S_GLOBAL) {\n\t\tparse.abc_vers = g_abc_vers;\n\t\tulen = g_ulen;\n\t\tmicroscale = g_microscale;\n\t\tmemcpy(char_tb, g_char_tb, sizeof g_char_tb);\n\t}\n}\n\n/* -- treat the broken rhythm '>' and '<' -- */\nstatic void broken_rhythm(struct SYMBOL *s,\n\t\t\t  int num)\t/* >0: do dot, <0: do half */\n{\n\tstruct notes *notes = &s->u.note;\n\tint l, m, n;\n\n\tnum *= 2;\n\tif (num > 0) {\n\t\tif (num == 6)\n\t\t\tnum = 8;\n\t\tn = num * 2 - 1;\n\t\tfor (m = 0; m <= s->nhd; m++)\n\t\t\tnotes->notes[m].len = (notes->notes[m].len * n) / num;\n\t} else {\n\t\tn = -num;\n\t\tif (n == 6)\n\t\t\tn = 8;\n\t\tfor (m = 0; m <= s->nhd; m++)\n\t\t\tnotes->notes[m].len /= n;\n\t}\n\tl = notes->notes[0].len;\n\tfor (m = 1; m <= s->nhd; m++)\n\t\tif (notes->notes[m].len < l)\n\t\t\tl = notes->notes[m].len;\n}\n\n/* -- check for the '!' as end of line (ABC2Win) -- */\nstatic int check_nl(char *p)\n{\n\twhile (*p != '\\0') {\n\t\tswitch (*p++) {\n\t\tcase '!':\n\t\t\treturn 0;\n\t\tcase '|':\n\t\tcase '[':\n\t\tcase ':':\n\t\tcase ']':\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/* -- parse extra K: or V: definitions (clef, octave and microscale  -- */\nstatic char *parse_extra(char *p,\n\t\t\tchar **p_name,\n\t\t\tchar **p_middle,\n\t\t\tchar **p_stlines,\n\t\t\tchar **p_scale,\n\t\t\tchar **p_octave,\n\t\t\tchar **p_cue,\n\t\t\tchar **p_map)\n{\n\tfor (;;) {\n\t\tif (strncmp(p, \"clef=\", 5) == 0\n\t\t || strncmp(p, \"bass\", 4) == 0\n\t\t || strncmp(p, \"treble\", 6) == 0\n\t\t || strncmp(p, \"alto\", 4) == 0\n\t\t || strncmp(p, \"tenor\", 5) == 0\n\t\t || strncmp(p, \"perc\", 4) == 0) {\n\t\t\tif (*p_name)\n\t\t\t\tsyntax(\"Double clef name\", p);\n\t\t\t*p_name = p;\n\t\t} else if (strncmp(p, \"microscale=\", 11) == 0\n\t\t\t|| strncmp(p, \"uscale=\", 7) == 0) {\n\t\t\tint i;\n\n\t\t\tp += p[0] == 'm' ? 11 : 7;\n\t\t\ti = atoi(p);\n\t\t\tif (i < 4 || i >= 256)\n\t\t\t\tsyntax(\"Invalid value in microscale=\", p);\n\t\t\telse\n\t\t\t\tmicroscale = i;\n\t\t} else if (strncmp(p, \"middle=\", 7) == 0\n\t\t\t|| strncmp(p, \"m=\", 2) == 0) {\n\t\t\tif (*p_middle)\n\t\t\t\tsyntax(\"Double clef middle\", p);\n\t\t\t*p_middle = p + (p[1] == '=' ? 2 : 7);\n\t\t} else if (strncmp(p, \"octave=\", 7) == 0) {\n\t\t\tif (*p_octave)\n\t\t\t\tsyntax(\"Double octave=\", p);\n\t\t\t*p_octave = p + 7;\n\t\t} else if (strncmp(p, \"stafflines=\", 11) == 0) {\n\t\t\tint l;\n\t\t\tchar *q;\n\n\t\t\tif (*p_stlines)\n\t\t\t\tsyntax(\"Double stafflines\", p);\n\t\t\tp += 11;\n\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\tswitch (atoi(p)) {\n\t\t\t\tcase 0: *p_stlines = \"...\"; break;\n\t\t\t\tcase 1: *p_stlines = \"..|\"; break;\n\t\t\t\tcase 2: *p_stlines = \".||\"; break;\n\t\t\t\tcase 3: *p_stlines = \".|||\"; break;\n\t\t\t\tcase 4: *p_stlines = \"||||\"; break;\n\t\t\t\tcase 5: *p_stlines = \"|||||\"; break;\n\t\t\t\tcase 6: *p_stlines = \"||||||\"; break;\n\t\t\t\tcase 7: *p_stlines = \"|||||||\"; break;\n\t\t\t\tcase 8: *p_stlines = \"||||||||\"; break;\n\t\t\t\tdefault:\n\t\t\t\t\tsyntax(\"Bad number of lines\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tq = p;\n\t\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\t\tp++;\n\t\t\t\tl = p - q;\n\t\t\t\t*p_stlines = getarena(l + 1);\n\t\t\t\tstrncpy(*p_stlines, q, l);\n\t\t\t\t(*p_stlines)[l] = '\\0';\n\t\t\t}\n\t\t} else if (strncmp(p, \"staffscale=\", 11) == 0) {\n\t\t\tif (*p_scale)\n\t\t\t\tsyntax(\"Double staffscale\", p);\n\t\t\t*p_scale = p + 11;\n\t\t} else if (strncmp(p, \"cue=\", 4) == 0) {\n\t\t\tif (*p_cue)\n\t\t\t\tsyntax(\"Double cue\", p);\n\t\t\t*p_cue = p + 4;\n\t\t} else if (strncmp(p, \"map=\", 4) == 0) {\n\t\t\tif (*p_map)\n\t\t\t\tsyntax(\"Double map\", p);\n\t\t\t*p_map = p + 4;\n//\t\t} else if (strncmp(p, \"transpose=\", 10) == 0\n//\t\t\t|| strncmp(p, \"t=\", 2) == 0) {\n//\t\t\t;\t\t/* ignored - abcMIDI */\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t}\n\treturn p;\n}\n\n/* -- parse a decoration 'xxx<decosep>' -- */\nstatic char *get_deco(char *p,\n\t\t      unsigned char *p_dc)\n{\n\tchar *q, sep, **t;\n\tunsigned i, l;\n\n\t*p_dc = 0;\n\tq = p;\n\tsep = q[-1];\n\tif (char_tb[(unsigned char) sep] == CHAR_DECOS) {\n\t\tif (sep == '+') {\n\t\t\tif (*p == '+' && p[1] == '+')\n\t\t\t\tp++;\t\t/* special case \"+++\" */\n\t\t}\n\t} else {\n\t\tsep = '\\0';\t\t\t/* Barfly U: */\n\t}\n\twhile (*p != sep) {\n\t\tif (*p == '\\0') {\n\t\t\tsyntax(\"Decoration not terminated\", q);\n\t\t\treturn p;\n\t\t}\n\t\tp++;\n\t}\n\tl = p - q;\n\tif (*p == sep)\n\t\tp++;\n\tfor (i = 1, t = &parse.deco_tb[1];\n\t     *t && i < DC_NAME_SZ;\n\t     i++, t++) {\n\t\tif (strlen(*t) == l\n\t\t && strncmp(*t, q, l) == 0) {\n\t\t\t*p_dc = i + 128;\n\t\t\treturn p;\n\t\t}\n\t}\n\n\t/* new decoration */\n\tif (i < DC_NAME_SZ) {\n//\t\tif (parse.abc_state != ABC_S_GLOBAL)\n//\t\t\tlvlarena(0);\n\t\t*t = getarena(l + 1);\n//\t\tif (parse.abc_state != ABC_S_GLOBAL)\n//\t\t\tlvlarena(1);\n\t\tmemcpy(*t, q, l);\n\t\t(*t)[l] = '\\0';\n\t\t*p_dc = i + 128;\n\t} else {\n\t\tsyntax(\"Too many decoration types\", q);\n\t}\n\treturn p;\n}\n\n/* -- parse a list of accidentals (K:) -- */\nstatic char *parse_acc(char *p,\n\t\t\tstruct SYMBOL *s)\n{\n\tint pit = 0, acc;\n\tunsigned nacc;\n\n\tnacc = 0;\n\tfor (;;) {\n\t\tif (nacc >= sizeof s->u.key.pits) {\n\t\t\tsyntax(\"Too many accidentals\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\tif (acc < 0)\n\t\t\tbreak;\n\t\ts->u.key.pits[nacc] = pit;\n\t\ts->u.key.accs[nacc++] = acc;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tif (*p != '^' && *p != '_' && *p != '=')\n\t\t\tbreak;\n\t}\n\ts->u.key.microscale = microscale;\n\tif (s->u.key.empty != 2)\n\t\ts->u.key.nacc = nacc;\n\treturn p;\n}\n\n/* -- parse a clef (K: or V:) -- */\nstatic void parse_clef(struct SYMBOL *s,\n\t\t\tchar *name,\n\t\t\tchar *middle)\n{\n\tint clef = -1;\n\tint transpose = 0;\n\tint clef_line = 2;\n\tchar *warn = NULL;\n\tchar str[80];\n\n\tstr[0] = '\\0';\n\tif (name && strncmp(name, \"clef=\", 5) == 0) {\n\t\tname += 5;\n\t\tswitch (*name) {\n\t\tcase '\\\"':\n\t\t\tname = get_str(str, name, sizeof str);\n\t\t\ts->u.clef.name = getarena(strlen(str) + 1);\n\t\t\tstrcpy(s->u.clef.name, str);\n\t\t\tclef = TREBLE;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\twarn = name;\n\t\t\ttranspose = -7;\n\t\tcase 'G':\n\t\t\tclef = TREBLE;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\twarn = name;\n\t\t\ttranspose = -14;\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (name[1] == ',')\t/* abc2.1.1 clef=F == clef=F, */\n\t\t\t\ttranspose = -7;\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\twarn = name;\n\t\t\ttranspose = -7;\n\t\tcase 'C':\n\t\t\tclef = ALTO;\n\t\t\tclef_line = 3;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tclef = PERC;\n\t\t\tclef_line = 3;\n\t\t\tbreak;\n\t\t}\n\t\tif (clef >= 0) {\n\t\t\tname++;\n\t\t\tif (*name == ',' || *name== '\\'')\n\t\t\t\twarn = name;\n\t\t\twhile (*name == ',') {\n\t\t\t\ttranspose += 7;\n\t\t\t\tname++;\n\t\t\t}\n\t\t\twhile (*name == '\\'') {\n\t\t\t\ttranspose -= 7;\n\t\t\t\tname++;\n\t\t\t}\n\t\t}\n\t}\n\tif (name && clef < 0) {\n\t\tif (!strncmp(name, \"bass\", 4)) {\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\ts->u.clef.check_pitch = 1;\n\t\t\tname += 4;\n\t\t} else if (!strncmp(name, \"treble\", 6)) {\n\t\t\tclef = TREBLE;\n\t\t\tname += 6;\n\t\t} else if (!strncmp(name, \"alto\", 4)\n\t\t\t|| !strncmp(name, \"tenor\", 5)) {\n\t\t\tclef = ALTO;\n\t\t\tclef_line = *name == 'a' ? 3 : 4;\n\t\t\ts->u.clef.check_pitch = 1;\n\t\t\tif (*name == 'a')\n\t\t\t\tname += 4;\n\t\t\telse\n\t\t\t\tname += 5;\n\t\t} else if (!strncmp(name, \"perc\", 4)) {\n\t\t\tclef = PERC;\n\t\t\tclef_line = 3;\n\t\t\tname += 4;\n\t\t} else if (!strncmp(name, \"auto\", 4)) {\n\t\t\tclef = AUTOCLEF;\n\t\t\tname += 4;\n\t\t} else if (strncmp(name, \"none\", 4) == 0) {\n\t\t\tclef = TREBLE;\n\t\t\ts->u.clef.invis = 1;\n\t\t\ts->flags |= ABC_F_INVIS;\n\t\t\tname += 4;\n\t\t} else {\n\t\t\tsyntax(\"Unknown clef\", name);\n\t\t\tclef = TREBLE;\n\t\t}\n\t}\n\n\tif (clef >= 0) {\n\t\tif (isdigit((unsigned char) *name))\n\t\t\tclef_line = *name++ - '0';\n\t\tif (name[1] == '8') {\n\t\t\tswitch (*name) {\n\t\t\tcase '^':\n\t\t\t\ttranspose -= 7;\n\t\t\tcase '+':\n\t\t\t\ts->u.clef.octave = 1;\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\ttranspose += 7;\n\t\t\tcase '-':\n\t\t\t\ts->u.clef.octave = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (middle) {\n\t\tint pit = 0, acc, l;\n\t\tstatic const char line_tb[7] =\n\t\t\t{ALTO, TREBLE, ALTO, BASS, ALTO, BASS, ALTO};\n\n\t\twarn = middle;\n\t\t/* 'middle=<note pitch>' */\n\t\tparse_acc_pit(middle, &pit, &acc);\n\t\tif (acc < 0)\t\t\t// if error\n\t\t\tpit = 22;\n\n\t\tif (clef < 0)\n\t\t\tclef = line_tb[(pit + 7) % 7];\n\t\n\t\tswitch (clef) {\n\t\tdefault:\n\t\t\tl = 20 + 4;\n\t\t\tbreak;\n\t\tcase ALTO:\n\t\t\tl = 16 + 4;\n\t\t\tbreak;\n\t\tcase BASS:\n\t\t\tl = 12 + 4;\n\t\t\tbreak;\n\t\t}\n\t\tclef_line = (l - pit + 28) % 7;\n\t\tif (clef_line & 1) {\n\t\t\tsyntax(\"Bad 'middle' value for the clef\", middle);\n\t\t\tpit++;\n\t\t}\n\t\tclef_line = clef_line / 2 + 1;\n\n\t\ttranspose = l - (clef_line - 1) * 2 - pit;\n\t\ts->u.clef.check_pitch = 0;\n\t}\n\n\ts->u.clef.type = clef;\n\ts->u.clef.line = clef_line;\n\ts->u.clef.transpose = transpose;\n\tif (warn) {\n\t\tint sev_sav;\n\n\t\tsev_sav = severity;\n\t\tsyntax(\"Warning: Deprecated or non-standard item\", warn);\n\t\tseverity = sev_sav;\n\t}\n}\n\n/* get the octave= value */\nstatic int parse_octave(char *p)\n{\n\tint oct;\n\n\tif (p) {\n\t\toct = 1;\n\t\tif (*p == '-') {\n\t\t\toct = -1;\n\t\t\tp++;\n\t\t}\n\t\tif (*p >= '0' && *p <= '4')\n\t\t\treturn oct * (*p - '0');\n\t\tsyntax(\"Bad octave value\", p);\n\t}\n\treturn NO_OCTAVE;\n}\n\n/* -- parse a 'K:' -- */\nstatic void parse_key(char *p,\n\t\t      struct SYMBOL *s)\n{\n\tint sf, empty, instr;\n//\tint mode;\n\tchar *clef_name, *clef_middle, *clef_stlines, *clef_scale;\n\tchar *p_octave, *p_cue, *p_map;\n\n\t// set important default values\n//\ts->u.key.stafflines = \"|||||\";\n\ts->u.key.octave = NO_OCTAVE;\n\n\tif (*p == '\\0') {\n\t\ts->u.key.empty = 1;\n\t\treturn;\n\t}\n\tsf = 0;\n//\tmode = 0;\n\tempty = 0;\n\tinstr = 0;\n\tswitch (*p++) {\n\tcase 'F': sf = -1; break;\n\tcase 'B': sf++;\n\tcase 'E': sf++;\n\tcase 'A': sf++;\n\tcase 'D': sf++;\n\tcase 'G': sf++;\n\tcase 'C': break;\n\tcase 'H':\n\t\tif (*p == 'P') {\n\t\t\tinstr = K_HP;\n\t\t\tp++;\n\t\t} else if (*p == 'p') {\n\t\t\tinstr = K_Hp;\n\t\t\tsf = 2;\n\t\t\tp++;\n\t\t} else {\n\t\t\tsyntax(\"Unknown bagpipe-like key\", p);\n\t\t}\n\t\tbreak;\n\tcase 'P':\n\t\tinstr = K_DRUM;\n\t\tp++;\n\t\tbreak;\n\tcase 'n':\n\t\tif (strncmp(p, \"one\", 3) == 0) {\t// none\n\t\t\tempty = 2;\n\t\t\tp += 3;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0') {\n\t\t\t\ts->u.key.empty = empty;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// fall thru\n\tdefault:\n\t\tp--;\n\t\tempty = 1;\n\t\tbreak;\n\t}\n\ts->u.key.empty = empty;\n\n\tif (!empty) {\n\t\tif (*p == '#') {\n\t\t\tsf += 7;\n\t\t\tp++;\n\t\t} else if (*p == 'b') {\n\t\t\tsf -= 7;\n\t\t\tp++;\n\t\t}\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tswitch (*p) {\n\t\tcase 'a':\n\t\tcase 'A':\n\t\t\tif (strncasecmp(p, \"aeo\", 3) == 0) {\n\t\t\t\tsf -= 3;\n//\t\t\t\tmode = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tif (strncasecmp(p, \"dor\", 3) == 0) {\n\t\t\t\tsf -= 2;\n//\t\t\t\tmode = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\tif (strncasecmp(p, \"ion\", 3) == 0) {\n//\t\t\t\tmode = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tif (strncasecmp(p, \"loc\", 3) == 0) {\n\t\t\t\tsf -= 5;\n//\t\t\t\tmode = 6;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"lyd\", 3) == 0) {\n\t\t\t\tsf += 1;\n//\t\t\t\tmode = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tif (strncasecmp(p, \"maj\", 3) == 0)\n\t\t\t\tbreak;\n\t\t\tif (strncasecmp(p, \"mix\", 3) == 0) {\n\t\t\t\tsf -= 1;\n//\t\t\t\tmode = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"min\", 3) == 0\n\t\t\t || !isalpha((unsigned char) p[1])) { /* 'm' alone */\n\t\t\t\tsf -= 3;\n//\t\t\t\tmode = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tif (strncasecmp(p, \"phr\", 3) == 0) {\n\t\t\t\tsf -= 4;\n//\t\t\t\tmode = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tdefault:\nunk:\n\t\t\tempty = 1;\t\t\t// (local value)\n\t\t\tbreak;\n\t\t}\n\t\tif (!empty) {\n\t\t\twhile (isalpha((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t}\n\n\t\t// [exp] accidentals\n\t\tif (strncmp(p, \"exp \", 4) == 0) {\n\t\t\tp += 4;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0')\n\t\t\t\tsyntax(\"no accidental after 'exp'\", p);\n\t\t\ts->u.key.exp = 1;\n\t\t}\n\t\tif (s->u.key.exp && strncmp(p, \"none\", 4) == 0) {\n\t\t\tsf = 0;\n\t\t\tp += 4;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t} else switch (*p) {\n\t\t\tcase '^':\n\t\t\tcase '_':\n\t\t\tcase '=':\n\t\t\t\tp = parse_acc(p, s);\t\t/* accidentals */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sf > 7 || sf < -7) {\n\t\tsyntax(\"Too many sharps/flats\", p);\n\t\tif (sf > 0)\n\t\t\tsf -= 12;\n\t\telse\n\t\t\tsf += 12;\n\t}\n\n\t// extra parameters\n\tclef_name = clef_middle = clef_stlines = clef_scale = NULL;\n\tp_octave = p_cue = p_map = NULL;\n\tparse_extra(p, &clef_name, &clef_middle, &clef_stlines,\n\t\t\t&clef_scale, &p_octave, &p_cue, &p_map);\n\n\ts->u.key.sf = sf;\n//\ts->u.key.mode = mode;\n\ts->u.key.instr = instr;\n\ts->u.key.octave = parse_octave(p_octave);\n\tif (p_cue) {\n\t\tif (strncmp(p_cue, \"on\", 2) == 0)\n\t\t\ts->u.key.cue = 1;\n\t\telse\n\t\t\ts->u.key.cue = -1;\n\t}\n\tif (clef_stlines)\n\t\ts->u.key.stafflines = clef_stlines;\n\tif (clef_scale) {\n\t\tfloat sc;\n\n\t\tsc = atof(clef_scale);\n\t\tif (sc >= 0.5 && sc <= 3)\n\t\t\ts->u.key.staffscale = sc;\n\t\telse\n\t\t\tsyntax(\"Bad value of staffscale\", clef_scale);\n\t}\n\tif (clef_name || clef_middle) {\n\t\ts = abc_new(ABC_T_CLEF, NULL);\n\t\tparse_clef(s, clef_name, clef_middle);\n\t}\n\tif (p_map) {\n\t\tstrcpy(tex_buf, \"%%voicemap \");\n\t\tget_str(&tex_buf[11], p_map, TEX_BUF_SZ - 12);\n\t\tabc_new(ABC_T_PSCOM, tex_buf);\n\t}\n}\n\n/* -- set default length from 'L:' -- */\nstatic char *get_len(char *p,\n\t\t     struct SYMBOL *s)\n{\n\tint l1, l2, d;\n\tchar *error_txt = NULL;\n\n\tif (strcmp(p, \"auto\") == 0) {\t\t/* L:auto */\n\t\tulen = 15120;\t\t\t// 2*2*2*2*3*3*3*5*7\n\t\ts->u.length.base_length = -1;\n\t\treturn error_txt;\n\t}\n\tl1 = 0;\n\tl2 = 1;\n\tif (sscanf(p, \"%d /%d \", &l1, &l2) != 2\n\t || l1 == 0) {\n\t\ts->u.length.base_length = ulen ? ulen : BASE_LEN / 8;\n\t\treturn \"Bad unit note length: unchanged\";\n\t}\n\n\tif (l2 == 0) {\n\t\terror_txt = \"Bad length divisor, set to 4\";\n\t\tl2 = 4;\n\t}\n\td = BASE_LEN / l2;\n\tif (d * l2 != BASE_LEN) {\n\t\terror_txt = \"Length incompatible with BASE, using 1/8\";\n\t\td = BASE_LEN / 8;\n\t} else \t{\n\t\td *= l1;\n\t\tif (l1 != 1\n\t\t || (l2 & (l2 - 1))) {\n\t\t\terror_txt = \"Incorrect unit note length, using 1/8\";\n\t\t\td = BASE_LEN / 8;\n\t\t}\n\t}\n\ts->u.length.base_length = d;\n\treturn error_txt;\n}\n\n/* -- parse a 'M:' -- */\nstatic char *parse_meter(char *p,\n\t\t\t\tstruct SYMBOL *s)\n{\n\tint m1, m2, d, wmeasure, nm, in_parenth;\n\tunsigned i;\n\tchar *q;\nstatic char top_err[] = \"Cannot identify meter top\";\n\n\tif (*p == '\\0')\n\t\treturn \"Empty meter string\";\n\tnm = 0;\n\tin_parenth = 0;\n\tm1 = 0;\n\tif (strncmp(p, \"none\", 4) == 0) {\n\t\tp += 4;\t\t\t\t/* no meter */\n\t\twmeasure = 1;\t/* simplify measure numbering and MREST conversion */\n\t} else {\n\t    wmeasure = 0;\n\t    while (*p != '\\0') {\n\t\tif (*p == '=')\n\t\t\tbreak;\n\t\tif (nm >= MAX_MEASURE)\n\t\t\treturn \"Too many values in M:\";\n\t\tswitch (*p) {\n\t\tcase 'C':\n\t\t\ts->u.meter.meter[nm].top[0] = *p++;\n\t\t\tif (*p == '|')\n\t\t\t\ts->u.meter.meter[nm].top[1] = *p++;\n\t\t\tm1 = 4;\n\t\t\tm2 = 4;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\tcase 'o':\n\t\t\tif (*p == 'c')\n\t\t\t\tm1 = 4;\n\t\t\telse\n\t\t\t\tm1 = 3;\n\t\t\tm2 = 4;\n\t\t\ts->u.meter.meter[nm].top[0] = *p++;\n\t\t\tif (*p == '.')\n\t\t\t\ts->u.meter.meter[nm].top[1] = *p++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tif (p[1] == '(') {\t/* \"M:5/4 ((2+3)/4)\" */\n\t\t\t\tin_parenth = 1;\n\t\t\t\ts->u.meter.meter[nm++].top[0] = *p++;\n\t\t\t}\n\t\t\tq = p + 1;\n\t\t\twhile (*q != '\\0') {\n\t\t\t\tif (*q == ')' || *q == '/')\n\t\t\t\t\tbreak;\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (*q == ')' && q[1] == '/') {\t/* \"M:5/4 (2+3)/4\" */\n\t\t\t\tp++;\t\t/* remove the parenthesis */\n\t\t\t\tcontinue;\n\t\t\t}\t\t\t/* \"M:5 (2+3)\" */\n\t\t\t/* fall thru */\n\t\tcase ')':\n\t\t\tin_parenth = *p == '(';\n\t\t\ts->u.meter.meter[nm++].top[0] = *p++;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (sscanf(p, \"%d\", &m1) != 1\n\t\t\t || m1 <= 0)\n\t\t\t\treturn top_err;\n\t\t\ti = 0;\n\t\t\tm2 = 2;\t\t\t/* default when no bottom value */\n\t\t\tfor (;;) {\n\t\t\t\twhile (isdigit((unsigned char) *p)\n\t\t\t\t    && i < sizeof s->u.meter.meter[0].top)\n\t\t\t\t\ts->u.meter.meter[nm].top[i++] = *p++;\n\t\t\t\tif (*p == ')') {\n\t\t\t\t\tif (p[1] != '/')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (*p == '/') {\n\t\t\t\t\tp++;\n\t\t\t\t\tif (sscanf(p, \"%d\", &m2) != 1\n\t\t\t\t\t || m2 <= 0)\n\t\t\t\t\t\treturn \"Cannot identify meter bottom\";\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (isdigit((unsigned char) *p)\n\t\t\t\t\t    && i < sizeof s->u.meter.meter[0].bot)\n\t\t\t\t\t\ts->u.meter.meter[nm].bot[i++] = *p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*p != ' ' && *p != '+')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == '\\0' || p[1] == '(')\t/* \"M:5 (2/4+3/4)\" */\n\t\t\t\t\tbreak;\n\t\t\t\tif (i < sizeof s->u.meter.meter[0].top)\n\t\t\t\t\ts->u.meter.meter[nm].top[i++] = *p++;\n\t\t\t\tif (sscanf(p, \"%d\", &d) != 1\n\t\t\t\t || d <= 0)\n\t\t\t\t\treturn top_err;\n\t\t\t\tif (p[-1] == ' ') {\n\t\t\t\t\tif (d > m1)\n\t\t\t\t\t\tm1 = d;\n\t\t\t\t} else {\n\t\t\t\t\tm1 += d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!in_parenth)\n\t\t\twmeasure += m1 * BASE_LEN / m2;\n\t\tnm++;\n\t\tif (*p == ' ')\n\t\t\tp++;\n\t\telse if (*p == '+')\n\t\t\ts->u.meter.meter[nm++].top[0] = *p++;\n\t    }\n\t}\n\tmeter = m1;\n\tif (*p == '=') {\n\t\tif (sscanf(++p, \"%d/%d\", &m1, &m2) != 2\n\t\t || m1 <= 0\n\t\t || m2 <= 0)\n\t\t\treturn \"Cannot identify meter explicit duration\";\n\t\twmeasure = m1 * BASE_LEN / m2;\n\t\ts->u.meter.expdur = 1;\n\t}\n\ts->u.meter.wmeasure = wmeasure;\n\ts->u.meter.nmeter = nm;\n\n\t/* in the tune header, change the unit note length */\n\tif (parse.abc_state == ABC_S_HEAD && ulen == 0) {\n\t\tif (wmeasure >= BASE_LEN * 3 / 4\n\t\t || wmeasure <= 1)\n\t\t\tulen = BASE_LEN / 8;\n\t\telse\n\t\t\tulen = BASE_LEN / 16;\n\t}\n\treturn 0;\n}\n\n/* -- get a possibly quoted string -- */\nchar *get_str(char *d,\t\t/* destination */\n\t      char *s,\t\t/* source */\n\t      int maxlen)\t/* max length */\n{\n\tchar c;\n\n\tmaxlen--;\t\t/* have place for the EOS */\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s == '\"') {\n\t\ts++;\n\t\twhile ((c = *s) != '\\0') {\n\t\t\tif (c == '\"') {\n\t\t\t\ts++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '\\\\') {\n\t\t\t\tif (--maxlen > 0)\n\t\t\t\t\t*d++ = c;\n\t\t\t\tc = *++s;\n\t\t\t}\n\t\t\tif (--maxlen > 0)\n\t\t\t\t*d++ = c;\n\t\t\ts++;\n\t\t}\n\t} else {\n\t\twhile ((c = *s) != '\\0') {\n\t\t\tif (isspace((unsigned char) c))\n\t\t\t\tbreak;\n\t\t\tif (--maxlen > 0)\n\t\t\t\t*d++ = c;\n\t\t\ts++;\n\t\t}\n\t}\n\t*d = '\\0';\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\treturn s;\n}\n\n/* -- parse a tempo (Q:) -- */\nstatic char *parse_tempo(char *p,\n\t\t\t struct SYMBOL *s)\n{\n\tchar c, str[80];\n\tint i, l, n, top, bot;\n\n\t/* string before */\n\tif (*p == '\"') {\n\t\tp = get_str(str, p, sizeof str);\n\t\ts->u.tempo.str1 = getarena(strlen(str) + 1);\n\t\tstrcpy(s->u.tempo.str1, str);\n\t}\n\n\t/* beat */\n\tif (*p == 'C' || *p == 'c'\n\t || *p == 'L' || *p == 'l') {\n\t\ts->u.tempo.beats[0] = ulen;\n\t\tif (parse.abc_vers >= (2 << 16))\n\t\t\tsyntax(\"Deprecated Q: value\", p);\n\t\tp++;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p != '=')\n\t\t\tgoto inval;\n\t\tc = '=';\n\t\tp--;\n\t} else if (isdigit((unsigned char) *p)) {\n\t\tif (strchr(p, '/') != NULL) {\n\t\t\ti = 0;\n\t\t\twhile (isdigit((unsigned char) *p)) {\n\t\t\t\tif (sscanf(p, \"%d/%d%n\", &top, &bot, &n) != 2\n\t\t\t\t || bot <= 0)\n\t\t\t\t\tgoto inval;\n\t\t\t\tl = (BASE_LEN * top) / bot;\n\t\t\t\tif (l <= 0\n\t\t\t\t || i >= sizeof s->u.tempo.beats\n\t\t\t\t\t\t/ sizeof s->u.tempo.beats[0])\n\t\t\t\t\tgoto inval;\n\t\t\t\ts->u.tempo.beats[i++] = l;\n\t\t\t\tp += n;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t}\n\t\t\tc = *p;\n\t\t\tif (c != '=')\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\ts->u.tempo.beats[0] = ulen;\n\t\t\tif (parse.abc_vers >= (2 << 16))\n\t\t\t\tsyntax(\"Deprecated Q: value\", p);\n\t\t\tc = '=';\n\t\t\tp--;\n\t\t}\n\t} else {\n\t\tc = '\\0';\n\t}\n\n\t/* tempo value */\n\tif (c == '=') {\n\t\tp++;\n\t\tif (strncmp(p, \"ca. \", 4) == 0) {\n\t\t\ts->u.tempo.circa = 1;\n\t\t\tp += 4;\n\t\t}\n\t\tif (sscanf(p, \"%d/%d%n\", &top, &bot, &n) == 2) {\n\t\t\tif (bot <= 0)\n\t\t\t\tgoto inval;\n\t\t\tl = (BASE_LEN * top) / bot;\n\t\t\tif (l <= 0)\n\t\t\t\tgoto inval;\n\t\t\ts->u.tempo.new_beat = l;\n\t\t} else {\n\t\t\tif (sscanf(p, \"%d%n\", &top, &n) != 1)\n\t\t\t\tgoto inval;\n\t\t\ts->u.tempo.tempo = top;\n\t\t}\n\t\tp += n;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t}\n\n\t/* string after */\n\tif (*p == '\"') {\n\t\tp = get_str(str, p, sizeof str);\n\t\ts->u.tempo.str2 = getarena(strlen(str) + 1);\n\t\tstrcpy(s->u.tempo.str2, str);\n\t}\n\n\treturn 0;\ninval:\n\treturn \"Invalid tempo\";\n}\n\n/* -- get a user defined symbol (U:) -- */\nstatic char *get_user(char *p,\n\t\t      struct SYMBOL *s)\n{\n\tunsigned char c;\n\tchar *value;\n\n\tc = (unsigned char) *p++;\n\tif (c == '\\\\') {\n\t\tc = (unsigned char) *p++;\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tc = '\\n';\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tc = '\\t';\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (char_tb[c]) {\n\tdefault:\n\t\treturn \"Bad decoration character\";\n\tcase CHAR_DECO:\n\t\tbreak;\n\tcase CHAR_BAD:\n\tcase CHAR_IGN:\n\tcase CHAR_SPAC:\n\tcase CHAR_DECOS:\n\tcase CHAR_LINEBREAK:\n\t\tchar_tb[c] = CHAR_DECO;\n\t\tbreak;\n\t}\n\ts->u.user.symbol = c;\n\n\t/* skip '=' */\n\twhile (isspace((unsigned char) *p) || *p == '=')\n\t\tp++;\n\tif (char_tb[(unsigned char) *p] == CHAR_DECOS)\n\t\tp++;\n/*fixme: 'U: <char> = \"text\"' is not treated */\n\tget_deco(p, &s->u.user.value);\n\tif (!s->u.user.value)\n\t\treturn 0;\n\n\t/* treat special pseudo decorations */\n\tvalue = parse.deco_tb[s->u.user.value - 128];\n\tif (strcmp(value, \"beambreak\") == 0)\n\t\tchar_tb[c] = CHAR_SPAC;\n\telse if (strcmp(value, \"ignore\") == 0)\n\t\tchar_tb[c] = CHAR_IGN;\n\telse if (strcmp(value, \"nil\") == 0\n\t      || strcmp(value, \"none\") == 0)\n\t\tchar_tb[c] = CHAR_BAD;\n\telse\n\t\treturn 0;\n\ts->u.user.value\t= 0;\t\t/* not a decoration */\n\treturn 0;\n}\n\n/* -- parse the voice parameters (V:) -- */\nstatic char *parse_voice(char *p,\n\t\t\t struct SYMBOL *s)\n{\n\tint voice;\n\tchar *error_txt = NULL;\n\tchar *clef_name, *clef_middle, *clef_stlines, *clef_scale;\n\tchar *p_octave, *p_cue, *p_map;\n\tsigned char *p_stem;\nstatic struct kw_s {\n\tchar *name;\n\tshort len;\n\tshort index;\n} kw_tb[] = {\n\t{\"name=\", 5, 0},\n\t{\"nm=\", 3, 0},\n\t{\"subname=\", 8, 1},\n\t{\"sname=\", 6, 1},\n\t{\"snm=\", 4, 1},\n\t{\"merge\", 5, 2},\n\t{\"up\", 2, 3},\n\t{\"down\", 4, 4},\n\t{\"stem=\", 5, 5},\n\t{\"gstem=\", 6, 6},\n\t{\"auto\", 4, 7},\n\t{\"dyn=\", 4, 8},\n\t{\"lyrics=\", 7, 9},\n\t{\"scale=\", 6, 10},\n\t{\"gchord=\", 7, 11},\n\t{0}\n};\n\tstruct kw_s *kw;\n\n\t/* save the parameters of the previous voice */\n\tcurvoice->ulen = ulen;\n\tcurvoice->microscale = microscale;\n\n\tif (voice_tb[0].id[0] == '\\0') {\n\t\tswitch (s->abc_prev->abc_type) {\n\t\tcase ABC_T_EOLN:\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\tcase ABC_T_BAR:\n\t\t\t/* the previous voice was implicit (after K:) */\n\t\t\tvoice_tb[0].id[0] = '1';\n\t\t\tbreak;\n\t\t}\n\t}\n\t{\n\t\tchar *id, sep;\n\n\t\tid = p;\n\t\twhile (isalnum((unsigned char) *p) || *p == '_')\n\t\t\tp++;\n\t\tsep = *p;\n\t\t*p = '\\0';\n\t\tif (voice_tb[0].id[0] == '\\0') {\n\t\t\tvoice = 0;\t\t\t/* first voice */\n\t\t} else {\n\t\t\tfor (voice = 0; voice <= nvoice; voice++) {\n\t\t\t\tif (strcmp(id, voice_tb[voice].id) == 0)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tif (voice >= MAXVOICE) {\n\t\t\t\tsyntax(\"Too many voices\", id);\n\t\t\t\tvoice--;\n\t\t\t}\n\t\t}\n\t\tnvoice = voice;\n\t\tstrncpy(voice_tb[voice].id, id, sizeof voice_tb[voice].id - 1);\n\t\tvoice_tb[voice].mvoice = voice;\n\tfound:\n\t\tstrcpy(s->u.voice.id, voice_tb[voice].id);\n\t\t*p = sep;\n\t}\n\tcurvoice = &voice_tb[voice];\n\ts->u.voice.voice = voice;\n\n\t/* if in tune, set the voice parameters */\n\tif (parse.abc_state == ABC_S_TUNE) {\n\t\tulen = curvoice->ulen;\n\t\tmicroscale = curvoice->microscale;\n\t}\n\n\t/* parse the other parameters */\n\tclef_name = clef_middle = clef_stlines = clef_scale = NULL;\n\tp_octave = p_cue = p_map = NULL;\n\tp_stem = &s->u.voice.stem;\n\tfor (;;) {\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tp = parse_extra(p, &clef_name, &clef_middle, &clef_stlines,\n\t\t\t\t&clef_scale, &p_octave, &p_cue, &p_map);\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tfor (kw = kw_tb; kw->name; kw++) {\n\t\t\tif (strncmp(p, kw->name, kw->len) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!kw->name) {\n\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\tp++;\t/* ignore unknown keywords */\n\t\t\tcontinue;\n\t\t}\n\t\tp += kw->len;\n\t\tswitch (kw->index) {\n\t\tcase 0:\t\t\t/* name */\n\t\t\tp = get_str(tex_buf, p, TEX_BUF_SZ);\n\t\t\ts->u.voice.fname = getarena(strlen(tex_buf) + 1);\n\t\t\tstrcpy(s->u.voice.fname, tex_buf);\n\t\t\tbreak;\n\t\tcase 1:\t\t\t/* subname */\n\t\t\tp = get_str(tex_buf, p, TEX_BUF_SZ);\n\t\t\ts->u.voice.nname = getarena(strlen(tex_buf) + 1);\n\t\t\tstrcpy(s->u.voice.nname, tex_buf);\n\t\t\tbreak;\n\t\tcase 2:\t\t\t/* merge */\n\t\t\ts->u.voice.merge = 1;\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* up */\n\t\t\t*p_stem = 1;\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* down */\n\t\t\t*p_stem = -1;\n\t\t\tbreak;\n\t\tcase 5:\t\t\t/* stem= */\n\t\t\tp_stem = &s->u.voice.stem;\n\t\t\tbreak;\n\t\tcase 6:\t\t\t/* gstem= */\n\t\t\tp_stem = &s->u.voice.gstem;\n\t\t\tbreak;\n\t\tcase 7:\t\t\t/* auto */\n\t\t\t*p_stem = 2;\n\t\t\tbreak;\n\t\tcase 8:\t\t\t/* dyn= */\n\t\t\tp_stem = &s->u.voice.dyn;\n\t\t\tbreak;\n\t\tcase 9:\t\t\t/* lyrics= */\n\t\t\tp_stem = &s->u.voice.lyrics;\n\t\t\tbreak;\n\t\tcase 10: {\t\t/* scale= */\n\t\t\tfloat sc;\n\n\t\t\tsc = atof(p);\n\t\t\tif (sc >= 0.5 && sc <= 2)\n\t\t\t\ts->u.voice.scale = sc;\n\t\t\telse\n\t\t\t\terror_txt = \"Bad value for voice scale\";\n\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\tp++;\n\t\t\tbreak;\n\t\t    }\n\t\tcase 11:\t\t/* gchord= */\n\t\t\tp_stem = &s->u.voice.gchord;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ts->u.voice.octave = parse_octave(p_octave);\n\tif (p_cue) {\n\t\tif (strncmp(p_cue, \"on\", 2) == 0)\n\t\t\ts->u.voice.cue = 1;\n\t\telse\n\t\t\ts->u.voice.cue = -1;\n\t}\n\tif (clef_stlines)\n\t\ts->u.voice.stafflines = clef_stlines;\n//\telse\n//\t\ts->u.voice.stafflines = \"|||||\";\n\tif (clef_scale) {\n\t\tfloat sc;\n\n\t\tsc = atof(clef_scale);\n\t\tif (sc >= 0.5 && sc <= 3)\n\t\t\ts->u.voice.staffscale = sc;\n\t\telse\n\t\t\tsyntax(\"Bad value of staffscale\", clef_scale);\n\t}\n\tif (clef_name || clef_middle) {\n\t\ts = abc_new(ABC_T_CLEF, NULL);\n\t\tparse_clef(s, clef_name, clef_middle);\n\t}\n\tif (p_map) {\n\t\tstrcpy(tex_buf, \"%%voicemap \");\n\t\tget_str(&tex_buf[11], p_map, TEX_BUF_SZ - 12);\n\t\tabc_new(ABC_T_PSCOM, tex_buf);\n\t}\n\treturn error_txt;\n}\n\n/* -- parse a bar -- */\nstatic char *parse_bar(char *p)\n{\n\tstruct SYMBOL *s;\n\tchar *q;\n\tint bar_type, i;\n\tchar repeat_value[32];\n\n\tq = --p;\t\t\t// keep the first char\n\tbar_type = 0;\n\tfor (;;) {\n\t\tswitch (*p++) {\n\t\tcase '|':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_BAR;\n\t\t\tcontinue;\n\t\tcase '[':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_OBRA;\n\t\t\tcontinue;\n\t\tcase ']':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_CBRA;\n\t\t\tcontinue;\n\t\tcase ':':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_COL;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tp--;\n\n\t/* if the last element is '[', it may start\n\t * a chord, an embedded header or an other bar */\n\tif ((bar_type & 0x0f) == B_OBRA && bar_type != B_OBRA\n\t && *p != ' ') {\n\t\tbar_type >>= 4;\n\t\tp--;\n\t}\n\n\tif (bar_type == (B_OBRA << 8) + (B_BAR << 4) + B_CBRA)\t/* [|] */\n\t\tbar_type = (B_OBRA << 4) + B_CBRA;\t\t/* [] */\n\n/*\tcurvoice->last_note = NULL; */\n\tif (vover > 0) {\n\t\tcurvoice = &voice_tb[curvoice->mvoice];\n\t\tvover = 0;\n\t}\n\ts = abc_new(ABC_T_BAR, gchord);\n\tif (gchord)\n\t\tgchord = NULL;\n\n\t/* handle the repeat sequences */\n\tif (bar_type == B_COL) {\n\t\tbar_type = B_BAR;\n\t\ts->u.bar.dotted = 1;\n\t} else {\n\t\tif (*q == ']') {\t\t/* repeat bar stop */\n\t\t\ti = p - q - 1;\n\t\t\tif (i > 0)\t\t/* remove the starting ']' */\n\t\t\t\ts->u.bar.type &= (1 << (i * 4)) - 1;\n\t\t\ts->flags |= ABC_F_RBSTOP;\n\t\t\ts->sflags |= S_RBSTOP;\n\t\t} else if ((bar_type & 0x0f) == B_COL\t/* left or */\n\t\t\t|| *q == ':') {\t\t\t/* right repeat bar */\n\t\t\ts->flags |= ABC_F_RBSTOP;\n\t\t\ts->sflags |= S_RBSTOP;\n\t\t\tif (*q == ':')\t\t/* right repeat bar */\n\t\t\t\ts->sflags |= S_RRBAR;\n\t\t}\n\t}\n\n\ts->u.bar.type = bar_type;\n\n\tif (dc.n > 0) {\n\t\tmemcpy(&s->u.bar.dc, &dc, sizeof s->u.bar.dc);\n\t\tdc.n = 0;\n\t}\n\n\tif (!lyric_started) {\n\t\tlyric_started = 1;\n\t\ts->flags |= ABC_F_LYRIC_START;\n\t}\n\n\tif (!isdigit((unsigned char) *p)\t/* if not a repeat bar */\n\t && (*p != '\"' || p[-1] != '['))\t/* ('[\"' only) */\n\t\treturn p;\n\n\tif (*p == '\"') {\n\t\tp = get_str(repeat_value, p, sizeof repeat_value);\n\t} else {\n\t\tchar *q;\n\n\t\tq = repeat_value;\n\t\twhile (isdigit((unsigned char) *p)\n\t\t    || *p == ','\n\t\t    || *p == '-'\n\t\t    || (*p == '.' && isdigit((unsigned char) p[1]))) {\n\t\t\tif (q < &repeat_value[sizeof repeat_value - 1])\n\t\t\t\t*q++ = *p++;\n\t\t\telse\n\t\t\t\tp++;\n\t\t}\n\t\t*q = '\\0';\n\t}\n\tif (bar_type != B_OBRA\n\t || s->text) {\n\t\ts = abc_new(ABC_T_BAR, repeat_value);\n\t\ts->u.bar.type = B_OBRA;\n\t} else {\n\t\ts->text = getarena(strlen(repeat_value) + 1);\n\t\tstrcpy(s->text, repeat_value);\n\t}\n\ts->u.bar.repeat_bar = 1;\n\ts->flags |= ABC_F_RBSTART | ABC_F_RBSTOP;\n\ts->sflags |= S_RBSTART | S_RBSTOP;\n\treturn p;\n}\n\n// parse the note accidental and pitch\nchar *parse_acc_pit(char *p,\n\t\tint *pit,\n\t\tint *acc)\n{\n\t/* look for accidental sign */\n\tswitch (*p) {\n\tcase '^':\n\t\tp++;\n\t\tif (*p == '^') {\n\t\t\tp++;\n\t\t\t*acc = A_DS;\n\t\t} else {\n\t\t\t*acc = A_SH;\n\t\t}\n\t\tbreak;\n\tcase '=':\n\t\tp++;\n\t\t*acc = A_NT;\n\t\tbreak;\n\tcase '_':\n\t\tp++;\n\t\tif (*p == '_') {\n\t\t\tp++;\n\t\t\t*acc = A_DF;\n\t\t} else {\n\t\t\t*acc = A_FT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*acc = 0;\n\t}\n\n\t/* look for microtone value */\n\tif (*acc != 0\n\t && (isdigit((unsigned char) *p)\n\t  || (*p == '/' && microscale == 0))) {\n\t\tint n, d;\n\t\tchar *q;\n\n\t\tn = d = 1;\n\t\tif (*p != '/') {\n\t\t\tn = strtol(p, &q, 10);\n\t\t\tp = q;\n\t\t}\n\t\tif (*p == '/') {\n\t\t\tp++;\n\t\t\tif (!isdigit((unsigned char) *p)) {\n\t\t\t\td = 2;\n\t\t\t} else {\n\t\t\t\td = strtol(p, &q, 10);\n\t\t\t\tp = q;\n\t\t\t}\n\t\t}\n\t\tif (microscale == 0) {\n\t\t\td--;\n\t\t\td += (n - 1) << 8;\t/* short [ (n-1) | (d-1) ] */\n\t\t\tif (d == 0) {\n\t\t\t\tn = MAXMICRO - 1;\n\t\t\t} else {\n\t\t\t    for (n = 1; n < MAXMICRO; n++) {\n\t\t\t\tif (parse.micro_tb[n] == d)\n\t\t\t\t\tbreak;\n\t\t\t\tif (parse.micro_tb[n] == 0) {\n\t\t\t\t\tparse.micro_tb[n] = d;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\tif (n == MAXMICRO) {\n\t\t\t\tsyntax(\"Too many microtone accidentals\", p);\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t}\n\t\t*acc += (n << 3);\n\t}\n\n\t/* get the pitch */\n\t{\n\t\tchar *p_n;\n\n\t\tp_n = strchr(all_notes, *p);\n\t\tif (!p_n || *p == '\\0') {\n\t\t\tsyntax(*acc ? \"Missing note after accidental\"\n\t\t\t\t   : \"Not a note\", p);\n\t\t\t*acc = -1;\n\t\t\tif (*p == '\\0')\n\t\t\t\tp--;\n\t\t} else {\n\t\t\t*pit = p_n - all_notes + 16;\n\t\t}\n\t\tp++;\n\t}\n\twhile (*p == '\\'') {\t\t/* eat up following ' chars */\n\t\t*pit += 7;\n\t\tp++;\n\t}\n\twhile (*p == ',') {\t\t/* eat up following , chars */\n\t\t*pit -= 7;\n\t\tp++;\n\t}\n\treturn p;\n}\n\n/* -- parse the decorations of notes and bars -- */\nstatic char *parse_deco(char *p,\n\t\t\t struct decos *deco,\n\t\t\t int m)\t\t\t/* note index / -1 */\n{\n\tint n;\n\tunsigned char t;\n\n\tn = deco->n;\n\tfor (;;) {\n\t\tt = (unsigned char) *p++;\n\t\tif (char_tb[t] != CHAR_DECO && char_tb[t] != CHAR_DECOS)\n\t\t\tbreak;\n\t\tif (char_tb[t] == CHAR_DECOS)\n\t\t\tp = get_deco(p, &t);\n\t\tif (n >= MAXDC) {\n\t\t\tsyntax(\"Too many decorations for the note\", p);\n\t\t} else if (t != 0) {\n\t\t\tdeco->tm[n].t = t;\n\t\t\tdeco->tm[n++].m = m;\n\t\t}\n\t}\n\tdeco->n = n;\n\treturn p - 1;\n}\n\n/* -- parse a decoration line (d: or s:) -- */\nstatic char *parse_decoline(char *p)\n{\n\tstruct SYMBOL *is;\n\tunsigned char t;\n\tint n;\n\n\tif ((is = deco_cont) == NULL)\n\t\tis = deco_start;\n\telse\n\t\tdeco_cont = NULL;\n\n\t/* scan the decoration line */\n\twhile (*p != '\\0') {\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tswitch (*p) {\n\t\tcase '|':\n\t\t\twhile (is && (is->abc_type != ABC_T_BAR\n\t\t\t\t\t|| is->u.bar.type == B_OBRA))\n\t\t\t\tis = is->abc_next;\n\t\t\tif (!is) {\n\t\t\t\tsyntax(\"Not enough bar lines for deco line\", p);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tis = is->abc_next;\n\t\t\tp++;\n\t\t\tcontinue;\n\t\tcase '*':\n\t\t\twhile (is && is->abc_type != ABC_T_NOTE)\n\t\t\t\tis = is->abc_next;\n\t\t\tif (!is) {\n\t\t\t\tsyntax(\"Not enough notes for deco line\", p);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tis = is->abc_next;\n\t\t\tp++;\n\t\t\tcontinue;\n\t\tcase '\\\\':\n\t\t\tif (p[1] == '\\0') {\n\t\t\t\tif (!is)\n\t\t\t\t\treturn \"Not enough notes for deco line\";\n\t\t\t\tdeco_cont = is;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tsyntax(\"'\\\\' ignored\", p);\n\t\t\tp++;\n\t\t\tcontinue;\n\t\tcase '\"':\n\t\t\tp = parse_gchord(p + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (char_tb[(unsigned char) *p] == CHAR_DECOS)\n\t\t\t\tp = get_deco(p + 1, &t);\n\t\t\telse\n\t\t\t\tt = (unsigned char) *p++;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* store the decoration and gchord/annotation in the next note */\n\t\twhile (is && (is->abc_type != ABC_T_NOTE\n\t\t\t\t|| (is->flags & ABC_F_GRACE)))\n\t\t\tis = is->abc_next;\n\t\tif (!is)\n\t\t\treturn \"Not enough notes for deco line\";\n\n\t\tif (gchord) {\n\t\t\tif (is->text) {\n\t\t\t\tchar *gch;\n\n\t\t\t\tn = strlen(is->text);\n\t\t\t\tgch = getarena(n + strlen(gchord) + 2);\n\t\t\t\tstrcpy(gch, is->text);\n\t\t\t\tgch[n] = '\\n';\n\t\t\t\tstrcpy(gch + n + 1, gchord);\n\t\t\t\tgchord = gch;\n\t\t\t}\n\t\t\tis->text = gchord;\n\t\t\tgchord = NULL;\n\t\t} else {\n\t\t\tn = is->u.note.dc.n;\n\t\t\tif (n >= MAXDC) {\n\t\t\t\tsyntax(\"Too many decorations for the note\", p);\n\t\t\t} else if (t != 0) {\n\t\t\t\tis->u.note.dc.tm[n].t = t;\n\t\t\t\tis->u.note.dc.tm[n].m = -1;\n\t\t\t\tis->u.note.dc.n = ++n;\n\t\t\t}\n\t\t}\n\t\tis = is->abc_next;\n\t}\n\treturn NULL;\n}\n\n/* -- parse a guitar chord / annotation -- */\nstatic char *parse_gchord(char *p)\n{\n\tchar *q;\n\tint l, l2;\n\n\tq = p;\n\twhile (*p != '\"') {\n\t\tif (*p == '\\\\')\n\t\t\tp++;\n\t\tif (*p == '\\0') {\n\t\t\tsyntax(\"No end of guitar chord\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\tl = p - q;\n\tif (gchord) {\n\t\tchar *gch;\n\n\t\t/* many guitar chords: concatenate with '\\n' */\n\t\tl2 = strlen(gchord);\n\t\tgch = getarena(l2 + 1 + l + 1);\n\t\tstrcpy(gch, gchord);\n\t\tgch[l2++] = '\\n';\n\t\tstrncpy(&gch[l2], q, l);\n\t\tgch[l2 + l] = '\\0';\n\t\tgchord = gch;\n\t} else {\n\t\tgchord = getarena(l + 1);\n\t\tstrncpy(gchord, q, l);\n\t\tgchord[l] = '\\0';\n\t}\n\tif (*p != '\\0')\n\t\tp++;\n\treturn p;\n}\n\n/* -- parse a note length -- */\nstatic char *parse_len(char *p,\n\t\t\tint dur_u,\n\t\t\tint *p_len)\n{\n\tint len, fac;\n\tint err = 0;\n\tchar *q;\n\n\tlen = dur_u;\n\tif (isdigit((unsigned char) *p)) {\n\t\tlen *= strtol(p, &q, 10);\n\t\tif (len <= 0 || len > 10000) {\n\t\t\tsyntax(\"Bad length\", p);\n\t\t\tlen = dur_u;\n\t\t}\n\t\tp = q;\n\t}\n\tif (*p != '/') {\n\t\t*p_len = len;\n\t\treturn p;\n\t}\n\tif (isdigit((unsigned char) p[1])) {\n\t\tfac = strtol(p + 1, &q, 10);\n\t\tp = q;\n\t\tif (fac == 0 || (fac & (fac - 1)))\n\t\t\terr = 1;\n\t\telse\n\t\t\tlen /= fac;\n\t} else {\n\t\twhile (*p == '/') {\n\t\t\tif (len & 1)\n\t\t\t\terr = 1;\n\t\t\tlen /= 2;\n\t\t\tp++;\n\t\t}\n\t}\n\tif (err || !len) {\n\t\tsyntax(\"Bad length divisor\", p - 1);\n\t\tlen = dur_u;\n\t}\n\t*p_len = len;\n\treturn p;\n}\n\n/* -- parse a ABC line -- */\n/* return 1 on end of tune, and 2 on start of new tune */\nstatic int parse_line(char *p)\n{\n\tstruct SYMBOL *s;\n\tchar *q, c;\n\tchar *dot = NULL;\n\tstruct SYMBOL *last_note_sav = NULL;\n\tstruct decos dc_sav;\n\tint i, flags, flags_sav = 0, slur;\n\tstatic char qtb[10] = {0, 1, 3, 2, 3, 0, 2, 0, 3, 0};\n\n\tcolnum = 0;\n\tswitch (*p) {\n\tcase '\\0':\t\t\t/* blank line */\n\t\tswitch (parse.abc_state) {\n\t\tcase ABC_S_GLOBAL:\n\t\t\tif (parse.last_sym\n\t\t\t && parse.last_sym->abc_type != ABC_T_NULL)\n\t\t\t\tabc_new(ABC_T_NULL, NULL);\n\t\tcase ABC_S_HEAD:\t/*fixme: may have blank lines in headers?*/\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase '%':\n\t\tif (p[1] == '%') {\n\t\t\ts = abc_new(ABC_T_PSCOM, p);\n\t\t\tp += 2;\t\t\t\t/* skip '%%' */\n\t\t\tif (strncasecmp(p, \"decoration \", 11) == 0) {\n\t\t\t\tp += 11;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '!':\n\t\t\t\t\tchar_tb['!'] = CHAR_DECOS;\n\t\t\t\t\tchar_tb['+'] = CHAR_BAD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tchar_tb['+'] = CHAR_DECOS;\n\t\t\t\t\tchar_tb['!'] = CHAR_BAD;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"linebreak \", 10) == 0) {\n\t\t\t\tfor (i = 0; i < sizeof char_tb; i++) {\n\t\t\t\t\tif (char_tb[i] == CHAR_LINEBREAK)\n\t\t\t\t\t\tchar_tb[i] = i != '!' ?\n\t\t\t\t\t\t\t\tCHAR_BAD :\n\t\t\t\t\t\t\t\tCHAR_DECOS;\n\t\t\t\t}\n\t\t\t\tp += 10;\n\t\t\t\tfor (;;) {\n\t\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\t\tp++;\n\t\t\t\t\tif (*p == '\\0')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tswitch (*p) {\n\t\t\t\t\tcase '!':\n\t\t\t\t\tcase '$':\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase ';':\n\t\t\t\t\tcase '?':\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tchar_tb[(unsigned char) *p++]\n\t\t\t\t\t\t\t\t= CHAR_LINEBREAK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tif (strncmp(p, \"<none>\", 6) == 0)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tif (strncmp(p, \"<EOL>\", 5) == 0) {\n\t\t\t\t\t\t\tchar_tb['\\n'] = CHAR_LINEBREAK;\n\t\t\t\t\t\t\tp += 5;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fall thru */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (strcmp(p, \"lock\") != 0)\n\t\t\t\t\t\t\tsyntax(\"Invalid character in %%%%linebreak\",\n\t\t\t\t\t\t\t\tp);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"microscale \", 11) == 0) {\n\t\t\t\tint v;\n\n\t\t\t\tp += 11;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tsscanf(p, \"%d\", &v);\n\t\t\t\tif (v < 4 || v >= 256 || v & 1)\n\t\t\t\t\tsyntax(\"Invalid value in %%microscale\", p);\n\t\t\t\telse\n\t\t\t\t\tmicroscale = v;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"user \", 5) == 0) {\n\t\t\t\tp += 5;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tget_user(p, s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/* fall thru */\n\tcase '\\\\':\t\t\t\t/* abc2mtex specific lines */\n\t\treturn 0;\t\t\t/* skip */\n\t}\n\n\t/* header fields */\n\tif (p[1] == ':'\n\t && *p != '|' && *p != ':') {\t\t/* not '|:' nor '::' */\n\t\tint new_tune;\n\n\t\tnew_tune = parse_info(p);\n\n\t\t/* handle BarFly voice definition */\n\t\t/* 'V:n <note line ending with a bar>' */\n\t\tif (*p != 'V'\n\t\t || parse.abc_state != ABC_S_TUNE)\n\t\t\treturn new_tune;\t\t/* (normal return) */\n\t\tc = p[strlen(p) - 1];\n\t\tif (c != '|' && c != ']')\n\t\t\treturn new_tune;\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t}\n\tif (parse.abc_state != ABC_S_TUNE)\n\t\treturn 0;\n\n\t/* music */\n\tflags = 0;\n\tif (parse.abc_vers <= (2 << 16))\n\t\tlyric_started = 0;\n\tdeco_start = deco_cont = NULL;\n\tslur = 0;\n\twhile (*p != '\\0') {\n\t\tcolnum = p - abc_line;\n\t\tswitch (char_tb[(unsigned char) *p++]) {\n\t\tcase CHAR_GCHORD:\t\t\t/* \" */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tp = parse_gchord(p);\n\t\t\tbreak;\n\t\tcase CHAR_GR_ST:\t\t/* '{' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tlast_note_sav = curvoice->last_note;\n\t\t\tcurvoice->last_note = NULL;\n\t\t\tmemcpy(&dc_sav, &dc, sizeof dc);\n\t\t\tdc.n = 0;\n\t\t\tflags_sav = flags;\n\t\t\tflags = ABC_F_GRACE;\n\t\t\tif (*p == '/') {\n\t\t\t\tflags |= ABC_F_SAPPO;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHAR_GR_EN:\t\t/* '}' */\n\t\t\tif (!(flags & ABC_F_GRACE))\n\t\t\t\tgoto bad_char;\n\t\t\tparse.last_sym->flags |= ABC_F_GR_END;\n\t\t\tif (dc.n != 0)\n\t\t\t\tsyntax(\"Decoration ignored\", p);\n\t\t\tcurvoice->last_note = last_note_sav;\n\t\t\tmemcpy(&dc, &dc_sav, sizeof dc);\n\t\t\tflags = flags_sav;\n\t\t\tbreak;\n\t\tcase CHAR_DECOS:\n\t\t\tif (p[-1] == '!'\n\t\t\t && char_tb['\\n'] == CHAR_LINEBREAK\n\t\t\t && check_nl(p)) {\n\t\t\t\ts = abc_new(ABC_T_EOLN, NULL);\t/* abc2win EOL */\n\t\t\t\ts->u.eoln.type = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall thru */\n\t\tcase CHAR_DECO:\n\t\t\tif (p[-1] == '.') {\n\t\t\t\tif (*p == '(' || *p == '-') {\n\t\t\t\t\tdot = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tif (*p == '|') {\n//\t\t\t\t\tp = parse_bar(p + 1);\n//\t\t\t\t\tparse.last_sym->u.bar.dotted = 1;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t}\n\t\t\tp = parse_deco(p - 1, &dc, -1);\n\t\t\tbreak;\n\t\tcase CHAR_LINEBREAK:\n\t\t\ts = abc_new(ABC_T_EOLN, NULL);\n//\t\t\ts->u.eoln.type = 0;\n\t\t\tbreak;\n\t\tcase CHAR_NOTE:\n\t\t\tp = parse_note(p - 1, flags);\n\t\t\tflags &= ABC_F_GRACE;\n\t\t\tparse.last_sym->u.note.slur_st = slur;\n\t\t\tslur = 0;\n\t\t\tif (parse.last_sym->u.note.notes[0].len > 0) /* if not space */\n\t\t\t\tcurvoice->last_note = parse.last_sym;\n\t\t\tbreak;\n\t\tcase CHAR_SLASH:\t\t/* '/' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (char_tb[(unsigned char) p[-1]] != CHAR_BAR)\n\t\t\t\tgoto bad_char;\n\t\t\tq = p;\n\t\t\twhile (*q == '/')\n\t\t\t\tq++;\n\t\t\tif (char_tb[(unsigned char) *q] != CHAR_BAR)\n\t\t\t\tgoto bad_char;\n\t\t\ts = abc_new(ABC_T_MREP, NULL);\n\t\t\ts->u.bar.type = 0;\n\t\t\ts->u.bar.len = q - p + 1;\n\t\t\tsyntax(\"Non standard measure repeat syntax\", p - 1);\n\t\t\tp = q;\n\t\t\tbreak;\n\t\tcase CHAR_BSLASH:\t\t/* '\\\\' */\n\t\t\tif (*p == '\\0')\n\t\t\t\tbreak;\n\t\t\tsyntax(\"'\\\\' ignored\", p - 1);\n\t\t\tbreak;\n\t\tcase CHAR_OBRA:\t\t\t/* '[' */\n\t\t\tif (*p == '|' || *p == ']' || *p == ':'\n\t\t\t || isdigit((unsigned char) *p) || *p == '\"'\n\t\t\t || *p == ' ') {\n\t\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\t\tgoto bad_char;\n\t\t\t\tp = parse_bar(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p[1] != ':') {\n\t\t\t\tp = parse_note(p - 1, flags); /* chord */\n\t\t\t\tflags &= ABC_F_GRACE;\n\t\t\t\tparse.last_sym->u.note.slur_st = slur;\n\t\t\t\tslur = 0;\n\t\t\t\tcurvoice->last_note = parse.last_sym;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* embedded information field */\n#if 0\n/*fixme:OK for [I:staff n], ?? for other headers*/\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n#endif\n\t\t\twhile (p[2] == ' ') {\t\t/* remove the spaces */\n\t\t\t\tp[2] = ':';\n\t\t\t\tp[1] = *p;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tc = ']';\n\t\t\tq = p;\n\t\t\twhile (*p != '\\0' && *p != c)\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0') {\n\t\t\t\tsyntax(\"Escape sequence [..] not closed\", q);\n\t\t\t\tc = '\\0';\n\t\t\t} else {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tparse_info(q);\n\t\t\t*p = c;\n\t\t\tif (c != '\\0')\n\t\t\t\tp++;\n\t\t\tbreak;\n\t\tcase CHAR_BAR:\t\t\t/* '|', ':' or ']' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tp = parse_bar(p);\n\t\t\tbreak;\n\t\tcase CHAR_OPAR:\t\t\t/* '(' */\n\t\t\tif (*p > '0' && *p <= '9') {\n\t\t\t\tint pplet, qplet, rplet;\n\n\t\t\t\tpplet = strtol(p, &q, 10);\n\t\t\t\tp = q;\n\t\t\t\tif ((unsigned) pplet < sizeof qtb / sizeof qtb[0])\n\t\t\t\t\tqplet = qtb[pplet];\n\t\t\t\telse\n\t\t\t\t\tqplet = qtb[0];\n\t\t\t\trplet = pplet;\n\t\t\t\tif (*p == ':') {\n\t\t\t\t\tp++;\n\t\t\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\t\t\tqplet = strtol(p, &q, 10);\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t}\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\t\t\t\trplet = strtol(p, &q, 10);\n\t\t\t\t\t\t\tp = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rplet < 1) {\n\t\t\t\t\tsyntax(\"Invalid 'r' in tuplet\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pplet >= 128 || qplet >= 128 || rplet >= 128) {\n\t\t\t\t\tsyntax(\"Invalid 'p:q:r' in tuplet\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (qplet == 0)\n\t\t\t\t\tqplet = meter % 3 == 0 ? 3 : 2;\n\t\t\t\ts = abc_new(ABC_T_TUPLET, NULL);\n\t\t\t\ts->u.tuplet.p_plet = pplet;\n\t\t\t\ts->u.tuplet.q_plet = qplet;\n\t\t\t\ts->u.tuplet.r_plet = rplet;\n\t\t\t\ts->flags |= flags;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*p == '&') {\n\t\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\t\tgoto bad_char;\n\t\t\t\tp++;\n\t\t\t\tif (vover != 0) {\n\t\t\t\t\tsyntax(\"Nested voice overlay\", p - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\t\ts->u.v_over.type = V_OVER_S;\n\t\t\t\ts->u.v_over.voice = curvoice - voice_tb;\n\t\t\t\tvover = -1;\t\t/* multi-bars */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tslur <<= 4;\n\t\t\tif (p == dot + 1 && dc.n == 0)\n\t\t\t\tslur |= SL_DOTTED;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\'':\n\t\t\t\tslur += SL_ABOVE;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tslur += SL_BELOW;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tslur += SL_AUTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHAR_CPAR:\t\t\t/* ')' */\n\t\t\tswitch (parse.last_sym->abc_type) {\n\t\t\tcase ABC_T_NOTE:\n\t\t\tcase ABC_T_REST:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto bad_char;\n\t\t\t}\n\t\t\tparse.last_sym->u.note.slur_end++;\n\t\t\tbreak;\n\t\tcase CHAR_VOV:\t\t\t/* '&' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (*p != ')'\n\t\t\t || vover == 0) {\t\t/*??*/\n\t\t\t\tif (!curvoice->last_note) {\n\t\t\t\t\tsyntax(\"Bad start of voice overlay\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\t\t/*s->u.v_over.type = V_OVER_V; */\n\t\t\t\tvover_new();\n\t\t\t\ts->u.v_over.voice = curvoice - voice_tb;\n\t\t\t\tif (vover == 0)\n\t\t\t\t\tvover = 1;\t/* single bar */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tvover = 0;\n\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\ts->u.v_over.type = V_OVER_E;\n\t\t\ts->u.v_over.voice = curvoice->mvoice;\n\t\t\tcurvoice->last_note = NULL;\t/* ?? */\n\t\t\tcurvoice = &voice_tb[curvoice->mvoice];\n\t\t\tbreak;\n\t\tcase CHAR_SPAC:\t\t\t/* ' ' and '\\t' */\n\t\t\tflags |= ABC_F_SPACE;\n\t\t\tbreak;\n\t\tcase CHAR_MINUS: {\t\t/* '-' */\n\t\t\tint tie_pos;\n\n\t\t\tif (!curvoice->last_note\n\t\t\t || curvoice->last_note->abc_type != ABC_T_NOTE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (p == dot + 1 && dc.n == 0)\n\t\t\t\ttie_pos = SL_DOTTED;\n\t\t\telse\n\t\t\t\ttie_pos = 0;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\'':\n\t\t\t\ttie_pos += SL_ABOVE;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttie_pos += SL_BELOW;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttie_pos += SL_AUTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i <= curvoice->last_note->nhd; i++) {\n\t\t\t\tif (curvoice->last_note->u.note.notes[i].ti1 == 0)\n\t\t\t\t\tcurvoice->last_note->u.note.notes[i].ti1 = tie_pos;\n\t\t\t\telse if (curvoice->last_note->nhd == 0)\n\t\t\t\t\tsyntax(\"Too many ties\", p);\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase CHAR_BRHY:\t\t\t/* '>' and '<' */\n\t\t\tif (!curvoice->last_note)\n\t\t\t\tgoto bad_char;\n\t\t\ti = 1;\n\t\t\twhile (*p == p[-1]) {\n\t\t\t\ti++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (i > 3) {\n\t\t\t\tsyntax(\"Bad broken rhythm\", p - 1);\n\t\t\t\ti = 3;\n\t\t\t}\n\t\t\tif (p[-1] == '<')\n\t\t\t\ti = -i;\n\t\t\tbroken_rhythm(curvoice->last_note, i);\n\t\t\tcurvoice->last_note->u.note.brhythm = i;\n\t\t\tbreak;\n\t\tcase CHAR_IGN:\t\t\t/* '*' & '`' */\n\t\t\tbreak;\n\t\tdefault:\n\t\tbad_char:\n\t\t\tsyntax((flags & ABC_F_GRACE)\n\t\t\t\t\t? \"Bad character in grace note sequence\"\n\t\t\t\t\t: \"Bad character\",\n\t\t\t\tp - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n/*fixme: may we have grace notes across lines?*/\n\tif (flags & ABC_F_GRACE) {\n\t\tsyntax(\"EOLN in grace note sequence\", p - 1);\n\t\tif (curvoice->last_note)\n\t\t\tcurvoice->last_note->flags |= ABC_F_GR_END;\n\t\tcurvoice->last_note = last_note_sav;\n\t\tmemcpy(&dc, &dc_sav, sizeof dc);\n\t}\n\n\t/* add eoln */\n\ts = abc_new(ABC_T_EOLN, NULL);\n\tif (flags & ABC_F_SPACE)\n\t\ts->flags |= ABC_F_SPACE;\n\tif (p[-1] == '\\\\'\n\t || char_tb['\\n'] != CHAR_LINEBREAK)\n\t\ts->u.eoln.type = 1;\t\t/* no break */\n\n\treturn 0;\n}\n\n/* -- parse a note or a rest -- */\nstatic char *parse_note(char *p,\n\t\t\tint flags)\n{\n\tstruct SYMBOL *s;\n\tchar *q;\n\tint pit = 0, len, acc, nostem, chord, j, m, n;\n\n\tif (flags & ABC_F_GRACE) {\t/* in a grace note sequence */\n\t\ts = abc_new(ABC_T_NOTE, NULL);\n\t} else {\n\t\ts = abc_new(ABC_T_NOTE, gchord);\n\t\tif (gchord)\n\t\t\tgchord = NULL;\n\t}\n\ts->flags |= flags;\n\ts->u.note.notes[0].color = -1;\n\n\tif (!lyric_started) {\n\t\tlyric_started = 1;\n\t\ts->flags |= ABC_F_LYRIC_START;\n\t}\n\tif (*p != 'X' && *p != 'Z'\n\t && !(flags & ABC_F_GRACE)) {\n\t\tif (!deco_start)\n\t\t\tdeco_start = s;\n\t}\n\tchord = 0;\n\n\t/* rest */\n\tswitch (*p) {\n\tcase 'X':\n\t\ts->flags |= ABC_F_INVIS;\n\tcase 'Z':\t\t\t/* multi-rest */\n\t\ts->abc_type = ABC_T_MREST;\n\t\tp++;\n\t\tlen = 1;\n\t\tif (isdigit((unsigned char) *p)) {\n\t\t\tlen = strtol(p, &q, 10);\n\t\t\tif (len == 0 || len > 100) {\n\t\t\t\tsyntax(\"Bad number of measures\", p);\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tp = q;\n\t\t}\n\t\ts->u.bar.type = 0;\n\t\ts->u.bar.len = len;\n\t\tgoto add_deco;\n\tcase 'y':\t\t\t/* space (BarFly) */\n\t\ts->abc_type = ABC_T_REST;\n\t\ts->flags |= ABC_F_INVIS;\n\t\tp++;\n\t\tif (isdigit((unsigned char) *p)\t\t/* number of points */\n\t\t || *p == '-') {\t\t\t/* accept negative offset... */\n\t\t\ts->u.note.notes[0].shhd = strtol(p, &q, 10);\n\t\t\tp = q;\n\t\t} else {\n\t\t\ts->u.note.notes[0].shhd = 10;\t// default\n\t\t}\n\t\tgoto add_deco;\n\tcase 'x':\t\t\t/* invisible rest */\n\t\ts->flags |= ABC_F_INVIS;\n\t\t/* fall thru */\n\tcase 'z':\n\t\ts->abc_type = ABC_T_REST;\n\t\tp = parse_len(p + 1, ulen, &len);\n\t\ts->u.note.notes[0].len = len;\n\t\tgoto do_brhythm;\n\tcase '[':\t\t\t/* '[..]' = chord */\n\t\tchord = 1;\n\t\tp++;\n\t\tbreak;\n\t}\n\n\tq = p;\n\n\t/* get pitch, length and possible accidental */\n\tm = 0;\n\tnostem = 0;\n\tfor (;;) {\n\t\tif (chord) {\n\t\t\tif (m >= MAXHD) {\n\t\t\t\tsyntax(\"Too many notes in chord\", p);\n\t\t\t\tm--;\n\t\t\t}\n\t\t\tn = 0;\n\t\t\tif (*p == '.') {\n\t\t\t\tn = SL_DOTTED;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p == '(') {\n\t\t\t\tp++;\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tn += SL_ABOVE;\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ',':\n\t\t\t\t\tn += SL_BELOW;\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tn += SL_AUTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts->u.note.notes[m].sl1 = (s->u.note.notes[m].sl1 << 3)\n\t\t\t\t\t\t\t+ n;\n\t\t\t}\n\t\t}\n\t\tp = parse_deco(p, &dc, m);\t/* note head decorations */\n\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\tif (*p == '0') {\n\t\t\tnostem = 1;\n\t\t\tp++;\n\t\t}\n\t\tp = parse_len(p, (flags & ABC_F_GRACE) ?\n\t\t\t\t\tBASE_LEN / 8 :\t// for grace note alone\n\t\t\t\t\tulen,\n\t\t\t\t&len);\n\t\ts->u.note.notes[m].pit = pit;\n\t\ts->pits[m] = pit;\n\t\ts->u.note.notes[m].len = len;\n\t\ts->u.note.notes[m].acc = acc;\n\t\ts->u.note.notes[m].color = -1;\n\n\t\tif (chord) {\n\t\t\tfor (;;) {\n\t\t\t\tif (*p == '.') {\n\t\t\t\t\tif (p[1] != '-')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (*p == '-') {\n\t\t\t\t\tswitch (p[1]) {\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_ABOVE;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ',':\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_BELOW;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_AUTO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (*p == ')') {\n\t\t\t\t\ts->u.note.notes[m].sl2++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tif (acc >= 0)\t\t\t/* if no error */\n\t\t\tm++;\t\t\t/* normal case */\n\n\t\tif (!chord)\n\t\t\tbreak;\n\t\tif (*p == ']') {\n\t\t\tp++;\n\t\t\tif (*p == '0') {\n\t\t\t\tnostem = 1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p == '/' || isdigit((unsigned char) *p)) {\n\t\t\t\tp = parse_len(p, ulen, &len);\n\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\ts->u.note.notes[j].len =\n\t\t\t\t\t\tlen * s->u.note.notes[j].len / ulen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (*p == '\\0') {\n\t\t\tsyntax(\"Chord not closed\", q);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nostem)\n\t\ts->flags |= ABC_F_STEMLESS;\n\n\tif (m == 0)\t\t\t/* if no note (or error) */\n\t\tgoto err;\n\n\ts->u.note.microscale = microscale;\n\ts->nhd = m - 1;\n\ndo_brhythm:\n\tif (curvoice->last_note\n\t && curvoice->last_note->u.note.brhythm != 0)\n\t\tbroken_rhythm(s, -curvoice->last_note->u.note.brhythm);\nadd_deco:\n\tif (dc.n > 0) {\n\t\tmemcpy(s->abc_type != ABC_T_MREST ? &s->u.note.dc\n\t\t\t\t: &s->u.bar.dc,\n\t\t\t&dc, sizeof dc);\n\t\tdc.n = 0;\n\t}\n\n\t/* forbid rests in grace note sequences */\n\tif (s->abc_type != ABC_T_NOTE && (flags & ABC_F_GRACE)) {\n\t\tsyntax(\"Not a note in grace note sequence\", p);\n\t\tgoto err;\n\t}\n\treturn p;\n\nerr:\n\tif ((parse.last_sym = s->abc_prev) == NULL) {\n\t\tparse.first_sym = NULL;\n\t} else {\n\t\ts->abc_prev->abc_next = NULL;\n\t\ts->abc_prev->flags |= (s->flags & ABC_F_ERROR);\n\t}\n\treturn p;\n}\n\n/* -- parse an information field -- */\n/* return 2 on start of new tune */\nstatic int parse_info(char *p)\n{\n\tstruct SYMBOL *s;\n\tchar info_type = *p;\n\tchar *error_txt = NULL;\n\n\ts = abc_new(ABC_T_INFO, p);\n\n\tp += 2;\n\n\tswitch (info_type) {\n\tcase 'd':\n\tcase 's':\n\t\tif (parse.abc_state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\tif (!deco_start) {\n\t\t\terror_txt = \"Erroneous 'd:'/'s:'\";\n\t\t\tbreak;\n\t\t}\n\t\terror_txt = parse_decoline(p);\n\t\tbreak;\n\tcase 'K':\n\t\tif (parse.abc_state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\tparse_key(p, s);\n\t\tif (parse.abc_state == ABC_S_HEAD) {\n\t\t\tint i;\n\n\t\t\tparse.abc_state = ABC_S_TUNE;\n\t\t\tif (ulen == 0)\n\t\t\t\tulen = BASE_LEN / 8;\n\t\t\tfor (i = MAXVOICE; --i >= 0; )\n\t\t\t\tvoice_tb[i].ulen = ulen;\n\t\t\tlyric_started = 0;\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\terror_txt = get_len(p, s);\n\t\tif (s->u.length.base_length > 0)\n\t\t\tulen = s->u.length.base_length;\n\t\tbreak;\n\tcase 'M':\n\t\terror_txt = parse_meter(p, s);\n\t\tbreak;\n\tcase 'Q':\n\t\terror_txt = parse_tempo(p, s);\n\t\tbreak;\n\tcase 'U':\n\t\terror_txt = get_user(p, s);\n\t\tbreak;\n\tcase 'V':\n\t\tif (parse.abc_state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\terror_txt = parse_voice(p, s);\n\t\tbreak;\n\tcase 'X':\n\t\tmemset(voice_tb, 0, sizeof voice_tb);\n\t\tnvoice = 0;\n\t\tcurvoice = voice_tb;\n\t\tparse.abc_state = ABC_S_HEAD;\n\t\tlvlarena(1);\n\t\treturn 2;\n\t}\n\tif (error_txt)\n\t\tsyntax(error_txt, p);\n\treturn 0;\n}\n\n/* -- print a syntax error message -- */\nstatic void syntax(char *msg,\n\t\t   char *q)\n{\n\tint n, len, m1, m2, pp;\n\tint maxcol = 73;\n\n\tseverity = 1;\n\tn = q - abc_line;\n\tlen = strlen(abc_line);\n\tif ((unsigned) n > (unsigned) len)\n\t\tn = -1;\n\tprint_error(msg, n);\n\tif (n < 0) {\n\t\tif (q && *q != '\\0')\n\t\t\tfprintf(stderr, \" (near '%s')\\n\", q);\n\t\treturn;\n\t}\n\tm1 = 0;\n\tm2 = len;\n\tif (m2 > maxcol) {\n\t\tif (n < maxcol) {\n\t\t\tm2 = maxcol;\n\t\t} else {\n\t\t\tm1 = n - 20;\n\t\t\tm2 = m1 + maxcol;\n\t\t\tif (m2 > len)\n\t\t\t\tm2 = len;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"%4d \", linenum);\n\tpp = 6;\n\tif (m1 > 0) {\n\t\tfprintf(stderr, \"...\");\n\t\tpp += 3;\n\t}\n\tfprintf(stderr, \"%.*s\", m2 - m1, &abc_line[m1]);\n\tif (m2 < len)\n\t\tfprintf(stderr, \"...\");\n\tfprintf(stderr, \"\\n\");\n\n\tif ((unsigned) n < 200)\n\t\tfprintf(stderr, \"%*s\\n\", n + pp - m1, \"^\");\n\n\tif (last_sym)\n\t\tlast_sym->flags |= ABC_F_ERROR;\n}\n\n/* -- switch to a new voice overlay -- */\nstatic void vover_new(void)\n{\n\tint voice, mvoice;\n\n\tmvoice = curvoice->mvoice;\n\tfor (voice = curvoice - voice_tb + 1; voice <= nvoice; voice++)\n\t\tif (voice_tb[voice].mvoice == mvoice)\n\t\t\tbreak;\n\tif (voice > nvoice) {\n\t\tif (nvoice >= MAXVOICE) {\n\t\t\tsyntax(\"Too many voices\", 0);\n\t\t\treturn;\n\t\t}\n\t\tnvoice = voice;\n\t\tvoice_tb[voice].id[0] = '&';\n\t\tvoice_tb[voice].mvoice = mvoice;\n\t}\n\tvoice_tb[voice].ulen = curvoice->ulen;\n\tvoice_tb[voice].microscale = curvoice->microscale;\n\tcurvoice = &voice_tb[voice];\n}\n"], "fixing_code": ["/*\n * Generic ABC parser.\n *\n * This file is part of abcm2ps.\n *\n * Copyright (C) 1998-2020 Jean-Fran\u00e7ois Moine (http://moinejf.free.fr)\n * Adapted from abc2ps, Copyright (C) 1996-1998 Michael Methfessel\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"abcm2ps.h\"\n\n/* global values */\nint severity;\t\t\t/* error severity */\n\nstatic int ulen;\t\t/* unit note length set by M: or L: */\nstatic short meter;\t\t/* upper value of time sig for n-plets */\nstatic unsigned char microscale; /* current microtone scale */\nstatic signed char vover;\t/* voice overlay (1: single bar, -1: multi-bar */\nstatic char lyric_started;\t/* lyric started */\nstatic char *gchord;\t\t/* guitar chord */\nstatic struct decos dc;\t\t/* decorations */\nstatic struct SYMBOL *deco_start; /* 1st note of the line for d: / s: */\nstatic struct SYMBOL *deco_cont; /* current symbol when d: / s: continuation */\n\nstatic int g_abc_vers, g_ulen, g_microscale;\nstatic char g_char_tb[128];\nstatic char *g_deco_tb[128];\t\t/* global decoration names */\nstatic unsigned short g_micro_tb[MAXMICRO]; /* global microtone values */\n\nstatic char *abc_fn;\t\t/* current source file name */\nstatic int linenum;\t\t/* current source line number */\nstatic int colnum;\t\t/* current source column number */\nstatic char *abc_line;\t\t/* line being parsed */\nstatic struct SYMBOL *last_sym;\t/* last symbol for errors */\n\nstatic short nvoice;\t\t/* number of voices (0..n-1) */\nstruct VOICE_S *curvoice;\t/* current voice while parsing */\n\nstruct parse parse;\n\n/* char table for note line parsing */\n#define CHAR_BAD 0\n#define CHAR_IGN 1\n#define CHAR_NOTE 2\n#define CHAR_GR_ST 3\n#define CHAR_DECO 4\n#define CHAR_GCHORD 5\n#define CHAR_BSLASH 6\n#define CHAR_OBRA 7\n#define CHAR_BAR 8\n#define CHAR_OPAR 9\n#define CHAR_VOV 10\n#define CHAR_SPAC 11\n#define CHAR_MINUS 12\n#define CHAR_CPAR 13\n#define CHAR_BRHY 14\n#define CHAR_DECOS 15\n#define CHAR_SLASH 16\n#define CHAR_GR_EN 17\n#define CHAR_LINEBREAK 18\nstatic char char_tb[256] = {\n\t0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t/* 00 - 07 */\n\t0, CHAR_SPAC, CHAR_LINEBREAK, 0, 0, 0, 0, 0,\t/* 08 - 0f */\n\t0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t/* 10 - 17 */\n\t0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t/* 18 - 1f */\n\tCHAR_SPAC, CHAR_DECOS, CHAR_GCHORD, CHAR_BAD,\t/* (sp) ! \" # */\n\tCHAR_BAD, CHAR_BAD, CHAR_VOV, CHAR_BAD, \t/* $ % & ' */\n\tCHAR_OPAR, CHAR_CPAR, CHAR_BAD, CHAR_DECOS, \t/* ( ) * + */\n\tCHAR_BAD, CHAR_MINUS, CHAR_DECO, CHAR_SLASH, \t/* , - . / */\n\tCHAR_BAD, CHAR_BAD, CHAR_BAD, CHAR_BAD, \t/* 0 1 2 3 */\n\tCHAR_BAD, CHAR_BAD, CHAR_BAD, CHAR_BAD, \t/* 4 5 6 7 */\n\tCHAR_BAD, CHAR_BAD, CHAR_BAR, CHAR_BAD, \t/* 8 9 : ; */\n\tCHAR_BRHY, CHAR_NOTE, CHAR_BRHY, CHAR_BAD, \t/* < = > ? */\n\tCHAR_BAD, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* @ A B C */\n\tCHAR_NOTE, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* D E F G */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* H I J K */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* L M N O */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* P Q R S */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* T U V W */\n\tCHAR_NOTE, CHAR_DECO, CHAR_NOTE, CHAR_OBRA, \t/* X Y Z [ */\n\tCHAR_BSLASH, CHAR_BAR, CHAR_NOTE, CHAR_NOTE, \t/* \\ ] ^ _ */\n\tCHAR_IGN, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* ` a b c */\n\tCHAR_NOTE, CHAR_NOTE, CHAR_NOTE, CHAR_NOTE, \t/* d e f g */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* h i j k */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* l m n o */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* p q r s */\n\tCHAR_DECO, CHAR_DECO, CHAR_DECO, CHAR_DECO, \t/* t u v w */\n\tCHAR_NOTE, CHAR_NOTE, CHAR_NOTE, CHAR_GR_ST, \t/* x y z { */\n\tCHAR_BAR, CHAR_GR_EN, CHAR_DECO, CHAR_BAD, \t/* | } ~ (del) */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 80 - 8f */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 90 - 9f */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* a0 - af */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* b0 - bf */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* c0 - cf */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* d0 - df */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* e0 - ef */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t/* f0 - ff */\n};\n\nstatic const char all_notes[] = \"CDEFGABcdefgab\";\n\nstatic int parse_info(char *p);\nstatic char *parse_gchord(char *p);\nstatic int parse_line(char *p);\nstatic char *parse_note(char *p,\n\t\t\tint flags);\nstatic void syntax(char *msg, char *q);\nstatic void vover_new(void);\n\n/* -- abcMIDI like errors -- */\nstatic void print_error(char *s, int col)\n{\n\tif (col >= 0)\n\t\tfprintf(stderr, \"%s:%d:%d: error: %s\\n\", abc_fn, linenum, col, s);\n\telse\n\t\tfprintf(stderr, \"%s:%d: error: %s\\n\", abc_fn, linenum, s);\n}\n\n/* -- new symbol -- */\nstatic struct SYMBOL *abc_new(int type, char *text)\n{\n\tstruct SYMBOL *s;\n\n\ts = getarena(sizeof(struct SYMBOL));\n\tmemset(s, 0, sizeof(struct SYMBOL));\n\tif (text) {\n\t\ts->text = getarena(strlen(text) + 1);\n\t\tstrcpy(s->text, text);\n\t}\n\tif (!parse.last_sym) {\n\t\tparse.first_sym = s;\n\t} else {\n\t\tif ((s->abc_next = parse.last_sym->abc_next) != NULL)\n\t\t\ts->abc_next->abc_prev = s;\n\t\tparse.last_sym->abc_next = s;\n\t\ts->abc_prev = parse.last_sym;\n\t}\n\tlast_sym = parse.last_sym = s;\n\ts->abc_type = type;\n\ts->state = parse.abc_state;\n\ts->fn = abc_fn;\n\ts->linenum = linenum;\n\ts->colnum = colnum;\n\treturn s;\n}\n\n/* -- parse an ABC line -- */\nvoid abc_parse(char *p, char *fname, int ln)\n{\n\tabc_fn = fname;\n\tlinenum = ln;\n\tabc_line = p;\n\n\t/* parse the music line */\n\tswitch (parse_line(p)) {\n\tcase 2:\t\t\t\t/* start of tune (X:) */\n\t\tg_abc_vers = parse.abc_vers;\n\t\tg_ulen = ulen;\n\t\tg_microscale = microscale;\n\n\t\tmeter = 2;\n\t\tmemcpy(g_char_tb, char_tb, sizeof g_char_tb);\n\t\tmemcpy(g_deco_tb, parse.deco_tb, sizeof g_deco_tb);\n\t\tmemcpy(g_micro_tb, parse.micro_tb, sizeof g_micro_tb);\n\t\tbreak;\n\tcase 1:\t\t\t\t/* end of tune */\n\t\tif (parse.first_sym) {\n\t\t\tdo_tune();\n\t\t\tparse.first_sym = parse.last_sym = NULL;\n\t\t}\n\t\tparse.abc_state = ABC_S_GLOBAL;\n\t\tparse.abc_vers = g_abc_vers;\n\t\tulen = g_ulen;\n\t\tmicroscale = g_microscale;\n\t\tmemcpy(char_tb, g_char_tb, sizeof g_char_tb);\n\t\tmemcpy(parse.deco_tb, g_deco_tb, sizeof parse.deco_tb);\n\t\tmemcpy(parse.micro_tb, g_micro_tb, sizeof parse.micro_tb);\n\t\tlvlarena(0);\n\t\tif (dc.n > 0)\n\t\t\tsyntax(\"Decoration without symbol\", 0);\n\t\tdc.n = 0;\n\t\tbreak;\n\t}\n}\n\n/* treat the end of file */\nvoid abc_eof(void)\n{\n//\tif (parse.abc_state == ABC_S_HEAD)\n//\t\tseverity = 1;\n\tdo_tune();\n\tparse.first_sym = parse.last_sym = NULL;\n\tif (parse.abc_state != ABC_S_GLOBAL) {\n\t\tparse.abc_vers = g_abc_vers;\n\t\tulen = g_ulen;\n\t\tmicroscale = g_microscale;\n\t\tmemcpy(char_tb, g_char_tb, sizeof g_char_tb);\n\t}\n}\n\n/* -- treat the broken rhythm '>' and '<' -- */\nstatic void broken_rhythm(struct SYMBOL *s,\n\t\t\t  int num)\t/* >0: do dot, <0: do half */\n{\n\tstruct notes *notes = &s->u.note;\n\tint l, m, n;\n\n\tnum *= 2;\n\tif (num > 0) {\n\t\tif (num == 6)\n\t\t\tnum = 8;\n\t\tn = num * 2 - 1;\n\t\tfor (m = 0; m <= s->nhd; m++)\n\t\t\tnotes->notes[m].len = (notes->notes[m].len * n) / num;\n\t} else {\n\t\tn = -num;\n\t\tif (n == 6)\n\t\t\tn = 8;\n\t\tfor (m = 0; m <= s->nhd; m++)\n\t\t\tnotes->notes[m].len /= n;\n\t}\n\tl = notes->notes[0].len;\n\tfor (m = 1; m <= s->nhd; m++)\n\t\tif (notes->notes[m].len < l)\n\t\t\tl = notes->notes[m].len;\n}\n\n/* -- check for the '!' as end of line (ABC2Win) -- */\nstatic int check_nl(char *p)\n{\n\twhile (*p != '\\0') {\n\t\tswitch (*p++) {\n\t\tcase '!':\n\t\t\treturn 0;\n\t\tcase '|':\n\t\tcase '[':\n\t\tcase ':':\n\t\tcase ']':\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/* -- parse extra K: or V: definitions (clef, octave and microscale  -- */\nstatic char *parse_extra(char *p,\n\t\t\tchar **p_name,\n\t\t\tchar **p_middle,\n\t\t\tchar **p_stlines,\n\t\t\tchar **p_scale,\n\t\t\tchar **p_octave,\n\t\t\tchar **p_cue,\n\t\t\tchar **p_map)\n{\n\tfor (;;) {\n\t\tif (strncmp(p, \"clef=\", 5) == 0\n\t\t || strncmp(p, \"bass\", 4) == 0\n\t\t || strncmp(p, \"treble\", 6) == 0\n\t\t || strncmp(p, \"alto\", 4) == 0\n\t\t || strncmp(p, \"tenor\", 5) == 0\n\t\t || strncmp(p, \"perc\", 4) == 0) {\n\t\t\tif (*p_name)\n\t\t\t\tsyntax(\"Double clef name\", p);\n\t\t\t*p_name = p;\n\t\t} else if (strncmp(p, \"microscale=\", 11) == 0\n\t\t\t|| strncmp(p, \"uscale=\", 7) == 0) {\n\t\t\tint i;\n\n\t\t\tp += p[0] == 'm' ? 11 : 7;\n\t\t\ti = atoi(p);\n\t\t\tif (i < 4 || i >= 256)\n\t\t\t\tsyntax(\"Invalid value in microscale=\", p);\n\t\t\telse\n\t\t\t\tmicroscale = i;\n\t\t} else if (strncmp(p, \"middle=\", 7) == 0\n\t\t\t|| strncmp(p, \"m=\", 2) == 0) {\n\t\t\tif (*p_middle)\n\t\t\t\tsyntax(\"Double clef middle\", p);\n\t\t\t*p_middle = p + (p[1] == '=' ? 2 : 7);\n\t\t} else if (strncmp(p, \"octave=\", 7) == 0) {\n\t\t\tif (*p_octave)\n\t\t\t\tsyntax(\"Double octave=\", p);\n\t\t\t*p_octave = p + 7;\n\t\t} else if (strncmp(p, \"stafflines=\", 11) == 0) {\n\t\t\tint l;\n\t\t\tchar *q;\n\n\t\t\tif (*p_stlines)\n\t\t\t\tsyntax(\"Double stafflines\", p);\n\t\t\tp += 11;\n\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\tswitch (atoi(p)) {\n\t\t\t\tcase 0: *p_stlines = \"...\"; break;\n\t\t\t\tcase 1: *p_stlines = \"..|\"; break;\n\t\t\t\tcase 2: *p_stlines = \".||\"; break;\n\t\t\t\tcase 3: *p_stlines = \".|||\"; break;\n\t\t\t\tcase 4: *p_stlines = \"||||\"; break;\n\t\t\t\tcase 5: *p_stlines = \"|||||\"; break;\n\t\t\t\tcase 6: *p_stlines = \"||||||\"; break;\n\t\t\t\tcase 7: *p_stlines = \"|||||||\"; break;\n\t\t\t\tcase 8: *p_stlines = \"||||||||\"; break;\n\t\t\t\tdefault:\n\t\t\t\t\tsyntax(\"Bad number of lines\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tq = p;\n\t\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\t\tp++;\n\t\t\t\tl = p - q;\n\t\t\t\t*p_stlines = getarena(l + 1);\n\t\t\t\tstrncpy(*p_stlines, q, l);\n\t\t\t\t(*p_stlines)[l] = '\\0';\n\t\t\t}\n\t\t} else if (strncmp(p, \"staffscale=\", 11) == 0) {\n\t\t\tif (*p_scale)\n\t\t\t\tsyntax(\"Double staffscale\", p);\n\t\t\t*p_scale = p + 11;\n\t\t} else if (strncmp(p, \"cue=\", 4) == 0) {\n\t\t\tif (*p_cue)\n\t\t\t\tsyntax(\"Double cue\", p);\n\t\t\t*p_cue = p + 4;\n\t\t} else if (strncmp(p, \"map=\", 4) == 0) {\n\t\t\tif (*p_map)\n\t\t\t\tsyntax(\"Double map\", p);\n\t\t\t*p_map = p + 4;\n//\t\t} else if (strncmp(p, \"transpose=\", 10) == 0\n//\t\t\t|| strncmp(p, \"t=\", 2) == 0) {\n//\t\t\t;\t\t/* ignored - abcMIDI */\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t}\n\treturn p;\n}\n\n/* -- parse a decoration 'xxx<decosep>' -- */\nstatic char *get_deco(char *p,\n\t\t      unsigned char *p_dc)\n{\n\tchar *q, sep, **t;\n\tunsigned i, l;\n\n\t*p_dc = 0;\n\tq = p;\n\tsep = q[-1];\n\tif (char_tb[(unsigned char) sep] == CHAR_DECOS) {\n\t\tif (sep == '+') {\n\t\t\tif (*p == '+' && p[1] == '+')\n\t\t\t\tp++;\t\t/* special case \"+++\" */\n\t\t}\n\t} else {\n\t\tsep = '\\0';\t\t\t/* Barfly U: */\n\t}\n\twhile (*p != sep) {\n\t\tif (*p == '\\0') {\n\t\t\tsyntax(\"Decoration not terminated\", q);\n\t\t\treturn p;\n\t\t}\n\t\tp++;\n\t}\n\tl = p - q;\n\tif (*p == sep)\n\t\tp++;\n\tfor (i = 1, t = &parse.deco_tb[1];\n\t     *t && i < DC_NAME_SZ;\n\t     i++, t++) {\n\t\tif (strlen(*t) == l\n\t\t && strncmp(*t, q, l) == 0) {\n\t\t\t*p_dc = i + 128;\n\t\t\treturn p;\n\t\t}\n\t}\n\n\t/* new decoration */\n\tif (i < DC_NAME_SZ) {\n//\t\tif (parse.abc_state != ABC_S_GLOBAL)\n//\t\t\tlvlarena(0);\n\t\t*t = getarena(l + 1);\n//\t\tif (parse.abc_state != ABC_S_GLOBAL)\n//\t\t\tlvlarena(1);\n\t\tmemcpy(*t, q, l);\n\t\t(*t)[l] = '\\0';\n\t\t*p_dc = i + 128;\n\t} else {\n\t\tsyntax(\"Too many decoration types\", q);\n\t}\n\treturn p;\n}\n\n/* -- parse a list of accidentals (K:) -- */\nstatic char *parse_acc(char *p,\n\t\t\tstruct SYMBOL *s)\n{\n\tint pit = 0, acc;\n\tunsigned nacc;\n\n\tnacc = 0;\n\tfor (;;) {\n\t\tif (nacc >= sizeof s->u.key.pits) {\n\t\t\tsyntax(\"Too many accidentals\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\tif (acc < 0)\n\t\t\tbreak;\n\t\ts->u.key.pits[nacc] = pit;\n\t\ts->u.key.accs[nacc++] = acc;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tif (*p != '^' && *p != '_' && *p != '=')\n\t\t\tbreak;\n\t}\n\ts->u.key.microscale = microscale;\n\tif (s->u.key.empty != 2)\n\t\ts->u.key.nacc = nacc;\n\treturn p;\n}\n\n/* -- parse a clef (K: or V:) -- */\nstatic void parse_clef(struct SYMBOL *s,\n\t\t\tchar *name,\n\t\t\tchar *middle)\n{\n\tint clef = -1;\n\tint transpose = 0;\n\tint clef_line = 2;\n\tchar *warn = NULL;\n\tchar str[80];\n\n\tstr[0] = '\\0';\n\tif (name && strncmp(name, \"clef=\", 5) == 0) {\n\t\tname += 5;\n\t\tswitch (*name) {\n\t\tcase '\\\"':\n\t\t\tname = get_str(str, name, sizeof str);\n\t\t\ts->u.clef.name = getarena(strlen(str) + 1);\n\t\t\tstrcpy(s->u.clef.name, str);\n\t\t\tclef = TREBLE;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\twarn = name;\n\t\t\ttranspose = -7;\n\t\tcase 'G':\n\t\t\tclef = TREBLE;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\twarn = name;\n\t\t\ttranspose = -14;\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (name[1] == ',')\t/* abc2.1.1 clef=F == clef=F, */\n\t\t\t\ttranspose = -7;\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\twarn = name;\n\t\t\ttranspose = -7;\n\t\tcase 'C':\n\t\t\tclef = ALTO;\n\t\t\tclef_line = 3;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tclef = PERC;\n\t\t\tclef_line = 3;\n\t\t\tbreak;\n\t\t}\n\t\tif (clef >= 0) {\n\t\t\tname++;\n\t\t\tif (*name == ',' || *name== '\\'')\n\t\t\t\twarn = name;\n\t\t\twhile (*name == ',') {\n\t\t\t\ttranspose += 7;\n\t\t\t\tname++;\n\t\t\t}\n\t\t\twhile (*name == '\\'') {\n\t\t\t\ttranspose -= 7;\n\t\t\t\tname++;\n\t\t\t}\n\t\t}\n\t}\n\tif (name && clef < 0) {\n\t\tif (!strncmp(name, \"bass\", 4)) {\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\ts->u.clef.check_pitch = 1;\n\t\t\tname += 4;\n\t\t} else if (!strncmp(name, \"treble\", 6)) {\n\t\t\tclef = TREBLE;\n\t\t\tname += 6;\n\t\t} else if (!strncmp(name, \"alto\", 4)\n\t\t\t|| !strncmp(name, \"tenor\", 5)) {\n\t\t\tclef = ALTO;\n\t\t\tclef_line = *name == 'a' ? 3 : 4;\n\t\t\ts->u.clef.check_pitch = 1;\n\t\t\tif (*name == 'a')\n\t\t\t\tname += 4;\n\t\t\telse\n\t\t\t\tname += 5;\n\t\t} else if (!strncmp(name, \"perc\", 4)) {\n\t\t\tclef = PERC;\n\t\t\tclef_line = 3;\n\t\t\tname += 4;\n\t\t} else if (!strncmp(name, \"auto\", 4)) {\n\t\t\tclef = AUTOCLEF;\n\t\t\tname += 4;\n\t\t} else if (strncmp(name, \"none\", 4) == 0) {\n\t\t\tclef = TREBLE;\n\t\t\ts->u.clef.invis = 1;\n\t\t\ts->flags |= ABC_F_INVIS;\n\t\t\tname += 4;\n\t\t} else {\n\t\t\tsyntax(\"Unknown clef\", name);\n\t\t\tclef = TREBLE;\n\t\t}\n\t}\n\n\tif (clef >= 0) {\n\t\tif (isdigit((unsigned char) *name))\n\t\t\tclef_line = *name++ - '0';\n\t\tif (name[1] == '8') {\n\t\t\tswitch (*name) {\n\t\t\tcase '^':\n\t\t\t\ttranspose -= 7;\n\t\t\tcase '+':\n\t\t\t\ts->u.clef.octave = 1;\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\ttranspose += 7;\n\t\t\tcase '-':\n\t\t\t\ts->u.clef.octave = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (middle) {\n\t\tint pit = 0, acc, l;\n\t\tstatic const char line_tb[7] =\n\t\t\t{ALTO, TREBLE, ALTO, BASS, ALTO, BASS, ALTO};\n\n\t\twarn = middle;\n\t\t/* 'middle=<note pitch>' */\n\t\tparse_acc_pit(middle, &pit, &acc);\n\t\tif (acc < 0)\t\t\t// if error\n\t\t\tpit = 22;\n\n\t\tif (clef < 0)\n\t\t\tclef = line_tb[(pit + 7) % 7];\n\t\n\t\tswitch (clef) {\n\t\tdefault:\n\t\t\tl = 20 + 4;\n\t\t\tbreak;\n\t\tcase ALTO:\n\t\t\tl = 16 + 4;\n\t\t\tbreak;\n\t\tcase BASS:\n\t\t\tl = 12 + 4;\n\t\t\tbreak;\n\t\t}\n\t\tclef_line = (l - pit + 28) % 7;\n\t\tif (clef_line & 1) {\n\t\t\tsyntax(\"Bad 'middle' value for the clef\", middle);\n\t\t\tpit++;\n\t\t}\n\t\tclef_line = clef_line / 2 + 1;\n\n\t\ttranspose = l - (clef_line - 1) * 2 - pit;\n\t\ts->u.clef.check_pitch = 0;\n\t}\n\n\ts->u.clef.type = clef;\n\ts->u.clef.line = clef_line;\n\ts->u.clef.transpose = transpose;\n\tif (warn) {\n\t\tint sev_sav;\n\n\t\tsev_sav = severity;\n\t\tsyntax(\"Warning: Deprecated or non-standard item\", warn);\n\t\tseverity = sev_sav;\n\t}\n}\n\n/* get the octave= value */\nstatic int parse_octave(char *p)\n{\n\tint oct;\n\n\tif (p) {\n\t\toct = 1;\n\t\tif (*p == '-') {\n\t\t\toct = -1;\n\t\t\tp++;\n\t\t}\n\t\tif (*p >= '0' && *p <= '4')\n\t\t\treturn oct * (*p - '0');\n\t\tsyntax(\"Bad octave value\", p);\n\t}\n\treturn NO_OCTAVE;\n}\n\n/* -- parse a 'K:' -- */\nstatic void parse_key(char *p,\n\t\t      struct SYMBOL *s)\n{\n\tint sf, empty, instr;\n//\tint mode;\n\tchar *clef_name, *clef_middle, *clef_stlines, *clef_scale;\n\tchar *p_octave, *p_cue, *p_map;\n\n\t// set important default values\n//\ts->u.key.stafflines = \"|||||\";\n\ts->u.key.octave = NO_OCTAVE;\n\n\tif (*p == '\\0') {\n\t\ts->u.key.empty = 1;\n\t\treturn;\n\t}\n\tsf = 0;\n//\tmode = 0;\n\tempty = 0;\n\tinstr = 0;\n\tswitch (*p++) {\n\tcase 'F': sf = -1; break;\n\tcase 'B': sf++;\n\tcase 'E': sf++;\n\tcase 'A': sf++;\n\tcase 'D': sf++;\n\tcase 'G': sf++;\n\tcase 'C': break;\n\tcase 'H':\n\t\tif (*p == 'P') {\n\t\t\tinstr = K_HP;\n\t\t\tp++;\n\t\t} else if (*p == 'p') {\n\t\t\tinstr = K_Hp;\n\t\t\tsf = 2;\n\t\t\tp++;\n\t\t} else {\n\t\t\tsyntax(\"Unknown bagpipe-like key\", p);\n\t\t}\n\t\tbreak;\n\tcase 'P':\n\t\tinstr = K_DRUM;\n\t\tp++;\n\t\tbreak;\n\tcase 'n':\n\t\tif (strncmp(p, \"one\", 3) == 0) {\t// none\n\t\t\tempty = 2;\n\t\t\tp += 3;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0') {\n\t\t\t\ts->u.key.empty = empty;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// fall thru\n\tdefault:\n\t\tp--;\n\t\tempty = 1;\n\t\tbreak;\n\t}\n\ts->u.key.empty = empty;\n\n\tif (!empty) {\n\t\tif (*p == '#') {\n\t\t\tsf += 7;\n\t\t\tp++;\n\t\t} else if (*p == 'b') {\n\t\t\tsf -= 7;\n\t\t\tp++;\n\t\t}\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tswitch (*p) {\n\t\tcase 'a':\n\t\tcase 'A':\n\t\t\tif (strncasecmp(p, \"aeo\", 3) == 0) {\n\t\t\t\tsf -= 3;\n//\t\t\t\tmode = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tif (strncasecmp(p, \"dor\", 3) == 0) {\n\t\t\t\tsf -= 2;\n//\t\t\t\tmode = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\tif (strncasecmp(p, \"ion\", 3) == 0) {\n//\t\t\t\tmode = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tif (strncasecmp(p, \"loc\", 3) == 0) {\n\t\t\t\tsf -= 5;\n//\t\t\t\tmode = 6;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"lyd\", 3) == 0) {\n\t\t\t\tsf += 1;\n//\t\t\t\tmode = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tif (strncasecmp(p, \"maj\", 3) == 0)\n\t\t\t\tbreak;\n\t\t\tif (strncasecmp(p, \"mix\", 3) == 0) {\n\t\t\t\tsf -= 1;\n//\t\t\t\tmode = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"min\", 3) == 0\n\t\t\t || !isalpha((unsigned char) p[1])) { /* 'm' alone */\n\t\t\t\tsf -= 3;\n//\t\t\t\tmode = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tif (strncasecmp(p, \"phr\", 3) == 0) {\n\t\t\t\tsf -= 4;\n//\t\t\t\tmode = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unk;\n\t\tdefault:\nunk:\n\t\t\tempty = 1;\t\t\t// (local value)\n\t\t\tbreak;\n\t\t}\n\t\tif (!empty) {\n\t\t\twhile (isalpha((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t}\n\n\t\t// [exp] accidentals\n\t\tif (strncmp(p, \"exp \", 4) == 0) {\n\t\t\tp += 4;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0')\n\t\t\t\tsyntax(\"no accidental after 'exp'\", p);\n\t\t\ts->u.key.exp = 1;\n\t\t}\n\t\tif (s->u.key.exp && strncmp(p, \"none\", 4) == 0) {\n\t\t\tsf = 0;\n\t\t\tp += 4;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t} else switch (*p) {\n\t\t\tcase '^':\n\t\t\tcase '_':\n\t\t\tcase '=':\n\t\t\t\tp = parse_acc(p, s);\t\t/* accidentals */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sf > 7 || sf < -7) {\n\t\tsyntax(\"Too many sharps/flats\", p);\n\t\tif (sf > 0)\n\t\t\tsf -= 12;\n\t\telse\n\t\t\tsf += 12;\n\t}\n\n\t// extra parameters\n\tclef_name = clef_middle = clef_stlines = clef_scale = NULL;\n\tp_octave = p_cue = p_map = NULL;\n\tparse_extra(p, &clef_name, &clef_middle, &clef_stlines,\n\t\t\t&clef_scale, &p_octave, &p_cue, &p_map);\n\n\ts->u.key.sf = sf;\n//\ts->u.key.mode = mode;\n\ts->u.key.instr = instr;\n\ts->u.key.octave = parse_octave(p_octave);\n\tif (p_cue) {\n\t\tif (strncmp(p_cue, \"on\", 2) == 0)\n\t\t\ts->u.key.cue = 1;\n\t\telse\n\t\t\ts->u.key.cue = -1;\n\t}\n\tif (clef_stlines)\n\t\ts->u.key.stafflines = clef_stlines;\n\tif (clef_scale) {\n\t\tfloat sc;\n\n\t\tsc = atof(clef_scale);\n\t\tif (sc >= 0.5 && sc <= 3)\n\t\t\ts->u.key.staffscale = sc;\n\t\telse\n\t\t\tsyntax(\"Bad value of staffscale\", clef_scale);\n\t}\n\tif (clef_name || clef_middle) {\n\t\ts = abc_new(ABC_T_CLEF, NULL);\n\t\tparse_clef(s, clef_name, clef_middle);\n\t}\n\tif (p_map) {\n\t\tstrcpy(tex_buf, \"%%voicemap \");\n\t\tget_str(&tex_buf[11], p_map, TEX_BUF_SZ - 12);\n\t\tabc_new(ABC_T_PSCOM, tex_buf);\n\t}\n}\n\n/* -- set default length from 'L:' -- */\nstatic char *get_len(char *p,\n\t\t     struct SYMBOL *s)\n{\n\tint l1, l2, d;\n\tchar *error_txt = NULL;\n\n\tif (strcmp(p, \"auto\") == 0) {\t\t/* L:auto */\n\t\tulen = 15120;\t\t\t// 2*2*2*2*3*3*3*5*7\n\t\ts->u.length.base_length = -1;\n\t\treturn error_txt;\n\t}\n\tl1 = 0;\n\tl2 = 1;\n\tif (sscanf(p, \"%d /%d \", &l1, &l2) != 2\n\t || l1 == 0) {\n\t\ts->u.length.base_length = ulen ? ulen : BASE_LEN / 8;\n\t\treturn \"Bad unit note length: unchanged\";\n\t}\n\n\tif (l2 == 0) {\n\t\terror_txt = \"Bad length divisor, set to 4\";\n\t\tl2 = 4;\n\t}\n\td = BASE_LEN / l2;\n\tif (d * l2 != BASE_LEN) {\n\t\terror_txt = \"Length incompatible with BASE, using 1/8\";\n\t\td = BASE_LEN / 8;\n\t} else \t{\n\t\td *= l1;\n\t\tif (l1 != 1\n\t\t || (l2 & (l2 - 1))) {\n\t\t\terror_txt = \"Incorrect unit note length, using 1/8\";\n\t\t\td = BASE_LEN / 8;\n\t\t}\n\t}\n\ts->u.length.base_length = d;\n\treturn error_txt;\n}\n\n/* -- parse a 'M:' -- */\nstatic char *parse_meter(char *p,\n\t\t\t\tstruct SYMBOL *s)\n{\n\tint m1, m2, d, wmeasure, nm, in_parenth;\n\tunsigned i;\n\tchar *q;\nstatic char top_err[] = \"Cannot identify meter top\";\n\n\tif (*p == '\\0')\n\t\treturn \"Empty meter string\";\n\tnm = 0;\n\tin_parenth = 0;\n\tm1 = 0;\n\tif (strncmp(p, \"none\", 4) == 0) {\n\t\tp += 4;\t\t\t\t/* no meter */\n\t\twmeasure = 1;\t/* simplify measure numbering and MREST conversion */\n\t} else {\n\t    wmeasure = 0;\n\t    while (*p != '\\0') {\n\t\tif (*p == '=')\n\t\t\tbreak;\n\t\tif (nm >= MAX_MEASURE)\n\t\t\treturn \"Too many values in M:\";\n\t\tswitch (*p) {\n\t\tcase 'C':\n\t\t\ts->u.meter.meter[nm].top[0] = *p++;\n\t\t\tif (*p == '|')\n\t\t\t\ts->u.meter.meter[nm].top[1] = *p++;\n\t\t\tm1 = 4;\n\t\t\tm2 = 4;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\tcase 'o':\n\t\t\tif (*p == 'c')\n\t\t\t\tm1 = 4;\n\t\t\telse\n\t\t\t\tm1 = 3;\n\t\t\tm2 = 4;\n\t\t\ts->u.meter.meter[nm].top[0] = *p++;\n\t\t\tif (*p == '.')\n\t\t\t\ts->u.meter.meter[nm].top[1] = *p++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tif (p[1] == '(') {\t/* \"M:5/4 ((2+3)/4)\" */\n\t\t\t\tin_parenth = 1;\n\t\t\t\ts->u.meter.meter[nm++].top[0] = *p++;\n\t\t\t}\n\t\t\tq = p + 1;\n\t\t\twhile (*q != '\\0') {\n\t\t\t\tif (*q == ')' || *q == '/')\n\t\t\t\t\tbreak;\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (*q == ')' && q[1] == '/') {\t/* \"M:5/4 (2+3)/4\" */\n\t\t\t\tp++;\t\t/* remove the parenthesis */\n\t\t\t\tcontinue;\n\t\t\t}\t\t\t/* \"M:5 (2+3)\" */\n\t\t\t/* fall thru */\n\t\tcase ')':\n\t\t\tin_parenth = *p == '(';\n\t\t\ts->u.meter.meter[nm++].top[0] = *p++;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (sscanf(p, \"%d\", &m1) != 1\n\t\t\t || m1 <= 0)\n\t\t\t\treturn top_err;\n\t\t\ti = 0;\n\t\t\tm2 = 2;\t\t\t/* default when no bottom value */\n\t\t\tfor (;;) {\n\t\t\t\twhile (isdigit((unsigned char) *p)\n\t\t\t\t    && i < sizeof s->u.meter.meter[0].top)\n\t\t\t\t\ts->u.meter.meter[nm].top[i++] = *p++;\n\t\t\t\tif (*p == ')') {\n\t\t\t\t\tif (p[1] != '/')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (*p == '/') {\n\t\t\t\t\tp++;\n\t\t\t\t\tif (sscanf(p, \"%d\", &m2) != 1\n\t\t\t\t\t || m2 <= 0)\n\t\t\t\t\t\treturn \"Cannot identify meter bottom\";\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (isdigit((unsigned char) *p)\n\t\t\t\t\t    && i < sizeof s->u.meter.meter[0].bot)\n\t\t\t\t\t\ts->u.meter.meter[nm].bot[i++] = *p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*p != ' ' && *p != '+')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == '\\0' || p[1] == '(')\t/* \"M:5 (2/4+3/4)\" */\n\t\t\t\t\tbreak;\n\t\t\t\tif (i < sizeof s->u.meter.meter[0].top)\n\t\t\t\t\ts->u.meter.meter[nm].top[i++] = *p++;\n\t\t\t\tif (sscanf(p, \"%d\", &d) != 1\n\t\t\t\t || d <= 0)\n\t\t\t\t\treturn top_err;\n\t\t\t\tif (p[-1] == ' ') {\n\t\t\t\t\tif (d > m1)\n\t\t\t\t\t\tm1 = d;\n\t\t\t\t} else {\n\t\t\t\t\tm1 += d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!in_parenth)\n\t\t\twmeasure += m1 * BASE_LEN / m2;\n\t\tnm++;\n\t\tif (*p == ' ')\n\t\t\tp++;\n\t\telse if (*p == '+')\n\t\t\ts->u.meter.meter[nm++].top[0] = *p++;\n\t    }\n\t}\n\tmeter = m1;\n\tif (*p == '=') {\n\t\tif (sscanf(++p, \"%d/%d\", &m1, &m2) != 2\n\t\t || m1 <= 0\n\t\t || m2 <= 0)\n\t\t\treturn \"Cannot identify meter explicit duration\";\n\t\twmeasure = m1 * BASE_LEN / m2;\n\t\ts->u.meter.expdur = 1;\n\t}\n\ts->u.meter.wmeasure = wmeasure;\n\ts->u.meter.nmeter = nm;\n\n\t/* in the tune header, change the unit note length */\n\tif (parse.abc_state == ABC_S_HEAD && ulen == 0) {\n\t\tif (wmeasure >= BASE_LEN * 3 / 4\n\t\t || wmeasure <= 1)\n\t\t\tulen = BASE_LEN / 8;\n\t\telse\n\t\t\tulen = BASE_LEN / 16;\n\t}\n\treturn 0;\n}\n\n/* -- get a possibly quoted string -- */\nchar *get_str(char *d,\t\t/* destination */\n\t      char *s,\t\t/* source */\n\t      int maxlen)\t/* max length */\n{\n\tchar c;\n\n\tmaxlen--;\t\t/* have place for the EOS */\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s == '\"') {\n\t\ts++;\n\t\twhile ((c = *s) != '\\0') {\n\t\t\tif (c == '\"') {\n\t\t\t\ts++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '\\\\') {\n\t\t\t\tif (--maxlen > 0)\n\t\t\t\t\t*d++ = c;\n\t\t\t\tc = *++s;\n\t\t\t}\n\t\t\tif (--maxlen > 0)\n\t\t\t\t*d++ = c;\n\t\t\ts++;\n\t\t}\n\t} else {\n\t\twhile ((c = *s) != '\\0') {\n\t\t\tif (isspace((unsigned char) c))\n\t\t\t\tbreak;\n\t\t\tif (--maxlen > 0)\n\t\t\t\t*d++ = c;\n\t\t\ts++;\n\t\t}\n\t}\n\t*d = '\\0';\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\treturn s;\n}\n\n/* -- parse a tempo (Q:) -- */\nstatic char *parse_tempo(char *p,\n\t\t\t struct SYMBOL *s)\n{\n\tchar c, str[80];\n\tint i, l, n, top, bot;\n\n\t/* string before */\n\tif (*p == '\"') {\n\t\tp = get_str(str, p, sizeof str);\n\t\ts->u.tempo.str1 = getarena(strlen(str) + 1);\n\t\tstrcpy(s->u.tempo.str1, str);\n\t}\n\n\t/* beat */\n\tif (*p == 'C' || *p == 'c'\n\t || *p == 'L' || *p == 'l') {\n\t\ts->u.tempo.beats[0] = ulen;\n\t\tif (parse.abc_vers >= (2 << 16))\n\t\t\tsyntax(\"Deprecated Q: value\", p);\n\t\tp++;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p != '=')\n\t\t\tgoto inval;\n\t\tc = '=';\n\t\tp--;\n\t} else if (isdigit((unsigned char) *p)) {\n\t\tif (strchr(p, '/') != NULL) {\n\t\t\ti = 0;\n\t\t\twhile (isdigit((unsigned char) *p)) {\n\t\t\t\tif (sscanf(p, \"%d/%d%n\", &top, &bot, &n) != 2\n\t\t\t\t || bot <= 0)\n\t\t\t\t\tgoto inval;\n\t\t\t\tl = (BASE_LEN * top) / bot;\n\t\t\t\tif (l <= 0\n\t\t\t\t || i >= sizeof s->u.tempo.beats\n\t\t\t\t\t\t/ sizeof s->u.tempo.beats[0])\n\t\t\t\t\tgoto inval;\n\t\t\t\ts->u.tempo.beats[i++] = l;\n\t\t\t\tp += n;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t}\n\t\t\tc = *p;\n\t\t\tif (c != '=')\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\ts->u.tempo.beats[0] = ulen;\n\t\t\tif (parse.abc_vers >= (2 << 16))\n\t\t\t\tsyntax(\"Deprecated Q: value\", p);\n\t\t\tc = '=';\n\t\t\tp--;\n\t\t}\n\t} else {\n\t\tc = '\\0';\n\t}\n\n\t/* tempo value */\n\tif (c == '=') {\n\t\tp++;\n\t\tif (strncmp(p, \"ca. \", 4) == 0) {\n\t\t\ts->u.tempo.circa = 1;\n\t\t\tp += 4;\n\t\t}\n\t\tif (sscanf(p, \"%d/%d%n\", &top, &bot, &n) == 2) {\n\t\t\tif (bot <= 0)\n\t\t\t\tgoto inval;\n\t\t\tl = (BASE_LEN * top) / bot;\n\t\t\tif (l <= 0)\n\t\t\t\tgoto inval;\n\t\t\ts->u.tempo.new_beat = l;\n\t\t} else {\n\t\t\tif (sscanf(p, \"%d%n\", &top, &n) != 1)\n\t\t\t\tgoto inval;\n\t\t\ts->u.tempo.tempo = top;\n\t\t}\n\t\tp += n;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t}\n\n\t/* string after */\n\tif (*p == '\"') {\n\t\tp = get_str(str, p, sizeof str);\n\t\ts->u.tempo.str2 = getarena(strlen(str) + 1);\n\t\tstrcpy(s->u.tempo.str2, str);\n\t}\n\n\treturn 0;\ninval:\n\treturn \"Invalid tempo\";\n}\n\n/* -- get a user defined symbol (U:) -- */\nstatic char *get_user(char *p,\n\t\t      struct SYMBOL *s)\n{\n\tunsigned char c;\n\tchar *value;\n\n\tc = (unsigned char) *p++;\n\tif (c == '\\\\') {\n\t\tc = (unsigned char) *p++;\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tc = '\\n';\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tc = '\\t';\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (char_tb[c]) {\n\tdefault:\n\t\treturn \"Bad decoration character\";\n\tcase CHAR_DECO:\n\t\tbreak;\n\tcase CHAR_BAD:\n\tcase CHAR_IGN:\n\tcase CHAR_SPAC:\n\tcase CHAR_DECOS:\n\tcase CHAR_LINEBREAK:\n\t\tchar_tb[c] = CHAR_DECO;\n\t\tbreak;\n\t}\n\ts->u.user.symbol = c;\n\n\t/* skip '=' */\n\twhile (isspace((unsigned char) *p) || *p == '=')\n\t\tp++;\n\tif (char_tb[(unsigned char) *p] == CHAR_DECOS)\n\t\tp++;\n/*fixme: 'U: <char> = \"text\"' is not treated */\n\tget_deco(p, &s->u.user.value);\n\tif (!s->u.user.value)\n\t\treturn 0;\n\n\t/* treat special pseudo decorations */\n\tvalue = parse.deco_tb[s->u.user.value - 128];\n\tif (strcmp(value, \"beambreak\") == 0)\n\t\tchar_tb[c] = CHAR_SPAC;\n\telse if (strcmp(value, \"ignore\") == 0)\n\t\tchar_tb[c] = CHAR_IGN;\n\telse if (strcmp(value, \"nil\") == 0\n\t      || strcmp(value, \"none\") == 0)\n\t\tchar_tb[c] = CHAR_BAD;\n\telse\n\t\treturn 0;\n\ts->u.user.value\t= 0;\t\t/* not a decoration */\n\treturn 0;\n}\n\n/* -- parse the voice parameters (V:) -- */\nstatic char *parse_voice(char *p,\n\t\t\t struct SYMBOL *s)\n{\n\tint voice;\n\tchar *error_txt = NULL;\n\tchar *clef_name, *clef_middle, *clef_stlines, *clef_scale;\n\tchar *p_octave, *p_cue, *p_map;\n\tsigned char *p_stem;\nstatic struct kw_s {\n\tchar *name;\n\tshort len;\n\tshort index;\n} kw_tb[] = {\n\t{\"name=\", 5, 0},\n\t{\"nm=\", 3, 0},\n\t{\"subname=\", 8, 1},\n\t{\"sname=\", 6, 1},\n\t{\"snm=\", 4, 1},\n\t{\"merge\", 5, 2},\n\t{\"up\", 2, 3},\n\t{\"down\", 4, 4},\n\t{\"stem=\", 5, 5},\n\t{\"gstem=\", 6, 6},\n\t{\"auto\", 4, 7},\n\t{\"dyn=\", 4, 8},\n\t{\"lyrics=\", 7, 9},\n\t{\"scale=\", 6, 10},\n\t{\"gchord=\", 7, 11},\n\t{0}\n};\n\tstruct kw_s *kw;\n\n\t/* save the parameters of the previous voice */\n\tcurvoice->ulen = ulen;\n\tcurvoice->microscale = microscale;\n\n\tif (voice_tb[0].id[0] == '\\0') {\n\t\tswitch (s->abc_prev->abc_type) {\n\t\tcase ABC_T_EOLN:\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\tcase ABC_T_BAR:\n\t\t\t/* the previous voice was implicit (after K:) */\n\t\t\tvoice_tb[0].id[0] = '1';\n\t\t\tbreak;\n\t\t}\n\t}\n\t{\n\t\tchar *id, sep;\n\n\t\tid = p;\n\t\twhile (isalnum((unsigned char) *p) || *p == '_')\n\t\t\tp++;\n\t\tsep = *p;\n\t\t*p = '\\0';\n\t\tif (voice_tb[0].id[0] == '\\0') {\n\t\t\tvoice = 0;\t\t\t/* first voice */\n\t\t} else {\n\t\t\tfor (voice = 0; voice <= nvoice; voice++) {\n\t\t\t\tif (strcmp(id, voice_tb[voice].id) == 0)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tif (voice >= MAXVOICE) {\n\t\t\t\tsyntax(\"Too many voices\", id);\n\t\t\t\tvoice--;\n\t\t\t}\n\t\t}\n\t\tnvoice = voice;\n\t\tstrncpy(voice_tb[voice].id, id, sizeof voice_tb[voice].id - 1);\n\t\tvoice_tb[voice].mvoice = voice;\n\tfound:\n\t\tstrcpy(s->u.voice.id, voice_tb[voice].id);\n\t\t*p = sep;\n\t}\n\tcurvoice = &voice_tb[voice];\n\ts->u.voice.voice = voice;\n\n\t/* if in tune, set the voice parameters */\n\tif (parse.abc_state == ABC_S_TUNE) {\n\t\tulen = curvoice->ulen;\n\t\tmicroscale = curvoice->microscale;\n\t}\n\n\t/* parse the other parameters */\n\tclef_name = clef_middle = clef_stlines = clef_scale = NULL;\n\tp_octave = p_cue = p_map = NULL;\n\tp_stem = &s->u.voice.stem;\n\tfor (;;) {\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tp = parse_extra(p, &clef_name, &clef_middle, &clef_stlines,\n\t\t\t\t&clef_scale, &p_octave, &p_cue, &p_map);\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tfor (kw = kw_tb; kw->name; kw++) {\n\t\t\tif (strncmp(p, kw->name, kw->len) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!kw->name) {\n\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\tp++;\t/* ignore unknown keywords */\n\t\t\tcontinue;\n\t\t}\n\t\tp += kw->len;\n\t\tswitch (kw->index) {\n\t\tcase 0:\t\t\t/* name */\n\t\t\tp = get_str(tex_buf, p, TEX_BUF_SZ);\n\t\t\ts->u.voice.fname = getarena(strlen(tex_buf) + 1);\n\t\t\tstrcpy(s->u.voice.fname, tex_buf);\n\t\t\tbreak;\n\t\tcase 1:\t\t\t/* subname */\n\t\t\tp = get_str(tex_buf, p, TEX_BUF_SZ);\n\t\t\ts->u.voice.nname = getarena(strlen(tex_buf) + 1);\n\t\t\tstrcpy(s->u.voice.nname, tex_buf);\n\t\t\tbreak;\n\t\tcase 2:\t\t\t/* merge */\n\t\t\ts->u.voice.merge = 1;\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* up */\n\t\t\t*p_stem = 1;\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* down */\n\t\t\t*p_stem = -1;\n\t\t\tbreak;\n\t\tcase 5:\t\t\t/* stem= */\n\t\t\tp_stem = &s->u.voice.stem;\n\t\t\tbreak;\n\t\tcase 6:\t\t\t/* gstem= */\n\t\t\tp_stem = &s->u.voice.gstem;\n\t\t\tbreak;\n\t\tcase 7:\t\t\t/* auto */\n\t\t\t*p_stem = 2;\n\t\t\tbreak;\n\t\tcase 8:\t\t\t/* dyn= */\n\t\t\tp_stem = &s->u.voice.dyn;\n\t\t\tbreak;\n\t\tcase 9:\t\t\t/* lyrics= */\n\t\t\tp_stem = &s->u.voice.lyrics;\n\t\t\tbreak;\n\t\tcase 10: {\t\t/* scale= */\n\t\t\tfloat sc;\n\n\t\t\tsc = atof(p);\n\t\t\tif (sc >= 0.5 && sc <= 2)\n\t\t\t\ts->u.voice.scale = sc;\n\t\t\telse\n\t\t\t\terror_txt = \"Bad value for voice scale\";\n\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\tp++;\n\t\t\tbreak;\n\t\t    }\n\t\tcase 11:\t\t/* gchord= */\n\t\t\tp_stem = &s->u.voice.gchord;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ts->u.voice.octave = parse_octave(p_octave);\n\tif (p_cue) {\n\t\tif (strncmp(p_cue, \"on\", 2) == 0)\n\t\t\ts->u.voice.cue = 1;\n\t\telse\n\t\t\ts->u.voice.cue = -1;\n\t}\n\tif (clef_stlines)\n\t\ts->u.voice.stafflines = clef_stlines;\n//\telse\n//\t\ts->u.voice.stafflines = \"|||||\";\n\tif (clef_scale) {\n\t\tfloat sc;\n\n\t\tsc = atof(clef_scale);\n\t\tif (sc >= 0.5 && sc <= 3)\n\t\t\ts->u.voice.staffscale = sc;\n\t\telse\n\t\t\tsyntax(\"Bad value of staffscale\", clef_scale);\n\t}\n\tif (clef_name || clef_middle) {\n\t\ts = abc_new(ABC_T_CLEF, NULL);\n\t\tparse_clef(s, clef_name, clef_middle);\n\t}\n\tif (p_map) {\n\t\tstrcpy(tex_buf, \"%%voicemap \");\n\t\tget_str(&tex_buf[11], p_map, TEX_BUF_SZ - 12);\n\t\tabc_new(ABC_T_PSCOM, tex_buf);\n\t}\n\treturn error_txt;\n}\n\n/* -- parse a bar -- */\nstatic char *parse_bar(char *p)\n{\n\tstruct SYMBOL *s;\n\tchar *q;\n\tint bar_type, i;\n\tchar repeat_value[32];\n\n\tq = --p;\t\t\t// keep the first char\n\tbar_type = 0;\n\tfor (;;) {\n\t\tswitch (*p++) {\n\t\tcase '|':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_BAR;\n\t\t\tcontinue;\n\t\tcase '[':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_OBRA;\n\t\t\tcontinue;\n\t\tcase ']':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_CBRA;\n\t\t\tcontinue;\n\t\tcase ':':\n\t\t\tbar_type <<= 4;\n\t\t\tbar_type |= B_COL;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tp--;\n\n\t/* if the last element is '[', it may start\n\t * a chord, an embedded header or an other bar */\n\tif ((bar_type & 0x0f) == B_OBRA && bar_type != B_OBRA\n\t && *p != ' ') {\n\t\tbar_type >>= 4;\n\t\tp--;\n\t}\n\n\tif (bar_type == (B_OBRA << 8) + (B_BAR << 4) + B_CBRA)\t/* [|] */\n\t\tbar_type = (B_OBRA << 4) + B_CBRA;\t\t/* [] */\n\n/*\tcurvoice->last_note = NULL; */\n\tif (vover > 0) {\n\t\tcurvoice = &voice_tb[curvoice->mvoice];\n\t\tvover = 0;\n\t}\n\ts = abc_new(ABC_T_BAR, gchord);\n\tif (gchord)\n\t\tgchord = NULL;\n\n\t/* handle the repeat sequences */\n\tif (bar_type == B_COL) {\n\t\tbar_type = B_BAR;\n\t\ts->u.bar.dotted = 1;\n\t} else {\n\t\tif (*q == ']') {\t\t/* repeat bar stop */\n\t\t\ti = p - q - 1;\n\t\t\tif (i > 0)\t\t/* remove the starting ']' */\n\t\t\t\ts->u.bar.type &= (1 << (i * 4)) - 1;\n\t\t\ts->flags |= ABC_F_RBSTOP;\n\t\t\ts->sflags |= S_RBSTOP;\n\t\t} else if ((bar_type & 0x0f) == B_COL\t/* left or */\n\t\t\t|| *q == ':') {\t\t\t/* right repeat bar */\n\t\t\ts->flags |= ABC_F_RBSTOP;\n\t\t\ts->sflags |= S_RBSTOP;\n\t\t\tif (*q == ':')\t\t/* right repeat bar */\n\t\t\t\ts->sflags |= S_RRBAR;\n\t\t}\n\t}\n\n\ts->u.bar.type = bar_type;\n\n\tif (dc.n > 0) {\n\t\tmemcpy(&s->u.bar.dc, &dc, sizeof s->u.bar.dc);\n\t\tdc.n = 0;\n\t}\n\n\tif (!lyric_started) {\n\t\tlyric_started = 1;\n\t\ts->flags |= ABC_F_LYRIC_START;\n\t}\n\n\tif (!isdigit((unsigned char) *p)\t/* if not a repeat bar */\n\t && (*p != '\"' || p[-1] != '['))\t/* ('[\"' only) */\n\t\treturn p;\n\n\tif (*p == '\"') {\n\t\tp = get_str(repeat_value, p, sizeof repeat_value);\n\t} else {\n\t\tchar *q;\n\n\t\tq = repeat_value;\n\t\twhile (isdigit((unsigned char) *p)\n\t\t    || *p == ','\n\t\t    || *p == '-'\n\t\t    || (*p == '.' && isdigit((unsigned char) p[1]))) {\n\t\t\tif (q < &repeat_value[sizeof repeat_value - 1])\n\t\t\t\t*q++ = *p++;\n\t\t\telse\n\t\t\t\tp++;\n\t\t}\n\t\t*q = '\\0';\n\t}\n\tif (bar_type != B_OBRA\n\t || s->text) {\n\t\ts = abc_new(ABC_T_BAR, repeat_value);\n\t\ts->u.bar.type = B_OBRA;\n\t} else {\n\t\ts->text = getarena(strlen(repeat_value) + 1);\n\t\tstrcpy(s->text, repeat_value);\n\t}\n\ts->u.bar.repeat_bar = 1;\n\ts->flags |= ABC_F_RBSTART | ABC_F_RBSTOP;\n\ts->sflags |= S_RBSTART | S_RBSTOP;\n\treturn p;\n}\n\n// parse the note accidental and pitch\nchar *parse_acc_pit(char *p,\n\t\tint *pit,\n\t\tint *acc)\n{\n\t/* look for accidental sign */\n\tswitch (*p) {\n\tcase '^':\n\t\tp++;\n\t\tif (*p == '^') {\n\t\t\tp++;\n\t\t\t*acc = A_DS;\n\t\t} else {\n\t\t\t*acc = A_SH;\n\t\t}\n\t\tbreak;\n\tcase '=':\n\t\tp++;\n\t\t*acc = A_NT;\n\t\tbreak;\n\tcase '_':\n\t\tp++;\n\t\tif (*p == '_') {\n\t\t\tp++;\n\t\t\t*acc = A_DF;\n\t\t} else {\n\t\t\t*acc = A_FT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*acc = 0;\n\t}\n\n\t/* look for microtone value */\n\tif (*acc != 0\n\t && (isdigit((unsigned char) *p)\n\t  || (*p == '/' && microscale == 0))) {\n\t\tint n, d;\n\t\tchar *q;\n\n\t\tn = d = 1;\n\t\tif (*p != '/') {\n\t\t\tn = strtol(p, &q, 10);\n\t\t\tp = q;\n\t\t}\n\t\tif (*p == '/') {\n\t\t\tp++;\n\t\t\tif (!isdigit((unsigned char) *p)) {\n\t\t\t\td = 2;\n\t\t\t} else {\n\t\t\t\td = strtol(p, &q, 10);\n\t\t\t\tp = q;\n\t\t\t}\n\t\t}\n\t\tif (microscale == 0) {\n\t\t\td--;\n\t\t\td += (n - 1) << 8;\t/* short [ (n-1) | (d-1) ] */\n\t\t\tif (d == 0) {\n\t\t\t\tn = MAXMICRO - 1;\n\t\t\t} else {\n\t\t\t    for (n = 1; n < MAXMICRO; n++) {\n\t\t\t\tif (parse.micro_tb[n] == d)\n\t\t\t\t\tbreak;\n\t\t\t\tif (parse.micro_tb[n] == 0) {\n\t\t\t\t\tparse.micro_tb[n] = d;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\tif (n == MAXMICRO) {\n\t\t\t\tsyntax(\"Too many microtone accidentals\", p);\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t}\n\t\t*acc += (n << 3);\n\t}\n\n\t/* get the pitch */\n\t{\n\t\tchar *p_n;\n\n\t\tp_n = strchr(all_notes, *p);\n\t\tif (!p_n || *p == '\\0') {\n\t\t\tsyntax(*acc ? \"Missing note after accidental\"\n\t\t\t\t   : \"Not a note\", p);\n\t\t\t*acc = -1;\n\t\t\tif (*p == '\\0')\n\t\t\t\tp--;\n\t\t} else {\n\t\t\t*pit = p_n - all_notes + 16;\n\t\t}\n\t\tp++;\n\t}\n\twhile (*p == '\\'') {\t\t/* eat up following ' chars */\n\t\t*pit += 7;\n\t\tp++;\n\t}\n\twhile (*p == ',') {\t\t/* eat up following , chars */\n\t\t*pit -= 7;\n\t\tp++;\n\t}\n\treturn p;\n}\n\n/* -- parse the decorations of notes and bars -- */\nstatic char *parse_deco(char *p,\n\t\t\t struct decos *deco,\n\t\t\t int m)\t\t\t/* note index / -1 */\n{\n\tint n;\n\tunsigned char t;\n\n\tn = deco->n;\n\tfor (;;) {\n\t\tt = (unsigned char) *p++;\n\t\tif (char_tb[t] != CHAR_DECO && char_tb[t] != CHAR_DECOS)\n\t\t\tbreak;\n\t\tif (char_tb[t] == CHAR_DECOS)\n\t\t\tp = get_deco(p, &t);\n\t\tif (n >= MAXDC) {\n\t\t\tsyntax(\"Too many decorations for the note\", p);\n\t\t} else if (t != 0) {\n\t\t\tdeco->tm[n].t = t;\n\t\t\tdeco->tm[n++].m = m;\n\t\t}\n\t}\n\tdeco->n = n;\n\treturn p - 1;\n}\n\n/* -- parse a decoration line (d: or s:) -- */\nstatic char *parse_decoline(char *p)\n{\n\tstruct SYMBOL *is;\n\tunsigned char t;\n\tint n;\n\n\tif ((is = deco_cont) == NULL)\n\t\tis = deco_start;\n\telse\n\t\tdeco_cont = NULL;\n\n\t/* scan the decoration line */\n\twhile (*p != '\\0') {\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tswitch (*p) {\n\t\tcase '|':\n\t\t\twhile (is && (is->abc_type != ABC_T_BAR\n\t\t\t\t\t|| is->u.bar.type == B_OBRA))\n\t\t\t\tis = is->abc_next;\n\t\t\tif (!is) {\n\t\t\t\tsyntax(\"Not enough bar lines for deco line\", p);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tis = is->abc_next;\n\t\t\tp++;\n\t\t\tcontinue;\n\t\tcase '*':\n\t\t\twhile (is && is->abc_type != ABC_T_NOTE)\n\t\t\t\tis = is->abc_next;\n\t\t\tif (!is) {\n\t\t\t\tsyntax(\"Not enough notes for deco line\", p);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tis = is->abc_next;\n\t\t\tp++;\n\t\t\tcontinue;\n\t\tcase '\\\\':\n\t\t\tif (p[1] == '\\0') {\n\t\t\t\tif (!is)\n\t\t\t\t\treturn \"Not enough notes for deco line\";\n\t\t\t\tdeco_cont = is;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tsyntax(\"'\\\\' ignored\", p);\n\t\t\tp++;\n\t\t\tcontinue;\n\t\tcase '\"':\n\t\t\tp = parse_gchord(p + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (char_tb[(unsigned char) *p] == CHAR_DECOS)\n\t\t\t\tp = get_deco(p + 1, &t);\n\t\t\telse\n\t\t\t\tt = (unsigned char) *p++;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* store the decoration and gchord/annotation in the next note */\n\t\twhile (is && (is->abc_type != ABC_T_NOTE\n\t\t\t\t|| (is->flags & ABC_F_GRACE)))\n\t\t\tis = is->abc_next;\n\t\tif (!is)\n\t\t\treturn \"Not enough notes for deco line\";\n\n\t\tif (gchord) {\n\t\t\tif (is->text) {\n\t\t\t\tchar *gch;\n\n\t\t\t\tn = strlen(is->text);\n\t\t\t\tgch = getarena(n + strlen(gchord) + 2);\n\t\t\t\tstrcpy(gch, is->text);\n\t\t\t\tgch[n] = '\\n';\n\t\t\t\tstrcpy(gch + n + 1, gchord);\n\t\t\t\tgchord = gch;\n\t\t\t}\n\t\t\tis->text = gchord;\n\t\t\tgchord = NULL;\n\t\t} else {\n\t\t\tn = is->u.note.dc.n;\n\t\t\tif (n >= MAXDC) {\n\t\t\t\tsyntax(\"Too many decorations for the note\", p);\n\t\t\t} else if (t != 0) {\n\t\t\t\tis->u.note.dc.tm[n].t = t;\n\t\t\t\tis->u.note.dc.tm[n].m = -1;\n\t\t\t\tis->u.note.dc.n = ++n;\n\t\t\t}\n\t\t}\n\t\tis = is->abc_next;\n\t}\n\treturn NULL;\n}\n\n/* -- parse a guitar chord / annotation -- */\nstatic char *parse_gchord(char *p)\n{\n\tchar *q;\n\tint l, l2;\n\n\tq = p;\n\twhile (*p != '\"') {\n\t\tif (*p == '\\\\')\n\t\t\tp++;\n\t\tif (*p == '\\0') {\n\t\t\tsyntax(\"No end of guitar chord\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\tl = p - q;\n\tif (gchord) {\n\t\tchar *gch;\n\n\t\t/* many guitar chords: concatenate with '\\n' */\n\t\tl2 = strlen(gchord);\n\t\tgch = getarena(l2 + 1 + l + 1);\n\t\tstrcpy(gch, gchord);\n\t\tgch[l2++] = '\\n';\n\t\tstrncpy(&gch[l2], q, l);\n\t\tgch[l2 + l] = '\\0';\n\t\tgchord = gch;\n\t} else {\n\t\tgchord = getarena(l + 1);\n\t\tstrncpy(gchord, q, l);\n\t\tgchord[l] = '\\0';\n\t}\n\tif (*p != '\\0')\n\t\tp++;\n\treturn p;\n}\n\n/* -- parse a note length -- */\nstatic char *parse_len(char *p,\n\t\t\tint dur_u,\n\t\t\tint *p_len)\n{\n\tint len, fac;\n\tint err = 0;\n\tchar *q;\n\n\tlen = dur_u;\n\tif (isdigit((unsigned char) *p)) {\n\t\tlen *= strtol(p, &q, 10);\n\t\tif (len <= 0 || len > 10000) {\n\t\t\tsyntax(\"Bad length\", p);\n\t\t\tlen = dur_u;\n\t\t}\n\t\tp = q;\n\t}\n\tif (*p != '/') {\n\t\t*p_len = len;\n\t\treturn p;\n\t}\n\tif (isdigit((unsigned char) p[1])) {\n\t\tfac = strtol(p + 1, &q, 10);\n\t\tp = q;\n\t\tif (fac == 0 || (fac & (fac - 1)))\n\t\t\terr = 1;\n\t\telse\n\t\t\tlen /= fac;\n\t} else {\n\t\twhile (*p == '/') {\n\t\t\tif (len & 1)\n\t\t\t\terr = 1;\n\t\t\tlen /= 2;\n\t\t\tp++;\n\t\t}\n\t}\n\tif (err || !len) {\n\t\tsyntax(\"Bad length divisor\", p - 1);\n\t\tlen = dur_u;\n\t}\n\t*p_len = len;\n\treturn p;\n}\n\n/* -- parse a ABC line -- */\n/* return 1 on end of tune, and 2 on start of new tune */\nstatic int parse_line(char *p)\n{\n\tstruct SYMBOL *s;\n\tchar *q, c;\n\tchar *dot = NULL;\n\tstruct SYMBOL *last_note_sav = NULL;\n\tstruct decos dc_sav;\n\tint i, flags, flags_sav = 0, slur;\n\tstatic char qtb[10] = {0, 1, 3, 2, 3, 0, 2, 0, 3, 0};\n\n\tcolnum = 0;\n\tswitch (*p) {\n\tcase '\\0':\t\t\t/* blank line */\n\t\tswitch (parse.abc_state) {\n\t\tcase ABC_S_GLOBAL:\n\t\t\tif (parse.last_sym\n\t\t\t && parse.last_sym->abc_type != ABC_T_NULL)\n\t\t\t\tabc_new(ABC_T_NULL, NULL);\n\t\tcase ABC_S_HEAD:\t/*fixme: may have blank lines in headers?*/\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase '%':\n\t\tif (p[1] == '%') {\n\t\t\ts = abc_new(ABC_T_PSCOM, p);\n\t\t\tp += 2;\t\t\t\t/* skip '%%' */\n\t\t\tif (strncasecmp(p, \"decoration \", 11) == 0) {\n\t\t\t\tp += 11;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '!':\n\t\t\t\t\tchar_tb['!'] = CHAR_DECOS;\n\t\t\t\t\tchar_tb['+'] = CHAR_BAD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tchar_tb['+'] = CHAR_DECOS;\n\t\t\t\t\tchar_tb['!'] = CHAR_BAD;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"linebreak \", 10) == 0) {\n\t\t\t\tfor (i = 0; i < sizeof char_tb; i++) {\n\t\t\t\t\tif (char_tb[i] == CHAR_LINEBREAK)\n\t\t\t\t\t\tchar_tb[i] = i != '!' ?\n\t\t\t\t\t\t\t\tCHAR_BAD :\n\t\t\t\t\t\t\t\tCHAR_DECOS;\n\t\t\t\t}\n\t\t\t\tp += 10;\n\t\t\t\tfor (;;) {\n\t\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\t\tp++;\n\t\t\t\t\tif (*p == '\\0')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tswitch (*p) {\n\t\t\t\t\tcase '!':\n\t\t\t\t\tcase '$':\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase ';':\n\t\t\t\t\tcase '?':\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tchar_tb[(unsigned char) *p++]\n\t\t\t\t\t\t\t\t= CHAR_LINEBREAK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tif (strncmp(p, \"<none>\", 6) == 0)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tif (strncmp(p, \"<EOL>\", 5) == 0) {\n\t\t\t\t\t\t\tchar_tb['\\n'] = CHAR_LINEBREAK;\n\t\t\t\t\t\t\tp += 5;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fall thru */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (strcmp(p, \"lock\") != 0)\n\t\t\t\t\t\t\tsyntax(\"Invalid character in %%%%linebreak\",\n\t\t\t\t\t\t\t\tp);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"microscale \", 11) == 0) {\n\t\t\t\tint v;\n\n\t\t\t\tp += 11;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tsscanf(p, \"%d\", &v);\n\t\t\t\tif (v < 4 || v >= 256 || v & 1)\n\t\t\t\t\tsyntax(\"Invalid value in %%microscale\", p);\n\t\t\t\telse\n\t\t\t\t\tmicroscale = v;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"user \", 5) == 0) {\n\t\t\t\tp += 5;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tget_user(p, s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/* fall thru */\n\tcase '\\\\':\t\t\t\t/* abc2mtex specific lines */\n\t\treturn 0;\t\t\t/* skip */\n\t}\n\n\t/* header fields */\n\tif (p[1] == ':'\n\t && *p != '|' && *p != ':') {\t\t/* not '|:' nor '::' */\n\t\tint new_tune;\n\n\t\tnew_tune = parse_info(p);\n\n\t\t/* handle BarFly voice definition */\n\t\t/* 'V:n <note line ending with a bar>' */\n\t\tif (*p != 'V'\n\t\t || parse.abc_state != ABC_S_TUNE)\n\t\t\treturn new_tune;\t\t/* (normal return) */\n\t\tc = p[strlen(p) - 1];\n\t\tif (c != '|' && c != ']')\n\t\t\treturn new_tune;\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t}\n\tif (parse.abc_state != ABC_S_TUNE)\n\t\treturn 0;\n\n\t/* music */\n\tflags = 0;\n\tif (parse.abc_vers <= (2 << 16))\n\t\tlyric_started = 0;\n\tdeco_start = deco_cont = NULL;\n\tslur = 0;\n\twhile (*p != '\\0') {\n\t\tcolnum = p - abc_line;\n\t\tswitch (char_tb[(unsigned char) *p++]) {\n\t\tcase CHAR_GCHORD:\t\t\t/* \" */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tp = parse_gchord(p);\n\t\t\tbreak;\n\t\tcase CHAR_GR_ST:\t\t/* '{' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tlast_note_sav = curvoice->last_note;\n\t\t\tcurvoice->last_note = NULL;\n\t\t\tmemcpy(&dc_sav, &dc, sizeof dc);\n\t\t\tdc.n = 0;\n\t\t\tflags_sav = flags;\n\t\t\tflags = ABC_F_GRACE;\n\t\t\tif (*p == '/') {\n\t\t\t\tflags |= ABC_F_SAPPO;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHAR_GR_EN:\t\t/* '}' */\n\t\t\tif (!(flags & ABC_F_GRACE))\n\t\t\t\tgoto bad_char;\n\t\t\tparse.last_sym->flags |= ABC_F_GR_END;\n\t\t\tif (dc.n != 0)\n\t\t\t\tsyntax(\"Decoration ignored\", p);\n\t\t\tcurvoice->last_note = last_note_sav;\n\t\t\tmemcpy(&dc, &dc_sav, sizeof dc);\n\t\t\tflags = flags_sav;\n\t\t\tbreak;\n\t\tcase CHAR_DECOS:\n\t\t\tif (p[-1] == '!'\n\t\t\t && char_tb['\\n'] == CHAR_LINEBREAK\n\t\t\t && check_nl(p)) {\n\t\t\t\ts = abc_new(ABC_T_EOLN, NULL);\t/* abc2win EOL */\n\t\t\t\ts->u.eoln.type = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall thru */\n\t\tcase CHAR_DECO:\n\t\t\tif (p[-1] == '.') {\n\t\t\t\tif (*p == '(' || *p == '-') {\n\t\t\t\t\tdot = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tif (*p == '|') {\n//\t\t\t\t\tp = parse_bar(p + 1);\n//\t\t\t\t\tparse.last_sym->u.bar.dotted = 1;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t}\n\t\t\tp = parse_deco(p - 1, &dc, -1);\n\t\t\tbreak;\n\t\tcase CHAR_LINEBREAK:\n\t\t\ts = abc_new(ABC_T_EOLN, NULL);\n//\t\t\ts->u.eoln.type = 0;\n\t\t\tbreak;\n\t\tcase CHAR_NOTE:\n\t\t\tp = parse_note(p - 1, flags);\n\t\t\tflags &= ABC_F_GRACE;\n\t\t\tif (slur && parse.last_sym->u.note.notes[0].len) {\n\t\t\t\tparse.last_sym->u.note.slur_st = slur;\n\t\t\t\tslur = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHAR_SLASH:\t\t/* '/' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (char_tb[(unsigned char) p[-1]] != CHAR_BAR)\n\t\t\t\tgoto bad_char;\n\t\t\tq = p;\n\t\t\twhile (*q == '/')\n\t\t\t\tq++;\n\t\t\tif (char_tb[(unsigned char) *q] != CHAR_BAR)\n\t\t\t\tgoto bad_char;\n\t\t\ts = abc_new(ABC_T_MREP, NULL);\n\t\t\ts->u.bar.type = 0;\n\t\t\ts->u.bar.len = q - p + 1;\n\t\t\tsyntax(\"Non standard measure repeat syntax\", p - 1);\n\t\t\tp = q;\n\t\t\tbreak;\n\t\tcase CHAR_BSLASH:\t\t/* '\\\\' */\n\t\t\tif (*p == '\\0')\n\t\t\t\tbreak;\n\t\t\tsyntax(\"'\\\\' ignored\", p - 1);\n\t\t\tbreak;\n\t\tcase CHAR_OBRA:\t\t\t/* '[' */\n\t\t\tif (*p == '|' || *p == ']' || *p == ':'\n\t\t\t || isdigit((unsigned char) *p) || *p == '\"'\n\t\t\t || *p == ' ') {\n\t\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\t\tgoto bad_char;\n\t\t\t\tp = parse_bar(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p[1] != ':') {\n\t\t\t\tp = parse_note(p - 1, flags); /* chord */\n\t\t\t\tflags &= ABC_F_GRACE;\n\t\t\t\tif (slur && parse.last_sym->u.note.notes[0].len) {\n\t\t\t\t\tparse.last_sym->u.note.slur_st = slur;\n\t\t\t\t\tslur = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* embedded information field */\n#if 0\n/*fixme:OK for [I:staff n], ?? for other headers*/\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n#endif\n\t\t\twhile (p[2] == ' ') {\t\t/* remove the spaces */\n\t\t\t\tp[2] = ':';\n\t\t\t\tp[1] = *p;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tc = ']';\n\t\t\tq = p;\n\t\t\twhile (*p != '\\0' && *p != c)\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0') {\n\t\t\t\tsyntax(\"Escape sequence [..] not closed\", q);\n\t\t\t\tc = '\\0';\n\t\t\t} else {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tparse_info(q);\n\t\t\t*p = c;\n\t\t\tif (c != '\\0')\n\t\t\t\tp++;\n\t\t\tbreak;\n\t\tcase CHAR_BAR:\t\t\t/* '|', ':' or ']' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tp = parse_bar(p);\n\t\t\tbreak;\n\t\tcase CHAR_OPAR:\t\t\t/* '(' */\n\t\t\tif (*p > '0' && *p <= '9') {\n\t\t\t\tint pplet, qplet, rplet;\n\n\t\t\t\tpplet = strtol(p, &q, 10);\n\t\t\t\tp = q;\n\t\t\t\tif ((unsigned) pplet < sizeof qtb / sizeof qtb[0])\n\t\t\t\t\tqplet = qtb[pplet];\n\t\t\t\telse\n\t\t\t\t\tqplet = qtb[0];\n\t\t\t\trplet = pplet;\n\t\t\t\tif (*p == ':') {\n\t\t\t\t\tp++;\n\t\t\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\t\t\tqplet = strtol(p, &q, 10);\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t}\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\t\t\t\trplet = strtol(p, &q, 10);\n\t\t\t\t\t\t\tp = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rplet < 1) {\n\t\t\t\t\tsyntax(\"Invalid 'r' in tuplet\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pplet >= 128 || qplet >= 128 || rplet >= 128) {\n\t\t\t\t\tsyntax(\"Invalid 'p:q:r' in tuplet\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (qplet == 0)\n\t\t\t\t\tqplet = meter % 3 == 0 ? 3 : 2;\n\t\t\t\ts = abc_new(ABC_T_TUPLET, NULL);\n\t\t\t\ts->u.tuplet.p_plet = pplet;\n\t\t\t\ts->u.tuplet.q_plet = qplet;\n\t\t\t\ts->u.tuplet.r_plet = rplet;\n\t\t\t\ts->flags |= flags;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*p == '&') {\n\t\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\t\tgoto bad_char;\n\t\t\t\tp++;\n\t\t\t\tif (vover != 0) {\n\t\t\t\t\tsyntax(\"Nested voice overlay\", p - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\t\ts->u.v_over.type = V_OVER_S;\n\t\t\t\ts->u.v_over.voice = curvoice - voice_tb;\n\t\t\t\tvover = -1;\t\t/* multi-bars */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tslur <<= 4;\n\t\t\tif (p == dot + 1 && dc.n == 0)\n\t\t\t\tslur |= SL_DOTTED;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\'':\n\t\t\t\tslur += SL_ABOVE;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tslur += SL_BELOW;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tslur += SL_AUTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHAR_CPAR:\t\t\t/* ')' */\n\t\t\tswitch (parse.last_sym->abc_type) {\n\t\t\tcase ABC_T_NOTE:\n\t\t\tcase ABC_T_REST:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto bad_char;\n\t\t\t}\n\t\t\tparse.last_sym->u.note.slur_end++;\n\t\t\tbreak;\n\t\tcase CHAR_VOV:\t\t\t/* '&' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (*p != ')'\n\t\t\t || vover == 0) {\t\t/*??*/\n\t\t\t\tif (!curvoice->last_note) {\n\t\t\t\t\tsyntax(\"Bad start of voice overlay\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\t\t/*s->u.v_over.type = V_OVER_V; */\n\t\t\t\tvover_new();\n\t\t\t\ts->u.v_over.voice = curvoice - voice_tb;\n\t\t\t\tif (vover == 0)\n\t\t\t\t\tvover = 1;\t/* single bar */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tvover = 0;\n\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\ts->u.v_over.type = V_OVER_E;\n\t\t\ts->u.v_over.voice = curvoice->mvoice;\n\t\t\tcurvoice->last_note = NULL;\t/* ?? */\n\t\t\tcurvoice = &voice_tb[curvoice->mvoice];\n\t\t\tbreak;\n\t\tcase CHAR_SPAC:\t\t\t/* ' ' and '\\t' */\n\t\t\tflags |= ABC_F_SPACE;\n\t\t\tbreak;\n\t\tcase CHAR_MINUS: {\t\t/* '-' */\n\t\t\tint tie_pos;\n\n\t\t\tif (!curvoice->last_note\n\t\t\t || curvoice->last_note->abc_type != ABC_T_NOTE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (p == dot + 1 && dc.n == 0)\n\t\t\t\ttie_pos = SL_DOTTED;\n\t\t\telse\n\t\t\t\ttie_pos = 0;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\'':\n\t\t\t\ttie_pos += SL_ABOVE;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttie_pos += SL_BELOW;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttie_pos += SL_AUTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i <= curvoice->last_note->nhd; i++) {\n\t\t\t\tif (curvoice->last_note->u.note.notes[i].ti1 == 0)\n\t\t\t\t\tcurvoice->last_note->u.note.notes[i].ti1 = tie_pos;\n\t\t\t\telse if (curvoice->last_note->nhd == 0)\n\t\t\t\t\tsyntax(\"Too many ties\", p);\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase CHAR_BRHY:\t\t\t/* '>' and '<' */\n\t\t\tif (!curvoice->last_note)\n\t\t\t\tgoto bad_char;\n\t\t\ti = 1;\n\t\t\twhile (*p == p[-1]) {\n\t\t\t\ti++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (i > 3) {\n\t\t\t\tsyntax(\"Bad broken rhythm\", p - 1);\n\t\t\t\ti = 3;\n\t\t\t}\n\t\t\tif (p[-1] == '<')\n\t\t\t\ti = -i;\n\t\t\tbroken_rhythm(curvoice->last_note, i);\n\t\t\tcurvoice->last_note->u.note.brhythm = i;\n\t\t\tbreak;\n\t\tcase CHAR_IGN:\t\t\t/* '*' & '`' */\n\t\t\tbreak;\n\t\tdefault:\n\t\tbad_char:\n\t\t\tsyntax((flags & ABC_F_GRACE)\n\t\t\t\t\t? \"Bad character in grace note sequence\"\n\t\t\t\t\t: \"Bad character\",\n\t\t\t\tp - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n/*fixme: may we have grace notes across lines?*/\n\tif (flags & ABC_F_GRACE) {\n\t\tsyntax(\"EOLN in grace note sequence\", p - 1);\n\t\tif (curvoice->last_note)\n\t\t\tcurvoice->last_note->flags |= ABC_F_GR_END;\n\t\tcurvoice->last_note = last_note_sav;\n\t\tmemcpy(&dc, &dc_sav, sizeof dc);\n\t}\n\n\t/* add eoln */\n\ts = abc_new(ABC_T_EOLN, NULL);\n\tif (flags & ABC_F_SPACE)\n\t\ts->flags |= ABC_F_SPACE;\n\tif (p[-1] == '\\\\'\n\t || char_tb['\\n'] != CHAR_LINEBREAK)\n\t\ts->u.eoln.type = 1;\t\t/* no break */\n\n\treturn 0;\n}\n\n/* -- parse a note or a rest -- */\nstatic char *parse_note(char *p,\n\t\t\tint flags)\n{\n\tstruct SYMBOL *s;\n\tchar *q;\n\tint pit = 0, len, acc, nostem, chord, j, m, n;\n\n\tif (flags & ABC_F_GRACE) {\t/* in a grace note sequence */\n\t\ts = abc_new(ABC_T_NOTE, NULL);\n\t} else {\n\t\ts = abc_new(ABC_T_NOTE, gchord);\n\t\tif (gchord)\n\t\t\tgchord = NULL;\n\t}\n\ts->flags |= flags;\n\ts->u.note.notes[0].color = -1;\n\n\tif (!lyric_started) {\n\t\tlyric_started = 1;\n\t\ts->flags |= ABC_F_LYRIC_START;\n\t}\n\tif (*p != 'X' && *p != 'Z'\n\t && !(flags & ABC_F_GRACE)) {\n\t\tif (!deco_start)\n\t\t\tdeco_start = s;\n\t}\n\tchord = 0;\n\n\t/* rest */\n\tswitch (*p) {\n\tcase 'X':\n\t\ts->flags |= ABC_F_INVIS;\n\tcase 'Z':\t\t\t/* multi-rest */\n\t\ts->abc_type = ABC_T_MREST;\n\t\tp++;\n\t\tlen = 1;\n\t\tif (isdigit((unsigned char) *p)) {\n\t\t\tlen = strtol(p, &q, 10);\n\t\t\tif (len == 0 || len > 100) {\n\t\t\t\tsyntax(\"Bad number of measures\", p);\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tp = q;\n\t\t}\n\t\ts->u.bar.type = 0;\n\t\ts->u.bar.len = len;\n\t\tgoto add_deco;\n\tcase 'y':\t\t\t/* space (BarFly) */\n\t\ts->abc_type = ABC_T_REST;\n\t\ts->flags |= ABC_F_INVIS;\n\t\tp++;\n\t\tif (isdigit((unsigned char) *p)\t\t/* number of points */\n\t\t || *p == '-') {\t\t\t/* accept negative offset... */\n\t\t\ts->u.note.notes[0].shhd = strtol(p, &q, 10);\n\t\t\tp = q;\n\t\t} else {\n\t\t\ts->u.note.notes[0].shhd = 10;\t// default\n\t\t}\n\t\tgoto add_deco;\n\tcase 'x':\t\t\t/* invisible rest */\n\t\ts->flags |= ABC_F_INVIS;\n\t\t/* fall thru */\n\tcase 'z':\n\t\ts->abc_type = ABC_T_REST;\n\t\tp = parse_len(p + 1, ulen, &len);\n\t\ts->u.note.notes[0].len = len;\n\t\tgoto do_brhythm;\n\tcase '[':\t\t\t/* '[..]' = chord */\n\t\tchord = 1;\n\t\tp++;\n\t\tbreak;\n\t}\n\n\tq = p;\n\n\t/* get pitch, length and possible accidental */\n\tm = 0;\n\tnostem = 0;\n\tfor (;;) {\n\t\tif (chord) {\n\t\t\tif (m >= MAXHD) {\n\t\t\t\tsyntax(\"Too many notes in chord\", p);\n\t\t\t\tm--;\n\t\t\t}\n\t\t\tn = 0;\n\t\t\tif (*p == '.') {\n\t\t\t\tn = SL_DOTTED;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p == '(') {\n\t\t\t\tp++;\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tn += SL_ABOVE;\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ',':\n\t\t\t\t\tn += SL_BELOW;\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tn += SL_AUTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts->u.note.notes[m].sl1 = (s->u.note.notes[m].sl1 << 3)\n\t\t\t\t\t\t\t+ n;\n\t\t\t}\n\t\t}\n\t\tp = parse_deco(p, &dc, m);\t/* note head decorations */\n\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\tif (*p == '0') {\n\t\t\tnostem = 1;\n\t\t\tp++;\n\t\t}\n\t\tp = parse_len(p, (flags & ABC_F_GRACE) ?\n\t\t\t\t\tBASE_LEN / 8 :\t// for grace note alone\n\t\t\t\t\tulen,\n\t\t\t\t&len);\n\t\ts->u.note.notes[m].pit = pit;\n\t\ts->pits[m] = pit;\n\t\ts->u.note.notes[m].len = len;\n\t\ts->u.note.notes[m].acc = acc;\n\t\ts->u.note.notes[m].color = -1;\n\n\t\tif (chord) {\n\t\t\tfor (;;) {\n\t\t\t\tif (*p == '.') {\n\t\t\t\t\tif (p[1] != '-')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (*p == '-') {\n\t\t\t\t\tswitch (p[1]) {\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_ABOVE;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ',':\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_BELOW;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_AUTO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (*p == ')') {\n\t\t\t\t\ts->u.note.notes[m].sl2++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tif (acc >= 0)\t\t\t/* if no error */\n\t\t\tm++;\t\t\t/* normal case */\n\n\t\tif (!chord)\n\t\t\tbreak;\n\t\tif (*p == ']') {\n\t\t\tp++;\n\t\t\tif (*p == '0') {\n\t\t\t\tnostem = 1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p == '/' || isdigit((unsigned char) *p)) {\n\t\t\t\tp = parse_len(p, ulen, &len);\n\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\ts->u.note.notes[j].len =\n\t\t\t\t\t\tlen * s->u.note.notes[j].len / ulen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (*p == '\\0') {\n\t\t\tsyntax(\"Chord not closed\", q);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nostem)\n\t\ts->flags |= ABC_F_STEMLESS;\n\n\tif (m == 0)\t\t\t/* if no note (or error) */\n\t\tgoto err;\n\n\ts->u.note.microscale = microscale;\n\ts->nhd = m - 1;\n\ndo_brhythm:\n\tif (curvoice->last_note\n\t && curvoice->last_note->u.note.brhythm != 0)\n\t\tbroken_rhythm(s, -curvoice->last_note->u.note.brhythm);\nadd_deco:\n\tif (dc.n > 0) {\n\t\tmemcpy(s->abc_type != ABC_T_MREST ? &s->u.note.dc\n\t\t\t\t: &s->u.bar.dc,\n\t\t\t&dc, sizeof dc);\n\t\tdc.n = 0;\n\t}\n\n\t/* forbid rests in grace note sequences */\n\tif (s->abc_type != ABC_T_NOTE && (flags & ABC_F_GRACE)) {\n\t\tsyntax(\"Not a note in grace note sequence\", p);\n\t\tgoto err;\n\t}\n\tif (s->u.note.notes[0].len > 0) /* if not space */\n\t\tcurvoice->last_note = s;\n\treturn p;\n\nerr:\n\tif ((parse.last_sym = s->abc_prev) == NULL) {\n\t\tparse.first_sym = NULL;\n\t} else {\n\t\ts->abc_prev->abc_next = NULL;\n\t\ts->abc_prev->flags |= (s->flags & ABC_F_ERROR);\n\t}\n\treturn p;\n}\n\n/* -- parse an information field -- */\n/* return 2 on start of new tune */\nstatic int parse_info(char *p)\n{\n\tstruct SYMBOL *s;\n\tchar info_type = *p;\n\tchar *error_txt = NULL;\n\n\ts = abc_new(ABC_T_INFO, p);\n\n\tp += 2;\n\n\tswitch (info_type) {\n\tcase 'd':\n\tcase 's':\n\t\tif (parse.abc_state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\tif (!deco_start) {\n\t\t\terror_txt = \"Erroneous 'd:'/'s:'\";\n\t\t\tbreak;\n\t\t}\n\t\terror_txt = parse_decoline(p);\n\t\tbreak;\n\tcase 'K':\n\t\tif (parse.abc_state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\tparse_key(p, s);\n\t\tif (parse.abc_state == ABC_S_HEAD) {\n\t\t\tint i;\n\n\t\t\tparse.abc_state = ABC_S_TUNE;\n\t\t\tif (ulen == 0)\n\t\t\t\tulen = BASE_LEN / 8;\n\t\t\tfor (i = MAXVOICE; --i >= 0; )\n\t\t\t\tvoice_tb[i].ulen = ulen;\n\t\t\tlyric_started = 0;\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\terror_txt = get_len(p, s);\n\t\tif (s->u.length.base_length > 0)\n\t\t\tulen = s->u.length.base_length;\n\t\tbreak;\n\tcase 'M':\n\t\terror_txt = parse_meter(p, s);\n\t\tbreak;\n\tcase 'Q':\n\t\terror_txt = parse_tempo(p, s);\n\t\tbreak;\n\tcase 'U':\n\t\terror_txt = get_user(p, s);\n\t\tbreak;\n\tcase 'V':\n\t\tif (parse.abc_state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\terror_txt = parse_voice(p, s);\n\t\tbreak;\n\tcase 'X':\n\t\tmemset(voice_tb, 0, sizeof voice_tb);\n\t\tnvoice = 0;\n\t\tcurvoice = voice_tb;\n\t\tparse.abc_state = ABC_S_HEAD;\n\t\tlvlarena(1);\n\t\treturn 2;\n\t}\n\tif (error_txt)\n\t\tsyntax(error_txt, p);\n\treturn 0;\n}\n\n/* -- print a syntax error message -- */\nstatic void syntax(char *msg,\n\t\t   char *q)\n{\n\tint n, len, m1, m2, pp;\n\tint maxcol = 73;\n\n\tseverity = 1;\n\tn = q - abc_line;\n\tlen = strlen(abc_line);\n\tif ((unsigned) n > (unsigned) len)\n\t\tn = -1;\n\tprint_error(msg, n);\n\tif (n < 0) {\n\t\tif (q && *q != '\\0')\n\t\t\tfprintf(stderr, \" (near '%s')\\n\", q);\n\t\treturn;\n\t}\n\tm1 = 0;\n\tm2 = len;\n\tif (m2 > maxcol) {\n\t\tif (n < maxcol) {\n\t\t\tm2 = maxcol;\n\t\t} else {\n\t\t\tm1 = n - 20;\n\t\t\tm2 = m1 + maxcol;\n\t\t\tif (m2 > len)\n\t\t\t\tm2 = len;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"%4d \", linenum);\n\tpp = 6;\n\tif (m1 > 0) {\n\t\tfprintf(stderr, \"...\");\n\t\tpp += 3;\n\t}\n\tfprintf(stderr, \"%.*s\", m2 - m1, &abc_line[m1]);\n\tif (m2 < len)\n\t\tfprintf(stderr, \"...\");\n\tfprintf(stderr, \"\\n\");\n\n\tif ((unsigned) n < 200)\n\t\tfprintf(stderr, \"%*s\\n\", n + pp - m1, \"^\");\n\n\tif (last_sym)\n\t\tlast_sym->flags |= ABC_F_ERROR;\n}\n\n/* -- switch to a new voice overlay -- */\nstatic void vover_new(void)\n{\n\tint voice, mvoice;\n\n\tmvoice = curvoice->mvoice;\n\tfor (voice = curvoice - voice_tb + 1; voice <= nvoice; voice++)\n\t\tif (voice_tb[voice].mvoice == mvoice)\n\t\t\tbreak;\n\tif (voice > nvoice) {\n\t\tif (nvoice >= MAXVOICE) {\n\t\t\tsyntax(\"Too many voices\", 0);\n\t\t\treturn;\n\t\t}\n\t\tnvoice = voice;\n\t\tvoice_tb[voice].id[0] = '&';\n\t\tvoice_tb[voice].mvoice = mvoice;\n\t}\n\tvoice_tb[voice].ulen = curvoice->ulen;\n\tvoice_tb[voice].microscale = curvoice->microscale;\n\tcurvoice = &voice_tb[voice];\n}\n"], "filenames": ["abcparse.c"], "buggy_code_start_loc": [2043], "buggy_code_end_loc": [2513], "fixing_code_start_loc": [2043], "fixing_code_end_loc": [2517], "type": "CWE-787", "message": "Stack-based buffer overflow in the function get_key in parse.c of abcm2ps v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified vectors.", "other": {"cve": {"id": "CVE-2021-32435", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-10T17:42:14.457", "lastModified": "2022-04-25T20:39:39.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the function get_key in parse.c of abcm2ps v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified vectors."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la regi\u00f3n Stack de la memoria en la funci\u00f3n get_key en el archivo parse.c de abcm2ps versi\u00f3n v8.14.11, permite a atacantes remotos causar una denegaci\u00f3n de servicio (DoS) por medio de vectores no especificados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:abcm2ps_project:abcm2ps:8.14.11:*:*:*:*:*:*:*", "matchCriteriaId": "F1915B5A-15EE-4267-9DBE-0827CA3F709E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/leesavide/abcm2ps/commit/3169ace6d63f6f517a64e8df0298f44a490c4a15", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/leesavide/abcm2ps/issues/84", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/04/msg00015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6333SXWMES3K22DBAOAW34G6EU6WIJEY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EVGJH4HMXI3TWMHQJQCG3M7KSXJWJM7R/", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YTF4FXCW22FFB5HNQO3GK3F4FFBLTZKE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/leesavide/abcm2ps/commit/3169ace6d63f6f517a64e8df0298f44a490c4a15"}}