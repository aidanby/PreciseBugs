{"buggy_code": ["/*\n *\tLinux NET3:\tGRE over IP protocol decoder.\n *\n *\tAuthors: Alexey Kuznetsov (kuznet@ms2.inr.ac.ru)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <asm/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/mroute.h>\n#include <linux/init.h>\n#include <linux/in6.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <net/ipip.h>\n#include <net/arp.h>\n#include <net/checksum.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n\n#ifdef CONFIG_IPV6\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#endif\n\n/*\n   Problems & solutions\n   --------------------\n\n   1. The most important issue is detecting local dead loops.\n   They would cause complete host lockup in transmit, which\n   would be \"resolved\" by stack overflow or, if queueing is enabled,\n   with infinite looping in net_bh.\n\n   We cannot track such dead loops during route installation,\n   it is infeasible task. The most general solutions would be\n   to keep skb->encapsulation counter (sort of local ttl),\n   and silently drop packet when it expires. It is the best\n   solution, but it supposes maintaing new variable in ALL\n   skb, even if no tunneling is used.\n\n   Current solution: HARD_TX_LOCK lock breaks dead loops.\n\n\n\n   2. Networking dead loops would not kill routers, but would really\n   kill network. IP hop limit plays role of \"t->recursion\" in this case,\n   if we copy it from packet being encapsulated to upper header.\n   It is very good solution, but it introduces two problems:\n\n   - Routing protocols, using packets with ttl=1 (OSPF, RIP2),\n     do not work over tunnels.\n   - traceroute does not work. I planned to relay ICMP from tunnel,\n     so that this problem would be solved and traceroute output\n     would even more informative. This idea appeared to be wrong:\n     only Linux complies to rfc1812 now (yes, guys, Linux is the only\n     true router now :-)), all routers (at least, in neighbourhood of mine)\n     return only 8 bytes of payload. It is the end.\n\n   Hence, if we want that OSPF worked or traceroute said something reasonable,\n   we should search for another solution.\n\n   One of them is to parse packet trying to detect inner encapsulation\n   made by our node. It is difficult or even impossible, especially,\n   taking into account fragmentation. TO be short, tt is not solution at all.\n\n   Current solution: The solution was UNEXPECTEDLY SIMPLE.\n   We force DF flag on tunnels with preconfigured hop limit,\n   that is ALL. :-) Well, it does not remove the problem completely,\n   but exponential growth of network traffic is changed to linear\n   (branches, that exceed pmtu are pruned) and tunnel mtu\n   fastly degrades to value <68, where looping stops.\n   Yes, it is not good if there exists a router in the loop,\n   which does not force DF, even when encapsulating packets have DF set.\n   But it is not our problem! Nobody could accuse us, we made\n   all that we could make. Even if it is your gated who injected\n   fatal route to network, even if it were you who configured\n   fatal static route: you are innocent. :-)\n\n\n\n   3. Really, ipv4/ipip.c, ipv4/ip_gre.c and ipv6/sit.c contain\n   practically identical code. It would be good to glue them\n   together, but it is not very evident, how to make them modular.\n   sit is integral part of IPv6, ipip and gre are naturally modular.\n   We could extract common parts (hash table, ioctl etc)\n   to a separate module (ip_tunnel.c).\n\n   Alexey Kuznetsov.\n */\n\nstatic struct rtnl_link_ops ipgre_link_ops __read_mostly;\nstatic int ipgre_tunnel_init(struct net_device *dev);\nstatic void ipgre_tunnel_setup(struct net_device *dev);\nstatic int ipgre_tunnel_bind_dev(struct net_device *dev);\n\n/* Fallback tunnel: no source, no destination, no key, no options */\n\n#define HASH_SIZE  16\n\nstatic int ipgre_net_id __read_mostly;\nstruct ipgre_net {\n\tstruct ip_tunnel *tunnels[4][HASH_SIZE];\n\n\tstruct net_device *fb_tunnel_dev;\n};\n\n/* Tunnel hash table */\n\n/*\n   4 hash tables:\n\n   3: (remote,local)\n   2: (remote,*)\n   1: (*,local)\n   0: (*,*)\n\n   We require exact key match i.e. if a key is present in packet\n   it will match only tunnel with the same key; if it is not present,\n   it will match only keyless tunnel.\n\n   All keysless packets, if not matched configured keyless tunnels\n   will match fallback tunnel.\n */\n\n#define HASH(addr) (((__force u32)addr^((__force u32)addr>>4))&0xF)\n\n#define tunnels_r_l\ttunnels[3]\n#define tunnels_r\ttunnels[2]\n#define tunnels_l\ttunnels[1]\n#define tunnels_wc\ttunnels[0]\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ipgre_lock);\n\n#define for_each_ip_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\n/* Given src, dst and key, find appropriate for input tunnel. */\n\nstatic struct ip_tunnel * ipgre_tunnel_lookup(struct net_device *dev,\n\t\t\t\t\t      __be32 remote, __be32 local,\n\t\t\t\t\t      __be32 key, __be16 gre_proto)\n{\n\tstruct net *net = dev_net(dev);\n\tint link = dev->ifindex;\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(key);\n\tstruct ip_tunnel *t, *cand = NULL;\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint dev_type = (gre_proto == htons(ETH_P_TEB)) ?\n\t\t       ARPHRD_ETHER : ARPHRD_IPGRE;\n\tint score, cand_score = 4;\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_r_l[h0 ^ h1]) {\n\t\tif (local != t->parms.iph.saddr ||\n\t\t    remote != t->parms.iph.daddr ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_r[h0 ^ h1]) {\n\t\tif (remote != t->parms.iph.daddr ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_l[h1]) {\n\t\tif ((local != t->parms.iph.saddr &&\n\t\t     (local != t->parms.iph.daddr ||\n\t\t      !ipv4_is_multicast(local))) ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_wc[h1]) {\n\t\tif (t->parms.i_key != key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tif (cand != NULL)\n\t\treturn cand;\n\n\tdev = ign->fb_tunnel_dev;\n\tif (dev->flags & IFF_UP)\n\t\treturn netdev_priv(dev);\n\n\treturn NULL;\n}\n\nstatic struct ip_tunnel **__ipgre_bucket(struct ipgre_net *ign,\n\t\tstruct ip_tunnel_parm *parms)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\t__be32 key = parms->i_key;\n\tunsigned h = HASH(key);\n\tint prio = 0;\n\n\tif (local)\n\t\tprio |= 1;\n\tif (remote && !ipv4_is_multicast(remote)) {\n\t\tprio |= 2;\n\t\th ^= HASH(remote);\n\t}\n\n\treturn &ign->tunnels[prio][h];\n}\n\nstatic inline struct ip_tunnel **ipgre_bucket(struct ipgre_net *ign,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipgre_bucket(ign, &t->parms);\n}\n\nstatic void ipgre_tunnel_link(struct ipgre_net *ign, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp = ipgre_bucket(ign, t);\n\n\tspin_lock_bh(&ipgre_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ipgre_lock);\n}\n\nstatic void ipgre_tunnel_unlink(struct ipgre_net *ign, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp;\n\n\tfor (tp = ipgre_bucket(ign, t); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ipgre_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ipgre_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct ip_tunnel *ipgre_tunnel_find(struct net *net,\n\t\t\t\t\t   struct ip_tunnel_parm *parms,\n\t\t\t\t\t   int type)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\t__be32 key = parms->i_key;\n\tint link = parms->link;\n\tstruct ip_tunnel *t, **tp;\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tfor (tp = __ipgre_bucket(ign, parms); (t = *tp) != NULL; tp = &t->next)\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    key == t->parms.i_key &&\n\t\t    link == t->parms.link &&\n\t\t    type == t->dev->type)\n\t\t\tbreak;\n\n\treturn t;\n}\n\nstatic struct ip_tunnel * ipgre_tunnel_locate(struct net *net,\n\t\tstruct ip_tunnel_parm *parms, int create)\n{\n\tstruct ip_tunnel *t, *nt;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tt = ipgre_tunnel_find(net, parms, ARPHRD_IPGRE);\n\tif (t || !create)\n\t\treturn t;\n\n\tif (parms->name[0])\n\t\tstrlcpy(name, parms->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"gre%%d\");\n\n\tdev = alloc_netdev(sizeof(*t), name, ipgre_tunnel_setup);\n\tif (!dev)\n\t  return NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tnt = netdev_priv(dev);\n\tnt->parms = *parms;\n\tdev->rtnl_link_ops = &ipgre_link_ops;\n\n\tdev->mtu = ipgre_tunnel_bind_dev(dev);\n\n\tif (register_netdevice(dev) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\tipgre_tunnel_link(ign, nt);\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstatic void ipgre_tunnel_uninit(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tipgre_tunnel_unlink(ign, netdev_priv(dev));\n\tdev_put(dev);\n}\n\n\nstatic void ipgre_err(struct sk_buff *skb, u32 info)\n{\n\n/* All the routers (except for Linux) return only\n   8 bytes of packet payload. It means, that precise relaying of\n   ICMP in the real Internet is absolutely infeasible.\n\n   Moreover, Cisco \"wise men\" put GRE key to the third word\n   in GRE header. It makes impossible maintaining even soft state for keyed\n   GRE tunnels with enabled checksum. Tell them \"thank you\".\n\n   Well, I wonder, rfc1812 was written by Cisco employee,\n   what the hell these idiots break standrads established\n   by themself???\n */\n\n\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\t__be16\t     *p = (__be16*)(skb->data+(iph->ihl<<2));\n\tint grehlen = (iph->ihl<<2) + 4;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct ip_tunnel *t;\n\t__be16 flags;\n\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n\t}\n\n\t/* If only 8 bytes returned, keyed message will be dropped here */\n\tif (skb_headlen(skb) < grehlen)\n\t\treturn;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\t/* Impossible event. */\n\t\t\treturn;\n\t\tcase ICMP_FRAG_NEEDED:\n\t\t\t/* Soft state for pmtu is maintained by IP core. */\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* All others are translated to HOST_UNREACH.\n\t\t\t   rfc2003 contains \"deep thoughts\" about NET_UNREACH,\n\t\t\t   I believe they are just ether pollution. --ANK\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\n\trcu_read_lock();\n\tt = ipgre_tunnel_lookup(skb->dev, iph->daddr, iph->saddr,\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n\tif (t == NULL || t->parms.iph.daddr == 0 ||\n\t    ipv4_is_multicast(t->parms.iph.daddr))\n\t\tgoto out;\n\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\trcu_read_unlock();\n\treturn;\n}\n\nstatic inline void ipgre_ecn_decapsulate(struct iphdr *iph, struct sk_buff *skb)\n{\n\tif (INET_ECN_is_ce(iph->tos)) {\n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\tIP_ECN_set_ce(ip_hdr(skb));\n\t\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tIP6_ECN_set_ce(ipv6_hdr(skb));\n\t\t}\n\t}\n}\n\nstatic inline u8\nipgre_ecn_encapsulate(u8 tos, struct iphdr *old_iph, struct sk_buff *skb)\n{\n\tu8 inner = 0;\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tinner = old_iph->tos;\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tinner = ipv6_get_dsfield((struct ipv6hdr *)old_iph);\n\treturn INET_ECN_encapsulate(tos, inner);\n}\n\nstatic int ipgre_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tu8     *h;\n\t__be16    flags;\n\t__sum16   csum = 0;\n\t__be32 key = 0;\n\tu32    seqno = 0;\n\tstruct ip_tunnel *tunnel;\n\tint    offset = 4;\n\t__be16 gre_proto;\n\tunsigned int len;\n\n\tif (!pskb_may_pull(skb, 16))\n\t\tgoto drop_nolock;\n\n\tiph = ip_hdr(skb);\n\th = skb->data;\n\tflags = *(__be16*)h;\n\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_ROUTING|GRE_SEQ|GRE_VERSION)) {\n\t\t/* - Version must be 0.\n\t\t   - We do not support routing headers.\n\t\t */\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\tgoto drop_nolock;\n\n\t\tif (flags&GRE_CSUM) {\n\t\t\tswitch (skb->ip_summed) {\n\t\t\tcase CHECKSUM_COMPLETE:\n\t\t\t\tcsum = csum_fold(skb->csum);\n\t\t\t\tif (!csum)\n\t\t\t\t\tbreak;\n\t\t\t\t/* fall through */\n\t\t\tcase CHECKSUM_NONE:\n\t\t\t\tskb->csum = 0;\n\t\t\t\tcsum = __skb_checksum_complete(skb);\n\t\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t\t}\n\t\t\toffset += 4;\n\t\t}\n\t\tif (flags&GRE_KEY) {\n\t\t\tkey = *(__be32*)(h + offset);\n\t\t\toffset += 4;\n\t\t}\n\t\tif (flags&GRE_SEQ) {\n\t\t\tseqno = ntohl(*(__be32*)(h + offset));\n\t\t\toffset += 4;\n\t\t}\n\t}\n\n\tgre_proto = *(__be16 *)(h + 2);\n\n\trcu_read_lock();\n\tif ((tunnel = ipgre_tunnel_lookup(skb->dev,\n\t\t\t\t\t  iph->saddr, iph->daddr, key,\n\t\t\t\t\t  gre_proto))) {\n\t\tstruct net_device_stats *stats = &tunnel->dev->stats;\n\n\t\tsecpath_reset(skb);\n\n\t\tskb->protocol = gre_proto;\n\t\t/* WCCP version 1 and 2 protocol decoding.\n\t\t * - Change protocol to IP\n\t\t * - When dealing with WCCPv2, Skip extra 4 bytes in GRE header\n\t\t */\n\t\tif (flags == 0 && gre_proto == htons(ETH_P_WCCP)) {\n\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\tif ((*(h + offset) & 0xF0) != 0x40)\n\t\t\t\toffset += 4;\n\t\t}\n\n\t\tskb->mac_header = skb->network_header;\n\t\t__pskb_pull(skb, offset);\n\t\tskb_postpull_rcsum(skb, skb_transport_header(skb), offset);\n\t\tskb->pkt_type = PACKET_HOST;\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t\tif (ipv4_is_multicast(iph->daddr)) {\n\t\t\t/* Looped back packet, drop it! */\n\t\t\tif (skb_rtable(skb)->fl.iif == 0)\n\t\t\t\tgoto drop;\n\t\t\tstats->multicast++;\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\t}\n#endif\n\n\t\tif (((flags&GRE_CSUM) && csum) ||\n\t\t    (!(flags&GRE_CSUM) && tunnel->parms.i_flags&GRE_CSUM)) {\n\t\t\tstats->rx_crc_errors++;\n\t\t\tstats->rx_errors++;\n\t\t\tgoto drop;\n\t\t}\n\t\tif (tunnel->parms.i_flags&GRE_SEQ) {\n\t\t\tif (!(flags&GRE_SEQ) ||\n\t\t\t    (tunnel->i_seqno && (s32)(seqno - tunnel->i_seqno) < 0)) {\n\t\t\t\tstats->rx_fifo_errors++;\n\t\t\t\tstats->rx_errors++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\ttunnel->i_seqno = seqno + 1;\n\t\t}\n\n\t\tlen = skb->len;\n\n\t\t/* Warning: All skb pointers will be invalidated! */\n\t\tif (tunnel->dev->type == ARPHRD_ETHER) {\n\t\t\tif (!pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\t\tstats->rx_length_errors++;\n\t\t\t\tstats->rx_errors++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tiph = ip_hdr(skb);\n\t\t\tskb->protocol = eth_type_trans(skb, tunnel->dev);\n\t\t\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\t\t}\n\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += len;\n\t\tskb->dev = tunnel->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\n\t\tskb_reset_network_header(skb);\n\t\tipgre_ecn_decapsulate(iph, skb);\n\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn(0);\n\t}\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\ndrop:\n\trcu_read_unlock();\ndrop_nolock:\n\tkfree_skb(skb);\n\treturn(0);\n}\n\nstatic netdev_tx_t ipgre_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\n\tstruct iphdr  *old_iph = ip_hdr(skb);\n\tstruct iphdr  *tiph;\n\tu8     tos;\n\t__be16 df;\n\tstruct rtable *rt;     \t\t\t/* Route to the other host */\n\tstruct net_device *tdev;\t\t\t/* Device to other host */\n\tstruct iphdr  *iph;\t\t\t/* Our new IP header */\n\tunsigned int max_headroom;\t\t/* The extra header space needed */\n\tint    gre_hlen;\n\t__be32 dst;\n\tint    mtu;\n\n\tif (dev->type == ARPHRD_ETHER)\n\t\tIPCB(skb)->flags = 0;\n\n\tif (dev->header_ops && dev->type == ARPHRD_IPGRE) {\n\t\tgre_hlen = 0;\n\t\ttiph = (struct iphdr *)skb->data;\n\t} else {\n\t\tgre_hlen = tunnel->hlen;\n\t\ttiph = &tunnel->parms.iph;\n\t}\n\n\tif ((dst = tiph->daddr) == 0) {\n\t\t/* NBMA tunnel */\n\n\t\tif (skb_dst(skb) == NULL) {\n\t\t\tstats->tx_fifo_errors++;\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\trt = skb_rtable(skb);\n\t\t\tif ((dst = rt->rt_gateway) == 0)\n\t\t\t\tgoto tx_error_icmp;\n\t\t}\n#ifdef CONFIG_IPV6\n\t\telse if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tstruct in6_addr *addr6;\n\t\t\tint addr_type;\n\t\t\tstruct neighbour *neigh = skb_dst(skb)->neighbour;\n\n\t\t\tif (neigh == NULL)\n\t\t\t\tgoto tx_error;\n\n\t\t\taddr6 = (struct in6_addr *)&neigh->primary_key;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t\t}\n\n\t\t\tif ((addr_type & IPV6_ADDR_COMPATv4) == 0)\n\t\t\t\tgoto tx_error_icmp;\n\n\t\t\tdst = addr6->s6_addr32[3];\n\t\t}\n#endif\n\t\telse\n\t\t\tgoto tx_error;\n\t}\n\n\ttos = tiph->tos;\n\tif (tos == 1) {\n\t\ttos = 0;\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\ttos = old_iph->tos;\n\t}\n\n\t{\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = dst,\n\t\t\t\t\t\t.saddr = tiph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(tos) } },\n\t\t\t\t    .proto = IPPROTO_GRE };\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\tstats->tx_carrier_errors++;\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n\ttdev = rt->u.dst.dev;\n\n\tif (tdev == dev) {\n\t\tip_rt_put(rt);\n\t\tstats->collisions++;\n\t\tgoto tx_error;\n\t}\n\n\tdf = tiph->frag_off;\n\tif (df)\n\t\tmtu = dst_mtu(&rt->u.dst) - dev->hard_header_len - tunnel->hlen;\n\telse\n\t\tmtu = skb_dst(skb) ? dst_mtu(skb_dst(skb)) : dev->mtu;\n\n\tif (skb_dst(skb))\n\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tdf |= (old_iph->frag_off&htons(IP_DF));\n\n\t\tif ((old_iph->frag_off&htons(IP_DF)) &&\n\t\t    mtu < ntohs(old_iph->tot_len)) {\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#ifdef CONFIG_IPV6\n\telse if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tstruct rt6_info *rt6 = (struct rt6_info *)skb_dst(skb);\n\n\t\tif (rt6 && mtu < dst_mtu(skb_dst(skb)) && mtu >= IPV6_MIN_MTU) {\n\t\t\tif ((tunnel->parms.iph.daddr &&\n\t\t\t     !ipv4_is_multicast(tunnel->parms.iph.daddr)) ||\n\t\t\t    rt6->rt6i_dst.plen == 128) {\n\t\t\t\trt6->rt6i_flags |= RTF_MODIFIED;\n\t\t\t\tskb_dst(skb)->metrics[RTAX_MTU-1] = mtu;\n\t\t\t}\n\t\t}\n\n\t\tif (mtu >= IPV6_MIN_MTU && mtu < skb->len - tunnel->hlen + gre_hlen) {\n\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, dev);\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#endif\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\tmax_headroom = LL_RESERVED_SPACE(tdev) + gre_hlen;\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb)||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\ttxq->tx_dropped++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t\told_iph = ip_hdr(skb);\n\t}\n\n\tskb_reset_transport_header(skb);\n\tskb_push(skb, gre_hlen);\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\n\t\t\t      IPSKB_REROUTED);\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->u.dst);\n\n\t/*\n\t *\tPush down and install the IPIP header.\n\t */\n\n\tiph \t\t\t=\tip_hdr(skb);\n\tiph->version\t\t=\t4;\n\tiph->ihl\t\t=\tsizeof(struct iphdr) >> 2;\n\tiph->frag_off\t\t=\tdf;\n\tiph->protocol\t\t=\tIPPROTO_GRE;\n\tiph->tos\t\t=\tipgre_ecn_encapsulate(tos, old_iph, skb);\n\tiph->daddr\t\t=\trt->rt_dst;\n\tiph->saddr\t\t=\trt->rt_src;\n\n\tif ((iph->ttl = tiph->ttl) == 0) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tiph->ttl = old_iph->ttl;\n#ifdef CONFIG_IPV6\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tiph->ttl = ((struct ipv6hdr *)old_iph)->hop_limit;\n#endif\n\t\telse\n\t\t\tiph->ttl = dst_metric(&rt->u.dst, RTAX_HOPLIMIT);\n\t}\n\n\t((__be16 *)(iph + 1))[0] = tunnel->parms.o_flags;\n\t((__be16 *)(iph + 1))[1] = (dev->type == ARPHRD_ETHER) ?\n\t\t\t\t   htons(ETH_P_TEB) : skb->protocol;\n\n\tif (tunnel->parms.o_flags&(GRE_KEY|GRE_CSUM|GRE_SEQ)) {\n\t\t__be32 *ptr = (__be32*)(((u8*)iph) + tunnel->hlen - 4);\n\n\t\tif (tunnel->parms.o_flags&GRE_SEQ) {\n\t\t\t++tunnel->o_seqno;\n\t\t\t*ptr = htonl(tunnel->o_seqno);\n\t\t\tptr--;\n\t\t}\n\t\tif (tunnel->parms.o_flags&GRE_KEY) {\n\t\t\t*ptr = tunnel->parms.o_key;\n\t\t\tptr--;\n\t\t}\n\t\tif (tunnel->parms.o_flags&GRE_CSUM) {\n\t\t\t*ptr = 0;\n\t\t\t*(__sum16*)ptr = ip_compute_csum((void*)(iph+1), skb->len - sizeof(struct iphdr));\n\t\t}\n\t}\n\n\tnf_reset(skb);\n\n\tIPTUNNEL_XMIT();\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\n\ntx_error:\n\tstats->tx_errors++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ipgre_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct net_device *tdev = NULL;\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\tint hlen = LL_MAX_HEADER;\n\tint mtu = ETH_DATA_LEN;\n\tint addend = sizeof(struct iphdr) + 4;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\t/* Guess output device to choose reasonable mtu and needed_headroom */\n\n\tif (iph->daddr) {\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = iph->daddr,\n\t\t\t\t\t\t.saddr = iph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(iph->tos) } },\n\t\t\t\t    .proto = IPPROTO_GRE };\n\t\tstruct rtable *rt;\n\t\tif (!ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\ttdev = rt->u.dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\n\t\tif (dev->type != ARPHRD_ETHER)\n\t\t\tdev->flags |= IFF_POINTOPOINT;\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\n\n\tif (tdev) {\n\t\thlen = tdev->hard_header_len + tdev->needed_headroom;\n\t\tmtu = tdev->mtu;\n\t}\n\tdev->iflink = tunnel->parms.link;\n\n\t/* Precalculate GRE options length */\n\tif (tunnel->parms.o_flags&(GRE_CSUM|GRE_KEY|GRE_SEQ)) {\n\t\tif (tunnel->parms.o_flags&GRE_CSUM)\n\t\t\taddend += 4;\n\t\tif (tunnel->parms.o_flags&GRE_KEY)\n\t\t\taddend += 4;\n\t\tif (tunnel->parms.o_flags&GRE_SEQ)\n\t\t\taddend += 4;\n\t}\n\tdev->needed_headroom = addend + hlen;\n\tmtu -= dev->hard_header_len + addend;\n\n\tif (mtu < 68)\n\t\tmtu = 68;\n\n\ttunnel->hlen = addend;\n\n\treturn mtu;\n}\n\nstatic int\nipgre_tunnel_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel *t;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tt = NULL;\n\t\tif (dev == ign->fb_tunnel_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ipgre_tunnel_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\t\tmemcpy(&p, &t->parms, sizeof(p));\n\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\tgoto done;\n\n\t\terr = -EINVAL;\n\t\tif (p.iph.version != 4 || p.iph.protocol != IPPROTO_GRE ||\n\t\t    p.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)) ||\n\t\t    ((p.i_flags|p.o_flags)&(GRE_VERSION|GRE_ROUTING)))\n\t\t\tgoto done;\n\t\tif (p.iph.ttl)\n\t\t\tp.iph.frag_off |= htons(IP_DF);\n\n\t\tif (!(p.i_flags&GRE_KEY))\n\t\t\tp.i_key = 0;\n\t\tif (!(p.o_flags&GRE_KEY))\n\t\t\tp.o_key = 0;\n\n\t\tt = ipgre_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\n\n\t\tif (dev != ign->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned nflags = 0;\n\n\t\t\t\tt = netdev_priv(dev);\n\n\t\t\t\tif (ipv4_is_multicast(p.iph.daddr))\n\t\t\t\t\tnflags = IFF_BROADCAST;\n\t\t\t\telse if (p.iph.daddr)\n\t\t\t\t\tnflags = IFF_POINTOPOINT;\n\n\t\t\t\tif ((dev->flags^nflags)&(IFF_POINTOPOINT|IFF_BROADCAST)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tipgre_tunnel_unlink(ign, t);\n\t\t\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\t\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\t\t\tt->parms.i_key = p.i_key;\n\t\t\t\tt->parms.o_key = p.o_key;\n\t\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t\t\tipgre_tunnel_link(ign, t);\n\t\t\t\tnetdev_state_change(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (cmd == SIOCCHGTUNNEL) {\n\t\t\t\tt->parms.iph.ttl = p.iph.ttl;\n\t\t\t\tt->parms.iph.tos = p.iph.tos;\n\t\t\t\tt->parms.iph.frag_off = p.iph.frag_off;\n\t\t\t\tif (t->parms.link != p.link) {\n\t\t\t\t\tt->parms.link = p.link;\n\t\t\t\t\tdev->mtu = ipgre_tunnel_bind_dev(dev);\n\t\t\t\t\tnetdev_state_change(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == ign->fb_tunnel_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\t\tgoto done;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ipgre_tunnel_locate(net, &p, 0)) == NULL)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t == netdev_priv(ign->fb_tunnel_dev))\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int ipgre_tunnel_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tif (new_mtu < 68 ||\n\t    new_mtu > 0xFFF8 - dev->hard_header_len - tunnel->hlen)\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n/* Nice toy. Unfortunately, useless in real life :-)\n   It allows to construct virtual multiprotocol broadcast \"LAN\"\n   over the Internet, provided multicast routing is tuned.\n\n\n   I have no idea was this bicycle invented before me,\n   so that I had to set ARPHRD_IPGRE to a random value.\n   I have an impression, that Cisco could make something similar,\n   but this feature is apparently missing in IOS<=11.2(8).\n\n   I set up 10.66.66/24 and fec0:6666:6666::0/96 as virtual networks\n   with broadcast 224.66.66.66. If you have access to mbone, play with me :-)\n\n   ping -t 255 224.66.66.66\n\n   If nobody answers, mbone does not work.\n\n   ip tunnel add Universe mode gre remote 224.66.66.66 local <Your_real_addr> ttl 255\n   ip addr add 10.66.66.<somewhat>/24 dev Universe\n   ifconfig Universe up\n   ifconfig Universe add fe80::<Your_real_addr>/10\n   ifconfig Universe add fec0:6666:6666::<Your_real_addr>/96\n   ftp 10.66.66.66\n   ...\n   ftp fec0:6666:6666::193.233.7.65\n   ...\n\n */\n\nstatic int ipgre_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type,\n\t\t\tconst void *daddr, const void *saddr, unsigned len)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct iphdr *iph = (struct iphdr *)skb_push(skb, t->hlen);\n\t__be16 *p = (__be16*)(iph+1);\n\n\tmemcpy(iph, &t->parms.iph, sizeof(struct iphdr));\n\tp[0]\t\t= t->parms.o_flags;\n\tp[1]\t\t= htons(type);\n\n\t/*\n\t *\tSet the source hardware address.\n\t */\n\n\tif (saddr)\n\t\tmemcpy(&iph->saddr, saddr, 4);\n\n\tif (daddr) {\n\t\tmemcpy(&iph->daddr, daddr, 4);\n\t\treturn t->hlen;\n\t}\n\tif (iph->daddr && !ipv4_is_multicast(iph->daddr))\n\t\treturn t->hlen;\n\n\treturn -t->hlen;\n}\n\nstatic int ipgre_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tstruct iphdr *iph = (struct iphdr *) skb_mac_header(skb);\n\tmemcpy(haddr, &iph->saddr, 4);\n\treturn 4;\n}\n\nstatic const struct header_ops ipgre_header_ops = {\n\t.create\t= ipgre_header,\n\t.parse\t= ipgre_header_parse,\n};\n\n#ifdef CONFIG_NET_IPGRE_BROADCAST\nstatic int ipgre_open(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr)) {\n\t\tstruct flowi fl = { .oif = t->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = t->parms.iph.daddr,\n\t\t\t\t\t\t.saddr = t->parms.iph.saddr,\n\t\t\t\t\t\t.tos = RT_TOS(t->parms.iph.tos) } },\n\t\t\t\t    .proto = IPPROTO_GRE };\n\t\tstruct rtable *rt;\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tdev = rt->u.dst.dev;\n\t\tip_rt_put(rt);\n\t\tif (__in_dev_get_rtnl(dev) == NULL)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tt->mlink = dev->ifindex;\n\t\tip_mc_inc_group(__in_dev_get_rtnl(dev), t->parms.iph.daddr);\n\t}\n\treturn 0;\n}\n\nstatic int ipgre_close(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {\n\t\tstruct in_device *in_dev;\n\t\tin_dev = inetdev_by_index(dev_net(dev), t->mlink);\n\t\tif (in_dev) {\n\t\t\tip_mc_dec_group(in_dev, t->parms.iph.daddr);\n\t\t\tin_dev_put(in_dev);\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif\n\nstatic const struct net_device_ops ipgre_netdev_ops = {\n\t.ndo_init\t\t= ipgre_tunnel_init,\n\t.ndo_uninit\t\t= ipgre_tunnel_uninit,\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t.ndo_open\t\t= ipgre_open,\n\t.ndo_stop\t\t= ipgre_close,\n#endif\n\t.ndo_start_xmit\t\t= ipgre_tunnel_xmit,\n\t.ndo_do_ioctl\t\t= ipgre_tunnel_ioctl,\n\t.ndo_change_mtu\t\t= ipgre_tunnel_change_mtu,\n};\n\nstatic void ipgre_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipgre_netdev_ops;\n\tdev->destructor \t= free_netdev;\n\n\tdev->type\t\t= ARPHRD_IPGRE;\n\tdev->needed_headroom \t= LL_MAX_HEADER + sizeof(struct iphdr) + 4;\n\tdev->mtu\t\t= ETH_DATA_LEN - sizeof(struct iphdr) - 4;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->iflink\t\t= 0;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n}\n\nstatic int ipgre_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\n\n\tif (iph->daddr) {\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t\tif (ipv4_is_multicast(iph->daddr)) {\n\t\t\tif (!iph->saddr)\n\t\t\t\treturn -EINVAL;\n\t\t\tdev->flags = IFF_BROADCAST;\n\t\t\tdev->header_ops = &ipgre_header_ops;\n\t\t}\n#endif\n\t} else\n\t\tdev->header_ops = &ipgre_header_ops;\n\n\treturn 0;\n}\n\nstatic void ipgre_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tstruct ipgre_net *ign = net_generic(dev_net(dev), ipgre_net_id);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_GRE;\n\tiph->ihl\t\t= 5;\n\ttunnel->hlen\t\t= sizeof(struct iphdr) + 4;\n\n\tdev_hold(dev);\n\tign->tunnels_wc[0]\t= tunnel;\n}\n\n\nstatic const struct net_protocol ipgre_protocol = {\n\t.handler\t=\tipgre_rcv,\n\t.err_handler\t=\tipgre_err,\n\t.netns_ok\t=\t1,\n};\n\nstatic void ipgre_destroy_tunnels(struct ipgre_net *ign, struct list_head *head)\n{\n\tint prio;\n\n\tfor (prio = 0; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\t\tstruct ip_tunnel *t = ign->tunnels[prio][h];\n\n\t\t\twhile (t != NULL) {\n\t\t\t\tunregister_netdevice_queue(t->dev, head);\n\t\t\t\tt = t->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init ipgre_init_net(struct net *net)\n{\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint err;\n\n\tign->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"gre0\",\n\t\t\t\t\t   ipgre_tunnel_setup);\n\tif (!ign->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(ign->fb_tunnel_dev, net);\n\n\tipgre_fb_tunnel_init(ign->fb_tunnel_dev);\n\tign->fb_tunnel_dev->rtnl_link_ops = &ipgre_link_ops;\n\n\tif ((err = register_netdev(ign->fb_tunnel_dev)))\n\t\tgoto err_reg_dev;\n\n\treturn 0;\n\nerr_reg_dev:\n\tfree_netdev(ign->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit ipgre_exit_net(struct net *net)\n{\n\tstruct ipgre_net *ign;\n\tLIST_HEAD(list);\n\n\tign = net_generic(net, ipgre_net_id);\n\trtnl_lock();\n\tipgre_destroy_tunnels(ign, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ipgre_net_ops = {\n\t.init = ipgre_init_net,\n\t.exit = ipgre_exit_net,\n\t.id   = &ipgre_net_id,\n\t.size = sizeof(struct ipgre_net),\n};\n\nstatic int ipgre_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\t__be16 flags;\n\n\tif (!data)\n\t\treturn 0;\n\n\tflags = 0;\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\tif (flags & (GRE_VERSION|GRE_ROUTING))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ipgre_tap_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\t__be32 daddr;\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (!data)\n\t\tgoto out;\n\n\tif (data[IFLA_GRE_REMOTE]) {\n\t\tmemcpy(&daddr, nla_data(data[IFLA_GRE_REMOTE]), 4);\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t}\n\nout:\n\treturn ipgre_tunnel_validate(tb, data);\n}\n\nstatic void ipgre_netlink_parms(struct nlattr *data[],\n\t\t\t\tstruct ip_tunnel_parm *parms)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tparms->iph.protocol = IPPROTO_GRE;\n\n\tif (!data)\n\t\treturn;\n\n\tif (data[IFLA_GRE_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_GRE_LINK]);\n\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tparms->i_flags = nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tparms->o_flags = nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\n\tif (data[IFLA_GRE_IKEY])\n\t\tparms->i_key = nla_get_be32(data[IFLA_GRE_IKEY]);\n\n\tif (data[IFLA_GRE_OKEY])\n\t\tparms->o_key = nla_get_be32(data[IFLA_GRE_OKEY]);\n\n\tif (data[IFLA_GRE_LOCAL])\n\t\tparms->iph.saddr = nla_get_be32(data[IFLA_GRE_LOCAL]);\n\n\tif (data[IFLA_GRE_REMOTE])\n\t\tparms->iph.daddr = nla_get_be32(data[IFLA_GRE_REMOTE]);\n\n\tif (data[IFLA_GRE_TTL])\n\t\tparms->iph.ttl = nla_get_u8(data[IFLA_GRE_TTL]);\n\n\tif (data[IFLA_GRE_TOS])\n\t\tparms->iph.tos = nla_get_u8(data[IFLA_GRE_TOS]);\n\n\tif (!data[IFLA_GRE_PMTUDISC] || nla_get_u8(data[IFLA_GRE_PMTUDISC]))\n\t\tparms->iph.frag_off = htons(IP_DF);\n}\n\nstatic int ipgre_tap_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel;\n\n\ttunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tipgre_tunnel_bind_dev(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ipgre_tap_netdev_ops = {\n\t.ndo_init\t\t= ipgre_tap_init,\n\t.ndo_uninit\t\t= ipgre_tunnel_uninit,\n\t.ndo_start_xmit\t\t= ipgre_tunnel_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= ipgre_tunnel_change_mtu,\n};\n\nstatic void ipgre_tap_setup(struct net_device *dev)\n{\n\n\tether_setup(dev);\n\n\tdev->netdev_ops\t\t= &ipgre_tap_netdev_ops;\n\tdev->destructor \t= free_netdev;\n\n\tdev->iflink\t\t= 0;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic int ipgre_newlink(struct net *src_net, struct net_device *dev, struct nlattr *tb[],\n\t\t\t struct nlattr *data[])\n{\n\tstruct ip_tunnel *nt;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint mtu;\n\tint err;\n\n\tnt = netdev_priv(dev);\n\tipgre_netlink_parms(data, &nt->parms);\n\n\tif (ipgre_tunnel_find(net, &nt->parms, dev->type))\n\t\treturn -EEXIST;\n\n\tif (dev->type == ARPHRD_ETHER && !tb[IFLA_ADDRESS])\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tmtu = ipgre_tunnel_bind_dev(dev);\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = mtu;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto out;\n\n\tdev_hold(dev);\n\tipgre_tunnel_link(ign, nt);\n\nout:\n\treturn err;\n}\n\nstatic int ipgre_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[])\n{\n\tstruct ip_tunnel *t, *nt;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tstruct ip_tunnel_parm p;\n\tint mtu;\n\n\tif (dev == ign->fb_tunnel_dev)\n\t\treturn -EINVAL;\n\n\tnt = netdev_priv(dev);\n\tipgre_netlink_parms(data, &p);\n\n\tt = ipgre_tunnel_locate(net, &p, 0);\n\n\tif (t) {\n\t\tif (t->dev != dev)\n\t\t\treturn -EEXIST;\n\t} else {\n\t\tt = nt;\n\n\t\tif (dev->type != ARPHRD_ETHER) {\n\t\t\tunsigned nflags = 0;\n\n\t\t\tif (ipv4_is_multicast(p.iph.daddr))\n\t\t\t\tnflags = IFF_BROADCAST;\n\t\t\telse if (p.iph.daddr)\n\t\t\t\tnflags = IFF_POINTOPOINT;\n\n\t\t\tif ((dev->flags ^ nflags) &\n\t\t\t    (IFF_POINTOPOINT | IFF_BROADCAST))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tipgre_tunnel_unlink(ign, t);\n\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\tt->parms.i_key = p.i_key;\n\t\tif (dev->type != ARPHRD_ETHER) {\n\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t}\n\t\tipgre_tunnel_link(ign, t);\n\t\tnetdev_state_change(dev);\n\t}\n\n\tt->parms.o_key = p.o_key;\n\tt->parms.iph.ttl = p.iph.ttl;\n\tt->parms.iph.tos = p.iph.tos;\n\tt->parms.iph.frag_off = p.iph.frag_off;\n\n\tif (t->parms.link != p.link) {\n\t\tt->parms.link = p.link;\n\t\tmtu = ipgre_tunnel_bind_dev(dev);\n\t\tif (!tb[IFLA_MTU])\n\t\t\tdev->mtu = mtu;\n\t\tnetdev_state_change(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t ipgre_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t/* IFLA_GRE_LINK */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_IFLAGS */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_GRE_OFLAGS */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_GRE_IKEY */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_OKEY */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_LOCAL */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_REMOTE */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_TTL */\n\t\tnla_total_size(1) +\n\t\t/* IFLA_GRE_TOS */\n\t\tnla_total_size(1) +\n\t\t/* IFLA_GRE_PMTUDISC */\n\t\tnla_total_size(1) +\n\t\t0;\n}\n\nstatic int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm *p = &t->parms;\n\n\tNLA_PUT_U32(skb, IFLA_GRE_LINK, p->link);\n\tNLA_PUT_BE16(skb, IFLA_GRE_IFLAGS, p->i_flags);\n\tNLA_PUT_BE16(skb, IFLA_GRE_OFLAGS, p->o_flags);\n\tNLA_PUT_BE32(skb, IFLA_GRE_IKEY, p->i_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_OKEY, p->o_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_LOCAL, p->iph.saddr);\n\tNLA_PUT_BE32(skb, IFLA_GRE_REMOTE, p->iph.daddr);\n\tNLA_PUT_U8(skb, IFLA_GRE_TTL, p->iph.ttl);\n\tNLA_PUT_U8(skb, IFLA_GRE_TOS, p->iph.tos);\n\tNLA_PUT_U8(skb, IFLA_GRE_PMTUDISC, !!(p->iph.frag_off & htons(IP_DF)));\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ipgre_policy[IFLA_GRE_MAX + 1] = {\n\t[IFLA_GRE_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_IFLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_OFLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_IKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_OKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_LOCAL]\t= { .len = FIELD_SIZEOF(struct iphdr, saddr) },\n\t[IFLA_GRE_REMOTE]\t= { .len = FIELD_SIZEOF(struct iphdr, daddr) },\n\t[IFLA_GRE_TTL]\t\t= { .type = NLA_U8 },\n\t[IFLA_GRE_TOS]\t\t= { .type = NLA_U8 },\n\t[IFLA_GRE_PMTUDISC]\t= { .type = NLA_U8 },\n};\n\nstatic struct rtnl_link_ops ipgre_link_ops __read_mostly = {\n\t.kind\t\t= \"gre\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ipgre_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipgre_tunnel_setup,\n\t.validate\t= ipgre_tunnel_validate,\n\t.newlink\t= ipgre_newlink,\n\t.changelink\t= ipgre_changelink,\n\t.get_size\t= ipgre_get_size,\n\t.fill_info\t= ipgre_fill_info,\n};\n\nstatic struct rtnl_link_ops ipgre_tap_ops __read_mostly = {\n\t.kind\t\t= \"gretap\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ipgre_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipgre_tap_setup,\n\t.validate\t= ipgre_tap_validate,\n\t.newlink\t= ipgre_newlink,\n\t.changelink\t= ipgre_changelink,\n\t.get_size\t= ipgre_get_size,\n\t.fill_info\t= ipgre_fill_info,\n};\n\n/*\n *\tAnd now the modules code and kernel interface.\n */\n\nstatic int __init ipgre_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\nout:\n\treturn err;\n\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}\n\nstatic void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}\n\nmodule_init(ipgre_init);\nmodule_exit(ipgre_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"gre\");\nMODULE_ALIAS_RTNL_LINK(\"gretap\");\n"], "fixing_code": ["/*\n *\tLinux NET3:\tGRE over IP protocol decoder.\n *\n *\tAuthors: Alexey Kuznetsov (kuznet@ms2.inr.ac.ru)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <asm/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/mroute.h>\n#include <linux/init.h>\n#include <linux/in6.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <net/ipip.h>\n#include <net/arp.h>\n#include <net/checksum.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n\n#ifdef CONFIG_IPV6\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#endif\n\n/*\n   Problems & solutions\n   --------------------\n\n   1. The most important issue is detecting local dead loops.\n   They would cause complete host lockup in transmit, which\n   would be \"resolved\" by stack overflow or, if queueing is enabled,\n   with infinite looping in net_bh.\n\n   We cannot track such dead loops during route installation,\n   it is infeasible task. The most general solutions would be\n   to keep skb->encapsulation counter (sort of local ttl),\n   and silently drop packet when it expires. It is the best\n   solution, but it supposes maintaing new variable in ALL\n   skb, even if no tunneling is used.\n\n   Current solution: HARD_TX_LOCK lock breaks dead loops.\n\n\n\n   2. Networking dead loops would not kill routers, but would really\n   kill network. IP hop limit plays role of \"t->recursion\" in this case,\n   if we copy it from packet being encapsulated to upper header.\n   It is very good solution, but it introduces two problems:\n\n   - Routing protocols, using packets with ttl=1 (OSPF, RIP2),\n     do not work over tunnels.\n   - traceroute does not work. I planned to relay ICMP from tunnel,\n     so that this problem would be solved and traceroute output\n     would even more informative. This idea appeared to be wrong:\n     only Linux complies to rfc1812 now (yes, guys, Linux is the only\n     true router now :-)), all routers (at least, in neighbourhood of mine)\n     return only 8 bytes of payload. It is the end.\n\n   Hence, if we want that OSPF worked or traceroute said something reasonable,\n   we should search for another solution.\n\n   One of them is to parse packet trying to detect inner encapsulation\n   made by our node. It is difficult or even impossible, especially,\n   taking into account fragmentation. TO be short, tt is not solution at all.\n\n   Current solution: The solution was UNEXPECTEDLY SIMPLE.\n   We force DF flag on tunnels with preconfigured hop limit,\n   that is ALL. :-) Well, it does not remove the problem completely,\n   but exponential growth of network traffic is changed to linear\n   (branches, that exceed pmtu are pruned) and tunnel mtu\n   fastly degrades to value <68, where looping stops.\n   Yes, it is not good if there exists a router in the loop,\n   which does not force DF, even when encapsulating packets have DF set.\n   But it is not our problem! Nobody could accuse us, we made\n   all that we could make. Even if it is your gated who injected\n   fatal route to network, even if it were you who configured\n   fatal static route: you are innocent. :-)\n\n\n\n   3. Really, ipv4/ipip.c, ipv4/ip_gre.c and ipv6/sit.c contain\n   practically identical code. It would be good to glue them\n   together, but it is not very evident, how to make them modular.\n   sit is integral part of IPv6, ipip and gre are naturally modular.\n   We could extract common parts (hash table, ioctl etc)\n   to a separate module (ip_tunnel.c).\n\n   Alexey Kuznetsov.\n */\n\nstatic struct rtnl_link_ops ipgre_link_ops __read_mostly;\nstatic int ipgre_tunnel_init(struct net_device *dev);\nstatic void ipgre_tunnel_setup(struct net_device *dev);\nstatic int ipgre_tunnel_bind_dev(struct net_device *dev);\n\n/* Fallback tunnel: no source, no destination, no key, no options */\n\n#define HASH_SIZE  16\n\nstatic int ipgre_net_id __read_mostly;\nstruct ipgre_net {\n\tstruct ip_tunnel *tunnels[4][HASH_SIZE];\n\n\tstruct net_device *fb_tunnel_dev;\n};\n\n/* Tunnel hash table */\n\n/*\n   4 hash tables:\n\n   3: (remote,local)\n   2: (remote,*)\n   1: (*,local)\n   0: (*,*)\n\n   We require exact key match i.e. if a key is present in packet\n   it will match only tunnel with the same key; if it is not present,\n   it will match only keyless tunnel.\n\n   All keysless packets, if not matched configured keyless tunnels\n   will match fallback tunnel.\n */\n\n#define HASH(addr) (((__force u32)addr^((__force u32)addr>>4))&0xF)\n\n#define tunnels_r_l\ttunnels[3]\n#define tunnels_r\ttunnels[2]\n#define tunnels_l\ttunnels[1]\n#define tunnels_wc\ttunnels[0]\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ipgre_lock);\n\n#define for_each_ip_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\n/* Given src, dst and key, find appropriate for input tunnel. */\n\nstatic struct ip_tunnel * ipgre_tunnel_lookup(struct net_device *dev,\n\t\t\t\t\t      __be32 remote, __be32 local,\n\t\t\t\t\t      __be32 key, __be16 gre_proto)\n{\n\tstruct net *net = dev_net(dev);\n\tint link = dev->ifindex;\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(key);\n\tstruct ip_tunnel *t, *cand = NULL;\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint dev_type = (gre_proto == htons(ETH_P_TEB)) ?\n\t\t       ARPHRD_ETHER : ARPHRD_IPGRE;\n\tint score, cand_score = 4;\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_r_l[h0 ^ h1]) {\n\t\tif (local != t->parms.iph.saddr ||\n\t\t    remote != t->parms.iph.daddr ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_r[h0 ^ h1]) {\n\t\tif (remote != t->parms.iph.daddr ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_l[h1]) {\n\t\tif ((local != t->parms.iph.saddr &&\n\t\t     (local != t->parms.iph.daddr ||\n\t\t      !ipv4_is_multicast(local))) ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_wc[h1]) {\n\t\tif (t->parms.i_key != key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tif (cand != NULL)\n\t\treturn cand;\n\n\tdev = ign->fb_tunnel_dev;\n\tif (dev->flags & IFF_UP)\n\t\treturn netdev_priv(dev);\n\n\treturn NULL;\n}\n\nstatic struct ip_tunnel **__ipgre_bucket(struct ipgre_net *ign,\n\t\tstruct ip_tunnel_parm *parms)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\t__be32 key = parms->i_key;\n\tunsigned h = HASH(key);\n\tint prio = 0;\n\n\tif (local)\n\t\tprio |= 1;\n\tif (remote && !ipv4_is_multicast(remote)) {\n\t\tprio |= 2;\n\t\th ^= HASH(remote);\n\t}\n\n\treturn &ign->tunnels[prio][h];\n}\n\nstatic inline struct ip_tunnel **ipgre_bucket(struct ipgre_net *ign,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipgre_bucket(ign, &t->parms);\n}\n\nstatic void ipgre_tunnel_link(struct ipgre_net *ign, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp = ipgre_bucket(ign, t);\n\n\tspin_lock_bh(&ipgre_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ipgre_lock);\n}\n\nstatic void ipgre_tunnel_unlink(struct ipgre_net *ign, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp;\n\n\tfor (tp = ipgre_bucket(ign, t); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ipgre_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ipgre_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct ip_tunnel *ipgre_tunnel_find(struct net *net,\n\t\t\t\t\t   struct ip_tunnel_parm *parms,\n\t\t\t\t\t   int type)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\t__be32 key = parms->i_key;\n\tint link = parms->link;\n\tstruct ip_tunnel *t, **tp;\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tfor (tp = __ipgre_bucket(ign, parms); (t = *tp) != NULL; tp = &t->next)\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    key == t->parms.i_key &&\n\t\t    link == t->parms.link &&\n\t\t    type == t->dev->type)\n\t\t\tbreak;\n\n\treturn t;\n}\n\nstatic struct ip_tunnel * ipgre_tunnel_locate(struct net *net,\n\t\tstruct ip_tunnel_parm *parms, int create)\n{\n\tstruct ip_tunnel *t, *nt;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tt = ipgre_tunnel_find(net, parms, ARPHRD_IPGRE);\n\tif (t || !create)\n\t\treturn t;\n\n\tif (parms->name[0])\n\t\tstrlcpy(name, parms->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"gre%%d\");\n\n\tdev = alloc_netdev(sizeof(*t), name, ipgre_tunnel_setup);\n\tif (!dev)\n\t  return NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tnt = netdev_priv(dev);\n\tnt->parms = *parms;\n\tdev->rtnl_link_ops = &ipgre_link_ops;\n\n\tdev->mtu = ipgre_tunnel_bind_dev(dev);\n\n\tif (register_netdevice(dev) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\tipgre_tunnel_link(ign, nt);\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstatic void ipgre_tunnel_uninit(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tipgre_tunnel_unlink(ign, netdev_priv(dev));\n\tdev_put(dev);\n}\n\n\nstatic void ipgre_err(struct sk_buff *skb, u32 info)\n{\n\n/* All the routers (except for Linux) return only\n   8 bytes of packet payload. It means, that precise relaying of\n   ICMP in the real Internet is absolutely infeasible.\n\n   Moreover, Cisco \"wise men\" put GRE key to the third word\n   in GRE header. It makes impossible maintaining even soft state for keyed\n   GRE tunnels with enabled checksum. Tell them \"thank you\".\n\n   Well, I wonder, rfc1812 was written by Cisco employee,\n   what the hell these idiots break standrads established\n   by themself???\n */\n\n\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\t__be16\t     *p = (__be16*)(skb->data+(iph->ihl<<2));\n\tint grehlen = (iph->ihl<<2) + 4;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct ip_tunnel *t;\n\t__be16 flags;\n\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n\t}\n\n\t/* If only 8 bytes returned, keyed message will be dropped here */\n\tif (skb_headlen(skb) < grehlen)\n\t\treturn;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\t/* Impossible event. */\n\t\t\treturn;\n\t\tcase ICMP_FRAG_NEEDED:\n\t\t\t/* Soft state for pmtu is maintained by IP core. */\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* All others are translated to HOST_UNREACH.\n\t\t\t   rfc2003 contains \"deep thoughts\" about NET_UNREACH,\n\t\t\t   I believe they are just ether pollution. --ANK\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\n\trcu_read_lock();\n\tt = ipgre_tunnel_lookup(skb->dev, iph->daddr, iph->saddr,\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n\tif (t == NULL || t->parms.iph.daddr == 0 ||\n\t    ipv4_is_multicast(t->parms.iph.daddr))\n\t\tgoto out;\n\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\trcu_read_unlock();\n\treturn;\n}\n\nstatic inline void ipgre_ecn_decapsulate(struct iphdr *iph, struct sk_buff *skb)\n{\n\tif (INET_ECN_is_ce(iph->tos)) {\n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\tIP_ECN_set_ce(ip_hdr(skb));\n\t\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tIP6_ECN_set_ce(ipv6_hdr(skb));\n\t\t}\n\t}\n}\n\nstatic inline u8\nipgre_ecn_encapsulate(u8 tos, struct iphdr *old_iph, struct sk_buff *skb)\n{\n\tu8 inner = 0;\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tinner = old_iph->tos;\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tinner = ipv6_get_dsfield((struct ipv6hdr *)old_iph);\n\treturn INET_ECN_encapsulate(tos, inner);\n}\n\nstatic int ipgre_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tu8     *h;\n\t__be16    flags;\n\t__sum16   csum = 0;\n\t__be32 key = 0;\n\tu32    seqno = 0;\n\tstruct ip_tunnel *tunnel;\n\tint    offset = 4;\n\t__be16 gre_proto;\n\tunsigned int len;\n\n\tif (!pskb_may_pull(skb, 16))\n\t\tgoto drop_nolock;\n\n\tiph = ip_hdr(skb);\n\th = skb->data;\n\tflags = *(__be16*)h;\n\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_ROUTING|GRE_SEQ|GRE_VERSION)) {\n\t\t/* - Version must be 0.\n\t\t   - We do not support routing headers.\n\t\t */\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\tgoto drop_nolock;\n\n\t\tif (flags&GRE_CSUM) {\n\t\t\tswitch (skb->ip_summed) {\n\t\t\tcase CHECKSUM_COMPLETE:\n\t\t\t\tcsum = csum_fold(skb->csum);\n\t\t\t\tif (!csum)\n\t\t\t\t\tbreak;\n\t\t\t\t/* fall through */\n\t\t\tcase CHECKSUM_NONE:\n\t\t\t\tskb->csum = 0;\n\t\t\t\tcsum = __skb_checksum_complete(skb);\n\t\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t\t}\n\t\t\toffset += 4;\n\t\t}\n\t\tif (flags&GRE_KEY) {\n\t\t\tkey = *(__be32*)(h + offset);\n\t\t\toffset += 4;\n\t\t}\n\t\tif (flags&GRE_SEQ) {\n\t\t\tseqno = ntohl(*(__be32*)(h + offset));\n\t\t\toffset += 4;\n\t\t}\n\t}\n\n\tgre_proto = *(__be16 *)(h + 2);\n\n\trcu_read_lock();\n\tif ((tunnel = ipgre_tunnel_lookup(skb->dev,\n\t\t\t\t\t  iph->saddr, iph->daddr, key,\n\t\t\t\t\t  gre_proto))) {\n\t\tstruct net_device_stats *stats = &tunnel->dev->stats;\n\n\t\tsecpath_reset(skb);\n\n\t\tskb->protocol = gre_proto;\n\t\t/* WCCP version 1 and 2 protocol decoding.\n\t\t * - Change protocol to IP\n\t\t * - When dealing with WCCPv2, Skip extra 4 bytes in GRE header\n\t\t */\n\t\tif (flags == 0 && gre_proto == htons(ETH_P_WCCP)) {\n\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\tif ((*(h + offset) & 0xF0) != 0x40)\n\t\t\t\toffset += 4;\n\t\t}\n\n\t\tskb->mac_header = skb->network_header;\n\t\t__pskb_pull(skb, offset);\n\t\tskb_postpull_rcsum(skb, skb_transport_header(skb), offset);\n\t\tskb->pkt_type = PACKET_HOST;\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t\tif (ipv4_is_multicast(iph->daddr)) {\n\t\t\t/* Looped back packet, drop it! */\n\t\t\tif (skb_rtable(skb)->fl.iif == 0)\n\t\t\t\tgoto drop;\n\t\t\tstats->multicast++;\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\t}\n#endif\n\n\t\tif (((flags&GRE_CSUM) && csum) ||\n\t\t    (!(flags&GRE_CSUM) && tunnel->parms.i_flags&GRE_CSUM)) {\n\t\t\tstats->rx_crc_errors++;\n\t\t\tstats->rx_errors++;\n\t\t\tgoto drop;\n\t\t}\n\t\tif (tunnel->parms.i_flags&GRE_SEQ) {\n\t\t\tif (!(flags&GRE_SEQ) ||\n\t\t\t    (tunnel->i_seqno && (s32)(seqno - tunnel->i_seqno) < 0)) {\n\t\t\t\tstats->rx_fifo_errors++;\n\t\t\t\tstats->rx_errors++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\ttunnel->i_seqno = seqno + 1;\n\t\t}\n\n\t\tlen = skb->len;\n\n\t\t/* Warning: All skb pointers will be invalidated! */\n\t\tif (tunnel->dev->type == ARPHRD_ETHER) {\n\t\t\tif (!pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\t\tstats->rx_length_errors++;\n\t\t\t\tstats->rx_errors++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tiph = ip_hdr(skb);\n\t\t\tskb->protocol = eth_type_trans(skb, tunnel->dev);\n\t\t\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\t\t}\n\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += len;\n\t\tskb->dev = tunnel->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\n\t\tskb_reset_network_header(skb);\n\t\tipgre_ecn_decapsulate(iph, skb);\n\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn(0);\n\t}\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\ndrop:\n\trcu_read_unlock();\ndrop_nolock:\n\tkfree_skb(skb);\n\treturn(0);\n}\n\nstatic netdev_tx_t ipgre_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\n\tstruct iphdr  *old_iph = ip_hdr(skb);\n\tstruct iphdr  *tiph;\n\tu8     tos;\n\t__be16 df;\n\tstruct rtable *rt;     \t\t\t/* Route to the other host */\n\tstruct net_device *tdev;\t\t\t/* Device to other host */\n\tstruct iphdr  *iph;\t\t\t/* Our new IP header */\n\tunsigned int max_headroom;\t\t/* The extra header space needed */\n\tint    gre_hlen;\n\t__be32 dst;\n\tint    mtu;\n\n\tif (dev->type == ARPHRD_ETHER)\n\t\tIPCB(skb)->flags = 0;\n\n\tif (dev->header_ops && dev->type == ARPHRD_IPGRE) {\n\t\tgre_hlen = 0;\n\t\ttiph = (struct iphdr *)skb->data;\n\t} else {\n\t\tgre_hlen = tunnel->hlen;\n\t\ttiph = &tunnel->parms.iph;\n\t}\n\n\tif ((dst = tiph->daddr) == 0) {\n\t\t/* NBMA tunnel */\n\n\t\tif (skb_dst(skb) == NULL) {\n\t\t\tstats->tx_fifo_errors++;\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\trt = skb_rtable(skb);\n\t\t\tif ((dst = rt->rt_gateway) == 0)\n\t\t\t\tgoto tx_error_icmp;\n\t\t}\n#ifdef CONFIG_IPV6\n\t\telse if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tstruct in6_addr *addr6;\n\t\t\tint addr_type;\n\t\t\tstruct neighbour *neigh = skb_dst(skb)->neighbour;\n\n\t\t\tif (neigh == NULL)\n\t\t\t\tgoto tx_error;\n\n\t\t\taddr6 = (struct in6_addr *)&neigh->primary_key;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t\t}\n\n\t\t\tif ((addr_type & IPV6_ADDR_COMPATv4) == 0)\n\t\t\t\tgoto tx_error_icmp;\n\n\t\t\tdst = addr6->s6_addr32[3];\n\t\t}\n#endif\n\t\telse\n\t\t\tgoto tx_error;\n\t}\n\n\ttos = tiph->tos;\n\tif (tos == 1) {\n\t\ttos = 0;\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\ttos = old_iph->tos;\n\t}\n\n\t{\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = dst,\n\t\t\t\t\t\t.saddr = tiph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(tos) } },\n\t\t\t\t    .proto = IPPROTO_GRE };\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\tstats->tx_carrier_errors++;\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n\ttdev = rt->u.dst.dev;\n\n\tif (tdev == dev) {\n\t\tip_rt_put(rt);\n\t\tstats->collisions++;\n\t\tgoto tx_error;\n\t}\n\n\tdf = tiph->frag_off;\n\tif (df)\n\t\tmtu = dst_mtu(&rt->u.dst) - dev->hard_header_len - tunnel->hlen;\n\telse\n\t\tmtu = skb_dst(skb) ? dst_mtu(skb_dst(skb)) : dev->mtu;\n\n\tif (skb_dst(skb))\n\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tdf |= (old_iph->frag_off&htons(IP_DF));\n\n\t\tif ((old_iph->frag_off&htons(IP_DF)) &&\n\t\t    mtu < ntohs(old_iph->tot_len)) {\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#ifdef CONFIG_IPV6\n\telse if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tstruct rt6_info *rt6 = (struct rt6_info *)skb_dst(skb);\n\n\t\tif (rt6 && mtu < dst_mtu(skb_dst(skb)) && mtu >= IPV6_MIN_MTU) {\n\t\t\tif ((tunnel->parms.iph.daddr &&\n\t\t\t     !ipv4_is_multicast(tunnel->parms.iph.daddr)) ||\n\t\t\t    rt6->rt6i_dst.plen == 128) {\n\t\t\t\trt6->rt6i_flags |= RTF_MODIFIED;\n\t\t\t\tskb_dst(skb)->metrics[RTAX_MTU-1] = mtu;\n\t\t\t}\n\t\t}\n\n\t\tif (mtu >= IPV6_MIN_MTU && mtu < skb->len - tunnel->hlen + gre_hlen) {\n\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, dev);\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#endif\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\tmax_headroom = LL_RESERVED_SPACE(tdev) + gre_hlen;\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb)||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\ttxq->tx_dropped++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t\told_iph = ip_hdr(skb);\n\t}\n\n\tskb_reset_transport_header(skb);\n\tskb_push(skb, gre_hlen);\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\n\t\t\t      IPSKB_REROUTED);\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->u.dst);\n\n\t/*\n\t *\tPush down and install the IPIP header.\n\t */\n\n\tiph \t\t\t=\tip_hdr(skb);\n\tiph->version\t\t=\t4;\n\tiph->ihl\t\t=\tsizeof(struct iphdr) >> 2;\n\tiph->frag_off\t\t=\tdf;\n\tiph->protocol\t\t=\tIPPROTO_GRE;\n\tiph->tos\t\t=\tipgre_ecn_encapsulate(tos, old_iph, skb);\n\tiph->daddr\t\t=\trt->rt_dst;\n\tiph->saddr\t\t=\trt->rt_src;\n\n\tif ((iph->ttl = tiph->ttl) == 0) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tiph->ttl = old_iph->ttl;\n#ifdef CONFIG_IPV6\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tiph->ttl = ((struct ipv6hdr *)old_iph)->hop_limit;\n#endif\n\t\telse\n\t\t\tiph->ttl = dst_metric(&rt->u.dst, RTAX_HOPLIMIT);\n\t}\n\n\t((__be16 *)(iph + 1))[0] = tunnel->parms.o_flags;\n\t((__be16 *)(iph + 1))[1] = (dev->type == ARPHRD_ETHER) ?\n\t\t\t\t   htons(ETH_P_TEB) : skb->protocol;\n\n\tif (tunnel->parms.o_flags&(GRE_KEY|GRE_CSUM|GRE_SEQ)) {\n\t\t__be32 *ptr = (__be32*)(((u8*)iph) + tunnel->hlen - 4);\n\n\t\tif (tunnel->parms.o_flags&GRE_SEQ) {\n\t\t\t++tunnel->o_seqno;\n\t\t\t*ptr = htonl(tunnel->o_seqno);\n\t\t\tptr--;\n\t\t}\n\t\tif (tunnel->parms.o_flags&GRE_KEY) {\n\t\t\t*ptr = tunnel->parms.o_key;\n\t\t\tptr--;\n\t\t}\n\t\tif (tunnel->parms.o_flags&GRE_CSUM) {\n\t\t\t*ptr = 0;\n\t\t\t*(__sum16*)ptr = ip_compute_csum((void*)(iph+1), skb->len - sizeof(struct iphdr));\n\t\t}\n\t}\n\n\tnf_reset(skb);\n\n\tIPTUNNEL_XMIT();\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\n\ntx_error:\n\tstats->tx_errors++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ipgre_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct net_device *tdev = NULL;\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\tint hlen = LL_MAX_HEADER;\n\tint mtu = ETH_DATA_LEN;\n\tint addend = sizeof(struct iphdr) + 4;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\t/* Guess output device to choose reasonable mtu and needed_headroom */\n\n\tif (iph->daddr) {\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = iph->daddr,\n\t\t\t\t\t\t.saddr = iph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(iph->tos) } },\n\t\t\t\t    .proto = IPPROTO_GRE };\n\t\tstruct rtable *rt;\n\t\tif (!ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\ttdev = rt->u.dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\n\t\tif (dev->type != ARPHRD_ETHER)\n\t\t\tdev->flags |= IFF_POINTOPOINT;\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\n\n\tif (tdev) {\n\t\thlen = tdev->hard_header_len + tdev->needed_headroom;\n\t\tmtu = tdev->mtu;\n\t}\n\tdev->iflink = tunnel->parms.link;\n\n\t/* Precalculate GRE options length */\n\tif (tunnel->parms.o_flags&(GRE_CSUM|GRE_KEY|GRE_SEQ)) {\n\t\tif (tunnel->parms.o_flags&GRE_CSUM)\n\t\t\taddend += 4;\n\t\tif (tunnel->parms.o_flags&GRE_KEY)\n\t\t\taddend += 4;\n\t\tif (tunnel->parms.o_flags&GRE_SEQ)\n\t\t\taddend += 4;\n\t}\n\tdev->needed_headroom = addend + hlen;\n\tmtu -= dev->hard_header_len + addend;\n\n\tif (mtu < 68)\n\t\tmtu = 68;\n\n\ttunnel->hlen = addend;\n\n\treturn mtu;\n}\n\nstatic int\nipgre_tunnel_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel *t;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tt = NULL;\n\t\tif (dev == ign->fb_tunnel_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ipgre_tunnel_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\t\tmemcpy(&p, &t->parms, sizeof(p));\n\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\tgoto done;\n\n\t\terr = -EINVAL;\n\t\tif (p.iph.version != 4 || p.iph.protocol != IPPROTO_GRE ||\n\t\t    p.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)) ||\n\t\t    ((p.i_flags|p.o_flags)&(GRE_VERSION|GRE_ROUTING)))\n\t\t\tgoto done;\n\t\tif (p.iph.ttl)\n\t\t\tp.iph.frag_off |= htons(IP_DF);\n\n\t\tif (!(p.i_flags&GRE_KEY))\n\t\t\tp.i_key = 0;\n\t\tif (!(p.o_flags&GRE_KEY))\n\t\t\tp.o_key = 0;\n\n\t\tt = ipgre_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\n\n\t\tif (dev != ign->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned nflags = 0;\n\n\t\t\t\tt = netdev_priv(dev);\n\n\t\t\t\tif (ipv4_is_multicast(p.iph.daddr))\n\t\t\t\t\tnflags = IFF_BROADCAST;\n\t\t\t\telse if (p.iph.daddr)\n\t\t\t\t\tnflags = IFF_POINTOPOINT;\n\n\t\t\t\tif ((dev->flags^nflags)&(IFF_POINTOPOINT|IFF_BROADCAST)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tipgre_tunnel_unlink(ign, t);\n\t\t\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\t\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\t\t\tt->parms.i_key = p.i_key;\n\t\t\t\tt->parms.o_key = p.o_key;\n\t\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t\t\tipgre_tunnel_link(ign, t);\n\t\t\t\tnetdev_state_change(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (cmd == SIOCCHGTUNNEL) {\n\t\t\t\tt->parms.iph.ttl = p.iph.ttl;\n\t\t\t\tt->parms.iph.tos = p.iph.tos;\n\t\t\t\tt->parms.iph.frag_off = p.iph.frag_off;\n\t\t\t\tif (t->parms.link != p.link) {\n\t\t\t\t\tt->parms.link = p.link;\n\t\t\t\t\tdev->mtu = ipgre_tunnel_bind_dev(dev);\n\t\t\t\t\tnetdev_state_change(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == ign->fb_tunnel_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\t\tgoto done;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ipgre_tunnel_locate(net, &p, 0)) == NULL)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t == netdev_priv(ign->fb_tunnel_dev))\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int ipgre_tunnel_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tif (new_mtu < 68 ||\n\t    new_mtu > 0xFFF8 - dev->hard_header_len - tunnel->hlen)\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n/* Nice toy. Unfortunately, useless in real life :-)\n   It allows to construct virtual multiprotocol broadcast \"LAN\"\n   over the Internet, provided multicast routing is tuned.\n\n\n   I have no idea was this bicycle invented before me,\n   so that I had to set ARPHRD_IPGRE to a random value.\n   I have an impression, that Cisco could make something similar,\n   but this feature is apparently missing in IOS<=11.2(8).\n\n   I set up 10.66.66/24 and fec0:6666:6666::0/96 as virtual networks\n   with broadcast 224.66.66.66. If you have access to mbone, play with me :-)\n\n   ping -t 255 224.66.66.66\n\n   If nobody answers, mbone does not work.\n\n   ip tunnel add Universe mode gre remote 224.66.66.66 local <Your_real_addr> ttl 255\n   ip addr add 10.66.66.<somewhat>/24 dev Universe\n   ifconfig Universe up\n   ifconfig Universe add fe80::<Your_real_addr>/10\n   ifconfig Universe add fec0:6666:6666::<Your_real_addr>/96\n   ftp 10.66.66.66\n   ...\n   ftp fec0:6666:6666::193.233.7.65\n   ...\n\n */\n\nstatic int ipgre_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type,\n\t\t\tconst void *daddr, const void *saddr, unsigned len)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct iphdr *iph = (struct iphdr *)skb_push(skb, t->hlen);\n\t__be16 *p = (__be16*)(iph+1);\n\n\tmemcpy(iph, &t->parms.iph, sizeof(struct iphdr));\n\tp[0]\t\t= t->parms.o_flags;\n\tp[1]\t\t= htons(type);\n\n\t/*\n\t *\tSet the source hardware address.\n\t */\n\n\tif (saddr)\n\t\tmemcpy(&iph->saddr, saddr, 4);\n\n\tif (daddr) {\n\t\tmemcpy(&iph->daddr, daddr, 4);\n\t\treturn t->hlen;\n\t}\n\tif (iph->daddr && !ipv4_is_multicast(iph->daddr))\n\t\treturn t->hlen;\n\n\treturn -t->hlen;\n}\n\nstatic int ipgre_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tstruct iphdr *iph = (struct iphdr *) skb_mac_header(skb);\n\tmemcpy(haddr, &iph->saddr, 4);\n\treturn 4;\n}\n\nstatic const struct header_ops ipgre_header_ops = {\n\t.create\t= ipgre_header,\n\t.parse\t= ipgre_header_parse,\n};\n\n#ifdef CONFIG_NET_IPGRE_BROADCAST\nstatic int ipgre_open(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr)) {\n\t\tstruct flowi fl = { .oif = t->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = t->parms.iph.daddr,\n\t\t\t\t\t\t.saddr = t->parms.iph.saddr,\n\t\t\t\t\t\t.tos = RT_TOS(t->parms.iph.tos) } },\n\t\t\t\t    .proto = IPPROTO_GRE };\n\t\tstruct rtable *rt;\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tdev = rt->u.dst.dev;\n\t\tip_rt_put(rt);\n\t\tif (__in_dev_get_rtnl(dev) == NULL)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tt->mlink = dev->ifindex;\n\t\tip_mc_inc_group(__in_dev_get_rtnl(dev), t->parms.iph.daddr);\n\t}\n\treturn 0;\n}\n\nstatic int ipgre_close(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {\n\t\tstruct in_device *in_dev;\n\t\tin_dev = inetdev_by_index(dev_net(dev), t->mlink);\n\t\tif (in_dev) {\n\t\t\tip_mc_dec_group(in_dev, t->parms.iph.daddr);\n\t\t\tin_dev_put(in_dev);\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif\n\nstatic const struct net_device_ops ipgre_netdev_ops = {\n\t.ndo_init\t\t= ipgre_tunnel_init,\n\t.ndo_uninit\t\t= ipgre_tunnel_uninit,\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t.ndo_open\t\t= ipgre_open,\n\t.ndo_stop\t\t= ipgre_close,\n#endif\n\t.ndo_start_xmit\t\t= ipgre_tunnel_xmit,\n\t.ndo_do_ioctl\t\t= ipgre_tunnel_ioctl,\n\t.ndo_change_mtu\t\t= ipgre_tunnel_change_mtu,\n};\n\nstatic void ipgre_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipgre_netdev_ops;\n\tdev->destructor \t= free_netdev;\n\n\tdev->type\t\t= ARPHRD_IPGRE;\n\tdev->needed_headroom \t= LL_MAX_HEADER + sizeof(struct iphdr) + 4;\n\tdev->mtu\t\t= ETH_DATA_LEN - sizeof(struct iphdr) - 4;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->iflink\t\t= 0;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n}\n\nstatic int ipgre_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\n\n\tif (iph->daddr) {\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t\tif (ipv4_is_multicast(iph->daddr)) {\n\t\t\tif (!iph->saddr)\n\t\t\t\treturn -EINVAL;\n\t\t\tdev->flags = IFF_BROADCAST;\n\t\t\tdev->header_ops = &ipgre_header_ops;\n\t\t}\n#endif\n\t} else\n\t\tdev->header_ops = &ipgre_header_ops;\n\n\treturn 0;\n}\n\nstatic void ipgre_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tstruct ipgre_net *ign = net_generic(dev_net(dev), ipgre_net_id);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_GRE;\n\tiph->ihl\t\t= 5;\n\ttunnel->hlen\t\t= sizeof(struct iphdr) + 4;\n\n\tdev_hold(dev);\n\tign->tunnels_wc[0]\t= tunnel;\n}\n\n\nstatic const struct net_protocol ipgre_protocol = {\n\t.handler\t=\tipgre_rcv,\n\t.err_handler\t=\tipgre_err,\n\t.netns_ok\t=\t1,\n};\n\nstatic void ipgre_destroy_tunnels(struct ipgre_net *ign, struct list_head *head)\n{\n\tint prio;\n\n\tfor (prio = 0; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\t\tstruct ip_tunnel *t = ign->tunnels[prio][h];\n\n\t\t\twhile (t != NULL) {\n\t\t\t\tunregister_netdevice_queue(t->dev, head);\n\t\t\t\tt = t->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init ipgre_init_net(struct net *net)\n{\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint err;\n\n\tign->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"gre0\",\n\t\t\t\t\t   ipgre_tunnel_setup);\n\tif (!ign->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(ign->fb_tunnel_dev, net);\n\n\tipgre_fb_tunnel_init(ign->fb_tunnel_dev);\n\tign->fb_tunnel_dev->rtnl_link_ops = &ipgre_link_ops;\n\n\tif ((err = register_netdev(ign->fb_tunnel_dev)))\n\t\tgoto err_reg_dev;\n\n\treturn 0;\n\nerr_reg_dev:\n\tfree_netdev(ign->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit ipgre_exit_net(struct net *net)\n{\n\tstruct ipgre_net *ign;\n\tLIST_HEAD(list);\n\n\tign = net_generic(net, ipgre_net_id);\n\trtnl_lock();\n\tipgre_destroy_tunnels(ign, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ipgre_net_ops = {\n\t.init = ipgre_init_net,\n\t.exit = ipgre_exit_net,\n\t.id   = &ipgre_net_id,\n\t.size = sizeof(struct ipgre_net),\n};\n\nstatic int ipgre_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\t__be16 flags;\n\n\tif (!data)\n\t\treturn 0;\n\n\tflags = 0;\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\tif (flags & (GRE_VERSION|GRE_ROUTING))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ipgre_tap_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\t__be32 daddr;\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (!data)\n\t\tgoto out;\n\n\tif (data[IFLA_GRE_REMOTE]) {\n\t\tmemcpy(&daddr, nla_data(data[IFLA_GRE_REMOTE]), 4);\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t}\n\nout:\n\treturn ipgre_tunnel_validate(tb, data);\n}\n\nstatic void ipgre_netlink_parms(struct nlattr *data[],\n\t\t\t\tstruct ip_tunnel_parm *parms)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tparms->iph.protocol = IPPROTO_GRE;\n\n\tif (!data)\n\t\treturn;\n\n\tif (data[IFLA_GRE_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_GRE_LINK]);\n\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tparms->i_flags = nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tparms->o_flags = nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\n\tif (data[IFLA_GRE_IKEY])\n\t\tparms->i_key = nla_get_be32(data[IFLA_GRE_IKEY]);\n\n\tif (data[IFLA_GRE_OKEY])\n\t\tparms->o_key = nla_get_be32(data[IFLA_GRE_OKEY]);\n\n\tif (data[IFLA_GRE_LOCAL])\n\t\tparms->iph.saddr = nla_get_be32(data[IFLA_GRE_LOCAL]);\n\n\tif (data[IFLA_GRE_REMOTE])\n\t\tparms->iph.daddr = nla_get_be32(data[IFLA_GRE_REMOTE]);\n\n\tif (data[IFLA_GRE_TTL])\n\t\tparms->iph.ttl = nla_get_u8(data[IFLA_GRE_TTL]);\n\n\tif (data[IFLA_GRE_TOS])\n\t\tparms->iph.tos = nla_get_u8(data[IFLA_GRE_TOS]);\n\n\tif (!data[IFLA_GRE_PMTUDISC] || nla_get_u8(data[IFLA_GRE_PMTUDISC]))\n\t\tparms->iph.frag_off = htons(IP_DF);\n}\n\nstatic int ipgre_tap_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel;\n\n\ttunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tipgre_tunnel_bind_dev(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ipgre_tap_netdev_ops = {\n\t.ndo_init\t\t= ipgre_tap_init,\n\t.ndo_uninit\t\t= ipgre_tunnel_uninit,\n\t.ndo_start_xmit\t\t= ipgre_tunnel_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= ipgre_tunnel_change_mtu,\n};\n\nstatic void ipgre_tap_setup(struct net_device *dev)\n{\n\n\tether_setup(dev);\n\n\tdev->netdev_ops\t\t= &ipgre_tap_netdev_ops;\n\tdev->destructor \t= free_netdev;\n\n\tdev->iflink\t\t= 0;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic int ipgre_newlink(struct net *src_net, struct net_device *dev, struct nlattr *tb[],\n\t\t\t struct nlattr *data[])\n{\n\tstruct ip_tunnel *nt;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint mtu;\n\tint err;\n\n\tnt = netdev_priv(dev);\n\tipgre_netlink_parms(data, &nt->parms);\n\n\tif (ipgre_tunnel_find(net, &nt->parms, dev->type))\n\t\treturn -EEXIST;\n\n\tif (dev->type == ARPHRD_ETHER && !tb[IFLA_ADDRESS])\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tmtu = ipgre_tunnel_bind_dev(dev);\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = mtu;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto out;\n\n\tdev_hold(dev);\n\tipgre_tunnel_link(ign, nt);\n\nout:\n\treturn err;\n}\n\nstatic int ipgre_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[])\n{\n\tstruct ip_tunnel *t, *nt;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tstruct ip_tunnel_parm p;\n\tint mtu;\n\n\tif (dev == ign->fb_tunnel_dev)\n\t\treturn -EINVAL;\n\n\tnt = netdev_priv(dev);\n\tipgre_netlink_parms(data, &p);\n\n\tt = ipgre_tunnel_locate(net, &p, 0);\n\n\tif (t) {\n\t\tif (t->dev != dev)\n\t\t\treturn -EEXIST;\n\t} else {\n\t\tt = nt;\n\n\t\tif (dev->type != ARPHRD_ETHER) {\n\t\t\tunsigned nflags = 0;\n\n\t\t\tif (ipv4_is_multicast(p.iph.daddr))\n\t\t\t\tnflags = IFF_BROADCAST;\n\t\t\telse if (p.iph.daddr)\n\t\t\t\tnflags = IFF_POINTOPOINT;\n\n\t\t\tif ((dev->flags ^ nflags) &\n\t\t\t    (IFF_POINTOPOINT | IFF_BROADCAST))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tipgre_tunnel_unlink(ign, t);\n\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\tt->parms.i_key = p.i_key;\n\t\tif (dev->type != ARPHRD_ETHER) {\n\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t}\n\t\tipgre_tunnel_link(ign, t);\n\t\tnetdev_state_change(dev);\n\t}\n\n\tt->parms.o_key = p.o_key;\n\tt->parms.iph.ttl = p.iph.ttl;\n\tt->parms.iph.tos = p.iph.tos;\n\tt->parms.iph.frag_off = p.iph.frag_off;\n\n\tif (t->parms.link != p.link) {\n\t\tt->parms.link = p.link;\n\t\tmtu = ipgre_tunnel_bind_dev(dev);\n\t\tif (!tb[IFLA_MTU])\n\t\t\tdev->mtu = mtu;\n\t\tnetdev_state_change(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t ipgre_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t/* IFLA_GRE_LINK */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_IFLAGS */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_GRE_OFLAGS */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_GRE_IKEY */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_OKEY */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_LOCAL */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_REMOTE */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_GRE_TTL */\n\t\tnla_total_size(1) +\n\t\t/* IFLA_GRE_TOS */\n\t\tnla_total_size(1) +\n\t\t/* IFLA_GRE_PMTUDISC */\n\t\tnla_total_size(1) +\n\t\t0;\n}\n\nstatic int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm *p = &t->parms;\n\n\tNLA_PUT_U32(skb, IFLA_GRE_LINK, p->link);\n\tNLA_PUT_BE16(skb, IFLA_GRE_IFLAGS, p->i_flags);\n\tNLA_PUT_BE16(skb, IFLA_GRE_OFLAGS, p->o_flags);\n\tNLA_PUT_BE32(skb, IFLA_GRE_IKEY, p->i_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_OKEY, p->o_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_LOCAL, p->iph.saddr);\n\tNLA_PUT_BE32(skb, IFLA_GRE_REMOTE, p->iph.daddr);\n\tNLA_PUT_U8(skb, IFLA_GRE_TTL, p->iph.ttl);\n\tNLA_PUT_U8(skb, IFLA_GRE_TOS, p->iph.tos);\n\tNLA_PUT_U8(skb, IFLA_GRE_PMTUDISC, !!(p->iph.frag_off & htons(IP_DF)));\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ipgre_policy[IFLA_GRE_MAX + 1] = {\n\t[IFLA_GRE_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_IFLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_OFLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_IKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_OKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_LOCAL]\t= { .len = FIELD_SIZEOF(struct iphdr, saddr) },\n\t[IFLA_GRE_REMOTE]\t= { .len = FIELD_SIZEOF(struct iphdr, daddr) },\n\t[IFLA_GRE_TTL]\t\t= { .type = NLA_U8 },\n\t[IFLA_GRE_TOS]\t\t= { .type = NLA_U8 },\n\t[IFLA_GRE_PMTUDISC]\t= { .type = NLA_U8 },\n};\n\nstatic struct rtnl_link_ops ipgre_link_ops __read_mostly = {\n\t.kind\t\t= \"gre\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ipgre_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipgre_tunnel_setup,\n\t.validate\t= ipgre_tunnel_validate,\n\t.newlink\t= ipgre_newlink,\n\t.changelink\t= ipgre_changelink,\n\t.get_size\t= ipgre_get_size,\n\t.fill_info\t= ipgre_fill_info,\n};\n\nstatic struct rtnl_link_ops ipgre_tap_ops __read_mostly = {\n\t.kind\t\t= \"gretap\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ipgre_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipgre_tap_setup,\n\t.validate\t= ipgre_tap_validate,\n\t.newlink\t= ipgre_newlink,\n\t.changelink\t= ipgre_changelink,\n\t.get_size\t= ipgre_get_size,\n\t.fill_info\t= ipgre_fill_info,\n};\n\n/*\n *\tAnd now the modules code and kernel interface.\n */\n\nstatic int __init ipgre_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = inet_add_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tif (err < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\tgoto add_proto_failed;\n\t}\n\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\nout:\n\treturn err;\n\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\nadd_proto_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\n\tgoto out;\n}\n\nstatic void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n\tunregister_pernet_device(&ipgre_net_ops);\n}\n\nmodule_init(ipgre_init);\nmodule_exit(ipgre_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"gre\");\nMODULE_ALIAS_RTNL_LINK(\"gretap\");\n"], "filenames": ["net/ipv4/ip_gre.c"], "buggy_code_start_loc": [1668], "buggy_code_end_loc": [1703], "fixing_code_start_loc": [1667], "fixing_code_end_loc": [1705], "type": "NVD-CWE-Other", "message": "net/ipv4/ip_gre.c in the Linux kernel before 2.6.34, when ip_gre is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading.", "other": {"cve": {"id": "CVE-2011-1767", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:54.247", "lastModified": "2023-02-13T01:19:27.203", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "net/ipv4/ip_gre.c in the Linux kernel before 2.6.34, when ip_gre is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading."}, {"lang": "es", "value": "net/ipv4/ip_gre.c del kernel de Linux en versiones anteriores a la 2.6.34, si ip_gre es configurado como m\u00f3dulo, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (OOPS) enviando un paquete durante la carga del m\u00f3dulo."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 5.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.33.20", "matchCriteriaId": "B8187F7E-B31E-4C1C-8EB3-384193B7D7EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:*:*:*:*:*:*:*", "matchCriteriaId": "D81C2911-5781-46A4-AD27-F946BD44EAEC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.1:*:*:*:*:*:*:*", "matchCriteriaId": "17721A7D-E955-407B-AACB-97F859CE79C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.2:*:*:*:*:*:*:*", "matchCriteriaId": "7B04F515-29A7-4D6A-AFC5-3A115F8A5918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.3:*:*:*:*:*:*:*", "matchCriteriaId": "7514928F-8992-4B8A-8AF4-E89F1CB6EFCE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.4:*:*:*:*:*:*:*", "matchCriteriaId": "BD6324B7-1329-4C6B-8DDB-D489250E07C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.5:*:*:*:*:*:*:*", "matchCriteriaId": "A7910FE5-E02C-4B20-9F27-F488E76BDE93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.6:*:*:*:*:*:*:*", "matchCriteriaId": "96F85BC2-54C4-4450-B3BA-A2A8EB78A81C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.7:*:*:*:*:*:*:*", "matchCriteriaId": "25E5B510-1096-42E8-8BD1-E9198D588050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.8:*:*:*:*:*:*:*", "matchCriteriaId": "29787617-FFDD-4BDE-97EB-330675B99614"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.9:*:*:*:*:*:*:*", "matchCriteriaId": "7B28D3CE-E432-4F10-BF25-D03B0D89388A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.10:*:*:*:*:*:*:*", "matchCriteriaId": "E587FF24-AA5D-454B-8928-9C3CE03C419C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.11:*:*:*:*:*:*:*", "matchCriteriaId": "9DDBAAA5-240F-4DE5-BAA1-89508BD2CD8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.12:*:*:*:*:*:*:*", "matchCriteriaId": "F5D61706-2974-4C96-8196-9F3F56F1791F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.13:*:*:*:*:*:*:*", "matchCriteriaId": "46C5D7F1-152C-435F-8694-A66D0008289B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.14:*:*:*:*:*:*:*", "matchCriteriaId": "BEA2A352-7F4F-449D-AE23-24D39BFE0DB3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.15:*:*:*:*:*:*:*", "matchCriteriaId": "D9763287-12D3-485D-9DB4-0EBBEB2858C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.16:*:*:*:*:*:*:*", "matchCriteriaId": "9CDB80CE-2F1D-47EE-AE64-EA07B0AA3C20"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.17:*:*:*:*:*:*:*", "matchCriteriaId": "E70E77F5-12EF-4E12-8D34-9C56D23CAB22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.18:*:*:*:*:*:*:*", "matchCriteriaId": "B0139175-7049-4A2D-878E-EC43325DB5B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.19:*:*:*:*:*:*:*", "matchCriteriaId": "18483901-EC47-45AD-A9EB-30591AA1247E"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.34", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=c2892f02712e9516d72841d5c019ed6916329794", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/05/05/6", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=702303", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/c2892f02712e9516d72841d5c019ed6916329794", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c2892f02712e9516d72841d5c019ed6916329794"}}