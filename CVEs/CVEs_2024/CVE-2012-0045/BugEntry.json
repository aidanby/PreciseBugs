{"buggy_code": ["/******************************************************************************\n * x86_emulate.h\n *\n * Generic x86 (32-bit and 64-bit) instruction decoder and emulator.\n *\n * Copyright (c) 2005 Keir Fraser\n *\n * From: xen-unstable 10676:af9809f51f81a3c43f276f00c81a52ef558afda4\n */\n\n#ifndef _ASM_X86_KVM_X86_EMULATE_H\n#define _ASM_X86_KVM_X86_EMULATE_H\n\n#include <asm/desc_defs.h>\n\nstruct x86_emulate_ctxt;\nenum x86_intercept;\nenum x86_intercept_stage;\n\nstruct x86_exception {\n\tu8 vector;\n\tbool error_code_valid;\n\tu16 error_code;\n\tbool nested_page_fault;\n\tu64 address; /* cr2 or nested page fault gpa */\n};\n\n/*\n * This struct is used to carry enough information from the instruction\n * decoder to main KVM so that a decision can be made whether the\n * instruction needs to be intercepted or not.\n */\nstruct x86_instruction_info {\n\tu8  intercept;          /* which intercept                      */\n\tu8  rep_prefix;         /* rep prefix?                          */\n\tu8  modrm_mod;\t\t/* mod part of modrm\t\t\t*/\n\tu8  modrm_reg;          /* index of register used               */\n\tu8  modrm_rm;\t\t/* rm part of modrm\t\t\t*/\n\tu64 src_val;            /* value of source operand              */\n\tu8  src_bytes;          /* size of source operand               */\n\tu8  dst_bytes;          /* size of destination operand          */\n\tu8  ad_bytes;           /* size of src/dst address              */\n\tu64 next_rip;           /* rip following the instruction        */\n};\n\n/*\n * x86_emulate_ops:\n *\n * These operations represent the instruction emulator's interface to memory.\n * There are two categories of operation: those that act on ordinary memory\n * regions (*_std), and those that act on memory regions known to require\n * special treatment or emulation (*_emulated).\n *\n * The emulator assumes that an instruction accesses only one 'emulated memory'\n * location, that this location is the given linear faulting address (cr2), and\n * that this is one of the instruction's data operands. Instruction fetches and\n * stack operations are assumed never to access emulated memory. The emulator\n * automatically deduces which operand of a string-move operation is accessing\n * emulated memory, and assumes that the other operand accesses normal memory.\n *\n * NOTES:\n *  1. The emulator isn't very smart about emulated vs. standard memory.\n *     'Emulated memory' access addresses should be checked for sanity.\n *     'Normal memory' accesses may fault, and the caller must arrange to\n *     detect and handle reentrancy into the emulator via recursive faults.\n *     Accesses may be unaligned and may cross page boundaries.\n *  2. If the access fails (cannot emulate, or a standard access faults) then\n *     it is up to the memop to propagate the fault to the guest VM via\n *     some out-of-band mechanism, unknown to the emulator. The memop signals\n *     failure by returning X86EMUL_PROPAGATE_FAULT to the emulator, which will\n *     then immediately bail.\n *  3. Valid access sizes are 1, 2, 4 and 8 bytes. On x86/32 systems only\n *     cmpxchg8b_emulated need support 8-byte accesses.\n *  4. The emulator cannot handle 64-bit mode emulation on an x86/32 system.\n */\n/* Access completed successfully: continue emulation as normal. */\n#define X86EMUL_CONTINUE        0\n/* Access is unhandleable: bail from emulation and return error to caller. */\n#define X86EMUL_UNHANDLEABLE    1\n/* Terminate emulation but return success to the caller. */\n#define X86EMUL_PROPAGATE_FAULT 2 /* propagate a generated fault to guest */\n#define X86EMUL_RETRY_INSTR     3 /* retry the instruction for some reason */\n#define X86EMUL_CMPXCHG_FAILED  4 /* cmpxchg did not see expected value */\n#define X86EMUL_IO_NEEDED       5 /* IO is needed to complete emulation */\n#define X86EMUL_INTERCEPTED     6 /* Intercepted by nested VMCB/VMCS */\n\nstruct x86_emulate_ops {\n\t/*\n\t * read_std: Read bytes of standard (non-emulated/special) memory.\n\t *           Used for descriptor reading.\n\t *  @addr:  [IN ] Linear address from which to read.\n\t *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to read from memory.\n\t */\n\tint (*read_std)(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr, void *val,\n\t\t\tunsigned int bytes,\n\t\t\tstruct x86_exception *fault);\n\n\t/*\n\t * write_std: Write bytes of standard (non-emulated/special) memory.\n\t *            Used for descriptor writing.\n\t *  @addr:  [IN ] Linear address to which to write.\n\t *  @val:   [OUT] Value write to memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to write to memory.\n\t */\n\tint (*write_std)(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *val, unsigned int bytes,\n\t\t\t struct x86_exception *fault);\n\t/*\n\t * fetch: Read bytes of standard (non-emulated/special) memory.\n\t *        Used for instruction fetch.\n\t *  @addr:  [IN ] Linear address from which to read.\n\t *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to read from memory.\n\t */\n\tint (*fetch)(struct x86_emulate_ctxt *ctxt,\n\t\t     unsigned long addr, void *val, unsigned int bytes,\n\t\t     struct x86_exception *fault);\n\n\t/*\n\t * read_emulated: Read bytes from emulated/special memory area.\n\t *  @addr:  [IN ] Linear address from which to read.\n\t *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to read from memory.\n\t */\n\tint (*read_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t     unsigned long addr, void *val, unsigned int bytes,\n\t\t\t     struct x86_exception *fault);\n\n\t/*\n\t * write_emulated: Write bytes to emulated/special memory area.\n\t *  @addr:  [IN ] Linear address to which to write.\n\t *  @val:   [IN ] Value to write to memory (low-order bytes used as\n\t *                required).\n\t *  @bytes: [IN ] Number of bytes to write to memory.\n\t */\n\tint (*write_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long addr, const void *val,\n\t\t\t      unsigned int bytes,\n\t\t\t      struct x86_exception *fault);\n\n\t/*\n\t * cmpxchg_emulated: Emulate an atomic (LOCKed) CMPXCHG operation on an\n\t *                   emulated/special memory area.\n\t *  @addr:  [IN ] Linear address to access.\n\t *  @old:   [IN ] Value expected to be current at @addr.\n\t *  @new:   [IN ] Value to write to @addr.\n\t *  @bytes: [IN ] Number of bytes to access using CMPXCHG.\n\t */\n\tint (*cmpxchg_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tunsigned long addr,\n\t\t\t\tconst void *old,\n\t\t\t\tconst void *new,\n\t\t\t\tunsigned int bytes,\n\t\t\t\tstruct x86_exception *fault);\n\tvoid (*invlpg)(struct x86_emulate_ctxt *ctxt, ulong addr);\n\n\tint (*pio_in_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t       int size, unsigned short port, void *val,\n\t\t\t       unsigned int count);\n\n\tint (*pio_out_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tint size, unsigned short port, const void *val,\n\t\t\t\tunsigned int count);\n\n\tbool (*get_segment)(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t    struct desc_struct *desc, u32 *base3, int seg);\n\tvoid (*set_segment)(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t    struct desc_struct *desc, u32 base3, int seg);\n\tunsigned long (*get_cached_segment_base)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t\t int seg);\n\tvoid (*get_gdt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*get_idt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*set_gdt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*set_idt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tulong (*get_cr)(struct x86_emulate_ctxt *ctxt, int cr);\n\tint (*set_cr)(struct x86_emulate_ctxt *ctxt, int cr, ulong val);\n\tint (*cpl)(struct x86_emulate_ctxt *ctxt);\n\tint (*get_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong *dest);\n\tint (*set_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong value);\n\tint (*set_msr)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 data);\n\tint (*get_msr)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 *pdata);\n\tint (*read_pmc)(struct x86_emulate_ctxt *ctxt, u32 pmc, u64 *pdata);\n\tvoid (*halt)(struct x86_emulate_ctxt *ctxt);\n\tvoid (*wbinvd)(struct x86_emulate_ctxt *ctxt);\n\tint (*fix_hypercall)(struct x86_emulate_ctxt *ctxt);\n\tvoid (*get_fpu)(struct x86_emulate_ctxt *ctxt); /* disables preempt */\n\tvoid (*put_fpu)(struct x86_emulate_ctxt *ctxt); /* reenables preempt */\n\tint (*intercept)(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_instruction_info *info,\n\t\t\t enum x86_intercept_stage stage);\n\n\tbool (*get_cpuid)(struct x86_emulate_ctxt *ctxt,\n\t\t\t u32 *eax, u32 *ebx, u32 *ecx, u32 *edx);\n};\n\ntypedef u32 __attribute__((vector_size(16))) sse128_t;\n\n/* Type, address-of, and value of an instruction's operand. */\nstruct operand {\n\tenum { OP_REG, OP_MEM, OP_IMM, OP_XMM, OP_NONE } type;\n\tunsigned int bytes;\n\tunion {\n\t\tunsigned long orig_val;\n\t\tu64 orig_val64;\n\t};\n\tunion {\n\t\tunsigned long *reg;\n\t\tstruct segmented_address {\n\t\t\tulong ea;\n\t\t\tunsigned seg;\n\t\t} mem;\n\t\tunsigned xmm;\n\t} addr;\n\tunion {\n\t\tunsigned long val;\n\t\tu64 val64;\n\t\tchar valptr[sizeof(unsigned long) + 2];\n\t\tsse128_t vec_val;\n\t};\n};\n\nstruct fetch_cache {\n\tu8 data[15];\n\tunsigned long start;\n\tunsigned long end;\n};\n\nstruct read_cache {\n\tu8 data[1024];\n\tunsigned long pos;\n\tunsigned long end;\n};\n\nstruct x86_emulate_ctxt {\n\tstruct x86_emulate_ops *ops;\n\n\t/* Register state before/after emulation. */\n\tunsigned long eflags;\n\tunsigned long eip; /* eip before instruction emulation */\n\t/* Emulated execution mode, represented by an X86EMUL_MODE value. */\n\tint mode;\n\n\t/* interruptibility state, as a result of execution of STI or MOV SS */\n\tint interruptibility;\n\n\tbool guest_mode; /* guest running a nested guest */\n\tbool perm_ok; /* do not check permissions if true */\n\tbool only_vendor_specific_insn;\n\n\tbool have_exception;\n\tstruct x86_exception exception;\n\n\t/* decode cache */\n\tu8 twobyte;\n\tu8 b;\n\tu8 intercept;\n\tu8 lock_prefix;\n\tu8 rep_prefix;\n\tu8 op_bytes;\n\tu8 ad_bytes;\n\tu8 rex_prefix;\n\tstruct operand src;\n\tstruct operand src2;\n\tstruct operand dst;\n\tbool has_seg_override;\n\tu8 seg_override;\n\tu64 d;\n\tint (*execute)(struct x86_emulate_ctxt *ctxt);\n\tint (*check_perm)(struct x86_emulate_ctxt *ctxt);\n\t/* modrm */\n\tu8 modrm;\n\tu8 modrm_mod;\n\tu8 modrm_reg;\n\tu8 modrm_rm;\n\tu8 modrm_seg;\n\tbool rip_relative;\n\tunsigned long _eip;\n\t/* Fields above regs are cleared together. */\n\tunsigned long regs[NR_VCPU_REGS];\n\tstruct operand memop;\n\tstruct operand *memopp;\n\tstruct fetch_cache fetch;\n\tstruct read_cache io_read;\n\tstruct read_cache mem_read;\n};\n\n/* Repeat String Operation Prefix */\n#define REPE_PREFIX\t0xf3\n#define REPNE_PREFIX\t0xf2\n\n/* Execution mode, passed to the emulator. */\n#define X86EMUL_MODE_REAL     0\t/* Real mode.             */\n#define X86EMUL_MODE_VM86     1\t/* Virtual 8086 mode.     */\n#define X86EMUL_MODE_PROT16   2\t/* 16-bit protected mode. */\n#define X86EMUL_MODE_PROT32   4\t/* 32-bit protected mode. */\n#define X86EMUL_MODE_PROT64   8\t/* 64-bit (long) mode.    */\n\n/* any protected mode   */\n#define X86EMUL_MODE_PROT     (X86EMUL_MODE_PROT16|X86EMUL_MODE_PROT32| \\\n\t\t\t       X86EMUL_MODE_PROT64)\n\nenum x86_intercept_stage {\n\tX86_ICTP_NONE = 0,   /* Allow zero-init to not match anything */\n\tX86_ICPT_PRE_EXCEPT,\n\tX86_ICPT_POST_EXCEPT,\n\tX86_ICPT_POST_MEMACCESS,\n};\n\nenum x86_intercept {\n\tx86_intercept_none,\n\tx86_intercept_cr_read,\n\tx86_intercept_cr_write,\n\tx86_intercept_clts,\n\tx86_intercept_lmsw,\n\tx86_intercept_smsw,\n\tx86_intercept_dr_read,\n\tx86_intercept_dr_write,\n\tx86_intercept_lidt,\n\tx86_intercept_sidt,\n\tx86_intercept_lgdt,\n\tx86_intercept_sgdt,\n\tx86_intercept_lldt,\n\tx86_intercept_sldt,\n\tx86_intercept_ltr,\n\tx86_intercept_str,\n\tx86_intercept_rdtsc,\n\tx86_intercept_rdpmc,\n\tx86_intercept_pushf,\n\tx86_intercept_popf,\n\tx86_intercept_cpuid,\n\tx86_intercept_rsm,\n\tx86_intercept_iret,\n\tx86_intercept_intn,\n\tx86_intercept_invd,\n\tx86_intercept_pause,\n\tx86_intercept_hlt,\n\tx86_intercept_invlpg,\n\tx86_intercept_invlpga,\n\tx86_intercept_vmrun,\n\tx86_intercept_vmload,\n\tx86_intercept_vmsave,\n\tx86_intercept_vmmcall,\n\tx86_intercept_stgi,\n\tx86_intercept_clgi,\n\tx86_intercept_skinit,\n\tx86_intercept_rdtscp,\n\tx86_intercept_icebp,\n\tx86_intercept_wbinvd,\n\tx86_intercept_monitor,\n\tx86_intercept_mwait,\n\tx86_intercept_rdmsr,\n\tx86_intercept_wrmsr,\n\tx86_intercept_in,\n\tx86_intercept_ins,\n\tx86_intercept_out,\n\tx86_intercept_outs,\n\n\tnr_x86_intercepts\n};\n\n/* Host execution mode. */\n#if defined(CONFIG_X86_32)\n#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT32\n#elif defined(CONFIG_X86_64)\n#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT64\n#endif\n\nint x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len);\nbool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt);\n#define EMULATION_FAILED -1\n#define EMULATION_OK 0\n#define EMULATION_RESTART 1\n#define EMULATION_INTERCEPTED 2\nint x86_emulate_insn(struct x86_emulate_ctxt *ctxt);\nint emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int reason,\n\t\t\t bool has_error_code, u32 error_code);\nint emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq);\n#endif /* _ASM_X86_KVM_X86_EMULATE_H */\n", "/******************************************************************************\n * emulate.c\n *\n * Generic x86 (32-bit and 64-bit) instruction decoder and emulator.\n *\n * Copyright (c) 2005 Keir Fraser\n *\n * Linux coding style, mod r/m decoder, segment base fixes, real-mode\n * privileged instructions:\n *\n * Copyright (C) 2006 Qumranet\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n *   Avi Kivity <avi@qumranet.com>\n *   Yaniv Kamay <yaniv@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * From: xen-unstable 10676:af9809f51f81a3c43f276f00c81a52ef558afda4\n */\n\n#include <linux/kvm_host.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/module.h>\n#include <asm/kvm_emulate.h>\n\n#include \"x86.h\"\n#include \"tss.h\"\n\n/*\n * Operand types\n */\n#define OpNone             0ull\n#define OpImplicit         1ull  /* No generic decode */\n#define OpReg              2ull  /* Register */\n#define OpMem              3ull  /* Memory */\n#define OpAcc              4ull  /* Accumulator: AL/AX/EAX/RAX */\n#define OpDI               5ull  /* ES:DI/EDI/RDI */\n#define OpMem64            6ull  /* Memory, 64-bit */\n#define OpImmUByte         7ull  /* Zero-extended 8-bit immediate */\n#define OpDX               8ull  /* DX register */\n#define OpCL               9ull  /* CL register (for shifts) */\n#define OpImmByte         10ull  /* 8-bit sign extended immediate */\n#define OpOne             11ull  /* Implied 1 */\n#define OpImm             12ull  /* Sign extended immediate */\n#define OpMem16           13ull  /* Memory operand (16-bit). */\n#define OpMem32           14ull  /* Memory operand (32-bit). */\n#define OpImmU            15ull  /* Immediate operand, zero extended */\n#define OpSI              16ull  /* SI/ESI/RSI */\n#define OpImmFAddr        17ull  /* Immediate far address */\n#define OpMemFAddr        18ull  /* Far address in memory */\n#define OpImmU16          19ull  /* Immediate operand, 16 bits, zero extended */\n#define OpES              20ull  /* ES */\n#define OpCS              21ull  /* CS */\n#define OpSS              22ull  /* SS */\n#define OpDS              23ull  /* DS */\n#define OpFS              24ull  /* FS */\n#define OpGS              25ull  /* GS */\n\n#define OpBits             5  /* Width of operand field */\n#define OpMask             ((1ull << OpBits) - 1)\n\n/*\n * Opcode effective-address decode tables.\n * Note that we only emulate instructions that have at least one memory\n * operand (excluding implicit stack references). We assume that stack\n * references and instruction fetches will never occur in special memory\n * areas that require emulation. So, for example, 'mov <imm>,<reg>' need\n * not be handled.\n */\n\n/* Operand sizes: 8-bit operands or specified/overridden size. */\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n/* Destination operand type. */\n#define DstShift    1\n#define ImplicitOps (OpImplicit << DstShift)\n#define DstReg      (OpReg << DstShift)\n#define DstMem      (OpMem << DstShift)\n#define DstAcc      (OpAcc << DstShift)\n#define DstDI       (OpDI << DstShift)\n#define DstMem64    (OpMem64 << DstShift)\n#define DstImmUByte (OpImmUByte << DstShift)\n#define DstDX       (OpDX << DstShift)\n#define DstMask     (OpMask << DstShift)\n/* Source operand type. */\n#define SrcShift    6\n#define SrcNone     (OpNone << SrcShift)\n#define SrcReg      (OpReg << SrcShift)\n#define SrcMem      (OpMem << SrcShift)\n#define SrcMem16    (OpMem16 << SrcShift)\n#define SrcMem32    (OpMem32 << SrcShift)\n#define SrcImm      (OpImm << SrcShift)\n#define SrcImmByte  (OpImmByte << SrcShift)\n#define SrcOne      (OpOne << SrcShift)\n#define SrcImmUByte (OpImmUByte << SrcShift)\n#define SrcImmU     (OpImmU << SrcShift)\n#define SrcSI       (OpSI << SrcShift)\n#define SrcImmFAddr (OpImmFAddr << SrcShift)\n#define SrcMemFAddr (OpMemFAddr << SrcShift)\n#define SrcAcc      (OpAcc << SrcShift)\n#define SrcImmU16   (OpImmU16 << SrcShift)\n#define SrcDX       (OpDX << SrcShift)\n#define SrcMask     (OpMask << SrcShift)\n#define BitOp       (1<<11)\n#define MemAbs      (1<<12)      /* Memory operand is absolute displacement */\n#define String      (1<<13)     /* String instruction (rep capable) */\n#define Stack       (1<<14)     /* Stack instruction (push/pop) */\n#define GroupMask   (7<<15)     /* Opcode uses one of the group mechanisms */\n#define Group       (1<<15)     /* Bits 3:5 of modrm byte extend opcode */\n#define GroupDual   (2<<15)     /* Alternate decoding of mod == 3 */\n#define Prefix      (3<<15)     /* Instruction varies with 66/f2/f3 prefix */\n#define RMExt       (4<<15)     /* Opcode extension in ModRM r/m if mod == 3 */\n#define Sse         (1<<18)     /* SSE Vector instruction */\n/* Generic ModRM decode. */\n#define ModRM       (1<<19)\n/* Destination is only written; never read. */\n#define Mov         (1<<20)\n/* Misc flags */\n#define Prot        (1<<21) /* instruction generates #UD if not in prot-mode */\n#define VendorSpecific (1<<22) /* Vendor specific instruction */\n#define NoAccess    (1<<23) /* Don't access memory (lea/invlpg/verr etc) */\n#define Op3264      (1<<24) /* Operand is 64b in long mode, 32b otherwise */\n#define Undefined   (1<<25) /* No Such Instruction */\n#define Lock        (1<<26) /* lock prefix is allowed for the instruction */\n#define Priv        (1<<27) /* instruction generates #GP if current CPL != 0 */\n#define No64\t    (1<<28)\n#define PageTable   (1 << 29)   /* instruction used to write page table */\n/* Source 2 operand type */\n#define Src2Shift   (30)\n#define Src2None    (OpNone << Src2Shift)\n#define Src2CL      (OpCL << Src2Shift)\n#define Src2ImmByte (OpImmByte << Src2Shift)\n#define Src2One     (OpOne << Src2Shift)\n#define Src2Imm     (OpImm << Src2Shift)\n#define Src2ES      (OpES << Src2Shift)\n#define Src2CS      (OpCS << Src2Shift)\n#define Src2SS      (OpSS << Src2Shift)\n#define Src2DS      (OpDS << Src2Shift)\n#define Src2FS      (OpFS << Src2Shift)\n#define Src2GS      (OpGS << Src2Shift)\n#define Src2Mask    (OpMask << Src2Shift)\n\n#define X2(x...) x, x\n#define X3(x...) X2(x), x\n#define X4(x...) X2(x), X2(x)\n#define X5(x...) X4(x), x\n#define X6(x...) X4(x), X2(x)\n#define X7(x...) X4(x), X3(x)\n#define X8(x...) X4(x), X4(x)\n#define X16(x...) X8(x), X8(x)\n\nstruct opcode {\n\tu64 flags : 56;\n\tu64 intercept : 8;\n\tunion {\n\t\tint (*execute)(struct x86_emulate_ctxt *ctxt);\n\t\tstruct opcode *group;\n\t\tstruct group_dual *gdual;\n\t\tstruct gprefix *gprefix;\n\t} u;\n\tint (*check_perm)(struct x86_emulate_ctxt *ctxt);\n};\n\nstruct group_dual {\n\tstruct opcode mod012[8];\n\tstruct opcode mod3[8];\n};\n\nstruct gprefix {\n\tstruct opcode pfx_no;\n\tstruct opcode pfx_66;\n\tstruct opcode pfx_f2;\n\tstruct opcode pfx_f3;\n};\n\n/* EFLAGS bit definitions. */\n#define EFLG_ID (1<<21)\n#define EFLG_VIP (1<<20)\n#define EFLG_VIF (1<<19)\n#define EFLG_AC (1<<18)\n#define EFLG_VM (1<<17)\n#define EFLG_RF (1<<16)\n#define EFLG_IOPL (3<<12)\n#define EFLG_NT (1<<14)\n#define EFLG_OF (1<<11)\n#define EFLG_DF (1<<10)\n#define EFLG_IF (1<<9)\n#define EFLG_TF (1<<8)\n#define EFLG_SF (1<<7)\n#define EFLG_ZF (1<<6)\n#define EFLG_AF (1<<4)\n#define EFLG_PF (1<<2)\n#define EFLG_CF (1<<0)\n\n#define EFLG_RESERVED_ZEROS_MASK 0xffc0802a\n#define EFLG_RESERVED_ONE_MASK 2\n\n/*\n * Instruction emulation:\n * Most instructions are emulated directly via a fragment of inline assembly\n * code. This allows us to save/restore EFLAGS and thus very easily pick up\n * any modified flags.\n */\n\n#if defined(CONFIG_X86_64)\n#define _LO32 \"k\"\t\t/* force 32-bit operand */\n#define _STK  \"%%rsp\"\t\t/* stack pointer */\n#elif defined(__i386__)\n#define _LO32 \"\"\t\t/* force 32-bit operand */\n#define _STK  \"%%esp\"\t\t/* stack pointer */\n#endif\n\n/*\n * These EFLAGS bits are restored from saved value during emulation, and\n * any changes are written back to the saved value after emulation.\n */\n#define EFLAGS_MASK (EFLG_OF|EFLG_SF|EFLG_ZF|EFLG_AF|EFLG_PF|EFLG_CF)\n\n/* Before executing instruction: restore necessary bits in EFLAGS. */\n#define _PRE_EFLAGS(_sav, _msk, _tmp)\t\t\t\t\t\\\n\t/* EFLAGS = (_sav & _msk) | (EFLAGS & ~_msk); _sav &= ~_msk; */ \\\n\t\"movl %\"_sav\",%\"_LO32 _tmp\"; \"                                  \\\n\t\"push %\"_tmp\"; \"                                                \\\n\t\"push %\"_tmp\"; \"                                                \\\n\t\"movl %\"_msk\",%\"_LO32 _tmp\"; \"                                  \\\n\t\"andl %\"_LO32 _tmp\",(\"_STK\"); \"                                 \\\n\t\"pushf; \"                                                       \\\n\t\"notl %\"_LO32 _tmp\"; \"                                          \\\n\t\"andl %\"_LO32 _tmp\",(\"_STK\"); \"                                 \\\n\t\"andl %\"_LO32 _tmp\",\"__stringify(BITS_PER_LONG/4)\"(\"_STK\"); \"\t\\\n\t\"pop  %\"_tmp\"; \"                                                \\\n\t\"orl  %\"_LO32 _tmp\",(\"_STK\"); \"                                 \\\n\t\"popf; \"                                                        \\\n\t\"pop  %\"_sav\"; \"\n\n/* After executing instruction: write-back necessary bits in EFLAGS. */\n#define _POST_EFLAGS(_sav, _msk, _tmp) \\\n\t/* _sav |= EFLAGS & _msk; */\t\t\\\n\t\"pushf; \"\t\t\t\t\\\n\t\"pop  %\"_tmp\"; \"\t\t\t\\\n\t\"andl %\"_msk\",%\"_LO32 _tmp\"; \"\t\t\\\n\t\"orl  %\"_LO32 _tmp\",%\"_sav\"; \"\n\n#ifdef CONFIG_X86_64\n#define ON64(x) x\n#else\n#define ON64(x)\n#endif\n\n#define ____emulate_2op(ctxt, _op, _x, _y, _suffix, _dsttype)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"4\", \"2\")\t\t\t\\\n\t\t\t_op _suffix \" %\"_x\"3,%1; \"\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"4\", \"2\")\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags),\t\t\t\\\n\t\t\t  \"+q\" (*(_dsttype*)&(ctxt)->dst.val),\t\t\\\n\t\t\t  \"=&r\" (_tmp)\t\t\t\t\t\\\n\t\t\t: _y ((ctxt)->src.val), \"i\" (EFLAGS_MASK));\t\\\n\t} while (0)\n\n\n/* Raw emulation: instruction has two explicit operands. */\n#define __emulate_2op_nobyte(ctxt,_op,_wx,_wy,_lx,_ly,_qx,_qy)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\t\t____emulate_2op(ctxt,_op,_wx,_wy,\"w\",u16);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\t____emulate_2op(ctxt,_op,_lx,_ly,\"l\",u32);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 8:\t\t\t\t\t\t\t\\\n\t\t\tON64(____emulate_2op(ctxt,_op,_qx,_qy,\"q\",u64)); \\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __emulate_2op(ctxt,_op,_bx,_by,_wx,_wy,_lx,_ly,_qx,_qy)\t\t     \\\n\tdo {\t\t\t\t\t\t\t\t     \\\n\t\tunsigned long _tmp;\t\t\t\t\t     \\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t     \\\n\t\tcase 1:\t\t\t\t\t\t\t     \\\n\t\t\t____emulate_2op(ctxt,_op,_bx,_by,\"b\",u8);\t     \\\n\t\t\tbreak;\t\t\t\t\t\t     \\\n\t\tdefault:\t\t\t\t\t\t     \\\n\t\t\t__emulate_2op_nobyte(ctxt, _op,\t\t\t     \\\n\t\t\t\t\t     _wx, _wy, _lx, _ly, _qx, _qy);  \\\n\t\t\tbreak;\t\t\t\t\t\t     \\\n\t\t}\t\t\t\t\t\t\t     \\\n\t} while (0)\n\n/* Source operand is byte-sized and may be restricted to just %cl. */\n#define emulate_2op_SrcB(ctxt, _op)\t\t\t\t\t\\\n\t__emulate_2op(ctxt, _op, \"b\", \"c\", \"b\", \"c\", \"b\", \"c\", \"b\", \"c\")\n\n/* Source operand is byte, word, long or quad sized. */\n#define emulate_2op_SrcV(ctxt, _op)\t\t\t\t\t\\\n\t__emulate_2op(ctxt, _op, \"b\", \"q\", \"w\", \"r\", _LO32, \"r\", \"\", \"r\")\n\n/* Source operand is word, long or quad sized. */\n#define emulate_2op_SrcV_nobyte(ctxt, _op)\t\t\t\t\\\n\t__emulate_2op_nobyte(ctxt, _op, \"w\", \"r\", _LO32, \"r\", \"\", \"r\")\n\n/* Instruction has three operands and one operand is stored in ECX register */\n#define __emulate_2op_cl(ctxt, _op, _suffix, _type)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\t_type _clv  = (ctxt)->src2.val;\t\t\t\t\\\n\t\t_type _srcv = (ctxt)->src.val;\t\t\t\t\\\n\t\t_type _dstv = (ctxt)->dst.val;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"5\", \"2\")\t\t\t\\\n\t\t\t_op _suffix \" %4,%1 \\n\"\t\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"5\", \"2\")\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags), \"+r\" (_dstv), \"=&r\" (_tmp) \\\n\t\t\t: \"c\" (_clv) , \"r\" (_srcv), \"i\" (EFLAGS_MASK)\t\\\n\t\t\t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t(ctxt)->src2.val  = (unsigned long) _clv;\t\t\\\n\t\t(ctxt)->src2.val = (unsigned long) _srcv;\t\t\\\n\t\t(ctxt)->dst.val = (unsigned long) _dstv;\t\t\\\n\t} while (0)\n\n#define emulate_2op_cl(ctxt, _op)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_2op_cl(ctxt, _op, \"w\", u16);\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_2op_cl(ctxt, _op, \"l\", u32);\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 8:\t\t\t\t\t\t\t\\\n\t\t\tON64(__emulate_2op_cl(ctxt, _op, \"q\", ulong));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __emulate_1op(ctxt, _op, _suffix)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"3\", \"2\")\t\t\t\\\n\t\t\t_op _suffix \" %1; \"\t\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"3\", \"2\")\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags), \"+m\" ((ctxt)->dst.val), \\\n\t\t\t  \"=&r\" (_tmp)\t\t\t\t\t\\\n\t\t\t: \"i\" (EFLAGS_MASK));\t\t\t\t\\\n\t} while (0)\n\n/* Instruction has only one explicit operand (no source operand). */\n#define emulate_1op(ctxt, _op)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t\\\n\t\tcase 1:\t__emulate_1op(ctxt, _op, \"b\"); break;\t\t\\\n\t\tcase 2:\t__emulate_1op(ctxt, _op, \"w\"); break;\t\t\\\n\t\tcase 4:\t__emulate_1op(ctxt, _op, \"l\"); break;\t\t\\\n\t\tcase 8:\tON64(__emulate_1op(ctxt, _op, \"q\")); break;\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __emulate_1op_rax_rdx(ctxt, _op, _suffix, _ex)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\tulong *rax = &(ctxt)->regs[VCPU_REGS_RAX];\t\t\\\n\t\tulong *rdx = &(ctxt)->regs[VCPU_REGS_RDX];\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"5\", \"1\")\t\t\t\\\n\t\t\t\"1: \\n\\t\"\t\t\t\t\t\\\n\t\t\t_op _suffix \" %6; \"\t\t\t\t\\\n\t\t\t\"2: \\n\\t\"\t\t\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"5\", \"1\")\t\t\t\\\n\t\t\t\".pushsection .fixup,\\\"ax\\\" \\n\\t\"\t\t\\\n\t\t\t\"3: movb $1, %4 \\n\\t\"\t\t\t\t\\\n\t\t\t\"jmp 2b \\n\\t\"\t\t\t\t\t\\\n\t\t\t\".popsection \\n\\t\"\t\t\t\t\\\n\t\t\t_ASM_EXTABLE(1b, 3b)\t\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags), \"=&r\" (_tmp),\t\t\\\n\t\t\t  \"+a\" (*rax), \"+d\" (*rdx), \"+qm\"(_ex)\t\t\\\n\t\t\t: \"i\" (EFLAGS_MASK), \"m\" ((ctxt)->src.val),\t\\\n\t\t\t  \"a\" (*rax), \"d\" (*rdx));\t\t\t\\\n\t} while (0)\n\n/* instruction has only one source operand, destination is implicit (e.g. mul, div, imul, idiv) */\n#define emulate_1op_rax_rdx(ctxt, _op, _ex)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tswitch((ctxt)->src.bytes) {\t\t\t\t\\\n\t\tcase 1:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"b\", _ex);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"w\", _ex);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"l\", _ex);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 8: ON64(\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"q\", _ex));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    enum x86_intercept intercept,\n\t\t\t\t    enum x86_intercept_stage stage)\n{\n\tstruct x86_instruction_info info = {\n\t\t.intercept  = intercept,\n\t\t.rep_prefix = ctxt->rep_prefix,\n\t\t.modrm_mod  = ctxt->modrm_mod,\n\t\t.modrm_reg  = ctxt->modrm_reg,\n\t\t.modrm_rm   = ctxt->modrm_rm,\n\t\t.src_val    = ctxt->src.val64,\n\t\t.src_bytes  = ctxt->src.bytes,\n\t\t.dst_bytes  = ctxt->dst.bytes,\n\t\t.ad_bytes   = ctxt->ad_bytes,\n\t\t.next_rip   = ctxt->eip,\n\t};\n\n\treturn ctxt->ops->intercept(ctxt, &info, stage);\n}\n\nstatic inline unsigned long ad_mask(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (1UL << (ctxt->ad_bytes << 3)) - 1;\n}\n\n/* Access/update address held in a register, based on addressing mode. */\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}\n\nstatic inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\treturn address_mask(ctxt, reg);\n}\n\nstatic inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, unsigned long *reg, int inc)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\t*reg += inc;\n\telse\n\t\t*reg = (*reg & ~ad_mask(ctxt)) | ((*reg + inc) & ad_mask(ctxt));\n}\n\nstatic inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tregister_address_increment(ctxt, &ctxt->_eip, rel);\n}\n\nstatic u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}\n\nstatic void set_seg_override(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tctxt->has_seg_override = true;\n\tctxt->seg_override = seg;\n}\n\nstatic unsigned long seg_base(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && seg < VCPU_SREG_FS)\n\t\treturn 0;\n\n\treturn ctxt->ops->get_cached_segment_base(ctxt, seg);\n}\n\nstatic unsigned seg_override(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!ctxt->has_seg_override)\n\t\treturn 0;\n\n\treturn ctxt->seg_override;\n}\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}\n\nstatic int emulate_db(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DB_VECTOR, 0, false);\n}\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}\n\nstatic int emulate_ss(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, SS_VECTOR, err, true);\n}\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}\n\nstatic int emulate_ts(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, TS_VECTOR, err, true);\n}\n\nstatic int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}\n\nstatic int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}\n\nstatic void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}\n\nstatic int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write, bool fetch,\n\t\t     ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\tunsigned cpl, rpl;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (((signed long)la << 16) >> 16 != la)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment or read-only data segment */\n\t\tif (((desc.type & 8) || !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif ((desc.type & 8) || !(desc.type & 4)) {\n\t\t\t/* expand-up segment */\n\t\t\tif (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)\n\t\t\t\tgoto bad;\n\t\t} else {\n\t\t\t/* exapand-down segment */\n\t\t\tif (addr.ea <= lim || (u32)(addr.ea + size - 1) <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t\tif (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tcpl = ctxt->ops->cpl(ctxt);\n\t\trpl = sel & 3;\n\t\tcpl = max(cpl, rpl);\n\t\tif (!(desc.type & 8)) {\n\t\t\t/* data segment */\n\t\t\tif (cpl > desc.dpl)\n\t\t\t\tgoto bad;\n\t\t} else if ((desc.type & 8) && !(desc.type & 4)) {\n\t\t\t/* nonconforming code segment */\n\t\t\tif (cpl != desc.dpl)\n\t\t\t\tgoto bad;\n\t\t} else if ((desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* conforming code segment */\n\t\t\tif (cpl < desc.dpl)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (fetch ? ctxt->mode != X86EMUL_MODE_PROT64 : ctxt->ad_bytes != 8)\n\t\tla &= (u32)-1;\n\t*linear = la;\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, addr.seg);\n\telse\n\t\treturn emulate_gp(ctxt, addr.seg);\n}\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\treturn __linearize(ctxt, addr, size, write, false, linear);\n}\n\n\nstatic int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct segmented_address addr,\n\t\t\t      void *data,\n\t\t\t      unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n}\n\n/*\n * Fetch the next byte of the instruction being emulated which is pointed to\n * by ctxt->_eip, then increment ctxt->_eip.\n *\n * Also prefetch the remaining bytes of the instruction without crossing page\n * boundary if they are not in fetch_cache yet.\n */\nstatic int do_insn_fetch_byte(struct x86_emulate_ctxt *ctxt, u8 *dest)\n{\n\tstruct fetch_cache *fc = &ctxt->fetch;\n\tint rc;\n\tint size, cur_size;\n\n\tif (ctxt->_eip == fc->end) {\n\t\tunsigned long linear;\n\t\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t\t  .ea  = ctxt->_eip };\n\t\tcur_size = fc->end - fc->start;\n\t\tsize = min(15UL - cur_size,\n\t\t\t   PAGE_SIZE - offset_in_page(ctxt->_eip));\n\t\trc = __linearize(ctxt, addr, size, false, true, &linear);\n\t\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\t\treturn rc;\n\t\trc = ctxt->ops->fetch(ctxt, linear, fc->data + cur_size,\n\t\t\t\t      size, &ctxt->exception);\n\t\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\t\treturn rc;\n\t\tfc->end += size;\n\t}\n\t*dest = fc->data[ctxt->_eip - fc->start];\n\tctxt->_eip++;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t void *dest, unsigned size)\n{\n\tint rc;\n\n\t/* x86 instructions are limited to 15 bytes. */\n\tif (unlikely(ctxt->_eip + size - ctxt->eip > 15))\n\t\treturn X86EMUL_UNHANDLEABLE;\n\twhile (size--) {\n\t\trc = do_insn_fetch_byte(ctxt, dest++);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\n/* Fetch next part of the instruction being emulated. */\n#define insn_fetch(_type, _ctxt)\t\t\t\t\t\\\n({\tunsigned long _x;\t\t\t\t\t\t\\\n\trc = do_insn_fetch(_ctxt, &_x, sizeof(_type));\t\t\t\\\n\tif (rc != X86EMUL_CONTINUE)\t\t\t\t\t\\\n\t\tgoto done;\t\t\t\t\t\t\\\n\t(_type)_x;\t\t\t\t\t\t\t\\\n})\n\n#define insn_fetch_arr(_arr, _size, _ctxt)\t\t\t\t\\\n({\trc = do_insn_fetch(_ctxt, _arr, (_size));\t\t\t\\\n\tif (rc != X86EMUL_CONTINUE)\t\t\t\t\t\\\n\t\tgoto done;\t\t\t\t\t\t\\\n})\n\n/*\n * Given the 'reg' portion of a ModRM byte, and a register block, return a\n * pointer into the block that addresses the relevant register.\n * @highbyte_regs specifies whether to decode AH,CH,DH,BH.\n */\nstatic void *decode_register(u8 modrm_reg, unsigned long *regs,\n\t\t\t     int highbyte_regs)\n{\n\tvoid *p;\n\n\tp = &regs[modrm_reg];\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)&regs[modrm_reg & 3] + 1;\n\treturn p;\n}\n\nstatic int read_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   u16 *size, unsigned long *address, int op_bytes)\n{\n\tint rc;\n\n\tif (op_bytes == 2)\n\t\top_bytes = 3;\n\t*address = 0;\n\trc = segmented_read_std(ctxt, addr, size, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\taddr.ea += 2;\n\trc = segmented_read_std(ctxt, addr, address, op_bytes);\n\treturn rc;\n}\n\nstatic int test_cc(unsigned int condition, unsigned int flags)\n{\n\tint rc = 0;\n\n\tswitch ((condition & 15) >> 1) {\n\tcase 0: /* o */\n\t\trc |= (flags & EFLG_OF);\n\t\tbreak;\n\tcase 1: /* b/c/nae */\n\t\trc |= (flags & EFLG_CF);\n\t\tbreak;\n\tcase 2: /* z/e */\n\t\trc |= (flags & EFLG_ZF);\n\t\tbreak;\n\tcase 3: /* be/na */\n\t\trc |= (flags & (EFLG_CF|EFLG_ZF));\n\t\tbreak;\n\tcase 4: /* s */\n\t\trc |= (flags & EFLG_SF);\n\t\tbreak;\n\tcase 5: /* p/pe */\n\t\trc |= (flags & EFLG_PF);\n\t\tbreak;\n\tcase 7: /* le/ng */\n\t\trc |= (flags & EFLG_ZF);\n\t\t/* fall through */\n\tcase 6: /* l/nge */\n\t\trc |= (!(flags & EFLG_SF) != !(flags & EFLG_OF));\n\t\tbreak;\n\t}\n\n\t/* Odd condition identifiers (lsb == 1) have inverted sense. */\n\treturn (!!rc ^ (condition & 1));\n}\n\nstatic void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}\n\nstatic void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqu %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqu %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqu %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqu %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqu %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqu %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqu %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqu %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqu %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqu %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqu %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqu %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqu %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqu %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqu %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqu %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}\n\nstatic void write_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data,\n\t\t\t  int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqu %0, %%xmm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movdqu %0, %%xmm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movdqu %0, %%xmm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movdqu %0, %%xmm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movdqu %0, %%xmm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movdqu %0, %%xmm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movdqu %0, %%xmm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movdqu %0, %%xmm7\" : : \"m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqu %0, %%xmm8\" : : \"m\"(*data)); break;\n\tcase 9: asm(\"movdqu %0, %%xmm9\" : : \"m\"(*data)); break;\n\tcase 10: asm(\"movdqu %0, %%xmm10\" : : \"m\"(*data)); break;\n\tcase 11: asm(\"movdqu %0, %%xmm11\" : : \"m\"(*data)); break;\n\tcase 12: asm(\"movdqu %0, %%xmm12\" : : \"m\"(*data)); break;\n\tcase 13: asm(\"movdqu %0, %%xmm13\" : : \"m\"(*data)); break;\n\tcase 14: asm(\"movdqu %0, %%xmm14\" : : \"m\"(*data)); break;\n\tcase 15: asm(\"movdqu %0, %%xmm15\" : : \"m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}\n\nstatic void decode_register_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    struct operand *op,\n\t\t\t\t    int inhibit_bytereg)\n{\n\tunsigned reg = ctxt->modrm_reg;\n\tint highbyte_regs = ctxt->rex_prefix == 0;\n\n\tif (!(ctxt->d & ModRM))\n\t\treg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);\n\n\tif (ctxt->d & Sse) {\n\t\top->type = OP_XMM;\n\t\top->bytes = 16;\n\t\top->addr.xmm = reg;\n\t\tread_sse_reg(ctxt, &op->vec_val, reg);\n\t\treturn;\n\t}\n\n\top->type = OP_REG;\n\tif ((ctxt->d & ByteOp) && !inhibit_bytereg) {\n\t\top->addr.reg = decode_register(reg, ctxt->regs, highbyte_regs);\n\t\top->bytes = 1;\n\t} else {\n\t\top->addr.reg = decode_register(reg, ctxt->regs, 0);\n\t\top->bytes = ctxt->op_bytes;\n\t}\n\tfetch_register_operand(op);\n\top->orig_val = op->val;\n}\n\nstatic int decode_modrm(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct operand *op)\n{\n\tu8 sib;\n\tint index_reg = 0, base_reg = 0, scale;\n\tint rc = X86EMUL_CONTINUE;\n\tulong modrm_ea = 0;\n\n\tif (ctxt->rex_prefix) {\n\t\tctxt->modrm_reg = (ctxt->rex_prefix & 4) << 1;\t/* REX.R */\n\t\tindex_reg = (ctxt->rex_prefix & 2) << 2; /* REX.X */\n\t\tctxt->modrm_rm = base_reg = (ctxt->rex_prefix & 1) << 3; /* REG.B */\n\t}\n\n\tctxt->modrm = insn_fetch(u8, ctxt);\n\tctxt->modrm_mod |= (ctxt->modrm & 0xc0) >> 6;\n\tctxt->modrm_reg |= (ctxt->modrm & 0x38) >> 3;\n\tctxt->modrm_rm |= (ctxt->modrm & 0x07);\n\tctxt->modrm_seg = VCPU_SREG_DS;\n\n\tif (ctxt->modrm_mod == 3) {\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = decode_register(ctxt->modrm_rm,\n\t\t\t\t\t       ctxt->regs, ctxt->d & ByteOp);\n\t\tif (ctxt->d & Sse) {\n\t\t\top->type = OP_XMM;\n\t\t\top->bytes = 16;\n\t\t\top->addr.xmm = ctxt->modrm_rm;\n\t\t\tread_sse_reg(ctxt, &op->vec_val, ctxt->modrm_rm);\n\t\t\treturn rc;\n\t\t}\n\t\tfetch_register_operand(op);\n\t\treturn rc;\n\t}\n\n\top->type = OP_MEM;\n\n\tif (ctxt->ad_bytes == 2) {\n\t\tunsigned bx = ctxt->regs[VCPU_REGS_RBX];\n\t\tunsigned bp = ctxt->regs[VCPU_REGS_RBP];\n\t\tunsigned si = ctxt->regs[VCPU_REGS_RSI];\n\t\tunsigned di = ctxt->regs[VCPU_REGS_RDI];\n\n\t\t/* 16-bit ModR/M decode. */\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 6)\n\t\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ctxt->modrm_rm) {\n\t\tcase 0:\n\t\t\tmodrm_ea += bx + si;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += bx + di;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += bp + si;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmodrm_ea += bp + di;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmodrm_ea += si;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmodrm_ea += di;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (ctxt->modrm_mod != 0)\n\t\t\t\tmodrm_ea += bp;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmodrm_ea += bx;\n\t\t\tbreak;\n\t\t}\n\t\tif (ctxt->modrm_rm == 2 || ctxt->modrm_rm == 3 ||\n\t\t    (ctxt->modrm_rm == 6 && ctxt->modrm_mod != 0))\n\t\t\tctxt->modrm_seg = VCPU_SREG_SS;\n\t\tmodrm_ea = (u16)modrm_ea;\n\t} else {\n\t\t/* 32/64-bit ModR/M decode. */\n\t\tif ((ctxt->modrm_rm & 7) == 4) {\n\t\t\tsib = insn_fetch(u8, ctxt);\n\t\t\tindex_reg |= (sib >> 3) & 7;\n\t\t\tbase_reg |= sib & 7;\n\t\t\tscale = sib >> 6;\n\n\t\t\tif ((base_reg & 7) == 5 && ctxt->modrm_mod == 0)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\telse\n\t\t\t\tmodrm_ea += ctxt->regs[base_reg];\n\t\t\tif (index_reg != 4)\n\t\t\t\tmodrm_ea += ctxt->regs[index_reg] << scale;\n\t\t} else if ((ctxt->modrm_rm & 7) == 5 && ctxt->modrm_mod == 0) {\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->rip_relative = 1;\n\t\t} else\n\t\t\tmodrm_ea += ctxt->regs[ctxt->modrm_rm];\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 5)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\t}\n\t}\n\top->addr.mem.ea = modrm_ea;\ndone:\n\treturn rc;\n}\n\nstatic int decode_abs(struct x86_emulate_ctxt *ctxt,\n\t\t      struct operand *op)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_MEM;\n\tswitch (ctxt->ad_bytes) {\n\tcase 2:\n\t\top->addr.mem.ea = insn_fetch(u16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->addr.mem.ea = insn_fetch(u32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->addr.mem.ea = insn_fetch(u64, ctxt);\n\t\tbreak;\n\t}\ndone:\n\treturn rc;\n}\n\nstatic void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~(ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\n\t\tctxt->dst.addr.mem.ea += (sv >> 3);\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}\n\nstatic int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\twhile (size) {\n\t\tint n = min(size, 8u);\n\t\tsize -= n;\n\t\tif (mc->pos < mc->end)\n\t\t\tgoto read_cached;\n\n\t\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, n,\n\t\t\t\t\t      &ctxt->exception);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\tmc->end += n;\n\n\tread_cached:\n\t\tmemcpy(dest, mc->data + mc->pos, n);\n\t\tmc->pos += n;\n\t\tdest += n;\n\t\taddr += n;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}\n\nstatic int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}\n\nstatic int segmented_cmpxchg(struct x86_emulate_ctxt *ctxt,\n\t\t\t     struct segmented_address addr,\n\t\t\t     const void *orig_data, const void *data,\n\t\t\t     unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->cmpxchg_emulated(ctxt, linear, orig_data, data,\n\t\t\t\t\t   size, &ctxt->exception);\n}\n\nstatic int pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t   unsigned int size, unsigned short port,\n\t\t\t   void *dest)\n{\n\tstruct read_cache *rc = &ctxt->io_read;\n\n\tif (rc->pos == rc->end) { /* refill pio read ahead */\n\t\tunsigned int in_page, n;\n\t\tunsigned int count = ctxt->rep_prefix ?\n\t\t\taddress_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) : 1;\n\t\tin_page = (ctxt->eflags & EFLG_DF) ?\n\t\t\toffset_in_page(ctxt->regs[VCPU_REGS_RDI]) :\n\t\t\tPAGE_SIZE - offset_in_page(ctxt->regs[VCPU_REGS_RDI]);\n\t\tn = min(min(in_page, (unsigned int)sizeof(rc->data)) / size,\n\t\t\tcount);\n\t\tif (n == 0)\n\t\t\tn = 1;\n\t\trc->pos = rc->end = 0;\n\t\tif (!ctxt->ops->pio_in_emulated(ctxt, size, port, rc->data, n))\n\t\t\treturn 0;\n\t\trc->end = n * size;\n\t}\n\n\tmemcpy(dest, rc->data + rc->pos, size);\n\trc->pos += size;\n\treturn 1;\n}\n\nstatic void get_descriptor_table_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, struct desc_ptr *dt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\n\tif (selector & 1 << 2) {\n\t\tstruct desc_struct desc;\n\t\tu16 sel;\n\n\t\tmemset (dt, 0, sizeof *dt);\n\t\tif (!ops->get_segment(ctxt, &sel, &desc, NULL, VCPU_SREG_LDTR))\n\t\t\treturn;\n\n\t\tdt->size = desc_limit_scaled(&desc); /* what if limit > 65535? */\n\t\tdt->address = get_desc_base(&desc);\n\t} else\n\t\tops->get_gdt(ctxt, dt);\n}\n\n/* allowed just for 8 bytes segments */\nstatic int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->read_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t   &ctxt->exception);\n}\n\n/* allowed just for 8 bytes segments */\nstatic int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}\n\n/* Does not support long mode */\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tstruct desc_struct seg_desc;\n\tu8 dpl, rpl, cpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tint ret;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif ((seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86)\n\t    || ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tgoto load;\n\t}\n\n\t/* NULL selector is not valid for TR, CS and SS */\n\tif ((seg == VCPU_SREG_CS || seg == VCPU_SREG_SS || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = GP_VECTOR;\n\n\t/* can't load system descriptor into segment selecor */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s)\n\t\tgoto exception;\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\trpl = selector & 3;\n\tdpl = seg_desc.dpl;\n\tcpl = ctxt->ops->cpl(ctxt);\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tseg_desc.type |= 1;\n\t\tret = write_segment_descriptor(ctxt, selector, &seg_desc);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, 0, seg);\n\treturn X86EMUL_CONTINUE;\nexception:\n\temulate_exception(ctxt, err_vec, err_code, true);\n\treturn X86EMUL_PROPAGATE_FAULT;\n}\n\nstatic void write_register_operand(struct operand *op)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\t*(u8 *)op->addr.reg = (u8)op->val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)op->addr.reg = (u16)op->val;\n\t\tbreak;\n\tcase 4:\n\t\t*op->addr.reg = (u32)op->val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*op->addr.reg = op->val;\n\t\tbreak;\n\t}\n}\n\nstatic int writeback(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\tswitch (ctxt->dst.type) {\n\tcase OP_REG:\n\t\twrite_register_operand(&ctxt->dst);\n\t\tbreak;\n\tcase OP_MEM:\n\t\tif (ctxt->lock_prefix)\n\t\t\trc = segmented_cmpxchg(ctxt,\n\t\t\t\t\t       ctxt->dst.addr.mem,\n\t\t\t\t\t       &ctxt->dst.orig_val,\n\t\t\t\t\t       &ctxt->dst.val,\n\t\t\t\t\t       ctxt->dst.bytes);\n\t\telse\n\t\t\trc = segmented_write(ctxt,\n\t\t\t\t\t     ctxt->dst.addr.mem,\n\t\t\t\t\t     &ctxt->dst.val,\n\t\t\t\t\t     ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\tbreak;\n\tcase OP_XMM:\n\t\twrite_sse_reg(ctxt, &ctxt->dst.vec_val, ctxt->dst.addr.xmm);\n\t\tbreak;\n\tcase OP_NONE:\n\t\t/* no writeback */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_push(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct segmented_address addr;\n\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP], -ctxt->op_bytes);\n\taddr.ea = register_address(ctxt, ctxt->regs[VCPU_REGS_RSP]);\n\taddr.seg = VCPU_SREG_SS;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, addr, &ctxt->src.val, ctxt->op_bytes);\n}\n\nstatic int emulate_pop(struct x86_emulate_ctxt *ctxt,\n\t\t       void *dest, int len)\n{\n\tint rc;\n\tstruct segmented_address addr;\n\n\taddr.ea = register_address(ctxt, ctxt->regs[VCPU_REGS_RSP]);\n\taddr.seg = VCPU_SREG_SS;\n\trc = segmented_read(ctxt, addr, dest, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP], len);\n\treturn rc;\n}\n\nstatic int em_pop(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> IOPL_SHIFT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = EFLG_CF | EFLG_PF | EFLG_AF | EFLG_ZF | EFLG_SF | EFLG_OF\n\t\t| EFLG_TF | EFLG_DF | EFLG_NT | EFLG_RF | EFLG_AC | EFLG_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= EFLG_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= EFLG_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= EFLG_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (EFLG_IOPL | EFLG_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}\n\nstatic int em_popf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->eflags;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn emulate_popf(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}\n\nstatic int em_push_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\n\tctxt->src.val = get_segment_selector(ctxt, seg);\n\n\treturn em_push(ctxt);\n}\n\nstatic int em_pop_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned long selector;\n\tint rc;\n\n\trc = emulate_pop(ctxt, &selector, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)selector, seg);\n\treturn rc;\n}\n\nstatic int em_pusha(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long old_esp = ctxt->regs[VCPU_REGS_RSP];\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RAX;\n\n\twhile (reg <= VCPU_REGS_RDI) {\n\t\t(reg == VCPU_REGS_RSP) ?\n\t\t(ctxt->src.val = old_esp) : (ctxt->src.val = ctxt->regs[reg]);\n\n\t\trc = em_push(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\n\t\t++reg;\n\t}\n\n\treturn rc;\n}\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val =  (unsigned long)ctxt->eflags;\n\treturn em_push(ctxt);\n}\n\nstatic int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP],\n\t\t\t\t\t\t\tctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\n\t\trc = emulate_pop(ctxt, &ctxt->regs[reg], ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\t--reg;\n\t}\n\treturn rc;\n}\n\nint emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(EFLG_IF | EFLG_TF | EFLG_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}\n\nstatic int emulate_int(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn emulate_int_real(ctxt, irq);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* Protected mode interrupts unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}\n\nstatic int emulate_iret_real(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tunsigned long temp_eip = 0;\n\tunsigned long temp_eflags = 0;\n\tunsigned long cs = 0;\n\tunsigned long mask = EFLG_CF | EFLG_PF | EFLG_AF | EFLG_ZF | EFLG_SF | EFLG_TF |\n\t\t\t     EFLG_IF | EFLG_DF | EFLG_OF | EFLG_IOPL | EFLG_NT | EFLG_RF |\n\t\t\t     EFLG_AC | EFLG_ID | (1 << 1); /* Last one is the reserved bit */\n\tunsigned long vm86_mask = EFLG_VM | EFLG_VIF | EFLG_VIP;\n\n\t/* TODO: Add stack limit check */\n\n\trc = emulate_pop(ctxt, &temp_eip, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (temp_eip & ~0xffff)\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = emulate_pop(ctxt, &temp_eflags, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = temp_eip;\n\n\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->eflags = ((temp_eflags & mask) | (ctxt->eflags & vm86_mask));\n\telse if (ctxt->op_bytes == 2) {\n\t\tctxt->eflags &= ~0xffff;\n\t\tctxt->eflags |= temp_eflags;\n\t}\n\n\tctxt->eflags &= ~EFLG_RESERVED_ZEROS_MASK; /* Clear reserved zeros */\n\tctxt->eflags |= EFLG_RESERVED_ONE_MASK;\n\n\treturn rc;\n}\n\nstatic int em_iret(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn emulate_iret_real(ctxt);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* iret from protected mode unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}\n\nstatic int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = load_segment_descriptor(ctxt, sel, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = 0;\n\tmemcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_grp2(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch (ctxt->modrm_reg) {\n\tcase 0:\t/* rol */\n\t\temulate_2op_SrcB(ctxt, \"rol\");\n\t\tbreak;\n\tcase 1:\t/* ror */\n\t\temulate_2op_SrcB(ctxt, \"ror\");\n\t\tbreak;\n\tcase 2:\t/* rcl */\n\t\temulate_2op_SrcB(ctxt, \"rcl\");\n\t\tbreak;\n\tcase 3:\t/* rcr */\n\t\temulate_2op_SrcB(ctxt, \"rcr\");\n\t\tbreak;\n\tcase 4:\t/* sal/shl */\n\tcase 6:\t/* sal/shl */\n\t\temulate_2op_SrcB(ctxt, \"sal\");\n\t\tbreak;\n\tcase 5:\t/* shr */\n\t\temulate_2op_SrcB(ctxt, \"shr\");\n\t\tbreak;\n\tcase 7:\t/* sar */\n\t\temulate_2op_SrcB(ctxt, \"sar\");\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_not(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ~ctxt->dst.val;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_neg(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_1op(ctxt, \"neg\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mul_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 ex = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"mul\", ex);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_imul_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 ex = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"imul\", ex);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_div_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 de = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"div\", de);\n\tif (de)\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_idiv_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 de = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"idiv\", de);\n\tif (de)\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (ctxt->modrm_reg) {\n\tcase 0:\t/* inc */\n\t\temulate_1op(ctxt, \"inc\");\n\t\tbreak;\n\tcase 1:\t/* dec */\n\t\temulate_1op(ctxt, \"dec\");\n\t\tbreak;\n\tcase 2: /* call near abs */ {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: /* jmp abs */\n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: /* jmp far */\n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t/* push */\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 old = ctxt->dst.orig_val64;\n\n\tif (((u32) (old >> 0) != (u32) ctxt->regs[VCPU_REGS_RAX]) ||\n\t    ((u32) (old >> 32) != (u32) ctxt->regs[VCPU_REGS_RDX])) {\n\t\tctxt->regs[VCPU_REGS_RAX] = (u32) (old >> 0);\n\t\tctxt->regs[VCPU_REGS_RDX] = (u32) (old >> 32);\n\t\tctxt->eflags &= ~EFLG_ZF;\n\t} else {\n\t\tctxt->dst.val64 = ((u64)ctxt->regs[VCPU_REGS_RCX] << 32) |\n\t\t\t(u32) ctxt->regs[VCPU_REGS_RBX];\n\n\t\tctxt->eflags |= EFLG_ZF;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn em_pop(ctxt);\n}\n\nstatic int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long cs;\n\n\trc = emulate_pop(ctxt, &ctxt->_eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->_eip = (u32)ctxt->_eip;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\treturn rc;\n}\n\nstatic int em_cmpxchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Save real source value, then compare EAX against destination. */\n\tctxt->src.orig_val = ctxt->src.val;\n\tctxt->src.val = ctxt->regs[VCPU_REGS_RAX];\n\temulate_2op_SrcV(ctxt, \"cmp\");\n\n\tif (ctxt->eflags & EFLG_ZF) {\n\t\t/* Success: write back to memory. */\n\t\tctxt->dst.val = ctxt->src.orig_val;\n\t} else {\n\t\t/* Failure: write the value we saw to EAX. */\n\t\tctxt->dst.type = OP_REG;\n\t\tctxt->dst.addr.reg = (unsigned long *)&ctxt->regs[VCPU_REGS_RAX];\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_lseg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned short sel;\n\tint rc;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = load_segment_descriptor(ctxt, sel, seg);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->dst.val = ctxt->src.val;\n\treturn rc;\n}\n\nstatic void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tu16 selector;\n\n\tmemset(cs, 0, sizeof(struct desc_struct));\n\tctxt->ops->get_segment(ctxt, &selector, cs, NULL, VCPU_SREG_CS);\n\tmemset(ss, 0, sizeof(struct desc_struct));\n\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n}\n\nstatic int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\t/* inject #GP if in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* XXX sysenter/sysexit have not been tested in 64bit mode.\n\t* Therefore, we inject an #UD.\n\t*/\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_ud(ctxt);\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\t}\n\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\tctxt->regs[VCPU_REGS_RSP] = msr_data;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\n\t/* inject #GP if in real mode or Virtual 8086 mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->_eip = ctxt->regs[VCPU_REGS_RDX];\n\tctxt->regs[VCPU_REGS_RSP] = ctxt->regs[VCPU_REGS_RCX];\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> IOPL_SHIFT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}\n\nstatic bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}\n\nstatic void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = ctxt->regs[VCPU_REGS_RAX];\n\ttss->cx = ctxt->regs[VCPU_REGS_RCX];\n\ttss->dx = ctxt->regs[VCPU_REGS_RDX];\n\ttss->bx = ctxt->regs[VCPU_REGS_RBX];\n\ttss->sp = ctxt->regs[VCPU_REGS_RSP];\n\ttss->bp = ctxt->regs[VCPU_REGS_RBP];\n\ttss->si = ctxt->regs[VCPU_REGS_RSI];\n\ttss->di = ctxt->regs[VCPU_REGS_RDI];\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}\n\nstatic int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\n\tctxt->_eip = tss->ip;\n\tctxt->eflags = tss->flag | 2;\n\tctxt->regs[VCPU_REGS_RAX] = tss->ax;\n\tctxt->regs[VCPU_REGS_RCX] = tss->cx;\n\tctxt->regs[VCPU_REGS_RDX] = tss->dx;\n\tctxt->regs[VCPU_REGS_RBX] = tss->bx;\n\tctxt->regs[VCPU_REGS_RSP] = tss->sp;\n\tctxt->regs[VCPU_REGS_RBP] = tss->bp;\n\tctxt->regs[VCPU_REGS_RSI] = tss->si;\n\tctxt->regs[VCPU_REGS_RDI] = tss->di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t/* FIXME: need to provide precise fault address */\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}\n\nstatic void save_state_to_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_32 *tss)\n{\n\ttss->cr3 = ctxt->ops->get_cr(ctxt, 3);\n\ttss->eip = ctxt->_eip;\n\ttss->eflags = ctxt->eflags;\n\ttss->eax = ctxt->regs[VCPU_REGS_RAX];\n\ttss->ecx = ctxt->regs[VCPU_REGS_RCX];\n\ttss->edx = ctxt->regs[VCPU_REGS_RDX];\n\ttss->ebx = ctxt->regs[VCPU_REGS_RBX];\n\ttss->esp = ctxt->regs[VCPU_REGS_RSP];\n\ttss->ebp = ctxt->regs[VCPU_REGS_RBP];\n\ttss->esi = ctxt->regs[VCPU_REGS_RSI];\n\ttss->edi = ctxt->regs[VCPU_REGS_RDI];\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->fs = get_segment_selector(ctxt, VCPU_SREG_FS);\n\ttss->gs = get_segment_selector(ctxt, VCPU_SREG_GS);\n\ttss->ldt_selector = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}\n\nstatic int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_32 *tss)\n{\n\tint ret;\n\n\tif (ctxt->ops->set_cr(ctxt, 3, tss->cr3))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->_eip = tss->eip;\n\tctxt->eflags = tss->eflags | 2;\n\tctxt->regs[VCPU_REGS_RAX] = tss->eax;\n\tctxt->regs[VCPU_REGS_RCX] = tss->ecx;\n\tctxt->regs[VCPU_REGS_RDX] = tss->edx;\n\tctxt->regs[VCPU_REGS_RBX] = tss->ebx;\n\tctxt->regs[VCPU_REGS_RSP] = tss->esp;\n\tctxt->regs[VCPU_REGS_RBP] = tss->ebp;\n\tctxt->regs[VCPU_REGS_RSI] = tss->esi;\n\tctxt->regs[VCPU_REGS_RDI] = tss->edi;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\tset_segment_selector(ctxt, tss->fs, VCPU_SREG_FS);\n\tset_segment_selector(ctxt, tss->gs, VCPU_SREG_GS);\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int task_switch_32(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_32 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tsave_state_to_tss32(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t/* FIXME: need to provide precise fault address */\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss32(ctxt, &tss_seg);\n}\n\nstatic int emulator_do_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 tss_selector, int reason,\n\t\t\t\t   bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct curr_tss_desc, next_tss_desc;\n\tint ret;\n\tu16 old_tss_sel = get_segment_selector(ctxt, VCPU_SREG_TR);\n\tulong old_tss_base =\n\t\tops->get_cached_segment_base(ctxt, VCPU_SREG_TR);\n\tu32 desc_limit;\n\n\t/* FIXME: old_tss_base == ~0 ? */\n\n\tret = read_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = read_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\t/* FIXME: check that next_tss_desc is tss */\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tif ((tss_selector & 3) > next_tss_desc.dpl ||\n\t\t    ops->cpl(ctxt) > next_tss_desc.dpl)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\n\n\tdesc_limit = desc_limit_scaled(&next_tss_desc);\n\tif (!next_tss_desc.p ||\n\t    ((desc_limit < 0x67 && (next_tss_desc.type & 8)) ||\n\t     desc_limit < 0x2b)) {\n\t\temulate_ts(ctxt, tss_selector & 0xfffc);\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t}\n\n\tif (reason == TASK_SWITCH_IRET || reason == TASK_SWITCH_JMP) {\n\t\tcurr_tss_desc.type &= ~(1 << 1); /* clear busy flag */\n\t\twrite_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET)\n\t\tctxt->eflags = ctxt->eflags & ~X86_EFLAGS_NT;\n\n\t/* set back link to prev task only if NT bit is set in eflags\n\t   note that old_tss_sel is not used afetr this point */\n\tif (reason != TASK_SWITCH_CALL && reason != TASK_SWITCH_GATE)\n\t\told_tss_sel = 0xffff;\n\n\tif (next_tss_desc.type & 8)\n\t\tret = task_switch_32(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\telse\n\t\tret = task_switch_16(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (reason == TASK_SWITCH_CALL || reason == TASK_SWITCH_GATE)\n\t\tctxt->eflags = ctxt->eflags | X86_EFLAGS_NT;\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tnext_tss_desc.type |= (1 << 1); /* set busy flag */\n\t\twrite_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\t}\n\n\tops->set_cr(ctxt, 0,  ops->get_cr(ctxt, 0) | X86_CR0_TS);\n\tops->set_segment(ctxt, tss_selector, &next_tss_desc, 0, VCPU_SREG_TR);\n\n\tif (has_error_code) {\n\t\tctxt->op_bytes = ctxt->ad_bytes = (next_tss_desc.type & 8) ? 4 : 2;\n\t\tctxt->lock_prefix = 0;\n\t\tctxt->src.val = (unsigned long) error_code;\n\t\tret = em_push(ctxt);\n\t}\n\n\treturn ret;\n}\n\nint emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int reason,\n\t\t\t bool has_error_code, u32 error_code)\n{\n\tint rc;\n\n\tctxt->_eip = ctxt->eip;\n\tctxt->dst.type = OP_NONE;\n\n\trc = emulator_do_task_switch(ctxt, tss_selector, reason,\n\t\t\t\t     has_error_code, error_code);\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->eip = ctxt->_eip;\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n}\n\nstatic void string_addr_inc(struct x86_emulate_ctxt *ctxt, unsigned seg,\n\t\t\t    int reg, struct operand *op)\n{\n\tint df = (ctxt->eflags & EFLG_DF) ? -1 : 1;\n\n\tregister_address_increment(ctxt, &ctxt->regs[reg], df * op->bytes);\n\top->addr.mem.ea = register_address(ctxt, ctxt->regs[reg]);\n\top->addr.mem.seg = seg;\n}\n\nstatic int em_das(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al, old_al;\n\tbool af, cf, old_cf;\n\n\tcf = ctxt->eflags & X86_EFLAGS_CF;\n\tal = ctxt->dst.val;\n\n\told_al = al;\n\told_cf = cf;\n\tcf = false;\n\taf = ctxt->eflags & X86_EFLAGS_AF;\n\tif ((al & 0x0f) > 9 || af) {\n\t\tal -= 6;\n\t\tcf = old_cf | (al >= 250);\n\t\taf = true;\n\t} else {\n\t\taf = false;\n\t}\n\tif (old_al > 0x99 || old_cf) {\n\t\tal -= 0x60;\n\t\tcf = true;\n\t}\n\n\tctxt->dst.val = al;\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\temulate_2op_SrcV(ctxt, \"or\");\n\tctxt->eflags &= ~(X86_EFLAGS_AF | X86_EFLAGS_CF);\n\tif (cf)\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\tif (af)\n\t\tctxt->eflags |= X86_EFLAGS_AF;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tlong rel = ctxt->src.val;\n\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\tjmp_rel(ctxt, rel);\n\treturn em_push(ctxt);\n}\n\nstatic int em_call_far(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel, old_cs;\n\tulong old_eip;\n\tint rc;\n\n\told_cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\told_eip = ctxt->_eip;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\tif (load_segment_descriptor(ctxt, sel, VCPU_SREG_CS))\n\t\treturn X86EMUL_CONTINUE;\n\n\tctxt->_eip = 0;\n\tmemcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);\n\n\tctxt->src.val = old_cs;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = old_eip;\n\treturn em_push(ctxt);\n}\n\nstatic int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP], ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_add(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"add\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_or(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"or\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_adc(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"adc\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sbb(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"sbb\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_and(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"and\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sub(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"sub\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_xor(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"xor\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_cmp(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"cmp\");\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_test(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"test\");\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_xchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Write back the register source. */\n\tctxt->src.val = ctxt->dst.val;\n\twrite_register_operand(&ctxt->src);\n\n\t/* Write back the memory destination with implicit LOCK prefix. */\n\tctxt->dst.val = ctxt->src.orig_val;\n\tctxt->lock_prefix = 1;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_imul(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"imul\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_imul_3op(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ctxt->src2.val;\n\treturn em_imul(ctxt);\n}\n\nstatic int em_cwd(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.bytes = ctxt->src.bytes;\n\tctxt->dst.addr.reg = &ctxt->regs[VCPU_REGS_RDX];\n\tctxt->dst.val = ~((ctxt->src.val >> (ctxt->src.bytes * 8 - 1)) - 1);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 tsc = 0;\n\n\tctxt->ops->get_msr(ctxt, MSR_IA32_TSC, &tsc);\n\tctxt->regs[VCPU_REGS_RAX] = (u32)tsc;\n\tctxt->regs[VCPU_REGS_RDX] = tsc >> 32;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 pmc;\n\n\tif (ctxt->ops->read_pmc(ctxt, ctxt->regs[VCPU_REGS_RCX], &pmc))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->regs[VCPU_REGS_RAX] = (u32)pmc;\n\tctxt->regs[VCPU_REGS_RDX] = pmc >> 32;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mov(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ctxt->src.val;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->ops->set_cr(ctxt, ctxt->modrm_reg, ctxt->src.val))\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long val;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tval = ctxt->src.val & ~0ULL;\n\telse\n\t\tval = ctxt->src.val & ~0U;\n\n\t/* #UD condition is already handled. */\n\tif (ctxt->ops->set_dr(ctxt, ctxt->modrm_reg, val) < 0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_wrmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tmsr_data = (u32)ctxt->regs[VCPU_REGS_RAX]\n\t\t| ((u64)ctxt->regs[VCPU_REGS_RDX] << 32);\n\tif (ctxt->ops->set_msr(ctxt, ctxt->regs[VCPU_REGS_RCX], msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_rdmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tif (ctxt->ops->get_msr(ctxt, ctxt->regs[VCPU_REGS_RCX], &msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->regs[VCPU_REGS_RAX] = (u32)msr_data;\n\tctxt->regs[VCPU_REGS_RDX] = msr_data >> 32;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mov_rm_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tctxt->dst.val = get_segment_selector(ctxt, ctxt->modrm_reg);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mov_sreg_rm(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\tif (ctxt->modrm_reg == VCPU_SREG_CS || ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tif (ctxt->modrm_reg == VCPU_SREG_SS)\n\t\tctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, ctxt->modrm_reg);\n}\n\nstatic int em_movdqu(struct x86_emulate_ctxt *ctxt)\n{\n\tmemcpy(&ctxt->dst.vec_val, &ctxt->src.vec_val, ctxt->op_bytes);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_invlpg(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, ctxt->src.addr.mem, 1, false, &linear);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->ops->invlpg(ctxt, linear);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_clts(struct x86_emulate_ctxt *ctxt)\n{\n\tulong cr0;\n\n\tcr0 = ctxt->ops->get_cr(ctxt, 0);\n\tcr0 &= ~X86_CR0_TS;\n\tctxt->ops->set_cr(ctxt, 0, cr0);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_vmcall(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\tif (ctxt->modrm_mod != 3 || ctxt->modrm_rm != 1)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\trc = ctxt->ops->fix_hypercall(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\t/* Let the processor re-execute the fixed hypercall */\n\tctxt->_eip = ctxt->eip;\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_lgdt(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_vmmcall(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\trc = ctxt->ops->fix_hypercall(ctxt);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn rc;\n}\n\nstatic int em_lidt(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_smsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = 2;\n\tctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_lmsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->set_cr(ctxt, 0, (ctxt->ops->get_cr(ctxt, 0) & ~0x0eul)\n\t\t\t  | (ctxt->src.val & 0x0f));\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RCX], -1);\n\tif ((address_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_in(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!pio_in_emulated(ctxt, ctxt->dst.bytes, ctxt->src.val,\n\t\t\t     &ctxt->dst.val))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->pio_out_emulated(ctxt, ctxt->src.bytes, ctxt->dst.val,\n\t\t\t\t    &ctxt->src.val, 1);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_cli(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->eflags &= ~X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sti(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->interruptibility = KVM_X86_SHADOW_INT_STI;\n\tctxt->eflags |= X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bts(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"bts\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_btr(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"btr\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_btc(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"btc\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bsf(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\n\t__asm__ (\"bsf %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\t/* Disable writeback. */\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\n\t__asm__ (\"bsr %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\t/* Disable writeback. */\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int check_cr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!valid_cr(ctxt->modrm_reg))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint cr = ctxt->modrm_reg;\n\tu64 efer = 0;\n\n\tstatic u64 cr_reserved_bits[] = {\n\t\t0xffffffff00000000ULL,\n\t\t0, 0, 0, /* CR3 checked later */\n\t\tCR4_RESERVED_BITS,\n\t\t0, 0, 0,\n\t\tCR8_RESERVED_BITS,\n\t};\n\n\tif (!valid_cr(cr))\n\t\treturn emulate_ud(ctxt);\n\n\tif (new_val & cr_reserved_bits[cr])\n\t\treturn emulate_gp(ctxt, 0);\n\n\tswitch (cr) {\n\tcase 0: {\n\t\tu64 cr4;\n\t\tif (((new_val & X86_CR0_PG) && !(new_val & X86_CR0_PE)) ||\n\t\t    ((new_val & X86_CR0_NW) && !(new_val & X86_CR0_CD)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((new_val & X86_CR0_PG) && (efer & EFER_LME) &&\n\t\t    !(cr4 & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 3: {\n\t\tu64 rsvd = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (efer & EFER_LMA)\n\t\t\trsvd = CR3_L_MODE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_PAE)\n\t\t\trsvd = CR3_PAE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 0) & X86_CR0_PG)\n\t\t\trsvd = CR3_NONPAE_RESERVED_BITS;\n\n\t\tif (new_val & rsvd)\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 4: {\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((efer & EFER_LMA) && !(new_val & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_dr7_gd(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long dr7;\n\n\tctxt->ops->get_dr(ctxt, 7, &dr7);\n\n\t/* Check if DR7.Global_Enable is set */\n\treturn dr7 & (1 << 13);\n}\n\nstatic int check_dr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tint dr = ctxt->modrm_reg;\n\tu64 cr4;\n\n\tif (dr > 7)\n\t\treturn emulate_ud(ctxt);\n\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif ((cr4 & X86_CR4_DE) && (dr == 4 || dr == 5))\n\t\treturn emulate_ud(ctxt);\n\n\tif (check_dr7_gd(ctxt))\n\t\treturn emulate_db(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint dr = ctxt->modrm_reg;\n\n\tif ((dr == 6 || dr == 7) && (new_val & 0xffffffff00000000ULL))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_dr_read(ctxt);\n}\n\nstatic int check_svme(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 efer;\n\n\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\tif (!(efer & EFER_SVME))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_svme_pa(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 rax = ctxt->regs[VCPU_REGS_RAX];\n\n\t/* Valid physical address? */\n\tif (rax & 0xffff000000000000ULL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_svme(ctxt);\n}\n\nstatic int check_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\n\tif (cr4 & X86_CR4_TSD && ctxt->ops->cpl(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\tu64 rcx = ctxt->regs[VCPU_REGS_RCX];\n\n\tif ((!(cr4 & X86_CR4_PCE) && ctxt->ops->cpl(ctxt)) ||\n\t    (rcx > 3))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_perm_in(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = min(ctxt->dst.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->src.val, ctxt->dst.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_perm_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.bytes = min(ctxt->src.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->dst.val, ctxt->src.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\n#define D(_y) { .flags = (_y) }\n#define DI(_y, _i) { .flags = (_y), .intercept = x86_intercept_##_i }\n#define DIP(_y, _i, _p) { .flags = (_y), .intercept = x86_intercept_##_i, \\\n\t\t      .check_perm = (_p) }\n#define N    D(0)\n#define EXT(_f, _e) { .flags = ((_f) | RMExt), .u.group = (_e) }\n#define G(_f, _g) { .flags = ((_f) | Group), .u.group = (_g) }\n#define GD(_f, _g) { .flags = ((_f) | GroupDual), .u.gdual = (_g) }\n#define I(_f, _e) { .flags = (_f), .u.execute = (_e) }\n#define II(_f, _e, _i) \\\n\t{ .flags = (_f), .u.execute = (_e), .intercept = x86_intercept_##_i }\n#define IIP(_f, _e, _i, _p) \\\n\t{ .flags = (_f), .u.execute = (_e), .intercept = x86_intercept_##_i, \\\n\t  .check_perm = (_p) }\n#define GP(_f, _g) { .flags = ((_f) | Prefix), .u.gprefix = (_g) }\n\n#define D2bv(_f)      D((_f) | ByteOp), D(_f)\n#define D2bvIP(_f, _i, _p) DIP((_f) | ByteOp, _i, _p), DIP(_f, _i, _p)\n#define I2bv(_f, _e)  I((_f) | ByteOp, _e), I(_f, _e)\n#define I2bvIP(_f, _e, _i, _p) \\\n\tIIP((_f) | ByteOp, _e, _i, _p), IIP(_f, _e, _i, _p)\n\n#define I6ALU(_f, _e) I2bv((_f) | DstMem | SrcReg | ModRM, _e),\t\t\\\n\t\tI2bv(((_f) | DstReg | SrcMem | ModRM) & ~Lock, _e),\t\\\n\t\tI2bv(((_f) & ~Lock) | DstAcc | SrcImm, _e)\n\nstatic struct opcode group7_rm1[] = {\n\tDI(SrcNone | ModRM | Priv, monitor),\n\tDI(SrcNone | ModRM | Priv, mwait),\n\tN, N, N, N, N, N,\n};\n\nstatic struct opcode group7_rm3[] = {\n\tDIP(SrcNone | ModRM | Prot | Priv, vmrun,   check_svme_pa),\n\tII(SrcNone | ModRM | Prot | VendorSpecific, em_vmmcall, vmmcall),\n\tDIP(SrcNone | ModRM | Prot | Priv, vmload,  check_svme_pa),\n\tDIP(SrcNone | ModRM | Prot | Priv, vmsave,  check_svme_pa),\n\tDIP(SrcNone | ModRM | Prot | Priv, stgi,    check_svme),\n\tDIP(SrcNone | ModRM | Prot | Priv, clgi,    check_svme),\n\tDIP(SrcNone | ModRM | Prot | Priv, skinit,  check_svme),\n\tDIP(SrcNone | ModRM | Prot | Priv, invlpga, check_svme),\n};\n\nstatic struct opcode group7_rm7[] = {\n\tN,\n\tDIP(SrcNone | ModRM, rdtscp, check_rdtsc),\n\tN, N, N, N, N, N,\n};\n\nstatic struct opcode group1[] = {\n\tI(Lock, em_add),\n\tI(Lock | PageTable, em_or),\n\tI(Lock, em_adc),\n\tI(Lock, em_sbb),\n\tI(Lock | PageTable, em_and),\n\tI(Lock, em_sub),\n\tI(Lock, em_xor),\n\tI(0, em_cmp),\n};\n\nstatic struct opcode group1A[] = {\n\tI(DstMem | SrcNone | ModRM | Mov | Stack, em_pop), N, N, N, N, N, N, N,\n};\n\nstatic struct opcode group3[] = {\n\tI(DstMem | SrcImm | ModRM, em_test),\n\tI(DstMem | SrcImm | ModRM, em_test),\n\tI(DstMem | SrcNone | ModRM | Lock, em_not),\n\tI(DstMem | SrcNone | ModRM | Lock, em_neg),\n\tI(SrcMem | ModRM, em_mul_ex),\n\tI(SrcMem | ModRM, em_imul_ex),\n\tI(SrcMem | ModRM, em_div_ex),\n\tI(SrcMem | ModRM, em_idiv_ex),\n};\n\nstatic struct opcode group4[] = {\n\tI(ByteOp | DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tI(ByteOp | DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tN, N, N, N, N, N,\n};\n\nstatic struct opcode group5[] = {\n\tI(DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tI(DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tI(SrcMem | ModRM | Stack, em_grp45),\n\tI(SrcMemFAddr | ModRM | ImplicitOps | Stack, em_call_far),\n\tI(SrcMem | ModRM | Stack, em_grp45),\n\tI(SrcMemFAddr | ModRM | ImplicitOps, em_grp45),\n\tI(SrcMem | ModRM | Stack, em_grp45), N,\n};\n\nstatic struct opcode group6[] = {\n\tDI(ModRM | Prot,        sldt),\n\tDI(ModRM | Prot,        str),\n\tDI(ModRM | Prot | Priv, lldt),\n\tDI(ModRM | Prot | Priv, ltr),\n\tN, N, N, N,\n};\n\nstatic struct group_dual group7 = { {\n\tDI(ModRM | Mov | DstMem | Priv, sgdt),\n\tDI(ModRM | Mov | DstMem | Priv, sidt),\n\tII(ModRM | SrcMem | Priv, em_lgdt, lgdt),\n\tII(ModRM | SrcMem | Priv, em_lidt, lidt),\n\tII(SrcNone | ModRM | DstMem | Mov, em_smsw, smsw), N,\n\tII(SrcMem16 | ModRM | Mov | Priv, em_lmsw, lmsw),\n\tII(SrcMem | ModRM | ByteOp | Priv | NoAccess, em_invlpg, invlpg),\n}, {\n\tI(SrcNone | ModRM | Priv | VendorSpecific, em_vmcall),\n\tEXT(0, group7_rm1),\n\tN, EXT(0, group7_rm3),\n\tII(SrcNone | ModRM | DstMem | Mov, em_smsw, smsw), N,\n\tII(SrcMem16 | ModRM | Mov | Priv, em_lmsw, lmsw), EXT(0, group7_rm7),\n} };\n\nstatic struct opcode group8[] = {\n\tN, N, N, N,\n\tI(DstMem | SrcImmByte | ModRM, em_bt),\n\tI(DstMem | SrcImmByte | ModRM | Lock | PageTable, em_bts),\n\tI(DstMem | SrcImmByte | ModRM | Lock, em_btr),\n\tI(DstMem | SrcImmByte | ModRM | Lock | PageTable, em_btc),\n};\n\nstatic struct group_dual group9 = { {\n\tN, I(DstMem64 | ModRM | Lock | PageTable, em_cmpxchg8b), N, N, N, N, N, N,\n}, {\n\tN, N, N, N, N, N, N, N,\n} };\n\nstatic struct opcode group11[] = {\n\tI(DstMem | SrcImm | ModRM | Mov | PageTable, em_mov),\n\tX7(D(Undefined)),\n};\n\nstatic struct gprefix pfx_0f_6f_0f_7f = {\n\tN, N, N, I(Sse, em_movdqu),\n};\n\nstatic struct opcode opcode_table[256] = {\n\t/* 0x00 - 0x07 */\n\tI6ALU(Lock, em_add),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_pop_sreg),\n\t/* 0x08 - 0x0F */\n\tI6ALU(Lock | PageTable, em_or),\n\tI(ImplicitOps | Stack | No64 | Src2CS, em_push_sreg),\n\tN,\n\t/* 0x10 - 0x17 */\n\tI6ALU(Lock, em_adc),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_pop_sreg),\n\t/* 0x18 - 0x1F */\n\tI6ALU(Lock, em_sbb),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_pop_sreg),\n\t/* 0x20 - 0x27 */\n\tI6ALU(Lock | PageTable, em_and), N, N,\n\t/* 0x28 - 0x2F */\n\tI6ALU(Lock, em_sub), N, I(ByteOp | DstAcc | No64, em_das),\n\t/* 0x30 - 0x37 */\n\tI6ALU(Lock, em_xor), N, N,\n\t/* 0x38 - 0x3F */\n\tI6ALU(0, em_cmp), N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg)),\n\t/* 0x50 - 0x57 */\n\tX8(I(SrcReg | Stack, em_push)),\n\t/* 0x58 - 0x5F */\n\tX8(I(DstReg | Stack, em_pop)),\n\t/* 0x60 - 0x67 */\n\tI(ImplicitOps | Stack | No64, em_pusha),\n\tI(ImplicitOps | Stack | No64, em_popa),\n\tN, D(DstReg | SrcMem32 | ModRM | Mov) /* movsxd (x86/64) */ ,\n\tN, N, N, N,\n\t/* 0x68 - 0x6F */\n\tI(SrcImm | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2Imm, em_imul_3op),\n\tI(SrcImmByte | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2ImmByte, em_imul_3op),\n\tI2bvIP(DstDI | SrcDX | Mov | String, em_in, ins, check_perm_in), /* insb, insw/insd */\n\tI2bvIP(SrcSI | DstDX | String, em_out, outs, check_perm_out), /* outsb, outsw/outsd */\n\t/* 0x70 - 0x7F */\n\tX16(D(SrcImmByte)),\n\t/* 0x80 - 0x87 */\n\tG(ByteOp | DstMem | SrcImm | ModRM | Group, group1),\n\tG(DstMem | SrcImm | ModRM | Group, group1),\n\tG(ByteOp | DstMem | SrcImm | ModRM | No64 | Group, group1),\n\tG(DstMem | SrcImmByte | ModRM | Group, group1),\n\tI2bv(DstMem | SrcReg | ModRM, em_test),\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_xchg),\n\t/* 0x88 - 0x8F */\n\tI2bv(DstMem | SrcReg | ModRM | Mov | PageTable, em_mov),\n\tI2bv(DstReg | SrcMem | ModRM | Mov, em_mov),\n\tI(DstMem | SrcNone | ModRM | Mov | PageTable, em_mov_rm_sreg),\n\tD(ModRM | SrcMem | NoAccess | DstReg),\n\tI(ImplicitOps | SrcMem16 | ModRM, em_mov_sreg_rm),\n\tG(0, group1A),\n\t/* 0x90 - 0x97 */\n\tDI(SrcAcc | DstReg, pause), X7(D(SrcAcc | DstReg)),\n\t/* 0x98 - 0x9F */\n\tD(DstAcc | SrcNone), I(ImplicitOps | SrcAcc, em_cwd),\n\tI(SrcImmFAddr | No64, em_call_far), N,\n\tII(ImplicitOps | Stack, em_pushf, pushf),\n\tII(ImplicitOps | Stack, em_popf, popf), N, N,\n\t/* 0xA0 - 0xA7 */\n\tI2bv(DstAcc | SrcMem | Mov | MemAbs, em_mov),\n\tI2bv(DstMem | SrcAcc | Mov | MemAbs | PageTable, em_mov),\n\tI2bv(SrcSI | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstDI | String, em_cmp),\n\t/* 0xA8 - 0xAF */\n\tI2bv(DstAcc | SrcImm, em_test),\n\tI2bv(SrcAcc | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstAcc | Mov | String, em_mov),\n\tI2bv(SrcAcc | DstDI | String, em_cmp),\n\t/* 0xB0 - 0xB7 */\n\tX8(I(ByteOp | DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xB8 - 0xBF */\n\tX8(I(DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xC0 - 0xC7 */\n\tD2bv(DstMem | SrcImmByte | ModRM),\n\tI(ImplicitOps | Stack | SrcImmU16, em_ret_near_imm),\n\tI(ImplicitOps | Stack, em_ret),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2ES, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2DS, em_lseg),\n\tG(ByteOp, group11), G(0, group11),\n\t/* 0xC8 - 0xCF */\n\tN, N, N, I(ImplicitOps | Stack, em_ret_far),\n\tD(ImplicitOps), DI(SrcImmByte, intn),\n\tD(ImplicitOps | No64), II(ImplicitOps, em_iret, iret),\n\t/* 0xD0 - 0xD7 */\n\tD2bv(DstMem | SrcOne | ModRM), D2bv(DstMem | ModRM),\n\tN, N, N, N,\n\t/* 0xD8 - 0xDF */\n\tN, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xE7 */\n\tX3(I(SrcImmByte, em_loop)),\n\tI(SrcImmByte, em_jcxz),\n\tI2bvIP(SrcImmUByte | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstImmUByte, em_out, out, check_perm_out),\n\t/* 0xE8 - 0xEF */\n\tI(SrcImm | Stack, em_call), D(SrcImm | ImplicitOps),\n\tI(SrcImmFAddr | No64, em_jmp_far), D(SrcImmByte | ImplicitOps),\n\tI2bvIP(SrcDX | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstDX, em_out, out, check_perm_out),\n\t/* 0xF0 - 0xF7 */\n\tN, DI(ImplicitOps, icebp), N, N,\n\tDI(ImplicitOps | Priv, hlt), D(ImplicitOps),\n\tG(ByteOp, group3), G(0, group3),\n\t/* 0xF8 - 0xFF */\n\tD(ImplicitOps), D(ImplicitOps),\n\tI(ImplicitOps, em_cli), I(ImplicitOps, em_sti),\n\tD(ImplicitOps), D(ImplicitOps), G(0, group4), G(0, group5),\n};\n\nstatic struct opcode twobyte_table[256] = {\n\t/* 0x00 - 0x0F */\n\tG(0, group6), GD(0, &group7), N, N,\n\tN, I(ImplicitOps | VendorSpecific, em_syscall),\n\tII(ImplicitOps | Priv, em_clts, clts), N,\n\tDI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,\n\tN, D(ImplicitOps | ModRM), N, N,\n\t/* 0x10 - 0x1F */\n\tN, N, N, N, N, N, N, N, D(ImplicitOps | ModRM), N, N, N, N, N, N, N,\n\t/* 0x20 - 0x2F */\n\tDIP(ModRM | DstMem | Priv | Op3264, cr_read, check_cr_read),\n\tDIP(ModRM | DstMem | Priv | Op3264, dr_read, check_dr_read),\n\tIIP(ModRM | SrcMem | Priv | Op3264, em_cr_write, cr_write, check_cr_write),\n\tIIP(ModRM | SrcMem | Priv | Op3264, em_dr_write, dr_write, check_dr_write),\n\tN, N, N, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x30 - 0x3F */\n\tII(ImplicitOps | Priv, em_wrmsr, wrmsr),\n\tIIP(ImplicitOps, em_rdtsc, rdtsc, check_rdtsc),\n\tII(ImplicitOps | Priv, em_rdmsr, rdmsr),\n\tIIP(ImplicitOps, em_rdpmc, rdpmc, check_rdpmc),\n\tI(ImplicitOps | VendorSpecific, em_sysenter),\n\tI(ImplicitOps | Priv | VendorSpecific, em_sysexit),\n\tN, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg | SrcMem | ModRM | Mov)),\n\t/* 0x50 - 0x5F */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0x60 - 0x6F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcMem | DstReg | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x70 - 0x7F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x80 - 0x8F */\n\tX16(D(SrcImm)),\n\t/* 0x90 - 0x9F */\n\tX16(D(ByteOp | DstMem | SrcNone | ModRM| Mov)),\n\t/* 0xA0 - 0xA7 */\n\tI(Stack | Src2FS, em_push_sreg), I(Stack | Src2FS, em_pop_sreg),\n\tDI(ImplicitOps, cpuid), I(DstMem | SrcReg | ModRM | BitOp, em_bt),\n\tD(DstMem | SrcReg | Src2ImmByte | ModRM),\n\tD(DstMem | SrcReg | Src2CL | ModRM), N, N,\n\t/* 0xA8 - 0xAF */\n\tI(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),\n\tDI(ImplicitOps, rsm),\n\tI(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),\n\tD(DstMem | SrcReg | Src2ImmByte | ModRM),\n\tD(DstMem | SrcReg | Src2CL | ModRM),\n\tD(ModRM), I(DstReg | SrcMem | ModRM, em_imul),\n\t/* 0xB0 - 0xB7 */\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_cmpxchg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2SS, em_lseg),\n\tI(DstMem | SrcReg | ModRM | BitOp | Lock, em_btr),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2FS, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2GS, em_lseg),\n\tD(ByteOp | DstReg | SrcMem | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xB8 - 0xBF */\n\tN, N,\n\tG(BitOp, group8),\n\tI(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_btc),\n\tI(DstReg | SrcMem | ModRM, em_bsf), I(DstReg | SrcMem | ModRM, em_bsr),\n\tD(ByteOp | DstReg | SrcMem | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xC0 - 0xCF */\n\tD2bv(DstMem | SrcReg | ModRM | Lock),\n\tN, D(DstMem | SrcReg | ModRM | Mov),\n\tN, N, N, GD(0, &group9),\n\tN, N, N, N, N, N, N, N,\n\t/* 0xD0 - 0xDF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xEF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xF0 - 0xFF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N\n};\n\n#undef D\n#undef N\n#undef G\n#undef GD\n#undef I\n#undef GP\n#undef EXT\n\n#undef D2bv\n#undef D2bvIP\n#undef I2bv\n#undef I2bvIP\n#undef I6ALU\n\nstatic unsigned imm_size(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned size;\n\n\tsize = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tif (size == 8)\n\t\tsize = 4;\n\treturn size;\n}\n\nstatic int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\t/* NB. Immediates are sign-extended as necessary. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}\n\nstatic int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op,\n\t\t\t op == &ctxt->dst &&\n\t\t\t ctxt->twobyte && (ctxt->b == 0xb6 || ctxt->b == 0xb7));\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif ((ctxt->d & BitOp) && op == &ctxt->dst)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = &ctxt->regs[VCPU_REGS_RAX];\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, ctxt->regs[VCPU_REGS_RDI]);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = &ctxt->regs[VCPU_REGS_RDX];\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->bytes = 1;\n\t\top->val = ctxt->regs[VCPU_REGS_RCX] & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, ctxt->regs[VCPU_REGS_RSI]);\n\t\top->addr.mem.seg = seg_override(ctxt);\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}\n\nint x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.start = ctxt->_eip;\n\tctxt->fetch.end = ctxt->fetch.start + insn_len;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\tset_seg_override(ctxt, (ctxt->b >> 3) & 3);\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\tset_seg_override(ctxt, ctxt->b & 7);\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->twobyte = 1;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\t}\n\tctxt->d = opcode.flags;\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\t\t\t--ctxt->_eip;\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\t\t\t--ctxt->_eip;\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\tctxt->execute = opcode.u.execute;\n\tctxt->check_perm = opcode.check_perm;\n\tctxt->intercept = opcode.intercept;\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0 || (ctxt->d & Undefined))\n\t\treturn EMULATION_FAILED;\n\n\tif (!(ctxt->d & VendorSpecific) && ctxt->only_vendor_specific_insn)\n\t\treturn EMULATION_FAILED;\n\n\tif (mode == X86EMUL_MODE_PROT64 && (ctxt->d & Stack))\n\t\tctxt->op_bytes = 8;\n\n\tif (ctxt->d & Op3264) {\n\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\tctxt->op_bytes = 8;\n\t\telse\n\t\t\tctxt->op_bytes = 4;\n\t}\n\n\tif (ctxt->d & Sse)\n\t\tctxt->op_bytes = 16;\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!ctxt->has_seg_override)\n\t\t\tset_seg_override(ctxt, ctxt->modrm_seg);\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!ctxt->has_seg_override)\n\t\tset_seg_override(ctxt, VCPU_SREG_DS);\n\n\tctxt->memop.addr.mem.seg = seg_override(ctxt);\n\n\tif (ctxt->memop.type == OP_MEM && ctxt->ad_bytes != 8)\n\t\tctxt->memop.addr.mem.ea = (u32)ctxt->memop.addr.mem.ea;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\ndone:\n\tif (ctxt->memopp && ctxt->memopp->type == OP_MEM && ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea += ctxt->_eip;\n\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}\n\nbool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt)\n{\n\treturn ctxt->d & PageTable;\n}\n\nstatic bool string_insn_completed(struct x86_emulate_ctxt *ctxt)\n{\n\t/* The second termination condition only applies for REPE\n\t * and REPNE. Test if the repeat string operation prefix is\n\t * REPE/REPZ or REPNE/REPNZ and if it's the case it tests the\n\t * corresponding termination condition according to:\n\t * \t- if REPE/REPZ and ZF = 0 then done\n\t * \t- if REPNE/REPNZ and ZF = 1 then done\n\t */\n\tif (((ctxt->b == 0xa6) || (ctxt->b == 0xa7) ||\n\t     (ctxt->b == 0xae) || (ctxt->b == 0xaf))\n\t    && (((ctxt->rep_prefix == REPE_PREFIX) &&\n\t\t ((ctxt->eflags & EFLG_ZF) == 0))\n\t\t|| ((ctxt->rep_prefix == REPNE_PREFIX) &&\n\t\t    ((ctxt->eflags & EFLG_ZF) == EFLG_ZF))))\n\t\treturn true;\n\n\treturn false;\n}\n\nint x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc = X86EMUL_CONTINUE;\n\tint saved_dst_type = ctxt->dst.type;\n\n\tctxt->mem_read.pos = 0;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\t/* LOCK prefix is allowed only with some instructions */\n\tif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & Sse)\n\t    && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)\n\t\t|| !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & Sse) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\n\t\trc = emulate_nm(ctxt);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->guest_mode) && ctxt->intercept) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_PRE_EXCEPT);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\t/* Privileged instruction can be executed only in CPL=0 */\n\tif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\n\t\trc = emulate_gp(ctxt, 0);\n\t\tgoto done;\n\t}\n\n\t/* Instruction can only be executed in protected mode */\n\tif ((ctxt->d & Prot) && !(ctxt->mode & X86EMUL_MODE_PROT)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\t/* Do instruction specific permission checks */\n\tif (ctxt->check_perm) {\n\t\trc = ctxt->check_perm(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->guest_mode) && ctxt->intercept) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_EXCEPT);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\t/* All REP prefixes have the same first termination condition */\n\t\tif (address_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) == 0) {\n\t\t\tctxt->eip = ctxt->_eip;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\n\t\trc = segmented_read(ctxt, ctxt->src.addr.mem,\n\t\t\t\t    ctxt->src.valptr, ctxt->src.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tctxt->src.orig_val64 = ctxt->src.val64;\n\t}\n\n\tif (ctxt->src2.type == OP_MEM) {\n\t\trc = segmented_read(ctxt, ctxt->src2.addr.mem,\n\t\t\t\t    &ctxt->src2.val, ctxt->src2.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & DstMask) == ImplicitOps)\n\t\tgoto special_insn;\n\n\n\tif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\n\t\t/* optimisation - avoid slow emulated read if Mov */\n\t\trc = segmented_read(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &ctxt->dst.val, ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tctxt->dst.orig_val = ctxt->dst.val;\n\nspecial_insn:\n\n\tif (unlikely(ctxt->guest_mode) && ctxt->intercept) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_MEMACCESS);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->execute) {\n\t\trc = ctxt->execute(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tgoto writeback;\n\t}\n\n\tif (ctxt->twobyte)\n\t\tgoto twobyte_insn;\n\n\tswitch (ctxt->b) {\n\tcase 0x40 ... 0x47: /* inc r16/r32 */\n\t\temulate_1op(ctxt, \"inc\");\n\t\tbreak;\n\tcase 0x48 ... 0x4f: /* dec r16/r32 */\n\t\temulate_1op(ctxt, \"dec\");\n\t\tbreak;\n\tcase 0x63:\t\t/* movsxd */\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\tgoto cannot_emulate;\n\t\tctxt->dst.val = (s32) ctxt->src.val;\n\t\tbreak;\n\tcase 0x70 ... 0x7f: /* jcc (short) */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tjmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x8d: /* lea r16/r32, m */\n\t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n\t\tbreak;\n\tcase 0x90 ... 0x97: /* nop / xchg reg, rax */\n\t\tif (ctxt->dst.addr.reg == &ctxt->regs[VCPU_REGS_RAX])\n\t\t\tbreak;\n\t\trc = em_xchg(ctxt);\n\t\tbreak;\n\tcase 0x98: /* cbw/cwde/cdqe */\n\t\tswitch (ctxt->op_bytes) {\n\t\tcase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\n\t\tcase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\n\t\tcase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n\t\t}\n\t\tbreak;\n\tcase 0xc0 ... 0xc1:\n\t\trc = em_grp2(ctxt);\n\t\tbreak;\n\tcase 0xcc:\t\t/* int3 */\n\t\trc = emulate_int(ctxt, 3);\n\t\tbreak;\n\tcase 0xcd:\t\t/* int n */\n\t\trc = emulate_int(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0xce:\t\t/* into */\n\t\tif (ctxt->eflags & EFLG_OF)\n\t\t\trc = emulate_int(ctxt, 4);\n\t\tbreak;\n\tcase 0xd0 ... 0xd1:\t/* Grp2 */\n\t\trc = em_grp2(ctxt);\n\t\tbreak;\n\tcase 0xd2 ... 0xd3:\t/* Grp2 */\n\t\tctxt->src.val = ctxt->regs[VCPU_REGS_RCX];\n\t\trc = em_grp2(ctxt);\n\t\tbreak;\n\tcase 0xe9: /* jmp rel */\n\tcase 0xeb: /* jmp rel short */\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\t\tctxt->dst.type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\tcase 0xf4:              /* hlt */\n\t\tctxt->ops->halt(ctxt);\n\t\tbreak;\n\tcase 0xf5:\t/* cmc */\n\t\t/* complement carry flag from eflags reg */\n\t\tctxt->eflags ^= EFLG_CF;\n\t\tbreak;\n\tcase 0xf8: /* clc */\n\t\tctxt->eflags &= ~EFLG_CF;\n\t\tbreak;\n\tcase 0xf9: /* stc */\n\t\tctxt->eflags |= EFLG_CF;\n\t\tbreak;\n\tcase 0xfc: /* cld */\n\t\tctxt->eflags &= ~EFLG_DF;\n\t\tbreak;\n\tcase 0xfd: /* std */\n\t\tctxt->eflags |= EFLG_DF;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\nwriteback:\n\trc = writeback(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * restore dst type in case the decoding will be reused\n\t * (happens for string instruction )\n\t */\n\tctxt->dst.type = saved_dst_type;\n\n\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\tstring_addr_inc(ctxt, seg_override(ctxt),\n\t\t\t\tVCPU_REGS_RSI, &ctxt->src);\n\n\tif ((ctxt->d & DstMask) == DstDI)\n\t\tstring_addr_inc(ctxt, VCPU_SREG_ES, VCPU_REGS_RDI,\n\t\t\t\t&ctxt->dst);\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\tstruct read_cache *r = &ctxt->io_read;\n\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RCX], -1);\n\n\t\tif (!string_insn_completed(ctxt)) {\n\t\t\t/*\n\t\t\t * Re-enter guest when pio read ahead buffer is empty\n\t\t\t * or, if it is not used, after each 1024 iteration.\n\t\t\t */\n\t\t\tif ((r->end != 0 || ctxt->regs[VCPU_REGS_RCX] & 0x3ff) &&\n\t\t\t    (r->end == 0 || r->end != r->pos)) {\n\t\t\t\t/*\n\t\t\t\t * Reset read cache. Usually happens before\n\t\t\t\t * decode, but since instruction is restarted\n\t\t\t\t * we have to do it here.\n\t\t\t\t */\n\t\t\t\tctxt->mem_read.end = 0;\n\t\t\t\treturn EMULATION_RESTART;\n\t\t\t}\n\t\t\tgoto done; /* skip rip writeback */\n\t\t}\n\t}\n\n\tctxt->eip = ctxt->_eip;\n\ndone:\n\tif (rc == X86EMUL_PROPAGATE_FAULT)\n\t\tctxt->have_exception = true;\n\tif (rc == X86EMUL_INTERCEPTED)\n\t\treturn EMULATION_INTERCEPTED;\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n\ntwobyte_insn:\n\tswitch (ctxt->b) {\n\tcase 0x09:\t\t/* wbinvd */\n\t\t(ctxt->ops->wbinvd)(ctxt);\n\t\tbreak;\n\tcase 0x08:\t\t/* invd */\n\tcase 0x0d:\t\t/* GrpP (prefetch) */\n\tcase 0x18:\t\t/* Grp16 (prefetch/nop) */\n\t\tbreak;\n\tcase 0x20: /* mov cr, reg */\n\t\tctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\n\t\tbreak;\n\tcase 0x21: /* mov from dr to reg */\n\t\tops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t/* cmov */\n\t\tctxt->dst.val = ctxt->dst.orig_val = ctxt->src.val;\n\t\tif (!test_cc(ctxt->b, ctxt->eflags))\n\t\t\tctxt->dst.type = OP_NONE; /* no writeback */\n\t\tbreak;\n\tcase 0x80 ... 0x8f: /* jnz rel, etc*/\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tjmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x90 ... 0x9f:     /* setcc r/m8 */\n\t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n\t\tbreak;\n\tcase 0xa4: /* shld imm8, r, r/m */\n\tcase 0xa5: /* shld cl, r, r/m */\n\t\temulate_2op_cl(ctxt, \"shld\");\n\t\tbreak;\n\tcase 0xac: /* shrd imm8, r, r/m */\n\tcase 0xad: /* shrd cl, r, r/m */\n\t\temulate_2op_cl(ctxt, \"shrd\");\n\t\tbreak;\n\tcase 0xae:              /* clflush */\n\t\tbreak;\n\tcase 0xb6 ... 0xb7:\t/* movzx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->d & ByteOp) ? (u8) ctxt->src.val\n\t\t\t\t\t\t       : (u16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xbe ... 0xbf:\t/* movsx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->d & ByteOp) ? (s8) ctxt->src.val :\n\t\t\t\t\t\t\t(s16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xc0 ... 0xc1:\t/* xadd */\n\t\temulate_2op_SrcV(ctxt, \"add\");\n\t\t/* Write back the register source. */\n\t\tctxt->src.val = ctxt->dst.orig_val;\n\t\twrite_register_operand(&ctxt->src);\n\t\tbreak;\n\tcase 0xc3:\t\t/* movnti */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->op_bytes == 4) ? (u32) ctxt->src.val :\n\t\t\t\t\t\t\t(u64) ctxt->src.val;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tgoto writeback;\n\ncannot_emulate:\n\treturn EMULATION_FAILED;\n}\n"], "fixing_code": ["/******************************************************************************\n * x86_emulate.h\n *\n * Generic x86 (32-bit and 64-bit) instruction decoder and emulator.\n *\n * Copyright (c) 2005 Keir Fraser\n *\n * From: xen-unstable 10676:af9809f51f81a3c43f276f00c81a52ef558afda4\n */\n\n#ifndef _ASM_X86_KVM_X86_EMULATE_H\n#define _ASM_X86_KVM_X86_EMULATE_H\n\n#include <asm/desc_defs.h>\n\nstruct x86_emulate_ctxt;\nenum x86_intercept;\nenum x86_intercept_stage;\n\nstruct x86_exception {\n\tu8 vector;\n\tbool error_code_valid;\n\tu16 error_code;\n\tbool nested_page_fault;\n\tu64 address; /* cr2 or nested page fault gpa */\n};\n\n/*\n * This struct is used to carry enough information from the instruction\n * decoder to main KVM so that a decision can be made whether the\n * instruction needs to be intercepted or not.\n */\nstruct x86_instruction_info {\n\tu8  intercept;          /* which intercept                      */\n\tu8  rep_prefix;         /* rep prefix?                          */\n\tu8  modrm_mod;\t\t/* mod part of modrm\t\t\t*/\n\tu8  modrm_reg;          /* index of register used               */\n\tu8  modrm_rm;\t\t/* rm part of modrm\t\t\t*/\n\tu64 src_val;            /* value of source operand              */\n\tu8  src_bytes;          /* size of source operand               */\n\tu8  dst_bytes;          /* size of destination operand          */\n\tu8  ad_bytes;           /* size of src/dst address              */\n\tu64 next_rip;           /* rip following the instruction        */\n};\n\n/*\n * x86_emulate_ops:\n *\n * These operations represent the instruction emulator's interface to memory.\n * There are two categories of operation: those that act on ordinary memory\n * regions (*_std), and those that act on memory regions known to require\n * special treatment or emulation (*_emulated).\n *\n * The emulator assumes that an instruction accesses only one 'emulated memory'\n * location, that this location is the given linear faulting address (cr2), and\n * that this is one of the instruction's data operands. Instruction fetches and\n * stack operations are assumed never to access emulated memory. The emulator\n * automatically deduces which operand of a string-move operation is accessing\n * emulated memory, and assumes that the other operand accesses normal memory.\n *\n * NOTES:\n *  1. The emulator isn't very smart about emulated vs. standard memory.\n *     'Emulated memory' access addresses should be checked for sanity.\n *     'Normal memory' accesses may fault, and the caller must arrange to\n *     detect and handle reentrancy into the emulator via recursive faults.\n *     Accesses may be unaligned and may cross page boundaries.\n *  2. If the access fails (cannot emulate, or a standard access faults) then\n *     it is up to the memop to propagate the fault to the guest VM via\n *     some out-of-band mechanism, unknown to the emulator. The memop signals\n *     failure by returning X86EMUL_PROPAGATE_FAULT to the emulator, which will\n *     then immediately bail.\n *  3. Valid access sizes are 1, 2, 4 and 8 bytes. On x86/32 systems only\n *     cmpxchg8b_emulated need support 8-byte accesses.\n *  4. The emulator cannot handle 64-bit mode emulation on an x86/32 system.\n */\n/* Access completed successfully: continue emulation as normal. */\n#define X86EMUL_CONTINUE        0\n/* Access is unhandleable: bail from emulation and return error to caller. */\n#define X86EMUL_UNHANDLEABLE    1\n/* Terminate emulation but return success to the caller. */\n#define X86EMUL_PROPAGATE_FAULT 2 /* propagate a generated fault to guest */\n#define X86EMUL_RETRY_INSTR     3 /* retry the instruction for some reason */\n#define X86EMUL_CMPXCHG_FAILED  4 /* cmpxchg did not see expected value */\n#define X86EMUL_IO_NEEDED       5 /* IO is needed to complete emulation */\n#define X86EMUL_INTERCEPTED     6 /* Intercepted by nested VMCB/VMCS */\n\nstruct x86_emulate_ops {\n\t/*\n\t * read_std: Read bytes of standard (non-emulated/special) memory.\n\t *           Used for descriptor reading.\n\t *  @addr:  [IN ] Linear address from which to read.\n\t *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to read from memory.\n\t */\n\tint (*read_std)(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr, void *val,\n\t\t\tunsigned int bytes,\n\t\t\tstruct x86_exception *fault);\n\n\t/*\n\t * write_std: Write bytes of standard (non-emulated/special) memory.\n\t *            Used for descriptor writing.\n\t *  @addr:  [IN ] Linear address to which to write.\n\t *  @val:   [OUT] Value write to memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to write to memory.\n\t */\n\tint (*write_std)(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *val, unsigned int bytes,\n\t\t\t struct x86_exception *fault);\n\t/*\n\t * fetch: Read bytes of standard (non-emulated/special) memory.\n\t *        Used for instruction fetch.\n\t *  @addr:  [IN ] Linear address from which to read.\n\t *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to read from memory.\n\t */\n\tint (*fetch)(struct x86_emulate_ctxt *ctxt,\n\t\t     unsigned long addr, void *val, unsigned int bytes,\n\t\t     struct x86_exception *fault);\n\n\t/*\n\t * read_emulated: Read bytes from emulated/special memory area.\n\t *  @addr:  [IN ] Linear address from which to read.\n\t *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.\n\t *  @bytes: [IN ] Number of bytes to read from memory.\n\t */\n\tint (*read_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t     unsigned long addr, void *val, unsigned int bytes,\n\t\t\t     struct x86_exception *fault);\n\n\t/*\n\t * write_emulated: Write bytes to emulated/special memory area.\n\t *  @addr:  [IN ] Linear address to which to write.\n\t *  @val:   [IN ] Value to write to memory (low-order bytes used as\n\t *                required).\n\t *  @bytes: [IN ] Number of bytes to write to memory.\n\t */\n\tint (*write_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long addr, const void *val,\n\t\t\t      unsigned int bytes,\n\t\t\t      struct x86_exception *fault);\n\n\t/*\n\t * cmpxchg_emulated: Emulate an atomic (LOCKed) CMPXCHG operation on an\n\t *                   emulated/special memory area.\n\t *  @addr:  [IN ] Linear address to access.\n\t *  @old:   [IN ] Value expected to be current at @addr.\n\t *  @new:   [IN ] Value to write to @addr.\n\t *  @bytes: [IN ] Number of bytes to access using CMPXCHG.\n\t */\n\tint (*cmpxchg_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tunsigned long addr,\n\t\t\t\tconst void *old,\n\t\t\t\tconst void *new,\n\t\t\t\tunsigned int bytes,\n\t\t\t\tstruct x86_exception *fault);\n\tvoid (*invlpg)(struct x86_emulate_ctxt *ctxt, ulong addr);\n\n\tint (*pio_in_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t       int size, unsigned short port, void *val,\n\t\t\t       unsigned int count);\n\n\tint (*pio_out_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tint size, unsigned short port, const void *val,\n\t\t\t\tunsigned int count);\n\n\tbool (*get_segment)(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t    struct desc_struct *desc, u32 *base3, int seg);\n\tvoid (*set_segment)(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t    struct desc_struct *desc, u32 base3, int seg);\n\tunsigned long (*get_cached_segment_base)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t\t int seg);\n\tvoid (*get_gdt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*get_idt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*set_gdt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*set_idt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tulong (*get_cr)(struct x86_emulate_ctxt *ctxt, int cr);\n\tint (*set_cr)(struct x86_emulate_ctxt *ctxt, int cr, ulong val);\n\tint (*cpl)(struct x86_emulate_ctxt *ctxt);\n\tint (*get_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong *dest);\n\tint (*set_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong value);\n\tint (*set_msr)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 data);\n\tint (*get_msr)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 *pdata);\n\tint (*read_pmc)(struct x86_emulate_ctxt *ctxt, u32 pmc, u64 *pdata);\n\tvoid (*halt)(struct x86_emulate_ctxt *ctxt);\n\tvoid (*wbinvd)(struct x86_emulate_ctxt *ctxt);\n\tint (*fix_hypercall)(struct x86_emulate_ctxt *ctxt);\n\tvoid (*get_fpu)(struct x86_emulate_ctxt *ctxt); /* disables preempt */\n\tvoid (*put_fpu)(struct x86_emulate_ctxt *ctxt); /* reenables preempt */\n\tint (*intercept)(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_instruction_info *info,\n\t\t\t enum x86_intercept_stage stage);\n\n\tbool (*get_cpuid)(struct x86_emulate_ctxt *ctxt,\n\t\t\t u32 *eax, u32 *ebx, u32 *ecx, u32 *edx);\n};\n\ntypedef u32 __attribute__((vector_size(16))) sse128_t;\n\n/* Type, address-of, and value of an instruction's operand. */\nstruct operand {\n\tenum { OP_REG, OP_MEM, OP_IMM, OP_XMM, OP_NONE } type;\n\tunsigned int bytes;\n\tunion {\n\t\tunsigned long orig_val;\n\t\tu64 orig_val64;\n\t};\n\tunion {\n\t\tunsigned long *reg;\n\t\tstruct segmented_address {\n\t\t\tulong ea;\n\t\t\tunsigned seg;\n\t\t} mem;\n\t\tunsigned xmm;\n\t} addr;\n\tunion {\n\t\tunsigned long val;\n\t\tu64 val64;\n\t\tchar valptr[sizeof(unsigned long) + 2];\n\t\tsse128_t vec_val;\n\t};\n};\n\nstruct fetch_cache {\n\tu8 data[15];\n\tunsigned long start;\n\tunsigned long end;\n};\n\nstruct read_cache {\n\tu8 data[1024];\n\tunsigned long pos;\n\tunsigned long end;\n};\n\nstruct x86_emulate_ctxt {\n\tstruct x86_emulate_ops *ops;\n\n\t/* Register state before/after emulation. */\n\tunsigned long eflags;\n\tunsigned long eip; /* eip before instruction emulation */\n\t/* Emulated execution mode, represented by an X86EMUL_MODE value. */\n\tint mode;\n\n\t/* interruptibility state, as a result of execution of STI or MOV SS */\n\tint interruptibility;\n\n\tbool guest_mode; /* guest running a nested guest */\n\tbool perm_ok; /* do not check permissions if true */\n\tbool only_vendor_specific_insn;\n\n\tbool have_exception;\n\tstruct x86_exception exception;\n\n\t/* decode cache */\n\tu8 twobyte;\n\tu8 b;\n\tu8 intercept;\n\tu8 lock_prefix;\n\tu8 rep_prefix;\n\tu8 op_bytes;\n\tu8 ad_bytes;\n\tu8 rex_prefix;\n\tstruct operand src;\n\tstruct operand src2;\n\tstruct operand dst;\n\tbool has_seg_override;\n\tu8 seg_override;\n\tu64 d;\n\tint (*execute)(struct x86_emulate_ctxt *ctxt);\n\tint (*check_perm)(struct x86_emulate_ctxt *ctxt);\n\t/* modrm */\n\tu8 modrm;\n\tu8 modrm_mod;\n\tu8 modrm_reg;\n\tu8 modrm_rm;\n\tu8 modrm_seg;\n\tbool rip_relative;\n\tunsigned long _eip;\n\t/* Fields above regs are cleared together. */\n\tunsigned long regs[NR_VCPU_REGS];\n\tstruct operand memop;\n\tstruct operand *memopp;\n\tstruct fetch_cache fetch;\n\tstruct read_cache io_read;\n\tstruct read_cache mem_read;\n};\n\n/* Repeat String Operation Prefix */\n#define REPE_PREFIX\t0xf3\n#define REPNE_PREFIX\t0xf2\n\n/* Execution mode, passed to the emulator. */\n#define X86EMUL_MODE_REAL     0\t/* Real mode.             */\n#define X86EMUL_MODE_VM86     1\t/* Virtual 8086 mode.     */\n#define X86EMUL_MODE_PROT16   2\t/* 16-bit protected mode. */\n#define X86EMUL_MODE_PROT32   4\t/* 32-bit protected mode. */\n#define X86EMUL_MODE_PROT64   8\t/* 64-bit (long) mode.    */\n\n/* any protected mode   */\n#define X86EMUL_MODE_PROT     (X86EMUL_MODE_PROT16|X86EMUL_MODE_PROT32| \\\n\t\t\t       X86EMUL_MODE_PROT64)\n\n/* CPUID vendors */\n#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx 0x68747541\n#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx 0x444d4163\n#define X86EMUL_CPUID_VENDOR_AuthenticAMD_edx 0x69746e65\n\n#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx 0x69444d41\n#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx 0x21726574\n#define X86EMUL_CPUID_VENDOR_AMDisbetterI_edx 0x74656273\n\n#define X86EMUL_CPUID_VENDOR_GenuineIntel_ebx 0x756e6547\n#define X86EMUL_CPUID_VENDOR_GenuineIntel_ecx 0x6c65746e\n#define X86EMUL_CPUID_VENDOR_GenuineIntel_edx 0x49656e69\n\nenum x86_intercept_stage {\n\tX86_ICTP_NONE = 0,   /* Allow zero-init to not match anything */\n\tX86_ICPT_PRE_EXCEPT,\n\tX86_ICPT_POST_EXCEPT,\n\tX86_ICPT_POST_MEMACCESS,\n};\n\nenum x86_intercept {\n\tx86_intercept_none,\n\tx86_intercept_cr_read,\n\tx86_intercept_cr_write,\n\tx86_intercept_clts,\n\tx86_intercept_lmsw,\n\tx86_intercept_smsw,\n\tx86_intercept_dr_read,\n\tx86_intercept_dr_write,\n\tx86_intercept_lidt,\n\tx86_intercept_sidt,\n\tx86_intercept_lgdt,\n\tx86_intercept_sgdt,\n\tx86_intercept_lldt,\n\tx86_intercept_sldt,\n\tx86_intercept_ltr,\n\tx86_intercept_str,\n\tx86_intercept_rdtsc,\n\tx86_intercept_rdpmc,\n\tx86_intercept_pushf,\n\tx86_intercept_popf,\n\tx86_intercept_cpuid,\n\tx86_intercept_rsm,\n\tx86_intercept_iret,\n\tx86_intercept_intn,\n\tx86_intercept_invd,\n\tx86_intercept_pause,\n\tx86_intercept_hlt,\n\tx86_intercept_invlpg,\n\tx86_intercept_invlpga,\n\tx86_intercept_vmrun,\n\tx86_intercept_vmload,\n\tx86_intercept_vmsave,\n\tx86_intercept_vmmcall,\n\tx86_intercept_stgi,\n\tx86_intercept_clgi,\n\tx86_intercept_skinit,\n\tx86_intercept_rdtscp,\n\tx86_intercept_icebp,\n\tx86_intercept_wbinvd,\n\tx86_intercept_monitor,\n\tx86_intercept_mwait,\n\tx86_intercept_rdmsr,\n\tx86_intercept_wrmsr,\n\tx86_intercept_in,\n\tx86_intercept_ins,\n\tx86_intercept_out,\n\tx86_intercept_outs,\n\n\tnr_x86_intercepts\n};\n\n/* Host execution mode. */\n#if defined(CONFIG_X86_32)\n#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT32\n#elif defined(CONFIG_X86_64)\n#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT64\n#endif\n\nint x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len);\nbool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt);\n#define EMULATION_FAILED -1\n#define EMULATION_OK 0\n#define EMULATION_RESTART 1\n#define EMULATION_INTERCEPTED 2\nint x86_emulate_insn(struct x86_emulate_ctxt *ctxt);\nint emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int reason,\n\t\t\t bool has_error_code, u32 error_code);\nint emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq);\n#endif /* _ASM_X86_KVM_X86_EMULATE_H */\n", "/******************************************************************************\n * emulate.c\n *\n * Generic x86 (32-bit and 64-bit) instruction decoder and emulator.\n *\n * Copyright (c) 2005 Keir Fraser\n *\n * Linux coding style, mod r/m decoder, segment base fixes, real-mode\n * privileged instructions:\n *\n * Copyright (C) 2006 Qumranet\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n *   Avi Kivity <avi@qumranet.com>\n *   Yaniv Kamay <yaniv@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * From: xen-unstable 10676:af9809f51f81a3c43f276f00c81a52ef558afda4\n */\n\n#include <linux/kvm_host.h>\n#include \"kvm_cache_regs.h\"\n#include <linux/module.h>\n#include <asm/kvm_emulate.h>\n\n#include \"x86.h\"\n#include \"tss.h\"\n\n/*\n * Operand types\n */\n#define OpNone             0ull\n#define OpImplicit         1ull  /* No generic decode */\n#define OpReg              2ull  /* Register */\n#define OpMem              3ull  /* Memory */\n#define OpAcc              4ull  /* Accumulator: AL/AX/EAX/RAX */\n#define OpDI               5ull  /* ES:DI/EDI/RDI */\n#define OpMem64            6ull  /* Memory, 64-bit */\n#define OpImmUByte         7ull  /* Zero-extended 8-bit immediate */\n#define OpDX               8ull  /* DX register */\n#define OpCL               9ull  /* CL register (for shifts) */\n#define OpImmByte         10ull  /* 8-bit sign extended immediate */\n#define OpOne             11ull  /* Implied 1 */\n#define OpImm             12ull  /* Sign extended immediate */\n#define OpMem16           13ull  /* Memory operand (16-bit). */\n#define OpMem32           14ull  /* Memory operand (32-bit). */\n#define OpImmU            15ull  /* Immediate operand, zero extended */\n#define OpSI              16ull  /* SI/ESI/RSI */\n#define OpImmFAddr        17ull  /* Immediate far address */\n#define OpMemFAddr        18ull  /* Far address in memory */\n#define OpImmU16          19ull  /* Immediate operand, 16 bits, zero extended */\n#define OpES              20ull  /* ES */\n#define OpCS              21ull  /* CS */\n#define OpSS              22ull  /* SS */\n#define OpDS              23ull  /* DS */\n#define OpFS              24ull  /* FS */\n#define OpGS              25ull  /* GS */\n\n#define OpBits             5  /* Width of operand field */\n#define OpMask             ((1ull << OpBits) - 1)\n\n/*\n * Opcode effective-address decode tables.\n * Note that we only emulate instructions that have at least one memory\n * operand (excluding implicit stack references). We assume that stack\n * references and instruction fetches will never occur in special memory\n * areas that require emulation. So, for example, 'mov <imm>,<reg>' need\n * not be handled.\n */\n\n/* Operand sizes: 8-bit operands or specified/overridden size. */\n#define ByteOp      (1<<0)\t/* 8-bit operands. */\n/* Destination operand type. */\n#define DstShift    1\n#define ImplicitOps (OpImplicit << DstShift)\n#define DstReg      (OpReg << DstShift)\n#define DstMem      (OpMem << DstShift)\n#define DstAcc      (OpAcc << DstShift)\n#define DstDI       (OpDI << DstShift)\n#define DstMem64    (OpMem64 << DstShift)\n#define DstImmUByte (OpImmUByte << DstShift)\n#define DstDX       (OpDX << DstShift)\n#define DstMask     (OpMask << DstShift)\n/* Source operand type. */\n#define SrcShift    6\n#define SrcNone     (OpNone << SrcShift)\n#define SrcReg      (OpReg << SrcShift)\n#define SrcMem      (OpMem << SrcShift)\n#define SrcMem16    (OpMem16 << SrcShift)\n#define SrcMem32    (OpMem32 << SrcShift)\n#define SrcImm      (OpImm << SrcShift)\n#define SrcImmByte  (OpImmByte << SrcShift)\n#define SrcOne      (OpOne << SrcShift)\n#define SrcImmUByte (OpImmUByte << SrcShift)\n#define SrcImmU     (OpImmU << SrcShift)\n#define SrcSI       (OpSI << SrcShift)\n#define SrcImmFAddr (OpImmFAddr << SrcShift)\n#define SrcMemFAddr (OpMemFAddr << SrcShift)\n#define SrcAcc      (OpAcc << SrcShift)\n#define SrcImmU16   (OpImmU16 << SrcShift)\n#define SrcDX       (OpDX << SrcShift)\n#define SrcMask     (OpMask << SrcShift)\n#define BitOp       (1<<11)\n#define MemAbs      (1<<12)      /* Memory operand is absolute displacement */\n#define String      (1<<13)     /* String instruction (rep capable) */\n#define Stack       (1<<14)     /* Stack instruction (push/pop) */\n#define GroupMask   (7<<15)     /* Opcode uses one of the group mechanisms */\n#define Group       (1<<15)     /* Bits 3:5 of modrm byte extend opcode */\n#define GroupDual   (2<<15)     /* Alternate decoding of mod == 3 */\n#define Prefix      (3<<15)     /* Instruction varies with 66/f2/f3 prefix */\n#define RMExt       (4<<15)     /* Opcode extension in ModRM r/m if mod == 3 */\n#define Sse         (1<<18)     /* SSE Vector instruction */\n/* Generic ModRM decode. */\n#define ModRM       (1<<19)\n/* Destination is only written; never read. */\n#define Mov         (1<<20)\n/* Misc flags */\n#define Prot        (1<<21) /* instruction generates #UD if not in prot-mode */\n#define VendorSpecific (1<<22) /* Vendor specific instruction */\n#define NoAccess    (1<<23) /* Don't access memory (lea/invlpg/verr etc) */\n#define Op3264      (1<<24) /* Operand is 64b in long mode, 32b otherwise */\n#define Undefined   (1<<25) /* No Such Instruction */\n#define Lock        (1<<26) /* lock prefix is allowed for the instruction */\n#define Priv        (1<<27) /* instruction generates #GP if current CPL != 0 */\n#define No64\t    (1<<28)\n#define PageTable   (1 << 29)   /* instruction used to write page table */\n/* Source 2 operand type */\n#define Src2Shift   (30)\n#define Src2None    (OpNone << Src2Shift)\n#define Src2CL      (OpCL << Src2Shift)\n#define Src2ImmByte (OpImmByte << Src2Shift)\n#define Src2One     (OpOne << Src2Shift)\n#define Src2Imm     (OpImm << Src2Shift)\n#define Src2ES      (OpES << Src2Shift)\n#define Src2CS      (OpCS << Src2Shift)\n#define Src2SS      (OpSS << Src2Shift)\n#define Src2DS      (OpDS << Src2Shift)\n#define Src2FS      (OpFS << Src2Shift)\n#define Src2GS      (OpGS << Src2Shift)\n#define Src2Mask    (OpMask << Src2Shift)\n\n#define X2(x...) x, x\n#define X3(x...) X2(x), x\n#define X4(x...) X2(x), X2(x)\n#define X5(x...) X4(x), x\n#define X6(x...) X4(x), X2(x)\n#define X7(x...) X4(x), X3(x)\n#define X8(x...) X4(x), X4(x)\n#define X16(x...) X8(x), X8(x)\n\nstruct opcode {\n\tu64 flags : 56;\n\tu64 intercept : 8;\n\tunion {\n\t\tint (*execute)(struct x86_emulate_ctxt *ctxt);\n\t\tstruct opcode *group;\n\t\tstruct group_dual *gdual;\n\t\tstruct gprefix *gprefix;\n\t} u;\n\tint (*check_perm)(struct x86_emulate_ctxt *ctxt);\n};\n\nstruct group_dual {\n\tstruct opcode mod012[8];\n\tstruct opcode mod3[8];\n};\n\nstruct gprefix {\n\tstruct opcode pfx_no;\n\tstruct opcode pfx_66;\n\tstruct opcode pfx_f2;\n\tstruct opcode pfx_f3;\n};\n\n/* EFLAGS bit definitions. */\n#define EFLG_ID (1<<21)\n#define EFLG_VIP (1<<20)\n#define EFLG_VIF (1<<19)\n#define EFLG_AC (1<<18)\n#define EFLG_VM (1<<17)\n#define EFLG_RF (1<<16)\n#define EFLG_IOPL (3<<12)\n#define EFLG_NT (1<<14)\n#define EFLG_OF (1<<11)\n#define EFLG_DF (1<<10)\n#define EFLG_IF (1<<9)\n#define EFLG_TF (1<<8)\n#define EFLG_SF (1<<7)\n#define EFLG_ZF (1<<6)\n#define EFLG_AF (1<<4)\n#define EFLG_PF (1<<2)\n#define EFLG_CF (1<<0)\n\n#define EFLG_RESERVED_ZEROS_MASK 0xffc0802a\n#define EFLG_RESERVED_ONE_MASK 2\n\n/*\n * Instruction emulation:\n * Most instructions are emulated directly via a fragment of inline assembly\n * code. This allows us to save/restore EFLAGS and thus very easily pick up\n * any modified flags.\n */\n\n#if defined(CONFIG_X86_64)\n#define _LO32 \"k\"\t\t/* force 32-bit operand */\n#define _STK  \"%%rsp\"\t\t/* stack pointer */\n#elif defined(__i386__)\n#define _LO32 \"\"\t\t/* force 32-bit operand */\n#define _STK  \"%%esp\"\t\t/* stack pointer */\n#endif\n\n/*\n * These EFLAGS bits are restored from saved value during emulation, and\n * any changes are written back to the saved value after emulation.\n */\n#define EFLAGS_MASK (EFLG_OF|EFLG_SF|EFLG_ZF|EFLG_AF|EFLG_PF|EFLG_CF)\n\n/* Before executing instruction: restore necessary bits in EFLAGS. */\n#define _PRE_EFLAGS(_sav, _msk, _tmp)\t\t\t\t\t\\\n\t/* EFLAGS = (_sav & _msk) | (EFLAGS & ~_msk); _sav &= ~_msk; */ \\\n\t\"movl %\"_sav\",%\"_LO32 _tmp\"; \"                                  \\\n\t\"push %\"_tmp\"; \"                                                \\\n\t\"push %\"_tmp\"; \"                                                \\\n\t\"movl %\"_msk\",%\"_LO32 _tmp\"; \"                                  \\\n\t\"andl %\"_LO32 _tmp\",(\"_STK\"); \"                                 \\\n\t\"pushf; \"                                                       \\\n\t\"notl %\"_LO32 _tmp\"; \"                                          \\\n\t\"andl %\"_LO32 _tmp\",(\"_STK\"); \"                                 \\\n\t\"andl %\"_LO32 _tmp\",\"__stringify(BITS_PER_LONG/4)\"(\"_STK\"); \"\t\\\n\t\"pop  %\"_tmp\"; \"                                                \\\n\t\"orl  %\"_LO32 _tmp\",(\"_STK\"); \"                                 \\\n\t\"popf; \"                                                        \\\n\t\"pop  %\"_sav\"; \"\n\n/* After executing instruction: write-back necessary bits in EFLAGS. */\n#define _POST_EFLAGS(_sav, _msk, _tmp) \\\n\t/* _sav |= EFLAGS & _msk; */\t\t\\\n\t\"pushf; \"\t\t\t\t\\\n\t\"pop  %\"_tmp\"; \"\t\t\t\\\n\t\"andl %\"_msk\",%\"_LO32 _tmp\"; \"\t\t\\\n\t\"orl  %\"_LO32 _tmp\",%\"_sav\"; \"\n\n#ifdef CONFIG_X86_64\n#define ON64(x) x\n#else\n#define ON64(x)\n#endif\n\n#define ____emulate_2op(ctxt, _op, _x, _y, _suffix, _dsttype)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"4\", \"2\")\t\t\t\\\n\t\t\t_op _suffix \" %\"_x\"3,%1; \"\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"4\", \"2\")\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags),\t\t\t\\\n\t\t\t  \"+q\" (*(_dsttype*)&(ctxt)->dst.val),\t\t\\\n\t\t\t  \"=&r\" (_tmp)\t\t\t\t\t\\\n\t\t\t: _y ((ctxt)->src.val), \"i\" (EFLAGS_MASK));\t\\\n\t} while (0)\n\n\n/* Raw emulation: instruction has two explicit operands. */\n#define __emulate_2op_nobyte(ctxt,_op,_wx,_wy,_lx,_ly,_qx,_qy)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\t\t____emulate_2op(ctxt,_op,_wx,_wy,\"w\",u16);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\t____emulate_2op(ctxt,_op,_lx,_ly,\"l\",u32);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 8:\t\t\t\t\t\t\t\\\n\t\t\tON64(____emulate_2op(ctxt,_op,_qx,_qy,\"q\",u64)); \\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __emulate_2op(ctxt,_op,_bx,_by,_wx,_wy,_lx,_ly,_qx,_qy)\t\t     \\\n\tdo {\t\t\t\t\t\t\t\t     \\\n\t\tunsigned long _tmp;\t\t\t\t\t     \\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t     \\\n\t\tcase 1:\t\t\t\t\t\t\t     \\\n\t\t\t____emulate_2op(ctxt,_op,_bx,_by,\"b\",u8);\t     \\\n\t\t\tbreak;\t\t\t\t\t\t     \\\n\t\tdefault:\t\t\t\t\t\t     \\\n\t\t\t__emulate_2op_nobyte(ctxt, _op,\t\t\t     \\\n\t\t\t\t\t     _wx, _wy, _lx, _ly, _qx, _qy);  \\\n\t\t\tbreak;\t\t\t\t\t\t     \\\n\t\t}\t\t\t\t\t\t\t     \\\n\t} while (0)\n\n/* Source operand is byte-sized and may be restricted to just %cl. */\n#define emulate_2op_SrcB(ctxt, _op)\t\t\t\t\t\\\n\t__emulate_2op(ctxt, _op, \"b\", \"c\", \"b\", \"c\", \"b\", \"c\", \"b\", \"c\")\n\n/* Source operand is byte, word, long or quad sized. */\n#define emulate_2op_SrcV(ctxt, _op)\t\t\t\t\t\\\n\t__emulate_2op(ctxt, _op, \"b\", \"q\", \"w\", \"r\", _LO32, \"r\", \"\", \"r\")\n\n/* Source operand is word, long or quad sized. */\n#define emulate_2op_SrcV_nobyte(ctxt, _op)\t\t\t\t\\\n\t__emulate_2op_nobyte(ctxt, _op, \"w\", \"r\", _LO32, \"r\", \"\", \"r\")\n\n/* Instruction has three operands and one operand is stored in ECX register */\n#define __emulate_2op_cl(ctxt, _op, _suffix, _type)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\t_type _clv  = (ctxt)->src2.val;\t\t\t\t\\\n\t\t_type _srcv = (ctxt)->src.val;\t\t\t\t\\\n\t\t_type _dstv = (ctxt)->dst.val;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"5\", \"2\")\t\t\t\\\n\t\t\t_op _suffix \" %4,%1 \\n\"\t\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"5\", \"2\")\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags), \"+r\" (_dstv), \"=&r\" (_tmp) \\\n\t\t\t: \"c\" (_clv) , \"r\" (_srcv), \"i\" (EFLAGS_MASK)\t\\\n\t\t\t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t(ctxt)->src2.val  = (unsigned long) _clv;\t\t\\\n\t\t(ctxt)->src2.val = (unsigned long) _srcv;\t\t\\\n\t\t(ctxt)->dst.val = (unsigned long) _dstv;\t\t\\\n\t} while (0)\n\n#define emulate_2op_cl(ctxt, _op)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_2op_cl(ctxt, _op, \"w\", u16);\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_2op_cl(ctxt, _op, \"l\", u32);\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 8:\t\t\t\t\t\t\t\\\n\t\t\tON64(__emulate_2op_cl(ctxt, _op, \"q\", ulong));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __emulate_1op(ctxt, _op, _suffix)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"3\", \"2\")\t\t\t\\\n\t\t\t_op _suffix \" %1; \"\t\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"3\", \"2\")\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags), \"+m\" ((ctxt)->dst.val), \\\n\t\t\t  \"=&r\" (_tmp)\t\t\t\t\t\\\n\t\t\t: \"i\" (EFLAGS_MASK));\t\t\t\t\\\n\t} while (0)\n\n/* Instruction has only one explicit operand (no source operand). */\n#define emulate_1op(ctxt, _op)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tswitch ((ctxt)->dst.bytes) {\t\t\t\t\\\n\t\tcase 1:\t__emulate_1op(ctxt, _op, \"b\"); break;\t\t\\\n\t\tcase 2:\t__emulate_1op(ctxt, _op, \"w\"); break;\t\t\\\n\t\tcase 4:\t__emulate_1op(ctxt, _op, \"l\"); break;\t\t\\\n\t\tcase 8:\tON64(__emulate_1op(ctxt, _op, \"q\")); break;\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __emulate_1op_rax_rdx(ctxt, _op, _suffix, _ex)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned long _tmp;\t\t\t\t\t\\\n\t\tulong *rax = &(ctxt)->regs[VCPU_REGS_RAX];\t\t\\\n\t\tulong *rdx = &(ctxt)->regs[VCPU_REGS_RDX];\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__asm__ __volatile__ (\t\t\t\t\t\\\n\t\t\t_PRE_EFLAGS(\"0\", \"5\", \"1\")\t\t\t\\\n\t\t\t\"1: \\n\\t\"\t\t\t\t\t\\\n\t\t\t_op _suffix \" %6; \"\t\t\t\t\\\n\t\t\t\"2: \\n\\t\"\t\t\t\t\t\\\n\t\t\t_POST_EFLAGS(\"0\", \"5\", \"1\")\t\t\t\\\n\t\t\t\".pushsection .fixup,\\\"ax\\\" \\n\\t\"\t\t\\\n\t\t\t\"3: movb $1, %4 \\n\\t\"\t\t\t\t\\\n\t\t\t\"jmp 2b \\n\\t\"\t\t\t\t\t\\\n\t\t\t\".popsection \\n\\t\"\t\t\t\t\\\n\t\t\t_ASM_EXTABLE(1b, 3b)\t\t\t\t\\\n\t\t\t: \"=m\" ((ctxt)->eflags), \"=&r\" (_tmp),\t\t\\\n\t\t\t  \"+a\" (*rax), \"+d\" (*rdx), \"+qm\"(_ex)\t\t\\\n\t\t\t: \"i\" (EFLAGS_MASK), \"m\" ((ctxt)->src.val),\t\\\n\t\t\t  \"a\" (*rax), \"d\" (*rdx));\t\t\t\\\n\t} while (0)\n\n/* instruction has only one source operand, destination is implicit (e.g. mul, div, imul, idiv) */\n#define emulate_1op_rax_rdx(ctxt, _op, _ex)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tswitch((ctxt)->src.bytes) {\t\t\t\t\\\n\t\tcase 1:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"b\", _ex);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"w\", _ex);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"l\", _ex);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase 8: ON64(\t\t\t\t\t\t\\\n\t\t\t__emulate_1op_rax_rdx(ctxt, _op, \"q\", _ex));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    enum x86_intercept intercept,\n\t\t\t\t    enum x86_intercept_stage stage)\n{\n\tstruct x86_instruction_info info = {\n\t\t.intercept  = intercept,\n\t\t.rep_prefix = ctxt->rep_prefix,\n\t\t.modrm_mod  = ctxt->modrm_mod,\n\t\t.modrm_reg  = ctxt->modrm_reg,\n\t\t.modrm_rm   = ctxt->modrm_rm,\n\t\t.src_val    = ctxt->src.val64,\n\t\t.src_bytes  = ctxt->src.bytes,\n\t\t.dst_bytes  = ctxt->dst.bytes,\n\t\t.ad_bytes   = ctxt->ad_bytes,\n\t\t.next_rip   = ctxt->eip,\n\t};\n\n\treturn ctxt->ops->intercept(ctxt, &info, stage);\n}\n\nstatic inline unsigned long ad_mask(struct x86_emulate_ctxt *ctxt)\n{\n\treturn (1UL << (ctxt->ad_bytes << 3)) - 1;\n}\n\n/* Access/update address held in a register, based on addressing mode. */\nstatic inline unsigned long\naddress_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\treturn reg;\n\telse\n\t\treturn reg & ad_mask(ctxt);\n}\n\nstatic inline unsigned long\nregister_address(struct x86_emulate_ctxt *ctxt, unsigned long reg)\n{\n\treturn address_mask(ctxt, reg);\n}\n\nstatic inline void\nregister_address_increment(struct x86_emulate_ctxt *ctxt, unsigned long *reg, int inc)\n{\n\tif (ctxt->ad_bytes == sizeof(unsigned long))\n\t\t*reg += inc;\n\telse\n\t\t*reg = (*reg & ~ad_mask(ctxt)) | ((*reg + inc) & ad_mask(ctxt));\n}\n\nstatic inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tregister_address_increment(ctxt, &ctxt->_eip, rel);\n}\n\nstatic u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}\n\nstatic void set_seg_override(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tctxt->has_seg_override = true;\n\tctxt->seg_override = seg;\n}\n\nstatic unsigned long seg_base(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && seg < VCPU_SREG_FS)\n\t\treturn 0;\n\n\treturn ctxt->ops->get_cached_segment_base(ctxt, seg);\n}\n\nstatic unsigned seg_override(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!ctxt->has_seg_override)\n\t\treturn 0;\n\n\treturn ctxt->seg_override;\n}\n\nstatic int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}\n\nstatic int emulate_db(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DB_VECTOR, 0, false);\n}\n\nstatic int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, GP_VECTOR, err, true);\n}\n\nstatic int emulate_ss(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, SS_VECTOR, err, true);\n}\n\nstatic int emulate_ud(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, UD_VECTOR, 0, false);\n}\n\nstatic int emulate_ts(struct x86_emulate_ctxt *ctxt, int err)\n{\n\treturn emulate_exception(ctxt, TS_VECTOR, err, true);\n}\n\nstatic int emulate_de(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, DE_VECTOR, 0, false);\n}\n\nstatic int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}\n\nstatic u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n{\n\tu16 selector;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);\n\treturn selector;\n}\n\nstatic void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t unsigned seg)\n{\n\tu16 dummy;\n\tu32 base3;\n\tstruct desc_struct desc;\n\n\tctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);\n\tctxt->ops->set_segment(ctxt, selector, &desc, base3, seg);\n}\n\nstatic int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write, bool fetch,\n\t\t     ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\tunsigned cpl, rpl;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (((signed long)la << 16) >> 16 != la)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment or read-only data segment */\n\t\tif (((desc.type & 8) || !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif ((desc.type & 8) || !(desc.type & 4)) {\n\t\t\t/* expand-up segment */\n\t\t\tif (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)\n\t\t\t\tgoto bad;\n\t\t} else {\n\t\t\t/* exapand-down segment */\n\t\t\tif (addr.ea <= lim || (u32)(addr.ea + size - 1) <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t\tif (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tcpl = ctxt->ops->cpl(ctxt);\n\t\trpl = sel & 3;\n\t\tcpl = max(cpl, rpl);\n\t\tif (!(desc.type & 8)) {\n\t\t\t/* data segment */\n\t\t\tif (cpl > desc.dpl)\n\t\t\t\tgoto bad;\n\t\t} else if ((desc.type & 8) && !(desc.type & 4)) {\n\t\t\t/* nonconforming code segment */\n\t\t\tif (cpl != desc.dpl)\n\t\t\t\tgoto bad;\n\t\t} else if ((desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* conforming code segment */\n\t\t\tif (cpl < desc.dpl)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (fetch ? ctxt->mode != X86EMUL_MODE_PROT64 : ctxt->ad_bytes != 8)\n\t\tla &= (u32)-1;\n\t*linear = la;\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, addr.seg);\n\telse\n\t\treturn emulate_gp(ctxt, addr.seg);\n}\n\nstatic int linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write,\n\t\t     ulong *linear)\n{\n\treturn __linearize(ctxt, addr, size, write, false, linear);\n}\n\n\nstatic int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct segmented_address addr,\n\t\t\t      void *data,\n\t\t\t      unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n}\n\n/*\n * Fetch the next byte of the instruction being emulated which is pointed to\n * by ctxt->_eip, then increment ctxt->_eip.\n *\n * Also prefetch the remaining bytes of the instruction without crossing page\n * boundary if they are not in fetch_cache yet.\n */\nstatic int do_insn_fetch_byte(struct x86_emulate_ctxt *ctxt, u8 *dest)\n{\n\tstruct fetch_cache *fc = &ctxt->fetch;\n\tint rc;\n\tint size, cur_size;\n\n\tif (ctxt->_eip == fc->end) {\n\t\tunsigned long linear;\n\t\tstruct segmented_address addr = { .seg = VCPU_SREG_CS,\n\t\t\t\t\t\t  .ea  = ctxt->_eip };\n\t\tcur_size = fc->end - fc->start;\n\t\tsize = min(15UL - cur_size,\n\t\t\t   PAGE_SIZE - offset_in_page(ctxt->_eip));\n\t\trc = __linearize(ctxt, addr, size, false, true, &linear);\n\t\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\t\treturn rc;\n\t\trc = ctxt->ops->fetch(ctxt, linear, fc->data + cur_size,\n\t\t\t\t      size, &ctxt->exception);\n\t\tif (unlikely(rc != X86EMUL_CONTINUE))\n\t\t\treturn rc;\n\t\tfc->end += size;\n\t}\n\t*dest = fc->data[ctxt->_eip - fc->start];\n\tctxt->_eip++;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t void *dest, unsigned size)\n{\n\tint rc;\n\n\t/* x86 instructions are limited to 15 bytes. */\n\tif (unlikely(ctxt->_eip + size - ctxt->eip > 15))\n\t\treturn X86EMUL_UNHANDLEABLE;\n\twhile (size--) {\n\t\trc = do_insn_fetch_byte(ctxt, dest++);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\n/* Fetch next part of the instruction being emulated. */\n#define insn_fetch(_type, _ctxt)\t\t\t\t\t\\\n({\tunsigned long _x;\t\t\t\t\t\t\\\n\trc = do_insn_fetch(_ctxt, &_x, sizeof(_type));\t\t\t\\\n\tif (rc != X86EMUL_CONTINUE)\t\t\t\t\t\\\n\t\tgoto done;\t\t\t\t\t\t\\\n\t(_type)_x;\t\t\t\t\t\t\t\\\n})\n\n#define insn_fetch_arr(_arr, _size, _ctxt)\t\t\t\t\\\n({\trc = do_insn_fetch(_ctxt, _arr, (_size));\t\t\t\\\n\tif (rc != X86EMUL_CONTINUE)\t\t\t\t\t\\\n\t\tgoto done;\t\t\t\t\t\t\\\n})\n\n/*\n * Given the 'reg' portion of a ModRM byte, and a register block, return a\n * pointer into the block that addresses the relevant register.\n * @highbyte_regs specifies whether to decode AH,CH,DH,BH.\n */\nstatic void *decode_register(u8 modrm_reg, unsigned long *regs,\n\t\t\t     int highbyte_regs)\n{\n\tvoid *p;\n\n\tp = &regs[modrm_reg];\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)&regs[modrm_reg & 3] + 1;\n\treturn p;\n}\n\nstatic int read_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   u16 *size, unsigned long *address, int op_bytes)\n{\n\tint rc;\n\n\tif (op_bytes == 2)\n\t\top_bytes = 3;\n\t*address = 0;\n\trc = segmented_read_std(ctxt, addr, size, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\taddr.ea += 2;\n\trc = segmented_read_std(ctxt, addr, address, op_bytes);\n\treturn rc;\n}\n\nstatic int test_cc(unsigned int condition, unsigned int flags)\n{\n\tint rc = 0;\n\n\tswitch ((condition & 15) >> 1) {\n\tcase 0: /* o */\n\t\trc |= (flags & EFLG_OF);\n\t\tbreak;\n\tcase 1: /* b/c/nae */\n\t\trc |= (flags & EFLG_CF);\n\t\tbreak;\n\tcase 2: /* z/e */\n\t\trc |= (flags & EFLG_ZF);\n\t\tbreak;\n\tcase 3: /* be/na */\n\t\trc |= (flags & (EFLG_CF|EFLG_ZF));\n\t\tbreak;\n\tcase 4: /* s */\n\t\trc |= (flags & EFLG_SF);\n\t\tbreak;\n\tcase 5: /* p/pe */\n\t\trc |= (flags & EFLG_PF);\n\t\tbreak;\n\tcase 7: /* le/ng */\n\t\trc |= (flags & EFLG_ZF);\n\t\t/* fall through */\n\tcase 6: /* l/nge */\n\t\trc |= (!(flags & EFLG_SF) != !(flags & EFLG_OF));\n\t\tbreak;\n\t}\n\n\t/* Odd condition identifiers (lsb == 1) have inverted sense. */\n\treturn (!!rc ^ (condition & 1));\n}\n\nstatic void fetch_register_operand(struct operand *op)\n{\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = *(u8 *)op->addr.reg;\n\t\tbreak;\n\tcase 2:\n\t\top->val = *(u16 *)op->addr.reg;\n\t\tbreak;\n\tcase 4:\n\t\top->val = *(u32 *)op->addr.reg;\n\t\tbreak;\n\tcase 8:\n\t\top->val = *(u64 *)op->addr.reg;\n\t\tbreak;\n\t}\n}\n\nstatic void read_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data, int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqu %%xmm0, %0\" : \"=m\"(*data)); break;\n\tcase 1: asm(\"movdqu %%xmm1, %0\" : \"=m\"(*data)); break;\n\tcase 2: asm(\"movdqu %%xmm2, %0\" : \"=m\"(*data)); break;\n\tcase 3: asm(\"movdqu %%xmm3, %0\" : \"=m\"(*data)); break;\n\tcase 4: asm(\"movdqu %%xmm4, %0\" : \"=m\"(*data)); break;\n\tcase 5: asm(\"movdqu %%xmm5, %0\" : \"=m\"(*data)); break;\n\tcase 6: asm(\"movdqu %%xmm6, %0\" : \"=m\"(*data)); break;\n\tcase 7: asm(\"movdqu %%xmm7, %0\" : \"=m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqu %%xmm8, %0\" : \"=m\"(*data)); break;\n\tcase 9: asm(\"movdqu %%xmm9, %0\" : \"=m\"(*data)); break;\n\tcase 10: asm(\"movdqu %%xmm10, %0\" : \"=m\"(*data)); break;\n\tcase 11: asm(\"movdqu %%xmm11, %0\" : \"=m\"(*data)); break;\n\tcase 12: asm(\"movdqu %%xmm12, %0\" : \"=m\"(*data)); break;\n\tcase 13: asm(\"movdqu %%xmm13, %0\" : \"=m\"(*data)); break;\n\tcase 14: asm(\"movdqu %%xmm14, %0\" : \"=m\"(*data)); break;\n\tcase 15: asm(\"movdqu %%xmm15, %0\" : \"=m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}\n\nstatic void write_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data,\n\t\t\t  int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqu %0, %%xmm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movdqu %0, %%xmm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movdqu %0, %%xmm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movdqu %0, %%xmm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movdqu %0, %%xmm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movdqu %0, %%xmm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movdqu %0, %%xmm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movdqu %0, %%xmm7\" : : \"m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqu %0, %%xmm8\" : : \"m\"(*data)); break;\n\tcase 9: asm(\"movdqu %0, %%xmm9\" : : \"m\"(*data)); break;\n\tcase 10: asm(\"movdqu %0, %%xmm10\" : : \"m\"(*data)); break;\n\tcase 11: asm(\"movdqu %0, %%xmm11\" : : \"m\"(*data)); break;\n\tcase 12: asm(\"movdqu %0, %%xmm12\" : : \"m\"(*data)); break;\n\tcase 13: asm(\"movdqu %0, %%xmm13\" : : \"m\"(*data)); break;\n\tcase 14: asm(\"movdqu %0, %%xmm14\" : : \"m\"(*data)); break;\n\tcase 15: asm(\"movdqu %0, %%xmm15\" : : \"m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}\n\nstatic void decode_register_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    struct operand *op,\n\t\t\t\t    int inhibit_bytereg)\n{\n\tunsigned reg = ctxt->modrm_reg;\n\tint highbyte_regs = ctxt->rex_prefix == 0;\n\n\tif (!(ctxt->d & ModRM))\n\t\treg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);\n\n\tif (ctxt->d & Sse) {\n\t\top->type = OP_XMM;\n\t\top->bytes = 16;\n\t\top->addr.xmm = reg;\n\t\tread_sse_reg(ctxt, &op->vec_val, reg);\n\t\treturn;\n\t}\n\n\top->type = OP_REG;\n\tif ((ctxt->d & ByteOp) && !inhibit_bytereg) {\n\t\top->addr.reg = decode_register(reg, ctxt->regs, highbyte_regs);\n\t\top->bytes = 1;\n\t} else {\n\t\top->addr.reg = decode_register(reg, ctxt->regs, 0);\n\t\top->bytes = ctxt->op_bytes;\n\t}\n\tfetch_register_operand(op);\n\top->orig_val = op->val;\n}\n\nstatic int decode_modrm(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct operand *op)\n{\n\tu8 sib;\n\tint index_reg = 0, base_reg = 0, scale;\n\tint rc = X86EMUL_CONTINUE;\n\tulong modrm_ea = 0;\n\n\tif (ctxt->rex_prefix) {\n\t\tctxt->modrm_reg = (ctxt->rex_prefix & 4) << 1;\t/* REX.R */\n\t\tindex_reg = (ctxt->rex_prefix & 2) << 2; /* REX.X */\n\t\tctxt->modrm_rm = base_reg = (ctxt->rex_prefix & 1) << 3; /* REG.B */\n\t}\n\n\tctxt->modrm = insn_fetch(u8, ctxt);\n\tctxt->modrm_mod |= (ctxt->modrm & 0xc0) >> 6;\n\tctxt->modrm_reg |= (ctxt->modrm & 0x38) >> 3;\n\tctxt->modrm_rm |= (ctxt->modrm & 0x07);\n\tctxt->modrm_seg = VCPU_SREG_DS;\n\n\tif (ctxt->modrm_mod == 3) {\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = decode_register(ctxt->modrm_rm,\n\t\t\t\t\t       ctxt->regs, ctxt->d & ByteOp);\n\t\tif (ctxt->d & Sse) {\n\t\t\top->type = OP_XMM;\n\t\t\top->bytes = 16;\n\t\t\top->addr.xmm = ctxt->modrm_rm;\n\t\t\tread_sse_reg(ctxt, &op->vec_val, ctxt->modrm_rm);\n\t\t\treturn rc;\n\t\t}\n\t\tfetch_register_operand(op);\n\t\treturn rc;\n\t}\n\n\top->type = OP_MEM;\n\n\tif (ctxt->ad_bytes == 2) {\n\t\tunsigned bx = ctxt->regs[VCPU_REGS_RBX];\n\t\tunsigned bp = ctxt->regs[VCPU_REGS_RBP];\n\t\tunsigned si = ctxt->regs[VCPU_REGS_RSI];\n\t\tunsigned di = ctxt->regs[VCPU_REGS_RDI];\n\n\t\t/* 16-bit ModR/M decode. */\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 6)\n\t\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(u16, ctxt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ctxt->modrm_rm) {\n\t\tcase 0:\n\t\t\tmodrm_ea += bx + si;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += bx + di;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += bp + si;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmodrm_ea += bp + di;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmodrm_ea += si;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmodrm_ea += di;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (ctxt->modrm_mod != 0)\n\t\t\t\tmodrm_ea += bp;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmodrm_ea += bx;\n\t\t\tbreak;\n\t\t}\n\t\tif (ctxt->modrm_rm == 2 || ctxt->modrm_rm == 3 ||\n\t\t    (ctxt->modrm_rm == 6 && ctxt->modrm_mod != 0))\n\t\t\tctxt->modrm_seg = VCPU_SREG_SS;\n\t\tmodrm_ea = (u16)modrm_ea;\n\t} else {\n\t\t/* 32/64-bit ModR/M decode. */\n\t\tif ((ctxt->modrm_rm & 7) == 4) {\n\t\t\tsib = insn_fetch(u8, ctxt);\n\t\t\tindex_reg |= (sib >> 3) & 7;\n\t\t\tbase_reg |= sib & 7;\n\t\t\tscale = sib >> 6;\n\n\t\t\tif ((base_reg & 7) == 5 && ctxt->modrm_mod == 0)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\telse\n\t\t\t\tmodrm_ea += ctxt->regs[base_reg];\n\t\t\tif (index_reg != 4)\n\t\t\t\tmodrm_ea += ctxt->regs[index_reg] << scale;\n\t\t} else if ((ctxt->modrm_rm & 7) == 5 && ctxt->modrm_mod == 0) {\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->rip_relative = 1;\n\t\t} else\n\t\t\tmodrm_ea += ctxt->regs[ctxt->modrm_rm];\n\t\tswitch (ctxt->modrm_mod) {\n\t\tcase 0:\n\t\t\tif (ctxt->modrm_rm == 5)\n\t\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmodrm_ea += insn_fetch(s8, ctxt);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmodrm_ea += insn_fetch(s32, ctxt);\n\t\t\tbreak;\n\t\t}\n\t}\n\top->addr.mem.ea = modrm_ea;\ndone:\n\treturn rc;\n}\n\nstatic int decode_abs(struct x86_emulate_ctxt *ctxt,\n\t\t      struct operand *op)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_MEM;\n\tswitch (ctxt->ad_bytes) {\n\tcase 2:\n\t\top->addr.mem.ea = insn_fetch(u16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->addr.mem.ea = insn_fetch(u32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->addr.mem.ea = insn_fetch(u64, ctxt);\n\t\tbreak;\n\t}\ndone:\n\treturn rc;\n}\n\nstatic void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~(ctxt->dst.bytes * 8 - 1);\n\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\n\t\tctxt->dst.addr.mem.ea += (sv >> 3);\n\t}\n\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}\n\nstatic int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\twhile (size) {\n\t\tint n = min(size, 8u);\n\t\tsize -= n;\n\t\tif (mc->pos < mc->end)\n\t\t\tgoto read_cached;\n\n\t\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, n,\n\t\t\t\t\t      &ctxt->exception);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\tmc->end += n;\n\n\tread_cached:\n\t\tmemcpy(dest, mc->data + mc->pos, n);\n\t\tmc->pos += n;\n\t\tdest += n;\n\t\taddr += n;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int segmented_read(struct x86_emulate_ctxt *ctxt,\n\t\t\t  struct segmented_address addr,\n\t\t\t  void *data,\n\t\t\t  unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, false, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn read_emulated(ctxt, linear, data, size);\n}\n\nstatic int segmented_write(struct x86_emulate_ctxt *ctxt,\n\t\t\t   struct segmented_address addr,\n\t\t\t   const void *data,\n\t\t\t   unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_emulated(ctxt, linear, data, size,\n\t\t\t\t\t &ctxt->exception);\n}\n\nstatic int segmented_cmpxchg(struct x86_emulate_ctxt *ctxt,\n\t\t\t     struct segmented_address addr,\n\t\t\t     const void *orig_data, const void *data,\n\t\t\t     unsigned size)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->cmpxchg_emulated(ctxt, linear, orig_data, data,\n\t\t\t\t\t   size, &ctxt->exception);\n}\n\nstatic int pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t   unsigned int size, unsigned short port,\n\t\t\t   void *dest)\n{\n\tstruct read_cache *rc = &ctxt->io_read;\n\n\tif (rc->pos == rc->end) { /* refill pio read ahead */\n\t\tunsigned int in_page, n;\n\t\tunsigned int count = ctxt->rep_prefix ?\n\t\t\taddress_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) : 1;\n\t\tin_page = (ctxt->eflags & EFLG_DF) ?\n\t\t\toffset_in_page(ctxt->regs[VCPU_REGS_RDI]) :\n\t\t\tPAGE_SIZE - offset_in_page(ctxt->regs[VCPU_REGS_RDI]);\n\t\tn = min(min(in_page, (unsigned int)sizeof(rc->data)) / size,\n\t\t\tcount);\n\t\tif (n == 0)\n\t\t\tn = 1;\n\t\trc->pos = rc->end = 0;\n\t\tif (!ctxt->ops->pio_in_emulated(ctxt, size, port, rc->data, n))\n\t\t\treturn 0;\n\t\trc->end = n * size;\n\t}\n\n\tmemcpy(dest, rc->data + rc->pos, size);\n\trc->pos += size;\n\treturn 1;\n}\n\nstatic void get_descriptor_table_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 selector, struct desc_ptr *dt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\n\tif (selector & 1 << 2) {\n\t\tstruct desc_struct desc;\n\t\tu16 sel;\n\n\t\tmemset (dt, 0, sizeof *dt);\n\t\tif (!ops->get_segment(ctxt, &sel, &desc, NULL, VCPU_SREG_LDTR))\n\t\t\treturn;\n\n\t\tdt->size = desc_limit_scaled(&desc); /* what if limit > 65535? */\n\t\tdt->address = get_desc_base(&desc);\n\t} else\n\t\tops->get_gdt(ctxt, dt);\n}\n\n/* allowed just for 8 bytes segments */\nstatic int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->read_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t   &ctxt->exception);\n}\n\n/* allowed just for 8 bytes segments */\nstatic int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tu16 index = selector >> 3;\n\tulong addr;\n\n\tget_descriptor_table_ptr(ctxt, selector, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, selector & 0xfffc);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t    &ctxt->exception);\n}\n\n/* Does not support long mode */\nstatic int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tstruct desc_struct seg_desc;\n\tu8 dpl, rpl, cpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tint ret;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif ((seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86)\n\t    || ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tgoto load;\n\t}\n\n\t/* NULL selector is not valid for TR, CS and SS */\n\tif ((seg == VCPU_SREG_CS || seg == VCPU_SREG_SS || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = GP_VECTOR;\n\n\t/* can't load system descriptor into segment selecor */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s)\n\t\tgoto exception;\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\trpl = selector & 3;\n\tdpl = seg_desc.dpl;\n\tcpl = ctxt->ops->cpl(ctxt);\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tseg_desc.type |= 1;\n\t\tret = write_segment_descriptor(ctxt, selector, &seg_desc);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, 0, seg);\n\treturn X86EMUL_CONTINUE;\nexception:\n\temulate_exception(ctxt, err_vec, err_code, true);\n\treturn X86EMUL_PROPAGATE_FAULT;\n}\n\nstatic void write_register_operand(struct operand *op)\n{\n\t/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\t*(u8 *)op->addr.reg = (u8)op->val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)op->addr.reg = (u16)op->val;\n\t\tbreak;\n\tcase 4:\n\t\t*op->addr.reg = (u32)op->val;\n\t\tbreak;\t/* 64b: zero-extend */\n\tcase 8:\n\t\t*op->addr.reg = op->val;\n\t\tbreak;\n\t}\n}\n\nstatic int writeback(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\tswitch (ctxt->dst.type) {\n\tcase OP_REG:\n\t\twrite_register_operand(&ctxt->dst);\n\t\tbreak;\n\tcase OP_MEM:\n\t\tif (ctxt->lock_prefix)\n\t\t\trc = segmented_cmpxchg(ctxt,\n\t\t\t\t\t       ctxt->dst.addr.mem,\n\t\t\t\t\t       &ctxt->dst.orig_val,\n\t\t\t\t\t       &ctxt->dst.val,\n\t\t\t\t\t       ctxt->dst.bytes);\n\t\telse\n\t\t\trc = segmented_write(ctxt,\n\t\t\t\t\t     ctxt->dst.addr.mem,\n\t\t\t\t\t     &ctxt->dst.val,\n\t\t\t\t\t     ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\tbreak;\n\tcase OP_XMM:\n\t\twrite_sse_reg(ctxt, &ctxt->dst.vec_val, ctxt->dst.addr.xmm);\n\t\tbreak;\n\tcase OP_NONE:\n\t\t/* no writeback */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_push(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct segmented_address addr;\n\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP], -ctxt->op_bytes);\n\taddr.ea = register_address(ctxt, ctxt->regs[VCPU_REGS_RSP]);\n\taddr.seg = VCPU_SREG_SS;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, addr, &ctxt->src.val, ctxt->op_bytes);\n}\n\nstatic int emulate_pop(struct x86_emulate_ctxt *ctxt,\n\t\t       void *dest, int len)\n{\n\tint rc;\n\tstruct segmented_address addr;\n\n\taddr.ea = register_address(ctxt, ctxt->regs[VCPU_REGS_RSP]);\n\taddr.seg = VCPU_SREG_SS;\n\trc = segmented_read(ctxt, addr, dest, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP], len);\n\treturn rc;\n}\n\nstatic int em_pop(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}\n\nstatic int emulate_popf(struct x86_emulate_ctxt *ctxt,\n\t\t\tvoid *dest, int len)\n{\n\tint rc;\n\tunsigned long val, change_mask;\n\tint iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> IOPL_SHIFT;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\n\trc = emulate_pop(ctxt, &val, len);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tchange_mask = EFLG_CF | EFLG_PF | EFLG_AF | EFLG_ZF | EFLG_SF | EFLG_OF\n\t\t| EFLG_TF | EFLG_DF | EFLG_NT | EFLG_RF | EFLG_AC | EFLG_ID;\n\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT16:\n\t\tif (cpl == 0)\n\t\t\tchange_mask |= EFLG_IOPL;\n\t\tif (cpl <= iopl)\n\t\t\tchange_mask |= EFLG_IF;\n\t\tbreak;\n\tcase X86EMUL_MODE_VM86:\n\t\tif (iopl < 3)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tchange_mask |= EFLG_IF;\n\t\tbreak;\n\tdefault: /* real mode */\n\t\tchange_mask |= (EFLG_IOPL | EFLG_IF);\n\t\tbreak;\n\t}\n\n\t*(unsigned long *)dest =\n\t\t(ctxt->eflags & ~change_mask) | (val & change_mask);\n\n\treturn rc;\n}\n\nstatic int em_popf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->eflags;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn emulate_popf(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n}\n\nstatic int em_push_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\n\tctxt->src.val = get_segment_selector(ctxt, seg);\n\n\treturn em_push(ctxt);\n}\n\nstatic int em_pop_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned long selector;\n\tint rc;\n\n\trc = emulate_pop(ctxt, &selector, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)selector, seg);\n\treturn rc;\n}\n\nstatic int em_pusha(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long old_esp = ctxt->regs[VCPU_REGS_RSP];\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RAX;\n\n\twhile (reg <= VCPU_REGS_RDI) {\n\t\t(reg == VCPU_REGS_RSP) ?\n\t\t(ctxt->src.val = old_esp) : (ctxt->src.val = ctxt->regs[reg]);\n\n\t\trc = em_push(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\n\t\t++reg;\n\t}\n\n\treturn rc;\n}\n\nstatic int em_pushf(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.val =  (unsigned long)ctxt->eflags;\n\treturn em_push(ctxt);\n}\n\nstatic int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP],\n\t\t\t\t\t\t\tctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\n\t\trc = emulate_pop(ctxt, &ctxt->regs[reg], ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\t--reg;\n\t}\n\treturn rc;\n}\n\nint emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(EFLG_IF | EFLG_TF | EFLG_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = eip;\n\n\treturn rc;\n}\n\nstatic int emulate_int(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn emulate_int_real(ctxt, irq);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* Protected mode interrupts unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}\n\nstatic int emulate_iret_real(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tunsigned long temp_eip = 0;\n\tunsigned long temp_eflags = 0;\n\tunsigned long cs = 0;\n\tunsigned long mask = EFLG_CF | EFLG_PF | EFLG_AF | EFLG_ZF | EFLG_SF | EFLG_TF |\n\t\t\t     EFLG_IF | EFLG_DF | EFLG_OF | EFLG_IOPL | EFLG_NT | EFLG_RF |\n\t\t\t     EFLG_AC | EFLG_ID | (1 << 1); /* Last one is the reserved bit */\n\tunsigned long vm86_mask = EFLG_VM | EFLG_VIF | EFLG_VIP;\n\n\t/* TODO: Add stack limit check */\n\n\trc = emulate_pop(ctxt, &temp_eip, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (temp_eip & ~0xffff)\n\t\treturn emulate_gp(ctxt, 0);\n\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = emulate_pop(ctxt, &temp_eflags, ctxt->op_bytes);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = temp_eip;\n\n\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->eflags = ((temp_eflags & mask) | (ctxt->eflags & vm86_mask));\n\telse if (ctxt->op_bytes == 2) {\n\t\tctxt->eflags &= ~0xffff;\n\t\tctxt->eflags |= temp_eflags;\n\t}\n\n\tctxt->eflags &= ~EFLG_RESERVED_ZEROS_MASK; /* Clear reserved zeros */\n\tctxt->eflags |= EFLG_RESERVED_ONE_MASK;\n\n\treturn rc;\n}\n\nstatic int em_iret(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch(ctxt->mode) {\n\tcase X86EMUL_MODE_REAL:\n\t\treturn emulate_iret_real(ctxt);\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\tcase X86EMUL_MODE_PROT32:\n\tcase X86EMUL_MODE_PROT64:\n\tdefault:\n\t\t/* iret from protected mode unimplemented yet */\n\t\treturn X86EMUL_UNHANDLEABLE;\n\t}\n}\n\nstatic int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = load_segment_descriptor(ctxt, sel, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->_eip = 0;\n\tmemcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_grp2(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch (ctxt->modrm_reg) {\n\tcase 0:\t/* rol */\n\t\temulate_2op_SrcB(ctxt, \"rol\");\n\t\tbreak;\n\tcase 1:\t/* ror */\n\t\temulate_2op_SrcB(ctxt, \"ror\");\n\t\tbreak;\n\tcase 2:\t/* rcl */\n\t\temulate_2op_SrcB(ctxt, \"rcl\");\n\t\tbreak;\n\tcase 3:\t/* rcr */\n\t\temulate_2op_SrcB(ctxt, \"rcr\");\n\t\tbreak;\n\tcase 4:\t/* sal/shl */\n\tcase 6:\t/* sal/shl */\n\t\temulate_2op_SrcB(ctxt, \"sal\");\n\t\tbreak;\n\tcase 5:\t/* shr */\n\t\temulate_2op_SrcB(ctxt, \"shr\");\n\t\tbreak;\n\tcase 7:\t/* sar */\n\t\temulate_2op_SrcB(ctxt, \"sar\");\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_not(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ~ctxt->dst.val;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_neg(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_1op(ctxt, \"neg\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mul_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 ex = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"mul\", ex);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_imul_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 ex = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"imul\", ex);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_div_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 de = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"div\", de);\n\tif (de)\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_idiv_ex(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 de = 0;\n\n\temulate_1op_rax_rdx(ctxt, \"idiv\", de);\n\tif (de)\n\t\treturn emulate_de(ctxt);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (ctxt->modrm_reg) {\n\tcase 0:\t/* inc */\n\t\temulate_1op(ctxt, \"inc\");\n\t\tbreak;\n\tcase 1:\t/* dec */\n\t\temulate_1op(ctxt, \"dec\");\n\t\tbreak;\n\tcase 2: /* call near abs */ {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: /* jmp abs */\n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: /* jmp far */\n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t/* push */\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 old = ctxt->dst.orig_val64;\n\n\tif (((u32) (old >> 0) != (u32) ctxt->regs[VCPU_REGS_RAX]) ||\n\t    ((u32) (old >> 32) != (u32) ctxt->regs[VCPU_REGS_RDX])) {\n\t\tctxt->regs[VCPU_REGS_RAX] = (u32) (old >> 0);\n\t\tctxt->regs[VCPU_REGS_RDX] = (u32) (old >> 32);\n\t\tctxt->eflags &= ~EFLG_ZF;\n\t} else {\n\t\tctxt->dst.val64 = ((u64)ctxt->regs[VCPU_REGS_RCX] << 32) |\n\t\t\t(u32) ctxt->regs[VCPU_REGS_RBX];\n\n\t\tctxt->eflags |= EFLG_ZF;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn em_pop(ctxt);\n}\n\nstatic int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long cs;\n\n\trc = emulate_pop(ctxt, &ctxt->_eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->_eip = (u32)ctxt->_eip;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n\treturn rc;\n}\n\nstatic int em_cmpxchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Save real source value, then compare EAX against destination. */\n\tctxt->src.orig_val = ctxt->src.val;\n\tctxt->src.val = ctxt->regs[VCPU_REGS_RAX];\n\temulate_2op_SrcV(ctxt, \"cmp\");\n\n\tif (ctxt->eflags & EFLG_ZF) {\n\t\t/* Success: write back to memory. */\n\t\tctxt->dst.val = ctxt->src.orig_val;\n\t} else {\n\t\t/* Failure: write the value we saw to EAX. */\n\t\tctxt->dst.type = OP_REG;\n\t\tctxt->dst.addr.reg = (unsigned long *)&ctxt->regs[VCPU_REGS_RAX];\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_lseg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned short sel;\n\tint rc;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = load_segment_descriptor(ctxt, sel, seg);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->dst.val = ctxt->src.val;\n\treturn rc;\n}\n\nstatic void\nsetup_syscalls_segments(struct x86_emulate_ctxt *ctxt,\n\t\t\tstruct desc_struct *cs, struct desc_struct *ss)\n{\n\tu16 selector;\n\n\tmemset(cs, 0, sizeof(struct desc_struct));\n\tctxt->ops->get_segment(ctxt, &selector, cs, NULL, VCPU_SREG_CS);\n\tmemset(ss, 0, sizeof(struct desc_struct));\n\n\tcs->l = 0;\t\t/* will be adjusted later */\n\tset_desc_base(cs, 0);\t/* flat segment */\n\tcs->g = 1;\t\t/* 4kb granularity */\n\tset_desc_limit(cs, 0xfffff);\t/* 4GB limit */\n\tcs->type = 0x0b;\t/* Read, Execute, Accessed */\n\tcs->s = 1;\n\tcs->dpl = 0;\t\t/* will be adjusted later */\n\tcs->p = 1;\n\tcs->d = 1;\n\n\tset_desc_base(ss, 0);\t/* flat segment */\n\tset_desc_limit(ss, 0xfffff);\t/* 4GB limit */\n\tss->g = 1;\t\t/* 4kb granularity */\n\tss->s = 1;\n\tss->type = 0x03;\t/* Read/Write, Accessed */\n\tss->d = 1;\t\t/* 32bit stack segment */\n\tss->dpl = 0;\n\tss->p = 1;\n}\n\nstatic bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\n\t/*\n\t * syscall should always be enabled in longmode - so only become\n\t * vendor specific (cpuid) if other modes are active...\n\t */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tif (ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx)) {\n\t\t/*\n\t\t * Intel (\"GenuineIntel\")\n\t\t * remark: Intel CPUs only support \"syscall\" in 64bit\n\t\t * longmode. Also an 64bit guest with a\n\t\t * 32bit compat-app running will #UD !! While this\n\t\t * behaviour can be fixed (by emulating) into AMD\n\t\t * response - CPUs of AMD can't behave like Intel.\n\t\t */\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\t\treturn false;\n\n\t\t/* AMD (\"AuthenticAMD\") */\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\t\treturn true;\n\n\t\t/* AMD (\"AMDisbetter!\") */\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\t\treturn true;\n\t}\n\n\t/* default: (not Intel, not AMD), apply Intel's stricter rules... */\n\treturn false;\n}\n\nstatic int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\n\tif (!(em_syscall_is_enabled(ctxt)))\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tif (!(efer & EFER_SCE))\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\t/* inject #GP if in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* XXX sysenter/sysexit have not been tested in 64bit mode.\n\t* Therefore, we inject an #UD.\n\t*/\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_ud(ctxt);\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\t}\n\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\tctxt->regs[VCPU_REGS_RSP] = msr_data;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\n\t/* inject #GP if in real mode or Virtual 8086 mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->_eip = ctxt->regs[VCPU_REGS_RDX];\n\tctxt->regs[VCPU_REGS_RSP] = ctxt->regs[VCPU_REGS_RCX];\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)\n{\n\tint iopl;\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn false;\n\tif (ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn true;\n\tiopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> IOPL_SHIFT;\n\treturn ctxt->ops->cpl(ctxt) > iopl;\n}\n\nstatic bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t u16 port, u16 len)\n{\n\tif (ctxt->perm_ok)\n\t\treturn true;\n\n\tif (emulator_bad_iopl(ctxt))\n\t\tif (!emulator_io_port_access_allowed(ctxt, port, len))\n\t\t\treturn false;\n\n\tctxt->perm_ok = true;\n\n\treturn true;\n}\n\nstatic void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = ctxt->regs[VCPU_REGS_RAX];\n\ttss->cx = ctxt->regs[VCPU_REGS_RCX];\n\ttss->dx = ctxt->regs[VCPU_REGS_RDX];\n\ttss->bx = ctxt->regs[VCPU_REGS_RBX];\n\ttss->sp = ctxt->regs[VCPU_REGS_RSP];\n\ttss->bp = ctxt->regs[VCPU_REGS_RBP];\n\ttss->si = ctxt->regs[VCPU_REGS_RSI];\n\ttss->di = ctxt->regs[VCPU_REGS_RDI];\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}\n\nstatic int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\n\tctxt->_eip = tss->ip;\n\tctxt->eflags = tss->flag | 2;\n\tctxt->regs[VCPU_REGS_RAX] = tss->ax;\n\tctxt->regs[VCPU_REGS_RCX] = tss->cx;\n\tctxt->regs[VCPU_REGS_RDX] = tss->dx;\n\tctxt->regs[VCPU_REGS_RBX] = tss->bx;\n\tctxt->regs[VCPU_REGS_RSP] = tss->sp;\n\tctxt->regs[VCPU_REGS_RBP] = tss->bp;\n\tctxt->regs[VCPU_REGS_RSI] = tss->si;\n\tctxt->regs[VCPU_REGS_RDI] = tss->di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t/* FIXME: need to provide precise fault address */\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}\n\nstatic void save_state_to_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_32 *tss)\n{\n\ttss->cr3 = ctxt->ops->get_cr(ctxt, 3);\n\ttss->eip = ctxt->_eip;\n\ttss->eflags = ctxt->eflags;\n\ttss->eax = ctxt->regs[VCPU_REGS_RAX];\n\ttss->ecx = ctxt->regs[VCPU_REGS_RCX];\n\ttss->edx = ctxt->regs[VCPU_REGS_RDX];\n\ttss->ebx = ctxt->regs[VCPU_REGS_RBX];\n\ttss->esp = ctxt->regs[VCPU_REGS_RSP];\n\ttss->ebp = ctxt->regs[VCPU_REGS_RBP];\n\ttss->esi = ctxt->regs[VCPU_REGS_RSI];\n\ttss->edi = ctxt->regs[VCPU_REGS_RDI];\n\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->fs = get_segment_selector(ctxt, VCPU_SREG_FS);\n\ttss->gs = get_segment_selector(ctxt, VCPU_SREG_GS);\n\ttss->ldt_selector = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}\n\nstatic int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_32 *tss)\n{\n\tint ret;\n\n\tif (ctxt->ops->set_cr(ctxt, 3, tss->cr3))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->_eip = tss->eip;\n\tctxt->eflags = tss->eflags | 2;\n\tctxt->regs[VCPU_REGS_RAX] = tss->eax;\n\tctxt->regs[VCPU_REGS_RCX] = tss->ecx;\n\tctxt->regs[VCPU_REGS_RDX] = tss->edx;\n\tctxt->regs[VCPU_REGS_RBX] = tss->ebx;\n\tctxt->regs[VCPU_REGS_RSP] = tss->esp;\n\tctxt->regs[VCPU_REGS_RBP] = tss->ebp;\n\tctxt->regs[VCPU_REGS_RSI] = tss->esi;\n\tctxt->regs[VCPU_REGS_RDI] = tss->edi;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\tset_segment_selector(ctxt, tss->fs, VCPU_SREG_FS);\n\tset_segment_selector(ctxt, tss->gs, VCPU_SREG_GS);\n\n\t/*\n\t * Now load segment descriptors. If fault happenes at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int task_switch_32(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_32 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tsave_state_to_tss32(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\t/* FIXME: need to provide precise fault address */\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t/* FIXME: need to provide precise fault address */\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss32(ctxt, &tss_seg);\n}\n\nstatic int emulator_do_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 tss_selector, int reason,\n\t\t\t\t   bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct curr_tss_desc, next_tss_desc;\n\tint ret;\n\tu16 old_tss_sel = get_segment_selector(ctxt, VCPU_SREG_TR);\n\tulong old_tss_base =\n\t\tops->get_cached_segment_base(ctxt, VCPU_SREG_TR);\n\tu32 desc_limit;\n\n\t/* FIXME: old_tss_base == ~0 ? */\n\n\tret = read_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = read_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\t/* FIXME: check that next_tss_desc is tss */\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tif ((tss_selector & 3) > next_tss_desc.dpl ||\n\t\t    ops->cpl(ctxt) > next_tss_desc.dpl)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\n\n\tdesc_limit = desc_limit_scaled(&next_tss_desc);\n\tif (!next_tss_desc.p ||\n\t    ((desc_limit < 0x67 && (next_tss_desc.type & 8)) ||\n\t     desc_limit < 0x2b)) {\n\t\temulate_ts(ctxt, tss_selector & 0xfffc);\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t}\n\n\tif (reason == TASK_SWITCH_IRET || reason == TASK_SWITCH_JMP) {\n\t\tcurr_tss_desc.type &= ~(1 << 1); /* clear busy flag */\n\t\twrite_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc);\n\t}\n\n\tif (reason == TASK_SWITCH_IRET)\n\t\tctxt->eflags = ctxt->eflags & ~X86_EFLAGS_NT;\n\n\t/* set back link to prev task only if NT bit is set in eflags\n\t   note that old_tss_sel is not used afetr this point */\n\tif (reason != TASK_SWITCH_CALL && reason != TASK_SWITCH_GATE)\n\t\told_tss_sel = 0xffff;\n\n\tif (next_tss_desc.type & 8)\n\t\tret = task_switch_32(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\telse\n\t\tret = task_switch_16(ctxt, tss_selector, old_tss_sel,\n\t\t\t\t     old_tss_base, &next_tss_desc);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (reason == TASK_SWITCH_CALL || reason == TASK_SWITCH_GATE)\n\t\tctxt->eflags = ctxt->eflags | X86_EFLAGS_NT;\n\n\tif (reason != TASK_SWITCH_IRET) {\n\t\tnext_tss_desc.type |= (1 << 1); /* set busy flag */\n\t\twrite_segment_descriptor(ctxt, tss_selector, &next_tss_desc);\n\t}\n\n\tops->set_cr(ctxt, 0,  ops->get_cr(ctxt, 0) | X86_CR0_TS);\n\tops->set_segment(ctxt, tss_selector, &next_tss_desc, 0, VCPU_SREG_TR);\n\n\tif (has_error_code) {\n\t\tctxt->op_bytes = ctxt->ad_bytes = (next_tss_desc.type & 8) ? 4 : 2;\n\t\tctxt->lock_prefix = 0;\n\t\tctxt->src.val = (unsigned long) error_code;\n\t\tret = em_push(ctxt);\n\t}\n\n\treturn ret;\n}\n\nint emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int reason,\n\t\t\t bool has_error_code, u32 error_code)\n{\n\tint rc;\n\n\tctxt->_eip = ctxt->eip;\n\tctxt->dst.type = OP_NONE;\n\n\trc = emulator_do_task_switch(ctxt, tss_selector, reason,\n\t\t\t\t     has_error_code, error_code);\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->eip = ctxt->_eip;\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n}\n\nstatic void string_addr_inc(struct x86_emulate_ctxt *ctxt, unsigned seg,\n\t\t\t    int reg, struct operand *op)\n{\n\tint df = (ctxt->eflags & EFLG_DF) ? -1 : 1;\n\n\tregister_address_increment(ctxt, &ctxt->regs[reg], df * op->bytes);\n\top->addr.mem.ea = register_address(ctxt, ctxt->regs[reg]);\n\top->addr.mem.seg = seg;\n}\n\nstatic int em_das(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al, old_al;\n\tbool af, cf, old_cf;\n\n\tcf = ctxt->eflags & X86_EFLAGS_CF;\n\tal = ctxt->dst.val;\n\n\told_al = al;\n\told_cf = cf;\n\tcf = false;\n\taf = ctxt->eflags & X86_EFLAGS_AF;\n\tif ((al & 0x0f) > 9 || af) {\n\t\tal -= 6;\n\t\tcf = old_cf | (al >= 250);\n\t\taf = true;\n\t} else {\n\t\taf = false;\n\t}\n\tif (old_al > 0x99 || old_cf) {\n\t\tal -= 0x60;\n\t\tcf = true;\n\t}\n\n\tctxt->dst.val = al;\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\temulate_2op_SrcV(ctxt, \"or\");\n\tctxt->eflags &= ~(X86_EFLAGS_AF | X86_EFLAGS_CF);\n\tif (cf)\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\tif (af)\n\t\tctxt->eflags |= X86_EFLAGS_AF;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tlong rel = ctxt->src.val;\n\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\tjmp_rel(ctxt, rel);\n\treturn em_push(ctxt);\n}\n\nstatic int em_call_far(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel, old_cs;\n\tulong old_eip;\n\tint rc;\n\n\told_cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\told_eip = ctxt->_eip;\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\tif (load_segment_descriptor(ctxt, sel, VCPU_SREG_CS))\n\t\treturn X86EMUL_CONTINUE;\n\n\tctxt->_eip = 0;\n\tmemcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);\n\n\tctxt->src.val = old_cs;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = old_eip;\n\treturn em_push(ctxt);\n}\n\nstatic int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP], ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_add(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"add\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_or(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"or\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_adc(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"adc\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sbb(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"sbb\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_and(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"and\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sub(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"sub\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_xor(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"xor\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_cmp(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"cmp\");\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_test(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"test\");\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_xchg(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Write back the register source. */\n\tctxt->src.val = ctxt->dst.val;\n\twrite_register_operand(&ctxt->src);\n\n\t/* Write back the memory destination with implicit LOCK prefix. */\n\tctxt->dst.val = ctxt->src.orig_val;\n\tctxt->lock_prefix = 1;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_imul(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"imul\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_imul_3op(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ctxt->src2.val;\n\treturn em_imul(ctxt);\n}\n\nstatic int em_cwd(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.bytes = ctxt->src.bytes;\n\tctxt->dst.addr.reg = &ctxt->regs[VCPU_REGS_RDX];\n\tctxt->dst.val = ~((ctxt->src.val >> (ctxt->src.bytes * 8 - 1)) - 1);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 tsc = 0;\n\n\tctxt->ops->get_msr(ctxt, MSR_IA32_TSC, &tsc);\n\tctxt->regs[VCPU_REGS_RAX] = (u32)tsc;\n\tctxt->regs[VCPU_REGS_RDX] = tsc >> 32;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 pmc;\n\n\tif (ctxt->ops->read_pmc(ctxt, ctxt->regs[VCPU_REGS_RCX], &pmc))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->regs[VCPU_REGS_RAX] = (u32)pmc;\n\tctxt->regs[VCPU_REGS_RDX] = pmc >> 32;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mov(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.val = ctxt->src.val;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->ops->set_cr(ctxt, ctxt->modrm_reg, ctxt->src.val))\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long val;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tval = ctxt->src.val & ~0ULL;\n\telse\n\t\tval = ctxt->src.val & ~0U;\n\n\t/* #UD condition is already handled. */\n\tif (ctxt->ops->set_dr(ctxt, ctxt->modrm_reg, val) < 0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_wrmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tmsr_data = (u32)ctxt->regs[VCPU_REGS_RAX]\n\t\t| ((u64)ctxt->regs[VCPU_REGS_RDX] << 32);\n\tif (ctxt->ops->set_msr(ctxt, ctxt->regs[VCPU_REGS_RCX], msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_rdmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\n\tif (ctxt->ops->get_msr(ctxt, ctxt->regs[VCPU_REGS_RCX], &msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->regs[VCPU_REGS_RAX] = (u32)msr_data;\n\tctxt->regs[VCPU_REGS_RDX] = msr_data >> 32;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mov_rm_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tif (ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tctxt->dst.val = get_segment_selector(ctxt, ctxt->modrm_reg);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_mov_sreg_rm(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel = ctxt->src.val;\n\n\tif (ctxt->modrm_reg == VCPU_SREG_CS || ctxt->modrm_reg > VCPU_SREG_GS)\n\t\treturn emulate_ud(ctxt);\n\n\tif (ctxt->modrm_reg == VCPU_SREG_SS)\n\t\tctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn load_segment_descriptor(ctxt, sel, ctxt->modrm_reg);\n}\n\nstatic int em_movdqu(struct x86_emulate_ctxt *ctxt)\n{\n\tmemcpy(&ctxt->dst.vec_val, &ctxt->src.vec_val, ctxt->op_bytes);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_invlpg(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tulong linear;\n\n\trc = linearize(ctxt, ctxt->src.addr.mem, 1, false, &linear);\n\tif (rc == X86EMUL_CONTINUE)\n\t\tctxt->ops->invlpg(ctxt, linear);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_clts(struct x86_emulate_ctxt *ctxt)\n{\n\tulong cr0;\n\n\tcr0 = ctxt->ops->get_cr(ctxt, 0);\n\tcr0 &= ~X86_CR0_TS;\n\tctxt->ops->set_cr(ctxt, 0, cr0);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_vmcall(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\tif (ctxt->modrm_mod != 3 || ctxt->modrm_rm != 1)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\trc = ctxt->ops->fix_hypercall(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\t/* Let the processor re-execute the fixed hypercall */\n\tctxt->_eip = ctxt->eip;\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_lgdt(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_vmmcall(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\n\trc = ctxt->ops->fix_hypercall(ctxt);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn rc;\n}\n\nstatic int em_lidt(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->set_idt(ctxt, &desc_ptr);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_smsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = 2;\n\tctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_lmsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->set_cr(ctxt, 0, (ctxt->ops->get_cr(ctxt, 0) & ~0x0eul)\n\t\t\t  | (ctxt->src.val & 0x0f));\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RCX], -1);\n\tif ((address_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_in(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!pio_in_emulated(ctxt, ctxt->dst.bytes, ctxt->src.val,\n\t\t\t     &ctxt->dst.val))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->ops->pio_out_emulated(ctxt, ctxt->src.bytes, ctxt->dst.val,\n\t\t\t\t    &ctxt->src.val, 1);\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_cli(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->eflags &= ~X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_sti(struct x86_emulate_ctxt *ctxt)\n{\n\tif (emulator_bad_iopl(ctxt))\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->interruptibility = KVM_X86_SHADOW_INT_STI;\n\tctxt->eflags |= X86_EFLAGS_IF;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\t/* only subword offset */\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bts(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"bts\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_btr(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"btr\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_btc(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"btc\");\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bsf(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\n\t__asm__ (\"bsf %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\t/* Disable writeback. */\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int em_bsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\n\t__asm__ (\"bsr %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\t/* Disable writeback. */\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int check_cr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!valid_cr(ctxt->modrm_reg))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint cr = ctxt->modrm_reg;\n\tu64 efer = 0;\n\n\tstatic u64 cr_reserved_bits[] = {\n\t\t0xffffffff00000000ULL,\n\t\t0, 0, 0, /* CR3 checked later */\n\t\tCR4_RESERVED_BITS,\n\t\t0, 0, 0,\n\t\tCR8_RESERVED_BITS,\n\t};\n\n\tif (!valid_cr(cr))\n\t\treturn emulate_ud(ctxt);\n\n\tif (new_val & cr_reserved_bits[cr])\n\t\treturn emulate_gp(ctxt, 0);\n\n\tswitch (cr) {\n\tcase 0: {\n\t\tu64 cr4;\n\t\tif (((new_val & X86_CR0_PG) && !(new_val & X86_CR0_PE)) ||\n\t\t    ((new_val & X86_CR0_NW) && !(new_val & X86_CR0_CD)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((new_val & X86_CR0_PG) && (efer & EFER_LME) &&\n\t\t    !(cr4 & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 3: {\n\t\tu64 rsvd = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (efer & EFER_LMA)\n\t\t\trsvd = CR3_L_MODE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_PAE)\n\t\t\trsvd = CR3_PAE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 0) & X86_CR0_PG)\n\t\t\trsvd = CR3_NONPAE_RESERVED_BITS;\n\n\t\tif (new_val & rsvd)\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 4: {\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((efer & EFER_LMA) && !(new_val & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_dr7_gd(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long dr7;\n\n\tctxt->ops->get_dr(ctxt, 7, &dr7);\n\n\t/* Check if DR7.Global_Enable is set */\n\treturn dr7 & (1 << 13);\n}\n\nstatic int check_dr_read(struct x86_emulate_ctxt *ctxt)\n{\n\tint dr = ctxt->modrm_reg;\n\tu64 cr4;\n\n\tif (dr > 7)\n\t\treturn emulate_ud(ctxt);\n\n\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\tif ((cr4 & X86_CR4_DE) && (dr == 4 || dr == 5))\n\t\treturn emulate_ud(ctxt);\n\n\tif (check_dr7_gd(ctxt))\n\t\treturn emulate_db(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint dr = ctxt->modrm_reg;\n\n\tif ((dr == 6 || dr == 7) && (new_val & 0xffffffff00000000ULL))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_dr_read(ctxt);\n}\n\nstatic int check_svme(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 efer;\n\n\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\tif (!(efer & EFER_SVME))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_svme_pa(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 rax = ctxt->regs[VCPU_REGS_RAX];\n\n\t/* Valid physical address? */\n\tif (rax & 0xffff000000000000ULL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_svme(ctxt);\n}\n\nstatic int check_rdtsc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\n\tif (cr4 & X86_CR4_TSD && ctxt->ops->cpl(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\tu64 rcx = ctxt->regs[VCPU_REGS_RCX];\n\n\tif ((!(cr4 & X86_CR4_PCE) && ctxt->ops->cpl(ctxt)) ||\n\t    (rcx > 3))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_perm_in(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = min(ctxt->dst.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->src.val, ctxt->dst.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int check_perm_out(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->src.bytes = min(ctxt->src.bytes, 4u);\n\tif (!emulator_io_permited(ctxt, ctxt->dst.val, ctxt->src.bytes))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n\n#define D(_y) { .flags = (_y) }\n#define DI(_y, _i) { .flags = (_y), .intercept = x86_intercept_##_i }\n#define DIP(_y, _i, _p) { .flags = (_y), .intercept = x86_intercept_##_i, \\\n\t\t      .check_perm = (_p) }\n#define N    D(0)\n#define EXT(_f, _e) { .flags = ((_f) | RMExt), .u.group = (_e) }\n#define G(_f, _g) { .flags = ((_f) | Group), .u.group = (_g) }\n#define GD(_f, _g) { .flags = ((_f) | GroupDual), .u.gdual = (_g) }\n#define I(_f, _e) { .flags = (_f), .u.execute = (_e) }\n#define II(_f, _e, _i) \\\n\t{ .flags = (_f), .u.execute = (_e), .intercept = x86_intercept_##_i }\n#define IIP(_f, _e, _i, _p) \\\n\t{ .flags = (_f), .u.execute = (_e), .intercept = x86_intercept_##_i, \\\n\t  .check_perm = (_p) }\n#define GP(_f, _g) { .flags = ((_f) | Prefix), .u.gprefix = (_g) }\n\n#define D2bv(_f)      D((_f) | ByteOp), D(_f)\n#define D2bvIP(_f, _i, _p) DIP((_f) | ByteOp, _i, _p), DIP(_f, _i, _p)\n#define I2bv(_f, _e)  I((_f) | ByteOp, _e), I(_f, _e)\n#define I2bvIP(_f, _e, _i, _p) \\\n\tIIP((_f) | ByteOp, _e, _i, _p), IIP(_f, _e, _i, _p)\n\n#define I6ALU(_f, _e) I2bv((_f) | DstMem | SrcReg | ModRM, _e),\t\t\\\n\t\tI2bv(((_f) | DstReg | SrcMem | ModRM) & ~Lock, _e),\t\\\n\t\tI2bv(((_f) & ~Lock) | DstAcc | SrcImm, _e)\n\nstatic struct opcode group7_rm1[] = {\n\tDI(SrcNone | ModRM | Priv, monitor),\n\tDI(SrcNone | ModRM | Priv, mwait),\n\tN, N, N, N, N, N,\n};\n\nstatic struct opcode group7_rm3[] = {\n\tDIP(SrcNone | ModRM | Prot | Priv, vmrun,   check_svme_pa),\n\tII(SrcNone | ModRM | Prot | VendorSpecific, em_vmmcall, vmmcall),\n\tDIP(SrcNone | ModRM | Prot | Priv, vmload,  check_svme_pa),\n\tDIP(SrcNone | ModRM | Prot | Priv, vmsave,  check_svme_pa),\n\tDIP(SrcNone | ModRM | Prot | Priv, stgi,    check_svme),\n\tDIP(SrcNone | ModRM | Prot | Priv, clgi,    check_svme),\n\tDIP(SrcNone | ModRM | Prot | Priv, skinit,  check_svme),\n\tDIP(SrcNone | ModRM | Prot | Priv, invlpga, check_svme),\n};\n\nstatic struct opcode group7_rm7[] = {\n\tN,\n\tDIP(SrcNone | ModRM, rdtscp, check_rdtsc),\n\tN, N, N, N, N, N,\n};\n\nstatic struct opcode group1[] = {\n\tI(Lock, em_add),\n\tI(Lock | PageTable, em_or),\n\tI(Lock, em_adc),\n\tI(Lock, em_sbb),\n\tI(Lock | PageTable, em_and),\n\tI(Lock, em_sub),\n\tI(Lock, em_xor),\n\tI(0, em_cmp),\n};\n\nstatic struct opcode group1A[] = {\n\tI(DstMem | SrcNone | ModRM | Mov | Stack, em_pop), N, N, N, N, N, N, N,\n};\n\nstatic struct opcode group3[] = {\n\tI(DstMem | SrcImm | ModRM, em_test),\n\tI(DstMem | SrcImm | ModRM, em_test),\n\tI(DstMem | SrcNone | ModRM | Lock, em_not),\n\tI(DstMem | SrcNone | ModRM | Lock, em_neg),\n\tI(SrcMem | ModRM, em_mul_ex),\n\tI(SrcMem | ModRM, em_imul_ex),\n\tI(SrcMem | ModRM, em_div_ex),\n\tI(SrcMem | ModRM, em_idiv_ex),\n};\n\nstatic struct opcode group4[] = {\n\tI(ByteOp | DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tI(ByteOp | DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tN, N, N, N, N, N,\n};\n\nstatic struct opcode group5[] = {\n\tI(DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tI(DstMem | SrcNone | ModRM | Lock, em_grp45),\n\tI(SrcMem | ModRM | Stack, em_grp45),\n\tI(SrcMemFAddr | ModRM | ImplicitOps | Stack, em_call_far),\n\tI(SrcMem | ModRM | Stack, em_grp45),\n\tI(SrcMemFAddr | ModRM | ImplicitOps, em_grp45),\n\tI(SrcMem | ModRM | Stack, em_grp45), N,\n};\n\nstatic struct opcode group6[] = {\n\tDI(ModRM | Prot,        sldt),\n\tDI(ModRM | Prot,        str),\n\tDI(ModRM | Prot | Priv, lldt),\n\tDI(ModRM | Prot | Priv, ltr),\n\tN, N, N, N,\n};\n\nstatic struct group_dual group7 = { {\n\tDI(ModRM | Mov | DstMem | Priv, sgdt),\n\tDI(ModRM | Mov | DstMem | Priv, sidt),\n\tII(ModRM | SrcMem | Priv, em_lgdt, lgdt),\n\tII(ModRM | SrcMem | Priv, em_lidt, lidt),\n\tII(SrcNone | ModRM | DstMem | Mov, em_smsw, smsw), N,\n\tII(SrcMem16 | ModRM | Mov | Priv, em_lmsw, lmsw),\n\tII(SrcMem | ModRM | ByteOp | Priv | NoAccess, em_invlpg, invlpg),\n}, {\n\tI(SrcNone | ModRM | Priv | VendorSpecific, em_vmcall),\n\tEXT(0, group7_rm1),\n\tN, EXT(0, group7_rm3),\n\tII(SrcNone | ModRM | DstMem | Mov, em_smsw, smsw), N,\n\tII(SrcMem16 | ModRM | Mov | Priv, em_lmsw, lmsw), EXT(0, group7_rm7),\n} };\n\nstatic struct opcode group8[] = {\n\tN, N, N, N,\n\tI(DstMem | SrcImmByte | ModRM, em_bt),\n\tI(DstMem | SrcImmByte | ModRM | Lock | PageTable, em_bts),\n\tI(DstMem | SrcImmByte | ModRM | Lock, em_btr),\n\tI(DstMem | SrcImmByte | ModRM | Lock | PageTable, em_btc),\n};\n\nstatic struct group_dual group9 = { {\n\tN, I(DstMem64 | ModRM | Lock | PageTable, em_cmpxchg8b), N, N, N, N, N, N,\n}, {\n\tN, N, N, N, N, N, N, N,\n} };\n\nstatic struct opcode group11[] = {\n\tI(DstMem | SrcImm | ModRM | Mov | PageTable, em_mov),\n\tX7(D(Undefined)),\n};\n\nstatic struct gprefix pfx_0f_6f_0f_7f = {\n\tN, N, N, I(Sse, em_movdqu),\n};\n\nstatic struct opcode opcode_table[256] = {\n\t/* 0x00 - 0x07 */\n\tI6ALU(Lock, em_add),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2ES, em_pop_sreg),\n\t/* 0x08 - 0x0F */\n\tI6ALU(Lock | PageTable, em_or),\n\tI(ImplicitOps | Stack | No64 | Src2CS, em_push_sreg),\n\tN,\n\t/* 0x10 - 0x17 */\n\tI6ALU(Lock, em_adc),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2SS, em_pop_sreg),\n\t/* 0x18 - 0x1F */\n\tI6ALU(Lock, em_sbb),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_push_sreg),\n\tI(ImplicitOps | Stack | No64 | Src2DS, em_pop_sreg),\n\t/* 0x20 - 0x27 */\n\tI6ALU(Lock | PageTable, em_and), N, N,\n\t/* 0x28 - 0x2F */\n\tI6ALU(Lock, em_sub), N, I(ByteOp | DstAcc | No64, em_das),\n\t/* 0x30 - 0x37 */\n\tI6ALU(Lock, em_xor), N, N,\n\t/* 0x38 - 0x3F */\n\tI6ALU(0, em_cmp), N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg)),\n\t/* 0x50 - 0x57 */\n\tX8(I(SrcReg | Stack, em_push)),\n\t/* 0x58 - 0x5F */\n\tX8(I(DstReg | Stack, em_pop)),\n\t/* 0x60 - 0x67 */\n\tI(ImplicitOps | Stack | No64, em_pusha),\n\tI(ImplicitOps | Stack | No64, em_popa),\n\tN, D(DstReg | SrcMem32 | ModRM | Mov) /* movsxd (x86/64) */ ,\n\tN, N, N, N,\n\t/* 0x68 - 0x6F */\n\tI(SrcImm | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2Imm, em_imul_3op),\n\tI(SrcImmByte | Mov | Stack, em_push),\n\tI(DstReg | SrcMem | ModRM | Src2ImmByte, em_imul_3op),\n\tI2bvIP(DstDI | SrcDX | Mov | String, em_in, ins, check_perm_in), /* insb, insw/insd */\n\tI2bvIP(SrcSI | DstDX | String, em_out, outs, check_perm_out), /* outsb, outsw/outsd */\n\t/* 0x70 - 0x7F */\n\tX16(D(SrcImmByte)),\n\t/* 0x80 - 0x87 */\n\tG(ByteOp | DstMem | SrcImm | ModRM | Group, group1),\n\tG(DstMem | SrcImm | ModRM | Group, group1),\n\tG(ByteOp | DstMem | SrcImm | ModRM | No64 | Group, group1),\n\tG(DstMem | SrcImmByte | ModRM | Group, group1),\n\tI2bv(DstMem | SrcReg | ModRM, em_test),\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_xchg),\n\t/* 0x88 - 0x8F */\n\tI2bv(DstMem | SrcReg | ModRM | Mov | PageTable, em_mov),\n\tI2bv(DstReg | SrcMem | ModRM | Mov, em_mov),\n\tI(DstMem | SrcNone | ModRM | Mov | PageTable, em_mov_rm_sreg),\n\tD(ModRM | SrcMem | NoAccess | DstReg),\n\tI(ImplicitOps | SrcMem16 | ModRM, em_mov_sreg_rm),\n\tG(0, group1A),\n\t/* 0x90 - 0x97 */\n\tDI(SrcAcc | DstReg, pause), X7(D(SrcAcc | DstReg)),\n\t/* 0x98 - 0x9F */\n\tD(DstAcc | SrcNone), I(ImplicitOps | SrcAcc, em_cwd),\n\tI(SrcImmFAddr | No64, em_call_far), N,\n\tII(ImplicitOps | Stack, em_pushf, pushf),\n\tII(ImplicitOps | Stack, em_popf, popf), N, N,\n\t/* 0xA0 - 0xA7 */\n\tI2bv(DstAcc | SrcMem | Mov | MemAbs, em_mov),\n\tI2bv(DstMem | SrcAcc | Mov | MemAbs | PageTable, em_mov),\n\tI2bv(SrcSI | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstDI | String, em_cmp),\n\t/* 0xA8 - 0xAF */\n\tI2bv(DstAcc | SrcImm, em_test),\n\tI2bv(SrcAcc | DstDI | Mov | String, em_mov),\n\tI2bv(SrcSI | DstAcc | Mov | String, em_mov),\n\tI2bv(SrcAcc | DstDI | String, em_cmp),\n\t/* 0xB0 - 0xB7 */\n\tX8(I(ByteOp | DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xB8 - 0xBF */\n\tX8(I(DstReg | SrcImm | Mov, em_mov)),\n\t/* 0xC0 - 0xC7 */\n\tD2bv(DstMem | SrcImmByte | ModRM),\n\tI(ImplicitOps | Stack | SrcImmU16, em_ret_near_imm),\n\tI(ImplicitOps | Stack, em_ret),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2ES, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | No64 | Src2DS, em_lseg),\n\tG(ByteOp, group11), G(0, group11),\n\t/* 0xC8 - 0xCF */\n\tN, N, N, I(ImplicitOps | Stack, em_ret_far),\n\tD(ImplicitOps), DI(SrcImmByte, intn),\n\tD(ImplicitOps | No64), II(ImplicitOps, em_iret, iret),\n\t/* 0xD0 - 0xD7 */\n\tD2bv(DstMem | SrcOne | ModRM), D2bv(DstMem | ModRM),\n\tN, N, N, N,\n\t/* 0xD8 - 0xDF */\n\tN, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xE7 */\n\tX3(I(SrcImmByte, em_loop)),\n\tI(SrcImmByte, em_jcxz),\n\tI2bvIP(SrcImmUByte | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstImmUByte, em_out, out, check_perm_out),\n\t/* 0xE8 - 0xEF */\n\tI(SrcImm | Stack, em_call), D(SrcImm | ImplicitOps),\n\tI(SrcImmFAddr | No64, em_jmp_far), D(SrcImmByte | ImplicitOps),\n\tI2bvIP(SrcDX | DstAcc, em_in,  in,  check_perm_in),\n\tI2bvIP(SrcAcc | DstDX, em_out, out, check_perm_out),\n\t/* 0xF0 - 0xF7 */\n\tN, DI(ImplicitOps, icebp), N, N,\n\tDI(ImplicitOps | Priv, hlt), D(ImplicitOps),\n\tG(ByteOp, group3), G(0, group3),\n\t/* 0xF8 - 0xFF */\n\tD(ImplicitOps), D(ImplicitOps),\n\tI(ImplicitOps, em_cli), I(ImplicitOps, em_sti),\n\tD(ImplicitOps), D(ImplicitOps), G(0, group4), G(0, group5),\n};\n\nstatic struct opcode twobyte_table[256] = {\n\t/* 0x00 - 0x0F */\n\tG(0, group6), GD(0, &group7), N, N,\n\tN, I(ImplicitOps | VendorSpecific, em_syscall),\n\tII(ImplicitOps | Priv, em_clts, clts), N,\n\tDI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,\n\tN, D(ImplicitOps | ModRM), N, N,\n\t/* 0x10 - 0x1F */\n\tN, N, N, N, N, N, N, N, D(ImplicitOps | ModRM), N, N, N, N, N, N, N,\n\t/* 0x20 - 0x2F */\n\tDIP(ModRM | DstMem | Priv | Op3264, cr_read, check_cr_read),\n\tDIP(ModRM | DstMem | Priv | Op3264, dr_read, check_dr_read),\n\tIIP(ModRM | SrcMem | Priv | Op3264, em_cr_write, cr_write, check_cr_write),\n\tIIP(ModRM | SrcMem | Priv | Op3264, em_dr_write, dr_write, check_dr_write),\n\tN, N, N, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x30 - 0x3F */\n\tII(ImplicitOps | Priv, em_wrmsr, wrmsr),\n\tIIP(ImplicitOps, em_rdtsc, rdtsc, check_rdtsc),\n\tII(ImplicitOps | Priv, em_rdmsr, rdmsr),\n\tIIP(ImplicitOps, em_rdpmc, rdpmc, check_rdpmc),\n\tI(ImplicitOps | VendorSpecific, em_sysenter),\n\tI(ImplicitOps | Priv | VendorSpecific, em_sysexit),\n\tN, N,\n\tN, N, N, N, N, N, N, N,\n\t/* 0x40 - 0x4F */\n\tX16(D(DstReg | SrcMem | ModRM | Mov)),\n\t/* 0x50 - 0x5F */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0x60 - 0x6F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcMem | DstReg | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x70 - 0x7F */\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, N,\n\tN, N, N, GP(SrcReg | DstMem | ModRM | Mov, &pfx_0f_6f_0f_7f),\n\t/* 0x80 - 0x8F */\n\tX16(D(SrcImm)),\n\t/* 0x90 - 0x9F */\n\tX16(D(ByteOp | DstMem | SrcNone | ModRM| Mov)),\n\t/* 0xA0 - 0xA7 */\n\tI(Stack | Src2FS, em_push_sreg), I(Stack | Src2FS, em_pop_sreg),\n\tDI(ImplicitOps, cpuid), I(DstMem | SrcReg | ModRM | BitOp, em_bt),\n\tD(DstMem | SrcReg | Src2ImmByte | ModRM),\n\tD(DstMem | SrcReg | Src2CL | ModRM), N, N,\n\t/* 0xA8 - 0xAF */\n\tI(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),\n\tDI(ImplicitOps, rsm),\n\tI(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),\n\tD(DstMem | SrcReg | Src2ImmByte | ModRM),\n\tD(DstMem | SrcReg | Src2CL | ModRM),\n\tD(ModRM), I(DstReg | SrcMem | ModRM, em_imul),\n\t/* 0xB0 - 0xB7 */\n\tI2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_cmpxchg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2SS, em_lseg),\n\tI(DstMem | SrcReg | ModRM | BitOp | Lock, em_btr),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2FS, em_lseg),\n\tI(DstReg | SrcMemFAddr | ModRM | Src2GS, em_lseg),\n\tD(ByteOp | DstReg | SrcMem | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xB8 - 0xBF */\n\tN, N,\n\tG(BitOp, group8),\n\tI(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_btc),\n\tI(DstReg | SrcMem | ModRM, em_bsf), I(DstReg | SrcMem | ModRM, em_bsr),\n\tD(ByteOp | DstReg | SrcMem | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),\n\t/* 0xC0 - 0xCF */\n\tD2bv(DstMem | SrcReg | ModRM | Lock),\n\tN, D(DstMem | SrcReg | ModRM | Mov),\n\tN, N, N, GD(0, &group9),\n\tN, N, N, N, N, N, N, N,\n\t/* 0xD0 - 0xDF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xE0 - 0xEF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n\t/* 0xF0 - 0xFF */\n\tN, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N\n};\n\n#undef D\n#undef N\n#undef G\n#undef GD\n#undef I\n#undef GP\n#undef EXT\n\n#undef D2bv\n#undef D2bvIP\n#undef I2bv\n#undef I2bvIP\n#undef I6ALU\n\nstatic unsigned imm_size(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned size;\n\n\tsize = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tif (size == 8)\n\t\tsize = 4;\n\treturn size;\n}\n\nstatic int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\t/* NB. Immediates are sign-extended as necessary. */\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}\n\nstatic int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op,\n\t\t\t op == &ctxt->dst &&\n\t\t\t ctxt->twobyte && (ctxt->b == 0xb6 || ctxt->b == 0xb7));\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif ((ctxt->d & BitOp) && op == &ctxt->dst)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = &ctxt->regs[VCPU_REGS_RAX];\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, ctxt->regs[VCPU_REGS_RDI]);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = &ctxt->regs[VCPU_REGS_RDX];\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->bytes = 1;\n\t\top->val = ctxt->regs[VCPU_REGS_RCX] & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, ctxt->regs[VCPU_REGS_RSI]);\n\t\top->addr.mem.seg = seg_override(ctxt);\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}\n\nint x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.start = ctxt->_eip;\n\tctxt->fetch.end = ctxt->fetch.start + insn_len;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\tset_seg_override(ctxt, (ctxt->b >> 3) & 3);\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\tset_seg_override(ctxt, ctxt->b & 7);\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->twobyte = 1;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\t}\n\tctxt->d = opcode.flags;\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\t\t\t--ctxt->_eip;\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\t\t\t--ctxt->_eip;\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\tctxt->execute = opcode.u.execute;\n\tctxt->check_perm = opcode.check_perm;\n\tctxt->intercept = opcode.intercept;\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0 || (ctxt->d & Undefined))\n\t\treturn EMULATION_FAILED;\n\n\tif (!(ctxt->d & VendorSpecific) && ctxt->only_vendor_specific_insn)\n\t\treturn EMULATION_FAILED;\n\n\tif (mode == X86EMUL_MODE_PROT64 && (ctxt->d & Stack))\n\t\tctxt->op_bytes = 8;\n\n\tif (ctxt->d & Op3264) {\n\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\tctxt->op_bytes = 8;\n\t\telse\n\t\t\tctxt->op_bytes = 4;\n\t}\n\n\tif (ctxt->d & Sse)\n\t\tctxt->op_bytes = 16;\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!ctxt->has_seg_override)\n\t\t\tset_seg_override(ctxt, ctxt->modrm_seg);\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!ctxt->has_seg_override)\n\t\tset_seg_override(ctxt, VCPU_SREG_DS);\n\n\tctxt->memop.addr.mem.seg = seg_override(ctxt);\n\n\tif (ctxt->memop.type == OP_MEM && ctxt->ad_bytes != 8)\n\t\tctxt->memop.addr.mem.ea = (u32)ctxt->memop.addr.mem.ea;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\ndone:\n\tif (ctxt->memopp && ctxt->memopp->type == OP_MEM && ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea += ctxt->_eip;\n\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}\n\nbool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt)\n{\n\treturn ctxt->d & PageTable;\n}\n\nstatic bool string_insn_completed(struct x86_emulate_ctxt *ctxt)\n{\n\t/* The second termination condition only applies for REPE\n\t * and REPNE. Test if the repeat string operation prefix is\n\t * REPE/REPZ or REPNE/REPNZ and if it's the case it tests the\n\t * corresponding termination condition according to:\n\t * \t- if REPE/REPZ and ZF = 0 then done\n\t * \t- if REPNE/REPNZ and ZF = 1 then done\n\t */\n\tif (((ctxt->b == 0xa6) || (ctxt->b == 0xa7) ||\n\t     (ctxt->b == 0xae) || (ctxt->b == 0xaf))\n\t    && (((ctxt->rep_prefix == REPE_PREFIX) &&\n\t\t ((ctxt->eflags & EFLG_ZF) == 0))\n\t\t|| ((ctxt->rep_prefix == REPNE_PREFIX) &&\n\t\t    ((ctxt->eflags & EFLG_ZF) == EFLG_ZF))))\n\t\treturn true;\n\n\treturn false;\n}\n\nint x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc = X86EMUL_CONTINUE;\n\tint saved_dst_type = ctxt->dst.type;\n\n\tctxt->mem_read.pos = 0;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\t/* LOCK prefix is allowed only with some instructions */\n\tif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & Sse)\n\t    && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)\n\t\t|| !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & Sse) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\n\t\trc = emulate_nm(ctxt);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->guest_mode) && ctxt->intercept) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_PRE_EXCEPT);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\t/* Privileged instruction can be executed only in CPL=0 */\n\tif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\n\t\trc = emulate_gp(ctxt, 0);\n\t\tgoto done;\n\t}\n\n\t/* Instruction can only be executed in protected mode */\n\tif ((ctxt->d & Prot) && !(ctxt->mode & X86EMUL_MODE_PROT)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\t/* Do instruction specific permission checks */\n\tif (ctxt->check_perm) {\n\t\trc = ctxt->check_perm(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->guest_mode) && ctxt->intercept) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_EXCEPT);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\t/* All REP prefixes have the same first termination condition */\n\t\tif (address_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) == 0) {\n\t\t\tctxt->eip = ctxt->_eip;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\n\t\trc = segmented_read(ctxt, ctxt->src.addr.mem,\n\t\t\t\t    ctxt->src.valptr, ctxt->src.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tctxt->src.orig_val64 = ctxt->src.val64;\n\t}\n\n\tif (ctxt->src2.type == OP_MEM) {\n\t\trc = segmented_read(ctxt, ctxt->src2.addr.mem,\n\t\t\t\t    &ctxt->src2.val, ctxt->src2.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & DstMask) == ImplicitOps)\n\t\tgoto special_insn;\n\n\n\tif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\n\t\t/* optimisation - avoid slow emulated read if Mov */\n\t\trc = segmented_read(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &ctxt->dst.val, ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tctxt->dst.orig_val = ctxt->dst.val;\n\nspecial_insn:\n\n\tif (unlikely(ctxt->guest_mode) && ctxt->intercept) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_MEMACCESS);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->execute) {\n\t\trc = ctxt->execute(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tgoto writeback;\n\t}\n\n\tif (ctxt->twobyte)\n\t\tgoto twobyte_insn;\n\n\tswitch (ctxt->b) {\n\tcase 0x40 ... 0x47: /* inc r16/r32 */\n\t\temulate_1op(ctxt, \"inc\");\n\t\tbreak;\n\tcase 0x48 ... 0x4f: /* dec r16/r32 */\n\t\temulate_1op(ctxt, \"dec\");\n\t\tbreak;\n\tcase 0x63:\t\t/* movsxd */\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\tgoto cannot_emulate;\n\t\tctxt->dst.val = (s32) ctxt->src.val;\n\t\tbreak;\n\tcase 0x70 ... 0x7f: /* jcc (short) */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tjmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x8d: /* lea r16/r32, m */\n\t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n\t\tbreak;\n\tcase 0x90 ... 0x97: /* nop / xchg reg, rax */\n\t\tif (ctxt->dst.addr.reg == &ctxt->regs[VCPU_REGS_RAX])\n\t\t\tbreak;\n\t\trc = em_xchg(ctxt);\n\t\tbreak;\n\tcase 0x98: /* cbw/cwde/cdqe */\n\t\tswitch (ctxt->op_bytes) {\n\t\tcase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\n\t\tcase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\n\t\tcase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n\t\t}\n\t\tbreak;\n\tcase 0xc0 ... 0xc1:\n\t\trc = em_grp2(ctxt);\n\t\tbreak;\n\tcase 0xcc:\t\t/* int3 */\n\t\trc = emulate_int(ctxt, 3);\n\t\tbreak;\n\tcase 0xcd:\t\t/* int n */\n\t\trc = emulate_int(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0xce:\t\t/* into */\n\t\tif (ctxt->eflags & EFLG_OF)\n\t\t\trc = emulate_int(ctxt, 4);\n\t\tbreak;\n\tcase 0xd0 ... 0xd1:\t/* Grp2 */\n\t\trc = em_grp2(ctxt);\n\t\tbreak;\n\tcase 0xd2 ... 0xd3:\t/* Grp2 */\n\t\tctxt->src.val = ctxt->regs[VCPU_REGS_RCX];\n\t\trc = em_grp2(ctxt);\n\t\tbreak;\n\tcase 0xe9: /* jmp rel */\n\tcase 0xeb: /* jmp rel short */\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\t\tctxt->dst.type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\tcase 0xf4:              /* hlt */\n\t\tctxt->ops->halt(ctxt);\n\t\tbreak;\n\tcase 0xf5:\t/* cmc */\n\t\t/* complement carry flag from eflags reg */\n\t\tctxt->eflags ^= EFLG_CF;\n\t\tbreak;\n\tcase 0xf8: /* clc */\n\t\tctxt->eflags &= ~EFLG_CF;\n\t\tbreak;\n\tcase 0xf9: /* stc */\n\t\tctxt->eflags |= EFLG_CF;\n\t\tbreak;\n\tcase 0xfc: /* cld */\n\t\tctxt->eflags &= ~EFLG_DF;\n\t\tbreak;\n\tcase 0xfd: /* std */\n\t\tctxt->eflags |= EFLG_DF;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\nwriteback:\n\trc = writeback(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * restore dst type in case the decoding will be reused\n\t * (happens for string instruction )\n\t */\n\tctxt->dst.type = saved_dst_type;\n\n\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\tstring_addr_inc(ctxt, seg_override(ctxt),\n\t\t\t\tVCPU_REGS_RSI, &ctxt->src);\n\n\tif ((ctxt->d & DstMask) == DstDI)\n\t\tstring_addr_inc(ctxt, VCPU_SREG_ES, VCPU_REGS_RDI,\n\t\t\t\t&ctxt->dst);\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\tstruct read_cache *r = &ctxt->io_read;\n\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RCX], -1);\n\n\t\tif (!string_insn_completed(ctxt)) {\n\t\t\t/*\n\t\t\t * Re-enter guest when pio read ahead buffer is empty\n\t\t\t * or, if it is not used, after each 1024 iteration.\n\t\t\t */\n\t\t\tif ((r->end != 0 || ctxt->regs[VCPU_REGS_RCX] & 0x3ff) &&\n\t\t\t    (r->end == 0 || r->end != r->pos)) {\n\t\t\t\t/*\n\t\t\t\t * Reset read cache. Usually happens before\n\t\t\t\t * decode, but since instruction is restarted\n\t\t\t\t * we have to do it here.\n\t\t\t\t */\n\t\t\t\tctxt->mem_read.end = 0;\n\t\t\t\treturn EMULATION_RESTART;\n\t\t\t}\n\t\t\tgoto done; /* skip rip writeback */\n\t\t}\n\t}\n\n\tctxt->eip = ctxt->_eip;\n\ndone:\n\tif (rc == X86EMUL_PROPAGATE_FAULT)\n\t\tctxt->have_exception = true;\n\tif (rc == X86EMUL_INTERCEPTED)\n\t\treturn EMULATION_INTERCEPTED;\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n\ntwobyte_insn:\n\tswitch (ctxt->b) {\n\tcase 0x09:\t\t/* wbinvd */\n\t\t(ctxt->ops->wbinvd)(ctxt);\n\t\tbreak;\n\tcase 0x08:\t\t/* invd */\n\tcase 0x0d:\t\t/* GrpP (prefetch) */\n\tcase 0x18:\t\t/* Grp16 (prefetch/nop) */\n\t\tbreak;\n\tcase 0x20: /* mov cr, reg */\n\t\tctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\n\t\tbreak;\n\tcase 0x21: /* mov from dr to reg */\n\t\tops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t/* cmov */\n\t\tctxt->dst.val = ctxt->dst.orig_val = ctxt->src.val;\n\t\tif (!test_cc(ctxt->b, ctxt->eflags))\n\t\t\tctxt->dst.type = OP_NONE; /* no writeback */\n\t\tbreak;\n\tcase 0x80 ... 0x8f: /* jnz rel, etc*/\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tjmp_rel(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0x90 ... 0x9f:     /* setcc r/m8 */\n\t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n\t\tbreak;\n\tcase 0xa4: /* shld imm8, r, r/m */\n\tcase 0xa5: /* shld cl, r, r/m */\n\t\temulate_2op_cl(ctxt, \"shld\");\n\t\tbreak;\n\tcase 0xac: /* shrd imm8, r, r/m */\n\tcase 0xad: /* shrd cl, r, r/m */\n\t\temulate_2op_cl(ctxt, \"shrd\");\n\t\tbreak;\n\tcase 0xae:              /* clflush */\n\t\tbreak;\n\tcase 0xb6 ... 0xb7:\t/* movzx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->d & ByteOp) ? (u8) ctxt->src.val\n\t\t\t\t\t\t       : (u16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xbe ... 0xbf:\t/* movsx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->d & ByteOp) ? (s8) ctxt->src.val :\n\t\t\t\t\t\t\t(s16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xc0 ... 0xc1:\t/* xadd */\n\t\temulate_2op_SrcV(ctxt, \"add\");\n\t\t/* Write back the register source. */\n\t\tctxt->src.val = ctxt->dst.orig_val;\n\t\twrite_register_operand(&ctxt->src);\n\t\tbreak;\n\tcase 0xc3:\t\t/* movnti */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->op_bytes == 4) ? (u32) ctxt->src.val :\n\t\t\t\t\t\t\t(u64) ctxt->src.val;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tgoto writeback;\n\ncannot_emulate:\n\treturn EMULATION_FAILED;\n}\n"], "filenames": ["arch/x86/include/asm/kvm_emulate.h", "arch/x86/kvm/emulate.c"], "buggy_code_start_loc": [302, 1893], "buggy_code_end_loc": [302, 1908], "fixing_code_start_loc": [303, 1894], "fixing_code_end_loc": [316, 1960], "type": "NVD-CWE-Other", "message": "The em_syscall function in arch/x86/kvm/emulate.c in the KVM implementation in the Linux kernel before 3.2.14 does not properly handle the 0f05 (aka syscall) opcode, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application, as demonstrated by an NASM file.", "other": {"cve": {"id": "CVE-2012-0045", "sourceIdentifier": "secalert@redhat.com", "published": "2012-07-03T16:40:31.397", "lastModified": "2023-02-13T03:24:14.087", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The em_syscall function in arch/x86/kvm/emulate.c in the KVM implementation in the Linux kernel before 3.2.14 does not properly handle the 0f05 (aka syscall) opcode, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application, as demonstrated by an NASM file."}, {"lang": "es", "value": "La funci\u00f3n em_syscall en arch/x86/kvm/emulate.c en la implementaci\u00f3n KVM en el kernel de linux anterior a v.3.2.14 no maneja correctamente el opcode 0f05, permitiendo a los clientes usuarios del sistema operativo  causar una denegaci\u00f3n de servicio a trav\u00e9s de una aplicaci\u00f3n hecha a mano, como lo demuestra un archivo NASM."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.13", "matchCriteriaId": "A906F26A-27B8-4526-9530-B25A6770CFE0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=c2226fc9e87ba3da060e47333657cd6616652b84", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-05/msg00013.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.2.14", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/01/12/2", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=773370", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84"}}