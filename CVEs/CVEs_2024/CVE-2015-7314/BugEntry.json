{"buggy_code": ["# ~*~ encoding: utf-8 ~*~\nrequire 'cgi'\nrequire 'sinatra'\nrequire 'gollum-lib'\nrequire 'mustache/sinatra'\nrequire 'useragent'\nrequire 'stringex'\n\nrequire 'gollum'\nrequire 'gollum/views/layout'\nrequire 'gollum/views/editable'\nrequire 'gollum/views/has_page'\n\nrequire File.expand_path '../helpers', __FILE__\n\n#required to upload bigger binary files\nGollum::set_git_timeout(120)\nGollum::set_git_max_filesize(190 * 10**6)\n\n# Fix to_url\nclass String\n  alias :upstream_to_url :to_url\n\n  if defined?(Gollum::GIT_ADAPTER) && Gollum::GIT_ADAPTER != 'grit'\n    def to_ascii\n      self # Do not transliterate utf-8 url's unless using Grit\n    end\n  end\n\n  # _Header => header which causes errors\n  def to_url\n    return nil if self.nil?\n    upstream_to_url :exclude => ['_Header', '_Footer', '_Sidebar'], :force_downcase => false\n  end\nend\n\n# Run the frontend, based on Sinatra\n#\n# There are a number of wiki options that can be set for the frontend\n#\n# Example\n# require 'gollum/app'\n# Precious::App.set(:wiki_options, {\n#     :universal_toc => false,\n# }\n#\n# See the wiki.rb file for more details on wiki options\nmodule Precious\n  class App < Sinatra::Base\n    register Mustache::Sinatra\n    include Precious::Helpers\n    \n    dir     = File.dirname(File.expand_path(__FILE__))\n\n    # Detect unsupported browsers.\n    Browser = Struct.new(:browser, :version)\n\n    @@min_ua = [\n        Browser.new('Internet Explorer', '10.0'),\n        Browser.new('Chrome', '7.0'),\n        Browser.new('Firefox', '4.0'),\n    ]\n\n    def supported_useragent?(user_agent)\n      ua = UserAgent.parse(user_agent)\n      @@min_ua.detect { |min| ua >= min }\n    end\n\n    # We want to serve public assets for now\n    set :public_folder, \"#{dir}/public/gollum\"\n    set :static, true\n    set :default_markup, :markdown\n\n    set :mustache, {\n        # Tell mustache where the Views constant lives\n        :namespace => Precious,\n\n        # Mustache templates live here\n        :templates => \"#{dir}/templates\",\n\n        # Tell mustache where the views are\n        :views     => \"#{dir}/views\"\n    }\n\n    # Sinatra error handling\n    configure :development, :staging do\n      enable :show_exceptions, :dump_errors\n      disable :raise_errors, :clean_trace\n    end\n\n    configure :test do\n      enable :logging, :raise_errors, :dump_errors\n    end\n\n    before do\n      settings.wiki_options[:allow_editing] = settings.wiki_options.fetch(:allow_editing, true)\n      @allow_editing = settings.wiki_options[:allow_editing]\n      forbid unless @allow_editing || request.request_method == \"GET\"\n      Precious::App.set(:mustache, {:templates => settings.wiki_options[:template_dir]}) if settings.wiki_options[:template_dir]\n      @base_url = url('/', false).chomp('/')\n      @page_dir = settings.wiki_options[:page_file_dir].to_s\n      # above will detect base_path when it's used with map in a config.ru\n      settings.wiki_options.merge!({ :base_path => @base_url })\n      @css = settings.wiki_options[:css]\n      @js  = settings.wiki_options[:js]\n      @mathjax_config = settings.wiki_options[:mathjax_config]\n    end\n\n    get '/' do\n      redirect clean_url(::File.join(@base_url, @page_dir, wiki_new.index_page))\n    end\n\n    # path is set to name if path is nil.\n    #   if path is 'a/b' and a and b are dirs, then\n    #   path must have a trailing slash 'a/b/' or\n    #   extract_path will trim path to 'a'\n    # name, path, version\n    def wiki_page(name, path = nil, version = nil, exact = true)\n      wiki = wiki_new\n      path = name if path.nil?\n      name = extract_name(name) || wiki.index_page\n      path = extract_path(path)\n      path = '/' if exact && path.nil?\n\n      OpenStruct.new(:wiki => wiki, :page => wiki.paged(name, path, exact, version),\n                     :name => name, :path => path)\n    end\n\n    def wiki_new\n      Gollum::Wiki.new(settings.gollum_path, settings.wiki_options)\n    end\n\n    get '/data/*' do\n      if page = wiki_page(params[:splat].first).page\n        page.raw_data\n      end\n    end\n\n    get '/edit/*' do\n      forbid unless @allow_editing\n      wikip = wiki_page(params[:splat].first)\n      @name = wikip.name\n      @path = wikip.path\n      @upload_dest   = find_upload_dest(@path)\n\n      wiki = wikip.wiki\n      @allow_uploads = wiki.allow_uploads\n      if page = wikip.page\n        if wiki.live_preview && page.format.to_s.include?('markdown') && supported_useragent?(request.user_agent)\n          live_preview_url = '/livepreview/?page=' + encodeURIComponent(@name)\n          if @path\n            live_preview_url << '&path=' + encodeURIComponent(@path)\n          end\n          redirect to(live_preview_url)\n        else\n          @page         = page\n          @page.version = wiki.repo.log(wiki.ref, @page.path).first\n          @content      = page.text_data\n          mustache :edit\n        end\n      else\n        redirect to(\"/create/#{encodeURIComponent(@name)}\")\n      end\n    end\n\n    post '/uploadFile' do\n      wiki = wiki_new\n\n      unless wiki.allow_uploads\n        @message = \"File uploads are disabled\"\n        mustache :error\n        return\n      end\n\n      if params[:file]\n        fullname = params[:file][:filename]\n        tempfile = params[:file][:tempfile]\n      end\n\n      # Remove page file dir prefix from upload path if necessary -- committer handles this itself\n      dir      = wiki.per_page_uploads ? params[:upload_dest].match(/^(#{wiki.page_file_dir}\\/+)?(.*)/)[2] : 'uploads'\n      ext      = ::File.extname(fullname)\n      format   = ext.split('.').last || 'txt'\n      filename = ::File.basename(fullname, ext)\n      contents = ::File.read(tempfile)\n      reponame = filename + '.' + format\n\n      head = wiki.repo.head\n\n      options = {\n          :message => \"Uploaded file to #{dir}/#{reponame}\",\n          :parent  => wiki.repo.head.commit,\n      }\n      author  = session['gollum.author']\n      unless author.nil?\n        options.merge! author\n      end\n\n      begin\n        committer = Gollum::Committer.new(wiki, options)\n        committer.add_to_index(dir, filename, format, contents)\n        committer.after_commit do |committer, sha|\n          wiki.clear_cache\n          committer.update_working_dir(dir, filename, format)\n        end\n        committer.commit\n        redirect to(request.referer)\n      rescue Gollum::DuplicatePageError => e\n        @message = \"Duplicate page: #{e.message}\"\n        mustache :error\n      end\n    end\n\n    post '/rename/*' do\n      wikip = wiki_page(params[:splat].first)\n      halt 500 if wikip.nil?\n      wiki   = wikip.wiki\n      page   = wiki.paged(wikip.name, wikip.path, exact = true)\n      rename = params[:rename]\n      halt 500 if page.nil?\n      halt 500 if rename.nil? or rename.empty?\n\n      # Fixup the rename if it is a relative path\n      # In 1.8.7 rename[0] != rename[0..0]\n      if rename[0..0] != '/'\n        source_dir                = ::File.dirname(page.path)\n        source_dir                = '' if source_dir == '.'\n        (target_dir, target_name) = ::File.split(rename)\n        target_dir                = target_dir == '' ? source_dir : \"#{source_dir}/#{target_dir}\"\n        rename                    = \"#{target_dir}/#{target_name}\"\n      end\n\n      committer = Gollum::Committer.new(wiki, commit_message)\n      commit    = { :committer => committer }\n\n      success = wiki.rename_page(page, rename, commit)\n      if !success\n        # This occurs on NOOPs, for example renaming A => A\n        redirect to(\"/#{page.escaped_url_path}\")\n        return\n      end\n      committer.commit\n\n      wikip = wiki_page(rename)\n      page  = wiki.paged(wikip.name, wikip.path, exact = true)\n      return if page.nil?\n      redirect to(\"/#{page.escaped_url_path}\")\n    end\n\n    post '/edit/*' do\n      path      = '/' + clean_url(sanitize_empty_params(params[:path])).to_s\n      page_name = CGI.unescape(params[:page])\n      wiki      = wiki_new\n      page      = wiki.paged(page_name, path, exact = true)\n      return if page.nil?\n      committer = Gollum::Committer.new(wiki, commit_message)\n      commit    = { :committer => committer }\n\n      update_wiki_page(wiki, page, params[:content], commit, page.name, params[:format])\n      update_wiki_page(wiki, page.header, params[:header], commit) if params[:header]\n      update_wiki_page(wiki, page.footer, params[:footer], commit) if params[:footer]\n      update_wiki_page(wiki, page.sidebar, params[:sidebar], commit) if params[:sidebar]\n      committer.commit\n\n      redirect to(\"/#{page.escaped_url_path}\") unless page.nil?\n    end\n\n    get '/delete/*' do\n      forbid unless @allow_editing\n      wikip = wiki_page(params[:splat].first)\n      name  = wikip.name\n      wiki  = wikip.wiki\n      page  = wikip.page\n      unless page.nil?\n        commit           = commit_message\n        commit[:message] = \"Destroyed #{name} (#{page.format})\"\n        wiki.delete_page(page, commit)\n      end\n\n      redirect to('/')\n    end\n\n    get '/create/*' do\n      forbid unless @allow_editing\n      wikip = wiki_page(params[:splat].first.gsub('+', '-'))\n      @name = wikip.name.to_url\n      @path = wikip.path\n      @allow_uploads = wikip.wiki.allow_uploads\n      @upload_dest   = find_upload_dest(@path)\n\n      page_dir = settings.wiki_options[:page_file_dir].to_s\n      unless page_dir.empty?\n        # --page-file-dir docs\n        # /docs/Home should be created in /Home\n        # not /docs/Home because write_page will append /docs\n        @path = @path.sub(page_dir, '/') if @path.start_with? page_dir\n      end\n      @path = clean_path(@path)\n\n      page = wikip.page\n      if page\n        page_dir = settings.wiki_options[:page_file_dir].to_s\n        redirect to(\"/#{clean_url(::File.join(page_dir, page.escaped_url_path))}\")\n      else\n        mustache :create\n      end\n    end\n\n    post '/create' do\n      name   = params[:page].to_url\n      path   = sanitize_empty_params(params[:path]) || ''\n      format = params[:format].intern\n      wiki   = wiki_new\n\n      path.gsub!(/^\\//, '')\n\n      begin\n        wiki.write_page(name, format, params[:content], commit_message, path)\n\n        page_dir = settings.wiki_options[:page_file_dir].to_s\n        redirect to(\"/#{clean_url(::File.join(page_dir, path, encodeURIComponent(name)))}\")\n      rescue Gollum::DuplicatePageError => e\n        @message = \"Duplicate page: #{e.message}\"\n        mustache :error\n      end\n    end\n\n    post '/revert/*/:sha1/:sha2' do\n      wikip = wiki_page(params[:splat].first)\n      @path = wikip.path\n      @name = wikip.name\n      wiki  = wikip.wiki\n      @page = wiki.paged(@name, @path)\n      sha1  = params[:sha1]\n      sha2  = params[:sha2]\n\n      commit           = commit_message\n      commit[:message] = \"Revert commit #{sha1.chars.take(7).join}\"\n      if wiki.revert_page(@page, sha1, sha2, commit)\n        redirect to(\"/#{@page.escaped_url_path}\")\n      else\n        sha2, sha1 = sha1, \"#{sha1}^\" if !sha2\n        @versions  = [sha1, sha2]\n        diffs      = wiki.repo.diff(@versions.first, @versions.last, @page.path)\n        @diff      = diffs.first\n        @message   = \"The patch does not apply.\"\n        mustache :compare\n      end\n    end\n\n    post '/preview' do\n      wiki           = wiki_new\n      @name          = params[:page] || \"Preview\"\n      @page          = wiki.preview_page(@name, params[:content], params[:format])\n      @content       = @page.formatted_data\n      @toc_content   = wiki.universal_toc ? @page.toc_data : nil\n      @mathjax       = wiki.mathjax\n      @h1_title      = wiki.h1_title\n      @editable      = false\n      @allow_uploads = wiki.allow_uploads\n      mustache :page\n    end\n\n    get '/livepreview/' do\n      wiki = wiki_new\n      @mathjax = wiki.mathjax\n      mustache :livepreview, { :layout => false }\n    end\n\n    get '/history/*' do\n      @page     = wiki_page(params[:splat].first).page\n      @page_num = [params[:page].to_i, 1].max\n      unless @page.nil?\n        @versions = @page.versions :page => @page_num\n        mustache :history\n      else\n        redirect to(\"/\")\n      end\n    end\n\n    get '/latest_changes' do\n      @wiki = wiki_new\n      max_count = settings.wiki_options.fetch(:latest_changes_count, 10)\n      @versions = @wiki.latest_changes({:max_count => max_count})\n      mustache :latest_changes\n    end\n\n    post '/compare/*' do\n      @file     = encodeURIComponent(params[:splat].first)\n      @versions = params[:versions] || []\n      if @versions.size < 2\n        redirect to(\"/history/#{@file}\")\n      else\n        redirect to(\"/compare/%s/%s...%s\" % [\n            @file,\n            @versions.last,\n            @versions.first]\n                 )\n      end\n    end\n\n    get %r{\n      /compare/ # match any URL beginning with /compare/\n      (.+)      # extract the full path (including any directories)\n      /         # match the final slash\n      ([^.]+)   # match the first SHA1\n      \\.{2,3}   # match .. or ...\n      (.+)      # match the second SHA1\n    }x do |path, start_version, end_version|\n      wikip     = wiki_page(path)\n      @path     = wikip.path\n      @name     = wikip.name\n      @versions = [start_version, end_version]\n      wiki      = wikip.wiki\n      @page     = wikip.page\n      diffs     = wiki.repo.diff(@versions.first, @versions.last, @page.path)\n      @diff     = diffs.first\n      mustache :compare\n    end\n\n    get %r{/(.+?)/([0-9a-f]{40})} do\n      file_path = params[:captures][0]\n      version   = params[:captures][1]\n      wikip     = wiki_page(file_path, file_path, version)\n      name      = wikip.name\n      path      = wikip.path\n      if page = wikip.page\n        @page    = page\n        @name    = name\n        @content = page.formatted_data\n        @version = version\n        mustache :page\n      elsif file = wikip.wiki.file(\"#{file_path}\", version, true)\n        show_file(file)\n      else\n        halt 404\n      end\n    end\n\n    get '/search' do\n      @query   = params[:q] || ''\n      wiki     = wiki_new\n      # Sort wiki search results by count (desc) and then by name (asc)\n      @results = wiki.search(@query).sort { |a, b| (a[:count] <=> b[:count]).nonzero? || b[:name] <=> a[:name] }.reverse\n      @name    = @query\n      mustache :search\n    end\n\n    get %r{\n      /pages  # match any URL beginning with /pages\n      (?:     # begin an optional non-capturing group\n        /(.+) # capture any path after the \"/pages\" excluding the leading slash\n      )?      # end the optional non-capturing group\n    }x do |path|\n      @path        = extract_path(path) if path\n      wiki_options = settings.wiki_options.merge({ :page_file_dir => @path })\n      wiki         = Gollum::Wiki.new(settings.gollum_path, wiki_options)\n      @results     = wiki.pages\n      @results     += wiki.files if settings.wiki_options[:show_all]\n      @results     = @results.sort_by { |p| p.name.downcase } # Sort Results alphabetically, fixes 922\n      @ref         = wiki.ref\n      mustache :pages\n    end\n\n    get '/fileview' do\n      wiki     = wiki_new\n      options  = settings.wiki_options\n      content  = wiki.pages\n      # if showing all files include wiki.files\n      content  += wiki.files if options[:show_all]\n\n      # must pass wiki_options to FileView\n      # --show-all and --collapse-tree can be set.\n      @results = Gollum::FileView.new(content, options).render_files\n      @ref     = wiki.ref\n      mustache :file_view, { :layout => false }\n    end\n\n    get '/*' do\n      show_page_or_file(params[:splat].first)\n    end\n\n    def show_page_or_file(fullpath)\n      wiki = wiki_new\n\n      name = extract_name(fullpath) || wiki.index_page\n      path = extract_path(fullpath) || '/'\n\n      if page = wiki.paged(name, path, exact = true)\n        @page          = page\n        @name          = name\n        @content       = page.formatted_data\n        @upload_dest   = find_upload_dest(path)\n\n        # Extensions and layout data\n        @editable      = true\n        @page_exists   = !page.versions.empty?\n        @toc_content   = wiki.universal_toc ? @page.toc_data : nil\n        @mathjax       = wiki.mathjax\n        @h1_title      = wiki.h1_title\n        @bar_side      = wiki.bar_side\n        @allow_uploads = wiki.allow_uploads\n\n        mustache :page\n      elsif file = wiki.file(fullpath, wiki.ref, true)\n        show_file(file)\n      else\n        not_found unless @allow_editing\n        page_path = [path, name].compact.join('/')\n        redirect to(\"/create/#{clean_url(encodeURIComponent(page_path))}\")\n      end\n    end\n\n    def show_file(file)\n      return unless file\n      if file.on_disk?\n        send_file file.on_disk_path, :disposition => 'inline'\n      else\n        content_type file.mime_type\n        file.raw_data\n      end\n    end\n\n    def update_wiki_page(wiki, page, content, commit, name = nil, format = nil)\n      return if !page ||\n          ((!content || page.raw_data == content) && page.format == format)\n      name    ||= page.name\n      format  = (format || page.format).to_sym\n      content ||= page.raw_data\n      wiki.update_page(page, name, format, content.to_s, commit)\n    end\n\n    private\n\n    # Options parameter to Gollum::Committer#initialize\n    #     :message   - The String commit message.\n    #     :name      - The String author full name.\n    #     :email     - The String email address.\n    # message is sourced from the incoming request parameters\n    # author details are sourced from the session, to be populated by rack middleware ahead of us\n    def commit_message\n      msg               = (params[:message].nil? or params[:message].empty?) ? \"[no message]\" : params[:message]\n      commit_message    = { :message => msg }\n      author_parameters = session['gollum.author']\n      commit_message.merge! author_parameters unless author_parameters.nil?\n      commit_message\n    end\n\n    def find_upload_dest(path)\n      settings.wiki_options[:allow_uploads] ?\n          (settings.wiki_options[:per_page_uploads] ?\n              \"#{path}/#{@name}\".sub(/^\\/\\//, '') : 'uploads'\n          ) : ''\n    end\n  end\nend\n"], "fixing_code": ["# ~*~ encoding: utf-8 ~*~\nrequire 'cgi'\nrequire 'sinatra'\nrequire 'gollum-lib'\nrequire 'mustache/sinatra'\nrequire 'useragent'\nrequire 'stringex'\n\nrequire 'gollum'\nrequire 'gollum/views/layout'\nrequire 'gollum/views/editable'\nrequire 'gollum/views/has_page'\n\nrequire File.expand_path '../helpers', __FILE__\n\n#required to upload bigger binary files\nGollum::set_git_timeout(120)\nGollum::set_git_max_filesize(190 * 10**6)\n\n# Fix to_url\nclass String\n  alias :upstream_to_url :to_url\n\n  if defined?(Gollum::GIT_ADAPTER) && Gollum::GIT_ADAPTER != 'grit'\n    def to_ascii\n      self # Do not transliterate utf-8 url's unless using Grit\n    end\n  end\n\n  # _Header => header which causes errors\n  def to_url\n    return nil if self.nil?\n    upstream_to_url :exclude => ['_Header', '_Footer', '_Sidebar'], :force_downcase => false\n  end\nend\n\n# Run the frontend, based on Sinatra\n#\n# There are a number of wiki options that can be set for the frontend\n#\n# Example\n# require 'gollum/app'\n# Precious::App.set(:wiki_options, {\n#     :universal_toc => false,\n# }\n#\n# See the wiki.rb file for more details on wiki options\nmodule Precious\n  class App < Sinatra::Base\n    register Mustache::Sinatra\n    include Precious::Helpers\n    \n    dir     = File.dirname(File.expand_path(__FILE__))\n\n    # Detect unsupported browsers.\n    Browser = Struct.new(:browser, :version)\n\n    @@min_ua = [\n        Browser.new('Internet Explorer', '10.0'),\n        Browser.new('Chrome', '7.0'),\n        Browser.new('Firefox', '4.0'),\n    ]\n\n    def supported_useragent?(user_agent)\n      ua = UserAgent.parse(user_agent)\n      @@min_ua.detect { |min| ua >= min }\n    end\n\n    # We want to serve public assets for now\n    set :public_folder, \"#{dir}/public/gollum\"\n    set :static, true\n    set :default_markup, :markdown\n\n    set :mustache, {\n        # Tell mustache where the Views constant lives\n        :namespace => Precious,\n\n        # Mustache templates live here\n        :templates => \"#{dir}/templates\",\n\n        # Tell mustache where the views are\n        :views     => \"#{dir}/views\"\n    }\n\n    # Sinatra error handling\n    configure :development, :staging do\n      enable :show_exceptions, :dump_errors\n      disable :raise_errors, :clean_trace\n    end\n\n    configure :test do\n      enable :logging, :raise_errors, :dump_errors\n    end\n\n    before do\n      settings.wiki_options[:allow_editing] = settings.wiki_options.fetch(:allow_editing, true)\n      @allow_editing = settings.wiki_options[:allow_editing]\n      forbid unless @allow_editing || request.request_method == \"GET\"\n      Precious::App.set(:mustache, {:templates => settings.wiki_options[:template_dir]}) if settings.wiki_options[:template_dir]\n      @base_url = url('/', false).chomp('/')\n      @page_dir = settings.wiki_options[:page_file_dir].to_s\n      # above will detect base_path when it's used with map in a config.ru\n      settings.wiki_options.merge!({ :base_path => @base_url })\n      @css = settings.wiki_options[:css]\n      @js  = settings.wiki_options[:js]\n      @mathjax_config = settings.wiki_options[:mathjax_config]\n    end\n\n    get '/' do\n      redirect clean_url(::File.join(@base_url, @page_dir, wiki_new.index_page))\n    end\n\n    # path is set to name if path is nil.\n    #   if path is 'a/b' and a and b are dirs, then\n    #   path must have a trailing slash 'a/b/' or\n    #   extract_path will trim path to 'a'\n    # name, path, version\n    def wiki_page(name, path = nil, version = nil, exact = true)\n      wiki = wiki_new\n      path = name if path.nil?\n      name = extract_name(name) || wiki.index_page\n      path = extract_path(path)\n      path = '/' if exact && path.nil?\n\n      OpenStruct.new(:wiki => wiki, :page => wiki.paged(name, path, exact, version),\n                     :name => name, :path => path)\n    end\n\n    def wiki_new\n      Gollum::Wiki.new(settings.gollum_path, settings.wiki_options)\n    end\n\n    get '/data/*' do\n      if page = wiki_page(params[:splat].first).page\n        page.raw_data\n      end\n    end\n\n    get '/edit/*' do\n      forbid unless @allow_editing\n      wikip = wiki_page(params[:splat].first)\n      @name = wikip.name\n      @path = wikip.path\n      @upload_dest   = find_upload_dest(@path)\n\n      wiki = wikip.wiki\n      @allow_uploads = wiki.allow_uploads\n      if page = wikip.page\n        if wiki.live_preview && page.format.to_s.include?('markdown') && supported_useragent?(request.user_agent)\n          live_preview_url = '/livepreview/?page=' + encodeURIComponent(@name)\n          if @path\n            live_preview_url << '&path=' + encodeURIComponent(@path)\n          end\n          redirect to(live_preview_url)\n        else\n          @page         = page\n          @page.version = wiki.repo.log(wiki.ref, @page.path).first\n          @content      = page.text_data\n          mustache :edit\n        end\n      else\n        redirect to(\"/create/#{encodeURIComponent(@name)}\")\n      end\n    end\n\n    post '/uploadFile' do\n      wiki = wiki_new\n\n      unless wiki.allow_uploads\n        @message = \"File uploads are disabled\"\n        mustache :error\n        return\n      end\n\n      if params[:file]\n        fullname = params[:file][:filename]\n        tempfile = params[:file][:tempfile]\n      end\n      halt 500 unless tempfile.is_a? Tempfile\n\n      # Remove page file dir prefix from upload path if necessary -- committer handles this itself\n      dir      = wiki.per_page_uploads ? params[:upload_dest].match(/^(#{wiki.page_file_dir}\\/+)?(.*)/)[2] : 'uploads'\n      ext      = ::File.extname(fullname)\n      format   = ext.split('.').last || 'txt'\n      filename = ::File.basename(fullname, ext)\n      contents = ::File.read(tempfile)\n      reponame = filename + '.' + format\n\n      head = wiki.repo.head\n\n      options = {\n          :message => \"Uploaded file to #{dir}/#{reponame}\",\n          :parent  => wiki.repo.head.commit,\n      }\n      author  = session['gollum.author']\n      unless author.nil?\n        options.merge! author\n      end\n\n      begin\n        committer = Gollum::Committer.new(wiki, options)\n        committer.add_to_index(dir, filename, format, contents)\n        committer.after_commit do |committer, sha|\n          wiki.clear_cache\n          committer.update_working_dir(dir, filename, format)\n        end\n        committer.commit\n        redirect to(request.referer)\n      rescue Gollum::DuplicatePageError => e\n        @message = \"Duplicate page: #{e.message}\"\n        mustache :error\n      end\n    end\n\n    post '/rename/*' do\n      wikip = wiki_page(params[:splat].first)\n      halt 500 if wikip.nil?\n      wiki   = wikip.wiki\n      page   = wiki.paged(wikip.name, wikip.path, exact = true)\n      rename = params[:rename]\n      halt 500 if page.nil?\n      halt 500 if rename.nil? or rename.empty?\n\n      # Fixup the rename if it is a relative path\n      # In 1.8.7 rename[0] != rename[0..0]\n      if rename[0..0] != '/'\n        source_dir                = ::File.dirname(page.path)\n        source_dir                = '' if source_dir == '.'\n        (target_dir, target_name) = ::File.split(rename)\n        target_dir                = target_dir == '' ? source_dir : \"#{source_dir}/#{target_dir}\"\n        rename                    = \"#{target_dir}/#{target_name}\"\n      end\n\n      committer = Gollum::Committer.new(wiki, commit_message)\n      commit    = { :committer => committer }\n\n      success = wiki.rename_page(page, rename, commit)\n      if !success\n        # This occurs on NOOPs, for example renaming A => A\n        redirect to(\"/#{page.escaped_url_path}\")\n        return\n      end\n      committer.commit\n\n      wikip = wiki_page(rename)\n      page  = wiki.paged(wikip.name, wikip.path, exact = true)\n      return if page.nil?\n      redirect to(\"/#{page.escaped_url_path}\")\n    end\n\n    post '/edit/*' do\n      path      = '/' + clean_url(sanitize_empty_params(params[:path])).to_s\n      page_name = CGI.unescape(params[:page])\n      wiki      = wiki_new\n      page      = wiki.paged(page_name, path, exact = true)\n      return if page.nil?\n      committer = Gollum::Committer.new(wiki, commit_message)\n      commit    = { :committer => committer }\n\n      update_wiki_page(wiki, page, params[:content], commit, page.name, params[:format])\n      update_wiki_page(wiki, page.header, params[:header], commit) if params[:header]\n      update_wiki_page(wiki, page.footer, params[:footer], commit) if params[:footer]\n      update_wiki_page(wiki, page.sidebar, params[:sidebar], commit) if params[:sidebar]\n      committer.commit\n\n      redirect to(\"/#{page.escaped_url_path}\") unless page.nil?\n    end\n\n    get '/delete/*' do\n      forbid unless @allow_editing\n      wikip = wiki_page(params[:splat].first)\n      name  = wikip.name\n      wiki  = wikip.wiki\n      page  = wikip.page\n      unless page.nil?\n        commit           = commit_message\n        commit[:message] = \"Destroyed #{name} (#{page.format})\"\n        wiki.delete_page(page, commit)\n      end\n\n      redirect to('/')\n    end\n\n    get '/create/*' do\n      forbid unless @allow_editing\n      wikip = wiki_page(params[:splat].first.gsub('+', '-'))\n      @name = wikip.name.to_url\n      @path = wikip.path\n      @allow_uploads = wikip.wiki.allow_uploads\n      @upload_dest   = find_upload_dest(@path)\n\n      page_dir = settings.wiki_options[:page_file_dir].to_s\n      unless page_dir.empty?\n        # --page-file-dir docs\n        # /docs/Home should be created in /Home\n        # not /docs/Home because write_page will append /docs\n        @path = @path.sub(page_dir, '/') if @path.start_with? page_dir\n      end\n      @path = clean_path(@path)\n\n      page = wikip.page\n      if page\n        page_dir = settings.wiki_options[:page_file_dir].to_s\n        redirect to(\"/#{clean_url(::File.join(page_dir, page.escaped_url_path))}\")\n      else\n        mustache :create\n      end\n    end\n\n    post '/create' do\n      name   = params[:page].to_url\n      path   = sanitize_empty_params(params[:path]) || ''\n      format = params[:format].intern\n      wiki   = wiki_new\n\n      path.gsub!(/^\\//, '')\n\n      begin\n        wiki.write_page(name, format, params[:content], commit_message, path)\n\n        page_dir = settings.wiki_options[:page_file_dir].to_s\n        redirect to(\"/#{clean_url(::File.join(page_dir, path, encodeURIComponent(name)))}\")\n      rescue Gollum::DuplicatePageError => e\n        @message = \"Duplicate page: #{e.message}\"\n        mustache :error\n      end\n    end\n\n    post '/revert/*/:sha1/:sha2' do\n      wikip = wiki_page(params[:splat].first)\n      @path = wikip.path\n      @name = wikip.name\n      wiki  = wikip.wiki\n      @page = wiki.paged(@name, @path)\n      sha1  = params[:sha1]\n      sha2  = params[:sha2]\n\n      commit           = commit_message\n      commit[:message] = \"Revert commit #{sha1.chars.take(7).join}\"\n      if wiki.revert_page(@page, sha1, sha2, commit)\n        redirect to(\"/#{@page.escaped_url_path}\")\n      else\n        sha2, sha1 = sha1, \"#{sha1}^\" if !sha2\n        @versions  = [sha1, sha2]\n        diffs      = wiki.repo.diff(@versions.first, @versions.last, @page.path)\n        @diff      = diffs.first\n        @message   = \"The patch does not apply.\"\n        mustache :compare\n      end\n    end\n\n    post '/preview' do\n      wiki           = wiki_new\n      @name          = params[:page] || \"Preview\"\n      @page          = wiki.preview_page(@name, params[:content], params[:format])\n      @content       = @page.formatted_data\n      @toc_content   = wiki.universal_toc ? @page.toc_data : nil\n      @mathjax       = wiki.mathjax\n      @h1_title      = wiki.h1_title\n      @editable      = false\n      @allow_uploads = wiki.allow_uploads\n      mustache :page\n    end\n\n    get '/livepreview/' do\n      wiki = wiki_new\n      @mathjax = wiki.mathjax\n      mustache :livepreview, { :layout => false }\n    end\n\n    get '/history/*' do\n      @page     = wiki_page(params[:splat].first).page\n      @page_num = [params[:page].to_i, 1].max\n      unless @page.nil?\n        @versions = @page.versions :page => @page_num\n        mustache :history\n      else\n        redirect to(\"/\")\n      end\n    end\n\n    get '/latest_changes' do\n      @wiki = wiki_new\n      max_count = settings.wiki_options.fetch(:latest_changes_count, 10)\n      @versions = @wiki.latest_changes({:max_count => max_count})\n      mustache :latest_changes\n    end\n\n    post '/compare/*' do\n      @file     = encodeURIComponent(params[:splat].first)\n      @versions = params[:versions] || []\n      if @versions.size < 2\n        redirect to(\"/history/#{@file}\")\n      else\n        redirect to(\"/compare/%s/%s...%s\" % [\n            @file,\n            @versions.last,\n            @versions.first]\n                 )\n      end\n    end\n\n    get %r{\n      /compare/ # match any URL beginning with /compare/\n      (.+)      # extract the full path (including any directories)\n      /         # match the final slash\n      ([^.]+)   # match the first SHA1\n      \\.{2,3}   # match .. or ...\n      (.+)      # match the second SHA1\n    }x do |path, start_version, end_version|\n      wikip     = wiki_page(path)\n      @path     = wikip.path\n      @name     = wikip.name\n      @versions = [start_version, end_version]\n      wiki      = wikip.wiki\n      @page     = wikip.page\n      diffs     = wiki.repo.diff(@versions.first, @versions.last, @page.path)\n      @diff     = diffs.first\n      mustache :compare\n    end\n\n    get %r{/(.+?)/([0-9a-f]{40})} do\n      file_path = params[:captures][0]\n      version   = params[:captures][1]\n      wikip     = wiki_page(file_path, file_path, version)\n      name      = wikip.name\n      path      = wikip.path\n      if page = wikip.page\n        @page    = page\n        @name    = name\n        @content = page.formatted_data\n        @version = version\n        mustache :page\n      elsif file = wikip.wiki.file(\"#{file_path}\", version, true)\n        show_file(file)\n      else\n        halt 404\n      end\n    end\n\n    get '/search' do\n      @query   = params[:q] || ''\n      wiki     = wiki_new\n      # Sort wiki search results by count (desc) and then by name (asc)\n      @results = wiki.search(@query).sort { |a, b| (a[:count] <=> b[:count]).nonzero? || b[:name] <=> a[:name] }.reverse\n      @name    = @query\n      mustache :search\n    end\n\n    get %r{\n      /pages  # match any URL beginning with /pages\n      (?:     # begin an optional non-capturing group\n        /(.+) # capture any path after the \"/pages\" excluding the leading slash\n      )?      # end the optional non-capturing group\n    }x do |path|\n      @path        = extract_path(path) if path\n      wiki_options = settings.wiki_options.merge({ :page_file_dir => @path })\n      wiki         = Gollum::Wiki.new(settings.gollum_path, wiki_options)\n      @results     = wiki.pages\n      @results     += wiki.files if settings.wiki_options[:show_all]\n      @results     = @results.sort_by { |p| p.name.downcase } # Sort Results alphabetically, fixes 922\n      @ref         = wiki.ref\n      mustache :pages\n    end\n\n    get '/fileview' do\n      wiki     = wiki_new\n      options  = settings.wiki_options\n      content  = wiki.pages\n      # if showing all files include wiki.files\n      content  += wiki.files if options[:show_all]\n\n      # must pass wiki_options to FileView\n      # --show-all and --collapse-tree can be set.\n      @results = Gollum::FileView.new(content, options).render_files\n      @ref     = wiki.ref\n      mustache :file_view, { :layout => false }\n    end\n\n    get '/*' do\n      show_page_or_file(params[:splat].first)\n    end\n\n    def show_page_or_file(fullpath)\n      wiki = wiki_new\n\n      name = extract_name(fullpath) || wiki.index_page\n      path = extract_path(fullpath) || '/'\n\n      if page = wiki.paged(name, path, exact = true)\n        @page          = page\n        @name          = name\n        @content       = page.formatted_data\n        @upload_dest   = find_upload_dest(path)\n\n        # Extensions and layout data\n        @editable      = true\n        @page_exists   = !page.versions.empty?\n        @toc_content   = wiki.universal_toc ? @page.toc_data : nil\n        @mathjax       = wiki.mathjax\n        @h1_title      = wiki.h1_title\n        @bar_side      = wiki.bar_side\n        @allow_uploads = wiki.allow_uploads\n\n        mustache :page\n      elsif file = wiki.file(fullpath, wiki.ref, true)\n        show_file(file)\n      else\n        not_found unless @allow_editing\n        page_path = [path, name].compact.join('/')\n        redirect to(\"/create/#{clean_url(encodeURIComponent(page_path))}\")\n      end\n    end\n\n    def show_file(file)\n      return unless file\n      if file.on_disk?\n        send_file file.on_disk_path, :disposition => 'inline'\n      else\n        content_type file.mime_type\n        file.raw_data\n      end\n    end\n\n    def update_wiki_page(wiki, page, content, commit, name = nil, format = nil)\n      return if !page ||\n          ((!content || page.raw_data == content) && page.format == format)\n      name    ||= page.name\n      format  = (format || page.format).to_sym\n      content ||= page.raw_data\n      wiki.update_page(page, name, format, content.to_s, commit)\n    end\n\n    private\n\n    # Options parameter to Gollum::Committer#initialize\n    #     :message   - The String commit message.\n    #     :name      - The String author full name.\n    #     :email     - The String email address.\n    # message is sourced from the incoming request parameters\n    # author details are sourced from the session, to be populated by rack middleware ahead of us\n    def commit_message\n      msg               = (params[:message].nil? or params[:message].empty?) ? \"[no message]\" : params[:message]\n      commit_message    = { :message => msg }\n      author_parameters = session['gollum.author']\n      commit_message.merge! author_parameters unless author_parameters.nil?\n      commit_message\n    end\n\n    def find_upload_dest(path)\n      settings.wiki_options[:allow_uploads] ?\n          (settings.wiki_options[:per_page_uploads] ?\n              \"#{path}/#{@name}\".sub(/^\\/\\//, '') : 'uploads'\n          ) : ''\n    end\n  end\nend\n"], "filenames": ["lib/gollum/app.rb"], "buggy_code_start_loc": [178], "buggy_code_end_loc": [178], "fixing_code_start_loc": [179], "fixing_code_end_loc": [180], "type": "CWE-200", "message": "The Precious module in gollum before 4.0.1 allows remote attackers to read arbitrary files by leveraging the lack of a certain temporary-file check.", "other": {"cve": {"id": "CVE-2015-7314", "sourceIdentifier": "cve@mitre.org", "published": "2015-10-06T01:59:32.500", "lastModified": "2015-10-07T14:45:05.060", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Precious module in gollum before 4.0.1 allows remote attackers to read arbitrary files by leveraging the lack of a certain temporary-file check."}, {"lang": "es", "value": "El m\u00f3dulo Precious en gollum en versiones anteriores a 4.0.1 permite a atacantes remotos leer archivos arbitrarios mediante el aprovechamiento de la falta de una cierta verificaci\u00f3n de archivo temporal."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gollum_project:gollum:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0", "matchCriteriaId": "ED604B55-01F7-48C0-9CA4-93DA49626F2A"}]}]}], "references": [{"url": "http://jvn.jp/en/jp/JVN27548431/index.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://jvndb.jvn.jp/jvndb/JVNDB-2015-000149", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/09/22/12", "source": "cve@mitre.org"}, {"url": "https://github.com/gollum/gollum/commit/ce68a88293ce3b18c261312392ad33a88bb69ea1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/gollum/gollum/issues/1070", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gollum/gollum/commit/ce68a88293ce3b18c261312392ad33a88bb69ea1"}}