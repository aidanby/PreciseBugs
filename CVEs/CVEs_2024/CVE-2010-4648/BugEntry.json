{"buggy_code": ["/* Wireless extensions support.\n *\n * See copyright notice in main.c\n */\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/wireless.h>\n#include <linux/ieee80211.h>\n#include <net/iw_handler.h>\n#include <net/cfg80211.h>\n\n#include \"hermes.h\"\n#include \"hermes_rid.h\"\n#include \"orinoco.h\"\n\n#include \"hw.h\"\n#include \"mic.h\"\n#include \"scan.h\"\n#include \"main.h\"\n\n#include \"wext.h\"\n\n#define MAX_RID_LEN 1024\n\n/* Helper routine to record keys\n * It is called under orinoco_lock so it may not sleep */\nstatic int orinoco_set_key(struct orinoco_private *priv, int index,\n\t\t\t   enum orinoco_alg alg, const u8 *key, int key_len,\n\t\t\t   const u8 *seq, int seq_len)\n{\n\tkzfree(priv->keys[index].key);\n\tkzfree(priv->keys[index].seq);\n\n\tif (key_len) {\n\t\tpriv->keys[index].key = kzalloc(key_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].key)\n\t\t\tgoto nomem;\n\t} else\n\t\tpriv->keys[index].key = NULL;\n\n\tif (seq_len) {\n\t\tpriv->keys[index].seq = kzalloc(seq_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].seq)\n\t\t\tgoto free_key;\n\t} else\n\t\tpriv->keys[index].seq = NULL;\n\n\tpriv->keys[index].key_len = key_len;\n\tpriv->keys[index].seq_len = seq_len;\n\n\tif (key_len)\n\t\tmemcpy(priv->keys[index].key, key, key_len);\n\tif (seq_len)\n\t\tmemcpy(priv->keys[index].seq, seq, seq_len);\n\n\tswitch (alg) {\n\tcase ORINOCO_ALG_TKIP:\n\t\tpriv->keys[index].cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_WEP:\n\t\tpriv->keys[index].cipher = (key_len > SMALL_KEY_SIZE) ?\n\t\t\tWLAN_CIPHER_SUITE_WEP104 : WLAN_CIPHER_SUITE_WEP40;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_NONE:\n\tdefault:\n\t\tpriv->keys[index].cipher = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nfree_key:\n\tkfree(priv->keys[index].key);\n\tpriv->keys[index].key = NULL;\n\nnomem:\n\tpriv->keys[index].key_len = 0;\n\tpriv->keys[index].seq_len = 0;\n\tpriv->keys[index].cipher = 0;\n\n\treturn -ENOMEM;\n}\n\nstatic struct iw_statistics *orinoco_get_wireless_stats(struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_statistics *wstats = &priv->wstats;\n\tint err;\n\tunsigned long flags;\n\n\tif (!netif_device_present(dev)) {\n\t\tprintk(KERN_WARNING \"%s: get_wireless_stats() called while device not present\\n\",\n\t\t       dev->name);\n\t\treturn NULL; /* FIXME: Can we do better than this? */\n\t}\n\n\t/* If busy, return the old stats.  Returning NULL may cause\n\t * the interface to disappear from /proc/net/wireless */\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn wstats;\n\n\t/* We can't really wait for the tallies inquiry command to\n\t * complete, so we just use the previous results and trigger\n\t * a new tallies inquiry command for next time - Jean II */\n\t/* FIXME: Really we should wait for the inquiry to come back -\n\t * as it is the stats we give don't make a whole lot of sense.\n\t * Unfortunately, it's not clear how to do that within the\n\t * wireless extensions framework: I think we're in user\n\t * context, but a lock seems to be held by the time we get in\n\t * here so we're not safe to sleep here. */\n\thermes_inquire(hw, HERMES_INQ_TALLIES);\n\n\tif (priv->iw_mode == NL80211_IFTYPE_ADHOC) {\n\t\tmemset(&wstats->qual, 0, sizeof(wstats->qual));\n\t\t/* If a spy address is defined, we report stats of the\n\t\t * first spy address - Jean II */\n\t\tif (SPY_NUMBER(priv)) {\n\t\t\twstats->qual.qual = priv->spy_data.spy_stat[0].qual;\n\t\t\twstats->qual.level = priv->spy_data.spy_stat[0].level;\n\t\t\twstats->qual.noise = priv->spy_data.spy_stat[0].noise;\n\t\t\twstats->qual.updated =\n\t\t\t\tpriv->spy_data.spy_stat[0].updated;\n\t\t}\n\t} else {\n\t\tstruct {\n\t\t\t__le16 qual, signal, noise, unused;\n\t\t} __packed cq;\n\n\t\terr = HERMES_READ_RECORD(hw, USER_BAP,\n\t\t\t\t\t HERMES_RID_COMMSQUALITY, &cq);\n\n\t\tif (!err) {\n\t\t\twstats->qual.qual = (int)le16_to_cpu(cq.qual);\n\t\t\twstats->qual.level = (int)le16_to_cpu(cq.signal) - 0x95;\n\t\t\twstats->qual.noise = (int)le16_to_cpu(cq.noise) - 0x95;\n\t\t\twstats->qual.updated =\n\t\t\t\tIW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t\t}\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn wstats;\n}\n\n/********************************************************************/\n/* Wireless extensions                                              */\n/********************************************************************/\n\nstatic int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\tunsigned long flags;\n\tstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* Enable automatic roaming - no sanity checks are needed */\n\tif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\n\t    memcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\n\t\tpriv->bssid_fixed = 0;\n\t\tmemset(priv->desired_bssid, 0, ETH_ALEN);\n\n\t\t/* \"off\" means keep existing connection */\n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* Intersil firmware hangs without Desired ESSID */\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* Finally, enable manual roaming */\n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tap_addr->sa_family = ARPHRD_ETHER;\n\terr = orinoco_hw_get_current_bssid(priv, ap_addr->sa_data);\n\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_setiwencode(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     struct iw_point *erq,\n\t\t\t\t     char *keybuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint index = (erq->flags & IW_ENCODE_INDEX) - 1;\n\tint setindex = priv->tx_key;\n\tenum orinoco_alg encode_alg = priv->encode_alg;\n\tint restricted = priv->wep_restrict;\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\tunsigned long flags;\n\n\tif (!priv->has_wep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (erq->pointer) {\n\t\t/* We actually have a key to set - check its length */\n\t\tif (erq->length > LARGE_KEY_SIZE)\n\t\t\treturn -E2BIG;\n\n\t\tif ((erq->length > SMALL_KEY_SIZE) && !priv->has_big_wep)\n\t\t\treturn -E2BIG;\n\t}\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* Clear any TKIP key we have */\n\tif ((priv->has_wpa) && (priv->encode_alg == ORINOCO_ALG_TKIP))\n\t\t(void) orinoco_clear_tkip_key(priv, setindex);\n\n\tif (erq->length > 0) {\n\t\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\n\t\t\tindex = priv->tx_key;\n\n\t\t/* Switch on WEP if off */\n\t\tif (encode_alg != ORINOCO_ALG_WEP) {\n\t\t\tsetindex = index;\n\t\t\tencode_alg = ORINOCO_ALG_WEP;\n\t\t}\n\t} else {\n\t\t/* Important note : if the user do \"iwconfig eth0 enc off\",\n\t\t * we will arrive there with an index of -1. This is valid\n\t\t * but need to be taken care off... Jean II */\n\t\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS)) {\n\t\t\tif ((index != -1) || (erq->flags == 0)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Set the index : Check that the key is valid */\n\t\t\tif (priv->keys[index].key_len == 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsetindex = index;\n\t\t}\n\t}\n\n\tif (erq->flags & IW_ENCODE_DISABLED)\n\t\tencode_alg = ORINOCO_ALG_NONE;\n\tif (erq->flags & IW_ENCODE_OPEN)\n\t\trestricted = 0;\n\tif (erq->flags & IW_ENCODE_RESTRICTED)\n\t\trestricted = 1;\n\n\tif (erq->pointer && erq->length > 0) {\n\t\terr = orinoco_set_key(priv, index, ORINOCO_ALG_WEP, keybuf,\n\t\t\t\t      erq->length, NULL, 0);\n\t}\n\tpriv->tx_key = setindex;\n\n\t/* Try fast key change if connected and only keys are changed */\n\tif ((priv->encode_alg == encode_alg) &&\n\t    (priv->wep_restrict == restricted) &&\n\t    netif_carrier_ok(dev)) {\n\t\terr = __orinoco_hw_setup_wepkeys(priv);\n\t\t/* No need to commit if successful */\n\t\tgoto out;\n\t}\n\n\tpriv->encode_alg = encode_alg;\n\tpriv->wep_restrict = restricted;\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getiwencode(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     struct iw_point *erq,\n\t\t\t\t     char *keybuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint index = (erq->flags & IW_ENCODE_INDEX) - 1;\n\tunsigned long flags;\n\n\tif (!priv->has_wep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\n\t\tindex = priv->tx_key;\n\n\terq->flags = 0;\n\tif (!priv->encode_alg)\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\terq->flags |= index + 1;\n\n\tif (priv->wep_restrict)\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\telse\n\t\terq->flags |= IW_ENCODE_OPEN;\n\n\terq->length = priv->keys[index].key_len;\n\n\tmemcpy(keybuf, priv->keys[index].key, erq->length);\n\n\torinoco_unlock(priv, &flags);\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\n\t/* Note : ESSID is ignored in Ad-Hoc demo mode, but we can set it\n\t * anyway... - Jean II */\n\n\t/* Hum... Should not use Wireless Extension constant (may change),\n\t * should use our own... - Jean II */\n\tif (erq->length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* NULL the string (for NULL termination & ESSID = ANY) - Jean II */\n\tmemset(priv->desired_essid, 0, sizeof(priv->desired_essid));\n\n\t/* If not ANY, get the new ESSID */\n\tif (erq->flags)\n\t\tmemcpy(priv->desired_essid, essidbuf, erq->length);\n\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\n\terq->flags = 1;\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_freq *frq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint chan = -1;\n\tunsigned long flags;\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\n\t/* In infrastructure mode the AP sets the channel */\n\tif (priv->iw_mode == NL80211_IFTYPE_STATION)\n\t\treturn -EBUSY;\n\n\tif ((frq->e == 0) && (frq->m <= 1000)) {\n\t\t/* Setting by channel number */\n\t\tchan = frq->m;\n\t} else {\n\t\t/* Setting by frequency */\n\t\tint denom = 1;\n\t\tint i;\n\n\t\t/* Calculate denominator to rescale to MHz */\n\t\tfor (i = 0; i < (6 - frq->e); i++)\n\t\t\tdenom *= 10;\n\n\t\tchan = ieee80211_freq_to_dsss_chan(frq->m / denom);\n\t}\n\n\tif ((chan < 1) || (chan > NUM_CHANNELS) ||\n\t     !(priv->channel_mask & (1 << (chan-1))))\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tpriv->channel = chan;\n\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR) {\n\t\t/* Fast channel change - no commit if successful */\n\t\thermes_t *hw = &priv->hw;\n\t\terr = hw->ops->cmd_wait(hw, HERMES_CMD_TEST |\n\t\t\t\t\t    HERMES_TEST_SET_CHANNEL,\n\t\t\t\t\tchan, NULL);\n\t}\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_freq *frq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint tmp;\n\n\t/* Locking done in there */\n\ttmp = orinoco_hw_get_freq(priv);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\tfrq->m = tmp * 100000;\n\tfrq->e = 1;\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_getsens(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *srq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tu16 val;\n\tint err;\n\tunsigned long flags;\n\n\tif (!priv->has_sensitivity)\n\t\treturn -EOPNOTSUPP;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFSYSTEMSCALE, &val);\n\torinoco_unlock(priv, &flags);\n\n\tif (err)\n\t\treturn err;\n\n\tsrq->value = val;\n\tsrq->fixed = 0; /* auto */\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setsens(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *srq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = srq->value;\n\tunsigned long flags;\n\n\tif (!priv->has_sensitivity)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((val < 1) || (val > 3))\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->ap_density = val;\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_setrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint ratemode;\n\tint bitrate; /* 100s of kilobits */\n\tunsigned long flags;\n\n\t/* As the user space doesn't know our highest rate, it uses -1\n\t * to ask us to set the highest rate.  Test it using \"iwconfig\n\t * ethX rate auto\" - Jean II */\n\tif (rrq->value == -1)\n\t\tbitrate = 110;\n\telse {\n\t\tif (rrq->value % 100000)\n\t\t\treturn -EINVAL;\n\t\tbitrate = rrq->value / 100000;\n\t}\n\n\tratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\n\n\tif (ratemode == -1)\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->bitratemode = ratemode;\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int orinoco_ioctl_getrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = 0;\n\tint bitrate, automatic;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\torinoco_get_ratemode_cfg(priv->bitratemode, &bitrate, &automatic);\n\n\t/* If the interface is running we try to find more about the\n\t   current mode */\n\tif (netif_running(dev)) {\n\t\tint act_bitrate;\n\t\tint lerr;\n\n\t\t/* Ignore errors if we can't get the actual bitrate */\n\t\tlerr = orinoco_hw_get_act_bitrate(priv, &act_bitrate);\n\t\tif (!lerr)\n\t\t\tbitrate = act_bitrate;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\n\trrq->value = bitrate;\n\trrq->fixed = !automatic;\n\trrq->disabled = 0;\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_setpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif (prq->disabled) {\n\t\tpriv->pm_on = 0;\n\t} else {\n\t\tswitch (prq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tpriv->pm_mcast = 0;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tpriv->pm_mcast = 1;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\t/* No flags : but we may have a value - Jean II */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (prq->flags & IW_POWER_TIMEOUT) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_timeout = prq->value / 1000;\n\t\t}\n\t\tif (prq->flags & IW_POWER_PERIOD) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_period = prq->value / 1000;\n\t\t}\n\t\t/* It's valid to not have a value if we are just toggling\n\t\t * the flags... Jean II */\n\t\tif (!priv->pm_on) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tint err = 0;\n\tu16 enable, period, timeout, mcast;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFPMENABLED, &enable);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFMAXSLEEPDURATION, &period);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFPMHOLDOVERDURATION, &timeout);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFMULTICASTRECEIVE, &mcast);\n\tif (err)\n\t\tgoto out;\n\n\tprq->disabled = !enable;\n\t/* Note : by default, display the period */\n\tif ((prq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tprq->flags = IW_POWER_TIMEOUT;\n\t\tprq->value = timeout * 1000;\n\t} else {\n\t\tprq->flags = IW_POWER_PERIOD;\n\t\tprq->value = period * 1000;\n\t}\n\tif (mcast)\n\t\tprq->flags |= IW_POWER_ALL_R;\n\telse\n\t\tprq->flags |= IW_POWER_UNICAST_R;\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_encodeext(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu,\n\t\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, alg = ext->alg, set_key = 1;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* Determine and validate the key index */\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif ((idx < 1) || (idx > 4))\n\t\t\tgoto out;\n\t\tidx--;\n\t} else\n\t\tidx = priv->tx_key;\n\n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t\talg = IW_ENCODE_ALG_NONE;\n\n\tif (priv->has_wpa && (alg != IW_ENCODE_ALG_TKIP)) {\n\t\t/* Clear any TKIP TX key we had */\n\t\t(void) orinoco_clear_tkip_key(priv, priv->tx_key);\n\t}\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tpriv->tx_key = idx;\n\t\tset_key = ((alg == IW_ENCODE_ALG_TKIP) ||\n\t\t\t   (ext->key_len > 0)) ? 1 : 0;\n\t}\n\n\tif (set_key) {\n\t\t/* Set the requested key first */\n\t\tswitch (alg) {\n\t\tcase IW_ENCODE_ALG_NONE:\n\t\t\tpriv->encode_alg = ORINOCO_ALG_NONE;\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_NONE,\n\t\t\t\t\t      NULL, 0, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase IW_ENCODE_ALG_WEP:\n\t\t\tif (ext->key_len <= 0)\n\t\t\t\tgoto out;\n\n\t\t\tpriv->encode_alg = ORINOCO_ALG_WEP;\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_WEP,\n\t\t\t\t\t      ext->key, ext->key_len, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase IW_ENCODE_ALG_TKIP:\n\t\t{\n\t\t\tu8 *tkip_iv = NULL;\n\n\t\t\tif (!priv->has_wpa ||\n\t\t\t    (ext->key_len > sizeof(struct orinoco_tkip_key)))\n\t\t\t\tgoto out;\n\n\t\t\tpriv->encode_alg = ORINOCO_ALG_TKIP;\n\n\t\t\tif (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)\n\t\t\t\ttkip_iv = &ext->rx_seq[0];\n\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_TKIP,\n\t\t\t\t\t      ext->key, ext->key_len, tkip_iv,\n\t\t\t\t\t      ORINOCO_SEQ_LEN);\n\n\t\t\terr = __orinoco_hw_set_tkip_key(priv, idx,\n\t\t\t\t ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY,\n\t\t\t\t priv->keys[idx].key,\n\t\t\t\t tkip_iv, ORINOCO_SEQ_LEN, NULL, 0);\n\t\t\tif (err)\n\t\t\t\tprintk(KERN_ERR \"%s: Error %d setting TKIP key\"\n\t\t\t\t       \"\\n\", dev->name, err);\n\n\t\t\tgoto out;\n\t\t}\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = -EINPROGRESS;\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_get_encodeext(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu,\n\t\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, max_key_len;\n\tunsigned long flags;\n\tint err;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = -EINVAL;\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\tgoto out;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif ((idx < 1) || (idx > 4))\n\t\t\tgoto out;\n\t\tidx--;\n\t} else\n\t\tidx = priv->tx_key;\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tswitch (priv->encode_alg) {\n\tcase ORINOCO_ALG_NONE:\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\text->key_len = 0;\n\t\tencoding->flags |= IW_ENCODE_DISABLED;\n\t\tbreak;\n\tcase ORINOCO_ALG_WEP:\n\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\text->key_len = min(priv->keys[idx].key_len, max_key_len);\n\t\tmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\tcase ORINOCO_ALG_TKIP:\n\t\text->alg = IW_ENCODE_ALG_TKIP;\n\t\text->key_len = min(priv->keys[idx].key_len, max_key_len);\n\t\tmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\t}\n\n\terr = 0;\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\t/*\n\t\t * orinoco does not use these parameters\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_KEY_MGMT:\n\t\t/* wl_lkm implies value 2 == PSK for Hermes I\n\t\t * which ties in with WEXT\n\t\t * no other hints tho :(\n\t\t */\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\t/* When countermeasures are enabled, shut down the\n\t\t * card; when disabled, re-enable the card. This must\n\t\t * take effect immediately.\n\t\t *\n\t\t * TODO: Make sure that the EAPOL message is getting\n\t\t *       out before card disabled\n\t\t */\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t/* else silently accept disable of WPA */\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_get_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_KEY_MGMT:\n\t\tparam->value = priv->key_mgmt;\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tparam->value = priv->tkip_cm_active;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (priv->wep_restrict)\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\telse\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = priv->wpa_enabled;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_set_genie(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tu8 *buf;\n\tunsigned long flags;\n\n\t/* cut off at IEEE80211_MAX_DATA_LEN */\n\tif ((wrqu->data.length > IEEE80211_MAX_DATA_LEN) ||\n\t    (wrqu->data.length && (extra == NULL)))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuf = NULL;\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\tkfree(buf);\n\t\treturn -EBUSY;\n\t}\n\n\tkfree(priv->wpa_ie);\n\tpriv->wpa_ie = buf;\n\tpriv->wpa_ie_len = wrqu->data.length;\n\n\tif (priv->wpa_ie) {\n\t\t/* Looks like wl_lkm wants to check the auth alg, and\n\t\t * somehow pass it to the firmware.\n\t\t * Instead it just calls the key mgmt rid\n\t\t *   - we do this in set auth.\n\t\t */\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_get_genie(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif ((priv->wpa_ie_len == 0) || (priv->wpa_ie == NULL)) {\n\t\twrqu->data.length = 0;\n\t\tgoto out;\n\t}\n\n\tif (wrqu->data.length < priv->wpa_ie_len) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\n\twrqu->data.length = priv->wpa_ie_len;\n\tmemcpy(extra, priv->wpa_ie, priv->wpa_ie_len);\n\nout:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_mlme(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\t/* silently ignore */\n\t\tbreak;\n\n\tcase IW_MLME_DISASSOC:\n\n\t\tret = orinoco_hw_disassociate(priv, mlme->addr.sa_data,\n\t\t\t\t\t      mlme->reason_code);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_reset(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       void *wrqu,\n\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (info->cmd == (SIOCIWFIRSTPRIV + 0x1)) {\n\t\tprintk(KERN_DEBUG \"%s: Forcing reset!\\n\", dev->name);\n\n\t\t/* Firmware reset */\n\t\torinoco_reset(&priv->reset_work);\n\t} else {\n\t\tprintk(KERN_DEBUG \"%s: Force scheduling reset!\\n\", dev->name);\n\n\t\tschedule_work(&priv->reset_work);\n\t}\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setibssport(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = *((int *) extra);\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tpriv->ibss_port = val;\n\n\t/* Actually update the mode we are using */\n\tset_port_type(priv);\n\n\torinoco_unlock(priv, &flags);\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_getibssport(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\t*val = priv->ibss_port;\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setport3(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  void *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = *((int *) extra);\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (val) {\n\tcase 0: /* Try to do IEEE ad-hoc mode */\n\t\tif (!priv->has_ibss) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 0;\n\n\t\tbreak;\n\n\tcase 1: /* Try to do Lucent proprietary ad-hoc mode */\n\t\tif (!priv->has_port3) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 1;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tif (!err) {\n\t\t/* Actually update the mode we are using */\n\t\tset_port_type(priv);\n\t\terr = -EINPROGRESS;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getport3(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  void *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\t*val = priv->prefer_port3;\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setpreamble(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint val;\n\n\tif (!priv->has_preamble)\n\t\treturn -EOPNOTSUPP;\n\n\t/* 802.11b has recently defined some short preamble.\n\t * Basically, the Phy header has been reduced in size.\n\t * This increase performance, especially at high rates\n\t * (the preamble is transmitted at 1Mb/s), unfortunately\n\t * this give compatibility troubles... - Jean II */\n\tval = *((int *) extra);\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif (val)\n\t\tpriv->preamble = 1;\n\telse\n\t\tpriv->preamble = 0;\n\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_getpreamble(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\tif (!priv->has_preamble)\n\t\treturn -EOPNOTSUPP;\n\n\t*val = priv->preamble;\n\treturn 0;\n}\n\n/* ioctl interface to hermes_read_ltv()\n * To use with iwpriv, pass the RID as the token argument, e.g.\n * iwpriv get_rid [0xfc00]\n * At least Wireless Tools 25 is required to use iwpriv.\n * For Wireless Tools 25 and 26 append \"dummy\" are the end. */\nstatic int orinoco_ioctl_getrid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct iw_point *data,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tint rid = data->flags;\n\tu16 length;\n\tint err;\n\tunsigned long flags;\n\n\t/* It's a \"get\" function, but we don't want users to access the\n\t * WEP key and other raw firmware data */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (rid < 0xfc00 || rid > 0xffff)\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, rid, MAX_RID_LEN, &length,\n\t\t\t\textra);\n\tif (err)\n\t\tgoto out;\n\n\tdata->length = min_t(u16, HERMES_RECLEN_TO_BYTES(length),\n\t\t\t     MAX_RID_LEN);\n\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\n\n/* Commit handler, called after set operations */\nstatic int orinoco_ioctl_commit(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tvoid *wrqu,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (!priv->open)\n\t\treturn 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn err;\n\n\terr = orinoco_commit(priv);\n\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic const struct iw_priv_args orinoco_privtab[] = {\n\t{ SIOCIWFIRSTPRIV + 0x0, 0, 0, \"force_reset\" },\n\t{ SIOCIWFIRSTPRIV + 0x1, 0, 0, \"card_reset\" },\n\t{ SIOCIWFIRSTPRIV + 0x2, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_port3\" },\n\t{ SIOCIWFIRSTPRIV + 0x3, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_port3\" },\n\t{ SIOCIWFIRSTPRIV + 0x4, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_preamble\" },\n\t{ SIOCIWFIRSTPRIV + 0x5, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_preamble\" },\n\t{ SIOCIWFIRSTPRIV + 0x6, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_ibssport\" },\n\t{ SIOCIWFIRSTPRIV + 0x7, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_ibssport\" },\n\t{ SIOCIWFIRSTPRIV + 0x9, 0, IW_PRIV_TYPE_BYTE | MAX_RID_LEN,\n\t  \"get_rid\" },\n};\n\n\n/*\n * Structures to export the Wireless Handlers\n */\n\nstatic const iw_handler\torinoco_handler[] = {\n\tIW_HANDLER(SIOCSIWCOMMIT,\t(iw_handler)orinoco_ioctl_commit),\n\tIW_HANDLER(SIOCGIWNAME,\t\t(iw_handler)cfg80211_wext_giwname),\n\tIW_HANDLER(SIOCSIWFREQ,\t\t(iw_handler)orinoco_ioctl_setfreq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\t(iw_handler)orinoco_ioctl_getfreq),\n\tIW_HANDLER(SIOCSIWMODE,\t\t(iw_handler)cfg80211_wext_siwmode),\n\tIW_HANDLER(SIOCGIWMODE,\t\t(iw_handler)cfg80211_wext_giwmode),\n\tIW_HANDLER(SIOCSIWSENS,\t\t(iw_handler)orinoco_ioctl_setsens),\n\tIW_HANDLER(SIOCGIWSENS,\t\t(iw_handler)orinoco_ioctl_getsens),\n\tIW_HANDLER(SIOCGIWRANGE,\t(iw_handler)cfg80211_wext_giwrange),\n\tIW_HANDLER(SIOCSIWSPY,\t\tiw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY,\t\tiw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY,\tiw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY,\tiw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWAP,\t\t(iw_handler)orinoco_ioctl_setwap),\n\tIW_HANDLER(SIOCGIWAP,\t\t(iw_handler)orinoco_ioctl_getwap),\n\tIW_HANDLER(SIOCSIWSCAN,\t\t(iw_handler)cfg80211_wext_siwscan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\t(iw_handler)cfg80211_wext_giwscan),\n\tIW_HANDLER(SIOCSIWESSID,\t(iw_handler)orinoco_ioctl_setessid),\n\tIW_HANDLER(SIOCGIWESSID,\t(iw_handler)orinoco_ioctl_getessid),\n\tIW_HANDLER(SIOCSIWRATE,\t\t(iw_handler)orinoco_ioctl_setrate),\n\tIW_HANDLER(SIOCGIWRATE,\t\t(iw_handler)orinoco_ioctl_getrate),\n\tIW_HANDLER(SIOCSIWRTS,\t\t(iw_handler)cfg80211_wext_siwrts),\n\tIW_HANDLER(SIOCGIWRTS,\t\t(iw_handler)cfg80211_wext_giwrts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\t(iw_handler)cfg80211_wext_siwfrag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\t(iw_handler)cfg80211_wext_giwfrag),\n\tIW_HANDLER(SIOCGIWRETRY,\t(iw_handler)cfg80211_wext_giwretry),\n\tIW_HANDLER(SIOCSIWENCODE,\t(iw_handler)orinoco_ioctl_setiwencode),\n\tIW_HANDLER(SIOCGIWENCODE,\t(iw_handler)orinoco_ioctl_getiwencode),\n\tIW_HANDLER(SIOCSIWPOWER,\t(iw_handler)orinoco_ioctl_setpower),\n\tIW_HANDLER(SIOCGIWPOWER,\t(iw_handler)orinoco_ioctl_getpower),\n\tIW_HANDLER(SIOCSIWGENIE,\torinoco_ioctl_set_genie),\n\tIW_HANDLER(SIOCGIWGENIE,\torinoco_ioctl_get_genie),\n\tIW_HANDLER(SIOCSIWMLME,\t\torinoco_ioctl_set_mlme),\n\tIW_HANDLER(SIOCSIWAUTH,\t\torinoco_ioctl_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH,\t\torinoco_ioctl_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT,\torinoco_ioctl_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT,\torinoco_ioctl_get_encodeext),\n};\n\n\n/*\n  Added typecasting since we no longer use iwreq_data -- Moustafa\n */\nstatic const iw_handler\torinoco_private_handler[] = {\n\t[0] = (iw_handler)orinoco_ioctl_reset,\n\t[1] = (iw_handler)orinoco_ioctl_reset,\n\t[2] = (iw_handler)orinoco_ioctl_setport3,\n\t[3] = (iw_handler)orinoco_ioctl_getport3,\n\t[4] = (iw_handler)orinoco_ioctl_setpreamble,\n\t[5] = (iw_handler)orinoco_ioctl_getpreamble,\n\t[6] = (iw_handler)orinoco_ioctl_setibssport,\n\t[7] = (iw_handler)orinoco_ioctl_getibssport,\n\t[9] = (iw_handler)orinoco_ioctl_getrid,\n};\n\nconst struct iw_handler_def orinoco_handler_def = {\n\t.num_standard = ARRAY_SIZE(orinoco_handler),\n\t.num_private = ARRAY_SIZE(orinoco_private_handler),\n\t.num_private_args = ARRAY_SIZE(orinoco_privtab),\n\t.standard = orinoco_handler,\n\t.private = orinoco_private_handler,\n\t.private_args = orinoco_privtab,\n\t.get_wireless_stats = orinoco_get_wireless_stats,\n};\n"], "fixing_code": ["/* Wireless extensions support.\n *\n * See copyright notice in main.c\n */\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/wireless.h>\n#include <linux/ieee80211.h>\n#include <net/iw_handler.h>\n#include <net/cfg80211.h>\n\n#include \"hermes.h\"\n#include \"hermes_rid.h\"\n#include \"orinoco.h\"\n\n#include \"hw.h\"\n#include \"mic.h\"\n#include \"scan.h\"\n#include \"main.h\"\n\n#include \"wext.h\"\n\n#define MAX_RID_LEN 1024\n\n/* Helper routine to record keys\n * It is called under orinoco_lock so it may not sleep */\nstatic int orinoco_set_key(struct orinoco_private *priv, int index,\n\t\t\t   enum orinoco_alg alg, const u8 *key, int key_len,\n\t\t\t   const u8 *seq, int seq_len)\n{\n\tkzfree(priv->keys[index].key);\n\tkzfree(priv->keys[index].seq);\n\n\tif (key_len) {\n\t\tpriv->keys[index].key = kzalloc(key_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].key)\n\t\t\tgoto nomem;\n\t} else\n\t\tpriv->keys[index].key = NULL;\n\n\tif (seq_len) {\n\t\tpriv->keys[index].seq = kzalloc(seq_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].seq)\n\t\t\tgoto free_key;\n\t} else\n\t\tpriv->keys[index].seq = NULL;\n\n\tpriv->keys[index].key_len = key_len;\n\tpriv->keys[index].seq_len = seq_len;\n\n\tif (key_len)\n\t\tmemcpy(priv->keys[index].key, key, key_len);\n\tif (seq_len)\n\t\tmemcpy(priv->keys[index].seq, seq, seq_len);\n\n\tswitch (alg) {\n\tcase ORINOCO_ALG_TKIP:\n\t\tpriv->keys[index].cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_WEP:\n\t\tpriv->keys[index].cipher = (key_len > SMALL_KEY_SIZE) ?\n\t\t\tWLAN_CIPHER_SUITE_WEP104 : WLAN_CIPHER_SUITE_WEP40;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_NONE:\n\tdefault:\n\t\tpriv->keys[index].cipher = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nfree_key:\n\tkfree(priv->keys[index].key);\n\tpriv->keys[index].key = NULL;\n\nnomem:\n\tpriv->keys[index].key_len = 0;\n\tpriv->keys[index].seq_len = 0;\n\tpriv->keys[index].cipher = 0;\n\n\treturn -ENOMEM;\n}\n\nstatic struct iw_statistics *orinoco_get_wireless_stats(struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_statistics *wstats = &priv->wstats;\n\tint err;\n\tunsigned long flags;\n\n\tif (!netif_device_present(dev)) {\n\t\tprintk(KERN_WARNING \"%s: get_wireless_stats() called while device not present\\n\",\n\t\t       dev->name);\n\t\treturn NULL; /* FIXME: Can we do better than this? */\n\t}\n\n\t/* If busy, return the old stats.  Returning NULL may cause\n\t * the interface to disappear from /proc/net/wireless */\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn wstats;\n\n\t/* We can't really wait for the tallies inquiry command to\n\t * complete, so we just use the previous results and trigger\n\t * a new tallies inquiry command for next time - Jean II */\n\t/* FIXME: Really we should wait for the inquiry to come back -\n\t * as it is the stats we give don't make a whole lot of sense.\n\t * Unfortunately, it's not clear how to do that within the\n\t * wireless extensions framework: I think we're in user\n\t * context, but a lock seems to be held by the time we get in\n\t * here so we're not safe to sleep here. */\n\thermes_inquire(hw, HERMES_INQ_TALLIES);\n\n\tif (priv->iw_mode == NL80211_IFTYPE_ADHOC) {\n\t\tmemset(&wstats->qual, 0, sizeof(wstats->qual));\n\t\t/* If a spy address is defined, we report stats of the\n\t\t * first spy address - Jean II */\n\t\tif (SPY_NUMBER(priv)) {\n\t\t\twstats->qual.qual = priv->spy_data.spy_stat[0].qual;\n\t\t\twstats->qual.level = priv->spy_data.spy_stat[0].level;\n\t\t\twstats->qual.noise = priv->spy_data.spy_stat[0].noise;\n\t\t\twstats->qual.updated =\n\t\t\t\tpriv->spy_data.spy_stat[0].updated;\n\t\t}\n\t} else {\n\t\tstruct {\n\t\t\t__le16 qual, signal, noise, unused;\n\t\t} __packed cq;\n\n\t\terr = HERMES_READ_RECORD(hw, USER_BAP,\n\t\t\t\t\t HERMES_RID_COMMSQUALITY, &cq);\n\n\t\tif (!err) {\n\t\t\twstats->qual.qual = (int)le16_to_cpu(cq.qual);\n\t\t\twstats->qual.level = (int)le16_to_cpu(cq.signal) - 0x95;\n\t\t\twstats->qual.noise = (int)le16_to_cpu(cq.noise) - 0x95;\n\t\t\twstats->qual.updated =\n\t\t\t\tIW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t\t}\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn wstats;\n}\n\n/********************************************************************/\n/* Wireless extensions                                              */\n/********************************************************************/\n\nstatic int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\tunsigned long flags;\n\tstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* Enable automatic roaming - no sanity checks are needed */\n\tif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\n\t    memcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\n\t\tpriv->bssid_fixed = 0;\n\t\tmemset(priv->desired_bssid, 0, ETH_ALEN);\n\n\t\t/* \"off\" means keep existing connection */\n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* Intersil firmware hangs without Desired ESSID */\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* Finally, enable manual roaming */\n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tap_addr->sa_family = ARPHRD_ETHER;\n\terr = orinoco_hw_get_current_bssid(priv, ap_addr->sa_data);\n\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_setiwencode(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     struct iw_point *erq,\n\t\t\t\t     char *keybuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint index = (erq->flags & IW_ENCODE_INDEX) - 1;\n\tint setindex = priv->tx_key;\n\tenum orinoco_alg encode_alg = priv->encode_alg;\n\tint restricted = priv->wep_restrict;\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\tunsigned long flags;\n\n\tif (!priv->has_wep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (erq->pointer) {\n\t\t/* We actually have a key to set - check its length */\n\t\tif (erq->length > LARGE_KEY_SIZE)\n\t\t\treturn -E2BIG;\n\n\t\tif ((erq->length > SMALL_KEY_SIZE) && !priv->has_big_wep)\n\t\t\treturn -E2BIG;\n\t}\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* Clear any TKIP key we have */\n\tif ((priv->has_wpa) && (priv->encode_alg == ORINOCO_ALG_TKIP))\n\t\t(void) orinoco_clear_tkip_key(priv, setindex);\n\n\tif (erq->length > 0) {\n\t\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\n\t\t\tindex = priv->tx_key;\n\n\t\t/* Switch on WEP if off */\n\t\tif (encode_alg != ORINOCO_ALG_WEP) {\n\t\t\tsetindex = index;\n\t\t\tencode_alg = ORINOCO_ALG_WEP;\n\t\t}\n\t} else {\n\t\t/* Important note : if the user do \"iwconfig eth0 enc off\",\n\t\t * we will arrive there with an index of -1. This is valid\n\t\t * but need to be taken care off... Jean II */\n\t\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS)) {\n\t\t\tif ((index != -1) || (erq->flags == 0)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Set the index : Check that the key is valid */\n\t\t\tif (priv->keys[index].key_len == 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsetindex = index;\n\t\t}\n\t}\n\n\tif (erq->flags & IW_ENCODE_DISABLED)\n\t\tencode_alg = ORINOCO_ALG_NONE;\n\tif (erq->flags & IW_ENCODE_OPEN)\n\t\trestricted = 0;\n\tif (erq->flags & IW_ENCODE_RESTRICTED)\n\t\trestricted = 1;\n\n\tif (erq->pointer && erq->length > 0) {\n\t\terr = orinoco_set_key(priv, index, ORINOCO_ALG_WEP, keybuf,\n\t\t\t\t      erq->length, NULL, 0);\n\t}\n\tpriv->tx_key = setindex;\n\n\t/* Try fast key change if connected and only keys are changed */\n\tif ((priv->encode_alg == encode_alg) &&\n\t    (priv->wep_restrict == restricted) &&\n\t    netif_carrier_ok(dev)) {\n\t\terr = __orinoco_hw_setup_wepkeys(priv);\n\t\t/* No need to commit if successful */\n\t\tgoto out;\n\t}\n\n\tpriv->encode_alg = encode_alg;\n\tpriv->wep_restrict = restricted;\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getiwencode(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     struct iw_point *erq,\n\t\t\t\t     char *keybuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint index = (erq->flags & IW_ENCODE_INDEX) - 1;\n\tunsigned long flags;\n\n\tif (!priv->has_wep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\n\t\tindex = priv->tx_key;\n\n\terq->flags = 0;\n\tif (!priv->encode_alg)\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\terq->flags |= index + 1;\n\n\tif (priv->wep_restrict)\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\telse\n\t\terq->flags |= IW_ENCODE_OPEN;\n\n\terq->length = priv->keys[index].key_len;\n\n\tmemcpy(keybuf, priv->keys[index].key, erq->length);\n\n\torinoco_unlock(priv, &flags);\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\n\t/* Note : ESSID is ignored in Ad-Hoc demo mode, but we can set it\n\t * anyway... - Jean II */\n\n\t/* Hum... Should not use Wireless Extension constant (may change),\n\t * should use our own... - Jean II */\n\tif (erq->length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* NULL the string (for NULL termination & ESSID = ANY) - Jean II */\n\tmemset(priv->desired_essid, 0, sizeof(priv->desired_essid));\n\n\t/* If not ANY, get the new ESSID */\n\tif (erq->flags)\n\t\tmemcpy(priv->desired_essid, essidbuf, erq->length);\n\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\n\terq->flags = 1;\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_freq *frq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint chan = -1;\n\tunsigned long flags;\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\n\t/* In infrastructure mode the AP sets the channel */\n\tif (priv->iw_mode == NL80211_IFTYPE_STATION)\n\t\treturn -EBUSY;\n\n\tif ((frq->e == 0) && (frq->m <= 1000)) {\n\t\t/* Setting by channel number */\n\t\tchan = frq->m;\n\t} else {\n\t\t/* Setting by frequency */\n\t\tint denom = 1;\n\t\tint i;\n\n\t\t/* Calculate denominator to rescale to MHz */\n\t\tfor (i = 0; i < (6 - frq->e); i++)\n\t\t\tdenom *= 10;\n\n\t\tchan = ieee80211_freq_to_dsss_chan(frq->m / denom);\n\t}\n\n\tif ((chan < 1) || (chan > NUM_CHANNELS) ||\n\t     !(priv->channel_mask & (1 << (chan-1))))\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tpriv->channel = chan;\n\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR) {\n\t\t/* Fast channel change - no commit if successful */\n\t\thermes_t *hw = &priv->hw;\n\t\terr = hw->ops->cmd_wait(hw, HERMES_CMD_TEST |\n\t\t\t\t\t    HERMES_TEST_SET_CHANNEL,\n\t\t\t\t\tchan, NULL);\n\t}\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_freq *frq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint tmp;\n\n\t/* Locking done in there */\n\ttmp = orinoco_hw_get_freq(priv);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\tfrq->m = tmp * 100000;\n\tfrq->e = 1;\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_getsens(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *srq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tu16 val;\n\tint err;\n\tunsigned long flags;\n\n\tif (!priv->has_sensitivity)\n\t\treturn -EOPNOTSUPP;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFSYSTEMSCALE, &val);\n\torinoco_unlock(priv, &flags);\n\n\tif (err)\n\t\treturn err;\n\n\tsrq->value = val;\n\tsrq->fixed = 0; /* auto */\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setsens(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *srq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = srq->value;\n\tunsigned long flags;\n\n\tif (!priv->has_sensitivity)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((val < 1) || (val > 3))\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->ap_density = val;\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_setrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint ratemode;\n\tint bitrate; /* 100s of kilobits */\n\tunsigned long flags;\n\n\t/* As the user space doesn't know our highest rate, it uses -1\n\t * to ask us to set the highest rate.  Test it using \"iwconfig\n\t * ethX rate auto\" - Jean II */\n\tif (rrq->value == -1)\n\t\tbitrate = 110;\n\telse {\n\t\tif (rrq->value % 100000)\n\t\t\treturn -EINVAL;\n\t\tbitrate = rrq->value / 100000;\n\t}\n\n\tratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\n\n\tif (ratemode == -1)\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->bitratemode = ratemode;\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int orinoco_ioctl_getrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = 0;\n\tint bitrate, automatic;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\torinoco_get_ratemode_cfg(priv->bitratemode, &bitrate, &automatic);\n\n\t/* If the interface is running we try to find more about the\n\t   current mode */\n\tif (netif_running(dev)) {\n\t\tint act_bitrate;\n\t\tint lerr;\n\n\t\t/* Ignore errors if we can't get the actual bitrate */\n\t\tlerr = orinoco_hw_get_act_bitrate(priv, &act_bitrate);\n\t\tif (!lerr)\n\t\t\tbitrate = act_bitrate;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\n\trrq->value = bitrate;\n\trrq->fixed = !automatic;\n\trrq->disabled = 0;\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_setpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t/* Call commit handler */\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif (prq->disabled) {\n\t\tpriv->pm_on = 0;\n\t} else {\n\t\tswitch (prq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tpriv->pm_mcast = 0;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tpriv->pm_mcast = 1;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\t/* No flags : but we may have a value - Jean II */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (prq->flags & IW_POWER_TIMEOUT) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_timeout = prq->value / 1000;\n\t\t}\n\t\tif (prq->flags & IW_POWER_PERIOD) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_period = prq->value / 1000;\n\t\t}\n\t\t/* It's valid to not have a value if we are just toggling\n\t\t * the flags... Jean II */\n\t\tif (!priv->pm_on) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tint err = 0;\n\tu16 enable, period, timeout, mcast;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFPMENABLED, &enable);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFMAXSLEEPDURATION, &period);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFPMHOLDOVERDURATION, &timeout);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFMULTICASTRECEIVE, &mcast);\n\tif (err)\n\t\tgoto out;\n\n\tprq->disabled = !enable;\n\t/* Note : by default, display the period */\n\tif ((prq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tprq->flags = IW_POWER_TIMEOUT;\n\t\tprq->value = timeout * 1000;\n\t} else {\n\t\tprq->flags = IW_POWER_PERIOD;\n\t\tprq->value = period * 1000;\n\t}\n\tif (mcast)\n\t\tprq->flags |= IW_POWER_ALL_R;\n\telse\n\t\tprq->flags |= IW_POWER_UNICAST_R;\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_encodeext(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu,\n\t\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, alg = ext->alg, set_key = 1;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t/* Determine and validate the key index */\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif ((idx < 1) || (idx > 4))\n\t\t\tgoto out;\n\t\tidx--;\n\t} else\n\t\tidx = priv->tx_key;\n\n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t\talg = IW_ENCODE_ALG_NONE;\n\n\tif (priv->has_wpa && (alg != IW_ENCODE_ALG_TKIP)) {\n\t\t/* Clear any TKIP TX key we had */\n\t\t(void) orinoco_clear_tkip_key(priv, priv->tx_key);\n\t}\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tpriv->tx_key = idx;\n\t\tset_key = ((alg == IW_ENCODE_ALG_TKIP) ||\n\t\t\t   (ext->key_len > 0)) ? 1 : 0;\n\t}\n\n\tif (set_key) {\n\t\t/* Set the requested key first */\n\t\tswitch (alg) {\n\t\tcase IW_ENCODE_ALG_NONE:\n\t\t\tpriv->encode_alg = ORINOCO_ALG_NONE;\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_NONE,\n\t\t\t\t\t      NULL, 0, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase IW_ENCODE_ALG_WEP:\n\t\t\tif (ext->key_len <= 0)\n\t\t\t\tgoto out;\n\n\t\t\tpriv->encode_alg = ORINOCO_ALG_WEP;\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_WEP,\n\t\t\t\t\t      ext->key, ext->key_len, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase IW_ENCODE_ALG_TKIP:\n\t\t{\n\t\t\tu8 *tkip_iv = NULL;\n\n\t\t\tif (!priv->has_wpa ||\n\t\t\t    (ext->key_len > sizeof(struct orinoco_tkip_key)))\n\t\t\t\tgoto out;\n\n\t\t\tpriv->encode_alg = ORINOCO_ALG_TKIP;\n\n\t\t\tif (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)\n\t\t\t\ttkip_iv = &ext->rx_seq[0];\n\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_TKIP,\n\t\t\t\t\t      ext->key, ext->key_len, tkip_iv,\n\t\t\t\t\t      ORINOCO_SEQ_LEN);\n\n\t\t\terr = __orinoco_hw_set_tkip_key(priv, idx,\n\t\t\t\t ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY,\n\t\t\t\t priv->keys[idx].key,\n\t\t\t\t tkip_iv, ORINOCO_SEQ_LEN, NULL, 0);\n\t\t\tif (err)\n\t\t\t\tprintk(KERN_ERR \"%s: Error %d setting TKIP key\"\n\t\t\t\t       \"\\n\", dev->name, err);\n\n\t\t\tgoto out;\n\t\t}\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = -EINPROGRESS;\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_get_encodeext(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu,\n\t\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, max_key_len;\n\tunsigned long flags;\n\tint err;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = -EINVAL;\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\tgoto out;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif ((idx < 1) || (idx > 4))\n\t\t\tgoto out;\n\t\tidx--;\n\t} else\n\t\tidx = priv->tx_key;\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tswitch (priv->encode_alg) {\n\tcase ORINOCO_ALG_NONE:\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\text->key_len = 0;\n\t\tencoding->flags |= IW_ENCODE_DISABLED;\n\t\tbreak;\n\tcase ORINOCO_ALG_WEP:\n\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\text->key_len = min(priv->keys[idx].key_len, max_key_len);\n\t\tmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\tcase ORINOCO_ALG_TKIP:\n\t\text->alg = IW_ENCODE_ALG_TKIP;\n\t\text->key_len = min(priv->keys[idx].key_len, max_key_len);\n\t\tmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\t}\n\n\terr = 0;\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\t/*\n\t\t * orinoco does not use these parameters\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_KEY_MGMT:\n\t\t/* wl_lkm implies value 2 == PSK for Hermes I\n\t\t * which ties in with WEXT\n\t\t * no other hints tho :(\n\t\t */\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\t/* When countermeasures are enabled, shut down the\n\t\t * card; when disabled, re-enable the card. This must\n\t\t * take effect immediately.\n\t\t *\n\t\t * TODO: Make sure that the EAPOL message is getting\n\t\t *       out before card disabled\n\t\t */\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t/* else silently accept disable of WPA */\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_get_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_KEY_MGMT:\n\t\tparam->value = priv->key_mgmt;\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tparam->value = priv->tkip_cm_active;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (priv->wep_restrict)\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\telse\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = priv->wpa_enabled;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_set_genie(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tu8 *buf;\n\tunsigned long flags;\n\n\t/* cut off at IEEE80211_MAX_DATA_LEN */\n\tif ((wrqu->data.length > IEEE80211_MAX_DATA_LEN) ||\n\t    (wrqu->data.length && (extra == NULL)))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuf = NULL;\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\tkfree(buf);\n\t\treturn -EBUSY;\n\t}\n\n\tkfree(priv->wpa_ie);\n\tpriv->wpa_ie = buf;\n\tpriv->wpa_ie_len = wrqu->data.length;\n\n\tif (priv->wpa_ie) {\n\t\t/* Looks like wl_lkm wants to check the auth alg, and\n\t\t * somehow pass it to the firmware.\n\t\t * Instead it just calls the key mgmt rid\n\t\t *   - we do this in set auth.\n\t\t */\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_get_genie(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif ((priv->wpa_ie_len == 0) || (priv->wpa_ie == NULL)) {\n\t\twrqu->data.length = 0;\n\t\tgoto out;\n\t}\n\n\tif (wrqu->data.length < priv->wpa_ie_len) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\n\twrqu->data.length = priv->wpa_ie_len;\n\tmemcpy(extra, priv->wpa_ie, priv->wpa_ie_len);\n\nout:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_mlme(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\t/* silently ignore */\n\t\tbreak;\n\n\tcase IW_MLME_DISASSOC:\n\n\t\tret = orinoco_hw_disassociate(priv, mlme->addr.sa_data,\n\t\t\t\t\t      mlme->reason_code);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_reset(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       void *wrqu,\n\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (info->cmd == (SIOCIWFIRSTPRIV + 0x1)) {\n\t\tprintk(KERN_DEBUG \"%s: Forcing reset!\\n\", dev->name);\n\n\t\t/* Firmware reset */\n\t\torinoco_reset(&priv->reset_work);\n\t} else {\n\t\tprintk(KERN_DEBUG \"%s: Force scheduling reset!\\n\", dev->name);\n\n\t\tschedule_work(&priv->reset_work);\n\t}\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setibssport(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = *((int *) extra);\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tpriv->ibss_port = val;\n\n\t/* Actually update the mode we are using */\n\tset_port_type(priv);\n\n\torinoco_unlock(priv, &flags);\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_getibssport(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\t*val = priv->ibss_port;\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setport3(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  void *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = *((int *) extra);\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (val) {\n\tcase 0: /* Try to do IEEE ad-hoc mode */\n\t\tif (!priv->has_ibss) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 0;\n\n\t\tbreak;\n\n\tcase 1: /* Try to do Lucent proprietary ad-hoc mode */\n\t\tif (!priv->has_port3) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 1;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tif (!err) {\n\t\t/* Actually update the mode we are using */\n\t\tset_port_type(priv);\n\t\terr = -EINPROGRESS;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getport3(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  void *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\t*val = priv->prefer_port3;\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setpreamble(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint val;\n\n\tif (!priv->has_preamble)\n\t\treturn -EOPNOTSUPP;\n\n\t/* 802.11b has recently defined some short preamble.\n\t * Basically, the Phy header has been reduced in size.\n\t * This increase performance, especially at high rates\n\t * (the preamble is transmitted at 1Mb/s), unfortunately\n\t * this give compatibility troubles... - Jean II */\n\tval = *((int *) extra);\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif (val)\n\t\tpriv->preamble = 1;\n\telse\n\t\tpriv->preamble = 0;\n\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\nstatic int orinoco_ioctl_getpreamble(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\tif (!priv->has_preamble)\n\t\treturn -EOPNOTSUPP;\n\n\t*val = priv->preamble;\n\treturn 0;\n}\n\n/* ioctl interface to hermes_read_ltv()\n * To use with iwpriv, pass the RID as the token argument, e.g.\n * iwpriv get_rid [0xfc00]\n * At least Wireless Tools 25 is required to use iwpriv.\n * For Wireless Tools 25 and 26 append \"dummy\" are the end. */\nstatic int orinoco_ioctl_getrid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct iw_point *data,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tint rid = data->flags;\n\tu16 length;\n\tint err;\n\tunsigned long flags;\n\n\t/* It's a \"get\" function, but we don't want users to access the\n\t * WEP key and other raw firmware data */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (rid < 0xfc00 || rid > 0xffff)\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, rid, MAX_RID_LEN, &length,\n\t\t\t\textra);\n\tif (err)\n\t\tgoto out;\n\n\tdata->length = min_t(u16, HERMES_RECLEN_TO_BYTES(length),\n\t\t\t     MAX_RID_LEN);\n\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\n\n/* Commit handler, called after set operations */\nstatic int orinoco_ioctl_commit(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tvoid *wrqu,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (!priv->open)\n\t\treturn 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn err;\n\n\terr = orinoco_commit(priv);\n\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic const struct iw_priv_args orinoco_privtab[] = {\n\t{ SIOCIWFIRSTPRIV + 0x0, 0, 0, \"force_reset\" },\n\t{ SIOCIWFIRSTPRIV + 0x1, 0, 0, \"card_reset\" },\n\t{ SIOCIWFIRSTPRIV + 0x2, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_port3\" },\n\t{ SIOCIWFIRSTPRIV + 0x3, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_port3\" },\n\t{ SIOCIWFIRSTPRIV + 0x4, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_preamble\" },\n\t{ SIOCIWFIRSTPRIV + 0x5, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_preamble\" },\n\t{ SIOCIWFIRSTPRIV + 0x6, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_ibssport\" },\n\t{ SIOCIWFIRSTPRIV + 0x7, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_ibssport\" },\n\t{ SIOCIWFIRSTPRIV + 0x9, 0, IW_PRIV_TYPE_BYTE | MAX_RID_LEN,\n\t  \"get_rid\" },\n};\n\n\n/*\n * Structures to export the Wireless Handlers\n */\n\nstatic const iw_handler\torinoco_handler[] = {\n\tIW_HANDLER(SIOCSIWCOMMIT,\t(iw_handler)orinoco_ioctl_commit),\n\tIW_HANDLER(SIOCGIWNAME,\t\t(iw_handler)cfg80211_wext_giwname),\n\tIW_HANDLER(SIOCSIWFREQ,\t\t(iw_handler)orinoco_ioctl_setfreq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\t(iw_handler)orinoco_ioctl_getfreq),\n\tIW_HANDLER(SIOCSIWMODE,\t\t(iw_handler)cfg80211_wext_siwmode),\n\tIW_HANDLER(SIOCGIWMODE,\t\t(iw_handler)cfg80211_wext_giwmode),\n\tIW_HANDLER(SIOCSIWSENS,\t\t(iw_handler)orinoco_ioctl_setsens),\n\tIW_HANDLER(SIOCGIWSENS,\t\t(iw_handler)orinoco_ioctl_getsens),\n\tIW_HANDLER(SIOCGIWRANGE,\t(iw_handler)cfg80211_wext_giwrange),\n\tIW_HANDLER(SIOCSIWSPY,\t\tiw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY,\t\tiw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY,\tiw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY,\tiw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWAP,\t\t(iw_handler)orinoco_ioctl_setwap),\n\tIW_HANDLER(SIOCGIWAP,\t\t(iw_handler)orinoco_ioctl_getwap),\n\tIW_HANDLER(SIOCSIWSCAN,\t\t(iw_handler)cfg80211_wext_siwscan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\t(iw_handler)cfg80211_wext_giwscan),\n\tIW_HANDLER(SIOCSIWESSID,\t(iw_handler)orinoco_ioctl_setessid),\n\tIW_HANDLER(SIOCGIWESSID,\t(iw_handler)orinoco_ioctl_getessid),\n\tIW_HANDLER(SIOCSIWRATE,\t\t(iw_handler)orinoco_ioctl_setrate),\n\tIW_HANDLER(SIOCGIWRATE,\t\t(iw_handler)orinoco_ioctl_getrate),\n\tIW_HANDLER(SIOCSIWRTS,\t\t(iw_handler)cfg80211_wext_siwrts),\n\tIW_HANDLER(SIOCGIWRTS,\t\t(iw_handler)cfg80211_wext_giwrts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\t(iw_handler)cfg80211_wext_siwfrag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\t(iw_handler)cfg80211_wext_giwfrag),\n\tIW_HANDLER(SIOCGIWRETRY,\t(iw_handler)cfg80211_wext_giwretry),\n\tIW_HANDLER(SIOCSIWENCODE,\t(iw_handler)orinoco_ioctl_setiwencode),\n\tIW_HANDLER(SIOCGIWENCODE,\t(iw_handler)orinoco_ioctl_getiwencode),\n\tIW_HANDLER(SIOCSIWPOWER,\t(iw_handler)orinoco_ioctl_setpower),\n\tIW_HANDLER(SIOCGIWPOWER,\t(iw_handler)orinoco_ioctl_getpower),\n\tIW_HANDLER(SIOCSIWGENIE,\torinoco_ioctl_set_genie),\n\tIW_HANDLER(SIOCGIWGENIE,\torinoco_ioctl_get_genie),\n\tIW_HANDLER(SIOCSIWMLME,\t\torinoco_ioctl_set_mlme),\n\tIW_HANDLER(SIOCSIWAUTH,\t\torinoco_ioctl_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH,\t\torinoco_ioctl_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT,\torinoco_ioctl_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT,\torinoco_ioctl_get_encodeext),\n};\n\n\n/*\n  Added typecasting since we no longer use iwreq_data -- Moustafa\n */\nstatic const iw_handler\torinoco_private_handler[] = {\n\t[0] = (iw_handler)orinoco_ioctl_reset,\n\t[1] = (iw_handler)orinoco_ioctl_reset,\n\t[2] = (iw_handler)orinoco_ioctl_setport3,\n\t[3] = (iw_handler)orinoco_ioctl_getport3,\n\t[4] = (iw_handler)orinoco_ioctl_setpreamble,\n\t[5] = (iw_handler)orinoco_ioctl_getpreamble,\n\t[6] = (iw_handler)orinoco_ioctl_setibssport,\n\t[7] = (iw_handler)orinoco_ioctl_getibssport,\n\t[9] = (iw_handler)orinoco_ioctl_getrid,\n};\n\nconst struct iw_handler_def orinoco_handler_def = {\n\t.num_standard = ARRAY_SIZE(orinoco_handler),\n\t.num_private = ARRAY_SIZE(orinoco_private_handler),\n\t.num_private_args = ARRAY_SIZE(orinoco_privtab),\n\t.standard = orinoco_handler,\n\t.private = orinoco_private_handler,\n\t.private_args = orinoco_privtab,\n\t.get_wireless_stats = orinoco_get_wireless_stats,\n};\n"], "filenames": ["drivers/net/wireless/orinoco/wext.c"], "buggy_code_start_loc": [914], "buggy_code_end_loc": [918], "fixing_code_start_loc": [914], "fixing_code_end_loc": [918], "type": "NVD-CWE-noinfo", "message": "The orinoco_ioctl_set_auth function in drivers/net/wireless/orinoco/wext.c in the Linux kernel before 2.6.37 does not properly implement a TKIP protection mechanism, which makes it easier for remote attackers to obtain access to a Wi-Fi network by reading Wi-Fi frames.", "other": {"cve": {"id": "CVE-2010-4648", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:01.693", "lastModified": "2023-02-13T03:20:33.853", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The orinoco_ioctl_set_auth function in drivers/net/wireless/orinoco/wext.c in the Linux kernel before 2.6.37 does not properly implement a TKIP protection mechanism, which makes it easier for remote attackers to obtain access to a Wi-Fi network by reading Wi-Fi frames."}, {"lang": "es", "value": "La funci\u00f3n de orinoco_ioctl_set_auth en drivers/net/wireless/orinoco/wext.c en el kernel de Linux en vesiones anteriores a la v2.6.37 no implementa un mecanismo de protecci\u00f3n TKIP, lo que facilita a los atacantes remotos a la hora de obtener acceso a una red Wi-Fi mediante la lectura de frames Wi-Fi."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 6.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.36.4", "matchCriteriaId": "C03086A2-8EEE-40E3-9A7F-A5303FBF0472"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.1:*:*:*:*:*:*:*", "matchCriteriaId": "907A3F7F-B11D-4CF1-A1B2-A28BBEBF03C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.2:*:*:*:*:*:*:*", "matchCriteriaId": "EE4657B8-B691-4833-8546-220AD2BA8A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.3:*:*:*:*:*:*:*", "matchCriteriaId": "A2455F37-66D8-4BE1-8739-1A20A2E5375D"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.37", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=0a54917c3fc295cb61f3fb52373c173fd3b69f48", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/01/06/18", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=667907", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/0a54917c3fc295cb61f3fb52373c173fd3b69f48", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0a54917c3fc295cb61f3fb52373c173fd3b69f48"}}