{"buggy_code": ["/*\n * lxc: linux Container library\n *\n * (C) Copyright IBM Corp. 2007, 2008\n *\n * Authors:\n * Daniel Lezcano <daniel.lezcano at free.fr>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <sys/param.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n#include <linux/unistd.h>\n#include <pwd.h>\n\n#ifndef HAVE_DECL_PR_CAPBSET_DROP\n#define PR_CAPBSET_DROP 24\n#endif\n\n#ifndef HAVE_DECL_PR_SET_NO_NEW_PRIVS\n#define PR_SET_NO_NEW_PRIVS 38\n#endif\n\n#ifndef HAVE_DECL_PR_GET_NO_NEW_PRIVS\n#define PR_GET_NO_NEW_PRIVS 39\n#endif\n\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"attach.h\"\n#include \"caps.h\"\n#include \"config.h\"\n#include \"utils.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"lxclock.h\"\n#include \"conf.h\"\n#include \"lxcseccomp.h\"\n#include <lxc/lxccontainer.h>\n#include \"lsm/lsm.h\"\n#include \"confile.h\"\n\n#if HAVE_SYS_PERSONALITY_H\n#include <sys/personality.h>\n#endif\n\n#ifndef SOCK_CLOEXEC\n#  define SOCK_CLOEXEC                02000000\n#endif\n\n#ifndef MS_REC\n#define MS_REC 16384\n#endif\n\n#ifndef MS_SLAVE\n#define MS_SLAVE (1<<19)\n#endif\n\nlxc_log_define(lxc_attach, lxc);\n\nint lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {\n\tint labelfd = -1;\n\tint ret = 0;\n\tconst char* name;\n\tchar* command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\tgoto out;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\tgoto out;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec) {\n\t\tlabelfd = openat(procfd, \"self/attr/exec\", O_RDWR);\n\t}\n\telse {\n\t\tlabelfd = openat(procfd, \"self/attr/current\", O_RDWR);\n\t}\n\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open LSM label\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\telse if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\telse {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tfree(command);\n\n\tif (labelfd != -1)\n\t\tclose(labelfd);\n\n\treturn ret;\n}\n\nstatic struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n{\n\tstruct lxc_proc_context_info *info = calloc(1, sizeof(*info));\n\tFILE *proc_file;\n\tchar proc_fn[MAXPATHLEN];\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tint ret, found;\n\n\tif (!info) {\n\t\tSYSERROR(\"Could not allocate memory.\");\n\t\treturn NULL;\n\t}\n\n\t/* read capabilities */\n\tsnprintf(proc_fn, MAXPATHLEN, \"/proc/%d/status\", pid);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file) {\n\t\tSYSERROR(\"Could not open %s\", proc_fn);\n\t\tgoto out_error;\n\t}\n\n\tfound = 0;\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\tret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);\n\t\tif (ret != EOF && ret > 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(proc_file);\n\n\tif (!found) {\n\t\tSYSERROR(\"Could not read capability bounding set from %s\", proc_fn);\n\t\terrno = ENOENT;\n\t\tgoto out_error;\n\t}\n\n\tinfo->lsm_label = lsm_process_label_get(pid);\n\n\treturn info;\n\nout_error:\n\tfree(info);\n\treturn NULL;\n}\n\nstatic void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}\n\nstatic int lxc_attach_to_ns(pid_t pid, int which)\n{\n\tint fd[LXC_NS_MAX];\n\tint i, j, saved_errno;\n\n\n\tif (access(\"/proc/self/ns\", X_OK)) {\n\t\tERROR(\"Does this kernel version support 'attach' ?\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\t/* ignore if we are not supposed to attach to that\n\t\t * namespace\n\t\t */\n\t\tif (which != -1 && !(which & ns_info[i].clone_flag)) {\n\t\t\tfd[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (fd[i] < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\t/* close all already opened file descriptors before\n\t\t\t * we return an error, so we don't leak them\n\t\t\t */\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"failed to open namespace: '%s'.\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(fd[i], 0) < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\tfor (j = i; j < LXC_NS_MAX; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to attach to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"Attached to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\n\t\tclose(fd[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int lxc_attach_remount_sys_proc(void)\n{\n\tint ret;\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\treturn -1;\n\t}\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\t/* assume /proc is always mounted, so remount it */\n\tret = umount2(\"/proc\", MNT_DETACH);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to unmount /proc\");\n\t\treturn -1;\n\t}\n\n\tret = mount(\"none\", \"/proc\", \"proc\", 0, NULL);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to remount /proc\");\n\t\treturn -1;\n\t}\n\n\t/* try to umount /sys - if it's not a mount point,\n\t * we'll get EINVAL, then we ignore it because it\n\t * may not have been mounted in the first place\n\t */\n\tret = umount2(\"/sys\", MNT_DETACH);\n\tif (ret < 0 && errno != EINVAL) {\n\t\tSYSERROR(\"failed to unmount /sys\");\n\t\treturn -1;\n\t} else if (ret == 0) {\n\t\t/* remount it */\n\t\tret = mount(\"none\", \"/sys\", \"sysfs\", 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"failed to remount /sys\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lxc_attach_drop_privs(struct lxc_proc_context_info *ctx)\n{\n\tint last_cap = lxc_caps_last_cap();\n\tint cap;\n\n\tfor (cap = 0; cap <= last_cap; cap++) {\n\t\tif (ctx->capability_mask & (1LL << cap))\n\t\t\tcontinue;\n\n\t\tif (prctl(PR_CAPBSET_DROP, cap, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove capability id %d\", cap);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy, char** extra_env, char** extra_keep)\n{\n\tif (policy == LXC_ATTACH_CLEAR_ENV) {\n\t\tchar **extra_keep_store = NULL;\n\t\tint path_kept = 0;\n\n\t\tif (extra_keep) {\n\t\t\tsize_t count, i;\n\n\t\t\tfor (count = 0; extra_keep[count]; count++);\n\n\t\t\textra_keep_store = calloc(count, sizeof(char *));\n\t\t\tif (!extra_keep_store) {\n\t\t\t\tSYSERROR(\"failed to allocate memory for storing current \"\n\t\t\t\t         \"environment variable values that will be kept\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tchar *v = getenv(extra_keep[i]);\n\t\t\t\tif (v) {\n\t\t\t\t\textra_keep_store[i] = strdup(v);\n\t\t\t\t\tif (!extra_keep_store[i]) {\n\t\t\t\t\t\tSYSERROR(\"failed to allocate memory for storing current \"\n\t\t\t\t\t\t         \"environment variable values that will be kept\");\n\t\t\t\t\t\twhile (i > 0)\n\t\t\t\t\t\t\tfree(extra_keep_store[--i]);\n\t\t\t\t\t\tfree(extra_keep_store);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(extra_keep[i], \"PATH\") == 0)\n\t\t\t\t\t\tpath_kept = 1;\n\t\t\t\t}\n\t\t\t\t/* calloc sets entire array to zero, so we don't\n\t\t\t\t * need an else */\n\t\t\t}\n\t\t}\n\n\t\tif (clearenv()) {\n\t\t\tchar **p;\n\t\t\tSYSERROR(\"failed to clear environment\");\n\t\t\tif (extra_keep_store) {\n\t\t\t\tfor (p = extra_keep_store; *p; p++)\n\t\t\t\t\tfree(*p);\n\t\t\t\tfree(extra_keep_store);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (extra_keep_store) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; extra_keep[i]; i++) {\n\t\t\t\tif (extra_keep_store[i]) {\n\t\t\t\t\tif (setenv(extra_keep[i], extra_keep_store[i], 1) < 0)\n\t\t\t\t\t\tSYSERROR(\"Unable to set environment variable\");\n\t\t\t\t}\n\t\t\t\tfree(extra_keep_store[i]);\n\t\t\t}\n\t\t\tfree(extra_keep_store);\n\t\t}\n\n\t\t/* always set a default path; shells and execlp tend\n\t\t * to be fine without it, but there is a disturbing\n\t\t * number of C programs out there that just assume\n\t\t * that getenv(\"PATH\") is never NULL and then die a\n\t\t * painful segfault death. */\n\t\tif (!path_kept)\n\t\t\tsetenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1);\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"failed to set environment variable\");\n\t\treturn -1;\n\t}\n\n\t/* set extra environment variables */\n\tif (extra_env) {\n\t\tfor (; *extra_env; extra_env++) {\n\t\t\t/* duplicate the string, just to be on\n\t\t\t * the safe side, because putenv does not\n\t\t\t * do it for us */\n\t\t\tchar *p = strdup(*extra_env);\n\t\t\t/* we just assume the user knows what they\n\t\t\t * are doing, so we don't do any checks */\n\t\t\tif (!p) {\n\t\t\t\tSYSERROR(\"failed to allocate memory for additional environment \"\n\t\t\t\t         \"variables\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tputenv(p);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic char *lxc_attach_getpwshell(uid_t uid)\n{\n\t/* local variables */\n\tpid_t pid;\n\tint pipes[2];\n\tint ret;\n\tint fd;\n\tchar *result = NULL;\n\n\t/* we need to fork off a process that runs the\n\t * getent program, and we need to capture its\n\t * output, so we use a pipe for that purpose\n\t */\n\tret = pipe(pipes);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid) {\n\t\t/* parent process */\n\t\tFILE *pipe_f;\n\t\tchar *line = NULL;\n\t\tsize_t line_bufsz = 0;\n\t\tint found = 0;\n\t\tint status;\n\n\t\tclose(pipes[1]);\n\n\t\tpipe_f = fdopen(pipes[0], \"r\");\n\t\twhile (getline(&line, &line_bufsz, pipe_f) != -1) {\n\t\t\tchar *token;\n\t\t\tchar *saveptr = NULL;\n\t\t\tlong value;\n\t\t\tchar *endptr = NULL;\n\t\t\tint i;\n\n\t\t\t/* if we already found something, just continue\n\t\t\t * to read until the pipe doesn't deliver any more\n\t\t\t * data, but don't modify the existing data\n\t\t\t * structure\n\t\t\t */\n\t\t\tif (found)\n\t\t\t\tcontinue;\n\n\t\t\t/* trim line on the right hand side */\n\t\t\tfor (i = strlen(line); i > 0 && (line[i - 1] == '\\n' || line[i - 1] == '\\r'); --i)\n\t\t\t\tline[i - 1] = '\\0';\n\n\t\t\t/* split into tokens: first user name */\n\t\t\ttoken = strtok_r(line, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: dummy password field */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: user id */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tvalue = token ? strtol(token, &endptr, 10) : 0;\n\t\t\tif (!token || !endptr || *endptr || value == LONG_MIN || value == LONG_MAX)\n\t\t\t\tcontinue;\n\t\t\t/* dummy sanity check: user id matches */\n\t\t\tif ((uid_t) value != uid)\n\t\t\t\tcontinue;\n\t\t\t/* skip fields: gid, gecos, dir, go to next field 'shell' */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\t\tif (!token)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\tfree(result);\n\t\t\tresult = strdup(token);\n\n\t\t\t/* sanity check that there are no fields after that */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (token)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t}\n\n\t\tfree(line);\n\t\tfclose(pipe_f);\n\tagain:\n\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* some sanity checks: if anything even hinted at going\n\t\t * wrong: we can't be sure we have a valid result, so\n\t\t * we assume we don't\n\t\t */\n\n\t\tif (!WIFEXITED(status))\n\t\t\treturn NULL;\n\n\t\tif (WEXITSTATUS(status) != 0)\n\t\t\treturn NULL;\n\n\t\tif (!found)\n\t\t\treturn NULL;\n\n\t\treturn result;\n\t} else {\n\t\t/* child process */\n\t\tchar uid_buf[32];\n\t\tchar *arguments[] = {\n\t\t\t\"getent\",\n\t\t\t\"passwd\",\n\t\t\tuid_buf,\n\t\t\tNULL\n\t\t};\n\n\t\tclose(pipes[0]);\n\n\t\t/* we want to capture stdout */\n\t\tdup2(pipes[1], 1);\n\t\tclose(pipes[1]);\n\n\t\t/* get rid of stdin/stderr, so we try to associate it\n\t\t * with /dev/null\n\t\t */\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd < 0) {\n\t\t\tclose(0);\n\t\t\tclose(2);\n\t\t} else {\n\t\t\tdup2(fd, 0);\n\t\t\tdup2(fd, 2);\n\t\t\tclose(fd);\n\t\t}\n\n\t\t/* finish argument list */\n\t\tret = snprintf(uid_buf, sizeof(uid_buf), \"%ld\", (long) uid);\n\t\tif (ret <= 0)\n\t\t\texit(-1);\n\n\t\t/* try to run getent program */\n\t\t(void) execvp(\"getent\", arguments);\n\t\texit(-1);\n\t}\n}\n\nstatic void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[MAXPATHLEN];\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tint ret;\n\tlong value = -1;\n\tuid_t uid = (uid_t)-1;\n\tgid_t gid = (gid_t)-1;\n\n\t/* read capabilities */\n\tsnprintf(proc_fn, MAXPATHLEN, \"/proc/%d/status\", 1);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file)\n\t\treturn;\n\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\t/* format is: real, effective, saved set user, fs\n\t\t * we only care about real uid\n\t\t */\n\t\tret = sscanf(line, \"Uid: %ld\", &value);\n\t\tif (ret != EOF && ret > 0) {\n\t\t\tuid = (uid_t) value;\n\t\t} else {\n\t\t\tret = sscanf(line, \"Gid: %ld\", &value);\n\t\t\tif (ret != EOF && ret > 0)\n\t\t\t\tgid = (gid_t) value;\n\t\t}\n\t\tif (uid != (uid_t)-1 && gid != (gid_t)-1)\n\t\t\tbreak;\n\t}\n\n\tfclose(proc_file);\n\tfree(line);\n\n\t/* only override arguments if we found something */\n\tif (uid != (uid_t)-1)\n\t\t*init_uid = uid;\n\tif (gid != (gid_t)-1)\n\t\t*init_gid = gid;\n\n\t/* TODO: we should also parse supplementary groups and use\n\t * setgroups() to set them */\n}\n\nstruct attach_clone_payload {\n\tint ipc_socket;\n\tlxc_attach_options_t* options;\n\tstruct lxc_proc_context_info* init_ctx;\n\tlxc_attach_exec_t exec_function;\n\tvoid* exec_payload;\n\tint procfd;\n};\n\nstatic int attach_child_main(void* data);\n\n/* help the optimizer along if it doesn't know that exit always exits */\n#define rexit(c)  do { int __c = (c); _exit(__c); return __c; } while(0)\n\n/* define default options if no options are supplied by the user */\nstatic lxc_attach_options_t attach_static_default_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\nstatic bool fetch_seccomp(struct lxc_container *c,\n\t\t\t  lxc_attach_options_t *options)\n{\n\tchar *path;\n\n\tif (!(options->namespaces & CLONE_NEWNS) || !(options->attach_flags & LXC_ATTACH_LSM)) {\n\t\tfree(c->lxc_conf->seccomp);\n\t\tc->lxc_conf->seccomp = NULL;\n\t\treturn true;\n\t}\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Fetch the current profile path over the cmd interface */\n\tpath = c->get_running_config_item(c, \"lxc.seccomp\");\n\tif (!path) {\n\t\tINFO(\"Failed to get running config item for lxc.seccomp.\");\n\t\treturn true;\n\t}\n\n\t/* Copy the value into the new lxc_conf */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", path)) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\tfree(path);\n\n\t/* Attempt to parse the resulting config */\n\tif (lxc_read_seccomp_config(c->lxc_conf) < 0) {\n\t\tERROR(\"Error reading seccomp policy\");\n\t\treturn false;\n\t}\n\n\tINFO(\"Retrieved seccomp policy.\");\n\treturn true;\n}\n\nstatic bool no_new_privs(struct lxc_container *c,\n\t\t\t lxc_attach_options_t *options)\n{\n\tchar *val;\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Retrieve currently active setting. */\n\tval = c->get_running_config_item(c, \"lxc.no_new_privs\");\n\tif (!val) {\n\t\tINFO(\"Failed to get running config item for lxc.no_new_privs.\");\n\t\treturn false;\n\t}\n\n\t/* Set currently active setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", val)) {\n\t\tfree(val);\n\t\treturn false;\n\t}\n\tfree(val);\n\n\treturn true;\n}\n\nstatic signed long get_personality(const char *name, const char *lxcpath)\n{\n\tchar *p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);\n\tsigned long ret;\n\n\tif (!p)\n\t\treturn -1;\n\tret = lxc_config_parse_arch(p);\n\tfree(p);\n\treturn ret;\n}\n\nint lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)\n{\n\tint ret, status;\n\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tint procfd;\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\tinit_pid = lxc_cmd_get_init_pid(name, lxcpath);\n\tif (init_pid < 0) {\n\t\tERROR(\"failed to get the init pid\");\n\t\treturn -1;\n\t}\n\n\tinit_ctx = lxc_proc_get_context_info(init_pid);\n\tif (!init_ctx) {\n\t\tERROR(\"failed to get context of the init process, pid = %ld\", (long)init_pid);\n\t\treturn -1;\n\t}\n\n\tpersonality = get_personality(name, lxcpath);\n\tif (init_ctx->personality < 0) {\n\t\tERROR(\"Failed to get personality of the container\");\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\tinit_ctx->personality = personality;\n\n\tinit_ctx->container = lxc_container_new(name, lxcpath);\n\tif (!init_ctx->container)\n\t\treturn -1;\n\n\tif (!fetch_seccomp(init_ctx->container, options))\n\t\tWARN(\"Failed to get seccomp policy\");\n\n\tif (!no_new_privs(init_ctx->container, options))\n\t\tWARN(\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\");\n\n\tcwd = getcwd(NULL, 0);\n\n\t/* determine which namespaces the container was created with\n\t * by asking lxc-start, if necessary\n\t */\n\tif (options->namespaces == -1) {\n\t\toptions->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);\n\t\t/* call failed */\n\t\tif (options->namespaces == -1) {\n\t\t\tERROR(\"failed to automatically determine the \"\n\t\t\t      \"namespaces which the container unshared\");\n\t\t\tfree(cwd);\n\t\t\tlxc_proc_put_context_info(init_ctx);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* create a socket pair for IPC communication; set SOCK_CLOEXEC in order\n\t * to make sure we don't irritate other threads that want to fork+exec away\n\t *\n\t * IMPORTANT: if the initial process is multithreaded and another call\n\t * just fork()s away without exec'ing directly after, the socket fd will\n\t * exist in the forked process from the other thread and any close() in\n\t * our own child process will not really cause the socket to close properly,\n\t * potentiall causing the parent to hang.\n\t *\n\t * For this reason, while IPC is still active, we have to use shutdown()\n\t * if the child exits prematurely in order to signal that the socket\n\t * is closed and cannot assume that the child exiting will automatically\n\t * do that.\n\t *\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *   close socket                                 close socket\n\t *                                                run program\n\t */\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tSYSERROR(\"could not set up required IPC mechanism for attaching\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* create intermediate subprocess, three reasons:\n\t *       1. runs all pthread_atfork handlers and the\n\t *          child will no longer be threaded\n\t *          (we can't properly setns() in a threaded process)\n\t *       2. we can't setns() in the child itself, since\n\t *          we want to make sure we are properly attached to\n\t *          the pidns\n\t *       3. also, the initial thread has to put the attached\n\t *          process into the cgroup, which we can only do if\n\t *          we didn't already setns() (otherwise, user\n\t *          namespaces will hate us)\n\t */\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to create first subprocess\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t/* initial thread, we close the socket that is for the\n\t\t * subprocesses\n\t\t */\n\t\tclose(ipc_sockets[1]);\n\t\tfree(cwd);\n\n\t\t/* attach to cgroup, if requested */\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Let the child process know to go ahead */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* get pid from intermediate process */\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive pid of attached process\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* ignore SIGKILL (CTRL-C) and SIGQUIT (CTRL-\\) - issue #313 */\n\t\tif (options->stdin_fd == 0) {\n\t\t\tsignal(SIGINT, SIG_IGN);\n\t\t\tsignal(SIGQUIT, SIG_IGN);\n\t\t}\n\n\t\t/* reap intermediate process */\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tgoto cleanup_error;\n\n\t\t/* we will always have to reap the grandchild now */\n\t\tto_cleanup_pid = attached_pid;\n\n\t\t/* tell attached process it may start initializing */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* wait for the attached process to finish initializing */\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive notification from attached process (1)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* tell attached process we're done */\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (2)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* now shut down communication with child, we're done */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tlxc_proc_put_context_info(init_ctx);\n\n\t\t/* we're done, the child process should now execute whatever\n\t\t * it is that the user requested. The parent can now track it\n\t\t * with waitpid() or similar.\n\t\t */\n\n\t\t*attached_process = attached_pid;\n\t\treturn 0;\n\n\tcleanup_error:\n\t\t/* first shut down the socket, then wait for the pid,\n\t\t * otherwise the pid we're waiting for may never exit\n\t\t */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* first subprocess begins here, we close the socket that is for the\n\t * initial thread\n\t */\n\tclose(ipc_sockets[0]);\n\n\t/* Wait for the parent to have setup cgroups */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"error communicating with child process\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\tprocfd = open(\"/proc\", O_DIRECTORY | O_RDONLY);\n\tif (procfd < 0) {\n\t\tSYSERROR(\"Unable to open /proc\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process\n\t */\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\tif (ret < 0) {\n\t\tERROR(\"failed to enter the namespace\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* attach succeeded, try to cwd */\n\tif (options->initial_cwd)\n\t\tnew_cwd = options->initial_cwd;\n\telse\n\t\tnew_cwd = cwd;\n\tret = chdir(new_cwd);\n\tif (ret < 0)\n\t\tWARN(\"could not change directory to '%s'\", new_cwd);\n\tfree(cwd);\n\n\t/* now create the real child process */\n\t{\n\t\tstruct attach_clone_payload payload = {\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t\t.procfd = procfd\n\t\t};\n\t\t/* We use clone_parent here to make this subprocess a direct child of\n\t\t * the initial process. Then this intermediate process can exit and\n\t\t * the parent can directly track the attached process.\n\t\t */\n\t\tpid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);\n\t}\n\n\t/* shouldn't happen, clone() should always return positive pid */\n\tif (pid <= 0) {\n\t\tSYSERROR(\"failed to create subprocess\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* tell grandparent the pid of the pid of the newly created child */\n\tret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));\n\tif (ret != sizeof(pid)) {\n\t\t/* if this really happens here, this is very unfortunate, since the\n\t\t * parent will not know the pid of the attached process and will\n\t\t * not be able to wait for it (and we won't either due to CLONE_PARENT)\n\t\t * so the parent won't be able to reap it and the attached process\n\t\t * will remain a zombie\n\t\t */\n\t\tERROR(\"error using IPC to notify main process of pid of the attached process\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* the rest is in the hands of the initial and the attached process */\n\trexit(0);\n}\n\nstatic int attach_child_main(void* data)\n{\n\tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n\tint ipc_socket = payload->ipc_socket;\n\tint procfd = payload->procfd;\n\tlxc_attach_options_t* options = payload->options;\n\tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n#if HAVE_SYS_PERSONALITY_H\n\tlong new_personality;\n#endif\n\tint ret;\n\tint status;\n\tint expected;\n\tlong flags;\n\tint fd;\n\tuid_t new_uid;\n\tgid_t new_gid;\n\n\t/* wait for the initial thread to signal us that it's ready\n\t * for us to start initializing\n\t */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"error using IPC to receive notification from initial process (0)\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* A description of the purpose of this functionality is\n\t * provided in the lxc-attach(1) manual page. We have to\n\t * remount here and not in the parent process, otherwise\n\t * /proc may not properly reflect the new pid namespace.\n\t */\n\tif (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {\n\t\tret = lxc_attach_remount_sys_proc();\n\t\tif (ret < 0) {\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* now perform additional attachments*/\n#if HAVE_SYS_PERSONALITY_H\n\tif (options->personality < 0)\n\t\tnew_personality = init_ctx->personality;\n\telse\n\t\tnew_personality = options->personality;\n\n\tif (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {\n\t\tret = personality(new_personality);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"could not ensure correct architecture\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n#endif\n\n\tif (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {\n\t\tret = lxc_attach_drop_privs(init_ctx);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"could not drop privileges\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL) if you want this to be a no-op) */\n\tret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);\n\tif (ret < 0) {\n\t\tERROR(\"could not set initial environment for attached process\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* set user / group id */\n\tnew_uid = 0;\n\tnew_gid = 0;\n\t/* ignore errors, we will fall back to root in that case\n\t * (/proc was not mounted etc.)\n\t */\n\tif (options->namespaces & CLONE_NEWUSER)\n\t\tlxc_attach_get_init_uidgid(&new_uid, &new_gid);\n\n\tif (options->uid != (uid_t)-1)\n\t\tnew_uid = options->uid;\n\tif (options->gid != (gid_t)-1)\n\t\tnew_gid = options->gid;\n\n\t/* setup the control tty */\n\tif (options->stdin_fd && isatty(options->stdin_fd)) {\n\t\tif (setsid() < 0) {\n\t\t\tSYSERROR(\"unable to setsid\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\tif (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {\n\t\t\tSYSERROR(\"unable to TIOCSTTY\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* try to set the uid/gid combination */\n\tif ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {\n\t\tif (setgid(new_gid) || setgroups(0, NULL)) {\n\t\t\tSYSERROR(\"switching to container gid\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\tif ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {\n\t\tSYSERROR(\"switching to container uid\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* tell initial process it may now put us into the cgroups */\n\tstatus = 1;\n\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n\tif (ret != sizeof(status)) {\n\t\tERROR(\"error using IPC to notify initial process for initialization (1)\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* wait for the initial thread to signal us that it has done\n\t * everything for us when it comes to cgroups etc.\n\t */\n\texpected = 2;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"error using IPC to receive final notification from initial process (2)\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tshutdown(ipc_socket, SHUT_RDWR);\n\tclose(ipc_socket);\n\n\tif ((init_ctx->container && init_ctx->container->lxc_conf &&\n\t     init_ctx->container->lxc_conf->no_new_privs) ||\n\t    (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {\n\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t\t\tSYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"\n\t\t\t\t \"Process can use execve() gainable \"\n\t\t\t\t \"privileges.\");\n\t\t\trexit(-1);\n\t\t}\n\t\tINFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"\n\t\t     \"gainable privileges.\");\n\t}\n\n\t/* set new apparmor profile/selinux context */\n\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\tint on_exec;\n\n\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\tif (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {\n\t\t\trexit(-1);\n\t\t}\n\t}\n\tif (init_ctx->container && init_ctx->container->lxc_conf &&\n\t    init_ctx->container->lxc_conf->seccomp &&\n\t    (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {\n\t\tERROR(\"Loading seccomp policy\");\n\t\trexit(-1);\n\t}\n\tlxc_proc_put_context_info(init_ctx);\n\n\t/* The following is done after the communication socket is\n\t * shut down. That way, all errors that might (though\n\t * unlikely) occur up until this point will have their messages\n\t * printed to the original stderr (if logging is so configured)\n\t * and not the fd the user supplied, if any.\n\t */\n\n\t/* fd handling for stdin, stdout and stderr;\n\t * ignore errors here, user may want to make sure\n\t * the fds are closed, for example */\n\tif (options->stdin_fd >= 0 && options->stdin_fd != 0)\n\t\tdup2(options->stdin_fd, 0);\n\tif (options->stdout_fd >= 0 && options->stdout_fd != 1)\n\t\tdup2(options->stdout_fd, 1);\n\tif (options->stderr_fd >= 0 && options->stderr_fd != 2)\n\t\tdup2(options->stderr_fd, 2);\n\n\t/* close the old fds */\n\tif (options->stdin_fd > 2)\n\t\tclose(options->stdin_fd);\n\tif (options->stdout_fd > 2)\n\t\tclose(options->stdout_fd);\n\tif (options->stderr_fd > 2)\n\t\tclose(options->stderr_fd);\n\n\t/* try to remove CLOEXEC flag from stdin/stdout/stderr,\n\t * but also here, ignore errors */\n\tfor (fd = 0; fd <= 2; fd++) {\n\t\tflags = fcntl(fd, F_GETFL);\n\t\tif (flags < 0)\n\t\t\tcontinue;\n\t\tif (flags & FD_CLOEXEC)\n\t\t\tif (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)\n\t\t\t\tSYSERROR(\"Unable to clear CLOEXEC from fd\");\n\t}\n\n\t/* we don't need proc anymore */\n\tclose(procfd);\n\n\t/* we're done, so we can now do whatever the user intended us to do */\n\trexit(payload->exec_function(payload->exec_payload));\n}\n\nint lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"failed to exec '%s'\", cmd->program);\n\treturn -1;\n}\n\nint lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* ignore payload parameter */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* this probably happens because of incompatible nss\n\t * implementations in host and container (remember, this\n\t * code is still using the host's glibc but our mount\n\t * namespace is in the container)\n\t * we may try to get the information by spawning a\n\t * [getent passwd uid] process and parsing the result\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* executed if either no passwd entry or execvp fails,\n\t * we will fall back on /bin/sh as a default shell\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"failed to exec shell\");\n\treturn -1;\n}\n"], "fixing_code": ["/*\n * lxc: linux Container library\n *\n * (C) Copyright IBM Corp. 2007, 2008\n *\n * Authors:\n * Daniel Lezcano <daniel.lezcano at free.fr>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <sys/param.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n#include <linux/unistd.h>\n#include <pwd.h>\n\n#ifndef HAVE_DECL_PR_CAPBSET_DROP\n#define PR_CAPBSET_DROP 24\n#endif\n\n#ifndef HAVE_DECL_PR_SET_NO_NEW_PRIVS\n#define PR_SET_NO_NEW_PRIVS 38\n#endif\n\n#ifndef HAVE_DECL_PR_GET_NO_NEW_PRIVS\n#define PR_GET_NO_NEW_PRIVS 39\n#endif\n\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include \"attach.h\"\n#include \"caps.h\"\n#include \"config.h\"\n#include \"utils.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"lxclock.h\"\n#include \"conf.h\"\n#include \"lxcseccomp.h\"\n#include <lxc/lxccontainer.h>\n#include \"lsm/lsm.h\"\n#include \"confile.h\"\n\n#if HAVE_SYS_PERSONALITY_H\n#include <sys/personality.h>\n#endif\n\n#ifndef SOCK_CLOEXEC\n#  define SOCK_CLOEXEC                02000000\n#endif\n\n#ifndef MS_REC\n#define MS_REC 16384\n#endif\n\n#ifndef MS_SLAVE\n#define MS_SLAVE (1<<19)\n#endif\n\nlxc_log_define(lxc_attach, lxc);\n\nstatic int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char* name;\n#define __LSMATTRLEN /* /proc */ (5 + /* /pid-to-str */ 21 + /* /current */ 7 + /* \\0 */ 1)\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec) {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t} else {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t}\n\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open LSM label\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}\n\nstatic int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\n\nout:\n\tfree(command);\n\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\n\treturn fret;\n}\n\nstatic struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n{\n\tstruct lxc_proc_context_info *info = calloc(1, sizeof(*info));\n\tFILE *proc_file;\n\tchar proc_fn[MAXPATHLEN];\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tint ret, found;\n\n\tif (!info) {\n\t\tSYSERROR(\"Could not allocate memory.\");\n\t\treturn NULL;\n\t}\n\n\t/* read capabilities */\n\tsnprintf(proc_fn, MAXPATHLEN, \"/proc/%d/status\", pid);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file) {\n\t\tSYSERROR(\"Could not open %s\", proc_fn);\n\t\tgoto out_error;\n\t}\n\n\tfound = 0;\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\tret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);\n\t\tif (ret != EOF && ret > 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(proc_file);\n\n\tif (!found) {\n\t\tSYSERROR(\"Could not read capability bounding set from %s\", proc_fn);\n\t\terrno = ENOENT;\n\t\tgoto out_error;\n\t}\n\n\tinfo->lsm_label = lsm_process_label_get(pid);\n\n\treturn info;\n\nout_error:\n\tfree(info);\n\treturn NULL;\n}\n\nstatic void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}\n\nstatic int lxc_attach_to_ns(pid_t pid, int which)\n{\n\tint fd[LXC_NS_MAX];\n\tint i, j, saved_errno;\n\n\n\tif (access(\"/proc/self/ns\", X_OK)) {\n\t\tERROR(\"Does this kernel version support 'attach' ?\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\t/* ignore if we are not supposed to attach to that\n\t\t * namespace\n\t\t */\n\t\tif (which != -1 && !(which & ns_info[i].clone_flag)) {\n\t\t\tfd[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (fd[i] < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\t/* close all already opened file descriptors before\n\t\t\t * we return an error, so we don't leak them\n\t\t\t */\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"failed to open namespace: '%s'.\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(fd[i], 0) < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\tfor (j = i; j < LXC_NS_MAX; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to attach to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"Attached to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\n\t\tclose(fd[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int lxc_attach_remount_sys_proc(void)\n{\n\tint ret;\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\treturn -1;\n\t}\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\t/* assume /proc is always mounted, so remount it */\n\tret = umount2(\"/proc\", MNT_DETACH);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to unmount /proc\");\n\t\treturn -1;\n\t}\n\n\tret = mount(\"none\", \"/proc\", \"proc\", 0, NULL);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to remount /proc\");\n\t\treturn -1;\n\t}\n\n\t/* try to umount /sys - if it's not a mount point,\n\t * we'll get EINVAL, then we ignore it because it\n\t * may not have been mounted in the first place\n\t */\n\tret = umount2(\"/sys\", MNT_DETACH);\n\tif (ret < 0 && errno != EINVAL) {\n\t\tSYSERROR(\"failed to unmount /sys\");\n\t\treturn -1;\n\t} else if (ret == 0) {\n\t\t/* remount it */\n\t\tret = mount(\"none\", \"/sys\", \"sysfs\", 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"failed to remount /sys\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lxc_attach_drop_privs(struct lxc_proc_context_info *ctx)\n{\n\tint last_cap = lxc_caps_last_cap();\n\tint cap;\n\n\tfor (cap = 0; cap <= last_cap; cap++) {\n\t\tif (ctx->capability_mask & (1LL << cap))\n\t\t\tcontinue;\n\n\t\tif (prctl(PR_CAPBSET_DROP, cap, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove capability id %d\", cap);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy, char** extra_env, char** extra_keep)\n{\n\tif (policy == LXC_ATTACH_CLEAR_ENV) {\n\t\tchar **extra_keep_store = NULL;\n\t\tint path_kept = 0;\n\n\t\tif (extra_keep) {\n\t\t\tsize_t count, i;\n\n\t\t\tfor (count = 0; extra_keep[count]; count++);\n\n\t\t\textra_keep_store = calloc(count, sizeof(char *));\n\t\t\tif (!extra_keep_store) {\n\t\t\t\tSYSERROR(\"failed to allocate memory for storing current \"\n\t\t\t\t         \"environment variable values that will be kept\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tchar *v = getenv(extra_keep[i]);\n\t\t\t\tif (v) {\n\t\t\t\t\textra_keep_store[i] = strdup(v);\n\t\t\t\t\tif (!extra_keep_store[i]) {\n\t\t\t\t\t\tSYSERROR(\"failed to allocate memory for storing current \"\n\t\t\t\t\t\t         \"environment variable values that will be kept\");\n\t\t\t\t\t\twhile (i > 0)\n\t\t\t\t\t\t\tfree(extra_keep_store[--i]);\n\t\t\t\t\t\tfree(extra_keep_store);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(extra_keep[i], \"PATH\") == 0)\n\t\t\t\t\t\tpath_kept = 1;\n\t\t\t\t}\n\t\t\t\t/* calloc sets entire array to zero, so we don't\n\t\t\t\t * need an else */\n\t\t\t}\n\t\t}\n\n\t\tif (clearenv()) {\n\t\t\tchar **p;\n\t\t\tSYSERROR(\"failed to clear environment\");\n\t\t\tif (extra_keep_store) {\n\t\t\t\tfor (p = extra_keep_store; *p; p++)\n\t\t\t\t\tfree(*p);\n\t\t\t\tfree(extra_keep_store);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (extra_keep_store) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; extra_keep[i]; i++) {\n\t\t\t\tif (extra_keep_store[i]) {\n\t\t\t\t\tif (setenv(extra_keep[i], extra_keep_store[i], 1) < 0)\n\t\t\t\t\t\tSYSERROR(\"Unable to set environment variable\");\n\t\t\t\t}\n\t\t\t\tfree(extra_keep_store[i]);\n\t\t\t}\n\t\t\tfree(extra_keep_store);\n\t\t}\n\n\t\t/* always set a default path; shells and execlp tend\n\t\t * to be fine without it, but there is a disturbing\n\t\t * number of C programs out there that just assume\n\t\t * that getenv(\"PATH\") is never NULL and then die a\n\t\t * painful segfault death. */\n\t\tif (!path_kept)\n\t\t\tsetenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1);\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"failed to set environment variable\");\n\t\treturn -1;\n\t}\n\n\t/* set extra environment variables */\n\tif (extra_env) {\n\t\tfor (; *extra_env; extra_env++) {\n\t\t\t/* duplicate the string, just to be on\n\t\t\t * the safe side, because putenv does not\n\t\t\t * do it for us */\n\t\t\tchar *p = strdup(*extra_env);\n\t\t\t/* we just assume the user knows what they\n\t\t\t * are doing, so we don't do any checks */\n\t\t\tif (!p) {\n\t\t\t\tSYSERROR(\"failed to allocate memory for additional environment \"\n\t\t\t\t         \"variables\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tputenv(p);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic char *lxc_attach_getpwshell(uid_t uid)\n{\n\t/* local variables */\n\tpid_t pid;\n\tint pipes[2];\n\tint ret;\n\tint fd;\n\tchar *result = NULL;\n\n\t/* we need to fork off a process that runs the\n\t * getent program, and we need to capture its\n\t * output, so we use a pipe for that purpose\n\t */\n\tret = pipe(pipes);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid) {\n\t\t/* parent process */\n\t\tFILE *pipe_f;\n\t\tchar *line = NULL;\n\t\tsize_t line_bufsz = 0;\n\t\tint found = 0;\n\t\tint status;\n\n\t\tclose(pipes[1]);\n\n\t\tpipe_f = fdopen(pipes[0], \"r\");\n\t\twhile (getline(&line, &line_bufsz, pipe_f) != -1) {\n\t\t\tchar *token;\n\t\t\tchar *saveptr = NULL;\n\t\t\tlong value;\n\t\t\tchar *endptr = NULL;\n\t\t\tint i;\n\n\t\t\t/* if we already found something, just continue\n\t\t\t * to read until the pipe doesn't deliver any more\n\t\t\t * data, but don't modify the existing data\n\t\t\t * structure\n\t\t\t */\n\t\t\tif (found)\n\t\t\t\tcontinue;\n\n\t\t\t/* trim line on the right hand side */\n\t\t\tfor (i = strlen(line); i > 0 && (line[i - 1] == '\\n' || line[i - 1] == '\\r'); --i)\n\t\t\t\tline[i - 1] = '\\0';\n\n\t\t\t/* split into tokens: first user name */\n\t\t\ttoken = strtok_r(line, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: dummy password field */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: user id */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tvalue = token ? strtol(token, &endptr, 10) : 0;\n\t\t\tif (!token || !endptr || *endptr || value == LONG_MIN || value == LONG_MAX)\n\t\t\t\tcontinue;\n\t\t\t/* dummy sanity check: user id matches */\n\t\t\tif ((uid_t) value != uid)\n\t\t\t\tcontinue;\n\t\t\t/* skip fields: gid, gecos, dir, go to next field 'shell' */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\t\tif (!token)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\tfree(result);\n\t\t\tresult = strdup(token);\n\n\t\t\t/* sanity check that there are no fields after that */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (token)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t}\n\n\t\tfree(line);\n\t\tfclose(pipe_f);\n\tagain:\n\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* some sanity checks: if anything even hinted at going\n\t\t * wrong: we can't be sure we have a valid result, so\n\t\t * we assume we don't\n\t\t */\n\n\t\tif (!WIFEXITED(status))\n\t\t\treturn NULL;\n\n\t\tif (WEXITSTATUS(status) != 0)\n\t\t\treturn NULL;\n\n\t\tif (!found)\n\t\t\treturn NULL;\n\n\t\treturn result;\n\t} else {\n\t\t/* child process */\n\t\tchar uid_buf[32];\n\t\tchar *arguments[] = {\n\t\t\t\"getent\",\n\t\t\t\"passwd\",\n\t\t\tuid_buf,\n\t\t\tNULL\n\t\t};\n\n\t\tclose(pipes[0]);\n\n\t\t/* we want to capture stdout */\n\t\tdup2(pipes[1], 1);\n\t\tclose(pipes[1]);\n\n\t\t/* get rid of stdin/stderr, so we try to associate it\n\t\t * with /dev/null\n\t\t */\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd < 0) {\n\t\t\tclose(0);\n\t\t\tclose(2);\n\t\t} else {\n\t\t\tdup2(fd, 0);\n\t\t\tdup2(fd, 2);\n\t\t\tclose(fd);\n\t\t}\n\n\t\t/* finish argument list */\n\t\tret = snprintf(uid_buf, sizeof(uid_buf), \"%ld\", (long) uid);\n\t\tif (ret <= 0)\n\t\t\texit(-1);\n\n\t\t/* try to run getent program */\n\t\t(void) execvp(\"getent\", arguments);\n\t\texit(-1);\n\t}\n}\n\nstatic void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[MAXPATHLEN];\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tint ret;\n\tlong value = -1;\n\tuid_t uid = (uid_t)-1;\n\tgid_t gid = (gid_t)-1;\n\n\t/* read capabilities */\n\tsnprintf(proc_fn, MAXPATHLEN, \"/proc/%d/status\", 1);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file)\n\t\treturn;\n\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\t/* format is: real, effective, saved set user, fs\n\t\t * we only care about real uid\n\t\t */\n\t\tret = sscanf(line, \"Uid: %ld\", &value);\n\t\tif (ret != EOF && ret > 0) {\n\t\t\tuid = (uid_t) value;\n\t\t} else {\n\t\t\tret = sscanf(line, \"Gid: %ld\", &value);\n\t\t\tif (ret != EOF && ret > 0)\n\t\t\t\tgid = (gid_t) value;\n\t\t}\n\t\tif (uid != (uid_t)-1 && gid != (gid_t)-1)\n\t\t\tbreak;\n\t}\n\n\tfclose(proc_file);\n\tfree(line);\n\n\t/* only override arguments if we found something */\n\tif (uid != (uid_t)-1)\n\t\t*init_uid = uid;\n\tif (gid != (gid_t)-1)\n\t\t*init_gid = gid;\n\n\t/* TODO: we should also parse supplementary groups and use\n\t * setgroups() to set them */\n}\n\nstruct attach_clone_payload {\n\tint ipc_socket;\n\tlxc_attach_options_t* options;\n\tstruct lxc_proc_context_info* init_ctx;\n\tlxc_attach_exec_t exec_function;\n\tvoid* exec_payload;\n};\n\nstatic int attach_child_main(void* data);\n\n/* help the optimizer along if it doesn't know that exit always exits */\n#define rexit(c)  do { int __c = (c); _exit(__c); return __c; } while(0)\n\n/* define default options if no options are supplied by the user */\nstatic lxc_attach_options_t attach_static_default_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\nstatic bool fetch_seccomp(struct lxc_container *c,\n\t\t\t  lxc_attach_options_t *options)\n{\n\tchar *path;\n\n\tif (!(options->namespaces & CLONE_NEWNS) || !(options->attach_flags & LXC_ATTACH_LSM)) {\n\t\tfree(c->lxc_conf->seccomp);\n\t\tc->lxc_conf->seccomp = NULL;\n\t\treturn true;\n\t}\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Fetch the current profile path over the cmd interface */\n\tpath = c->get_running_config_item(c, \"lxc.seccomp\");\n\tif (!path) {\n\t\tINFO(\"Failed to get running config item for lxc.seccomp.\");\n\t\treturn true;\n\t}\n\n\t/* Copy the value into the new lxc_conf */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", path)) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\tfree(path);\n\n\t/* Attempt to parse the resulting config */\n\tif (lxc_read_seccomp_config(c->lxc_conf) < 0) {\n\t\tERROR(\"Error reading seccomp policy\");\n\t\treturn false;\n\t}\n\n\tINFO(\"Retrieved seccomp policy.\");\n\treturn true;\n}\n\nstatic bool no_new_privs(struct lxc_container *c,\n\t\t\t lxc_attach_options_t *options)\n{\n\tchar *val;\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Retrieve currently active setting. */\n\tval = c->get_running_config_item(c, \"lxc.no_new_privs\");\n\tif (!val) {\n\t\tINFO(\"Failed to get running config item for lxc.no_new_privs.\");\n\t\treturn false;\n\t}\n\n\t/* Set currently active setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", val)) {\n\t\tfree(val);\n\t\treturn false;\n\t}\n\tfree(val);\n\n\treturn true;\n}\n\nstatic signed long get_personality(const char *name, const char *lxcpath)\n{\n\tchar *p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);\n\tsigned long ret;\n\n\tif (!p)\n\t\treturn -1;\n\tret = lxc_config_parse_arch(p);\n\tfree(p);\n\treturn ret;\n}\n\nint lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)\n{\n\tint ret, status;\n\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\tinit_pid = lxc_cmd_get_init_pid(name, lxcpath);\n\tif (init_pid < 0) {\n\t\tERROR(\"failed to get the init pid\");\n\t\treturn -1;\n\t}\n\n\tinit_ctx = lxc_proc_get_context_info(init_pid);\n\tif (!init_ctx) {\n\t\tERROR(\"failed to get context of the init process, pid = %ld\", (long)init_pid);\n\t\treturn -1;\n\t}\n\n\tpersonality = get_personality(name, lxcpath);\n\tif (init_ctx->personality < 0) {\n\t\tERROR(\"Failed to get personality of the container\");\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\tinit_ctx->personality = personality;\n\n\tinit_ctx->container = lxc_container_new(name, lxcpath);\n\tif (!init_ctx->container)\n\t\treturn -1;\n\n\tif (!fetch_seccomp(init_ctx->container, options))\n\t\tWARN(\"Failed to get seccomp policy\");\n\n\tif (!no_new_privs(init_ctx->container, options))\n\t\tWARN(\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\");\n\n\tcwd = getcwd(NULL, 0);\n\n\t/* determine which namespaces the container was created with\n\t * by asking lxc-start, if necessary\n\t */\n\tif (options->namespaces == -1) {\n\t\toptions->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);\n\t\t/* call failed */\n\t\tif (options->namespaces == -1) {\n\t\t\tERROR(\"failed to automatically determine the \"\n\t\t\t      \"namespaces which the container unshared\");\n\t\t\tfree(cwd);\n\t\t\tlxc_proc_put_context_info(init_ctx);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* create a socket pair for IPC communication; set SOCK_CLOEXEC in order\n\t * to make sure we don't irritate other threads that want to fork+exec away\n\t *\n\t * IMPORTANT: if the initial process is multithreaded and another call\n\t * just fork()s away without exec'ing directly after, the socket fd will\n\t * exist in the forked process from the other thread and any close() in\n\t * our own child process will not really cause the socket to close properly,\n\t * potentiall causing the parent to hang.\n\t *\n\t * For this reason, while IPC is still active, we have to use shutdown()\n\t * if the child exits prematurely in order to signal that the socket\n\t * is closed and cannot assume that the child exiting will automatically\n\t * do that.\n\t *\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\t */\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tSYSERROR(\"could not set up required IPC mechanism for attaching\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* create intermediate subprocess, three reasons:\n\t *       1. runs all pthread_atfork handlers and the\n\t *          child will no longer be threaded\n\t *          (we can't properly setns() in a threaded process)\n\t *       2. we can't setns() in the child itself, since\n\t *          we want to make sure we are properly attached to\n\t *          the pidns\n\t *       3. also, the initial thread has to put the attached\n\t *          process into the cgroup, which we can only do if\n\t *          we didn't already setns() (otherwise, user\n\t *          namespaces will hate us)\n\t */\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to create first subprocess\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tint procfd = -1;\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t/* initial thread, we close the socket that is for the\n\t\t * subprocesses\n\t\t */\n\t\tclose(ipc_sockets[1]);\n\t\tfree(cwd);\n\n\t\t/* attach to cgroup, if requested */\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Open /proc before setns() to the containers namespace so we\n\t\t * don't rely on any information from inside the container.\n\t\t */\n\t\tprocfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\t\tif (procfd < 0) {\n\t\t\tSYSERROR(\"Unable to open /proc.\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Let the child process know to go ahead */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* get pid from intermediate process */\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive pid of attached process\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* ignore SIGKILL (CTRL-C) and SIGQUIT (CTRL-\\) - issue #313 */\n\t\tif (options->stdin_fd == 0) {\n\t\t\tsignal(SIGINT, SIG_IGN);\n\t\t\tsignal(SIGQUIT, SIG_IGN);\n\t\t}\n\n\t\t/* reap intermediate process */\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tgoto cleanup_error;\n\n\t\t/* we will always have to reap the grandchild now */\n\t\tto_cleanup_pid = attached_pid;\n\n\t\t/* tell attached process it may start initializing */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* wait for the attached process to finish initializing */\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive notification \"\n\t\t\t\t      \"from attached process (1)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* tell attached process we're done */\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Error using IPC to notify attached process for \"\n\t\t\t      \"initialization (2): %s.\", strerror(errno));\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Wait for the (grand)child to tell us that it's ready to set\n\t\t * up its LSM labels.\n\t\t */\n\t\texpected = 3;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",\n\t\t\t      strerror(errno));\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Open LSM fd and send it to child. */\n\t\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\t\tint on_exec, labelfd;\n\t\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\t\t/* Open fd for the LSM security module. */\n\t\t\tlabelfd = lsm_openat(procfd, attached_pid, on_exec);\n\t\t\tif (labelfd < 0)\n\t\t\t\tgoto cleanup_error;\n\n\t\t\t/* Send child fd of the LSM security module to write to. */\n\t\t\tret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tERROR(\"Error using IPC to send child LSM fd (4): %s.\",\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\tgoto cleanup_error;\n\t\t\t}\n\t\t}\n\n\t\t/* now shut down communication with child, we're done */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tlxc_proc_put_context_info(init_ctx);\n\n\t\t/* we're done, the child process should now execute whatever\n\t\t * it is that the user requested. The parent can now track it\n\t\t * with waitpid() or similar.\n\t\t */\n\n\t\t*attached_process = attached_pid;\n\t\treturn 0;\n\n\tcleanup_error:\n\t\t/* first shut down the socket, then wait for the pid,\n\t\t * otherwise the pid we're waiting for may never exit\n\t\t */\n\t\tif (procfd >= 0)\n\t\t\tclose(procfd);\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* first subprocess begins here, we close the socket that is for the\n\t * initial thread\n\t */\n\tclose(ipc_sockets[0]);\n\n\t/* Wait for the parent to have setup cgroups */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"error communicating with child process\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\t/* attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process\n\t */\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\tif (ret < 0) {\n\t\tERROR(\"failed to enter the namespace\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* attach succeeded, try to cwd */\n\tif (options->initial_cwd)\n\t\tnew_cwd = options->initial_cwd;\n\telse\n\t\tnew_cwd = cwd;\n\tret = chdir(new_cwd);\n\tif (ret < 0)\n\t\tWARN(\"could not change directory to '%s'\", new_cwd);\n\tfree(cwd);\n\n\t/* now create the real child process */\n\t{\n\t\tstruct attach_clone_payload payload = {\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t};\n\t\t/* We use clone_parent here to make this subprocess a direct child of\n\t\t * the initial process. Then this intermediate process can exit and\n\t\t * the parent can directly track the attached process.\n\t\t */\n\t\tpid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);\n\t}\n\n\t/* shouldn't happen, clone() should always return positive pid */\n\tif (pid <= 0) {\n\t\tSYSERROR(\"failed to create subprocess\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* tell grandparent the pid of the pid of the newly created child */\n\tret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));\n\tif (ret != sizeof(pid)) {\n\t\t/* if this really happens here, this is very unfortunate, since the\n\t\t * parent will not know the pid of the attached process and will\n\t\t * not be able to wait for it (and we won't either due to CLONE_PARENT)\n\t\t * so the parent won't be able to reap it and the attached process\n\t\t * will remain a zombie\n\t\t */\n\t\tERROR(\"error using IPC to notify main process of pid of the attached process\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* the rest is in the hands of the initial and the attached process */\n\trexit(0);\n}\n\nstatic int attach_child_main(void* data)\n{\n\tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n\tint ipc_socket = payload->ipc_socket;\n\tlxc_attach_options_t* options = payload->options;\n\tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n#if HAVE_SYS_PERSONALITY_H\n\tlong new_personality;\n#endif\n\tint ret;\n\tint status;\n\tint expected;\n\tlong flags;\n\tint fd;\n\tint lsm_labelfd;\n\tuid_t new_uid;\n\tgid_t new_gid;\n\n\t/* wait for the initial thread to signal us that it's ready\n\t * for us to start initializing\n\t */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* A description of the purpose of this functionality is\n\t * provided in the lxc-attach(1) manual page. We have to\n\t * remount here and not in the parent process, otherwise\n\t * /proc may not properly reflect the new pid namespace.\n\t */\n\tif (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {\n\t\tret = lxc_attach_remount_sys_proc();\n\t\tif (ret < 0) {\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* now perform additional attachments*/\n#if HAVE_SYS_PERSONALITY_H\n\tif (options->personality < 0)\n\t\tnew_personality = init_ctx->personality;\n\telse\n\t\tnew_personality = options->personality;\n\n\tif (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {\n\t\tret = personality(new_personality);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"could not ensure correct architecture\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n#endif\n\n\tif (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {\n\t\tret = lxc_attach_drop_privs(init_ctx);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"could not drop privileges\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL) if you want this to be a no-op) */\n\tret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);\n\tif (ret < 0) {\n\t\tERROR(\"could not set initial environment for attached process\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* set user / group id */\n\tnew_uid = 0;\n\tnew_gid = 0;\n\t/* ignore errors, we will fall back to root in that case\n\t * (/proc was not mounted etc.)\n\t */\n\tif (options->namespaces & CLONE_NEWUSER)\n\t\tlxc_attach_get_init_uidgid(&new_uid, &new_gid);\n\n\tif (options->uid != (uid_t)-1)\n\t\tnew_uid = options->uid;\n\tif (options->gid != (gid_t)-1)\n\t\tnew_gid = options->gid;\n\n\t/* setup the control tty */\n\tif (options->stdin_fd && isatty(options->stdin_fd)) {\n\t\tif (setsid() < 0) {\n\t\t\tSYSERROR(\"unable to setsid\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\tif (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {\n\t\t\tSYSERROR(\"unable to TIOCSTTY\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* try to set the uid/gid combination */\n\tif ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {\n\t\tif (setgid(new_gid) || setgroups(0, NULL)) {\n\t\t\tSYSERROR(\"switching to container gid\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\tif ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {\n\t\tSYSERROR(\"switching to container uid\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* tell initial process it may now put us into the cgroups */\n\tstatus = 1;\n\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n\tif (ret != sizeof(status)) {\n\t\tERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* wait for the initial thread to signal us that it has done\n\t * everything for us when it comes to cgroups etc.\n\t */\n\texpected = 2;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Error using IPC to receive message from initial process \"\n\t\t      \"that it is done pre-initializing (2): %s\",\n\t\t      strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((init_ctx->container && init_ctx->container->lxc_conf &&\n\t     init_ctx->container->lxc_conf->no_new_privs) ||\n\t    (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {\n\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t\t\tSYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"\n\t\t\t\t \"Process can use execve() gainable \"\n\t\t\t\t \"privileges.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t\tINFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"\n\t\t     \"gainable privileges.\");\n\t}\n\n\t/* Tell the (grand)parent to send us LSM label fd. */\n\tstatus = 3;\n\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n\tif (ret <= 0) {\n\t\tERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\tint on_exec;\n\t\t/* Receive fd for LSM security module. */\n\t\tret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\t/* Change into our new LSM profile. */\n\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\tif (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {\n\t\t\tSYSERROR(\"Failed to set LSM label.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\tclose(lsm_labelfd);\n\t\t\trexit(-1);\n\t\t}\n\t\tclose(lsm_labelfd);\n\t}\n\n\tif (init_ctx->container && init_ctx->container->lxc_conf &&\n\t    init_ctx->container->lxc_conf->seccomp &&\n\t    (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {\n\t\tERROR(\"Loading seccomp policy\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tshutdown(ipc_socket, SHUT_RDWR);\n\tclose(ipc_socket);\n\tlxc_proc_put_context_info(init_ctx);\n\n\t/* The following is done after the communication socket is\n\t * shut down. That way, all errors that might (though\n\t * unlikely) occur up until this point will have their messages\n\t * printed to the original stderr (if logging is so configured)\n\t * and not the fd the user supplied, if any.\n\t */\n\n\t/* fd handling for stdin, stdout and stderr;\n\t * ignore errors here, user may want to make sure\n\t * the fds are closed, for example */\n\tif (options->stdin_fd >= 0 && options->stdin_fd != 0)\n\t\tdup2(options->stdin_fd, 0);\n\tif (options->stdout_fd >= 0 && options->stdout_fd != 1)\n\t\tdup2(options->stdout_fd, 1);\n\tif (options->stderr_fd >= 0 && options->stderr_fd != 2)\n\t\tdup2(options->stderr_fd, 2);\n\n\t/* close the old fds */\n\tif (options->stdin_fd > 2)\n\t\tclose(options->stdin_fd);\n\tif (options->stdout_fd > 2)\n\t\tclose(options->stdout_fd);\n\tif (options->stderr_fd > 2)\n\t\tclose(options->stderr_fd);\n\n\t/* try to remove CLOEXEC flag from stdin/stdout/stderr,\n\t * but also here, ignore errors */\n\tfor (fd = 0; fd <= 2; fd++) {\n\t\tflags = fcntl(fd, F_GETFL);\n\t\tif (flags < 0)\n\t\t\tcontinue;\n\t\tif (flags & FD_CLOEXEC)\n\t\t\tif (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)\n\t\t\t\tSYSERROR(\"Unable to clear CLOEXEC from fd\");\n\t}\n\n\t/* we're done, so we can now do whatever the user intended us to do */\n\trexit(payload->exec_function(payload->exec_payload));\n}\n\nint lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"failed to exec '%s'\", cmd->program);\n\treturn -1;\n}\n\nint lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* ignore payload parameter */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* this probably happens because of incompatible nss\n\t * implementations in host and container (remember, this\n\t * code is still using the host's glibc but our mount\n\t * namespace is in the container)\n\t * we may try to get the information by spawning a\n\t * [getent passwd uid] process and parsing the result\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* executed if either no passwd entry or execvp fails,\n\t * we will fall back on /bin/sh as a default shell\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"failed to exec shell\");\n\treturn -1;\n}\n"], "filenames": ["src/lxc/attach.c"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [1250], "fixing_code_start_loc": [56], "fixing_code_end_loc": [1333], "type": "CWE-264", "message": "lxc-attach in LXC before 1.0.9 and 2.x before 2.0.6 allows an attacker inside of an unprivileged container to use an inherited file descriptor, of the host's /proc, to access the rest of the host's filesystem via the openat() family of syscalls.", "other": {"cve": {"id": "CVE-2016-8649", "sourceIdentifier": "secalert@redhat.com", "published": "2017-05-01T06:59:00.157", "lastModified": "2018-10-26T13:53:08.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lxc-attach in LXC before 1.0.9 and 2.x before 2.0.6 allows an attacker inside of an unprivileged container to use an inherited file descriptor, of the host's /proc, to access the rest of the host's filesystem via the openat() family of syscalls."}, {"lang": "es", "value": "lxc-attach en LXC entre las versiones 1.0.9 y 2.x hasta la versi\u00f3n 2.0.6 permite que un atacante dentro de un contenedor sin privilegios, utilice un descriptor de archivo heredado de la carpeta /proc del host para acceder al resto del sistema de archivos del host a trav\u00e9s de llamadas al sistema openat()."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxcontainers:lxc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.9", "matchCriteriaId": "83629BC8-27B7-479D-A128-EFA5630BB184"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxcontainers:lxc:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.6", "matchCriteriaId": "B65EC152-48AC-43E9-A1DF-E76C953508A5"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/94498", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=845465", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1639345", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1398242", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2016-8649", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c"}}