{"buggy_code": ["{\n  \"name\": \"striptags\",\n  \"description\": \"PHP strip_tags in Node.js\",\n  \"license\": \"MIT\",\n  \"author\": \"Eric Norris (https://github.com/ericnorris)\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ericnorris/striptags.git\"\n  },\n  \"main\": \"src/striptags.js\",\n  \"homepage\": \"https://github.com/ericnorris/striptags\",\n  \"bugs\": \"https://github.com/ericnorris/striptags/issues\",\n  \"version\": \"3.1.1\",\n  \"devDependencies\": {\n    \"istanbul\": \"^0.4.5\",\n    \"mocha\": \"^3.2.0\"\n  },\n  \"keywords\": [\n    \"striptags\",\n    \"strip_tags\",\n    \"html\",\n    \"strip\",\n    \"tags\"\n  ],\n  \"typings\": \"index.d.ts\",\n  \"scripts\": {\n    \"test\": \"mocha\",\n    \"coverage\": \"istanbul cover _mocha -- -R spec\"\n  }\n}\n", "'use strict';\n\n(function (global) {\n\n    // minimal symbol polyfill for IE11 and others\n    if (typeof Symbol !== 'function') {\n        var Symbol = function(name) {\n            return name;\n        }\n\n        Symbol.nonNative = true;\n    }\n\n    const STATE_PLAINTEXT = Symbol('plaintext');\n    const STATE_HTML      = Symbol('html');\n    const STATE_COMMENT   = Symbol('comment');\n\n    const ALLOWED_TAGS_REGEX  = /<(\\w*)>/g;\n    const NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n\n    function striptags(html, allowable_tags, tag_replacement) {\n        html            = html || '';\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return striptags_internal(html, context);\n    }\n\n    function init_striptags_stream(allowable_tags, tag_replacement) {\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return function striptags_stream(html) {\n            return striptags_internal(html || '', context);\n        };\n    }\n\n    striptags.init_streaming_mode = init_striptags_stream;\n\n    function init_context(allowable_tags, tag_replacement) {\n        allowable_tags = parse_allowable_tags(allowable_tags);\n\n        return {\n            allowable_tags : allowable_tags,\n            tag_replacement: tag_replacement,\n\n            state         : STATE_PLAINTEXT,\n            tag_buffer    : '',\n            depth         : 0,\n            in_quote_char : ''\n        };\n    }\n\n    function striptags_internal(html, context) {\n        let allowable_tags  = context.allowable_tags;\n        let tag_replacement = context.tag_replacement;\n\n        let state         = context.state;\n        let tag_buffer    = context.tag_buffer;\n        let depth         = context.depth;\n        let in_quote_char = context.in_quote_char;\n        let output        = '';\n\n        for (let idx = 0, length = html.length; idx < length; idx++) {\n            let char = html[idx];\n\n            if (state === STATE_PLAINTEXT) {\n                switch (char) {\n                    case '<':\n                        state       = STATE_HTML;\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        output += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_HTML) {\n                switch (char) {\n                    case '<':\n                        // ignore '<' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // we're seeing a nested '<'\n                        depth++;\n                        break;\n\n                    case '>':\n                        // ignore '>' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // something like this is happening: '<<>>'\n                        if (depth) {\n                            depth--;\n\n                            break;\n                        }\n\n                        // this is closing the tag in tag_buffer\n                        in_quote_char = '';\n                        state         = STATE_PLAINTEXT;\n                        tag_buffer   += '>';\n\n                        if (allowable_tags.has(normalize_tag(tag_buffer))) {\n                            output += tag_buffer;\n                        } else {\n                            output += tag_replacement;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    case '\"':\n                    case '\\'':\n                        // catch both single and double quotes\n\n                        if (char === in_quote_char) {\n                            in_quote_char = '';\n                        } else {\n                            in_quote_char = in_quote_char || char;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case '-':\n                        if (tag_buffer === '<!-') {\n                            state = STATE_COMMENT;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case ' ':\n                    case '\\n':\n                        if (tag_buffer === '<') {\n                            state      = STATE_PLAINTEXT;\n                            output    += '< ';\n                            tag_buffer = '';\n\n                            break;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_COMMENT) {\n                switch (char) {\n                    case '>':\n                        if (tag_buffer.slice(-2) == '--') {\n                            // close the comment\n                            state = STATE_PLAINTEXT;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n        }\n\n        // save the context for future iterations\n        context.state         = state;\n        context.tag_buffer    = tag_buffer;\n        context.depth         = depth;\n        context.in_quote_char = in_quote_char;\n\n        return output;\n    }\n\n    function parse_allowable_tags(allowable_tags) {\n        let tag_set = new Set();\n\n        if (typeof allowable_tags === 'string') {\n            let match;\n\n            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {\n                tag_set.add(match[1]);\n            }\n        }\n\n        else if (!Symbol.nonNative &&\n                 typeof allowable_tags[Symbol.iterator] === 'function') {\n\n            tag_set = new Set(allowable_tags);\n        }\n\n        else if (typeof allowable_tags.forEach === 'function') {\n            // IE11 compatible\n            allowable_tags.forEach(tag_set.add, tag_set);\n        }\n\n        return tag_set;\n    }\n\n    function normalize_tag(tag_buffer) {\n        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n\n        return match ? match[1].toLowerCase() : null;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(function module_factory() { return striptags; });\n    }\n\n    else if (typeof module === 'object' && module.exports) {\n        // Node\n        module.exports = striptags;\n    }\n\n    else {\n        // Browser\n        global.striptags = striptags;\n    }\n}(this));\n", "'use strict';\n/* global describe, it */\n\nlet assert    = require('assert');\nlet fs        = require('fs');\nlet vm        = require('vm');\nlet striptags = require('../');\n\n\ndescribe('striptags', function() {\n    describe('#module', function() {\n        let path   = require.resolve('../');\n        let src    = fs.readFileSync(path);\n        let script = new vm.Script(src);\n\n        it('should define a Node module', function() {\n            let module = { exports: {} };\n\n            script.runInNewContext({module});\n\n            assert.equal(module.exports.toString(), striptags.toString());\n        });\n\n        it('should define an AMD module', function() {\n            let module = null;\n            let define = function(module_factory) {\n                module = module_factory();\n            };\n\n            define.amd = true;\n\n            script.runInNewContext({define});\n\n            assert.equal(module.toString(), striptags.toString());\n        });\n\n        it('should define a browser global', function() {\n            let global = {};\n\n            script.runInNewContext(global);\n\n            assert.notEqual(global.striptags, null);\n        });\n    });\n\n    describe('with no optional parameters', function() {\n        it('should not strip invalid tags', function() {\n            let text = 'lorem ipsum < a> < div>';\n\n            assert.equal(striptags(text), text);\n        });\n\n        it('should remove simple HTML tags', function() {\n            let html = '<a href=\"\">lorem <strong>ipsum</strong></a>',\n                text = 'lorem ipsum';\n\n            assert.equal(striptags(html), text);\n        });\n\n        it('should remove comments', function() {\n            let html = '<!-- lorem -- ipsum -- --> dolor sit amet',\n                text = ' dolor sit amet';\n\n            assert.equal(striptags(html), text);\n        });\n\n        it('should strip tags within comments', function() {\n            let html = '<!-- <strong>lorem ipsum</strong> --> dolor sit',\n                text = ' dolor sit';\n\n            assert.equal(striptags(html), text);\n        });\n\n\n        it('should not fail with nested quotes', function() {\n            let html = '<article attr=\"foo \\'bar\\'\">lorem</article> ipsum',\n                text = 'lorem ipsum';\n\n            assert.equal(striptags(html), text);\n        });\n    });\n\n    describe('#allowed_tags', function() {\n        it('should parse a string', function() {\n            let html = '<strong>lorem ipsum</strong>',\n                allowed_tags = '<strong>';\n\n            assert.equal(striptags(html, allowed_tags), html);\n        });\n\n        it('should take an array', function() {\n            let html = '<strong>lorem <em>ipsum</em></strong>',\n                allowed_tags = ['strong', 'em'];\n\n            assert.equal(striptags(html, allowed_tags), html);\n        });\n    });\n\n    describe('with allowable_tags parameter', function() {\n        it('should leave attributes when allowing HTML', function() {\n            let html = '<a href=\"https://example.com\">lorem ipsum</a>',\n                allowed_tags = '<a>';\n\n            assert.equal(striptags(html, allowed_tags), html);\n        });\n\n        it('should strip extra < within tags', function() {\n            let html = '<div<>>lorem ipsum</div>',\n                text = '<div>lorem ipsum</div>',\n                allowed_tags = '<div>';\n\n            assert.equal(striptags(html, allowed_tags), text);\n        });\n\n        it('should strip <> within quotes', function() {\n            let html = '<a href=\"<script>\">lorem ipsum</a>',\n                text = '<a href=\"script\">lorem ipsum</a>',\n                allowed_tags = '<a>';\n\n            assert.equal(striptags(html, allowed_tags), text);\n        });\n    });\n\n    describe('with tag_replacement parameter', function() {\n        it('should replace tags with that parameter', function() {\n            var html = 'Line One<br>Line Two',\n                allowed_tags = [],\n                tag_replacement = '\\n',\n                text = 'Line One\\nLine Two';\n\n            assert.equal(striptags(html, allowed_tags, tag_replacement), text);\n        });\n    });\n\n    describe('#streaming_mode', function() {\n        it('should strip streamed HTML', function() {\n            let striptags_stream = striptags.init_streaming_mode();\n\n            let part_one   = striptags_stream('lorem ipsum <stro');\n            let part_two   = striptags_stream('ng>dolor sit <');\n            let part_three = striptags_stream(' amet');\n\n            assert.equal(part_one, 'lorem ipsum ');\n            assert.equal(part_two, 'dolor sit ');\n            assert.equal(part_three, '< amet');\n        });\n\n        it('should work with allowable_tags', function() {\n            let striptags_stream = striptags.init_streaming_mode(['strong']);\n\n            let part_one   = striptags_stream('lorem ipsum <stro');\n            let part_two   = striptags_stream('ng>dolor sit <');\n            let part_three = striptags_stream(' amet');\n\n            assert.equal(part_one, 'lorem ipsum ');\n            assert.equal(part_two, '<strong>dolor sit ');\n            assert.equal(part_three, '< amet');\n        });\n    });\n});\n"], "fixing_code": ["{\n  \"name\": \"striptags\",\n  \"description\": \"PHP strip_tags in Node.js\",\n  \"license\": \"MIT\",\n  \"author\": \"Eric Norris (https://github.com/ericnorris)\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ericnorris/striptags.git\"\n  },\n  \"main\": \"src/striptags.js\",\n  \"homepage\": \"https://github.com/ericnorris/striptags\",\n  \"bugs\": \"https://github.com/ericnorris/striptags/issues\",\n  \"version\": \"3.2.0\",\n  \"devDependencies\": {\n    \"istanbul\": \"^0.4.5\",\n    \"mocha\": \"^3.2.0\"\n  },\n  \"keywords\": [\n    \"striptags\",\n    \"strip_tags\",\n    \"html\",\n    \"strip\",\n    \"tags\"\n  ],\n  \"typings\": \"index.d.ts\",\n  \"scripts\": {\n    \"test\": \"mocha\",\n    \"coverage\": \"istanbul cover _mocha -- -R spec\"\n  }\n}\n", "'use strict';\n\n(function (global) {\n\n    // minimal symbol polyfill for IE11 and others\n    if (typeof Symbol !== 'function') {\n        var Symbol = function(name) {\n            return name;\n        }\n\n        Symbol.nonNative = true;\n    }\n\n    const STATE_PLAINTEXT = Symbol('plaintext');\n    const STATE_HTML      = Symbol('html');\n    const STATE_COMMENT   = Symbol('comment');\n\n    const ALLOWED_TAGS_REGEX  = /<(\\w*)>/g;\n    const NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n\n    function striptags(html, allowable_tags, tag_replacement) {\n        html            = html || '';\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return striptags_internal(html, context);\n    }\n\n    function init_striptags_stream(allowable_tags, tag_replacement) {\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return function striptags_stream(html) {\n            return striptags_internal(html || '', context);\n        };\n    }\n\n    striptags.init_streaming_mode = init_striptags_stream;\n\n    function init_context(allowable_tags, tag_replacement) {\n        allowable_tags = parse_allowable_tags(allowable_tags);\n\n        return {\n            allowable_tags : allowable_tags,\n            tag_replacement: tag_replacement,\n\n            state         : STATE_PLAINTEXT,\n            tag_buffer    : '',\n            depth         : 0,\n            in_quote_char : ''\n        };\n    }\n\n    function striptags_internal(html, context) {\n        if (typeof html != \"string\") {\n            throw new TypeError(\"'html' parameter must be a string\");\n        }\n\n        let allowable_tags  = context.allowable_tags;\n        let tag_replacement = context.tag_replacement;\n\n        let state         = context.state;\n        let tag_buffer    = context.tag_buffer;\n        let depth         = context.depth;\n        let in_quote_char = context.in_quote_char;\n        let output        = '';\n\n        for (let idx = 0, length = html.length; idx < length; idx++) {\n            let char = html[idx];\n\n            if (state === STATE_PLAINTEXT) {\n                switch (char) {\n                    case '<':\n                        state       = STATE_HTML;\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        output += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_HTML) {\n                switch (char) {\n                    case '<':\n                        // ignore '<' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // we're seeing a nested '<'\n                        depth++;\n                        break;\n\n                    case '>':\n                        // ignore '>' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // something like this is happening: '<<>>'\n                        if (depth) {\n                            depth--;\n\n                            break;\n                        }\n\n                        // this is closing the tag in tag_buffer\n                        in_quote_char = '';\n                        state         = STATE_PLAINTEXT;\n                        tag_buffer   += '>';\n\n                        if (allowable_tags.has(normalize_tag(tag_buffer))) {\n                            output += tag_buffer;\n                        } else {\n                            output += tag_replacement;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    case '\"':\n                    case '\\'':\n                        // catch both single and double quotes\n\n                        if (char === in_quote_char) {\n                            in_quote_char = '';\n                        } else {\n                            in_quote_char = in_quote_char || char;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case '-':\n                        if (tag_buffer === '<!-') {\n                            state = STATE_COMMENT;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case ' ':\n                    case '\\n':\n                        if (tag_buffer === '<') {\n                            state      = STATE_PLAINTEXT;\n                            output    += '< ';\n                            tag_buffer = '';\n\n                            break;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_COMMENT) {\n                switch (char) {\n                    case '>':\n                        if (tag_buffer.slice(-2) == '--') {\n                            // close the comment\n                            state = STATE_PLAINTEXT;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n        }\n\n        // save the context for future iterations\n        context.state         = state;\n        context.tag_buffer    = tag_buffer;\n        context.depth         = depth;\n        context.in_quote_char = in_quote_char;\n\n        return output;\n    }\n\n    function parse_allowable_tags(allowable_tags) {\n        let tag_set = new Set();\n\n        if (typeof allowable_tags === 'string') {\n            let match;\n\n            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {\n                tag_set.add(match[1]);\n            }\n        }\n\n        else if (!Symbol.nonNative &&\n                 typeof allowable_tags[Symbol.iterator] === 'function') {\n\n            tag_set = new Set(allowable_tags);\n        }\n\n        else if (typeof allowable_tags.forEach === 'function') {\n            // IE11 compatible\n            allowable_tags.forEach(tag_set.add, tag_set);\n        }\n\n        return tag_set;\n    }\n\n    function normalize_tag(tag_buffer) {\n        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n\n        return match ? match[1].toLowerCase() : null;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(function module_factory() { return striptags; });\n    }\n\n    else if (typeof module === 'object' && module.exports) {\n        // Node\n        module.exports = striptags;\n    }\n\n    else {\n        // Browser\n        global.striptags = striptags;\n    }\n}(this));\n", "'use strict';\n/* global describe, it */\n\nlet assert    = require('assert');\nlet fs        = require('fs');\nlet vm        = require('vm');\nlet striptags = require('../');\n\n\ndescribe('striptags', function() {\n    describe('#module', function() {\n        let path   = require.resolve('../');\n        let src    = fs.readFileSync(path);\n        let script = new vm.Script(src);\n\n        it('should define a Node module', function() {\n            let module = { exports: {} };\n\n            script.runInNewContext({module});\n\n            assert.equal(module.exports.toString(), striptags.toString());\n        });\n\n        it('should define an AMD module', function() {\n            let module = null;\n            let define = function(module_factory) {\n                module = module_factory();\n            };\n\n            define.amd = true;\n\n            script.runInNewContext({define});\n\n            assert.equal(module.toString(), striptags.toString());\n        });\n\n        it('should define a browser global', function() {\n            let global = {};\n\n            script.runInNewContext(global);\n\n            assert.notEqual(global.striptags, null);\n        });\n    });\n\n    describe('with no optional parameters', function() {\n        it('should not strip invalid tags', function() {\n            let text = 'lorem ipsum < a> < div>';\n\n            assert.equal(striptags(text), text);\n        });\n\n        it('should remove simple HTML tags', function() {\n            let html = '<a href=\"\">lorem <strong>ipsum</strong></a>',\n                text = 'lorem ipsum';\n\n            assert.equal(striptags(html), text);\n        });\n\n        it('should remove comments', function() {\n            let html = '<!-- lorem -- ipsum -- --> dolor sit amet',\n                text = ' dolor sit amet';\n\n            assert.equal(striptags(html), text);\n        });\n\n        it('should strip tags within comments', function() {\n            let html = '<!-- <strong>lorem ipsum</strong> --> dolor sit',\n                text = ' dolor sit';\n\n            assert.equal(striptags(html), text);\n        });\n\n\n        it('should not fail with nested quotes', function() {\n            let html = '<article attr=\"foo \\'bar\\'\">lorem</article> ipsum',\n                text = 'lorem ipsum';\n\n            assert.equal(striptags(html), text);\n        });\n    });\n\n    describe('#allowed_tags', function() {\n        it('should parse a string', function() {\n            let html = '<strong>lorem ipsum</strong>',\n                allowed_tags = '<strong>';\n\n            assert.equal(striptags(html, allowed_tags), html);\n        });\n\n        it('should take an array', function() {\n            let html = '<strong>lorem <em>ipsum</em></strong>',\n                allowed_tags = ['strong', 'em'];\n\n            assert.equal(striptags(html, allowed_tags), html);\n        });\n    });\n\n    describe('with allowable_tags parameter', function() {\n        it('should leave attributes when allowing HTML', function() {\n            let html = '<a href=\"https://example.com\">lorem ipsum</a>',\n                allowed_tags = '<a>';\n\n            assert.equal(striptags(html, allowed_tags), html);\n        });\n\n        it('should strip extra < within tags', function() {\n            let html = '<div<>>lorem ipsum</div>',\n                text = '<div>lorem ipsum</div>',\n                allowed_tags = '<div>';\n\n            assert.equal(striptags(html, allowed_tags), text);\n        });\n\n        it('should strip <> within quotes', function() {\n            let html = '<a href=\"<script>\">lorem ipsum</a>',\n                text = '<a href=\"script\">lorem ipsum</a>',\n                allowed_tags = '<a>';\n\n            assert.equal(striptags(html, allowed_tags), text);\n        });\n    });\n\n    describe('with tag_replacement parameter', function() {\n        it('should replace tags with that parameter', function() {\n            var html = 'Line One<br>Line Two',\n                allowed_tags = [],\n                tag_replacement = '\\n',\n                text = 'Line One\\nLine Two';\n\n            assert.equal(striptags(html, allowed_tags, tag_replacement), text);\n        });\n    });\n\n    describe('#streaming_mode', function() {\n        it('should strip streamed HTML', function() {\n            let striptags_stream = striptags.init_streaming_mode();\n\n            let part_one   = striptags_stream('lorem ipsum <stro');\n            let part_two   = striptags_stream('ng>dolor sit <');\n            let part_three = striptags_stream(' amet');\n\n            assert.equal(part_one, 'lorem ipsum ');\n            assert.equal(part_two, 'dolor sit ');\n            assert.equal(part_three, '< amet');\n        });\n\n        it('should work with allowable_tags', function() {\n            let striptags_stream = striptags.init_streaming_mode(['strong']);\n\n            let part_one   = striptags_stream('lorem ipsum <stro');\n            let part_two   = striptags_stream('ng>dolor sit <');\n            let part_three = striptags_stream(' amet');\n\n            assert.equal(part_one, 'lorem ipsum ');\n            assert.equal(part_two, '<strong>dolor sit ');\n            assert.equal(part_three, '< amet');\n        });\n    });\n\n    it('GHSL-2021-074', function() {\n        assert.throws(\n            function() {\n                striptags([\"type-confusion\"]);\n            },\n            TypeError,\n        );\n    });\n});\n"], "filenames": ["package.json", "src/striptags.js", "test/striptags-test.js"], "buggy_code_start_loc": [13, 58, 159], "buggy_code_end_loc": [14, 58, 159], "fixing_code_start_loc": [13, 59, 160], "fixing_code_end_loc": [14, 63, 169], "type": "CWE-843", "message": "The npm package \"striptags\" is an implementation of PHP's strip_tags in Typescript. In striptags before version 3.2.0, a type-confusion vulnerability can cause `striptags` to concatenate unsanitized strings when an array-like object is passed in as the `html` parameter. This can be abused by an attacker who can control the shape of their input, e.g. if query parameters are passed directly into the function. This can lead to a XSS.", "other": {"cve": {"id": "CVE-2021-32696", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-18T20:15:07.633", "lastModified": "2021-06-24T19:20:20.253", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The npm package \"striptags\" is an implementation of PHP's strip_tags in Typescript. In striptags before version 3.2.0, a type-confusion vulnerability can cause `striptags` to concatenate unsanitized strings when an array-like object is passed in as the `html` parameter. This can be abused by an attacker who can control the shape of their input, e.g. if query parameters are passed directly into the function. This can lead to a XSS."}, {"lang": "es", "value": "El paquete npm \"striptags\" es una implementaci\u00f3n de strip_tags de PHP en Typescript. En striptags versiones anteriores a 3.2.0, una vulnerabilidad de confusi\u00f3n de tipos puede causar que \"striptags\" concatene cadenas no saneadas cuando es pasado un objeto tipo array como el par\u00e1metro \"html\". Esto puede ser abusado por un atacante que pueda controlar la forma de su entrada, por ejemplo, si los par\u00e1metros query son pasados directamente a la funci\u00f3n. Esto puede conllevar una vulnerabilidad de tipo XSS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-241"}, {"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:striptags_project:striptags:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.2.0", "matchCriteriaId": "15E6A9CD-E398-4D89-A6B4-CD1E88213789"}]}]}], "references": [{"url": "https://github.com/ericnorris/striptags/commit/f252a6b0819499cd65403707ebaf5cc925f2faca", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ericnorris/striptags/releases/tag/v3.2.0", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ericnorris/striptags/security/advisories/GHSA-qxg5-2qff-p49r", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/striptags", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ericnorris/striptags/commit/f252a6b0819499cd65403707ebaf5cc925f2faca"}}