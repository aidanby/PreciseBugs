{"buggy_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nBottle is a fast and simple micro-framework for small web applications. It\noffers request dispatching (Routes) with url parameter support, templates,\na built-in HTTP Server and adapters for many third party WSGI/HTTP-server and\ntemplate engines - all in a single file and with no dependencies other than the\nPython Standard Library.\n\nHomepage and documentation: http://bottlepy.org/\n\nCopyright (c) 2016, Marcel Hellkamp.\nLicense: MIT (see LICENSE for details)\n\"\"\"\n\nfrom __future__ import with_statement\n\n__author__ = 'Marcel Hellkamp'\n__version__ = '0.12.19'\n__license__ = 'MIT'\n\n# The gevent server adapter needs to patch some modules before they are imported\n# This is why we parse the commandline parameters here but handle them later\nif __name__ == '__main__':\n    from optparse import OptionParser\n    _cmd_parser = OptionParser(usage=\"usage: %prog [options] package.module:app\")\n    _opt = _cmd_parser.add_option\n    _opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    _opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")\n    _opt(\"-s\", \"--server\", default='wsgiref', help=\"use SERVER as backend.\")\n    _opt(\"-p\", \"--plugin\", action=\"append\", help=\"install additional plugin/s.\")\n    _opt(\"--debug\", action=\"store_true\", help=\"start server in debug mode.\")\n    _opt(\"--reload\", action=\"store_true\", help=\"auto-reload on file changes.\")\n    _cmd_options, _cmd_args = _cmd_parser.parse_args()\n    if _cmd_options.server and _cmd_options.server.startswith('gevent'):\n        import gevent.monkey; gevent.monkey.patch_all()\n\nimport base64, cgi, email.utils, functools, hmac, itertools, mimetypes,\\\n        os, re, subprocess, sys, tempfile, threading, time, warnings, hashlib\n\nfrom datetime import date as datedate, datetime, timedelta\nfrom tempfile import TemporaryFile\nfrom traceback import format_exc, print_exc\nfrom inspect import getargspec\nfrom unicodedata import normalize\n\n\ntry: from simplejson import dumps as json_dumps, loads as json_lds\nexcept ImportError: # pragma: no cover\n    try: from json import dumps as json_dumps, loads as json_lds\n    except ImportError:\n        try: from django.utils.simplejson import dumps as json_dumps, loads as json_lds\n        except ImportError:\n            def json_dumps(data):\n                raise ImportError(\"JSON support requires Python 2.6 or simplejson.\")\n            json_lds = json_dumps\n\n\n\n# We now try to fix 2.5/2.6/3.1/3.2 incompatibilities.\n# It ain't pretty but it works... Sorry for the mess.\n\npy   = sys.version_info\npy3k = py >= (3, 0, 0)\npy25 = py <  (2, 6, 0)\npy31 = (3, 1, 0) <= py < (3, 2, 0)\n\n# Workaround for the missing \"as\" keyword in py3k.\ndef _e(): return sys.exc_info()[1]\n\n# Workaround for the \"print is a keyword/function\" Python 2/3 dilemma\n# and a fallback for mod_wsgi (resticts stdout/err attribute access)\ntry:\n    _stdout, _stderr = sys.stdout.write, sys.stderr.write\nexcept IOError:\n    _stdout = lambda x: sys.stdout.write(x)\n    _stderr = lambda x: sys.stderr.write(x)\n\n# Lots of stdlib and builtin differences.\nif py3k:\n    import http.client as httplib\n    import _thread as thread\n    from urllib.parse import urljoin, SplitResult as UrlSplitResult\n    from urllib.parse import urlencode, quote as urlquote, unquote as urlunquote\n    urlunquote = functools.partial(urlunquote, encoding='latin1')\n    from http.cookies import SimpleCookie\n    if py >= (3, 3, 0):\n        from collections.abc import MutableMapping as DictMixin\n        from types import ModuleType as new_module\n    else:\n        from collections import MutableMapping as DictMixin\n        from imp import new_module\n    import pickle\n    from io import BytesIO\n    from configparser import ConfigParser\n    basestring = str\n    unicode = str\n    json_loads = lambda s: json_lds(touni(s))\n    callable = lambda x: hasattr(x, '__call__')\n    imap = map\n    def _raise(*a): raise a[0](a[1]).with_traceback(a[2])\nelse: # 2.x\n    import httplib\n    import thread\n    from urlparse import urljoin, SplitResult as UrlSplitResult\n    from urllib import urlencode, quote as urlquote, unquote as urlunquote\n    from Cookie import SimpleCookie\n    from itertools import imap\n    import cPickle as pickle\n    from imp import new_module\n    from StringIO import StringIO as BytesIO\n    from ConfigParser import SafeConfigParser as ConfigParser\n    if py25:\n        msg  = \"Python 2.5 support may be dropped in future versions of Bottle.\"\n        warnings.warn(msg, DeprecationWarning)\n        from UserDict import DictMixin\n        def next(it): return it.next()\n        bytes = str\n    else: # 2.6, 2.7\n        from collections import MutableMapping as DictMixin\n    unicode = unicode\n    json_loads = json_lds\n    eval(compile('def _raise(*a): raise a[0], a[1], a[2]', '<py3fix>', 'exec'))\n\n# Some helpers for string/byte handling\ndef tob(s, enc='utf8'):\n    return s.encode(enc) if isinstance(s, unicode) else bytes(s)\ndef touni(s, enc='utf8', err='strict'):\n    return s.decode(enc, err) if isinstance(s, bytes) else unicode(s)\ntonat = touni if py3k else tob\n\n# 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n# 3.1 needs a workaround.\nif py31:\n    from io import TextIOWrapper\n    class NCTextIOWrapper(TextIOWrapper):\n        def close(self): pass # Keep wrapped buffer open.\n\n\n# A bug in functools causes it to break if the wrapper is an instance method\ndef update_wrapper(wrapper, wrapped, *a, **ka):\n    try: functools.update_wrapper(wrapper, wrapped, *a, **ka)\n    except AttributeError: pass\n\n\n\n# These helpers are used at module level and need to be defined first.\n# And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.\n\ndef depr(message, hard=False):\n    warnings.warn(message, DeprecationWarning, stacklevel=3)\n\ndef makelist(data): # This is just to handy\n    if isinstance(data, (tuple, list, set, dict)): return list(data)\n    elif data: return [data]\n    else: return []\n\n\nclass DictProperty(object):\n    ''' Property that maps to a key in a local dict-like attribute. '''\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter, self.key = func, self.key or func.__name__\n        return self\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        key, storage = self.key, getattr(obj, self.attr)\n        if key not in storage: storage[key] = self.getter(obj)\n        return storage[key]\n\n    def __set__(self, obj, value):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        getattr(obj, self.attr)[self.key] = value\n\n    def __delete__(self, obj):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        del getattr(obj, self.attr)[self.key]\n\n\nclass cached_property(object):\n    ''' A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. '''\n\n    def __init__(self, func):\n        self.__doc__ = getattr(func, '__doc__')\n        self.func = func\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value\n\n\nclass lazy_attribute(object):\n    ''' A property that caches itself to the class object. '''\n    def __init__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter = func\n\n    def __get__(self, obj, cls):\n        value = self.getter(cls)\n        setattr(cls, self.__name__, value)\n        return value\n\n\n\n\n\n\n###############################################################################\n# Exceptions and Events ########################################################\n###############################################################################\n\n\nclass BottleException(Exception):\n    \"\"\" A base class for exceptions used by bottle. \"\"\"\n    pass\n\n\n\n\n\n\n###############################################################################\n# Routing ######################################################################\n###############################################################################\n\n\nclass RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\n\n\nclass RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all\n        plugins are re-applied. \"\"\"\n\nclass RouterUnknownModeError(RouteError): pass\n\n\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\n\n\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\n\n\ndef _re_flatten(p):\n    ''' Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. '''\n    if '(' not in p: return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))',\n        lambda m: m.group(0) if len(m.group(1)) % 2 else m.group(1) + '(?:', p)\n\n\nclass Router(object):\n    ''' A Router is an ordered collection of route->target pairs. It is used to\n        efficiently match WSGI requests against a number of routes and return\n        the first target that satisfies the request. The target may be anything,\n        usually a string, ID or callable object. A route consists of a path-rule\n        and a HTTP method.\n\n        The path-rule is either a static path (e.g. `/contact`) or a dynamic\n        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax\n        and details on the matching order are described in docs:`routing`.\n    '''\n\n    default_pattern = '[^/]+'\n    default_filter  = 're'\n\n    #: The current CPython regexp implementation does not allow more\n    #: than 99 matching groups per regular expression.\n    _MAX_GROUPS_PER_PATTERN = 99\n\n    def __init__(self, strict=False):\n        self.rules    = [] # All rules in order\n        self._groups  = {} # index of regexes to find them in dyna_routes\n        self.builder  = {} # Data structure for the url builder\n        self.static   = {} # Search structure for static routes\n        self.dyna_routes   = {}\n        self.dyna_regexes  = {} # Search structure for dynamic routes\n        #: If true, static routes are no longer checked first.\n        self.strict_order = strict\n        self.filters = {\n            're':    lambda conf:\n                (_re_flatten(conf or self.default_pattern), None, None),\n            'int':   lambda conf: (r'-?\\d+', int, lambda x: str(int(x))),\n            'float': lambda conf: (r'-?[\\d.]+', float, lambda x: str(float(x))),\n            'path':  lambda conf: (r'.+?', None, None)}\n\n    def add_filter(self, name, func):\n        ''' Add a filter. The provided function is called with the configuration\n        string as parameter and must return a (regexp, to_python, to_url) tuple.\n        The first element is a string, the last two are callables or None. '''\n        self.filters[name] = func\n\n    rule_syntax = re.compile('(\\\\\\\\*)'\\\n        '(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'\\\n          '|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'\\\n            '(?::((?:\\\\\\\\.|[^\\\\\\\\>]+)+)?)?)?>))')\n\n    def _itertokens(self, rule):\n        offset, prefix = 0, ''\n        for match in self.rule_syntax.finditer(rule):\n            prefix += rule[offset:match.start()]\n            g = match.groups()\n            if len(g[0])%2: # Escaped wildcard\n                prefix += match.group(0)[len(g[0]):]\n                offset = match.end()\n                continue\n            if prefix:\n                yield prefix, None, None\n            name, filtr, conf = g[4:7] if g[2] is None else g[1:4]\n            yield name, filtr or 'default', conf or None\n            offset, prefix = match.end(), ''\n        if offset <= len(rule) or prefix:\n            yield prefix+rule[offset:], None, None\n\n    def add(self, rule, method, target, name=None):\n        ''' Add a new rule or replace the target for an existing rule. '''\n        anons     = 0    # Number of anonymous wildcards found\n        keys      = []   # Names of keys\n        pattern   = ''   # Regular expression pattern with named groups\n        filters   = []   # Lists of wildcard input filters\n        builder   = []   # Data structure for the URL builder\n        is_static = True\n\n        for key, mode, conf in self._itertokens(rule):\n            if mode:\n                is_static = False\n                if mode == 'default': mode = self.default_filter\n                mask, in_filter, out_filter = self.filters[mode](conf)\n                if not key:\n                    pattern += '(?:%s)' % mask\n                    key = 'anon%d' % anons\n                    anons += 1\n                else:\n                    pattern += '(?P<%s>%s)' % (key, mask)\n                    keys.append(key)\n                if in_filter: filters.append((key, in_filter))\n                builder.append((key, out_filter or str))\n            elif key:\n                pattern += re.escape(key)\n                builder.append((None, key))\n\n        self.builder[rule] = builder\n        if name: self.builder[name] = builder\n\n        if is_static and not self.strict_order:\n            self.static.setdefault(method, {})\n            self.static[method][self.build(rule)] = (target, None)\n            return\n\n        try:\n            re_pattern = re.compile('^(%s)$' % pattern)\n            re_match = re_pattern.match\n        except re.error:\n            raise RouteSyntaxError(\"Could not add Route: %s (%s)\" % (rule, _e()))\n\n        if filters:\n            def getargs(path):\n                url_args = re_match(path).groupdict()\n                for name, wildcard_filter in filters:\n                    try:\n                        url_args[name] = wildcard_filter(url_args[name])\n                    except ValueError:\n                        raise HTTPError(400, 'Path has wrong format.')\n                return url_args\n        elif re_pattern.groupindex:\n            def getargs(path):\n                return re_match(path).groupdict()\n        else:\n            getargs = None\n\n        flatpat = _re_flatten(pattern)\n        whole_rule = (rule, flatpat, target, getargs)\n\n        if (flatpat, method) in self._groups:\n            if DEBUG:\n                msg = 'Route <%s %s> overwrites a previously defined route'\n                warnings.warn(msg % (method, rule), RuntimeWarning)\n            self.dyna_routes[method][self._groups[flatpat, method]] = whole_rule\n        else:\n            self.dyna_routes.setdefault(method, []).append(whole_rule)\n            self._groups[flatpat, method] = len(self.dyna_routes[method]) - 1\n\n        self._compile(method)\n\n    def _compile(self, method):\n        all_rules = self.dyna_routes[method]\n        comborules = self.dyna_regexes[method] = []\n        maxgroups = self._MAX_GROUPS_PER_PATTERN\n        for x in range(0, len(all_rules), maxgroups):\n            some = all_rules[x:x+maxgroups]\n            combined = (flatpat for (_, flatpat, _, _) in some)\n            combined = '|'.join('(^%s$)' % flatpat for flatpat in combined)\n            combined = re.compile(combined).match\n            rules = [(target, getargs) for (_, _, target, getargs) in some]\n            comborules.append((combined, rules))\n\n    def build(self, _name, *anons, **query):\n        ''' Build an URL by filling the wildcards in a rule. '''\n        builder = self.builder.get(_name)\n        if not builder: raise RouteBuildError(\"No route with that name.\", _name)\n        try:\n            for i, value in enumerate(anons): query['anon%d'%i] = value\n            url = ''.join([f(query.pop(n)) if n else f for (n,f) in builder])\n            return url if not query else url+'?'+urlencode(query)\n        except KeyError:\n            raise RouteBuildError('Missing URL argument: %r' % _e().args[0])\n\n    def match(self, environ):\n        ''' Return a (target, url_agrs) tuple or raise HTTPError(400/404/405). '''\n        verb = environ['REQUEST_METHOD'].upper()\n        path = environ['PATH_INFO'] or '/'\n        target = None\n        if verb == 'HEAD':\n            methods = ['PROXY', verb, 'GET', 'ANY']\n        else:\n            methods = ['PROXY', verb, 'ANY']\n\n        for method in methods:\n            if method in self.static and path in self.static[method]:\n                target, getargs = self.static[method][path]\n                return target, getargs(path) if getargs else {}\n            elif method in self.dyna_regexes:\n                for combined, rules in self.dyna_regexes[method]:\n                    match = combined(path)\n                    if match:\n                        target, getargs = rules[match.lastindex - 1]\n                        return target, getargs(path) if getargs else {}\n\n        # No matching route found. Collect alternative methods for 405 response\n        allowed = set([])\n        nocheck = set(methods)\n        for method in set(self.static) - nocheck:\n            if path in self.static[method]:\n                allowed.add(method)\n        for method in set(self.dyna_regexes) - allowed - nocheck:\n            for combined, rules in self.dyna_regexes[method]:\n                match = combined(path)\n                if match:\n                    allowed.add(method)\n        if allowed:\n            allow_header = \",\".join(sorted(allowed))\n            raise HTTPError(405, \"Method not allowed.\", Allow=allow_header)\n\n        # No matching route and no alternative method found. We give up\n        raise HTTPError(404, \"Not found: \" + repr(path))\n\n\n\n\n\n\nclass Route(object):\n    ''' This class wraps a route callback along with route specific metadata and\n        configuration and applies Plugins on demand. It is also responsible for\n        turing an URL path rule into a regular expression usable by the Router.\n    '''\n\n    def __init__(self, app, rule, method, callback, name=None,\n                 plugins=None, skiplist=None, **config):\n        #: The application this route is installed to.\n        self.app = app\n        #: The path-rule string (e.g. ``/wiki/:page``).\n        self.rule = rule\n        #: The HTTP method as a string (e.g. ``GET``).\n        self.method = method\n        #: The original callback with no plugins applied. Useful for introspection.\n        self.callback = callback\n        #: The name of the route (if specified) or ``None``.\n        self.name = name or None\n        #: A list of route-specific plugins (see :meth:`Bottle.route`).\n        self.plugins = plugins or []\n        #: A list of plugins to not apply to this route (see :meth:`Bottle.route`).\n        self.skiplist = skiplist or []\n        #: Additional keyword arguments passed to the :meth:`Bottle.route`\n        #: decorator are stored in this dictionary. Used for route-specific\n        #: plugin configuration and meta-data.\n        self.config = ConfigDict().load_dict(config, make_namespaces=True)\n\n    def __call__(self, *a, **ka):\n        depr(\"Some APIs changed to return Route() instances instead of\"\\\n             \" callables. Make sure to use the Route.call method and not to\"\\\n             \" call Route instances directly.\") #0.12\n        return self.call(*a, **ka)\n\n    @cached_property\n    def call(self):\n        ''' The route callback with all plugins applied. This property is\n            created on demand and then cached to speed up subsequent requests.'''\n        return self._make_callback()\n\n    def reset(self):\n        ''' Forget any cached values. The next time :attr:`call` is accessed,\n            all plugins are re-applied. '''\n        self.__dict__.pop('call', None)\n\n    def prepare(self):\n        ''' Do all on-demand work immediately (useful for debugging).'''\n        self.call\n\n    @property\n    def _context(self):\n        depr('Switch to Plugin API v2 and access the Route object directly.')  #0.12\n        return dict(rule=self.rule, method=self.method, callback=self.callback,\n                    name=self.name, app=self.app, config=self.config,\n                    apply=self.plugins, skip=self.skiplist)\n\n    def all_plugins(self):\n        ''' Yield all Plugins affecting this route. '''\n        unique = set()\n        for p in reversed(self.app.plugins + self.plugins):\n            if True in self.skiplist: break\n            name = getattr(p, 'name', False)\n            if name and (name in self.skiplist or name in unique): continue\n            if p in self.skiplist or type(p) in self.skiplist: continue\n            if name: unique.add(name)\n            yield p\n\n    def _make_callback(self):\n        callback = self.callback\n        for plugin in self.all_plugins():\n            try:\n                if hasattr(plugin, 'apply'):\n                    api = getattr(plugin, 'api', 1)\n                    context = self if api > 1 else self._context\n                    callback = plugin.apply(callback, context)\n                else:\n                    callback = plugin(callback)\n            except RouteReset: # Try again with changed configuration.\n                return self._make_callback()\n            if not callback is self.callback:\n                update_wrapper(callback, self.callback)\n        return callback\n\n    def get_undecorated_callback(self):\n        ''' Return the callback. If the callback is a decorated function, try to\n            recover the original function. '''\n        func = self.callback\n        func = getattr(func, '__func__' if py3k else 'im_func', func)\n        closure_attr = '__closure__' if py3k else 'func_closure'\n        while hasattr(func, closure_attr) and getattr(func, closure_attr):\n            func = getattr(func, closure_attr)[0].cell_contents\n        return func\n\n    def get_callback_args(self):\n        ''' Return a list of argument names the callback (most likely) accepts\n            as keyword arguments. If the callback is a decorated function, try\n            to recover the original function before inspection. '''\n        return getargspec(self.get_undecorated_callback())[0]\n\n    def get_config(self, key, default=None):\n        ''' Lookup a config field and return its value, first checking the\n            route.config, then route.app.config.'''\n        for conf in (self.config, self.app.conifg):\n            if key in conf: return conf[key]\n        return default\n\n    def __repr__(self):\n        cb = self.get_undecorated_callback()\n        return '<%s %r %r>' % (self.method, self.rule, cb)\n\n\n\n\n\n\n###############################################################################\n# Application Object ###########################################################\n###############################################################################\n\n\nclass Bottle(object):\n    \"\"\" Each Bottle object represents a single, distinct web application and\n        consists of routes, callbacks, plugins, resources and configuration.\n        Instances are callable WSGI applications.\n\n        :param catchall: If true (default), handle all exceptions. Turn off to\n                         let debugging middleware handle exceptions.\n    \"\"\"\n\n    def __init__(self, catchall=True, autojson=True):\n\n        #: A :class:`ConfigDict` for app specific configuration.\n        self.config = ConfigDict()\n        self.config._on_change = functools.partial(self.trigger_hook, 'config')\n        self.config.meta_set('autojson', 'validate', bool)\n        self.config.meta_set('catchall', 'validate', bool)\n        self.config['catchall'] = catchall\n        self.config['autojson'] = autojson\n\n        #: A :class:`ResourceManager` for application files\n        self.resources = ResourceManager()\n\n        self.routes = [] # List of installed :class:`Route` instances.\n        self.router = Router() # Maps requests to :class:`Route` instances.\n        self.error_handler = {}\n\n        # Core plugins\n        self.plugins = [] # List of installed plugins.\n        if self.config['autojson']:\n            self.install(JSONPlugin())\n        self.install(TemplatePlugin())\n\n    #: If true, most exceptions are caught and returned as :exc:`HTTPError`\n    catchall = DictProperty('config', 'catchall')\n\n    __hook_names = 'before_request', 'after_request', 'app_reset', 'config'\n    __hook_reversed = 'after_request'\n\n    @cached_property\n    def _hooks(self):\n        return dict((name, []) for name in self.__hook_names)\n\n    def add_hook(self, name, func):\n        ''' Attach a callback to a hook. Three hooks are currently implemented:\n\n            before_request\n                Executed once before each request. The request context is\n                available, but no routing has happened yet.\n            after_request\n                Executed once after each request regardless of its outcome.\n            app_reset\n                Called whenever :meth:`Bottle.reset` is called.\n        '''\n        if name in self.__hook_reversed:\n            self._hooks[name].insert(0, func)\n        else:\n            self._hooks[name].append(func)\n\n    def remove_hook(self, name, func):\n        ''' Remove a callback from a hook. '''\n        if name in self._hooks and func in self._hooks[name]:\n            self._hooks[name].remove(func)\n            return True\n\n    def trigger_hook(self, __name, *args, **kwargs):\n        ''' Trigger a hook and return a list of results. '''\n        return [hook(*args, **kwargs) for hook in self._hooks[__name][:]]\n\n    def hook(self, name):\n        \"\"\" Return a decorator that attaches a callback to a hook. See\n            :meth:`add_hook` for details.\"\"\"\n        def decorator(func):\n            self.add_hook(name, func)\n            return func\n        return decorator\n\n    def mount(self, prefix, app, **options):\n        ''' Mount an application (:class:`Bottle` or plain WSGI) to a specific\n            URL prefix. Example::\n\n                root_app.mount('/admin/', admin_app)\n\n            :param prefix: path prefix or `mount-point`. If it ends in a slash,\n                that slash is mandatory.\n            :param app: an instance of :class:`Bottle` or a WSGI application.\n\n            All other parameters are passed to the underlying :meth:`route` call.\n        '''\n        if isinstance(app, basestring):\n            depr('Parameter order of Bottle.mount() changed.', True) # 0.10\n\n        segments = [p for p in prefix.split('/') if p]\n        if not segments: raise ValueError('Empty path prefix.')\n        path_depth = len(segments)\n\n        def mountpoint_wrapper():\n            try:\n                request.path_shift(path_depth)\n                rs = HTTPResponse([])\n                def start_response(status, headerlist, exc_info=None):\n                    if exc_info:\n                        try:\n                            _raise(*exc_info)\n                        finally:\n                            exc_info = None\n                    rs.status = status\n                    for name, value in headerlist: rs.add_header(name, value)\n                    return rs.body.append\n                body = app(request.environ, start_response)\n                if body and rs.body: body = itertools.chain(rs.body, body)\n                rs.body = body or rs.body\n                return rs\n            finally:\n                request.path_shift(-path_depth)\n\n        options.setdefault('skip', True)\n        options.setdefault('method', 'PROXY')\n        options.setdefault('mountpoint', {'prefix': prefix, 'target': app})\n        options['callback'] = mountpoint_wrapper\n\n        self.route('/%s/<:re:.*>' % '/'.join(segments), **options)\n        if not prefix.endswith('/'):\n            self.route('/' + '/'.join(segments), **options)\n\n    def merge(self, routes):\n        ''' Merge the routes of another :class:`Bottle` application or a list of\n            :class:`Route` objects into this application. The routes keep their\n            'owner', meaning that the :data:`Route.app` attribute is not\n            changed. '''\n        if isinstance(routes, Bottle):\n            routes = routes.routes\n        for route in routes:\n            self.add_route(route)\n\n    def install(self, plugin):\n        ''' Add a plugin to the list of plugins and prepare it for being\n            applied to all routes of this application. A plugin may be a simple\n            decorator or an object that implements the :class:`Plugin` API.\n        '''\n        if hasattr(plugin, 'setup'): plugin.setup(self)\n        if not callable(plugin) and not hasattr(plugin, 'apply'):\n            raise TypeError(\"Plugins must be callable or implement .apply()\")\n        self.plugins.append(plugin)\n        self.reset()\n        return plugin\n\n    def uninstall(self, plugin):\n        ''' Uninstall plugins. Pass an instance to remove a specific plugin, a type\n            object to remove all plugins that match that type, a string to remove\n            all plugins with a matching ``name`` attribute or ``True`` to remove all\n            plugins. Return the list of removed plugins. '''\n        removed, remove = [], plugin\n        for i, plugin in list(enumerate(self.plugins))[::-1]:\n            if remove is True or remove is plugin or remove is type(plugin) \\\n            or getattr(plugin, 'name', True) == remove:\n                removed.append(plugin)\n                del self.plugins[i]\n                if hasattr(plugin, 'close'): plugin.close()\n        if removed: self.reset()\n        return removed\n\n    def reset(self, route=None):\n        ''' Reset all routes (force plugins to be re-applied) and clear all\n            caches. If an ID or route object is given, only that specific route\n            is affected. '''\n        if route is None: routes = self.routes\n        elif isinstance(route, Route): routes = [route]\n        else: routes = [self.routes[route]]\n        for route in routes: route.reset()\n        if DEBUG:\n            for route in routes: route.prepare()\n        self.trigger_hook('app_reset')\n\n    def close(self):\n        ''' Close the application and all installed plugins. '''\n        for plugin in self.plugins:\n            if hasattr(plugin, 'close'): plugin.close()\n        self.stopped = True\n\n    def run(self, **kwargs):\n        ''' Calls :func:`run` with the same parameters. '''\n        run(self, **kwargs)\n\n    def match(self, environ):\n        \"\"\" Search for a matching route and return a (:class:`Route` , urlargs)\n            tuple. The second value is a dictionary with parameters extracted\n            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.\"\"\"\n        return self.router.match(environ)\n\n    def get_url(self, routename, **kargs):\n        \"\"\" Return a string that matches a named route \"\"\"\n        scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'\n        location = self.router.build(routename, **kargs).lstrip('/')\n        return urljoin(urljoin('/', scriptname), location)\n\n    def add_route(self, route):\n        ''' Add a route object, but do not change the :data:`Route.app`\n            attribute.'''\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n\n    def route(self, path=None, method='GET', callback=None, name=None,\n              apply=None, skip=None, **config):\n        \"\"\" A decorator to bind a function to a request URL. Example::\n\n                @app.route('/hello/:name')\n                def hello(name):\n                    return 'Hello %s' % name\n\n            The ``:name`` part is a wildcard. See :class:`Router` for syntax\n            details.\n\n            :param path: Request path or a list of paths to listen to. If no\n              path is specified, it is automatically generated from the\n              signature of the function.\n            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of\n              methods to listen to. (default: `GET`)\n            :param callback: An optional shortcut to avoid the decorator\n              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``\n            :param name: The name for this route. (default: None)\n            :param apply: A decorator or plugin or a list of plugins. These are\n              applied to the route callback in addition to installed plugins.\n            :param skip: A list of plugins, plugin classes or names. Matching\n              plugins are not installed to this route. ``True`` skips all.\n\n            Any additional keyword arguments are stored as route-specific\n            configuration and passed to plugins (see :meth:`Plugin.apply`).\n        \"\"\"\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n        def decorator(callback):\n            # TODO: Documentation and tests\n            if isinstance(callback, basestring): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback, name=name,\n                                  plugins=plugins, skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n        return decorator(callback) if callback else decorator\n\n    def get(self, path=None, method='GET', **options):\n        \"\"\" Equals :meth:`route`. \"\"\"\n        return self.route(path, method, **options)\n\n    def post(self, path=None, method='POST', **options):\n        \"\"\" Equals :meth:`route` with a ``POST`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def put(self, path=None, method='PUT', **options):\n        \"\"\" Equals :meth:`route` with a ``PUT`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def delete(self, path=None, method='DELETE', **options):\n        \"\"\" Equals :meth:`route` with a ``DELETE`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def error(self, code=500):\n        \"\"\" Decorator: Register an output handler for a HTTP error code\"\"\"\n        def wrapper(handler):\n            self.error_handler[int(code)] = handler\n            return handler\n        return wrapper\n\n    def default_error_handler(self, res):\n        return tob(template(ERROR_PAGE_TEMPLATE, e=res))\n\n    def _handle(self, environ):\n        try:\n\n            environ['bottle.app'] = self\n            request.bind(environ)\n            response.bind()\n\n            path = environ['bottle.raw_path'] = environ['PATH_INFO']\n            if py3k:\n                try:\n                    environ['PATH_INFO'] = path.encode('latin1').decode('utf8')\n                except UnicodeError:\n                    return HTTPError(400, 'Invalid path string. Expected UTF-8')\n\n            try:\n                self.trigger_hook('before_request')\n                route, args = self.router.match(environ)\n                environ['route.handle'] = route\n                environ['bottle.route'] = route\n                environ['route.url_args'] = args\n                return route.call(**args)\n            finally:\n                self.trigger_hook('after_request')\n\n        except HTTPResponse:\n            return _e()\n        except RouteReset:\n            route.reset()\n            return self._handle(environ)\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception:\n            if not self.catchall: raise\n            stacktrace = format_exc()\n            environ['wsgi.errors'].write(stacktrace)\n            return HTTPError(500, \"Internal Server Error\", _e(), stacktrace)\n\n    def _cast(self, out, peek=None):\n        \"\"\" Try to convert the parameter into something WSGI compatible and set\n        correct HTTP headers when possible.\n        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,\n        iterable of strings and iterable of unicodes\n        \"\"\"\n\n        # Empty output is done here\n        if not out:\n            if 'Content-Length' not in response:\n                response['Content-Length'] = 0\n            return []\n        # Join lists of byte or unicode strings. Mixed lists are NOT supported\n        if isinstance(out, (tuple, list))\\\n        and isinstance(out[0], (bytes, unicode)):\n            out = out[0][0:0].join(out) # b'abc'[0:0] -> b''\n        # Encode unicode strings\n        if isinstance(out, unicode):\n            out = out.encode(response.charset)\n        # Byte Strings are just returned\n        if isinstance(out, bytes):\n            if 'Content-Length' not in response:\n                response['Content-Length'] = len(out)\n            return [out]\n        # HTTPError or HTTPException (recursive, because they may wrap anything)\n        # TODO: Handle these explicitly in handle() or make them iterable.\n        if isinstance(out, HTTPError):\n            out.apply(response)\n            out = self.error_handler.get(out.status_code, self.default_error_handler)(out)\n            return self._cast(out)\n        if isinstance(out, HTTPResponse):\n            out.apply(response)\n            return self._cast(out.body)\n\n        # File-like objects.\n        if hasattr(out, 'read'):\n            if 'wsgi.file_wrapper' in request.environ:\n                return request.environ['wsgi.file_wrapper'](out)\n            elif hasattr(out, 'close') or not hasattr(out, '__iter__'):\n                return WSGIFileWrapper(out)\n\n        # Handle Iterables. We peek into them to detect their inner type.\n        try:\n            iout = iter(out)\n            first = next(iout)\n            while not first:\n                first = next(iout)\n        except StopIteration:\n            return self._cast('')\n        except HTTPResponse:\n            first = _e()\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception:\n            if not self.catchall: raise\n            first = HTTPError(500, 'Unhandled exception', _e(), format_exc())\n\n        # These are the inner types allowed in iterator or generator objects.\n        if isinstance(first, HTTPResponse):\n            return self._cast(first)\n        elif isinstance(first, bytes):\n            new_iter = itertools.chain([first], iout)\n        elif isinstance(first, unicode):\n            encoder = lambda x: x.encode(response.charset)\n            new_iter = imap(encoder, itertools.chain([first], iout))\n        else:\n            msg = 'Unsupported response type: %s' % type(first)\n            return self._cast(HTTPError(500, msg))\n        if hasattr(out, 'close'):\n            new_iter = _closeiter(new_iter, out.close)\n        return new_iter\n\n    def wsgi(self, environ, start_response):\n        \"\"\" The bottle WSGI-interface. \"\"\"\n        try:\n            out = self._cast(self._handle(environ))\n            # rfc2616 section 4.3\n            if response._status_code in (100, 101, 204, 304)\\\n            or environ['REQUEST_METHOD'] == 'HEAD':\n                if hasattr(out, 'close'): out.close()\n                out = []\n            start_response(response._status_line, response.headerlist)\n            return out\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception:\n            if not self.catchall: raise\n            err = '<h1>Critical error while processing request: %s</h1>' \\\n                  % html_escape(environ.get('PATH_INFO', '/'))\n            if DEBUG:\n                err += '<h2>Error:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       '<h2>Traceback:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       % (html_escape(repr(_e())), html_escape(format_exc()))\n            environ['wsgi.errors'].write(err)\n            headers = [('Content-Type', 'text/html; charset=UTF-8')]\n            start_response('500 INTERNAL SERVER ERROR', headers, sys.exc_info())\n            return [tob(err)]\n\n    def __call__(self, environ, start_response):\n        ''' Each instance of :class:'Bottle' is a WSGI application. '''\n        return self.wsgi(environ, start_response)\n\n\n\n\n\n\n###############################################################################\n# HTTP and WSGI Tools ##########################################################\n###############################################################################\n\nclass BaseRequest(object):\n    \"\"\" A wrapper for WSGI environment dictionaries that adds a lot of\n        convenient access methods and properties. Most of them are read-only.\n\n        Adding new attributes to a request actually adds them to the environ\n        dictionary (as 'bottle.request.ext.<name>'). This is the recommended\n        way to store and access request-specific data.\n    \"\"\"\n\n    __slots__ = ('environ')\n\n    #: Maximum size of memory buffer for :attr:`body` in bytes.\n    MEMFILE_MAX = 102400\n\n    def __init__(self, environ=None):\n        \"\"\" Wrap a WSGI environ dictionary. \"\"\"\n        #: The wrapped WSGI environ dictionary. This is the only real attribute.\n        #: All other attributes actually are read-only properties.\n        self.environ = {} if environ is None else environ\n        self.environ['bottle.request'] = self\n\n    @DictProperty('environ', 'bottle.app', read_only=True)\n    def app(self):\n        ''' Bottle application handling this request. '''\n        raise RuntimeError('This request is not connected to an application.')\n\n    @DictProperty('environ', 'bottle.route', read_only=True)\n    def route(self):\n        \"\"\" The bottle :class:`Route` object that matches this request. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @DictProperty('environ', 'route.url_args', read_only=True)\n    def url_args(self):\n        \"\"\" The arguments extracted from the URL. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @property\n    def path(self):\n        ''' The value of ``PATH_INFO`` with exactly one prefixed slash (to fix\n            broken clients and avoid the \"empty path\" edge case). '''\n        return '/' + self.environ.get('PATH_INFO','').lstrip('/')\n\n    @property\n    def method(self):\n        ''' The ``REQUEST_METHOD`` value as an uppercase string. '''\n        return self.environ.get('REQUEST_METHOD', 'GET').upper()\n\n    @DictProperty('environ', 'bottle.request.headers', read_only=True)\n    def headers(self):\n        ''' A :class:`WSGIHeaderDict` that provides case-insensitive access to\n            HTTP request headers. '''\n        return WSGIHeaderDict(self.environ)\n\n    def get_header(self, name, default=None):\n        ''' Return the value of a request header, or a given default value. '''\n        return self.headers.get(name, default)\n\n    @DictProperty('environ', 'bottle.request.cookies', read_only=True)\n    def cookies(self):\n        \"\"\" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT\n            decoded. Use :meth:`get_cookie` if you expect signed cookies. \"\"\"\n        cookies = SimpleCookie(self.environ.get('HTTP_COOKIE','')).values()\n        return FormsDict((c.key, c.value) for c in cookies)\n\n    def get_cookie(self, key, default=None, secret=None):\n        \"\"\" Return the content of a cookie. To read a `Signed Cookie`, the\n            `secret` must match the one used to create the cookie (see\n            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing\n            cookie or wrong signature), return a default value. \"\"\"\n        value = self.cookies.get(key)\n        if secret and value:\n            dec = cookie_decode(value, secret) # (key, value) tuple or None\n            return dec[1] if dec and dec[0] == key else default\n        return value or default\n\n    @DictProperty('environ', 'bottle.request.query', read_only=True)\n    def query(self):\n        ''' The :attr:`query_string` parsed into a :class:`FormsDict`. These\n            values are sometimes called \"URL arguments\" or \"GET parameters\", but\n            not to be confused with \"URL wildcards\" as they are provided by the\n            :class:`Router`. '''\n        get = self.environ['bottle.get'] = FormsDict()\n        pairs = _parse_qsl(self.environ.get('QUERY_STRING', ''))\n        for key, value in pairs:\n            get[key] = value\n        return get\n\n    @DictProperty('environ', 'bottle.request.forms', read_only=True)\n    def forms(self):\n        \"\"\" Form values parsed from an `url-encoded` or `multipart/form-data`\n            encoded POST or PUT request body. The result is returned as a\n            :class:`FormsDict`. All keys and values are strings. File uploads\n            are stored separately in :attr:`files`. \"\"\"\n        forms = FormsDict()\n        for name, item in self.POST.allitems():\n            if not isinstance(item, FileUpload):\n                forms[name] = item\n        return forms\n\n    @DictProperty('environ', 'bottle.request.params', read_only=True)\n    def params(self):\n        \"\"\" A :class:`FormsDict` with the combined values of :attr:`query` and\n            :attr:`forms`. File uploads are stored in :attr:`files`. \"\"\"\n        params = FormsDict()\n        for key, value in self.query.allitems():\n            params[key] = value\n        for key, value in self.forms.allitems():\n            params[key] = value\n        return params\n\n    @DictProperty('environ', 'bottle.request.files', read_only=True)\n    def files(self):\n        \"\"\" File uploads parsed from `multipart/form-data` encoded POST or PUT\n            request body. The values are instances of :class:`FileUpload`.\n\n        \"\"\"\n        files = FormsDict()\n        for name, item in self.POST.allitems():\n            if isinstance(item, FileUpload):\n                files[name] = item\n        return files\n\n    @DictProperty('environ', 'bottle.request.json', read_only=True)\n    def json(self):\n        ''' If the ``Content-Type`` header is ``application/json``, this\n            property holds the parsed content of the request body. Only requests\n            smaller than :attr:`MEMFILE_MAX` are processed to avoid memory\n            exhaustion. '''\n        ctype = self.environ.get('CONTENT_TYPE', '').lower().split(';')[0]\n        if ctype == 'application/json':\n            b = self._get_body_string()\n            if not b:\n                return None\n            return json_loads(b)\n        return None\n\n    def _iter_body(self, read, bufsize):\n        maxread = max(0, self.content_length)\n        while maxread:\n            part = read(min(maxread, bufsize))\n            if not part: break\n            yield part\n            maxread -= len(part)\n\n    def _iter_chunked(self, read, bufsize):\n        err = HTTPError(400, 'Error while parsing chunked transfer body.')\n        rn, sem, bs = tob('\\r\\n'), tob(';'), tob('')\n        while True:\n            header = read(1)\n            while header[-2:] != rn:\n                c = read(1)\n                header += c\n                if not c: raise err\n                if len(header) > bufsize: raise err\n            size, _, _ = header.partition(sem)\n            try:\n                maxread = int(tonat(size.strip()), 16)\n            except ValueError:\n                raise err\n            if maxread == 0: break\n            buff = bs\n            while maxread > 0:\n                if not buff:\n                    buff = read(min(maxread, bufsize))\n                part, buff = buff[:maxread], buff[maxread:]\n                if not part: raise err\n                yield part\n                maxread -= len(part)\n            if read(2) != rn:\n                raise err\n\n    @DictProperty('environ', 'bottle.request.body', read_only=True)\n    def _body(self):\n        body_iter = self._iter_chunked if self.chunked else self._iter_body\n        read_func = self.environ['wsgi.input'].read\n        body, body_size, is_temp_file = BytesIO(), 0, False\n        for part in body_iter(read_func, self.MEMFILE_MAX):\n            body.write(part)\n            body_size += len(part)\n            if not is_temp_file and body_size > self.MEMFILE_MAX:\n                body, tmp = TemporaryFile(mode='w+b'), body\n                body.write(tmp.getvalue())\n                del tmp\n                is_temp_file = True\n        self.environ['wsgi.input'] = body\n        body.seek(0)\n        return body\n\n    def _get_body_string(self):\n        ''' read body until content-length or MEMFILE_MAX into a string. Raise\n            HTTPError(413) on requests that are to large. '''\n        clen = self.content_length\n        if clen > self.MEMFILE_MAX:\n            raise HTTPError(413, 'Request to large')\n        if clen < 0: clen = self.MEMFILE_MAX + 1\n        data = self.body.read(clen)\n        if len(data) > self.MEMFILE_MAX: # Fail fast\n            raise HTTPError(413, 'Request to large')\n        return data\n\n    @property\n    def body(self):\n        \"\"\" The HTTP request body as a seek-able file-like object. Depending on\n            :attr:`MEMFILE_MAX`, this is either a temporary file or a\n            :class:`io.BytesIO` instance. Accessing this property for the first\n            time reads and replaces the ``wsgi.input`` environ variable.\n            Subsequent accesses just do a `seek(0)` on the file object. \"\"\"\n        self._body.seek(0)\n        return self._body\n\n    @property\n    def chunked(self):\n        ''' True if Chunked transfer encoding was. '''\n        return 'chunked' in self.environ.get('HTTP_TRANSFER_ENCODING', '').lower()\n\n    #: An alias for :attr:`query`.\n    GET = query\n\n    @DictProperty('environ', 'bottle.request.post', read_only=True)\n    def POST(self):\n        \"\"\" The values of :attr:`forms` and :attr:`files` combined into a single\n            :class:`FormsDict`. Values are either strings (form values) or\n            instances of :class:`cgi.FieldStorage` (file uploads).\n        \"\"\"\n        post = FormsDict()\n        # We default to application/x-www-form-urlencoded for everything that\n        # is not multipart and take the fast path (also: 3.1 workaround)\n        if not self.content_type.startswith('multipart/'):\n            pairs = _parse_qsl(tonat(self._get_body_string(), 'latin1'))\n            for key, value in pairs:\n                post[key] = value\n            return post\n\n        safe_env = {'QUERY_STRING':''} # Build a safe environment for cgi\n        for key in ('REQUEST_METHOD', 'CONTENT_TYPE', 'CONTENT_LENGTH'):\n            if key in self.environ: safe_env[key] = self.environ[key]\n        args = dict(fp=self.body, environ=safe_env, keep_blank_values=True)\n        if py31:\n            args['fp'] = NCTextIOWrapper(args['fp'], encoding='utf8',\n                                         newline='\\n')\n        elif py3k:\n            args['encoding'] = 'utf8'\n        data = cgi.FieldStorage(**args)\n        self['_cgi.FieldStorage'] = data #http://bugs.python.org/issue18394#msg207958\n        data = data.list or []\n        for item in data:\n            if item.filename is None:\n                post[item.name] = item.value\n            else:\n                post[item.name] = FileUpload(item.file, item.name,\n                                             item.filename, item.headers)\n        return post\n\n    @property\n    def url(self):\n        \"\"\" The full request URI including hostname and scheme. If your app\n            lives behind a reverse proxy or load balancer and you get confusing\n            results, make sure that the ``X-Forwarded-Host`` header is set\n            correctly. \"\"\"\n        return self.urlparts.geturl()\n\n    @DictProperty('environ', 'bottle.request.urlparts', read_only=True)\n    def urlparts(self):\n        ''' The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.\n            The tuple contains (scheme, host, path, query_string and fragment),\n            but the fragment is always empty because it is not visible to the\n            server. '''\n        env = self.environ\n        http = env.get('HTTP_X_FORWARDED_PROTO') or env.get('wsgi.url_scheme', 'http')\n        host = env.get('HTTP_X_FORWARDED_HOST') or env.get('HTTP_HOST')\n        if not host:\n            # HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.\n            host = env.get('SERVER_NAME', '127.0.0.1')\n            port = env.get('SERVER_PORT')\n            if port and port != ('80' if http == 'http' else '443'):\n                host += ':' + port\n        path = urlquote(self.fullpath)\n        return UrlSplitResult(http, host, path, env.get('QUERY_STRING'), '')\n\n    @property\n    def fullpath(self):\n        \"\"\" Request path including :attr:`script_name` (if present). \"\"\"\n        return urljoin(self.script_name, self.path.lstrip('/'))\n\n    @property\n    def query_string(self):\n        \"\"\" The raw :attr:`query` part of the URL (everything in between ``?``\n            and ``#``) as a string. \"\"\"\n        return self.environ.get('QUERY_STRING', '')\n\n    @property\n    def script_name(self):\n        ''' The initial portion of the URL's `path` that was removed by a higher\n            level (server or routing middleware) before the application was\n            called. This script path is returned with leading and tailing\n            slashes. '''\n        script_name = self.environ.get('SCRIPT_NAME', '').strip('/')\n        return '/' + script_name + '/' if script_name else '/'\n\n    def path_shift(self, shift=1):\n        ''' Shift path segments from :attr:`path` to :attr:`script_name` and\n            vice versa.\n\n           :param shift: The number of path segments to shift. May be negative\n                         to change the shift direction. (default: 1)\n        '''\n        script = self.environ.get('SCRIPT_NAME','/')\n        self['SCRIPT_NAME'], self['PATH_INFO'] = path_shift(script, self.path, shift)\n\n    @property\n    def content_length(self):\n        ''' The request body length as an integer. The client is responsible to\n            set this header. Otherwise, the real length of the body is unknown\n            and -1 is returned. In this case, :attr:`body` will be empty. '''\n        return int(self.environ.get('CONTENT_LENGTH') or -1)\n\n    @property\n    def content_type(self):\n        ''' The Content-Type header as a lowercase-string (default: empty). '''\n        return self.environ.get('CONTENT_TYPE', '').lower()\n\n    @property\n    def is_xhr(self):\n        ''' True if the request was triggered by a XMLHttpRequest. This only\n            works with JavaScript libraries that support the `X-Requested-With`\n            header (most of the popular libraries do). '''\n        requested_with = self.environ.get('HTTP_X_REQUESTED_WITH','')\n        return requested_with.lower() == 'xmlhttprequest'\n\n    @property\n    def is_ajax(self):\n        ''' Alias for :attr:`is_xhr`. \"Ajax\" is not the right term. '''\n        return self.is_xhr\n\n    @property\n    def auth(self):\n        \"\"\" HTTP authentication data as a (user, password) tuple. This\n            implementation currently supports basic (not digest) authentication\n            only. If the authentication happened at a higher level (e.g. in the\n            front web-server or a middleware), the password field is None, but\n            the user field is looked up from the ``REMOTE_USER`` environ\n            variable. On any errors, None is returned. \"\"\"\n        basic = parse_auth(self.environ.get('HTTP_AUTHORIZATION',''))\n        if basic: return basic\n        ruser = self.environ.get('REMOTE_USER')\n        if ruser: return (ruser, None)\n        return None\n\n    @property\n    def remote_route(self):\n        \"\"\" A list of all IPs that were involved in this request, starting with\n            the client IP and followed by zero or more proxies. This does only\n            work if all proxies support the ```X-Forwarded-For`` header. Note\n            that this information can be forged by malicious clients. \"\"\"\n        proxy = self.environ.get('HTTP_X_FORWARDED_FOR')\n        if proxy: return [ip.strip() for ip in proxy.split(',')]\n        remote = self.environ.get('REMOTE_ADDR')\n        return [remote] if remote else []\n\n    @property\n    def remote_addr(self):\n        \"\"\" The client IP as a string. Note that this information can be forged\n            by malicious clients. \"\"\"\n        route = self.remote_route\n        return route[0] if route else None\n\n    def copy(self):\n        \"\"\" Return a new :class:`Request` with a shallow :attr:`environ` copy. \"\"\"\n        return Request(self.environ.copy())\n\n    def get(self, value, default=None): return self.environ.get(value, default)\n    def __getitem__(self, key): return self.environ[key]\n    def __delitem__(self, key): self[key] = \"\"; del(self.environ[key])\n    def __iter__(self): return iter(self.environ)\n    def __len__(self): return len(self.environ)\n    def keys(self): return self.environ.keys()\n    def __setitem__(self, key, value):\n        \"\"\" Change an environ value and clear all caches that depend on it. \"\"\"\n\n        if self.environ.get('bottle.request.readonly'):\n            raise KeyError('The environ dictionary is read-only.')\n\n        self.environ[key] = value\n        todelete = ()\n\n        if key == 'wsgi.input':\n            todelete = ('body', 'forms', 'files', 'params', 'post', 'json')\n        elif key == 'QUERY_STRING':\n            todelete = ('query', 'params')\n        elif key.startswith('HTTP_'):\n            todelete = ('headers', 'cookies')\n\n        for key in todelete:\n            self.environ.pop('bottle.request.'+key, None)\n\n    def __repr__(self):\n        return '<%s: %s %s>' % (self.__class__.__name__, self.method, self.url)\n\n    def __getattr__(self, name):\n        ''' Search in self.environ for additional user defined attributes. '''\n        try:\n            var = self.environ['bottle.request.ext.%s'%name]\n            return var.__get__(self) if hasattr(var, '__get__') else var\n        except KeyError:\n            raise AttributeError('Attribute %r not defined.' % name)\n\n    def __setattr__(self, name, value):\n        if name == 'environ': return object.__setattr__(self, name, value)\n        self.environ['bottle.request.ext.%s'%name] = value\n\n\ndef _hkey(key):\n    if '\\n' in key or '\\r' in key or '\\0' in key:\n        raise ValueError(\"Header names must not contain control characters: %r\" % key)\n    return key.title().replace('_', '-')\n\n\ndef _hval(value):\n    value = tonat(value)\n    if '\\n' in value or '\\r' in value or '\\0' in value:\n        raise ValueError(\"Header value must not contain control characters: %r\" % value)\n    return value\n\n\n\nclass HeaderProperty(object):\n    def __init__(self, name, reader=None, writer=None, default=''):\n        self.name, self.default = name, default\n        self.reader, self.writer = reader, writer\n        self.__doc__ = 'Current value of the %r header.' % name.title()\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.get_header(self.name, self.default)\n        return self.reader(value) if self.reader else value\n\n    def __set__(self, obj, value):\n        obj[self.name] = self.writer(value) if self.writer else value\n\n    def __delete__(self, obj):\n        del obj[self.name]\n\n\nclass BaseResponse(object):\n    \"\"\" Storage class for a response body as well as headers and cookies.\n\n        This class does support dict-like case-insensitive item-access to\n        headers, but is NOT a dict. Most notably, iterating over a response\n        yields parts of the body and not the headers.\n\n        :param body: The response body as one of the supported types.\n        :param status: Either an HTTP status code (e.g. 200) or a status line\n                       including the reason phrase (e.g. '200 OK').\n        :param headers: A dictionary or a list of name-value pairs.\n\n        Additional keyword arguments are added to the list of headers.\n        Underscores in the header name are replaced with dashes.\n    \"\"\"\n\n    default_status = 200\n    default_content_type = 'text/html; charset=UTF-8'\n\n    # Header blacklist for specific response codes\n    # (rfc2616 section 10.2.3 and 10.3.5)\n    bad_headers = {\n        204: set(('Content-Type',)),\n        304: set(('Allow', 'Content-Encoding', 'Content-Language',\n                  'Content-Length', 'Content-Range', 'Content-Type',\n                  'Content-Md5', 'Last-Modified'))}\n\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        self._cookies = None\n        self._headers = {}\n        self.body = body\n        self.status = status or self.default_status\n        if headers:\n            if isinstance(headers, dict):\n                headers = headers.items()\n            for name, value in headers:\n                self.add_header(name, value)\n        if more_headers:\n            for name, value in more_headers.items():\n                self.add_header(name, value)\n\n    def copy(self, cls=None):\n        ''' Returns a copy of self. '''\n        cls = cls or BaseResponse\n        assert issubclass(cls, BaseResponse)\n        copy = cls()\n        copy.status = self.status\n        copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())\n        if self._cookies:\n            copy._cookies = SimpleCookie()\n            copy._cookies.load(self._cookies.output(header=''))\n        return copy\n\n    def __iter__(self):\n        return iter(self.body)\n\n    def close(self):\n        if hasattr(self.body, 'close'):\n            self.body.close()\n\n    @property\n    def status_line(self):\n        ''' The HTTP status line as a string (e.g. ``404 Not Found``).'''\n        return self._status_line\n\n    @property\n    def status_code(self):\n        ''' The HTTP status code as an integer (e.g. 404).'''\n        return self._status_code\n\n    def _set_status(self, status):\n        if isinstance(status, int):\n            code, status = status, _HTTP_STATUS_LINES.get(status)\n        elif ' ' in status:\n            status = status.strip()\n            code   = int(status.split()[0])\n        else:\n            raise ValueError('String status line without a reason phrase.')\n        if not 100 <= code <= 999: raise ValueError('Status code out of range.')\n        self._status_code = code\n        self._status_line = str(status or ('%d Unknown' % code))\n\n    def _get_status(self):\n        return self._status_line\n\n    status = property(_get_status, _set_status, None,\n        ''' A writeable property to change the HTTP response status. It accepts\n            either a numeric code (100-999) or a string with a custom reason\n            phrase (e.g. \"404 Brain not found\"). Both :data:`status_line` and\n            :data:`status_code` are updated accordingly. The return value is\n            always a status string. ''')\n    del _get_status, _set_status\n\n    @property\n    def headers(self):\n        ''' An instance of :class:`HeaderDict`, a case-insensitive dict-like\n            view on the response headers. '''\n        hdict = HeaderDict()\n        hdict.dict = self._headers\n        return hdict\n\n    def __contains__(self, name): return _hkey(name) in self._headers\n    def __delitem__(self, name):  del self._headers[_hkey(name)]\n    def __getitem__(self, name):  return self._headers[_hkey(name)][-1]\n    def __setitem__(self, name, value): self._headers[_hkey(name)] = [_hval(value)]\n\n    def get_header(self, name, default=None):\n        ''' Return the value of a previously defined header. If there is no\n            header with that name, return a default value. '''\n        return self._headers.get(_hkey(name), [default])[-1]\n\n    def set_header(self, name, value):\n        ''' Create a new response header, replacing any previously defined\n            headers with the same name. '''\n        self._headers[_hkey(name)] = [_hval(value)]\n\n    def add_header(self, name, value):\n        ''' Add an additional response header, not removing duplicates. '''\n        self._headers.setdefault(_hkey(name), []).append(_hval(value))\n\n    def iter_headers(self):\n        ''' Yield (header, value) tuples, skipping headers that are not\n            allowed with the current response status code. '''\n        return self.headerlist\n\n    @property\n    def headerlist(self):\n        \"\"\" WSGI conform list of (header, value) tuples. \"\"\"\n        out = []\n        headers = list(self._headers.items())\n        if 'Content-Type' not in self._headers:\n            headers.append(('Content-Type', [self.default_content_type]))\n        if self._status_code in self.bad_headers:\n            bad_headers = self.bad_headers[self._status_code]\n            headers = [h for h in headers if h[0] not in bad_headers]\n        out += [(name, val) for (name, vals) in headers for val in vals]\n        if self._cookies:\n            for c in self._cookies.values():\n                out.append(('Set-Cookie', _hval(c.OutputString())))\n        if py3k:\n            out = [(k, v.encode('utf8').decode('latin1')) for (k, v) in out]\n        return out\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int)\n    expires = HeaderProperty('Expires',\n        reader=lambda x: datetime.utcfromtimestamp(parse_date(x)),\n        writer=lambda x: http_date(x))\n\n    @property\n    def charset(self, default='UTF-8'):\n        \"\"\" Return the charset specified in the content-type header (default: utf8). \"\"\"\n        if 'charset=' in self.content_type:\n            return self.content_type.split('charset=')[-1].split(';')[0].strip()\n        return default\n\n    def set_cookie(self, name, value, secret=None, **options):\n        ''' Create a new cookie or replace an old one. If the `secret` parameter is\n            set, create a `Signed Cookie` (described below).\n\n            :param name: the name of the cookie.\n            :param value: the value of the cookie.\n            :param secret: a signature key required for signed cookies.\n\n            Additionally, this method accepts all RFC 2109 attributes that are\n            supported by :class:`cookie.Morsel`, including:\n\n            :param max_age: maximum age in seconds. (default: None)\n            :param expires: a datetime object or UNIX timestamp. (default: None)\n            :param domain: the domain that is allowed to read the cookie.\n              (default: current domain)\n            :param path: limits the cookie to a given path (default: current path)\n            :param secure: limit the cookie to HTTPS connections (default: off).\n            :param httponly: prevents client-side javascript to read this cookie\n              (default: off, requires Python 2.6 or newer).\n\n            If neither `expires` nor `max_age` is set (default), the cookie will\n            expire at the end of the browser session (as soon as the browser\n            window is closed).\n\n            Signed cookies may store any pickle-able object and are\n            cryptographically signed to prevent manipulation. Keep in mind that\n            cookies are limited to 4kb in most browsers.\n\n            Warning: Signed cookies are not encrypted (the client can still see\n            the content) and not copy-protected (the client can restore an old\n            cookie). The main intention is to make pickling and unpickling\n            save, not to store secret information at client side.\n        '''\n        if not self._cookies:\n            self._cookies = SimpleCookie()\n\n        if secret:\n            value = touni(cookie_encode((name, value), secret))\n        elif not isinstance(value, basestring):\n            raise TypeError('Secret key missing for non-string Cookie.')\n\n        if len(value) > 4096: raise ValueError('Cookie value to long.')\n        self._cookies[name] = value\n\n        for key, value in options.items():\n            if key == 'max_age':\n                if isinstance(value, timedelta):\n                    value = value.seconds + value.days * 24 * 3600\n            if key == 'expires':\n                if isinstance(value, (datedate, datetime)):\n                    value = value.timetuple()\n                elif isinstance(value, (int, float)):\n                    value = time.gmtime(value)\n                value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n            self._cookies[name][key.replace('_', '-')] = value\n\n    def delete_cookie(self, key, **kwargs):\n        ''' Delete a cookie. Be sure to use the same `domain` and `path`\n            settings as used to create the cookie. '''\n        kwargs['max_age'] = -1\n        kwargs['expires'] = 0\n        self.set_cookie(key, '', **kwargs)\n\n    def __repr__(self):\n        out = ''\n        for name, value in self.headerlist:\n            out += '%s: %s\\n' % (name.title(), value.strip())\n        return out\n\n\ndef local_property(name=None):\n    if name: depr('local_property() is deprecated and will be removed.') #0.12\n    ls = threading.local()\n    def fget(self):\n        try: return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n    def fset(self, value): ls.var = value\n    def fdel(self): del ls.var\n    return property(fget, fset, fdel, 'Thread-local property')\n\n\nclass LocalRequest(BaseRequest):\n    ''' A thread-local subclass of :class:`BaseRequest` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`request`). If accessed during a\n        request/response cycle, this instance always refers to the *current*\n        request (even on a multithreaded server). '''\n    bind = BaseRequest.__init__\n    environ = local_property()\n\n\nclass LocalResponse(BaseResponse):\n    ''' A thread-local subclass of :class:`BaseResponse` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`response`). Its attributes are used\n        to build the HTTP response at the end of the request/response cycle.\n    '''\n    bind = BaseResponse.__init__\n    _status_line = local_property()\n    _status_code = local_property()\n    _cookies     = local_property()\n    _headers     = local_property()\n    body         = local_property()\n\n\nRequest = BaseRequest\nResponse = BaseResponse\n\n\nclass HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n\n    def apply(self, response):\n        response._status_code = self._status_code\n        response._status_line = self._status_line\n        response._headers = self._headers\n        response._cookies = self._cookies\n        response.body = self.body\n\n\nclass HTTPError(HTTPResponse):\n    default_status = 500\n    def __init__(self, status=None, body=None, exception=None, traceback=None,\n                 **options):\n        self.exception = exception\n        self.traceback = traceback\n        super(HTTPError, self).__init__(body, status, **options)\n\n\n\n\n\n###############################################################################\n# Plugins ######################################################################\n###############################################################################\n\nclass PluginError(BottleException): pass\n\n\nclass JSONPlugin(object):\n    name = 'json'\n    api  = 2\n\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not dumps: return callback\n        def wrapper(*a, **ka):\n            try:\n                rv = callback(*a, **ka)\n            except HTTPError:\n                rv = _e()\n\n            if isinstance(rv, dict):\n                #Attempt to serialize, raises exception on failure\n                json_response = dumps(rv)\n                #Set content type only if serialization succesful\n                response.content_type = 'application/json'\n                return json_response\n            elif isinstance(rv, HTTPResponse) and isinstance(rv.body, dict):\n                rv.body = dumps(rv.body)\n                rv.content_type = 'application/json'\n            return rv\n\n        return wrapper\n\n\nclass TemplatePlugin(object):\n    ''' This plugin applies the :func:`view` decorator to all routes with a\n        `template` config parameter. If the parameter is a tuple, the second\n        element must be a dict with additional options (e.g. `template_engine`)\n        or default variables for the template. '''\n    name = 'template'\n    api  = 2\n\n    def apply(self, callback, route):\n        conf = route.config.get('template')\n        if isinstance(conf, (tuple, list)) and len(conf) == 2:\n            return view(conf[0], **conf[1])(callback)\n        elif isinstance(conf, str):\n            return view(conf)(callback)\n        else:\n            return callback\n\n\n#: Not a plugin, but part of the plugin API. TODO: Find a better place.\nclass _ImportRedirect(object):\n    def __init__(self, name, impmask):\n        ''' Create a virtual package that redirects imports (see PEP 302). '''\n        self.name = name\n        self.impmask = impmask\n        self.module = sys.modules.setdefault(name, new_module(name))\n        self.module.__dict__.update({'__file__': __file__, '__path__': [],\n                                    '__all__': [], '__loader__': self})\n        sys.meta_path.append(self)\n\n    def find_module(self, fullname, path=None):\n        if '.' not in fullname: return\n        packname = fullname.rsplit('.', 1)[0]\n        if packname != self.name: return\n        return self\n\n    def load_module(self, fullname):\n        if fullname in sys.modules: return sys.modules[fullname]\n        modname = fullname.rsplit('.', 1)[1]\n        realname = self.impmask % modname\n        __import__(realname)\n        module = sys.modules[fullname] = sys.modules[realname]\n        setattr(self.module, modname, module)\n        module.__loader__ = self\n        return module\n\n\n\n\n\n\n###############################################################################\n# Common Utilities #############################################################\n###############################################################################\n\n\nclass MultiDict(DictMixin):\n    \"\"\" This dict stores multiple values per key, but behaves exactly like a\n        normal dict in that it returns only the newest value for any given key.\n        There are special methods available to access the full list of values.\n    \"\"\"\n\n    def __init__(self, *a, **k):\n        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n\n    def __len__(self): return len(self.dict)\n    def __iter__(self): return iter(self.dict)\n    def __contains__(self, key): return key in self.dict\n    def __delitem__(self, key): del self.dict[key]\n    def __getitem__(self, key): return self.dict[key][-1]\n    def __setitem__(self, key, value): self.append(key, value)\n    def keys(self): return self.dict.keys()\n\n    if py3k:\n        def values(self): return (v[-1] for v in self.dict.values())\n        def items(self): return ((k, v[-1]) for k, v in self.dict.items())\n        def allitems(self):\n            return ((k, v) for k, vl in self.dict.items() for v in vl)\n        iterkeys = keys\n        itervalues = values\n        iteritems = items\n        iterallitems = allitems\n\n    else:\n        def values(self): return [v[-1] for v in self.dict.values()]\n        def items(self): return [(k, v[-1]) for k, v in self.dict.items()]\n        def iterkeys(self): return self.dict.iterkeys()\n        def itervalues(self): return (v[-1] for v in self.dict.itervalues())\n        def iteritems(self):\n            return ((k, v[-1]) for k, v in self.dict.iteritems())\n        def iterallitems(self):\n            return ((k, v) for k, vl in self.dict.iteritems() for v in vl)\n        def allitems(self):\n            return [(k, v) for k, vl in self.dict.iteritems() for v in vl]\n\n    def get(self, key, default=None, index=-1, type=None):\n        ''' Return the most recent value for a key.\n\n            :param default: The default value to be returned if the key is not\n                   present or the type conversion fails.\n            :param index: An index for the list of available values.\n            :param type: If defined, this callable is used to cast the value\n                    into a specific type. Exception are suppressed and result in\n                    the default value to be returned.\n        '''\n        try:\n            val = self.dict[key][index]\n            return type(val) if type else val\n        except Exception:\n            pass\n        return default\n\n    def append(self, key, value):\n        ''' Add a new value to the list of values for this key. '''\n        self.dict.setdefault(key, []).append(value)\n\n    def replace(self, key, value):\n        ''' Replace the list of values with a single value. '''\n        self.dict[key] = [value]\n\n    def getall(self, key):\n        ''' Return a (possibly empty) list of values for a key. '''\n        return self.dict.get(key) or []\n\n    #: Aliases for WTForms to mimic other multi-dict APIs (Django)\n    getone = get\n    getlist = getall\n\n\nclass FormsDict(MultiDict):\n    ''' This :class:`MultiDict` subclass is used to store request form data.\n        Additionally to the normal dict-like item access methods (which return\n        unmodified data as native strings), this container also supports\n        attribute-like access to its values. Attributes are automatically de-\n        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing\n        attributes default to an empty string. '''\n\n    #: Encoding used for attribute values.\n    input_encoding = 'utf8'\n    #: If true (default), unicode strings are first encoded with `latin1`\n    #: and then decoded to match :attr:`input_encoding`.\n    recode_unicode = True\n\n    def _fix(self, s, encoding=None):\n        if isinstance(s, unicode) and self.recode_unicode: # Python 3 WSGI\n            return s.encode('latin1').decode(encoding or self.input_encoding)\n        elif isinstance(s, bytes): # Python 2 WSGI\n            return s.decode(encoding or self.input_encoding)\n        else:\n            return s\n\n    def decode(self, encoding=None):\n        ''' Returns a copy with all keys and values de- or recoded to match\n            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a\n            unicode dictionary. '''\n        copy = FormsDict()\n        enc = copy.input_encoding = encoding or self.input_encoding\n        copy.recode_unicode = False\n        for key, value in self.allitems():\n            copy.append(self._fix(key, enc), self._fix(value, enc))\n        return copy\n\n    def getunicode(self, name, default=None, encoding=None):\n        ''' Return the value as a unicode string, or the default. '''\n        try:\n            return self._fix(self[name], encoding)\n        except (UnicodeError, KeyError):\n            return default\n\n    def __getattr__(self, name, default=unicode()):\n        # Without this guard, pickle generates a cryptic TypeError:\n        if name.startswith('__') and name.endswith('__'):\n            return super(FormsDict, self).__getattr__(name)\n        return self.getunicode(name, default=default)\n\nclass HeaderDict(MultiDict):\n    \"\"\" A case-insensitive version of :class:`MultiDict` that defaults to\n        replace the old value instead of appending it. \"\"\"\n\n    def __init__(self, *a, **ka):\n        self.dict = {}\n        if a or ka: self.update(*a, **ka)\n\n    def __contains__(self, key): return _hkey(key) in self.dict\n    def __delitem__(self, key): del self.dict[_hkey(key)]\n    def __getitem__(self, key): return self.dict[_hkey(key)][-1]\n    def __setitem__(self, key, value): self.dict[_hkey(key)] = [_hval(value)]\n    def append(self, key, value): self.dict.setdefault(_hkey(key), []).append(_hval(value))\n    def replace(self, key, value): self.dict[_hkey(key)] = [_hval(value)]\n    def getall(self, key): return self.dict.get(_hkey(key)) or []\n    def get(self, key, default=None, index=-1):\n        return MultiDict.get(self, _hkey(key), default, index)\n    def filter(self, names):\n        for name in (_hkey(n) for n in names):\n            if name in self.dict:\n                del self.dict[name]\n\n\nclass WSGIHeaderDict(DictMixin):\n    ''' This dict-like class wraps a WSGI environ dict and provides convenient\n        access to HTTP_* fields. Keys and values are native strings\n        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI\n        environment contains non-native string values, these are de- or encoded\n        using a lossless 'latin1' character set.\n\n        The API will remain stable even on changes to the relevant PEPs.\n        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one\n        that uses non-native strings.)\n    '''\n    #: List of keys that do not have a ``HTTP_`` prefix.\n    cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')\n\n    def __init__(self, environ):\n        self.environ = environ\n\n    def _ekey(self, key):\n        ''' Translate header field name to CGI/WSGI environ key. '''\n        key = key.replace('-','_').upper()\n        if key in self.cgikeys:\n            return key\n        return 'HTTP_' + key\n\n    def raw(self, key, default=None):\n        ''' Return the header value as is (may be bytes or unicode). '''\n        return self.environ.get(self._ekey(key), default)\n\n    def __getitem__(self, key):\n        return tonat(self.environ[self._ekey(key)], 'latin1')\n\n    def __setitem__(self, key, value):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __delitem__(self, key):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __iter__(self):\n        for key in self.environ:\n            if key[:5] == 'HTTP_':\n                yield key[5:].replace('_', '-').title()\n            elif key in self.cgikeys:\n                yield key.replace('_', '-').title()\n\n    def keys(self): return [x for x in self]\n    def __len__(self): return len(self.keys())\n    def __contains__(self, key): return self._ekey(key) in self.environ\n\n\n\nclass ConfigDict(dict):\n    ''' A dict-like configuration storage with additional support for\n        namespaces, validators, meta-data, on_change listeners and more.\n\n        This storage is optimized for fast read access. Retrieving a key\n        or using non-altering dict methods (e.g. `dict.get()`) has no overhead\n        compared to a native dict.\n    '''\n    __slots__ = ('_meta', '_on_change')\n\n    class Namespace(DictMixin):\n\n        def __init__(self, config, namespace):\n            self._config = config\n            self._prefix = namespace\n\n        def __getitem__(self, key):\n            depr('Accessing namespaces as dicts is discouraged. '\n                 'Only use flat item access: '\n                 'cfg[\"names\"][\"pace\"][\"key\"] -> cfg[\"name.space.key\"]') #0.12\n            return self._config[self._prefix + '.' + key]\n\n        def __setitem__(self, key, value):\n            self._config[self._prefix + '.' + key] = value\n\n        def __delitem__(self, key):\n            del self._config[self._prefix + '.' + key]\n\n        def __iter__(self):\n            ns_prefix = self._prefix + '.'\n            for key in self._config:\n                ns, dot, name = key.rpartition('.')\n                if ns == self._prefix and name:\n                    yield name\n\n        def keys(self): return [x for x in self]\n        def __len__(self): return len(self.keys())\n        def __contains__(self, key): return self._prefix + '.' + key in self._config\n        def __repr__(self): return '<Config.Namespace %s.*>' % self._prefix\n        def __str__(self): return '<Config.Namespace %s.*>' % self._prefix\n\n        # Deprecated ConfigDict features\n        def __getattr__(self, key):\n            depr('Attribute access is deprecated.') #0.12\n            if key not in self and key[0].isupper():\n                self[key] = ConfigDict.Namespace(self._config, self._prefix + '.' + key)\n            if key not in self and key.startswith('__'):\n                raise AttributeError(key)\n            return self.get(key)\n\n        def __setattr__(self, key, value):\n            if key in ('_config', '_prefix'):\n                self.__dict__[key] = value\n                return\n            depr('Attribute assignment is deprecated.') #0.12\n            if hasattr(DictMixin, key):\n                raise AttributeError('Read-only attribute.')\n            if key in self and self[key] and isinstance(self[key], self.__class__):\n                raise AttributeError('Non-empty namespace attribute.')\n            self[key] = value\n\n        def __delattr__(self, key):\n            if key in self:\n                val = self.pop(key)\n                if isinstance(val, self.__class__):\n                    prefix = key + '.'\n                    for key in self:\n                        if key.startswith(prefix):\n                            del self[prefix+key]\n\n        def __call__(self, *a, **ka):\n            depr('Calling ConfDict is deprecated. Use the update() method.') #0.12\n            self.update(*a, **ka)\n            return self\n\n    def __init__(self, *a, **ka):\n        self._meta = {}\n        self._on_change = lambda name, value: None\n        if a or ka:\n            depr('Constructor does no longer accept parameters.') #0.12\n            self.update(*a, **ka)\n\n    def load_config(self, filename):\n        ''' Load values from an *.ini style config file.\n\n            If the config file contains sections, their names are used as\n            namespaces for the values within. The two special sections\n            ``DEFAULT`` and ``bottle`` refer to the root namespace (no prefix).\n        '''\n        conf = ConfigParser()\n        conf.read(filename)\n        for section in conf.sections():\n            for key, value in conf.items(section):\n                if section not in ('DEFAULT', 'bottle'):\n                    key = section + '.' + key\n                self[key] = value\n        return self\n\n    def load_dict(self, source, namespace='', make_namespaces=False):\n        ''' Import values from a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> ConfigDict().load_dict({'name': {'space': {'key': 'value'}}})\n            {'name.space.key': 'value'}\n        '''\n        stack = [(namespace, source)]\n        while stack:\n            prefix, source = stack.pop()\n            if not isinstance(source, dict):\n                raise TypeError('Source is not a dict (r)' % type(key))\n            for key, value in source.items():\n                if not isinstance(key, basestring):\n                    raise TypeError('Key is not a string (%r)' % type(key))\n                full_key = prefix + '.' + key if prefix else key\n                if isinstance(value, dict):\n                    stack.append((full_key, value))\n                    if make_namespaces:\n                        self[full_key] = self.Namespace(self, full_key)\n                else:\n                    self[full_key] = value\n        return self\n\n    def update(self, *a, **ka):\n        ''' If the first parameter is a string, all keys are prefixed with this\n            namespace. Apart from that it works just as the usual dict.update().\n            Example: ``update('some.namespace', key='value')`` '''\n        prefix = ''\n        if a and isinstance(a[0], basestring):\n            prefix = a[0].strip('.') + '.'\n            a = a[1:]\n        for key, value in dict(*a, **ka).items():\n            self[prefix+key] = value\n\n    def setdefault(self, key, value):\n        if key not in self:\n            self[key] = value\n        return self[key]\n\n    def __setitem__(self, key, value):\n        if not isinstance(key, basestring):\n            raise TypeError('Key has type %r (not a string)' % type(key))\n\n        value = self.meta_get(key, 'filter', lambda x: x)(value)\n        if key in self and self[key] is value:\n            return\n        self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, key)\n\n    def clear(self):\n        for key in self:\n            del self[key]\n\n    def meta_get(self, key, metafield, default=None):\n        ''' Return the value of a meta field for a key. '''\n        return self._meta.get(key, {}).get(metafield, default)\n\n    def meta_set(self, key, metafield, value):\n        ''' Set the meta field for a key to a new value. This triggers the\n            on-change handler for existing keys. '''\n        self._meta.setdefault(key, {})[metafield] = value\n        if key in self:\n            self[key] = self[key]\n\n    def meta_list(self, key):\n        ''' Return an iterable of meta field names defined for a key. '''\n        return self._meta.get(key, {}).keys()\n\n    # Deprecated ConfigDict features\n    def __getattr__(self, key):\n        depr('Attribute access is deprecated.') #0.12\n        if key not in self and key[0].isupper():\n            self[key] = self.Namespace(self, key)\n        if key not in self and key.startswith('__'):\n            raise AttributeError(key)\n        return self.get(key)\n\n    def __setattr__(self, key, value):\n        if key in self.__slots__:\n            return dict.__setattr__(self, key, value)\n        depr('Attribute assignment is deprecated.') #0.12\n        if hasattr(dict, key):\n            raise AttributeError('Read-only attribute.')\n        if key in self and self[key] and isinstance(self[key], self.Namespace):\n            raise AttributeError('Non-empty namespace attribute.')\n        self[key] = value\n\n    def __delattr__(self, key):\n        if key in self:\n            val = self.pop(key)\n            if isinstance(val, self.Namespace):\n                prefix = key + '.'\n                for key in self:\n                    if key.startswith(prefix):\n                        del self[prefix+key]\n\n    def __call__(self, *a, **ka):\n        depr('Calling ConfDict is deprecated. Use the update() method.') #0.12\n        self.update(*a, **ka)\n        return self\n\n\n\nclass AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self[-1]\n\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)\n        return value\n\n\nclass WSGIFileWrapper(object):\n\n    def __init__(self, fp, buffer_size=1024*64):\n        self.fp, self.buffer_size = fp, buffer_size\n        for attr in ('fileno', 'close', 'read', 'readlines', 'tell', 'seek'):\n            if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))\n\n    def __iter__(self):\n        buff, read = self.buffer_size, self.read\n        while True:\n            part = read(buff)\n            if not part: return\n            yield part\n\n\nclass _closeiter(object):\n    ''' This only exists to be able to attach a .close method to iterators that\n        do not support attribute assignment (most of itertools). '''\n\n    def __init__(self, iterator, close=None):\n        self.iterator = iterator\n        self.close_callbacks = makelist(close)\n\n    def __iter__(self):\n        return iter(self.iterator)\n\n    def close(self):\n        for func in self.close_callbacks:\n            func()\n\n\nclass ResourceManager(object):\n    ''' This class manages a list of search paths and helps to find and open\n        application-bound resources (files).\n\n        :param base: default value for :meth:`add_path` calls.\n        :param opener: callable used to open resources.\n        :param cachemode: controls which lookups are cached. One of 'all',\n                         'found' or 'none'.\n    '''\n\n    def __init__(self, base='./', opener=open, cachemode='all'):\n        self.opener = open\n        self.base = base\n        self.cachemode = cachemode\n\n        #: A list of search paths. See :meth:`add_path` for details.\n        self.path = []\n        #: A cache for resolved paths. ``res.cache.clear()`` clears the cache.\n        self.cache = {}\n\n    def add_path(self, path, base=None, index=None, create=False):\n        ''' Add a new path to the list of search paths. Return False if the\n            path does not exist.\n\n            :param path: The new search path. Relative paths are turned into\n                an absolute and normalized form. If the path looks like a file\n                (not ending in `/`), the filename is stripped off.\n            :param base: Path used to absolutize relative search paths.\n                Defaults to :attr:`base` which defaults to ``os.getcwd()``.\n            :param index: Position within the list of search paths. Defaults\n                to last index (appends to the list).\n\n            The `base` parameter makes it easy to reference files installed\n            along with a python module or package::\n\n                res.add_path('./resources/', __file__)\n        '''\n        base = os.path.abspath(os.path.dirname(base or self.base))\n        path = os.path.abspath(os.path.join(base, os.path.dirname(path)))\n        path += os.sep\n        if path in self.path:\n            self.path.remove(path)\n        if create and not os.path.isdir(path):\n            os.makedirs(path)\n        if index is None:\n            self.path.append(path)\n        else:\n            self.path.insert(index, path)\n        self.cache.clear()\n        return os.path.exists(path)\n\n    def __iter__(self):\n        ''' Iterate over all existing files in all registered paths. '''\n        search = self.path[:]\n        while search:\n            path = search.pop()\n            if not os.path.isdir(path): continue\n            for name in os.listdir(path):\n                full = os.path.join(path, name)\n                if os.path.isdir(full): search.append(full)\n                else: yield full\n\n    def lookup(self, name):\n        ''' Search for a resource and return an absolute file path, or `None`.\n\n            The :attr:`path` list is searched in order. The first match is\n            returend. Symlinks are followed. The result is cached to speed up\n            future lookups. '''\n        if name not in self.cache or DEBUG:\n            for path in self.path:\n                fpath = os.path.join(path, name)\n                if os.path.isfile(fpath):\n                    if self.cachemode in ('all', 'found'):\n                        self.cache[name] = fpath\n                    return fpath\n            if self.cachemode == 'all':\n                self.cache[name] = None\n        return self.cache[name]\n\n    def open(self, name, mode='r', *args, **kwargs):\n        ''' Find a resource and return a file object, or raise IOError. '''\n        fname = self.lookup(name)\n        if not fname: raise IOError(\"Resource %r not found.\" % name)\n        return self.opener(fname, mode=mode, *args, **kwargs)\n\n\nclass FileUpload(object):\n\n    def __init__(self, fileobj, name, filename, headers=None):\n        ''' Wrapper for file uploads. '''\n        #: Open file(-like) object (BytesIO buffer or temporary file)\n        self.file = fileobj\n        #: Name of the upload form field\n        self.name = name\n        #: Raw filename as sent by the client (may contain unsafe characters)\n        self.raw_filename = filename\n        #: A :class:`HeaderDict` with additional headers (e.g. content-type)\n        self.headers = HeaderDict(headers) if headers else HeaderDict()\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a header within the mulripart part. \"\"\"\n        return self.headers.get(name, default)\n\n    @cached_property\n    def filename(self):\n        ''' Name of the file on the client file system, but normalized to ensure\n            file system compatibility. An empty filename is returned as 'empty'.\n\n            Only ASCII letters, digits, dashes, underscores and dots are\n            allowed in the final filename. Accents are removed, if possible.\n            Whitespace is replaced by a single dash. Leading or tailing dots\n            or dashes are removed. The filename is limited to 255 characters.\n        '''\n        fname = self.raw_filename\n        if not isinstance(fname, unicode):\n            fname = fname.decode('utf8', 'ignore')\n        fname = normalize('NFKD', fname).encode('ASCII', 'ignore').decode('ASCII')\n        fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n        fname = re.sub(r'[^a-zA-Z0-9-_.\\s]', '', fname).strip()\n        fname = re.sub(r'[-\\s]+', '-', fname).strip('.-')\n        return fname[:255] or 'empty'\n\n    def _copy_file(self, fp, chunk_size=2**16):\n        read, write, offset = self.file.read, fp.write, self.file.tell()\n        while 1:\n            buf = read(chunk_size)\n            if not buf: break\n            write(buf)\n        self.file.seek(offset)\n\n    def save(self, destination, overwrite=False, chunk_size=2**16):\n        ''' Save file to disk or copy its content to an open file(-like) object.\n            If *destination* is a directory, :attr:`filename` is added to the\n            path. Existing files are not overwritten by default (IOError).\n\n            :param destination: File path, directory or file(-like) object.\n            :param overwrite: If True, replace existing files. (default: False)\n            :param chunk_size: Bytes to read at a time. (default: 64kb)\n        '''\n        if isinstance(destination, basestring): # Except file-likes here\n            if os.path.isdir(destination):\n                destination = os.path.join(destination, self.filename)\n            if not overwrite and os.path.exists(destination):\n                raise IOError('File exists.')\n            with open(destination, 'wb') as fp:\n                self._copy_file(fp, chunk_size)\n        else:\n            self._copy_file(destination, chunk_size)\n\n\n\n\n\n\n###############################################################################\n# Application Helper ###########################################################\n###############################################################################\n\n\ndef abort(code=500, text='Unknown Error.'):\n    \"\"\" Aborts execution and causes a HTTP error. \"\"\"\n    raise HTTPError(code, text)\n\n\ndef redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code\n    res.body = \"\"\n    res.set_header('Location', urljoin(request.url, url))\n    raise res\n\n\ndef _file_iter_range(fp, offset, bytes, maxread=1024*1024):\n    ''' Yield chunks from a range in a file. No chunk is bigger than maxread.'''\n    fp.seek(offset)\n    while bytes > 0:\n        part = fp.read(min(bytes, maxread))\n        if not part: break\n        bytes -= len(part)\n        yield part\n\n\ndef static_file(filename, root, mimetype='auto', download=False, charset='UTF-8'):\n    \"\"\" Open a file in a safe way and return :exc:`HTTPResponse` with status\n        code 200, 305, 403 or 404. The ``Content-Type``, ``Content-Encoding``,\n        ``Content-Length`` and ``Last-Modified`` headers are set if possible.\n        Special support for ``If-Modified-Since``, ``Range`` and ``HEAD``\n        requests.\n\n        :param filename: Name or path of the file to send.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Defines the content-type header (default: guess from\n            file extension)\n        :param download: If True, ask the browser to open a `Save as...` dialog\n            instead of opening the file with the associated program. You can\n            specify a custom filename as a string. If not specified, the\n            original filename is used (default: False).\n        :param charset: The charset to use for files with a ``text/*``\n            mime-type. (default: UTF-8)\n    \"\"\"\n\n    root = os.path.abspath(root) + os.sep\n    filename = os.path.abspath(os.path.join(root, filename.strip('/\\\\')))\n    headers = dict()\n\n    if not filename.startswith(root):\n        return HTTPError(403, \"Access denied.\")\n    if not os.path.exists(filename) or not os.path.isfile(filename):\n        return HTTPError(404, \"File does not exist.\")\n    if not os.access(filename, os.R_OK):\n        return HTTPError(403, \"You do not have permission to access this file.\")\n\n    if mimetype == 'auto':\n        mimetype, encoding = mimetypes.guess_type(filename)\n        if encoding: headers['Content-Encoding'] = encoding\n\n    if mimetype:\n        if mimetype[:5] == 'text/' and charset and 'charset' not in mimetype:\n            mimetype += '; charset=%s' % charset\n        headers['Content-Type'] = mimetype\n\n    if download:\n        download = os.path.basename(filename if download == True else download)\n        headers['Content-Disposition'] = 'attachment; filename=\"%s\"' % download\n\n    stats = os.stat(filename)\n    headers['Content-Length'] = clen = stats.st_size\n    lm = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime(stats.st_mtime))\n    headers['Last-Modified'] = lm\n\n    ims = request.environ.get('HTTP_IF_MODIFIED_SINCE')\n    if ims:\n        ims = parse_date(ims.split(\";\")[0].strip())\n    if ims is not None and ims >= int(stats.st_mtime):\n        headers['Date'] = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime())\n        return HTTPResponse(status=304, **headers)\n\n    body = '' if request.method == 'HEAD' else open(filename, 'rb')\n\n    headers[\"Accept-Ranges\"] = \"bytes\"\n    ranges = request.environ.get('HTTP_RANGE')\n    if 'HTTP_RANGE' in request.environ:\n        ranges = list(parse_range_header(request.environ['HTTP_RANGE'], clen))\n        if not ranges:\n            return HTTPError(416, \"Requested Range Not Satisfiable\")\n        offset, end = ranges[0]\n        headers[\"Content-Range\"] = \"bytes %d-%d/%d\" % (offset, end-1, clen)\n        headers[\"Content-Length\"] = str(end-offset)\n        if body: body = _file_iter_range(body, offset, end-offset)\n        return HTTPResponse(body, status=206, **headers)\n    return HTTPResponse(body, **headers)\n\n\n\n\n\n\n###############################################################################\n# HTTP Utilities and MISC (TODO) ###############################################\n###############################################################################\n\n\ndef debug(mode=True):\n    \"\"\" Change the debug level.\n    There is only one debug level supported at the moment.\"\"\"\n    global DEBUG\n    if mode: warnings.simplefilter('default')\n    DEBUG = bool(mode)\n\ndef http_date(value):\n    if isinstance(value, (datedate, datetime)):\n        value = value.utctimetuple()\n    elif isinstance(value, (int, float)):\n        value = time.gmtime(value)\n    if not isinstance(value, basestring):\n        value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n    return value\n\ndef parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"\n    try:\n        ts = email.utils.parsedate_tz(ims)\n        return time.mktime(ts[:8] + (0,)) - (ts[9] or 0) - time.timezone\n    except (TypeError, ValueError, IndexError, OverflowError):\n        return None\n\ndef parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            user, pwd = touni(base64.b64decode(tob(data))).split(':',1)\n            return user, pwd\n    except (KeyError, ValueError):\n        return None\n\ndef parse_range_header(header, maxlen=0):\n    ''' Yield (start, end) ranges parsed from a HTTP Range header. Skip\n        unsatisfiable ranges. The end index is non-inclusive.'''\n    if not header or header[:6] != 'bytes=': return\n    ranges = [r.split('-', 1) for r in header[6:].split(',') if '-' in r]\n    for start, end in ranges:\n        try:\n            if not start:  # bytes=-100    -> last 100 bytes\n                start, end = max(0, maxlen-int(end)), maxlen\n            elif not end:  # bytes=100-    -> all but the first 99 bytes\n                start, end = int(start), maxlen\n            else:          # bytes=100-200 -> bytes 100-200 (inclusive)\n                start, end = int(start), min(int(end)+1, maxlen)\n            if 0 <= start < end <= maxlen:\n                yield start, end\n        except ValueError:\n            pass\n\ndef _parse_qsl(qs):\n    r = []\n    for pair in qs.split('&'):\n        if not pair: continue\n        nv = pair.split('=', 1)\n        if len(nv) != 2: nv.append('')\n        key = urlunquote(nv[0].replace('+', ' '))\n        value = urlunquote(nv[1].replace('+', ' '))\n        r.append((key, value))\n    return r\n\ndef _lscmp(a, b):\n    ''' Compares two strings in a cryptographically safe way:\n        Runtime is not affected by length of common prefix. '''\n    return not sum(0 if x==y else 1 for x, y in zip(a, b)) and len(a) == len(b)\n\n\ndef cookie_encode(data, key):\n    ''' Encode and sign a pickle-able object. Return a (byte) string '''\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())\n    return tob('!') + sig + tob('?') + msg\n\n\ndef cookie_decode(data, key):\n    ''' Verify and decode an encoded string. Return an object or None.'''\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())):\n            return pickle.loads(base64.b64decode(msg))\n    return None\n\n\ndef cookie_is_encoded(data):\n    ''' Return True if the argument looks like a encoded cookie.'''\n    return bool(data.startswith(tob('!')) and tob('?') in data)\n\n\ndef html_escape(string):\n    ''' Escape HTML special characters ``&<>`` and quotes ``'\"``. '''\n    return string.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')\\\n                 .replace('\"','&quot;').replace(\"'\",'&#039;')\n\n\ndef html_quote(string):\n    ''' Escape and quote a string to be used as an HTTP attribute.'''\n    return '\"%s\"' % html_escape(string).replace('\\n','&#10;')\\\n                    .replace('\\r','&#13;').replace('\\t','&#9;')\n\n\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'\n        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\n        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n    \"\"\"\n    path = '/' + func.__name__.replace('__','/').lstrip('/')\n    spec = getargspec(func)\n    argc = len(spec[0]) - len(spec[3] or [])\n    path += ('/<%s>' * argc) % tuple(spec[0][:argc])\n    yield path\n    for arg in spec[0][argc:]:\n        path += '/<%s>' % arg\n        yield path\n\n\ndef path_shift(script_name, path_info, shift=1):\n    ''' Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n\n        :return: The modified paths.\n        :param script_name: The SCRIPT_NAME path.\n        :param script_name: The PATH_INFO path.\n        :param shift: The number of path fragments to shift. May be negative to\n          change the shift direction. (default: 1)\n    '''\n    if shift == 0: return script_name, path_info\n    pathlist = path_info.strip('/').split('/')\n    scriptlist = script_name.strip('/').split('/')\n    if pathlist and pathlist[0] == '': pathlist = []\n    if scriptlist and scriptlist[0] == '': scriptlist = []\n    if shift > 0 and shift <= len(pathlist):\n        moved = pathlist[:shift]\n        scriptlist = scriptlist + moved\n        pathlist = pathlist[shift:]\n    elif shift < 0 and shift >= -len(scriptlist):\n        moved = scriptlist[shift:]\n        pathlist = moved + pathlist\n        scriptlist = scriptlist[:shift]\n    else:\n        empty = 'SCRIPT_NAME' if shift < 0 else 'PATH_INFO'\n        raise AssertionError(\"Cannot shift. Nothing left from %s\" % empty)\n    new_script_name = '/' + '/'.join(scriptlist)\n    new_path_info = '/' + '/'.join(pathlist)\n    if path_info.endswith('/') and pathlist: new_path_info += '/'\n    return new_script_name, new_path_info\n\n\ndef auth_basic(check, realm=\"private\", text=\"Access denied\"):\n    ''' Callback decorator to require HTTP auth (basic).\n        TODO: Add route(check_auth=...) parameter. '''\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*a, **ka):\n            user, password = request.auth or (None, None)\n            if user is None or not check(user, password):\n                err = HTTPError(401, text)\n                err.add_header('WWW-Authenticate', 'Basic realm=\"%s\"' % realm)\n                return err\n            return func(*a, **ka)\n        return wrapper\n    return decorator\n\n\n# Shortcuts for common Bottle methods.\n# They all refer to the current default application.\n\ndef make_default_app_wrapper(name):\n    ''' Return a callable that relays calls to the current default app. '''\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n    return wrapper\n\nroute     = make_default_app_wrapper('route')\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')\ndelete    = make_default_app_wrapper('delete')\nerror     = make_default_app_wrapper('error')\nmount     = make_default_app_wrapper('mount')\nhook      = make_default_app_wrapper('hook')\ninstall   = make_default_app_wrapper('install')\nuninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n\n\n\n\n\n\n\n###############################################################################\n# Server Adapter ###############################################################\n###############################################################################\n\n\nclass ServerAdapter(object):\n    quiet = False\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n\n    def run(self, handler): # pragma: no cover\n        pass\n\n    def __repr__(self):\n        args = ', '.join(['%s=%s'%(k,repr(v)) for k, v in self.options.items()])\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass CGIServer(ServerAdapter):\n    quiet = True\n    def run(self, handler): # pragma: no cover\n        from wsgiref.handlers import CGIHandler\n        def fixed_environ(environ, start_response):\n            environ.setdefault('PATH_INFO', '')\n            return handler(environ, start_response)\n        CGIHandler().run(fixed_environ)\n\n\nclass FlupFCGIServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        import flup.server.fcgi\n        self.options.setdefault('bindAddress', (self.host, self.port))\n        flup.server.fcgi.WSGIServer(handler, **self.options).run()\n\n\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app): # pragma: no cover\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        from wsgiref.simple_server import make_server\n        import socket\n\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self): # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n            def log_request(*args, **kw):\n                if not self.quiet:\n                    return WSGIRequestHandler.log_request(*args, **kw)\n\n        handler_cls = self.options.get('handler_class', FixedHandler)\n        server_cls  = self.options.get('server_class', WSGIServer)\n\n        if ':' in self.host: # Fix wsgiref for IPv6 addresses.\n            if getattr(server_cls, 'address_family') == socket.AF_INET:\n                class server_cls(server_cls):\n                    address_family = socket.AF_INET6\n\n        srv = make_server(self.host, self.port, app, server_cls, handler_cls)\n        srv.serve_forever()\n\n\nclass CherryPyServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        depr(0, 13, \"The wsgi server part of cherrypy was split into a new \"\n                    \"project called 'cheroot'.\", \"Use the 'cheroot' server \"\n                    \"adapter instead of cherrypy.\")\n        from cherrypy import wsgiserver # This will fail for CherryPy >= 9\n\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n\n        certfile = self.options.get('certfile')\n        if certfile:\n            del self.options['certfile']\n        keyfile = self.options.get('keyfile')\n        if keyfile:\n            del self.options['keyfile']\n\n        server = wsgiserver.CherryPyWSGIServer(**self.options)\n        if certfile:\n            server.ssl_certificate = certfile\n        if keyfile:\n            server.ssl_private_key = keyfile\n\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass CherootServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from cheroot import wsgi\n        from cheroot.ssl import builtin\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n        certfile = self.options.pop('certfile', None)\n        keyfile = self.options.pop('keyfile', None)\n        chainfile = self.options.pop('chainfile', None)\n        server = wsgi.Server(**self.options)\n        if certfile and keyfile:\n            server.ssl_adapter = builtin.BuiltinSSLAdapter(\n                    certfile, keyfile, chainfile)\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass WaitressServer(ServerAdapter):\n    def run(self, handler):\n        from waitress import serve\n        serve(handler, host=self.host, port=self.port)\n\n\nclass PasteServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler, host=self.host, port=str(self.port),\n                         **self.options)\n\n\nclass MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server\n        server.listen((self.host, self.port))\n        server.run(handler)\n\n\nclass FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See http://www.fapws.org/ \"\"\"\n    def run(self, handler): # pragma: no cover\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config\n        port = self.port\n        if float(config.SERVER_IDENT[-2:]) > 0.4:\n            # fapws3 silently changed its API in 0.5\n            port = str(port)\n        evwsgi.start(self.host, port)\n        # fapws3 never releases the GIL. Complain upstream. I tried. No luck.\n        if 'BOTTLE_CHILD' in os.environ and not self.quiet:\n            _stderr(\"WARNING: Auto-reloading does not work with Fapws3.\\n\")\n            _stderr(\"         (Fapws3 breaks python thread support)\\n\")\n        evwsgi.set_base_module(base)\n        def app(environ, start_response):\n            environ['wsgi.multiprocess'] = False\n            return handler(environ, start_response)\n        evwsgi.wsgi_cb(('', app))\n        evwsgi.run()\n\n\nclass TornadoServer(ServerAdapter):\n    \"\"\" The super hyped asynchronous server by facebook. Untested. \"\"\"\n    def run(self, handler): # pragma: no cover\n        import tornado.wsgi, tornado.httpserver, tornado.ioloop\n        container = tornado.wsgi.WSGIContainer(handler)\n        server = tornado.httpserver.HTTPServer(container)\n        server.listen(port=self.port,address=self.host)\n        tornado.ioloop.IOLoop.instance().start()\n\n\nclass AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"\n    quiet = True\n    def run(self, handler):\n        from google.appengine.ext.webapp import util\n        # A main() function in the handler script enables 'App Caching'.\n        # Lets makes sure it is there. This _really_ improves performance.\n        module = sys.modules.get('__main__')\n        if module and not hasattr(module, 'main'):\n            module.main = lambda: util.run_wsgi_app(handler)\n        util.run_wsgi_app(handler)\n\n\nclass TwistedServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from twisted.web import server, wsgi\n        from twisted.python.threadpool import ThreadPool\n        from twisted.internet import reactor\n        thread_pool = ThreadPool()\n        thread_pool.start()\n        reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)\n        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))\n        reactor.listenTCP(self.port, factory, interface=self.host)\n        reactor.run()\n\n\nclass DieselServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from diesel.protocols.wsgi import WSGIApplication\n        app = WSGIApplication(handler, port=self.port)\n        app.run()\n\n\nclass GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * `fast` (default: False) uses libevent's http server, but has some\n          issues: No streaming, no pipelining, no SSL.\n        * See gevent.wsgi.WSGIServer() documentation for more options.\n    \"\"\"\n    def run(self, handler):\n        from gevent import pywsgi, local\n        if not isinstance(threading.local(), local.local):\n            msg = \"Bottle requires gevent.monkey.patch_all() (before import)\"\n            raise RuntimeError(msg)\n        if self.options.pop('fast', None):\n            depr('The \"fast\" option has been deprecated and removed by Gevent.')\n        if self.quiet:\n            self.options['log'] = None\n        address = (self.host, self.port)\n        server = pywsgi.WSGIServer(address, handler, **self.options)\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: server.stop())\n        server.serve_forever()\n\n\nclass GeventSocketIOServer(ServerAdapter):\n    def run(self,handler):\n        from socketio import server\n        address = (self.host, self.port)\n        server.SocketIOServer(address, handler, **self.options).serve_forever()\n\n\nclass GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n    def run(self, handler):\n        from gunicorn.app.base import Application\n\n        config = {'bind': \"%s:%d\" % (self.host, int(self.port))}\n        config.update(self.options)\n\n        class GunicornApplication(Application):\n            def init(self, parser, opts, args):\n                return config\n\n            def load(self):\n                return handler\n\n        GunicornApplication().run()\n\n\nclass EventletServer(ServerAdapter):\n    \"\"\" Untested \"\"\"\n    def run(self, handler):\n        from eventlet import wsgi, listen\n        try:\n            wsgi.server(listen((self.host, self.port)), handler,\n                        log_output=(not self.quiet))\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            wsgi.server(listen((self.host, self.port)), handler)\n\n\nclass RocketServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from rocket import Rocket\n        server = Rocket((self.host, self.port), 'wsgi', { 'wsgi_app' : handler })\n        server.start()\n\n\nclass BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n    def run(self, handler):\n        from bjoern import run\n        run(handler, self.host, self.port)\n\n\nclass AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                CherootServer, WSGIRefServer]\n\n    def run(self, handler):\n        for sa in self.adapters:\n            try:\n                return sa(self.host, self.port, **self.options).run(handler)\n            except ImportError:\n                pass\n\nserver_names = {\n    'cgi': CGIServer,\n    'flup': FlupFCGIServer,\n    'wsgiref': WSGIRefServer,\n    'waitress': WaitressServer,\n    'cherrypy': CherryPyServer,\n    'cheroot': CherootServer,\n    'paste': PasteServer,\n    'fapws3': FapwsServer,\n    'tornado': TornadoServer,\n    'gae': AppEngineServer,\n    'twisted': TwistedServer,\n    'diesel': DieselServer,\n    'meinheld': MeinheldServer,\n    'gunicorn': GunicornServer,\n    'eventlet': EventletServer,\n    'gevent': GeventServer,\n    'geventSocketIO':GeventSocketIOServer,\n    'rocket': RocketServer,\n    'bjoern' : BjoernServer,\n    'auto': AutoServer,\n}\n\n\n\n\n\n\n###############################################################################\n# Application Control ##########################################################\n###############################################################################\n\n\ndef load(target, **namespace):\n    \"\"\" Import a module or fetch an object from a module.\n\n        * ``package.module`` returns `module` as a module object.\n        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.\n        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.\n\n        The last form accepts not only function calls, but any type of\n        expression. Keyword arguments passed to this function are available as\n        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``\n    \"\"\"\n    module, target = target.split(\":\", 1) if ':' in target else (target, None)\n    if module not in sys.modules: __import__(module)\n    if not target: return sys.modules[module]\n    if target.isalnum(): return getattr(sys.modules[module], target)\n    package_name = module.split('.')[0]\n    namespace[package_name] = sys.modules[package_name]\n    return eval('%s.%s' % (module, target), namespace)\n\n\ndef load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN; NORUN, nr_old = True, NORUN\n    try:\n        tmp = default_app.push() # Create a new \"default application\"\n        rv = load(target) # Import the target module\n        return rv if callable(rv) else tmp\n    finally:\n        default_app.remove(tmp) # Remove the temporary added default application\n        NORUN = nr_old\n\n_debug = debug\ndef run(app=None, server='wsgiref', host='127.0.0.1', port=8080,\n        interval=1, reloader=False, quiet=False, plugins=None,\n        debug=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on\n               all interfaces including the external one. (default: 127.0.0.1)\n        :param port: Server port to bind to. Values below 1024 require root\n               privileges. (default: 8080)\n        :param reloader: Start auto-reloading server? (default: False)\n        :param interval: Auto-reloader interval in seconds (default: 1)\n        :param quiet: Suppress output to stdout and stderr? (default: False)\n        :param options: Options passed to the server adapter.\n     \"\"\"\n    if NORUN: return\n    if reloader and not os.environ.get('BOTTLE_CHILD'):\n        try:\n            lockfile = None\n            fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')\n            os.close(fd) # We only need this file to exist. We never write to it\n            while os.path.exists(lockfile):\n                args = [sys.executable] + sys.argv\n                environ = os.environ.copy()\n                environ['BOTTLE_CHILD'] = 'true'\n                environ['BOTTLE_LOCKFILE'] = lockfile\n                p = subprocess.Popen(args, env=environ)\n                while p.poll() is None: # Busy wait...\n                    os.utime(lockfile, None) # I am alive!\n                    time.sleep(interval)\n                if p.poll() != 3:\n                    if os.path.exists(lockfile): os.unlink(lockfile)\n                    sys.exit(p.poll())\n        except KeyboardInterrupt:\n            pass\n        finally:\n            if os.path.exists(lockfile):\n                os.unlink(lockfile)\n        return\n\n    try:\n        if debug is not None: _debug(debug)\n        app = app or default_app()\n        if isinstance(app, basestring):\n            app = load_app(app)\n        if not callable(app):\n            raise ValueError(\"Application is not callable: %r\" % app)\n\n        for plugin in plugins or []:\n            app.install(plugin)\n\n        if server in server_names:\n            server = server_names.get(server)\n        if isinstance(server, basestring):\n            server = load(server)\n        if isinstance(server, type):\n            server = server(host=host, port=port, **kargs)\n        if not isinstance(server, ServerAdapter):\n            raise ValueError(\"Unknown or unsupported server: %r\" % server)\n\n        server.quiet = server.quiet or quiet\n        if not server.quiet:\n            _stderr(\"Bottle v%s server starting up (using %s)...\\n\" % (__version__, repr(server)))\n            _stderr(\"Listening on http://%s:%d/\\n\" % (server.host, server.port))\n            _stderr(\"Hit Ctrl-C to quit.\\n\\n\")\n\n        if reloader:\n            lockfile = os.environ.get('BOTTLE_LOCKFILE')\n            bgcheck = FileCheckerThread(lockfile, interval)\n            with bgcheck:\n                server.run(app)\n            if bgcheck.status == 'reload':\n                sys.exit(3)\n        else:\n            server.run(app)\n    except KeyboardInterrupt:\n        pass\n    except (SystemExit, MemoryError):\n        raise\n    except:\n        if not reloader: raise\n        if not getattr(server, 'quiet', quiet):\n            print_exc()\n        time.sleep(interval)\n        sys.exit(3)\n\n\n\nclass FileCheckerThread(threading.Thread):\n    ''' Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets to old. '''\n\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n\n    def run(self):\n        exists = os.path.exists\n        mtime = lambda path: os.stat(path).st_mtime\n        files = dict()\n\n        for module in list(sys.modules.values()):\n            path = getattr(module, '__file__', '') or ''\n            if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]\n            if path and exists(path): files[path] = mtime(path)\n\n        while not self.status:\n            if not exists(self.lockfile)\\\n            or mtime(self.lockfile) < time.time() - self.interval - 5:\n                self.status = 'error'\n                thread.interrupt_main()\n            for path, lmtime in list(files.items()):\n                if not exists(path) or mtime(path) > lmtime:\n                    self.status = 'reload'\n                    thread.interrupt_main()\n                    break\n            time.sleep(self.interval)\n\n    def __enter__(self):\n        self.start()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if not self.status: self.status = 'exit' # silent exit\n        self.join()\n        return exc_type is not None and issubclass(exc_type, KeyboardInterrupt)\n\n\n\n\n\n###############################################################################\n# Template Adapters ############################################################\n###############################################################################\n\n\nclass TemplateError(HTTPError):\n    def __init__(self, message):\n        HTTPError.__init__(self, 500, message)\n\n\nclass BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl','html','thtml','stpl']\n    settings = {} #used in prepare()\n    defaults = {} #used in render()\n\n    def __init__(self, source=None, name=None, lookup=[], encoding='utf8', **settings):\n        \"\"\" Create a new template.\n        If the source parameter (str or buffer) is missing, the name argument\n        is used to guess a template filename. Subclasses can assume that\n        self.source and/or self.filename are set. Both are strings.\n        The lookup, encoding and settings parameters are stored as instance\n        variables.\n        The lookup parameter stores a list containing directory paths.\n        The encoding parameter should be used to decode byte strings or files.\n        The settings parameter contains a dict for engine-specific settings.\n        \"\"\"\n        self.name = name\n        self.source = source.read() if hasattr(source, 'read') else source\n        self.filename = source.filename if hasattr(source, 'filename') else None\n        self.lookup = [os.path.abspath(x) for x in lookup]\n        self.encoding = encoding\n        self.settings = self.settings.copy() # Copy from class variable\n        self.settings.update(settings) # Apply\n        if not self.source and self.name:\n            self.filename = self.search(self.name, self.lookup)\n            if not self.filename:\n                raise TemplateError('Template %s not found.' % repr(name))\n        if not self.source and not self.filename:\n            raise TemplateError('No template specified.')\n        self.prepare(**self.settings)\n\n    @classmethod\n    def search(cls, name, lookup=[]):\n        \"\"\" Search name in all directories specified in lookup.\n        First without, then with common extensions. Return first hit. \"\"\"\n        if not lookup:\n            depr('The template lookup path list should not be empty.') #0.12\n            lookup = ['.']\n\n        if os.path.isabs(name) and os.path.isfile(name):\n            depr('Absolute template path names are deprecated.') #0.12\n            return os.path.abspath(name)\n\n        for spath in lookup:\n            spath = os.path.abspath(spath) + os.sep\n            fname = os.path.abspath(os.path.join(spath, name))\n            if not fname.startswith(spath): continue\n            if os.path.isfile(fname): return fname\n            for ext in cls.extensions:\n                if os.path.isfile('%s.%s' % (fname, ext)):\n                    return '%s.%s' % (fname, ext)\n\n    @classmethod\n    def global_config(cls, key, *args):\n        ''' This reads or sets the global settings stored in class.settings. '''\n        if args:\n            cls.settings = cls.settings.copy() # Make settings local to class\n            cls.settings[key] = args[0]\n        else:\n            return cls.settings[key]\n\n    def prepare(self, **options):\n        \"\"\" Run preparations (parsing, caching, ...).\n        It should be possible to call this again to refresh a template or to\n        update settings.\n        \"\"\"\n        raise NotImplementedError\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template with the specified local variables and return\n        a single byte or unicode string. If it is a byte string, the encoding\n        must match self.encoding. This method must be thread-safe!\n        Local variables may be provided in dictionaries (args)\n        or directly, as keywords (kwargs).\n        \"\"\"\n        raise NotImplementedError\n\n\nclass MakoTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from mako.template import Template\n        from mako.lookup import TemplateLookup\n        options.update({'input_encoding':self.encoding})\n        options.setdefault('format_exceptions', bool(DEBUG))\n        lookup = TemplateLookup(directories=self.lookup, **options)\n        if self.source:\n            self.tpl = Template(self.source, lookup=lookup, **options)\n        else:\n            self.tpl = Template(uri=self.name, filename=self.filename, lookup=lookup, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args: kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n\nclass CheetahTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from Cheetah.Template import Template\n        self.context = threading.local()\n        self.context.vars = {}\n        options['searchList'] = [self.context.vars]\n        if self.source:\n            self.tpl = Template(source=self.source, **options)\n        else:\n            self.tpl = Template(file=self.filename, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args: kwargs.update(dictarg)\n        self.context.vars.update(self.defaults)\n        self.context.vars.update(kwargs)\n        out = str(self.tpl)\n        self.context.vars.clear()\n        return out\n\n\nclass Jinja2Template(BaseTemplate):\n    def prepare(self, filters=None, tests=None, globals={}, **kwargs):\n        from jinja2 import Environment, FunctionLoader\n        if 'prefix' in kwargs: # TODO: to be removed after a while\n            raise RuntimeError('The keyword argument `prefix` has been removed. '\n                'Use the full jinja2 environment name line_statement_prefix instead.')\n        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)\n        if filters: self.env.filters.update(filters)\n        if tests: self.env.tests.update(tests)\n        if globals: self.env.globals.update(globals)\n        if self.source:\n            self.tpl = self.env.from_string(self.source)\n        else:\n            self.tpl = self.env.get_template(self.filename)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args: kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n    def loader(self, name):\n        fname = self.search(name, self.lookup)\n        if not fname: return\n        with open(fname, \"rb\") as f:\n            return f.read().decode(self.encoding)\n\n\nclass SimpleTemplate(BaseTemplate):\n\n    def prepare(self, escape_func=html_escape, noescape=False, syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n\n    @cached_property\n    def co(self):\n        return compile(self.code, self.filename or '<string>', 'exec')\n\n    @cached_property\n    def code(self):\n        source = self.source\n        if not source:\n            with open(self.filename, 'rb') as f:\n                source = f.read()\n        try:\n            source, encoding = touni(source), 'utf8'\n        except UnicodeError:\n            depr('Template encodings other than utf8 are no longer supported.') #0.11\n            source, encoding = touni(source, 'latin1'), 'latin1'\n        parser = StplParser(source, encoding=encoding, syntax=self.syntax)\n        code = parser.translate()\n        self.encoding = parser.encoding\n        return code\n\n    def _rebase(self, _env, _name=None, **kwargs):\n        if _name is None:\n            depr('Rebase function called without arguments.'\n                 ' You were probably looking for {{base}}?', True) #0.12\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        if _name is None:\n            depr('Rebase function called without arguments.'\n                 ' You were probably looking for {{base}}?', True) #0.12\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup)\n        return self.cache[_name].execute(env['_stdout'], env)\n\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({'_stdout': _stdout, '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env), '_rebase': None,\n            '_str': self._str, '_escape': self._escape, 'get': env.get,\n            'setdefault': env.setdefault, 'defined': env.__contains__ })\n        eval(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout) #copy stdout\n            del _stdout[:] # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}; stdout = []\n        for dictarg in args: env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n\n\nclass StplSyntaxError(TemplateError): pass\n\n\nclass StplParser(object):\n    ''' Parser for stpl templates. '''\n    _re_cache = {} #: Cache for compiled re patterns\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # 1: All kinds of python strings (trust me, it works)\n    _re_tok = '([urbURB]?(?:\\'\\'(?!\\')|\"\"(?!\")|\\'{6}|\"{6}' \\\n               '|\\'(?:[^\\\\\\\\\\']|\\\\\\\\.)+?\\'|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)+?\"' \\\n               '|\\'{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\\'{3}' \\\n               '|\"{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\"{3}))'\n    _re_inl = _re_tok.replace('|\\\\n','') # We re-use this string pattern later\n    # 2: Comments (until end of line, but not the newline itself)\n    _re_tok += '|(#.*)'\n    # 3,4: Open and close grouping tokens\n    _re_tok += '|([\\\\[\\\\{\\\\(])'\n    _re_tok += '|([\\\\]\\\\}\\\\)])'\n    # 5,6: Keywords that start or continue a python block (only start of line)\n    _re_tok += '|^([ \\\\t]*(?:if|for|while|with|try|def|class)\\\\b)' \\\n               '|^([ \\\\t]*(?:elif|else|except|finally)\\\\b)'\n    # 7: Our special 'end' keyword (but only if it stands alone)\n    _re_tok += '|((?:^|;)[ \\\\t]*end[ \\\\t]*(?=(?:%(block_close)s[ \\\\t]*)?\\\\r?$|;|#))'\n    # 8: A customizable end-of-code-block template token (only end of line)\n    _re_tok += '|(%(block_close)s[ \\\\t]*(?=\\\\r?$))'\n    # 9: And finally, a single newline. The 10th token is 'everything else'\n    _re_tok += '|(\\\\r?\\\\n)'\n\n    # Match the start tokens of code areas in a template\n    _re_split = '(?m)^[ \\t]*(\\\\\\\\?)((%(line_start)s)|(%(block_start)s))(%%?)'\n    # Match inline statements (may contain python strings)\n    _re_inl = '(?m)%%(inline_start)s((?:%s|[^\\'\"\\n]*?)+)%%(inline_end)s' % _re_inl\n    _re_tok = '(?m)' + _re_tok\n\n    default_syntax = '<% %> % {{ }}'\n\n    def __init__(self, source, syntax=None, encoding='utf8'):\n        self.source, self.encoding = touni(source, encoding), encoding\n        self.set_syntax(syntax or self.default_syntax)\n        self.code_buffer, self.text_buffer = [], []\n        self.lineno, self.offset = 1, 0\n        self.indent, self.indent_mod = 0, 0\n        self.paren_depth = 0\n\n    def get_syntax(self):\n        ''' Tokens as a space separated string (default: <% %> % {{ }}) '''\n        return self._syntax\n\n    def set_syntax(self, syntax):\n        self._syntax = syntax\n        self._tokens = syntax.split()\n        if not syntax in self._re_cache:\n            names = 'block_start block_close line_start inline_start inline_end'\n            etokens = map(re.escape, self._tokens)\n            pattern_vars = dict(zip(names.split(), etokens))\n            patterns = (self._re_split, self._re_tok, self._re_inl)\n            patterns = [re.compile(p%pattern_vars) for p in patterns]\n            self._re_cache[syntax] = patterns\n        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]\n\n    syntax = property(get_syntax, set_syntax)\n\n    def translate(self):\n        if self.offset: raise RuntimeError('Parser is a one time instance.')\n        while True:\n            m = self.re_split.search(self.source[self.offset:])\n            if m:\n                text = self.source[self.offset:self.offset+m.start()]\n                self.text_buffer.append(text)\n                self.offset += m.end()\n                if m.group(1): # New escape syntax\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(m.group(2)+m.group(5)+line+sep)\n                    self.offset += len(line+sep)+1\n                    continue\n                elif m.group(5): # Old escape syntax\n                    depr('Escape code lines with a backslash.') #0.12\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(m.group(2)+line+sep)\n                    self.offset += len(line+sep)+1\n                    continue\n                self.flush_text()\n                self.read_code(multiline=bool(m.group(4)))\n            else: break\n        self.text_buffer.append(self.source[self.offset:])\n        self.flush_text()\n        return ''.join(self.code_buffer)\n\n    def read_code(self, multiline):\n        code_line, comment = '', ''\n        while True:\n            m = self.re_tok.search(self.source[self.offset:])\n            if not m:\n                code_line += self.source[self.offset:]\n                self.offset = len(self.source)\n                self.write_code(code_line.strip(), comment)\n                return\n            code_line += self.source[self.offset:self.offset+m.start()]\n            self.offset += m.end()\n            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()\n            if (code_line or self.paren_depth > 0) and (_blk1 or _blk2): # a if b else c\n                code_line += _blk1 or _blk2\n                continue\n            if _str:    # Python string\n                code_line += _str\n            elif _com:  # Python comment (up to EOL)\n                comment = _com\n                if multiline and _com.strip().endswith(self._tokens[1]):\n                    multiline = False # Allow end-of-block in comments\n            elif _po:  # open parenthesis\n                self.paren_depth += 1\n                code_line += _po\n            elif _pc:  # close parenthesis\n                if self.paren_depth > 0:\n                    # we could check for matching parentheses here, but it's\n                    # easier to leave that to python - just check counts\n                    self.paren_depth -= 1\n                code_line += _pc\n            elif _blk1: # Start-block keyword (if/for/while/def/try/...)\n                code_line, self.indent_mod = _blk1, -1\n                self.indent += 1\n            elif _blk2: # Continue-block keyword (else/elif/except/...)\n                code_line, self.indent_mod = _blk2, -1\n            elif _end:  # The non-standard 'end'-keyword (ends a block)\n                self.indent -= 1\n            elif _cend: # The end-code-block template token (usually '%>')\n                if multiline: multiline = False\n                else: code_line += _cend\n            else: # \\n\n                self.write_code(code_line.strip(), comment)\n                self.lineno += 1\n                code_line, comment, self.indent_mod = '', '', 0\n                if not multiline:\n                    break\n\n    def flush_text(self):\n        text = ''.join(self.text_buffer)\n        del self.text_buffer[:]\n        if not text: return\n        parts, pos, nl = [], 0, '\\\\\\n'+'  '*self.indent\n        for m in self.re_inl.finditer(text):\n            prefix, pos = text[pos:m.start()], m.end()\n            if prefix:\n                parts.append(nl.join(map(repr, prefix.splitlines(True))))\n            if prefix.endswith('\\n'): parts[-1] += nl\n            parts.append(self.process_inline(m.group(1).strip()))\n        if pos < len(text):\n            prefix = text[pos:]\n            lines = prefix.splitlines(True)\n            if lines[-1].endswith('\\\\\\\\\\n'): lines[-1] = lines[-1][:-3]\n            elif lines[-1].endswith('\\\\\\\\\\r\\n'): lines[-1] = lines[-1][:-4]\n            parts.append(nl.join(map(repr, lines)))\n        code = '_printlist((%s,))' % ', '.join(parts)\n        self.lineno += code.count('\\n')+1\n        self.write_code(code)\n\n    def process_inline(self, chunk):\n        if chunk[0] == '!': return '_str(%s)' % chunk[1:]\n        return '_escape(%s)' % chunk\n\n    def write_code(self, line, comment=''):\n        line, comment = self.fix_backward_compatibility(line, comment)\n        code  = '  ' * (self.indent+self.indent_mod)\n        code += line.lstrip() + comment + '\\n'\n        self.code_buffer.append(code)\n\n    def fix_backward_compatibility(self, line, comment):\n        parts = line.strip().split(None, 2)\n        if parts and parts[0] in ('include', 'rebase'):\n            depr('The include and rebase keywords are functions now.') #0.12\n            if len(parts) == 1:   return \"_printlist([base])\", comment\n            elif len(parts) == 2: return \"_=%s(%r)\" % tuple(parts), comment\n            else:                 return \"_=%s(%r, %s)\" % tuple(parts), comment\n        if self.lineno <= 2 and not line.strip() and 'coding' in comment:\n            m = re.match(r\"#.*coding[:=]\\s*([-\\w.]+)\", comment)\n            if m:\n                depr('PEP263 encoding strings in templates are deprecated.') #0.12\n                enc = m.group(1)\n                self.source = self.source.encode(self.encoding).decode(enc)\n                self.encoding = enc\n                return line, comment.replace('coding','coding*')\n        return line, comment\n\n\ndef template(*args, **kwargs):\n    '''\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    '''\n    tpl = args[0] if args else None\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    for dictarg in args[1:]: kwargs.update(dictarg)\n    return TEMPLATES[tplid].render(kwargs)\n\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template, template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n\n\ndef view(tpl_name, **defaults):\n    ''' Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    '''\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if isinstance(result, (dict, DictMixin)):\n                tplvars = defaults.copy()\n                tplvars.update(result)\n                return template(tpl_name, **tplvars)\n            elif result is None:\n                return template(tpl_name, defaults)\n            return result\n        return wrapper\n    return decorator\n\nmako_view = functools.partial(view, template_adapter=MakoTemplate)\ncheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n\n\n\n\n\n\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\n\n\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()\n\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses\nHTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">\n              html {background-color: #eee; font-family: sans;}\n              body {background-color: #fff; border: 1px solid #ddd;\n                    padding: 15px; margin: 15px;}\n              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}\n            </style>\n        </head>\n        <body>\n            <h1>Error: {{e.status}}</h1>\n            <p>Sorry, the requested URL <tt>{{repr(request.url)}}</tt>\n               caused an error:</p>\n            <pre>{{e.body}}</pre>\n            %%if DEBUG and e.exception:\n              <h2>Exception:</h2>\n              <pre>{{repr(e.exception)}}</pre>\n            %%end\n            %%if DEBUG and e.traceback:\n              <h2>Traceback:</h2>\n              <pre>{{e.traceback}}</pre>\n            %%end\n        </body>\n    </html>\n%%except ImportError:\n    <b>ImportError:</b> Could not generate the error page. Please add bottle to\n    the import path.\n%%end\n\"\"\" % __name__\n\n#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a\n#: request callback, this instance always refers to the *current* request\n#: (even on a multithreaded server).\nrequest = LocalRequest()\n\n#: A thread-safe instance of :class:`LocalResponse`. It is used to change the\n#: HTTP response for the *current* request.\nresponse = LocalResponse()\n\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n\n# Initialize app stack (create first empty Bottle app)\n# BC: 0.6.4 and needed for run()\napp = default_app = AppStack()\napp.push()\n\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else __name__+\".ext\", 'bottle_%s').module\n\nif __name__ == '__main__':\n    opt, args, parser = _cmd_options, _cmd_args, _cmd_parser\n    if opt.version:\n        _stdout('Bottle %s\\n'%__version__)\n        sys.exit(0)\n    if not args:\n        parser.print_help()\n        _stderr('\\nError: No application specified.\\n')\n        sys.exit(1)\n\n    sys.path.insert(0, '.')\n    sys.modules.setdefault('bottle', sys.modules['__main__'])\n\n    host, port = (opt.bind or 'localhost'), 8080\n    if ':' in host and host.rfind(']') < host.rfind(':'):\n        host, port = host.rsplit(':', 1)\n    host = host.strip('[]')\n\n    run(args[0], host=host, port=int(port), server=opt.server,\n        reloader=opt.reload, plugins=opt.plugin, debug=opt.debug)\n\n\n\n\n# THE END\n"], "fixing_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nBottle is a fast and simple micro-framework for small web applications. It\noffers request dispatching (Routes) with url parameter support, templates,\na built-in HTTP Server and adapters for many third party WSGI/HTTP-server and\ntemplate engines - all in a single file and with no dependencies other than the\nPython Standard Library.\n\nHomepage and documentation: http://bottlepy.org/\n\nCopyright (c) 2016, Marcel Hellkamp.\nLicense: MIT (see LICENSE for details)\n\"\"\"\n\nfrom __future__ import with_statement\n\n__author__ = 'Marcel Hellkamp'\n__version__ = '0.12.20'\n__license__ = 'MIT'\n\n# The gevent server adapter needs to patch some modules before they are imported\n# This is why we parse the commandline parameters here but handle them later\nif __name__ == '__main__':\n    from optparse import OptionParser\n    _cmd_parser = OptionParser(usage=\"usage: %prog [options] package.module:app\")\n    _opt = _cmd_parser.add_option\n    _opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    _opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")\n    _opt(\"-s\", \"--server\", default='wsgiref', help=\"use SERVER as backend.\")\n    _opt(\"-p\", \"--plugin\", action=\"append\", help=\"install additional plugin/s.\")\n    _opt(\"--debug\", action=\"store_true\", help=\"start server in debug mode.\")\n    _opt(\"--reload\", action=\"store_true\", help=\"auto-reload on file changes.\")\n    _cmd_options, _cmd_args = _cmd_parser.parse_args()\n    if _cmd_options.server and _cmd_options.server.startswith('gevent'):\n        import gevent.monkey; gevent.monkey.patch_all()\n\nimport base64, cgi, email.utils, functools, hmac, itertools, mimetypes,\\\n        os, re, subprocess, sys, tempfile, threading, time, warnings, hashlib\n\nfrom datetime import date as datedate, datetime, timedelta\nfrom tempfile import TemporaryFile\nfrom traceback import format_exc, print_exc\nfrom inspect import getargspec\nfrom unicodedata import normalize\n\n\ntry: from simplejson import dumps as json_dumps, loads as json_lds\nexcept ImportError: # pragma: no cover\n    try: from json import dumps as json_dumps, loads as json_lds\n    except ImportError:\n        try: from django.utils.simplejson import dumps as json_dumps, loads as json_lds\n        except ImportError:\n            def json_dumps(data):\n                raise ImportError(\"JSON support requires Python 2.6 or simplejson.\")\n            json_lds = json_dumps\n\n\n\n# We now try to fix 2.5/2.6/3.1/3.2 incompatibilities.\n# It ain't pretty but it works... Sorry for the mess.\n\npy   = sys.version_info\npy3k = py >= (3, 0, 0)\npy25 = py <  (2, 6, 0)\npy31 = (3, 1, 0) <= py < (3, 2, 0)\n\n# Workaround for the missing \"as\" keyword in py3k.\ndef _e(): return sys.exc_info()[1]\n\n# Workaround for the \"print is a keyword/function\" Python 2/3 dilemma\n# and a fallback for mod_wsgi (resticts stdout/err attribute access)\ntry:\n    _stdout, _stderr = sys.stdout.write, sys.stderr.write\nexcept IOError:\n    _stdout = lambda x: sys.stdout.write(x)\n    _stderr = lambda x: sys.stderr.write(x)\n\n# Lots of stdlib and builtin differences.\nif py3k:\n    import http.client as httplib\n    import _thread as thread\n    from urllib.parse import urljoin, SplitResult as UrlSplitResult\n    from urllib.parse import urlencode, quote as urlquote, unquote as urlunquote\n    urlunquote = functools.partial(urlunquote, encoding='latin1')\n    from http.cookies import SimpleCookie\n    if py >= (3, 3, 0):\n        from collections.abc import MutableMapping as DictMixin\n        from types import ModuleType as new_module\n    else:\n        from collections import MutableMapping as DictMixin\n        from imp import new_module\n    import pickle\n    from io import BytesIO\n    from configparser import ConfigParser\n    basestring = str\n    unicode = str\n    json_loads = lambda s: json_lds(touni(s))\n    callable = lambda x: hasattr(x, '__call__')\n    imap = map\n    def _raise(*a): raise a[0](a[1]).with_traceback(a[2])\nelse: # 2.x\n    import httplib\n    import thread\n    from urlparse import urljoin, SplitResult as UrlSplitResult\n    from urllib import urlencode, quote as urlquote, unquote as urlunquote\n    from Cookie import SimpleCookie\n    from itertools import imap\n    import cPickle as pickle\n    from imp import new_module\n    from StringIO import StringIO as BytesIO\n    from ConfigParser import SafeConfigParser as ConfigParser\n    if py25:\n        msg  = \"Python 2.5 support may be dropped in future versions of Bottle.\"\n        warnings.warn(msg, DeprecationWarning)\n        from UserDict import DictMixin\n        def next(it): return it.next()\n        bytes = str\n    else: # 2.6, 2.7\n        from collections import MutableMapping as DictMixin\n    unicode = unicode\n    json_loads = json_lds\n    eval(compile('def _raise(*a): raise a[0], a[1], a[2]', '<py3fix>', 'exec'))\n\n# Some helpers for string/byte handling\ndef tob(s, enc='utf8'):\n    return s.encode(enc) if isinstance(s, unicode) else bytes(s)\ndef touni(s, enc='utf8', err='strict'):\n    return s.decode(enc, err) if isinstance(s, bytes) else unicode(s)\ntonat = touni if py3k else tob\n\n# 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n# 3.1 needs a workaround.\nif py31:\n    from io import TextIOWrapper\n    class NCTextIOWrapper(TextIOWrapper):\n        def close(self): pass # Keep wrapped buffer open.\n\n\n# A bug in functools causes it to break if the wrapper is an instance method\ndef update_wrapper(wrapper, wrapped, *a, **ka):\n    try: functools.update_wrapper(wrapper, wrapped, *a, **ka)\n    except AttributeError: pass\n\n\n\n# These helpers are used at module level and need to be defined first.\n# And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.\n\ndef depr(message, hard=False):\n    warnings.warn(message, DeprecationWarning, stacklevel=3)\n\ndef makelist(data): # This is just to handy\n    if isinstance(data, (tuple, list, set, dict)): return list(data)\n    elif data: return [data]\n    else: return []\n\n\nclass DictProperty(object):\n    ''' Property that maps to a key in a local dict-like attribute. '''\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter, self.key = func, self.key or func.__name__\n        return self\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        key, storage = self.key, getattr(obj, self.attr)\n        if key not in storage: storage[key] = self.getter(obj)\n        return storage[key]\n\n    def __set__(self, obj, value):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        getattr(obj, self.attr)[self.key] = value\n\n    def __delete__(self, obj):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        del getattr(obj, self.attr)[self.key]\n\n\nclass cached_property(object):\n    ''' A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. '''\n\n    def __init__(self, func):\n        self.__doc__ = getattr(func, '__doc__')\n        self.func = func\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value\n\n\nclass lazy_attribute(object):\n    ''' A property that caches itself to the class object. '''\n    def __init__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter = func\n\n    def __get__(self, obj, cls):\n        value = self.getter(cls)\n        setattr(cls, self.__name__, value)\n        return value\n\n\n\n\n\n\n###############################################################################\n# Exceptions and Events ########################################################\n###############################################################################\n\n\nclass BottleException(Exception):\n    \"\"\" A base class for exceptions used by bottle. \"\"\"\n    pass\n\n\n\n\n\n\n###############################################################################\n# Routing ######################################################################\n###############################################################################\n\n\nclass RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\n\n\nclass RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all\n        plugins are re-applied. \"\"\"\n\nclass RouterUnknownModeError(RouteError): pass\n\n\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\n\n\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\n\n\ndef _re_flatten(p):\n    ''' Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. '''\n    if '(' not in p: return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))',\n        lambda m: m.group(0) if len(m.group(1)) % 2 else m.group(1) + '(?:', p)\n\n\nclass Router(object):\n    ''' A Router is an ordered collection of route->target pairs. It is used to\n        efficiently match WSGI requests against a number of routes and return\n        the first target that satisfies the request. The target may be anything,\n        usually a string, ID or callable object. A route consists of a path-rule\n        and a HTTP method.\n\n        The path-rule is either a static path (e.g. `/contact`) or a dynamic\n        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax\n        and details on the matching order are described in docs:`routing`.\n    '''\n\n    default_pattern = '[^/]+'\n    default_filter  = 're'\n\n    #: The current CPython regexp implementation does not allow more\n    #: than 99 matching groups per regular expression.\n    _MAX_GROUPS_PER_PATTERN = 99\n\n    def __init__(self, strict=False):\n        self.rules    = [] # All rules in order\n        self._groups  = {} # index of regexes to find them in dyna_routes\n        self.builder  = {} # Data structure for the url builder\n        self.static   = {} # Search structure for static routes\n        self.dyna_routes   = {}\n        self.dyna_regexes  = {} # Search structure for dynamic routes\n        #: If true, static routes are no longer checked first.\n        self.strict_order = strict\n        self.filters = {\n            're':    lambda conf:\n                (_re_flatten(conf or self.default_pattern), None, None),\n            'int':   lambda conf: (r'-?\\d+', int, lambda x: str(int(x))),\n            'float': lambda conf: (r'-?[\\d.]+', float, lambda x: str(float(x))),\n            'path':  lambda conf: (r'.+?', None, None)}\n\n    def add_filter(self, name, func):\n        ''' Add a filter. The provided function is called with the configuration\n        string as parameter and must return a (regexp, to_python, to_url) tuple.\n        The first element is a string, the last two are callables or None. '''\n        self.filters[name] = func\n\n    rule_syntax = re.compile('(\\\\\\\\*)'\\\n        '(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'\\\n          '|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'\\\n            '(?::((?:\\\\\\\\.|[^\\\\\\\\>]+)+)?)?)?>))')\n\n    def _itertokens(self, rule):\n        offset, prefix = 0, ''\n        for match in self.rule_syntax.finditer(rule):\n            prefix += rule[offset:match.start()]\n            g = match.groups()\n            if len(g[0])%2: # Escaped wildcard\n                prefix += match.group(0)[len(g[0]):]\n                offset = match.end()\n                continue\n            if prefix:\n                yield prefix, None, None\n            name, filtr, conf = g[4:7] if g[2] is None else g[1:4]\n            yield name, filtr or 'default', conf or None\n            offset, prefix = match.end(), ''\n        if offset <= len(rule) or prefix:\n            yield prefix+rule[offset:], None, None\n\n    def add(self, rule, method, target, name=None):\n        ''' Add a new rule or replace the target for an existing rule. '''\n        anons     = 0    # Number of anonymous wildcards found\n        keys      = []   # Names of keys\n        pattern   = ''   # Regular expression pattern with named groups\n        filters   = []   # Lists of wildcard input filters\n        builder   = []   # Data structure for the URL builder\n        is_static = True\n\n        for key, mode, conf in self._itertokens(rule):\n            if mode:\n                is_static = False\n                if mode == 'default': mode = self.default_filter\n                mask, in_filter, out_filter = self.filters[mode](conf)\n                if not key:\n                    pattern += '(?:%s)' % mask\n                    key = 'anon%d' % anons\n                    anons += 1\n                else:\n                    pattern += '(?P<%s>%s)' % (key, mask)\n                    keys.append(key)\n                if in_filter: filters.append((key, in_filter))\n                builder.append((key, out_filter or str))\n            elif key:\n                pattern += re.escape(key)\n                builder.append((None, key))\n\n        self.builder[rule] = builder\n        if name: self.builder[name] = builder\n\n        if is_static and not self.strict_order:\n            self.static.setdefault(method, {})\n            self.static[method][self.build(rule)] = (target, None)\n            return\n\n        try:\n            re_pattern = re.compile('^(%s)$' % pattern)\n            re_match = re_pattern.match\n        except re.error:\n            raise RouteSyntaxError(\"Could not add Route: %s (%s)\" % (rule, _e()))\n\n        if filters:\n            def getargs(path):\n                url_args = re_match(path).groupdict()\n                for name, wildcard_filter in filters:\n                    try:\n                        url_args[name] = wildcard_filter(url_args[name])\n                    except ValueError:\n                        raise HTTPError(400, 'Path has wrong format.')\n                return url_args\n        elif re_pattern.groupindex:\n            def getargs(path):\n                return re_match(path).groupdict()\n        else:\n            getargs = None\n\n        flatpat = _re_flatten(pattern)\n        whole_rule = (rule, flatpat, target, getargs)\n\n        if (flatpat, method) in self._groups:\n            if DEBUG:\n                msg = 'Route <%s %s> overwrites a previously defined route'\n                warnings.warn(msg % (method, rule), RuntimeWarning)\n            self.dyna_routes[method][self._groups[flatpat, method]] = whole_rule\n        else:\n            self.dyna_routes.setdefault(method, []).append(whole_rule)\n            self._groups[flatpat, method] = len(self.dyna_routes[method]) - 1\n\n        self._compile(method)\n\n    def _compile(self, method):\n        all_rules = self.dyna_routes[method]\n        comborules = self.dyna_regexes[method] = []\n        maxgroups = self._MAX_GROUPS_PER_PATTERN\n        for x in range(0, len(all_rules), maxgroups):\n            some = all_rules[x:x+maxgroups]\n            combined = (flatpat for (_, flatpat, _, _) in some)\n            combined = '|'.join('(^%s$)' % flatpat for flatpat in combined)\n            combined = re.compile(combined).match\n            rules = [(target, getargs) for (_, _, target, getargs) in some]\n            comborules.append((combined, rules))\n\n    def build(self, _name, *anons, **query):\n        ''' Build an URL by filling the wildcards in a rule. '''\n        builder = self.builder.get(_name)\n        if not builder: raise RouteBuildError(\"No route with that name.\", _name)\n        try:\n            for i, value in enumerate(anons): query['anon%d'%i] = value\n            url = ''.join([f(query.pop(n)) if n else f for (n,f) in builder])\n            return url if not query else url+'?'+urlencode(query)\n        except KeyError:\n            raise RouteBuildError('Missing URL argument: %r' % _e().args[0])\n\n    def match(self, environ):\n        ''' Return a (target, url_agrs) tuple or raise HTTPError(400/404/405). '''\n        verb = environ['REQUEST_METHOD'].upper()\n        path = environ['PATH_INFO'] or '/'\n        target = None\n        if verb == 'HEAD':\n            methods = ['PROXY', verb, 'GET', 'ANY']\n        else:\n            methods = ['PROXY', verb, 'ANY']\n\n        for method in methods:\n            if method in self.static and path in self.static[method]:\n                target, getargs = self.static[method][path]\n                return target, getargs(path) if getargs else {}\n            elif method in self.dyna_regexes:\n                for combined, rules in self.dyna_regexes[method]:\n                    match = combined(path)\n                    if match:\n                        target, getargs = rules[match.lastindex - 1]\n                        return target, getargs(path) if getargs else {}\n\n        # No matching route found. Collect alternative methods for 405 response\n        allowed = set([])\n        nocheck = set(methods)\n        for method in set(self.static) - nocheck:\n            if path in self.static[method]:\n                allowed.add(method)\n        for method in set(self.dyna_regexes) - allowed - nocheck:\n            for combined, rules in self.dyna_regexes[method]:\n                match = combined(path)\n                if match:\n                    allowed.add(method)\n        if allowed:\n            allow_header = \",\".join(sorted(allowed))\n            raise HTTPError(405, \"Method not allowed.\", Allow=allow_header)\n\n        # No matching route and no alternative method found. We give up\n        raise HTTPError(404, \"Not found: \" + repr(path))\n\n\n\n\n\n\nclass Route(object):\n    ''' This class wraps a route callback along with route specific metadata and\n        configuration and applies Plugins on demand. It is also responsible for\n        turing an URL path rule into a regular expression usable by the Router.\n    '''\n\n    def __init__(self, app, rule, method, callback, name=None,\n                 plugins=None, skiplist=None, **config):\n        #: The application this route is installed to.\n        self.app = app\n        #: The path-rule string (e.g. ``/wiki/:page``).\n        self.rule = rule\n        #: The HTTP method as a string (e.g. ``GET``).\n        self.method = method\n        #: The original callback with no plugins applied. Useful for introspection.\n        self.callback = callback\n        #: The name of the route (if specified) or ``None``.\n        self.name = name or None\n        #: A list of route-specific plugins (see :meth:`Bottle.route`).\n        self.plugins = plugins or []\n        #: A list of plugins to not apply to this route (see :meth:`Bottle.route`).\n        self.skiplist = skiplist or []\n        #: Additional keyword arguments passed to the :meth:`Bottle.route`\n        #: decorator are stored in this dictionary. Used for route-specific\n        #: plugin configuration and meta-data.\n        self.config = ConfigDict().load_dict(config, make_namespaces=True)\n\n    def __call__(self, *a, **ka):\n        depr(\"Some APIs changed to return Route() instances instead of\"\\\n             \" callables. Make sure to use the Route.call method and not to\"\\\n             \" call Route instances directly.\") #0.12\n        return self.call(*a, **ka)\n\n    @cached_property\n    def call(self):\n        ''' The route callback with all plugins applied. This property is\n            created on demand and then cached to speed up subsequent requests.'''\n        return self._make_callback()\n\n    def reset(self):\n        ''' Forget any cached values. The next time :attr:`call` is accessed,\n            all plugins are re-applied. '''\n        self.__dict__.pop('call', None)\n\n    def prepare(self):\n        ''' Do all on-demand work immediately (useful for debugging).'''\n        self.call\n\n    @property\n    def _context(self):\n        depr('Switch to Plugin API v2 and access the Route object directly.')  #0.12\n        return dict(rule=self.rule, method=self.method, callback=self.callback,\n                    name=self.name, app=self.app, config=self.config,\n                    apply=self.plugins, skip=self.skiplist)\n\n    def all_plugins(self):\n        ''' Yield all Plugins affecting this route. '''\n        unique = set()\n        for p in reversed(self.app.plugins + self.plugins):\n            if True in self.skiplist: break\n            name = getattr(p, 'name', False)\n            if name and (name in self.skiplist or name in unique): continue\n            if p in self.skiplist or type(p) in self.skiplist: continue\n            if name: unique.add(name)\n            yield p\n\n    def _make_callback(self):\n        callback = self.callback\n        for plugin in self.all_plugins():\n            try:\n                if hasattr(plugin, 'apply'):\n                    api = getattr(plugin, 'api', 1)\n                    context = self if api > 1 else self._context\n                    callback = plugin.apply(callback, context)\n                else:\n                    callback = plugin(callback)\n            except RouteReset: # Try again with changed configuration.\n                return self._make_callback()\n            if not callback is self.callback:\n                update_wrapper(callback, self.callback)\n        return callback\n\n    def get_undecorated_callback(self):\n        ''' Return the callback. If the callback is a decorated function, try to\n            recover the original function. '''\n        func = self.callback\n        func = getattr(func, '__func__' if py3k else 'im_func', func)\n        closure_attr = '__closure__' if py3k else 'func_closure'\n        while hasattr(func, closure_attr) and getattr(func, closure_attr):\n            func = getattr(func, closure_attr)[0].cell_contents\n        return func\n\n    def get_callback_args(self):\n        ''' Return a list of argument names the callback (most likely) accepts\n            as keyword arguments. If the callback is a decorated function, try\n            to recover the original function before inspection. '''\n        return getargspec(self.get_undecorated_callback())[0]\n\n    def get_config(self, key, default=None):\n        ''' Lookup a config field and return its value, first checking the\n            route.config, then route.app.config.'''\n        for conf in (self.config, self.app.conifg):\n            if key in conf: return conf[key]\n        return default\n\n    def __repr__(self):\n        cb = self.get_undecorated_callback()\n        return '<%s %r %r>' % (self.method, self.rule, cb)\n\n\n\n\n\n\n###############################################################################\n# Application Object ###########################################################\n###############################################################################\n\n\nclass Bottle(object):\n    \"\"\" Each Bottle object represents a single, distinct web application and\n        consists of routes, callbacks, plugins, resources and configuration.\n        Instances are callable WSGI applications.\n\n        :param catchall: If true (default), handle all exceptions. Turn off to\n                         let debugging middleware handle exceptions.\n    \"\"\"\n\n    def __init__(self, catchall=True, autojson=True):\n\n        #: A :class:`ConfigDict` for app specific configuration.\n        self.config = ConfigDict()\n        self.config._on_change = functools.partial(self.trigger_hook, 'config')\n        self.config.meta_set('autojson', 'validate', bool)\n        self.config.meta_set('catchall', 'validate', bool)\n        self.config['catchall'] = catchall\n        self.config['autojson'] = autojson\n\n        #: A :class:`ResourceManager` for application files\n        self.resources = ResourceManager()\n\n        self.routes = [] # List of installed :class:`Route` instances.\n        self.router = Router() # Maps requests to :class:`Route` instances.\n        self.error_handler = {}\n\n        # Core plugins\n        self.plugins = [] # List of installed plugins.\n        if self.config['autojson']:\n            self.install(JSONPlugin())\n        self.install(TemplatePlugin())\n\n    #: If true, most exceptions are caught and returned as :exc:`HTTPError`\n    catchall = DictProperty('config', 'catchall')\n\n    __hook_names = 'before_request', 'after_request', 'app_reset', 'config'\n    __hook_reversed = 'after_request'\n\n    @cached_property\n    def _hooks(self):\n        return dict((name, []) for name in self.__hook_names)\n\n    def add_hook(self, name, func):\n        ''' Attach a callback to a hook. Three hooks are currently implemented:\n\n            before_request\n                Executed once before each request. The request context is\n                available, but no routing has happened yet.\n            after_request\n                Executed once after each request regardless of its outcome.\n            app_reset\n                Called whenever :meth:`Bottle.reset` is called.\n        '''\n        if name in self.__hook_reversed:\n            self._hooks[name].insert(0, func)\n        else:\n            self._hooks[name].append(func)\n\n    def remove_hook(self, name, func):\n        ''' Remove a callback from a hook. '''\n        if name in self._hooks and func in self._hooks[name]:\n            self._hooks[name].remove(func)\n            return True\n\n    def trigger_hook(self, __name, *args, **kwargs):\n        ''' Trigger a hook and return a list of results. '''\n        return [hook(*args, **kwargs) for hook in self._hooks[__name][:]]\n\n    def hook(self, name):\n        \"\"\" Return a decorator that attaches a callback to a hook. See\n            :meth:`add_hook` for details.\"\"\"\n        def decorator(func):\n            self.add_hook(name, func)\n            return func\n        return decorator\n\n    def mount(self, prefix, app, **options):\n        ''' Mount an application (:class:`Bottle` or plain WSGI) to a specific\n            URL prefix. Example::\n\n                root_app.mount('/admin/', admin_app)\n\n            :param prefix: path prefix or `mount-point`. If it ends in a slash,\n                that slash is mandatory.\n            :param app: an instance of :class:`Bottle` or a WSGI application.\n\n            All other parameters are passed to the underlying :meth:`route` call.\n        '''\n        if isinstance(app, basestring):\n            depr('Parameter order of Bottle.mount() changed.', True) # 0.10\n\n        segments = [p for p in prefix.split('/') if p]\n        if not segments: raise ValueError('Empty path prefix.')\n        path_depth = len(segments)\n\n        def mountpoint_wrapper():\n            try:\n                request.path_shift(path_depth)\n                rs = HTTPResponse([])\n                def start_response(status, headerlist, exc_info=None):\n                    if exc_info:\n                        try:\n                            _raise(*exc_info)\n                        finally:\n                            exc_info = None\n                    rs.status = status\n                    for name, value in headerlist: rs.add_header(name, value)\n                    return rs.body.append\n                body = app(request.environ, start_response)\n                if body and rs.body: body = itertools.chain(rs.body, body)\n                rs.body = body or rs.body\n                return rs\n            finally:\n                request.path_shift(-path_depth)\n\n        options.setdefault('skip', True)\n        options.setdefault('method', 'PROXY')\n        options.setdefault('mountpoint', {'prefix': prefix, 'target': app})\n        options['callback'] = mountpoint_wrapper\n\n        self.route('/%s/<:re:.*>' % '/'.join(segments), **options)\n        if not prefix.endswith('/'):\n            self.route('/' + '/'.join(segments), **options)\n\n    def merge(self, routes):\n        ''' Merge the routes of another :class:`Bottle` application or a list of\n            :class:`Route` objects into this application. The routes keep their\n            'owner', meaning that the :data:`Route.app` attribute is not\n            changed. '''\n        if isinstance(routes, Bottle):\n            routes = routes.routes\n        for route in routes:\n            self.add_route(route)\n\n    def install(self, plugin):\n        ''' Add a plugin to the list of plugins and prepare it for being\n            applied to all routes of this application. A plugin may be a simple\n            decorator or an object that implements the :class:`Plugin` API.\n        '''\n        if hasattr(plugin, 'setup'): plugin.setup(self)\n        if not callable(plugin) and not hasattr(plugin, 'apply'):\n            raise TypeError(\"Plugins must be callable or implement .apply()\")\n        self.plugins.append(plugin)\n        self.reset()\n        return plugin\n\n    def uninstall(self, plugin):\n        ''' Uninstall plugins. Pass an instance to remove a specific plugin, a type\n            object to remove all plugins that match that type, a string to remove\n            all plugins with a matching ``name`` attribute or ``True`` to remove all\n            plugins. Return the list of removed plugins. '''\n        removed, remove = [], plugin\n        for i, plugin in list(enumerate(self.plugins))[::-1]:\n            if remove is True or remove is plugin or remove is type(plugin) \\\n            or getattr(plugin, 'name', True) == remove:\n                removed.append(plugin)\n                del self.plugins[i]\n                if hasattr(plugin, 'close'): plugin.close()\n        if removed: self.reset()\n        return removed\n\n    def reset(self, route=None):\n        ''' Reset all routes (force plugins to be re-applied) and clear all\n            caches. If an ID or route object is given, only that specific route\n            is affected. '''\n        if route is None: routes = self.routes\n        elif isinstance(route, Route): routes = [route]\n        else: routes = [self.routes[route]]\n        for route in routes: route.reset()\n        if DEBUG:\n            for route in routes: route.prepare()\n        self.trigger_hook('app_reset')\n\n    def close(self):\n        ''' Close the application and all installed plugins. '''\n        for plugin in self.plugins:\n            if hasattr(plugin, 'close'): plugin.close()\n        self.stopped = True\n\n    def run(self, **kwargs):\n        ''' Calls :func:`run` with the same parameters. '''\n        run(self, **kwargs)\n\n    def match(self, environ):\n        \"\"\" Search for a matching route and return a (:class:`Route` , urlargs)\n            tuple. The second value is a dictionary with parameters extracted\n            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.\"\"\"\n        return self.router.match(environ)\n\n    def get_url(self, routename, **kargs):\n        \"\"\" Return a string that matches a named route \"\"\"\n        scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'\n        location = self.router.build(routename, **kargs).lstrip('/')\n        return urljoin(urljoin('/', scriptname), location)\n\n    def add_route(self, route):\n        ''' Add a route object, but do not change the :data:`Route.app`\n            attribute.'''\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n\n    def route(self, path=None, method='GET', callback=None, name=None,\n              apply=None, skip=None, **config):\n        \"\"\" A decorator to bind a function to a request URL. Example::\n\n                @app.route('/hello/:name')\n                def hello(name):\n                    return 'Hello %s' % name\n\n            The ``:name`` part is a wildcard. See :class:`Router` for syntax\n            details.\n\n            :param path: Request path or a list of paths to listen to. If no\n              path is specified, it is automatically generated from the\n              signature of the function.\n            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of\n              methods to listen to. (default: `GET`)\n            :param callback: An optional shortcut to avoid the decorator\n              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``\n            :param name: The name for this route. (default: None)\n            :param apply: A decorator or plugin or a list of plugins. These are\n              applied to the route callback in addition to installed plugins.\n            :param skip: A list of plugins, plugin classes or names. Matching\n              plugins are not installed to this route. ``True`` skips all.\n\n            Any additional keyword arguments are stored as route-specific\n            configuration and passed to plugins (see :meth:`Plugin.apply`).\n        \"\"\"\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n        def decorator(callback):\n            # TODO: Documentation and tests\n            if isinstance(callback, basestring): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback, name=name,\n                                  plugins=plugins, skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n        return decorator(callback) if callback else decorator\n\n    def get(self, path=None, method='GET', **options):\n        \"\"\" Equals :meth:`route`. \"\"\"\n        return self.route(path, method, **options)\n\n    def post(self, path=None, method='POST', **options):\n        \"\"\" Equals :meth:`route` with a ``POST`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def put(self, path=None, method='PUT', **options):\n        \"\"\" Equals :meth:`route` with a ``PUT`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def delete(self, path=None, method='DELETE', **options):\n        \"\"\" Equals :meth:`route` with a ``DELETE`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def error(self, code=500):\n        \"\"\" Decorator: Register an output handler for a HTTP error code\"\"\"\n        def wrapper(handler):\n            self.error_handler[int(code)] = handler\n            return handler\n        return wrapper\n\n    def default_error_handler(self, res):\n        return tob(template(ERROR_PAGE_TEMPLATE, e=res))\n\n    def _handle(self, environ):\n        try:\n\n            environ['bottle.app'] = self\n            request.bind(environ)\n            response.bind()\n\n            path = environ['bottle.raw_path'] = environ['PATH_INFO']\n            if py3k:\n                try:\n                    environ['PATH_INFO'] = path.encode('latin1').decode('utf8')\n                except UnicodeError:\n                    return HTTPError(400, 'Invalid path string. Expected UTF-8')\n\n            try:\n                self.trigger_hook('before_request')\n                route, args = self.router.match(environ)\n                environ['route.handle'] = route\n                environ['bottle.route'] = route\n                environ['route.url_args'] = args\n                return route.call(**args)\n            finally:\n                self.trigger_hook('after_request')\n\n        except HTTPResponse:\n            return _e()\n        except RouteReset:\n            route.reset()\n            return self._handle(environ)\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception:\n            if not self.catchall: raise\n            stacktrace = format_exc()\n            environ['wsgi.errors'].write(stacktrace)\n            return HTTPError(500, \"Internal Server Error\", _e(), stacktrace)\n\n    def _cast(self, out, peek=None):\n        \"\"\" Try to convert the parameter into something WSGI compatible and set\n        correct HTTP headers when possible.\n        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,\n        iterable of strings and iterable of unicodes\n        \"\"\"\n\n        # Empty output is done here\n        if not out:\n            if 'Content-Length' not in response:\n                response['Content-Length'] = 0\n            return []\n        # Join lists of byte or unicode strings. Mixed lists are NOT supported\n        if isinstance(out, (tuple, list))\\\n        and isinstance(out[0], (bytes, unicode)):\n            out = out[0][0:0].join(out) # b'abc'[0:0] -> b''\n        # Encode unicode strings\n        if isinstance(out, unicode):\n            out = out.encode(response.charset)\n        # Byte Strings are just returned\n        if isinstance(out, bytes):\n            if 'Content-Length' not in response:\n                response['Content-Length'] = len(out)\n            return [out]\n        # HTTPError or HTTPException (recursive, because they may wrap anything)\n        # TODO: Handle these explicitly in handle() or make them iterable.\n        if isinstance(out, HTTPError):\n            out.apply(response)\n            out = self.error_handler.get(out.status_code, self.default_error_handler)(out)\n            return self._cast(out)\n        if isinstance(out, HTTPResponse):\n            out.apply(response)\n            return self._cast(out.body)\n\n        # File-like objects.\n        if hasattr(out, 'read'):\n            if 'wsgi.file_wrapper' in request.environ:\n                return request.environ['wsgi.file_wrapper'](out)\n            elif hasattr(out, 'close') or not hasattr(out, '__iter__'):\n                return WSGIFileWrapper(out)\n\n        # Handle Iterables. We peek into them to detect their inner type.\n        try:\n            iout = iter(out)\n            first = next(iout)\n            while not first:\n                first = next(iout)\n        except StopIteration:\n            return self._cast('')\n        except HTTPResponse:\n            first = _e()\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception:\n            if not self.catchall: raise\n            first = HTTPError(500, 'Unhandled exception', _e(), format_exc())\n\n        # These are the inner types allowed in iterator or generator objects.\n        if isinstance(first, HTTPResponse):\n            return self._cast(first)\n        elif isinstance(first, bytes):\n            new_iter = itertools.chain([first], iout)\n        elif isinstance(first, unicode):\n            encoder = lambda x: x.encode(response.charset)\n            new_iter = imap(encoder, itertools.chain([first], iout))\n        else:\n            msg = 'Unsupported response type: %s' % type(first)\n            return self._cast(HTTPError(500, msg))\n        if hasattr(out, 'close'):\n            new_iter = _closeiter(new_iter, out.close)\n        return new_iter\n\n    def wsgi(self, environ, start_response):\n        \"\"\" The bottle WSGI-interface. \"\"\"\n        try:\n            out = self._cast(self._handle(environ))\n            # rfc2616 section 4.3\n            if response._status_code in (100, 101, 204, 304)\\\n            or environ['REQUEST_METHOD'] == 'HEAD':\n                if hasattr(out, 'close'): out.close()\n                out = []\n            start_response(response._status_line, response.headerlist)\n            return out\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception:\n            if not self.catchall: raise\n            err = '<h1>Critical error while processing request: %s</h1>' \\\n                  % html_escape(environ.get('PATH_INFO', '/'))\n            if DEBUG:\n                err += '<h2>Error:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       '<h2>Traceback:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       % (html_escape(repr(_e())), html_escape(format_exc()))\n            environ['wsgi.errors'].write(err)\n            headers = [('Content-Type', 'text/html; charset=UTF-8')]\n            start_response('500 INTERNAL SERVER ERROR', headers, sys.exc_info())\n            return [tob(err)]\n\n    def __call__(self, environ, start_response):\n        ''' Each instance of :class:'Bottle' is a WSGI application. '''\n        return self.wsgi(environ, start_response)\n\n\n\n\n\n\n###############################################################################\n# HTTP and WSGI Tools ##########################################################\n###############################################################################\n\nclass BaseRequest(object):\n    \"\"\" A wrapper for WSGI environment dictionaries that adds a lot of\n        convenient access methods and properties. Most of them are read-only.\n\n        Adding new attributes to a request actually adds them to the environ\n        dictionary (as 'bottle.request.ext.<name>'). This is the recommended\n        way to store and access request-specific data.\n    \"\"\"\n\n    __slots__ = ('environ')\n\n    #: Maximum size of memory buffer for :attr:`body` in bytes.\n    MEMFILE_MAX = 102400\n\n    def __init__(self, environ=None):\n        \"\"\" Wrap a WSGI environ dictionary. \"\"\"\n        #: The wrapped WSGI environ dictionary. This is the only real attribute.\n        #: All other attributes actually are read-only properties.\n        self.environ = {} if environ is None else environ\n        self.environ['bottle.request'] = self\n\n    @DictProperty('environ', 'bottle.app', read_only=True)\n    def app(self):\n        ''' Bottle application handling this request. '''\n        raise RuntimeError('This request is not connected to an application.')\n\n    @DictProperty('environ', 'bottle.route', read_only=True)\n    def route(self):\n        \"\"\" The bottle :class:`Route` object that matches this request. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @DictProperty('environ', 'route.url_args', read_only=True)\n    def url_args(self):\n        \"\"\" The arguments extracted from the URL. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @property\n    def path(self):\n        ''' The value of ``PATH_INFO`` with exactly one prefixed slash (to fix\n            broken clients and avoid the \"empty path\" edge case). '''\n        return '/' + self.environ.get('PATH_INFO','').lstrip('/')\n\n    @property\n    def method(self):\n        ''' The ``REQUEST_METHOD`` value as an uppercase string. '''\n        return self.environ.get('REQUEST_METHOD', 'GET').upper()\n\n    @DictProperty('environ', 'bottle.request.headers', read_only=True)\n    def headers(self):\n        ''' A :class:`WSGIHeaderDict` that provides case-insensitive access to\n            HTTP request headers. '''\n        return WSGIHeaderDict(self.environ)\n\n    def get_header(self, name, default=None):\n        ''' Return the value of a request header, or a given default value. '''\n        return self.headers.get(name, default)\n\n    @DictProperty('environ', 'bottle.request.cookies', read_only=True)\n    def cookies(self):\n        \"\"\" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT\n            decoded. Use :meth:`get_cookie` if you expect signed cookies. \"\"\"\n        cookies = SimpleCookie(self.environ.get('HTTP_COOKIE','')).values()\n        return FormsDict((c.key, c.value) for c in cookies)\n\n    def get_cookie(self, key, default=None, secret=None):\n        \"\"\" Return the content of a cookie. To read a `Signed Cookie`, the\n            `secret` must match the one used to create the cookie (see\n            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing\n            cookie or wrong signature), return a default value. \"\"\"\n        value = self.cookies.get(key)\n        if secret and value:\n            dec = cookie_decode(value, secret) # (key, value) tuple or None\n            return dec[1] if dec and dec[0] == key else default\n        return value or default\n\n    @DictProperty('environ', 'bottle.request.query', read_only=True)\n    def query(self):\n        ''' The :attr:`query_string` parsed into a :class:`FormsDict`. These\n            values are sometimes called \"URL arguments\" or \"GET parameters\", but\n            not to be confused with \"URL wildcards\" as they are provided by the\n            :class:`Router`. '''\n        get = self.environ['bottle.get'] = FormsDict()\n        pairs = _parse_qsl(self.environ.get('QUERY_STRING', ''))\n        for key, value in pairs:\n            get[key] = value\n        return get\n\n    @DictProperty('environ', 'bottle.request.forms', read_only=True)\n    def forms(self):\n        \"\"\" Form values parsed from an `url-encoded` or `multipart/form-data`\n            encoded POST or PUT request body. The result is returned as a\n            :class:`FormsDict`. All keys and values are strings. File uploads\n            are stored separately in :attr:`files`. \"\"\"\n        forms = FormsDict()\n        for name, item in self.POST.allitems():\n            if not isinstance(item, FileUpload):\n                forms[name] = item\n        return forms\n\n    @DictProperty('environ', 'bottle.request.params', read_only=True)\n    def params(self):\n        \"\"\" A :class:`FormsDict` with the combined values of :attr:`query` and\n            :attr:`forms`. File uploads are stored in :attr:`files`. \"\"\"\n        params = FormsDict()\n        for key, value in self.query.allitems():\n            params[key] = value\n        for key, value in self.forms.allitems():\n            params[key] = value\n        return params\n\n    @DictProperty('environ', 'bottle.request.files', read_only=True)\n    def files(self):\n        \"\"\" File uploads parsed from `multipart/form-data` encoded POST or PUT\n            request body. The values are instances of :class:`FileUpload`.\n\n        \"\"\"\n        files = FormsDict()\n        for name, item in self.POST.allitems():\n            if isinstance(item, FileUpload):\n                files[name] = item\n        return files\n\n    @DictProperty('environ', 'bottle.request.json', read_only=True)\n    def json(self):\n        ''' If the ``Content-Type`` header is ``application/json``, this\n            property holds the parsed content of the request body. Only requests\n            smaller than :attr:`MEMFILE_MAX` are processed to avoid memory\n            exhaustion. '''\n        ctype = self.environ.get('CONTENT_TYPE', '').lower().split(';')[0]\n        if ctype == 'application/json':\n            b = self._get_body_string()\n            if not b:\n                return None\n            return json_loads(b)\n        return None\n\n    def _iter_body(self, read, bufsize):\n        maxread = max(0, self.content_length)\n        while maxread:\n            part = read(min(maxread, bufsize))\n            if not part: break\n            yield part\n            maxread -= len(part)\n\n    def _iter_chunked(self, read, bufsize):\n        err = HTTPError(400, 'Error while parsing chunked transfer body.')\n        rn, sem, bs = tob('\\r\\n'), tob(';'), tob('')\n        while True:\n            header = read(1)\n            while header[-2:] != rn:\n                c = read(1)\n                header += c\n                if not c: raise err\n                if len(header) > bufsize: raise err\n            size, _, _ = header.partition(sem)\n            try:\n                maxread = int(tonat(size.strip()), 16)\n            except ValueError:\n                raise err\n            if maxread == 0: break\n            buff = bs\n            while maxread > 0:\n                if not buff:\n                    buff = read(min(maxread, bufsize))\n                part, buff = buff[:maxread], buff[maxread:]\n                if not part: raise err\n                yield part\n                maxread -= len(part)\n            if read(2) != rn:\n                raise err\n\n    @DictProperty('environ', 'bottle.request.body', read_only=True)\n    def _body(self):\n        body_iter = self._iter_chunked if self.chunked else self._iter_body\n        read_func = self.environ['wsgi.input'].read\n        body, body_size, is_temp_file = BytesIO(), 0, False\n        for part in body_iter(read_func, self.MEMFILE_MAX):\n            body.write(part)\n            body_size += len(part)\n            if not is_temp_file and body_size > self.MEMFILE_MAX:\n                body, tmp = TemporaryFile(mode='w+b'), body\n                body.write(tmp.getvalue())\n                del tmp\n                is_temp_file = True\n        self.environ['wsgi.input'] = body\n        body.seek(0)\n        return body\n\n    def _get_body_string(self):\n        ''' read body until content-length or MEMFILE_MAX into a string. Raise\n            HTTPError(413) on requests that are to large. '''\n        clen = self.content_length\n        if clen > self.MEMFILE_MAX:\n            raise HTTPError(413, 'Request to large')\n        if clen < 0: clen = self.MEMFILE_MAX + 1\n        data = self.body.read(clen)\n        if len(data) > self.MEMFILE_MAX: # Fail fast\n            raise HTTPError(413, 'Request to large')\n        return data\n\n    @property\n    def body(self):\n        \"\"\" The HTTP request body as a seek-able file-like object. Depending on\n            :attr:`MEMFILE_MAX`, this is either a temporary file or a\n            :class:`io.BytesIO` instance. Accessing this property for the first\n            time reads and replaces the ``wsgi.input`` environ variable.\n            Subsequent accesses just do a `seek(0)` on the file object. \"\"\"\n        self._body.seek(0)\n        return self._body\n\n    @property\n    def chunked(self):\n        ''' True if Chunked transfer encoding was. '''\n        return 'chunked' in self.environ.get('HTTP_TRANSFER_ENCODING', '').lower()\n\n    #: An alias for :attr:`query`.\n    GET = query\n\n    @DictProperty('environ', 'bottle.request.post', read_only=True)\n    def POST(self):\n        \"\"\" The values of :attr:`forms` and :attr:`files` combined into a single\n            :class:`FormsDict`. Values are either strings (form values) or\n            instances of :class:`cgi.FieldStorage` (file uploads).\n        \"\"\"\n        post = FormsDict()\n        # We default to application/x-www-form-urlencoded for everything that\n        # is not multipart and take the fast path (also: 3.1 workaround)\n        if not self.content_type.startswith('multipart/'):\n            pairs = _parse_qsl(tonat(self._get_body_string(), 'latin1'))\n            for key, value in pairs:\n                post[key] = value\n            return post\n\n        safe_env = {'QUERY_STRING':''} # Build a safe environment for cgi\n        for key in ('REQUEST_METHOD', 'CONTENT_TYPE', 'CONTENT_LENGTH'):\n            if key in self.environ: safe_env[key] = self.environ[key]\n        args = dict(fp=self.body, environ=safe_env, keep_blank_values=True)\n        if py31:\n            args['fp'] = NCTextIOWrapper(args['fp'], encoding='utf8',\n                                         newline='\\n')\n        elif py3k:\n            args['encoding'] = 'utf8'\n        data = cgi.FieldStorage(**args)\n        self['_cgi.FieldStorage'] = data #http://bugs.python.org/issue18394#msg207958\n        data = data.list or []\n        for item in data:\n            if item.filename is None:\n                post[item.name] = item.value\n            else:\n                post[item.name] = FileUpload(item.file, item.name,\n                                             item.filename, item.headers)\n        return post\n\n    @property\n    def url(self):\n        \"\"\" The full request URI including hostname and scheme. If your app\n            lives behind a reverse proxy or load balancer and you get confusing\n            results, make sure that the ``X-Forwarded-Host`` header is set\n            correctly. \"\"\"\n        return self.urlparts.geturl()\n\n    @DictProperty('environ', 'bottle.request.urlparts', read_only=True)\n    def urlparts(self):\n        ''' The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.\n            The tuple contains (scheme, host, path, query_string and fragment),\n            but the fragment is always empty because it is not visible to the\n            server. '''\n        env = self.environ\n        http = env.get('HTTP_X_FORWARDED_PROTO') or env.get('wsgi.url_scheme', 'http')\n        host = env.get('HTTP_X_FORWARDED_HOST') or env.get('HTTP_HOST')\n        if not host:\n            # HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.\n            host = env.get('SERVER_NAME', '127.0.0.1')\n            port = env.get('SERVER_PORT')\n            if port and port != ('80' if http == 'http' else '443'):\n                host += ':' + port\n        path = urlquote(self.fullpath)\n        return UrlSplitResult(http, host, path, env.get('QUERY_STRING'), '')\n\n    @property\n    def fullpath(self):\n        \"\"\" Request path including :attr:`script_name` (if present). \"\"\"\n        return urljoin(self.script_name, self.path.lstrip('/'))\n\n    @property\n    def query_string(self):\n        \"\"\" The raw :attr:`query` part of the URL (everything in between ``?``\n            and ``#``) as a string. \"\"\"\n        return self.environ.get('QUERY_STRING', '')\n\n    @property\n    def script_name(self):\n        ''' The initial portion of the URL's `path` that was removed by a higher\n            level (server or routing middleware) before the application was\n            called. This script path is returned with leading and tailing\n            slashes. '''\n        script_name = self.environ.get('SCRIPT_NAME', '').strip('/')\n        return '/' + script_name + '/' if script_name else '/'\n\n    def path_shift(self, shift=1):\n        ''' Shift path segments from :attr:`path` to :attr:`script_name` and\n            vice versa.\n\n           :param shift: The number of path segments to shift. May be negative\n                         to change the shift direction. (default: 1)\n        '''\n        script = self.environ.get('SCRIPT_NAME','/')\n        self['SCRIPT_NAME'], self['PATH_INFO'] = path_shift(script, self.path, shift)\n\n    @property\n    def content_length(self):\n        ''' The request body length as an integer. The client is responsible to\n            set this header. Otherwise, the real length of the body is unknown\n            and -1 is returned. In this case, :attr:`body` will be empty. '''\n        return int(self.environ.get('CONTENT_LENGTH') or -1)\n\n    @property\n    def content_type(self):\n        ''' The Content-Type header as a lowercase-string (default: empty). '''\n        return self.environ.get('CONTENT_TYPE', '').lower()\n\n    @property\n    def is_xhr(self):\n        ''' True if the request was triggered by a XMLHttpRequest. This only\n            works with JavaScript libraries that support the `X-Requested-With`\n            header (most of the popular libraries do). '''\n        requested_with = self.environ.get('HTTP_X_REQUESTED_WITH','')\n        return requested_with.lower() == 'xmlhttprequest'\n\n    @property\n    def is_ajax(self):\n        ''' Alias for :attr:`is_xhr`. \"Ajax\" is not the right term. '''\n        return self.is_xhr\n\n    @property\n    def auth(self):\n        \"\"\" HTTP authentication data as a (user, password) tuple. This\n            implementation currently supports basic (not digest) authentication\n            only. If the authentication happened at a higher level (e.g. in the\n            front web-server or a middleware), the password field is None, but\n            the user field is looked up from the ``REMOTE_USER`` environ\n            variable. On any errors, None is returned. \"\"\"\n        basic = parse_auth(self.environ.get('HTTP_AUTHORIZATION',''))\n        if basic: return basic\n        ruser = self.environ.get('REMOTE_USER')\n        if ruser: return (ruser, None)\n        return None\n\n    @property\n    def remote_route(self):\n        \"\"\" A list of all IPs that were involved in this request, starting with\n            the client IP and followed by zero or more proxies. This does only\n            work if all proxies support the ```X-Forwarded-For`` header. Note\n            that this information can be forged by malicious clients. \"\"\"\n        proxy = self.environ.get('HTTP_X_FORWARDED_FOR')\n        if proxy: return [ip.strip() for ip in proxy.split(',')]\n        remote = self.environ.get('REMOTE_ADDR')\n        return [remote] if remote else []\n\n    @property\n    def remote_addr(self):\n        \"\"\" The client IP as a string. Note that this information can be forged\n            by malicious clients. \"\"\"\n        route = self.remote_route\n        return route[0] if route else None\n\n    def copy(self):\n        \"\"\" Return a new :class:`Request` with a shallow :attr:`environ` copy. \"\"\"\n        return Request(self.environ.copy())\n\n    def get(self, value, default=None): return self.environ.get(value, default)\n    def __getitem__(self, key): return self.environ[key]\n    def __delitem__(self, key): self[key] = \"\"; del(self.environ[key])\n    def __iter__(self): return iter(self.environ)\n    def __len__(self): return len(self.environ)\n    def keys(self): return self.environ.keys()\n    def __setitem__(self, key, value):\n        \"\"\" Change an environ value and clear all caches that depend on it. \"\"\"\n\n        if self.environ.get('bottle.request.readonly'):\n            raise KeyError('The environ dictionary is read-only.')\n\n        self.environ[key] = value\n        todelete = ()\n\n        if key == 'wsgi.input':\n            todelete = ('body', 'forms', 'files', 'params', 'post', 'json')\n        elif key == 'QUERY_STRING':\n            todelete = ('query', 'params')\n        elif key.startswith('HTTP_'):\n            todelete = ('headers', 'cookies')\n\n        for key in todelete:\n            self.environ.pop('bottle.request.'+key, None)\n\n    def __repr__(self):\n        return '<%s: %s %s>' % (self.__class__.__name__, self.method, self.url)\n\n    def __getattr__(self, name):\n        ''' Search in self.environ for additional user defined attributes. '''\n        try:\n            var = self.environ['bottle.request.ext.%s'%name]\n            return var.__get__(self) if hasattr(var, '__get__') else var\n        except KeyError:\n            raise AttributeError('Attribute %r not defined.' % name)\n\n    def __setattr__(self, name, value):\n        if name == 'environ': return object.__setattr__(self, name, value)\n        self.environ['bottle.request.ext.%s'%name] = value\n\n\ndef _hkey(key):\n    if '\\n' in key or '\\r' in key or '\\0' in key:\n        raise ValueError(\"Header names must not contain control characters: %r\" % key)\n    return key.title().replace('_', '-')\n\n\ndef _hval(value):\n    value = tonat(value)\n    if '\\n' in value or '\\r' in value or '\\0' in value:\n        raise ValueError(\"Header value must not contain control characters: %r\" % value)\n    return value\n\n\n\nclass HeaderProperty(object):\n    def __init__(self, name, reader=None, writer=None, default=''):\n        self.name, self.default = name, default\n        self.reader, self.writer = reader, writer\n        self.__doc__ = 'Current value of the %r header.' % name.title()\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.get_header(self.name, self.default)\n        return self.reader(value) if self.reader else value\n\n    def __set__(self, obj, value):\n        obj[self.name] = self.writer(value) if self.writer else value\n\n    def __delete__(self, obj):\n        del obj[self.name]\n\n\nclass BaseResponse(object):\n    \"\"\" Storage class for a response body as well as headers and cookies.\n\n        This class does support dict-like case-insensitive item-access to\n        headers, but is NOT a dict. Most notably, iterating over a response\n        yields parts of the body and not the headers.\n\n        :param body: The response body as one of the supported types.\n        :param status: Either an HTTP status code (e.g. 200) or a status line\n                       including the reason phrase (e.g. '200 OK').\n        :param headers: A dictionary or a list of name-value pairs.\n\n        Additional keyword arguments are added to the list of headers.\n        Underscores in the header name are replaced with dashes.\n    \"\"\"\n\n    default_status = 200\n    default_content_type = 'text/html; charset=UTF-8'\n\n    # Header blacklist for specific response codes\n    # (rfc2616 section 10.2.3 and 10.3.5)\n    bad_headers = {\n        204: set(('Content-Type',)),\n        304: set(('Allow', 'Content-Encoding', 'Content-Language',\n                  'Content-Length', 'Content-Range', 'Content-Type',\n                  'Content-Md5', 'Last-Modified'))}\n\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        self._cookies = None\n        self._headers = {}\n        self.body = body\n        self.status = status or self.default_status\n        if headers:\n            if isinstance(headers, dict):\n                headers = headers.items()\n            for name, value in headers:\n                self.add_header(name, value)\n        if more_headers:\n            for name, value in more_headers.items():\n                self.add_header(name, value)\n\n    def copy(self, cls=None):\n        ''' Returns a copy of self. '''\n        cls = cls or BaseResponse\n        assert issubclass(cls, BaseResponse)\n        copy = cls()\n        copy.status = self.status\n        copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())\n        if self._cookies:\n            copy._cookies = SimpleCookie()\n            copy._cookies.load(self._cookies.output(header=''))\n        return copy\n\n    def __iter__(self):\n        return iter(self.body)\n\n    def close(self):\n        if hasattr(self.body, 'close'):\n            self.body.close()\n\n    @property\n    def status_line(self):\n        ''' The HTTP status line as a string (e.g. ``404 Not Found``).'''\n        return self._status_line\n\n    @property\n    def status_code(self):\n        ''' The HTTP status code as an integer (e.g. 404).'''\n        return self._status_code\n\n    def _set_status(self, status):\n        if isinstance(status, int):\n            code, status = status, _HTTP_STATUS_LINES.get(status)\n        elif ' ' in status:\n            status = status.strip()\n            code   = int(status.split()[0])\n        else:\n            raise ValueError('String status line without a reason phrase.')\n        if not 100 <= code <= 999: raise ValueError('Status code out of range.')\n        self._status_code = code\n        self._status_line = str(status or ('%d Unknown' % code))\n\n    def _get_status(self):\n        return self._status_line\n\n    status = property(_get_status, _set_status, None,\n        ''' A writeable property to change the HTTP response status. It accepts\n            either a numeric code (100-999) or a string with a custom reason\n            phrase (e.g. \"404 Brain not found\"). Both :data:`status_line` and\n            :data:`status_code` are updated accordingly. The return value is\n            always a status string. ''')\n    del _get_status, _set_status\n\n    @property\n    def headers(self):\n        ''' An instance of :class:`HeaderDict`, a case-insensitive dict-like\n            view on the response headers. '''\n        hdict = HeaderDict()\n        hdict.dict = self._headers\n        return hdict\n\n    def __contains__(self, name): return _hkey(name) in self._headers\n    def __delitem__(self, name):  del self._headers[_hkey(name)]\n    def __getitem__(self, name):  return self._headers[_hkey(name)][-1]\n    def __setitem__(self, name, value): self._headers[_hkey(name)] = [_hval(value)]\n\n    def get_header(self, name, default=None):\n        ''' Return the value of a previously defined header. If there is no\n            header with that name, return a default value. '''\n        return self._headers.get(_hkey(name), [default])[-1]\n\n    def set_header(self, name, value):\n        ''' Create a new response header, replacing any previously defined\n            headers with the same name. '''\n        self._headers[_hkey(name)] = [_hval(value)]\n\n    def add_header(self, name, value):\n        ''' Add an additional response header, not removing duplicates. '''\n        self._headers.setdefault(_hkey(name), []).append(_hval(value))\n\n    def iter_headers(self):\n        ''' Yield (header, value) tuples, skipping headers that are not\n            allowed with the current response status code. '''\n        return self.headerlist\n\n    @property\n    def headerlist(self):\n        \"\"\" WSGI conform list of (header, value) tuples. \"\"\"\n        out = []\n        headers = list(self._headers.items())\n        if 'Content-Type' not in self._headers:\n            headers.append(('Content-Type', [self.default_content_type]))\n        if self._status_code in self.bad_headers:\n            bad_headers = self.bad_headers[self._status_code]\n            headers = [h for h in headers if h[0] not in bad_headers]\n        out += [(name, val) for (name, vals) in headers for val in vals]\n        if self._cookies:\n            for c in self._cookies.values():\n                out.append(('Set-Cookie', _hval(c.OutputString())))\n        if py3k:\n            out = [(k, v.encode('utf8').decode('latin1')) for (k, v) in out]\n        return out\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int)\n    expires = HeaderProperty('Expires',\n        reader=lambda x: datetime.utcfromtimestamp(parse_date(x)),\n        writer=lambda x: http_date(x))\n\n    @property\n    def charset(self, default='UTF-8'):\n        \"\"\" Return the charset specified in the content-type header (default: utf8). \"\"\"\n        if 'charset=' in self.content_type:\n            return self.content_type.split('charset=')[-1].split(';')[0].strip()\n        return default\n\n    def set_cookie(self, name, value, secret=None, **options):\n        ''' Create a new cookie or replace an old one. If the `secret` parameter is\n            set, create a `Signed Cookie` (described below).\n\n            :param name: the name of the cookie.\n            :param value: the value of the cookie.\n            :param secret: a signature key required for signed cookies.\n\n            Additionally, this method accepts all RFC 2109 attributes that are\n            supported by :class:`cookie.Morsel`, including:\n\n            :param max_age: maximum age in seconds. (default: None)\n            :param expires: a datetime object or UNIX timestamp. (default: None)\n            :param domain: the domain that is allowed to read the cookie.\n              (default: current domain)\n            :param path: limits the cookie to a given path (default: current path)\n            :param secure: limit the cookie to HTTPS connections (default: off).\n            :param httponly: prevents client-side javascript to read this cookie\n              (default: off, requires Python 2.6 or newer).\n\n            If neither `expires` nor `max_age` is set (default), the cookie will\n            expire at the end of the browser session (as soon as the browser\n            window is closed).\n\n            Signed cookies may store any pickle-able object and are\n            cryptographically signed to prevent manipulation. Keep in mind that\n            cookies are limited to 4kb in most browsers.\n\n            Warning: Signed cookies are not encrypted (the client can still see\n            the content) and not copy-protected (the client can restore an old\n            cookie). The main intention is to make pickling and unpickling\n            save, not to store secret information at client side.\n        '''\n        if not self._cookies:\n            self._cookies = SimpleCookie()\n\n        if secret:\n            value = touni(cookie_encode((name, value), secret))\n        elif not isinstance(value, basestring):\n            raise TypeError('Secret key missing for non-string Cookie.')\n\n        if len(value) > 4096: raise ValueError('Cookie value to long.')\n        self._cookies[name] = value\n\n        for key, value in options.items():\n            if key == 'max_age':\n                if isinstance(value, timedelta):\n                    value = value.seconds + value.days * 24 * 3600\n            if key == 'expires':\n                if isinstance(value, (datedate, datetime)):\n                    value = value.timetuple()\n                elif isinstance(value, (int, float)):\n                    value = time.gmtime(value)\n                value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n            self._cookies[name][key.replace('_', '-')] = value\n\n    def delete_cookie(self, key, **kwargs):\n        ''' Delete a cookie. Be sure to use the same `domain` and `path`\n            settings as used to create the cookie. '''\n        kwargs['max_age'] = -1\n        kwargs['expires'] = 0\n        self.set_cookie(key, '', **kwargs)\n\n    def __repr__(self):\n        out = ''\n        for name, value in self.headerlist:\n            out += '%s: %s\\n' % (name.title(), value.strip())\n        return out\n\n\ndef local_property(name=None):\n    if name: depr('local_property() is deprecated and will be removed.') #0.12\n    ls = threading.local()\n    def fget(self):\n        try: return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n    def fset(self, value): ls.var = value\n    def fdel(self): del ls.var\n    return property(fget, fset, fdel, 'Thread-local property')\n\n\nclass LocalRequest(BaseRequest):\n    ''' A thread-local subclass of :class:`BaseRequest` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`request`). If accessed during a\n        request/response cycle, this instance always refers to the *current*\n        request (even on a multithreaded server). '''\n    bind = BaseRequest.__init__\n    environ = local_property()\n\n\nclass LocalResponse(BaseResponse):\n    ''' A thread-local subclass of :class:`BaseResponse` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`response`). Its attributes are used\n        to build the HTTP response at the end of the request/response cycle.\n    '''\n    bind = BaseResponse.__init__\n    _status_line = local_property()\n    _status_code = local_property()\n    _cookies     = local_property()\n    _headers     = local_property()\n    body         = local_property()\n\n\nRequest = BaseRequest\nResponse = BaseResponse\n\n\nclass HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n\n    def apply(self, response):\n        response._status_code = self._status_code\n        response._status_line = self._status_line\n        response._headers = self._headers\n        response._cookies = self._cookies\n        response.body = self.body\n\n\nclass HTTPError(HTTPResponse):\n    default_status = 500\n    def __init__(self, status=None, body=None, exception=None, traceback=None,\n                 **options):\n        self.exception = exception\n        self.traceback = traceback\n        super(HTTPError, self).__init__(body, status, **options)\n\n\n\n\n\n###############################################################################\n# Plugins ######################################################################\n###############################################################################\n\nclass PluginError(BottleException): pass\n\n\nclass JSONPlugin(object):\n    name = 'json'\n    api  = 2\n\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not dumps: return callback\n        def wrapper(*a, **ka):\n            try:\n                rv = callback(*a, **ka)\n            except HTTPError:\n                rv = _e()\n\n            if isinstance(rv, dict):\n                #Attempt to serialize, raises exception on failure\n                json_response = dumps(rv)\n                #Set content type only if serialization succesful\n                response.content_type = 'application/json'\n                return json_response\n            elif isinstance(rv, HTTPResponse) and isinstance(rv.body, dict):\n                rv.body = dumps(rv.body)\n                rv.content_type = 'application/json'\n            return rv\n\n        return wrapper\n\n\nclass TemplatePlugin(object):\n    ''' This plugin applies the :func:`view` decorator to all routes with a\n        `template` config parameter. If the parameter is a tuple, the second\n        element must be a dict with additional options (e.g. `template_engine`)\n        or default variables for the template. '''\n    name = 'template'\n    api  = 2\n\n    def apply(self, callback, route):\n        conf = route.config.get('template')\n        if isinstance(conf, (tuple, list)) and len(conf) == 2:\n            return view(conf[0], **conf[1])(callback)\n        elif isinstance(conf, str):\n            return view(conf)(callback)\n        else:\n            return callback\n\n\n#: Not a plugin, but part of the plugin API. TODO: Find a better place.\nclass _ImportRedirect(object):\n    def __init__(self, name, impmask):\n        ''' Create a virtual package that redirects imports (see PEP 302). '''\n        self.name = name\n        self.impmask = impmask\n        self.module = sys.modules.setdefault(name, new_module(name))\n        self.module.__dict__.update({'__file__': __file__, '__path__': [],\n                                    '__all__': [], '__loader__': self})\n        sys.meta_path.append(self)\n\n    def find_module(self, fullname, path=None):\n        if '.' not in fullname: return\n        packname = fullname.rsplit('.', 1)[0]\n        if packname != self.name: return\n        return self\n\n    def load_module(self, fullname):\n        if fullname in sys.modules: return sys.modules[fullname]\n        modname = fullname.rsplit('.', 1)[1]\n        realname = self.impmask % modname\n        __import__(realname)\n        module = sys.modules[fullname] = sys.modules[realname]\n        setattr(self.module, modname, module)\n        module.__loader__ = self\n        return module\n\n\n\n\n\n\n###############################################################################\n# Common Utilities #############################################################\n###############################################################################\n\n\nclass MultiDict(DictMixin):\n    \"\"\" This dict stores multiple values per key, but behaves exactly like a\n        normal dict in that it returns only the newest value for any given key.\n        There are special methods available to access the full list of values.\n    \"\"\"\n\n    def __init__(self, *a, **k):\n        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n\n    def __len__(self): return len(self.dict)\n    def __iter__(self): return iter(self.dict)\n    def __contains__(self, key): return key in self.dict\n    def __delitem__(self, key): del self.dict[key]\n    def __getitem__(self, key): return self.dict[key][-1]\n    def __setitem__(self, key, value): self.append(key, value)\n    def keys(self): return self.dict.keys()\n\n    if py3k:\n        def values(self): return (v[-1] for v in self.dict.values())\n        def items(self): return ((k, v[-1]) for k, v in self.dict.items())\n        def allitems(self):\n            return ((k, v) for k, vl in self.dict.items() for v in vl)\n        iterkeys = keys\n        itervalues = values\n        iteritems = items\n        iterallitems = allitems\n\n    else:\n        def values(self): return [v[-1] for v in self.dict.values()]\n        def items(self): return [(k, v[-1]) for k, v in self.dict.items()]\n        def iterkeys(self): return self.dict.iterkeys()\n        def itervalues(self): return (v[-1] for v in self.dict.itervalues())\n        def iteritems(self):\n            return ((k, v[-1]) for k, v in self.dict.iteritems())\n        def iterallitems(self):\n            return ((k, v) for k, vl in self.dict.iteritems() for v in vl)\n        def allitems(self):\n            return [(k, v) for k, vl in self.dict.iteritems() for v in vl]\n\n    def get(self, key, default=None, index=-1, type=None):\n        ''' Return the most recent value for a key.\n\n            :param default: The default value to be returned if the key is not\n                   present or the type conversion fails.\n            :param index: An index for the list of available values.\n            :param type: If defined, this callable is used to cast the value\n                    into a specific type. Exception are suppressed and result in\n                    the default value to be returned.\n        '''\n        try:\n            val = self.dict[key][index]\n            return type(val) if type else val\n        except Exception:\n            pass\n        return default\n\n    def append(self, key, value):\n        ''' Add a new value to the list of values for this key. '''\n        self.dict.setdefault(key, []).append(value)\n\n    def replace(self, key, value):\n        ''' Replace the list of values with a single value. '''\n        self.dict[key] = [value]\n\n    def getall(self, key):\n        ''' Return a (possibly empty) list of values for a key. '''\n        return self.dict.get(key) or []\n\n    #: Aliases for WTForms to mimic other multi-dict APIs (Django)\n    getone = get\n    getlist = getall\n\n\nclass FormsDict(MultiDict):\n    ''' This :class:`MultiDict` subclass is used to store request form data.\n        Additionally to the normal dict-like item access methods (which return\n        unmodified data as native strings), this container also supports\n        attribute-like access to its values. Attributes are automatically de-\n        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing\n        attributes default to an empty string. '''\n\n    #: Encoding used for attribute values.\n    input_encoding = 'utf8'\n    #: If true (default), unicode strings are first encoded with `latin1`\n    #: and then decoded to match :attr:`input_encoding`.\n    recode_unicode = True\n\n    def _fix(self, s, encoding=None):\n        if isinstance(s, unicode) and self.recode_unicode: # Python 3 WSGI\n            return s.encode('latin1').decode(encoding or self.input_encoding)\n        elif isinstance(s, bytes): # Python 2 WSGI\n            return s.decode(encoding or self.input_encoding)\n        else:\n            return s\n\n    def decode(self, encoding=None):\n        ''' Returns a copy with all keys and values de- or recoded to match\n            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a\n            unicode dictionary. '''\n        copy = FormsDict()\n        enc = copy.input_encoding = encoding or self.input_encoding\n        copy.recode_unicode = False\n        for key, value in self.allitems():\n            copy.append(self._fix(key, enc), self._fix(value, enc))\n        return copy\n\n    def getunicode(self, name, default=None, encoding=None):\n        ''' Return the value as a unicode string, or the default. '''\n        try:\n            return self._fix(self[name], encoding)\n        except (UnicodeError, KeyError):\n            return default\n\n    def __getattr__(self, name, default=unicode()):\n        # Without this guard, pickle generates a cryptic TypeError:\n        if name.startswith('__') and name.endswith('__'):\n            return super(FormsDict, self).__getattr__(name)\n        return self.getunicode(name, default=default)\n\nclass HeaderDict(MultiDict):\n    \"\"\" A case-insensitive version of :class:`MultiDict` that defaults to\n        replace the old value instead of appending it. \"\"\"\n\n    def __init__(self, *a, **ka):\n        self.dict = {}\n        if a or ka: self.update(*a, **ka)\n\n    def __contains__(self, key): return _hkey(key) in self.dict\n    def __delitem__(self, key): del self.dict[_hkey(key)]\n    def __getitem__(self, key): return self.dict[_hkey(key)][-1]\n    def __setitem__(self, key, value): self.dict[_hkey(key)] = [_hval(value)]\n    def append(self, key, value): self.dict.setdefault(_hkey(key), []).append(_hval(value))\n    def replace(self, key, value): self.dict[_hkey(key)] = [_hval(value)]\n    def getall(self, key): return self.dict.get(_hkey(key)) or []\n    def get(self, key, default=None, index=-1):\n        return MultiDict.get(self, _hkey(key), default, index)\n    def filter(self, names):\n        for name in (_hkey(n) for n in names):\n            if name in self.dict:\n                del self.dict[name]\n\n\nclass WSGIHeaderDict(DictMixin):\n    ''' This dict-like class wraps a WSGI environ dict and provides convenient\n        access to HTTP_* fields. Keys and values are native strings\n        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI\n        environment contains non-native string values, these are de- or encoded\n        using a lossless 'latin1' character set.\n\n        The API will remain stable even on changes to the relevant PEPs.\n        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one\n        that uses non-native strings.)\n    '''\n    #: List of keys that do not have a ``HTTP_`` prefix.\n    cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')\n\n    def __init__(self, environ):\n        self.environ = environ\n\n    def _ekey(self, key):\n        ''' Translate header field name to CGI/WSGI environ key. '''\n        key = key.replace('-','_').upper()\n        if key in self.cgikeys:\n            return key\n        return 'HTTP_' + key\n\n    def raw(self, key, default=None):\n        ''' Return the header value as is (may be bytes or unicode). '''\n        return self.environ.get(self._ekey(key), default)\n\n    def __getitem__(self, key):\n        return tonat(self.environ[self._ekey(key)], 'latin1')\n\n    def __setitem__(self, key, value):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __delitem__(self, key):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __iter__(self):\n        for key in self.environ:\n            if key[:5] == 'HTTP_':\n                yield key[5:].replace('_', '-').title()\n            elif key in self.cgikeys:\n                yield key.replace('_', '-').title()\n\n    def keys(self): return [x for x in self]\n    def __len__(self): return len(self.keys())\n    def __contains__(self, key): return self._ekey(key) in self.environ\n\n\n\nclass ConfigDict(dict):\n    ''' A dict-like configuration storage with additional support for\n        namespaces, validators, meta-data, on_change listeners and more.\n\n        This storage is optimized for fast read access. Retrieving a key\n        or using non-altering dict methods (e.g. `dict.get()`) has no overhead\n        compared to a native dict.\n    '''\n    __slots__ = ('_meta', '_on_change')\n\n    class Namespace(DictMixin):\n\n        def __init__(self, config, namespace):\n            self._config = config\n            self._prefix = namespace\n\n        def __getitem__(self, key):\n            depr('Accessing namespaces as dicts is discouraged. '\n                 'Only use flat item access: '\n                 'cfg[\"names\"][\"pace\"][\"key\"] -> cfg[\"name.space.key\"]') #0.12\n            return self._config[self._prefix + '.' + key]\n\n        def __setitem__(self, key, value):\n            self._config[self._prefix + '.' + key] = value\n\n        def __delitem__(self, key):\n            del self._config[self._prefix + '.' + key]\n\n        def __iter__(self):\n            ns_prefix = self._prefix + '.'\n            for key in self._config:\n                ns, dot, name = key.rpartition('.')\n                if ns == self._prefix and name:\n                    yield name\n\n        def keys(self): return [x for x in self]\n        def __len__(self): return len(self.keys())\n        def __contains__(self, key): return self._prefix + '.' + key in self._config\n        def __repr__(self): return '<Config.Namespace %s.*>' % self._prefix\n        def __str__(self): return '<Config.Namespace %s.*>' % self._prefix\n\n        # Deprecated ConfigDict features\n        def __getattr__(self, key):\n            depr('Attribute access is deprecated.') #0.12\n            if key not in self and key[0].isupper():\n                self[key] = ConfigDict.Namespace(self._config, self._prefix + '.' + key)\n            if key not in self and key.startswith('__'):\n                raise AttributeError(key)\n            return self.get(key)\n\n        def __setattr__(self, key, value):\n            if key in ('_config', '_prefix'):\n                self.__dict__[key] = value\n                return\n            depr('Attribute assignment is deprecated.') #0.12\n            if hasattr(DictMixin, key):\n                raise AttributeError('Read-only attribute.')\n            if key in self and self[key] and isinstance(self[key], self.__class__):\n                raise AttributeError('Non-empty namespace attribute.')\n            self[key] = value\n\n        def __delattr__(self, key):\n            if key in self:\n                val = self.pop(key)\n                if isinstance(val, self.__class__):\n                    prefix = key + '.'\n                    for key in self:\n                        if key.startswith(prefix):\n                            del self[prefix+key]\n\n        def __call__(self, *a, **ka):\n            depr('Calling ConfDict is deprecated. Use the update() method.') #0.12\n            self.update(*a, **ka)\n            return self\n\n    def __init__(self, *a, **ka):\n        self._meta = {}\n        self._on_change = lambda name, value: None\n        if a or ka:\n            depr('Constructor does no longer accept parameters.') #0.12\n            self.update(*a, **ka)\n\n    def load_config(self, filename):\n        ''' Load values from an *.ini style config file.\n\n            If the config file contains sections, their names are used as\n            namespaces for the values within. The two special sections\n            ``DEFAULT`` and ``bottle`` refer to the root namespace (no prefix).\n        '''\n        conf = ConfigParser()\n        conf.read(filename)\n        for section in conf.sections():\n            for key, value in conf.items(section):\n                if section not in ('DEFAULT', 'bottle'):\n                    key = section + '.' + key\n                self[key] = value\n        return self\n\n    def load_dict(self, source, namespace='', make_namespaces=False):\n        ''' Import values from a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> ConfigDict().load_dict({'name': {'space': {'key': 'value'}}})\n            {'name.space.key': 'value'}\n        '''\n        stack = [(namespace, source)]\n        while stack:\n            prefix, source = stack.pop()\n            if not isinstance(source, dict):\n                raise TypeError('Source is not a dict (r)' % type(key))\n            for key, value in source.items():\n                if not isinstance(key, basestring):\n                    raise TypeError('Key is not a string (%r)' % type(key))\n                full_key = prefix + '.' + key if prefix else key\n                if isinstance(value, dict):\n                    stack.append((full_key, value))\n                    if make_namespaces:\n                        self[full_key] = self.Namespace(self, full_key)\n                else:\n                    self[full_key] = value\n        return self\n\n    def update(self, *a, **ka):\n        ''' If the first parameter is a string, all keys are prefixed with this\n            namespace. Apart from that it works just as the usual dict.update().\n            Example: ``update('some.namespace', key='value')`` '''\n        prefix = ''\n        if a and isinstance(a[0], basestring):\n            prefix = a[0].strip('.') + '.'\n            a = a[1:]\n        for key, value in dict(*a, **ka).items():\n            self[prefix+key] = value\n\n    def setdefault(self, key, value):\n        if key not in self:\n            self[key] = value\n        return self[key]\n\n    def __setitem__(self, key, value):\n        if not isinstance(key, basestring):\n            raise TypeError('Key has type %r (not a string)' % type(key))\n\n        value = self.meta_get(key, 'filter', lambda x: x)(value)\n        if key in self and self[key] is value:\n            return\n        self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, key)\n\n    def clear(self):\n        for key in self:\n            del self[key]\n\n    def meta_get(self, key, metafield, default=None):\n        ''' Return the value of a meta field for a key. '''\n        return self._meta.get(key, {}).get(metafield, default)\n\n    def meta_set(self, key, metafield, value):\n        ''' Set the meta field for a key to a new value. This triggers the\n            on-change handler for existing keys. '''\n        self._meta.setdefault(key, {})[metafield] = value\n        if key in self:\n            self[key] = self[key]\n\n    def meta_list(self, key):\n        ''' Return an iterable of meta field names defined for a key. '''\n        return self._meta.get(key, {}).keys()\n\n    # Deprecated ConfigDict features\n    def __getattr__(self, key):\n        depr('Attribute access is deprecated.') #0.12\n        if key not in self and key[0].isupper():\n            self[key] = self.Namespace(self, key)\n        if key not in self and key.startswith('__'):\n            raise AttributeError(key)\n        return self.get(key)\n\n    def __setattr__(self, key, value):\n        if key in self.__slots__:\n            return dict.__setattr__(self, key, value)\n        depr('Attribute assignment is deprecated.') #0.12\n        if hasattr(dict, key):\n            raise AttributeError('Read-only attribute.')\n        if key in self and self[key] and isinstance(self[key], self.Namespace):\n            raise AttributeError('Non-empty namespace attribute.')\n        self[key] = value\n\n    def __delattr__(self, key):\n        if key in self:\n            val = self.pop(key)\n            if isinstance(val, self.Namespace):\n                prefix = key + '.'\n                for key in self:\n                    if key.startswith(prefix):\n                        del self[prefix+key]\n\n    def __call__(self, *a, **ka):\n        depr('Calling ConfDict is deprecated. Use the update() method.') #0.12\n        self.update(*a, **ka)\n        return self\n\n\n\nclass AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self[-1]\n\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)\n        return value\n\n\nclass WSGIFileWrapper(object):\n\n    def __init__(self, fp, buffer_size=1024*64):\n        self.fp, self.buffer_size = fp, buffer_size\n        for attr in ('fileno', 'close', 'read', 'readlines', 'tell', 'seek'):\n            if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))\n\n    def __iter__(self):\n        buff, read = self.buffer_size, self.read\n        while True:\n            part = read(buff)\n            if not part: return\n            yield part\n\n\nclass _closeiter(object):\n    ''' This only exists to be able to attach a .close method to iterators that\n        do not support attribute assignment (most of itertools). '''\n\n    def __init__(self, iterator, close=None):\n        self.iterator = iterator\n        self.close_callbacks = makelist(close)\n\n    def __iter__(self):\n        return iter(self.iterator)\n\n    def close(self):\n        for func in self.close_callbacks:\n            func()\n\n\nclass ResourceManager(object):\n    ''' This class manages a list of search paths and helps to find and open\n        application-bound resources (files).\n\n        :param base: default value for :meth:`add_path` calls.\n        :param opener: callable used to open resources.\n        :param cachemode: controls which lookups are cached. One of 'all',\n                         'found' or 'none'.\n    '''\n\n    def __init__(self, base='./', opener=open, cachemode='all'):\n        self.opener = open\n        self.base = base\n        self.cachemode = cachemode\n\n        #: A list of search paths. See :meth:`add_path` for details.\n        self.path = []\n        #: A cache for resolved paths. ``res.cache.clear()`` clears the cache.\n        self.cache = {}\n\n    def add_path(self, path, base=None, index=None, create=False):\n        ''' Add a new path to the list of search paths. Return False if the\n            path does not exist.\n\n            :param path: The new search path. Relative paths are turned into\n                an absolute and normalized form. If the path looks like a file\n                (not ending in `/`), the filename is stripped off.\n            :param base: Path used to absolutize relative search paths.\n                Defaults to :attr:`base` which defaults to ``os.getcwd()``.\n            :param index: Position within the list of search paths. Defaults\n                to last index (appends to the list).\n\n            The `base` parameter makes it easy to reference files installed\n            along with a python module or package::\n\n                res.add_path('./resources/', __file__)\n        '''\n        base = os.path.abspath(os.path.dirname(base or self.base))\n        path = os.path.abspath(os.path.join(base, os.path.dirname(path)))\n        path += os.sep\n        if path in self.path:\n            self.path.remove(path)\n        if create and not os.path.isdir(path):\n            os.makedirs(path)\n        if index is None:\n            self.path.append(path)\n        else:\n            self.path.insert(index, path)\n        self.cache.clear()\n        return os.path.exists(path)\n\n    def __iter__(self):\n        ''' Iterate over all existing files in all registered paths. '''\n        search = self.path[:]\n        while search:\n            path = search.pop()\n            if not os.path.isdir(path): continue\n            for name in os.listdir(path):\n                full = os.path.join(path, name)\n                if os.path.isdir(full): search.append(full)\n                else: yield full\n\n    def lookup(self, name):\n        ''' Search for a resource and return an absolute file path, or `None`.\n\n            The :attr:`path` list is searched in order. The first match is\n            returend. Symlinks are followed. The result is cached to speed up\n            future lookups. '''\n        if name not in self.cache or DEBUG:\n            for path in self.path:\n                fpath = os.path.join(path, name)\n                if os.path.isfile(fpath):\n                    if self.cachemode in ('all', 'found'):\n                        self.cache[name] = fpath\n                    return fpath\n            if self.cachemode == 'all':\n                self.cache[name] = None\n        return self.cache[name]\n\n    def open(self, name, mode='r', *args, **kwargs):\n        ''' Find a resource and return a file object, or raise IOError. '''\n        fname = self.lookup(name)\n        if not fname: raise IOError(\"Resource %r not found.\" % name)\n        return self.opener(fname, mode=mode, *args, **kwargs)\n\n\nclass FileUpload(object):\n\n    def __init__(self, fileobj, name, filename, headers=None):\n        ''' Wrapper for file uploads. '''\n        #: Open file(-like) object (BytesIO buffer or temporary file)\n        self.file = fileobj\n        #: Name of the upload form field\n        self.name = name\n        #: Raw filename as sent by the client (may contain unsafe characters)\n        self.raw_filename = filename\n        #: A :class:`HeaderDict` with additional headers (e.g. content-type)\n        self.headers = HeaderDict(headers) if headers else HeaderDict()\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a header within the mulripart part. \"\"\"\n        return self.headers.get(name, default)\n\n    @cached_property\n    def filename(self):\n        ''' Name of the file on the client file system, but normalized to ensure\n            file system compatibility. An empty filename is returned as 'empty'.\n\n            Only ASCII letters, digits, dashes, underscores and dots are\n            allowed in the final filename. Accents are removed, if possible.\n            Whitespace is replaced by a single dash. Leading or tailing dots\n            or dashes are removed. The filename is limited to 255 characters.\n        '''\n        fname = self.raw_filename\n        if not isinstance(fname, unicode):\n            fname = fname.decode('utf8', 'ignore')\n        fname = normalize('NFKD', fname).encode('ASCII', 'ignore').decode('ASCII')\n        fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n        fname = re.sub(r'[^a-zA-Z0-9-_.\\s]', '', fname).strip()\n        fname = re.sub(r'[-\\s]+', '-', fname).strip('.-')\n        return fname[:255] or 'empty'\n\n    def _copy_file(self, fp, chunk_size=2**16):\n        read, write, offset = self.file.read, fp.write, self.file.tell()\n        while 1:\n            buf = read(chunk_size)\n            if not buf: break\n            write(buf)\n        self.file.seek(offset)\n\n    def save(self, destination, overwrite=False, chunk_size=2**16):\n        ''' Save file to disk or copy its content to an open file(-like) object.\n            If *destination* is a directory, :attr:`filename` is added to the\n            path. Existing files are not overwritten by default (IOError).\n\n            :param destination: File path, directory or file(-like) object.\n            :param overwrite: If True, replace existing files. (default: False)\n            :param chunk_size: Bytes to read at a time. (default: 64kb)\n        '''\n        if isinstance(destination, basestring): # Except file-likes here\n            if os.path.isdir(destination):\n                destination = os.path.join(destination, self.filename)\n            if not overwrite and os.path.exists(destination):\n                raise IOError('File exists.')\n            with open(destination, 'wb') as fp:\n                self._copy_file(fp, chunk_size)\n        else:\n            self._copy_file(destination, chunk_size)\n\n\n\n\n\n\n###############################################################################\n# Application Helper ###########################################################\n###############################################################################\n\n\ndef abort(code=500, text='Unknown Error.'):\n    \"\"\" Aborts execution and causes a HTTP error. \"\"\"\n    raise HTTPError(code, text)\n\n\ndef redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code\n    res.body = \"\"\n    res.set_header('Location', urljoin(request.url, url))\n    raise res\n\n\ndef _file_iter_range(fp, offset, bytes, maxread=1024*1024):\n    ''' Yield chunks from a range in a file. No chunk is bigger than maxread.'''\n    fp.seek(offset)\n    while bytes > 0:\n        part = fp.read(min(bytes, maxread))\n        if not part: break\n        bytes -= len(part)\n        yield part\n\n\ndef static_file(filename, root, mimetype='auto', download=False, charset='UTF-8'):\n    \"\"\" Open a file in a safe way and return :exc:`HTTPResponse` with status\n        code 200, 305, 403 or 404. The ``Content-Type``, ``Content-Encoding``,\n        ``Content-Length`` and ``Last-Modified`` headers are set if possible.\n        Special support for ``If-Modified-Since``, ``Range`` and ``HEAD``\n        requests.\n\n        :param filename: Name or path of the file to send.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Defines the content-type header (default: guess from\n            file extension)\n        :param download: If True, ask the browser to open a `Save as...` dialog\n            instead of opening the file with the associated program. You can\n            specify a custom filename as a string. If not specified, the\n            original filename is used (default: False).\n        :param charset: The charset to use for files with a ``text/*``\n            mime-type. (default: UTF-8)\n    \"\"\"\n\n    root = os.path.abspath(root) + os.sep\n    filename = os.path.abspath(os.path.join(root, filename.strip('/\\\\')))\n    headers = dict()\n\n    if not filename.startswith(root):\n        return HTTPError(403, \"Access denied.\")\n    if not os.path.exists(filename) or not os.path.isfile(filename):\n        return HTTPError(404, \"File does not exist.\")\n    if not os.access(filename, os.R_OK):\n        return HTTPError(403, \"You do not have permission to access this file.\")\n\n    if mimetype == 'auto':\n        mimetype, encoding = mimetypes.guess_type(filename)\n        if encoding: headers['Content-Encoding'] = encoding\n\n    if mimetype:\n        if mimetype[:5] == 'text/' and charset and 'charset' not in mimetype:\n            mimetype += '; charset=%s' % charset\n        headers['Content-Type'] = mimetype\n\n    if download:\n        download = os.path.basename(filename if download == True else download)\n        headers['Content-Disposition'] = 'attachment; filename=\"%s\"' % download\n\n    stats = os.stat(filename)\n    headers['Content-Length'] = clen = stats.st_size\n    lm = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime(stats.st_mtime))\n    headers['Last-Modified'] = lm\n\n    ims = request.environ.get('HTTP_IF_MODIFIED_SINCE')\n    if ims:\n        ims = parse_date(ims.split(\";\")[0].strip())\n    if ims is not None and ims >= int(stats.st_mtime):\n        headers['Date'] = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime())\n        return HTTPResponse(status=304, **headers)\n\n    body = '' if request.method == 'HEAD' else open(filename, 'rb')\n\n    headers[\"Accept-Ranges\"] = \"bytes\"\n    ranges = request.environ.get('HTTP_RANGE')\n    if 'HTTP_RANGE' in request.environ:\n        ranges = list(parse_range_header(request.environ['HTTP_RANGE'], clen))\n        if not ranges:\n            return HTTPError(416, \"Requested Range Not Satisfiable\")\n        offset, end = ranges[0]\n        headers[\"Content-Range\"] = \"bytes %d-%d/%d\" % (offset, end-1, clen)\n        headers[\"Content-Length\"] = str(end-offset)\n        if body: body = _file_iter_range(body, offset, end-offset)\n        return HTTPResponse(body, status=206, **headers)\n    return HTTPResponse(body, **headers)\n\n\n\n\n\n\n###############################################################################\n# HTTP Utilities and MISC (TODO) ###############################################\n###############################################################################\n\n\ndef debug(mode=True):\n    \"\"\" Change the debug level.\n    There is only one debug level supported at the moment.\"\"\"\n    global DEBUG\n    if mode: warnings.simplefilter('default')\n    DEBUG = bool(mode)\n\ndef http_date(value):\n    if isinstance(value, (datedate, datetime)):\n        value = value.utctimetuple()\n    elif isinstance(value, (int, float)):\n        value = time.gmtime(value)\n    if not isinstance(value, basestring):\n        value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n    return value\n\ndef parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"\n    try:\n        ts = email.utils.parsedate_tz(ims)\n        return time.mktime(ts[:8] + (0,)) - (ts[9] or 0) - time.timezone\n    except (TypeError, ValueError, IndexError, OverflowError):\n        return None\n\ndef parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            user, pwd = touni(base64.b64decode(tob(data))).split(':',1)\n            return user, pwd\n    except (KeyError, ValueError):\n        return None\n\ndef parse_range_header(header, maxlen=0):\n    ''' Yield (start, end) ranges parsed from a HTTP Range header. Skip\n        unsatisfiable ranges. The end index is non-inclusive.'''\n    if not header or header[:6] != 'bytes=': return\n    ranges = [r.split('-', 1) for r in header[6:].split(',') if '-' in r]\n    for start, end in ranges:\n        try:\n            if not start:  # bytes=-100    -> last 100 bytes\n                start, end = max(0, maxlen-int(end)), maxlen\n            elif not end:  # bytes=100-    -> all but the first 99 bytes\n                start, end = int(start), maxlen\n            else:          # bytes=100-200 -> bytes 100-200 (inclusive)\n                start, end = int(start), min(int(end)+1, maxlen)\n            if 0 <= start < end <= maxlen:\n                yield start, end\n        except ValueError:\n            pass\n\ndef _parse_qsl(qs):\n    r = []\n    for pair in qs.split('&'):\n        if not pair: continue\n        nv = pair.split('=', 1)\n        if len(nv) != 2: nv.append('')\n        key = urlunquote(nv[0].replace('+', ' '))\n        value = urlunquote(nv[1].replace('+', ' '))\n        r.append((key, value))\n    return r\n\ndef _lscmp(a, b):\n    ''' Compares two strings in a cryptographically safe way:\n        Runtime is not affected by length of common prefix. '''\n    return not sum(0 if x==y else 1 for x, y in zip(a, b)) and len(a) == len(b)\n\n\ndef cookie_encode(data, key):\n    ''' Encode and sign a pickle-able object. Return a (byte) string '''\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())\n    return tob('!') + sig + tob('?') + msg\n\n\ndef cookie_decode(data, key):\n    ''' Verify and decode an encoded string. Return an object or None.'''\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())):\n            return pickle.loads(base64.b64decode(msg))\n    return None\n\n\ndef cookie_is_encoded(data):\n    ''' Return True if the argument looks like a encoded cookie.'''\n    return bool(data.startswith(tob('!')) and tob('?') in data)\n\n\ndef html_escape(string):\n    ''' Escape HTML special characters ``&<>`` and quotes ``'\"``. '''\n    return string.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')\\\n                 .replace('\"','&quot;').replace(\"'\",'&#039;')\n\n\ndef html_quote(string):\n    ''' Escape and quote a string to be used as an HTTP attribute.'''\n    return '\"%s\"' % html_escape(string).replace('\\n','&#10;')\\\n                    .replace('\\r','&#13;').replace('\\t','&#9;')\n\n\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'\n        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\n        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n    \"\"\"\n    path = '/' + func.__name__.replace('__','/').lstrip('/')\n    spec = getargspec(func)\n    argc = len(spec[0]) - len(spec[3] or [])\n    path += ('/<%s>' * argc) % tuple(spec[0][:argc])\n    yield path\n    for arg in spec[0][argc:]:\n        path += '/<%s>' % arg\n        yield path\n\n\ndef path_shift(script_name, path_info, shift=1):\n    ''' Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n\n        :return: The modified paths.\n        :param script_name: The SCRIPT_NAME path.\n        :param script_name: The PATH_INFO path.\n        :param shift: The number of path fragments to shift. May be negative to\n          change the shift direction. (default: 1)\n    '''\n    if shift == 0: return script_name, path_info\n    pathlist = path_info.strip('/').split('/')\n    scriptlist = script_name.strip('/').split('/')\n    if pathlist and pathlist[0] == '': pathlist = []\n    if scriptlist and scriptlist[0] == '': scriptlist = []\n    if shift > 0 and shift <= len(pathlist):\n        moved = pathlist[:shift]\n        scriptlist = scriptlist + moved\n        pathlist = pathlist[shift:]\n    elif shift < 0 and shift >= -len(scriptlist):\n        moved = scriptlist[shift:]\n        pathlist = moved + pathlist\n        scriptlist = scriptlist[:shift]\n    else:\n        empty = 'SCRIPT_NAME' if shift < 0 else 'PATH_INFO'\n        raise AssertionError(\"Cannot shift. Nothing left from %s\" % empty)\n    new_script_name = '/' + '/'.join(scriptlist)\n    new_path_info = '/' + '/'.join(pathlist)\n    if path_info.endswith('/') and pathlist: new_path_info += '/'\n    return new_script_name, new_path_info\n\n\ndef auth_basic(check, realm=\"private\", text=\"Access denied\"):\n    ''' Callback decorator to require HTTP auth (basic).\n        TODO: Add route(check_auth=...) parameter. '''\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*a, **ka):\n            user, password = request.auth or (None, None)\n            if user is None or not check(user, password):\n                err = HTTPError(401, text)\n                err.add_header('WWW-Authenticate', 'Basic realm=\"%s\"' % realm)\n                return err\n            return func(*a, **ka)\n        return wrapper\n    return decorator\n\n\n# Shortcuts for common Bottle methods.\n# They all refer to the current default application.\n\ndef make_default_app_wrapper(name):\n    ''' Return a callable that relays calls to the current default app. '''\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n    return wrapper\n\nroute     = make_default_app_wrapper('route')\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')\ndelete    = make_default_app_wrapper('delete')\nerror     = make_default_app_wrapper('error')\nmount     = make_default_app_wrapper('mount')\nhook      = make_default_app_wrapper('hook')\ninstall   = make_default_app_wrapper('install')\nuninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n\n\n\n\n\n\n\n###############################################################################\n# Server Adapter ###############################################################\n###############################################################################\n\n\nclass ServerAdapter(object):\n    quiet = False\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n\n    def run(self, handler): # pragma: no cover\n        pass\n\n    def __repr__(self):\n        args = ', '.join(['%s=%s'%(k,repr(v)) for k, v in self.options.items()])\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass CGIServer(ServerAdapter):\n    quiet = True\n    def run(self, handler): # pragma: no cover\n        from wsgiref.handlers import CGIHandler\n        def fixed_environ(environ, start_response):\n            environ.setdefault('PATH_INFO', '')\n            return handler(environ, start_response)\n        CGIHandler().run(fixed_environ)\n\n\nclass FlupFCGIServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        import flup.server.fcgi\n        self.options.setdefault('bindAddress', (self.host, self.port))\n        flup.server.fcgi.WSGIServer(handler, **self.options).run()\n\n\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app): # pragma: no cover\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        from wsgiref.simple_server import make_server\n        import socket\n\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self): # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n            def log_request(*args, **kw):\n                if not self.quiet:\n                    return WSGIRequestHandler.log_request(*args, **kw)\n\n        handler_cls = self.options.get('handler_class', FixedHandler)\n        server_cls  = self.options.get('server_class', WSGIServer)\n\n        if ':' in self.host: # Fix wsgiref for IPv6 addresses.\n            if getattr(server_cls, 'address_family') == socket.AF_INET:\n                class server_cls(server_cls):\n                    address_family = socket.AF_INET6\n\n        srv = make_server(self.host, self.port, app, server_cls, handler_cls)\n        srv.serve_forever()\n\n\nclass CherryPyServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        depr(0, 13, \"The wsgi server part of cherrypy was split into a new \"\n                    \"project called 'cheroot'.\", \"Use the 'cheroot' server \"\n                    \"adapter instead of cherrypy.\")\n        from cherrypy import wsgiserver # This will fail for CherryPy >= 9\n\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n\n        certfile = self.options.get('certfile')\n        if certfile:\n            del self.options['certfile']\n        keyfile = self.options.get('keyfile')\n        if keyfile:\n            del self.options['keyfile']\n\n        server = wsgiserver.CherryPyWSGIServer(**self.options)\n        if certfile:\n            server.ssl_certificate = certfile\n        if keyfile:\n            server.ssl_private_key = keyfile\n\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass CherootServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from cheroot import wsgi\n        from cheroot.ssl import builtin\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n        certfile = self.options.pop('certfile', None)\n        keyfile = self.options.pop('keyfile', None)\n        chainfile = self.options.pop('chainfile', None)\n        server = wsgi.Server(**self.options)\n        if certfile and keyfile:\n            server.ssl_adapter = builtin.BuiltinSSLAdapter(\n                    certfile, keyfile, chainfile)\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass WaitressServer(ServerAdapter):\n    def run(self, handler):\n        from waitress import serve\n        serve(handler, host=self.host, port=self.port)\n\n\nclass PasteServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler, host=self.host, port=str(self.port),\n                         **self.options)\n\n\nclass MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server\n        server.listen((self.host, self.port))\n        server.run(handler)\n\n\nclass FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See http://www.fapws.org/ \"\"\"\n    def run(self, handler): # pragma: no cover\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config\n        port = self.port\n        if float(config.SERVER_IDENT[-2:]) > 0.4:\n            # fapws3 silently changed its API in 0.5\n            port = str(port)\n        evwsgi.start(self.host, port)\n        # fapws3 never releases the GIL. Complain upstream. I tried. No luck.\n        if 'BOTTLE_CHILD' in os.environ and not self.quiet:\n            _stderr(\"WARNING: Auto-reloading does not work with Fapws3.\\n\")\n            _stderr(\"         (Fapws3 breaks python thread support)\\n\")\n        evwsgi.set_base_module(base)\n        def app(environ, start_response):\n            environ['wsgi.multiprocess'] = False\n            return handler(environ, start_response)\n        evwsgi.wsgi_cb(('', app))\n        evwsgi.run()\n\n\nclass TornadoServer(ServerAdapter):\n    \"\"\" The super hyped asynchronous server by facebook. Untested. \"\"\"\n    def run(self, handler): # pragma: no cover\n        import tornado.wsgi, tornado.httpserver, tornado.ioloop\n        container = tornado.wsgi.WSGIContainer(handler)\n        server = tornado.httpserver.HTTPServer(container)\n        server.listen(port=self.port,address=self.host)\n        tornado.ioloop.IOLoop.instance().start()\n\n\nclass AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"\n    quiet = True\n    def run(self, handler):\n        from google.appengine.ext.webapp import util\n        # A main() function in the handler script enables 'App Caching'.\n        # Lets makes sure it is there. This _really_ improves performance.\n        module = sys.modules.get('__main__')\n        if module and not hasattr(module, 'main'):\n            module.main = lambda: util.run_wsgi_app(handler)\n        util.run_wsgi_app(handler)\n\n\nclass TwistedServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from twisted.web import server, wsgi\n        from twisted.python.threadpool import ThreadPool\n        from twisted.internet import reactor\n        thread_pool = ThreadPool()\n        thread_pool.start()\n        reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)\n        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))\n        reactor.listenTCP(self.port, factory, interface=self.host)\n        reactor.run()\n\n\nclass DieselServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from diesel.protocols.wsgi import WSGIApplication\n        app = WSGIApplication(handler, port=self.port)\n        app.run()\n\n\nclass GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * `fast` (default: False) uses libevent's http server, but has some\n          issues: No streaming, no pipelining, no SSL.\n        * See gevent.wsgi.WSGIServer() documentation for more options.\n    \"\"\"\n    def run(self, handler):\n        from gevent import pywsgi, local\n        if not isinstance(threading.local(), local.local):\n            msg = \"Bottle requires gevent.monkey.patch_all() (before import)\"\n            raise RuntimeError(msg)\n        if self.options.pop('fast', None):\n            depr('The \"fast\" option has been deprecated and removed by Gevent.')\n        if self.quiet:\n            self.options['log'] = None\n        address = (self.host, self.port)\n        server = pywsgi.WSGIServer(address, handler, **self.options)\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: server.stop())\n        server.serve_forever()\n\n\nclass GeventSocketIOServer(ServerAdapter):\n    def run(self,handler):\n        from socketio import server\n        address = (self.host, self.port)\n        server.SocketIOServer(address, handler, **self.options).serve_forever()\n\n\nclass GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n    def run(self, handler):\n        from gunicorn.app.base import Application\n\n        config = {'bind': \"%s:%d\" % (self.host, int(self.port))}\n        config.update(self.options)\n\n        class GunicornApplication(Application):\n            def init(self, parser, opts, args):\n                return config\n\n            def load(self):\n                return handler\n\n        GunicornApplication().run()\n\n\nclass EventletServer(ServerAdapter):\n    \"\"\" Untested \"\"\"\n    def run(self, handler):\n        from eventlet import wsgi, listen\n        try:\n            wsgi.server(listen((self.host, self.port)), handler,\n                        log_output=(not self.quiet))\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            wsgi.server(listen((self.host, self.port)), handler)\n\n\nclass RocketServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from rocket import Rocket\n        server = Rocket((self.host, self.port), 'wsgi', { 'wsgi_app' : handler })\n        server.start()\n\n\nclass BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n    def run(self, handler):\n        from bjoern import run\n        run(handler, self.host, self.port)\n\n\nclass AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                CherootServer, WSGIRefServer]\n\n    def run(self, handler):\n        for sa in self.adapters:\n            try:\n                return sa(self.host, self.port, **self.options).run(handler)\n            except ImportError:\n                pass\n\nserver_names = {\n    'cgi': CGIServer,\n    'flup': FlupFCGIServer,\n    'wsgiref': WSGIRefServer,\n    'waitress': WaitressServer,\n    'cherrypy': CherryPyServer,\n    'cheroot': CherootServer,\n    'paste': PasteServer,\n    'fapws3': FapwsServer,\n    'tornado': TornadoServer,\n    'gae': AppEngineServer,\n    'twisted': TwistedServer,\n    'diesel': DieselServer,\n    'meinheld': MeinheldServer,\n    'gunicorn': GunicornServer,\n    'eventlet': EventletServer,\n    'gevent': GeventServer,\n    'geventSocketIO':GeventSocketIOServer,\n    'rocket': RocketServer,\n    'bjoern' : BjoernServer,\n    'auto': AutoServer,\n}\n\n\n\n\n\n\n###############################################################################\n# Application Control ##########################################################\n###############################################################################\n\n\ndef load(target, **namespace):\n    \"\"\" Import a module or fetch an object from a module.\n\n        * ``package.module`` returns `module` as a module object.\n        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.\n        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.\n\n        The last form accepts not only function calls, but any type of\n        expression. Keyword arguments passed to this function are available as\n        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``\n    \"\"\"\n    module, target = target.split(\":\", 1) if ':' in target else (target, None)\n    if module not in sys.modules: __import__(module)\n    if not target: return sys.modules[module]\n    if target.isalnum(): return getattr(sys.modules[module], target)\n    package_name = module.split('.')[0]\n    namespace[package_name] = sys.modules[package_name]\n    return eval('%s.%s' % (module, target), namespace)\n\n\ndef load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN; NORUN, nr_old = True, NORUN\n    try:\n        tmp = default_app.push() # Create a new \"default application\"\n        rv = load(target) # Import the target module\n        return rv if callable(rv) else tmp\n    finally:\n        default_app.remove(tmp) # Remove the temporary added default application\n        NORUN = nr_old\n\n_debug = debug\ndef run(app=None, server='wsgiref', host='127.0.0.1', port=8080,\n        interval=1, reloader=False, quiet=False, plugins=None,\n        debug=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on\n               all interfaces including the external one. (default: 127.0.0.1)\n        :param port: Server port to bind to. Values below 1024 require root\n               privileges. (default: 8080)\n        :param reloader: Start auto-reloading server? (default: False)\n        :param interval: Auto-reloader interval in seconds (default: 1)\n        :param quiet: Suppress output to stdout and stderr? (default: False)\n        :param options: Options passed to the server adapter.\n     \"\"\"\n    if NORUN: return\n    if reloader and not os.environ.get('BOTTLE_CHILD'):\n        try:\n            lockfile = None\n            fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')\n            os.close(fd) # We only need this file to exist. We never write to it\n            while os.path.exists(lockfile):\n                args = [sys.executable] + sys.argv\n                environ = os.environ.copy()\n                environ['BOTTLE_CHILD'] = 'true'\n                environ['BOTTLE_LOCKFILE'] = lockfile\n                p = subprocess.Popen(args, env=environ)\n                while p.poll() is None: # Busy wait...\n                    os.utime(lockfile, None) # I am alive!\n                    time.sleep(interval)\n                if p.poll() != 3:\n                    if os.path.exists(lockfile): os.unlink(lockfile)\n                    sys.exit(p.poll())\n        except KeyboardInterrupt:\n            pass\n        finally:\n            if os.path.exists(lockfile):\n                os.unlink(lockfile)\n        return\n\n    try:\n        if debug is not None: _debug(debug)\n        app = app or default_app()\n        if isinstance(app, basestring):\n            app = load_app(app)\n        if not callable(app):\n            raise ValueError(\"Application is not callable: %r\" % app)\n\n        for plugin in plugins or []:\n            app.install(plugin)\n\n        if server in server_names:\n            server = server_names.get(server)\n        if isinstance(server, basestring):\n            server = load(server)\n        if isinstance(server, type):\n            server = server(host=host, port=port, **kargs)\n        if not isinstance(server, ServerAdapter):\n            raise ValueError(\"Unknown or unsupported server: %r\" % server)\n\n        server.quiet = server.quiet or quiet\n        if not server.quiet:\n            _stderr(\"Bottle v%s server starting up (using %s)...\\n\" % (__version__, repr(server)))\n            _stderr(\"Listening on http://%s:%d/\\n\" % (server.host, server.port))\n            _stderr(\"Hit Ctrl-C to quit.\\n\\n\")\n\n        if reloader:\n            lockfile = os.environ.get('BOTTLE_LOCKFILE')\n            bgcheck = FileCheckerThread(lockfile, interval)\n            with bgcheck:\n                server.run(app)\n            if bgcheck.status == 'reload':\n                sys.exit(3)\n        else:\n            server.run(app)\n    except KeyboardInterrupt:\n        pass\n    except (SystemExit, MemoryError):\n        raise\n    except:\n        if not reloader: raise\n        if not getattr(server, 'quiet', quiet):\n            print_exc()\n        time.sleep(interval)\n        sys.exit(3)\n\n\n\nclass FileCheckerThread(threading.Thread):\n    ''' Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets to old. '''\n\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n\n    def run(self):\n        exists = os.path.exists\n        mtime = lambda path: os.stat(path).st_mtime\n        files = dict()\n\n        for module in list(sys.modules.values()):\n            path = getattr(module, '__file__', '') or ''\n            if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]\n            if path and exists(path): files[path] = mtime(path)\n\n        while not self.status:\n            if not exists(self.lockfile)\\\n            or mtime(self.lockfile) < time.time() - self.interval - 5:\n                self.status = 'error'\n                thread.interrupt_main()\n            for path, lmtime in list(files.items()):\n                if not exists(path) or mtime(path) > lmtime:\n                    self.status = 'reload'\n                    thread.interrupt_main()\n                    break\n            time.sleep(self.interval)\n\n    def __enter__(self):\n        self.start()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if not self.status: self.status = 'exit' # silent exit\n        self.join()\n        return exc_type is not None and issubclass(exc_type, KeyboardInterrupt)\n\n\n\n\n\n###############################################################################\n# Template Adapters ############################################################\n###############################################################################\n\n\nclass TemplateError(HTTPError):\n    def __init__(self, message):\n        HTTPError.__init__(self, 500, message)\n\n\nclass BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl','html','thtml','stpl']\n    settings = {} #used in prepare()\n    defaults = {} #used in render()\n\n    def __init__(self, source=None, name=None, lookup=[], encoding='utf8', **settings):\n        \"\"\" Create a new template.\n        If the source parameter (str or buffer) is missing, the name argument\n        is used to guess a template filename. Subclasses can assume that\n        self.source and/or self.filename are set. Both are strings.\n        The lookup, encoding and settings parameters are stored as instance\n        variables.\n        The lookup parameter stores a list containing directory paths.\n        The encoding parameter should be used to decode byte strings or files.\n        The settings parameter contains a dict for engine-specific settings.\n        \"\"\"\n        self.name = name\n        self.source = source.read() if hasattr(source, 'read') else source\n        self.filename = source.filename if hasattr(source, 'filename') else None\n        self.lookup = [os.path.abspath(x) for x in lookup]\n        self.encoding = encoding\n        self.settings = self.settings.copy() # Copy from class variable\n        self.settings.update(settings) # Apply\n        if not self.source and self.name:\n            self.filename = self.search(self.name, self.lookup)\n            if not self.filename:\n                raise TemplateError('Template %s not found.' % repr(name))\n        if not self.source and not self.filename:\n            raise TemplateError('No template specified.')\n        self.prepare(**self.settings)\n\n    @classmethod\n    def search(cls, name, lookup=[]):\n        \"\"\" Search name in all directories specified in lookup.\n        First without, then with common extensions. Return first hit. \"\"\"\n        if not lookup:\n            depr('The template lookup path list should not be empty.') #0.12\n            lookup = ['.']\n\n        if os.path.isabs(name) and os.path.isfile(name):\n            depr('Absolute template path names are deprecated.') #0.12\n            return os.path.abspath(name)\n\n        for spath in lookup:\n            spath = os.path.abspath(spath) + os.sep\n            fname = os.path.abspath(os.path.join(spath, name))\n            if not fname.startswith(spath): continue\n            if os.path.isfile(fname): return fname\n            for ext in cls.extensions:\n                if os.path.isfile('%s.%s' % (fname, ext)):\n                    return '%s.%s' % (fname, ext)\n\n    @classmethod\n    def global_config(cls, key, *args):\n        ''' This reads or sets the global settings stored in class.settings. '''\n        if args:\n            cls.settings = cls.settings.copy() # Make settings local to class\n            cls.settings[key] = args[0]\n        else:\n            return cls.settings[key]\n\n    def prepare(self, **options):\n        \"\"\" Run preparations (parsing, caching, ...).\n        It should be possible to call this again to refresh a template or to\n        update settings.\n        \"\"\"\n        raise NotImplementedError\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template with the specified local variables and return\n        a single byte or unicode string. If it is a byte string, the encoding\n        must match self.encoding. This method must be thread-safe!\n        Local variables may be provided in dictionaries (args)\n        or directly, as keywords (kwargs).\n        \"\"\"\n        raise NotImplementedError\n\n\nclass MakoTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from mako.template import Template\n        from mako.lookup import TemplateLookup\n        options.update({'input_encoding':self.encoding})\n        options.setdefault('format_exceptions', bool(DEBUG))\n        lookup = TemplateLookup(directories=self.lookup, **options)\n        if self.source:\n            self.tpl = Template(self.source, lookup=lookup, **options)\n        else:\n            self.tpl = Template(uri=self.name, filename=self.filename, lookup=lookup, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args: kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n\nclass CheetahTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from Cheetah.Template import Template\n        self.context = threading.local()\n        self.context.vars = {}\n        options['searchList'] = [self.context.vars]\n        if self.source:\n            self.tpl = Template(source=self.source, **options)\n        else:\n            self.tpl = Template(file=self.filename, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args: kwargs.update(dictarg)\n        self.context.vars.update(self.defaults)\n        self.context.vars.update(kwargs)\n        out = str(self.tpl)\n        self.context.vars.clear()\n        return out\n\n\nclass Jinja2Template(BaseTemplate):\n    def prepare(self, filters=None, tests=None, globals={}, **kwargs):\n        from jinja2 import Environment, FunctionLoader\n        if 'prefix' in kwargs: # TODO: to be removed after a while\n            raise RuntimeError('The keyword argument `prefix` has been removed. '\n                'Use the full jinja2 environment name line_statement_prefix instead.')\n        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)\n        if filters: self.env.filters.update(filters)\n        if tests: self.env.tests.update(tests)\n        if globals: self.env.globals.update(globals)\n        if self.source:\n            self.tpl = self.env.from_string(self.source)\n        else:\n            self.tpl = self.env.get_template(self.filename)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args: kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n    def loader(self, name):\n        fname = self.search(name, self.lookup)\n        if not fname: return\n        with open(fname, \"rb\") as f:\n            return f.read().decode(self.encoding)\n\n\nclass SimpleTemplate(BaseTemplate):\n\n    def prepare(self, escape_func=html_escape, noescape=False, syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n\n    @cached_property\n    def co(self):\n        return compile(self.code, self.filename or '<string>', 'exec')\n\n    @cached_property\n    def code(self):\n        source = self.source\n        if not source:\n            with open(self.filename, 'rb') as f:\n                source = f.read()\n        try:\n            source, encoding = touni(source), 'utf8'\n        except UnicodeError:\n            depr('Template encodings other than utf8 are no longer supported.') #0.11\n            source, encoding = touni(source, 'latin1'), 'latin1'\n        parser = StplParser(source, encoding=encoding, syntax=self.syntax)\n        code = parser.translate()\n        self.encoding = parser.encoding\n        return code\n\n    def _rebase(self, _env, _name=None, **kwargs):\n        if _name is None:\n            depr('Rebase function called without arguments.'\n                 ' You were probably looking for {{base}}?', True) #0.12\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        if _name is None:\n            depr('Rebase function called without arguments.'\n                 ' You were probably looking for {{base}}?', True) #0.12\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup)\n        return self.cache[_name].execute(env['_stdout'], env)\n\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({'_stdout': _stdout, '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env), '_rebase': None,\n            '_str': self._str, '_escape': self._escape, 'get': env.get,\n            'setdefault': env.setdefault, 'defined': env.__contains__ })\n        eval(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout) #copy stdout\n            del _stdout[:] # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}; stdout = []\n        for dictarg in args: env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n\n\nclass StplSyntaxError(TemplateError): pass\n\n\nclass StplParser(object):\n    ''' Parser for stpl templates. '''\n    _re_cache = {} #: Cache for compiled re patterns\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # 1: All kinds of python strings (trust me, it works)\n    _re_tok = '([urbURB]?(?:\\'\\'(?!\\')|\"\"(?!\")|\\'{6}|\"{6}' \\\n               '|\\'(?:[^\\\\\\\\\\']|\\\\\\\\.)+?\\'|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)+?\"' \\\n               '|\\'{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\\'{3}' \\\n               '|\"{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\"{3}))'\n    _re_inl = _re_tok.replace('|\\\\n','') # We re-use this string pattern later\n    # 2: Comments (until end of line, but not the newline itself)\n    _re_tok += '|(#.*)'\n    # 3,4: Open and close grouping tokens\n    _re_tok += '|([\\\\[\\\\{\\\\(])'\n    _re_tok += '|([\\\\]\\\\}\\\\)])'\n    # 5,6: Keywords that start or continue a python block (only start of line)\n    _re_tok += '|^([ \\\\t]*(?:if|for|while|with|try|def|class)\\\\b)' \\\n               '|^([ \\\\t]*(?:elif|else|except|finally)\\\\b)'\n    # 7: Our special 'end' keyword (but only if it stands alone)\n    _re_tok += '|((?:^|;)[ \\\\t]*end[ \\\\t]*(?=(?:%(block_close)s[ \\\\t]*)?\\\\r?$|;|#))'\n    # 8: A customizable end-of-code-block template token (only end of line)\n    _re_tok += '|(%(block_close)s[ \\\\t]*(?=\\\\r?$))'\n    # 9: And finally, a single newline. The 10th token is 'everything else'\n    _re_tok += '|(\\\\r?\\\\n)'\n\n    # Match the start tokens of code areas in a template\n    _re_split = '(?m)^[ \\t]*(\\\\\\\\?)((%(line_start)s)|(%(block_start)s))(%%?)'\n    # Match inline statements (may contain python strings)\n    _re_inl = '(?m)%%(inline_start)s((?:%s|[^\\'\"\\n]*?)+)%%(inline_end)s' % _re_inl\n    _re_tok = '(?m)' + _re_tok\n\n    default_syntax = '<% %> % {{ }}'\n\n    def __init__(self, source, syntax=None, encoding='utf8'):\n        self.source, self.encoding = touni(source, encoding), encoding\n        self.set_syntax(syntax or self.default_syntax)\n        self.code_buffer, self.text_buffer = [], []\n        self.lineno, self.offset = 1, 0\n        self.indent, self.indent_mod = 0, 0\n        self.paren_depth = 0\n\n    def get_syntax(self):\n        ''' Tokens as a space separated string (default: <% %> % {{ }}) '''\n        return self._syntax\n\n    def set_syntax(self, syntax):\n        self._syntax = syntax\n        self._tokens = syntax.split()\n        if not syntax in self._re_cache:\n            names = 'block_start block_close line_start inline_start inline_end'\n            etokens = map(re.escape, self._tokens)\n            pattern_vars = dict(zip(names.split(), etokens))\n            patterns = (self._re_split, self._re_tok, self._re_inl)\n            patterns = [re.compile(p%pattern_vars) for p in patterns]\n            self._re_cache[syntax] = patterns\n        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]\n\n    syntax = property(get_syntax, set_syntax)\n\n    def translate(self):\n        if self.offset: raise RuntimeError('Parser is a one time instance.')\n        while True:\n            m = self.re_split.search(self.source[self.offset:])\n            if m:\n                text = self.source[self.offset:self.offset+m.start()]\n                self.text_buffer.append(text)\n                self.offset += m.end()\n                if m.group(1): # New escape syntax\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(m.group(2)+m.group(5)+line+sep)\n                    self.offset += len(line+sep)+1\n                    continue\n                elif m.group(5): # Old escape syntax\n                    depr('Escape code lines with a backslash.') #0.12\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(m.group(2)+line+sep)\n                    self.offset += len(line+sep)+1\n                    continue\n                self.flush_text()\n                self.read_code(multiline=bool(m.group(4)))\n            else: break\n        self.text_buffer.append(self.source[self.offset:])\n        self.flush_text()\n        return ''.join(self.code_buffer)\n\n    def read_code(self, multiline):\n        code_line, comment = '', ''\n        while True:\n            m = self.re_tok.search(self.source[self.offset:])\n            if not m:\n                code_line += self.source[self.offset:]\n                self.offset = len(self.source)\n                self.write_code(code_line.strip(), comment)\n                return\n            code_line += self.source[self.offset:self.offset+m.start()]\n            self.offset += m.end()\n            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()\n            if (code_line or self.paren_depth > 0) and (_blk1 or _blk2): # a if b else c\n                code_line += _blk1 or _blk2\n                continue\n            if _str:    # Python string\n                code_line += _str\n            elif _com:  # Python comment (up to EOL)\n                comment = _com\n                if multiline and _com.strip().endswith(self._tokens[1]):\n                    multiline = False # Allow end-of-block in comments\n            elif _po:  # open parenthesis\n                self.paren_depth += 1\n                code_line += _po\n            elif _pc:  # close parenthesis\n                if self.paren_depth > 0:\n                    # we could check for matching parentheses here, but it's\n                    # easier to leave that to python - just check counts\n                    self.paren_depth -= 1\n                code_line += _pc\n            elif _blk1: # Start-block keyword (if/for/while/def/try/...)\n                code_line, self.indent_mod = _blk1, -1\n                self.indent += 1\n            elif _blk2: # Continue-block keyword (else/elif/except/...)\n                code_line, self.indent_mod = _blk2, -1\n            elif _end:  # The non-standard 'end'-keyword (ends a block)\n                self.indent -= 1\n            elif _cend: # The end-code-block template token (usually '%>')\n                if multiline: multiline = False\n                else: code_line += _cend\n            else: # \\n\n                self.write_code(code_line.strip(), comment)\n                self.lineno += 1\n                code_line, comment, self.indent_mod = '', '', 0\n                if not multiline:\n                    break\n\n    def flush_text(self):\n        text = ''.join(self.text_buffer)\n        del self.text_buffer[:]\n        if not text: return\n        parts, pos, nl = [], 0, '\\\\\\n'+'  '*self.indent\n        for m in self.re_inl.finditer(text):\n            prefix, pos = text[pos:m.start()], m.end()\n            if prefix:\n                parts.append(nl.join(map(repr, prefix.splitlines(True))))\n            if prefix.endswith('\\n'): parts[-1] += nl\n            parts.append(self.process_inline(m.group(1).strip()))\n        if pos < len(text):\n            prefix = text[pos:]\n            lines = prefix.splitlines(True)\n            if lines[-1].endswith('\\\\\\\\\\n'): lines[-1] = lines[-1][:-3]\n            elif lines[-1].endswith('\\\\\\\\\\r\\n'): lines[-1] = lines[-1][:-4]\n            parts.append(nl.join(map(repr, lines)))\n        code = '_printlist((%s,))' % ', '.join(parts)\n        self.lineno += code.count('\\n')+1\n        self.write_code(code)\n\n    def process_inline(self, chunk):\n        if chunk[0] == '!': return '_str(%s)' % chunk[1:]\n        return '_escape(%s)' % chunk\n\n    def write_code(self, line, comment=''):\n        line, comment = self.fix_backward_compatibility(line, comment)\n        code  = '  ' * (self.indent+self.indent_mod)\n        code += line.lstrip() + comment + '\\n'\n        self.code_buffer.append(code)\n\n    def fix_backward_compatibility(self, line, comment):\n        parts = line.strip().split(None, 2)\n        if parts and parts[0] in ('include', 'rebase'):\n            depr('The include and rebase keywords are functions now.') #0.12\n            if len(parts) == 1:   return \"_printlist([base])\", comment\n            elif len(parts) == 2: return \"_=%s(%r)\" % tuple(parts), comment\n            else:                 return \"_=%s(%r, %s)\" % tuple(parts), comment\n        if self.lineno <= 2 and not line.strip() and 'coding' in comment:\n            m = re.match(r\"#.*coding[:=]\\s*([-\\w.]+)\", comment)\n            if m:\n                depr('PEP263 encoding strings in templates are deprecated.') #0.12\n                enc = m.group(1)\n                self.source = self.source.encode(self.encoding).decode(enc)\n                self.encoding = enc\n                return line, comment.replace('coding','coding*')\n        return line, comment\n\n\ndef template(*args, **kwargs):\n    '''\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    '''\n    tpl = args[0] if args else None\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    for dictarg in args[1:]: kwargs.update(dictarg)\n    return TEMPLATES[tplid].render(kwargs)\n\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template, template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n\n\ndef view(tpl_name, **defaults):\n    ''' Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    '''\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if isinstance(result, (dict, DictMixin)):\n                tplvars = defaults.copy()\n                tplvars.update(result)\n                return template(tpl_name, **tplvars)\n            elif result is None:\n                return template(tpl_name, defaults)\n            return result\n        return wrapper\n    return decorator\n\nmako_view = functools.partial(view, template_adapter=MakoTemplate)\ncheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n\n\n\n\n\n\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\n\n\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()\n\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses\nHTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">\n              html {background-color: #eee; font-family: sans;}\n              body {background-color: #fff; border: 1px solid #ddd;\n                    padding: 15px; margin: 15px;}\n              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}\n            </style>\n        </head>\n        <body>\n            <h1>Error: {{e.status}}</h1>\n            <p>Sorry, the requested URL <tt>{{repr(request.url)}}</tt>\n               caused an error:</p>\n            <pre>{{e.body}}</pre>\n            %%if DEBUG and e.exception:\n              <h2>Exception:</h2>\n              <pre>{{repr(e.exception)}}</pre>\n            %%end\n            %%if DEBUG and e.traceback:\n              <h2>Traceback:</h2>\n              <pre>{{e.traceback}}</pre>\n            %%end\n        </body>\n    </html>\n%%except ImportError:\n    <b>ImportError:</b> Could not generate the error page. Please add bottle to\n    the import path.\n%%end\n\"\"\" % __name__\n\n#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a\n#: request callback, this instance always refers to the *current* request\n#: (even on a multithreaded server).\nrequest = LocalRequest()\n\n#: A thread-safe instance of :class:`LocalResponse`. It is used to change the\n#: HTTP response for the *current* request.\nresponse = LocalResponse()\n\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n\n# Initialize app stack (create first empty Bottle app)\n# BC: 0.6.4 and needed for run()\napp = default_app = AppStack()\napp.push()\n\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else __name__+\".ext\", 'bottle_%s').module\n\nif __name__ == '__main__':\n    opt, args, parser = _cmd_options, _cmd_args, _cmd_parser\n    if opt.version:\n        _stdout('Bottle %s\\n'%__version__)\n        sys.exit(0)\n    if not args:\n        parser.print_help()\n        _stderr('\\nError: No application specified.\\n')\n        sys.exit(1)\n\n    sys.path.insert(0, '.')\n    sys.modules.setdefault('bottle', sys.modules['__main__'])\n\n    host, port = (opt.bind or 'localhost'), 8080\n    if ':' in host and host.rfind(']') < host.rfind(':'):\n        host, port = host.rsplit(':', 1)\n    host = host.strip('[]')\n\n    run(args[0], host=host, port=int(port), server=opt.server,\n        reloader=opt.reload, plugins=opt.plugin, debug=opt.debug)\n\n\n\n\n# THE END\n"], "filenames": ["bottle.py"], "buggy_code_start_loc": [19], "buggy_code_end_loc": [20], "fixing_code_start_loc": [19], "fixing_code_end_loc": [20], "type": "CWE-755", "message": "Bottle before 0.12.20 mishandles errors during early request binding.", "other": {"cve": {"id": "CVE-2022-31799", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:15:58.213", "lastModified": "2022-12-12T20:20:46.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Bottle before 0.12.20 mishandles errors during early request binding."}, {"lang": "es", "value": "Bottle versiones anteriores a 0.12.20, maneja inapropiadamente los errores durante la vinculaci\u00f3n temprana de peticiones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bottlepy:bottle:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.20", "matchCriteriaId": "8A477F9C-0555-4001-B286-1360CCAEB8D9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/bottlepy/bottle/commit/a2b0ee6bb4ce88895429ec4aca856616244c4c4c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bottlepy/bottle/commit/e140e1b54da721a660f2eb9d58a106b7b3ff2f00", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bottlepy/bottle/compare/0.12.19...0.12.20", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/06/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IE7U6J45PUEXIYYVWJKPM6QXIRKDK4HD/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KTLOQGMDZEPIYTFC2G53OQV2ULCGYS3F/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5159", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bottlepy/bottle/commit/a2b0ee6bb4ce88895429ec4aca856616244c4c4c"}}