{"buggy_code": ["/**\n * Encode and decode ini/conf/cfg files\n * @author Rolf Loges\n * @licence MIT\n * @param {{lineEnding: string, sectionOpenIdentifier: string, sectionCloseIdentifier: string, defaultValue: boolean, assignIdentifier: string, commentIdentifiers: string, trimLines: boolean, ignoreMultipleAssignIdentifier: boolean}} options\n */\nfunction Config(options){\n    this.options = {\n        lineEnding: \"\\r\\n\",\n        sectionOpenIdentifier: '[',\n        sectionCloseIdentifier: ']',\n        defaultValue: true,\n        assignIdentifier: \"=\",\n        valueIdentifier: undefined,\n        commentIdentifiers: [\";\"],\n        trimLines: true,\n        ignoreMultipleAssignIdentifier: false\n    };\n    if(typeof options === 'object'){\n        this.setOptions(options);\n    }\n}\n\n/**\n * Decode a config-string\n * \n * @param {string} data\n * @return {{}}\n */\nConfig.prototype.decode = function(data){\n    if(typeof data != 'string'){\n        if(typeof data.toString === 'function'){\n            data = data.toString();\n        } else {\n            throw new Error('expecting string but got '+typeof data);\n        }\n    }\n    var result = {};\n    var currentSection = undefined;\n    var lines = data.split(this.options.lineEnding);\n    for(var i = 0; i < lines.length; i++){\n        var line = lines[i];\n        if(this.options.trimLines === true){\n            line = line.trim();\n        }\n        if(line.length == 0 || stringBeginsWithOnOfTheseStrings(line,this.options.commentIdentifiers)){\n            continue;\n        }\n        \n        var sectionRegExp = new RegExp(\"^\\\\\"+this.options.sectionOpenIdentifier+\"(.*?)\\\\\"+this.options.sectionCloseIdentifier+\"$\");\n        var newSection = line.match(sectionRegExp);\n        if(newSection !== null){\n            currentSection = newSection[1];\n            if(typeof result[currentSection] === 'undefined'){\n                result[currentSection] = {};\n            }\n            continue;\n        }\n\n        var assignPosition = line.indexOf(this.options.assignIdentifier);\n        var key = undefined;\n        var value = undefined;\n        if(assignPosition === -1){\n            key = line;\n            value = this.options.defaultValue;\n        } else {\n            var assignIdentifierLength = this.options.assignIdentifier.length\n            if (this.options.ignoreMultipleAssignIdentifier) {\n                var regExp = new RegExp(escapeRegExp(this.options.assignIdentifier) + '+')\n                var matchResult = line.match(regExp)\n                if (matchResult !== null) {\n                    assignIdentifierLength = matchResult[0].length\n                }\n            }\n            key = line.substr(0,assignPosition);\n            value = line.substr(assignPosition+assignIdentifierLength);\n        }\n        if (typeof this.options.valueIdentifier === 'string') {\n            value = this.valueTrim(value, this.options.valueIdentifier);\n        }\n        if(typeof currentSection === 'undefined'){\n            result[key] = value;\n        } else {\n            result[currentSection][key] = value;\n        }\n    }\n    return result;\n}\n\n/**\n * Encode a object\n * no nesting section supported!\n * \n * @param {{}} object\n * @return {string}\n */\nConfig.prototype.encode = function(object){\n    var resultSections = \"\";\n    var resultAttributesWithoutSection = \"\";\n    var sections = Object.keys(object);\n    if (typeof this.options.valueIdentifier === 'string'){\n        var valueIdentifier = this.options.valueIdentifier;\n    } else {\n        var valueIdentifier = \"\";\n    }\n    for(var i = 0; i < sections.length; i++){\n        if(typeof object[sections[i]] === 'object'){\n            if(resultSections != \"\"){\n                resultSections += this.options.lineEnding;\n            }\n            resultSections += this.options.sectionOpenIdentifier;\n            resultSections += sections[i];\n            resultSections += this.options.sectionCloseIdentifier;\n            resultSections += this.options.lineEnding;\n            var attributes = Object.keys(object[sections[i]]);\n            for(var j = 0; j < attributes.length; j++){\n                resultSections += attributes[j];\n                resultSections += this.options.assignIdentifier;\n                resultSections += valueIdentifier;\n                resultSections += object[sections[i]][attributes[j]];\n                resultSections += valueIdentifier;\n                resultSections += this.options.lineEnding;\n            }\n        } else {\n            resultAttributesWithoutSection += sections[i];\n            resultAttributesWithoutSection += this.options.assignIdentifier;\n            resultAttributesWithoutSection += object[sections[i]];\n            resultAttributesWithoutSection += this.options.lineEnding;\n        }\n    }\n    return resultAttributesWithoutSection+resultSections;\n}\n\n/**\n * Set Options\n * @param {{lineEnding: string, sectionOpenIdentifier: string, sectionCloseIdentifier: string, defaultValue: boolean, assignIdentifier: string, commentIdentifiers: string, trimLines: boolean}} options\n */\nConfig.prototype.setOptions = function(options){\n    if(typeof options !== 'object'){\n        throw new Error('expecting object but got '+typeof options);\n    }\n    var option = Object.keys(options);\n    for(var i = 0; i < option.length; i++){\n        if(typeof options[option[i]] !== 'undefined'){\n            this.options[option[i]] = options[option[i]];\n        }\n    }\n}\n\n/**\n * Try to detect the used line ending\n * (windows, unix, mac)\n * @param {string} data\n * @return {string}\n */\nConfig.prototype.detectLineEnding = function(data){\n    var hasCaridgeReturn = data.indexOf(\"\\r\") !== -1;\n    var hasLineFeed = data.indexOf(\"\\n\") !== -1\n    if(hasCaridgeReturn && hasLineFeed){\n        if(data.indexOf(\"\\r\\n\") !== -1){\n            return \"\\r\\n\";\n        } else if(data.indexOf(\"\\n\\r\") !== -1){\n            return \"\\n\\r\";\n        } else {\n            throw new Error('found multiple line endings');\n        }\n    } else if(hasLineFeed){\n        return \"\\n\";\n    } else if(hasCaridgeReturn){\n        return \"\\r\";\n    } else {\n        return \"\\n\";\n    }\n}\n\n/**\n * @param string value\n * @param string chars\n */\nConfig.prototype.valueTrim = function(value, chars){\n    var charsEscaped = chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    var regEx = new RegExp(\"^[\"+charsEscaped+\"]?\");\n    value = value.replace(regEx, '');\n    regEx = new RegExp(\"[\"+charsEscaped+\"]?$\");\n    value = value.replace(regEx, '');\n    return value;\n}\n\n/**\n * @param {string} string\n * @param {string[]} stringList\n * @return {boolean}\n */\nfunction stringBeginsWithOnOfTheseStrings(string, stringList){\n    for(var i = 0; i < stringList.length; i++){\n        if(string.indexOf(stringList[i]) === 0){\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @param {string} string\n * @returns {string}\n */\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nmodule.exports = Config;\n", "var should = require('chai').should();\nvar expect = require('chai').expect;\nvar Config = require('./conf-cfg-ini');\n\nvar testData = [\n    \";comment\\n[SectionA]\\na=1\\nb=2\\n\",\n    \";comment\\r\\n[SectionA]\\r\\na=1\\r\\nb=2\\r\\n\",\n    \"stray=true;comment\\r\\n[SectionA]\\r\\na=1\\r\\nb=2\\r\\n\"\n];\n\ndescribe('Config', function() {\n    it('should be defined', function () {\n        should.exist(Config);\n    });\n    \n    it('setOptions should overwrite options', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.trimLines = true;\n        config.setOptions({lineEnding: \"\\r\\n\", trimLines: undefined});\n        expect(config.options.lineEnding).to.equal(\"\\r\\n\");\n        expect(config.options.trimLines).to.equal(true);\n    });\n    \n    it('detectLineEndings should detect windows style (\\\\r\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\r\\nline2\\r\\n\").should.equal(\"\\r\\n\");\n    });\n    \n    it('detectLineEndings should detect unix style (\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\nline2\\n\").should.equal(\"\\n\");\n    });\n    \n    it('detectLineEndings should detect mac style (\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\rline2\\r\").should.equal(\"\\r\");\n    });\n    \n    it('detectLineEndings should detect wtf style (\\\\n\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\n\\rline2\\n\\r\").should.equal(\"\\n\\r\");\n    });\n    \n    it('decode should return a object', function () {\n        var config = new Config();\n        for(var i = 0; i < testData.length; i++){\n            config.decode(testData[i]).should.be.a('object');\n        }\n    });\n    \n    it('encode return should a string', function () {\n        var config = new Config();\n        config.encode({'Section':{'a': 1}}).should.be.a('string');\n        config.encode({'a':1}).should.be.a('string');\n        config.encode({}).should.be.a('string');\n    });\n    \n    it('decode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var result = config.decode(\"stray=foo\\n[Section1]\\na=b\\n\");\n        expect(result.stray).to.equal(\"foo\");\n    });\n    \n    it('encode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var encoded = config.encode({stray:'foo','SectionA':{'a': 1}});\n        var decoded = config.decode(encoded);\n        expect(decoded.stray).to.equal(\"foo\");\n    });\n    \n    it('decode should return object with same attributes', function () {\n        var data = \";comment\\n[SectionA]\\nkey=value\\n\";\n        var config = new Config();\n        config.options.lineEnding = config.detectLineEnding(data);\n        var result = config.decode(data);\n        result.should.be.a('object');\n        should.exist(result.SectionA);\n        result.SectionA.key.should.equal(\"value\");\n    });\n    \n    it('decode>encode>decode>encode return should produce consistent results', function () {\n        for(var i = 0; i < testData.length; i++){\n            var data = testData[i];\n            var config = new Config();\n            config.options.lineEnding = config.detectLineEnding(data);\n            var decoded1 = config.decode(data);\n            var encoded1 = config.encode(decoded1);\n            var decoded2 = config.decode(encoded1);\n            var encoded2 = config.encode(decoded2);\n            expect(encoded1).to.equal(encoded2);\n            expect(decoded1).to.deep.equal(decoded2);\n        }\n    });\n    \n    it('decode should be able to handle multiple comment identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.commentIdentifiers = [';','//','#'];\n        var result = config.decode(\";comment1\\n//comment2\\n#comment3\\n\");\n        expect(result).to.deep.equal({});\n    });\n    \n    it('decode should be able to handle custom assign identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.assignIdentifier = \":\";\n        var result = config.decode(\"[Section]\\nfoo:bar\\n\");\n        should.exist(result.Section);\n        expect(result.Section.foo).to.equal(\"bar\");\n    });\n\n    it('valueTrim should trim custom chars', function () {\n        var config = new Config();\n        expect(config.valueTrim('\"Te\"s\"t\"', '\"')).to.equal('Te\"s\"t');\n        expect(config.valueTrim('\"Te\"s\"t\"', '')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"Te\"s\"t\"', '#')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"\"Te\"s\"t\"\"', '\"\"')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('[Te\"s\"t]', '[]')).to.equal('Te\"s\"t');\n    })\n\n    it('valueIdentifiers should trimed or added', function () {\n        var data = \"[SectionA]\\nkey1='val1'\\nkey2='val2'\\n\";\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.valueIdentifier = \"'\"\n        var result = config.decode(data);\n        expect(result.SectionA.key1).to.equal(\"val1\");\n        expect(result.SectionA.key2).to.equal(\"val2\");\n        var data2 = config.encode(result);\n        expect(data2).to.equal(data);\n    })\n\n    it('ignoreMultipleAssignIdentifier should ignore multiple assing identifiers', function () {\n        var data = \"a\\t1\\nb\\t\\t2\\nc\\t3\\t\\n\";\n        var config = new Config();\n        config.options.assignIdentifier = '\\t'\n        config.options.lineEnding = \"\\n\";\n        config.options.ignoreMultipleAssignIdentifier = true;\n        config.options.trimLines = false;\n        var result = config.decode(data);\n        expect(result.a).to.equal(\"1\");\n        expect(result.b).to.equal(\"2\");\n        expect(result.c).to.equal(\"3\\t\");\n    })\n});\n"], "fixing_code": ["/**\n * Encode and decode ini/conf/cfg files\n * @author Rolf Loges\n * @licence MIT\n * @param {{lineEnding: string, sectionOpenIdentifier: string, sectionCloseIdentifier: string, defaultValue: boolean, assignIdentifier: string, commentIdentifiers: string, trimLines: boolean, ignoreMultipleAssignIdentifier: boolean}} options\n */\nfunction Config(options){\n    this.options = {\n        lineEnding: \"\\r\\n\",\n        sectionOpenIdentifier: '[',\n        sectionCloseIdentifier: ']',\n        defaultValue: true,\n        assignIdentifier: \"=\",\n        valueIdentifier: undefined,\n        commentIdentifiers: [\";\"],\n        trimLines: true,\n        ignoreMultipleAssignIdentifier: false\n    };\n    if(typeof options === 'object'){\n        this.setOptions(options);\n    }\n}\n\n/**\n * Decode a config-string\n * \n * @param {string} data\n * @return {{}}\n */\nConfig.prototype.decode = function(data){\n    if(typeof data != 'string'){\n        if(typeof data.toString === 'function'){\n            data = data.toString();\n        } else {\n            throw new Error('expecting string but got '+typeof data);\n        }\n    }\n    var protectedKeys = ['__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', '__proto__'];\n    var result = {};\n    var currentSection = undefined;\n    var lines = data.split(this.options.lineEnding);\n    for(var i = 0; i < lines.length; i++){\n        var line = lines[i];\n        if(this.options.trimLines === true){\n            line = line.trim();\n        }\n        if(line.length == 0 || stringBeginsWithOnOfTheseStrings(line,this.options.commentIdentifiers)){\n            continue;\n        }\n        \n        var sectionRegExp = new RegExp(\"^\\\\\"+this.options.sectionOpenIdentifier+\"(.*?)\\\\\"+this.options.sectionCloseIdentifier+\"$\");\n        var newSection = line.match(sectionRegExp);\n        if(newSection !== null){\n            currentSection = newSection[1];\n            if(typeof result[currentSection] === 'undefined' && !protectedKeys.includes(currentSection)){\n                result[currentSection] = {};\n            }\n            continue;\n        }\n\n        var assignPosition = line.indexOf(this.options.assignIdentifier);\n        var key = undefined;\n        var value = undefined;\n        if(assignPosition === -1){\n            key = line;\n            value = this.options.defaultValue;\n        } else {\n            var assignIdentifierLength = this.options.assignIdentifier.length\n            if (this.options.ignoreMultipleAssignIdentifier) {\n                var regExp = new RegExp(escapeRegExp(this.options.assignIdentifier) + '+')\n                var matchResult = line.match(regExp)\n                if (matchResult !== null) {\n                    assignIdentifierLength = matchResult[0].length\n                }\n            }\n            key = line.substr(0,assignPosition);\n            value = line.substr(assignPosition+assignIdentifierLength);\n        }\n        if (typeof this.options.valueIdentifier === 'string') {\n            value = this.valueTrim(value, this.options.valueIdentifier);\n        }\n        if (protectedKeys.includes(currentSection) || protectedKeys.includes(key)) {\n            continue;\n        }\n        if(typeof currentSection === 'undefined'){\n            result[key] = value;\n        } else {\n            result[currentSection][key] = value;\n        }\n    }\n    return result;\n}\n\n/**\n * Encode a object\n * no nesting section supported!\n * \n * @param {{}} object\n * @return {string}\n */\nConfig.prototype.encode = function(object){\n    var resultSections = \"\";\n    var resultAttributesWithoutSection = \"\";\n    var sections = Object.keys(object);\n    if (typeof this.options.valueIdentifier === 'string'){\n        var valueIdentifier = this.options.valueIdentifier;\n    } else {\n        var valueIdentifier = \"\";\n    }\n    for(var i = 0; i < sections.length; i++){\n        if(typeof object[sections[i]] === 'object'){\n            if(resultSections != \"\"){\n                resultSections += this.options.lineEnding;\n            }\n            resultSections += this.options.sectionOpenIdentifier;\n            resultSections += sections[i];\n            resultSections += this.options.sectionCloseIdentifier;\n            resultSections += this.options.lineEnding;\n            var attributes = Object.keys(object[sections[i]]);\n            for(var j = 0; j < attributes.length; j++){\n                resultSections += attributes[j];\n                resultSections += this.options.assignIdentifier;\n                resultSections += valueIdentifier;\n                resultSections += object[sections[i]][attributes[j]];\n                resultSections += valueIdentifier;\n                resultSections += this.options.lineEnding;\n            }\n        } else {\n            resultAttributesWithoutSection += sections[i];\n            resultAttributesWithoutSection += this.options.assignIdentifier;\n            resultAttributesWithoutSection += object[sections[i]];\n            resultAttributesWithoutSection += this.options.lineEnding;\n        }\n    }\n    return resultAttributesWithoutSection+resultSections;\n}\n\n/**\n * Set Options\n * @param {{lineEnding: string, sectionOpenIdentifier: string, sectionCloseIdentifier: string, defaultValue: boolean, assignIdentifier: string, commentIdentifiers: string, trimLines: boolean}} options\n */\nConfig.prototype.setOptions = function(options){\n    if(typeof options !== 'object'){\n        throw new Error('expecting object but got '+typeof options);\n    }\n    var option = Object.keys(options);\n    for(var i = 0; i < option.length; i++){\n        if(typeof options[option[i]] !== 'undefined'){\n            this.options[option[i]] = options[option[i]];\n        }\n    }\n}\n\n/**\n * Try to detect the used line ending\n * (windows, unix, mac)\n * @param {string} data\n * @return {string}\n */\nConfig.prototype.detectLineEnding = function(data){\n    var hasCaridgeReturn = data.indexOf(\"\\r\") !== -1;\n    var hasLineFeed = data.indexOf(\"\\n\") !== -1\n    if(hasCaridgeReturn && hasLineFeed){\n        if(data.indexOf(\"\\r\\n\") !== -1){\n            return \"\\r\\n\";\n        } else if(data.indexOf(\"\\n\\r\") !== -1){\n            return \"\\n\\r\";\n        } else {\n            throw new Error('found multiple line endings');\n        }\n    } else if(hasLineFeed){\n        return \"\\n\";\n    } else if(hasCaridgeReturn){\n        return \"\\r\";\n    } else {\n        return \"\\n\";\n    }\n}\n\n/**\n * @param string value\n * @param string chars\n */\nConfig.prototype.valueTrim = function(value, chars){\n    var charsEscaped = chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    var regEx = new RegExp(\"^[\"+charsEscaped+\"]?\");\n    value = value.replace(regEx, '');\n    regEx = new RegExp(\"[\"+charsEscaped+\"]?$\");\n    value = value.replace(regEx, '');\n    return value;\n}\n\n/**\n * @param {string} string\n * @param {string[]} stringList\n * @return {boolean}\n */\nfunction stringBeginsWithOnOfTheseStrings(string, stringList){\n    for(var i = 0; i < stringList.length; i++){\n        if(string.indexOf(stringList[i]) === 0){\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @param {string} string\n * @returns {string}\n */\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nmodule.exports = Config;\n", "var should = require('chai').should();\nvar expect = require('chai').expect;\nvar Config = require('./conf-cfg-ini');\n\nvar testData = [\n    \";comment\\n[SectionA]\\na=1\\nb=2\\n\",\n    \";comment\\r\\n[SectionA]\\r\\na=1\\r\\nb=2\\r\\n\",\n    \"stray=true;comment\\r\\n[SectionA]\\r\\na=1\\r\\nb=2\\r\\n\"\n];\n\ndescribe('Config', function() {\n    it('should be defined', function () {\n        should.exist(Config);\n    });\n    \n    it('setOptions should overwrite options', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.trimLines = true;\n        config.setOptions({lineEnding: \"\\r\\n\", trimLines: undefined});\n        expect(config.options.lineEnding).to.equal(\"\\r\\n\");\n        expect(config.options.trimLines).to.equal(true);\n    });\n    \n    it('detectLineEndings should detect windows style (\\\\r\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\r\\nline2\\r\\n\").should.equal(\"\\r\\n\");\n    });\n    \n    it('detectLineEndings should detect unix style (\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\nline2\\n\").should.equal(\"\\n\");\n    });\n    \n    it('detectLineEndings should detect mac style (\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\rline2\\r\").should.equal(\"\\r\");\n    });\n    \n    it('detectLineEndings should detect wtf style (\\\\n\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\n\\rline2\\n\\r\").should.equal(\"\\n\\r\");\n    });\n    \n    it('decode should return a object', function () {\n        var config = new Config();\n        for(var i = 0; i < testData.length; i++){\n            config.decode(testData[i]).should.be.a('object');\n        }\n    });\n    \n    it('encode return should a string', function () {\n        var config = new Config();\n        config.encode({'Section':{'a': 1}}).should.be.a('string');\n        config.encode({'a':1}).should.be.a('string');\n        config.encode({}).should.be.a('string');\n    });\n    \n    it('decode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var result = config.decode(\"stray=foo\\n[Section1]\\na=b\\n\");\n        expect(result.stray).to.equal(\"foo\");\n    });\n    \n    it('encode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var encoded = config.encode({stray:'foo','SectionA':{'a': 1}});\n        var decoded = config.decode(encoded);\n        expect(decoded.stray).to.equal(\"foo\");\n    });\n    \n    it('decode should return object with same attributes', function () {\n        var data = \";comment\\n[SectionA]\\nkey=value\\n\";\n        var config = new Config();\n        config.options.lineEnding = config.detectLineEnding(data);\n        var result = config.decode(data);\n        result.should.be.a('object');\n        should.exist(result.SectionA);\n        result.SectionA.key.should.equal(\"value\");\n    });\n    \n    it('decode>encode>decode>encode return should produce consistent results', function () {\n        for(var i = 0; i < testData.length; i++){\n            var data = testData[i];\n            var config = new Config();\n            config.options.lineEnding = config.detectLineEnding(data);\n            var decoded1 = config.decode(data);\n            var encoded1 = config.encode(decoded1);\n            var decoded2 = config.decode(encoded1);\n            var encoded2 = config.encode(decoded2);\n            expect(encoded1).to.equal(encoded2);\n            expect(decoded1).to.deep.equal(decoded2);\n        }\n    });\n    \n    it('decode should be able to handle multiple comment identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.commentIdentifiers = [';','//','#'];\n        var result = config.decode(\";comment1\\n//comment2\\n#comment3\\n\");\n        expect(result).to.deep.equal({});\n    });\n    \n    it('decode should be able to handle custom assign identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.assignIdentifier = \":\";\n        var result = config.decode(\"[Section]\\nfoo:bar\\n\");\n        should.exist(result.Section);\n        expect(result.Section.foo).to.equal(\"bar\");\n    });\n\n    it('decode should prevent prototype pollution attacks', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.assignIdentifier = \":\";\n        var result = config.decode(\"[__proto__]\\nfoo:bar\\n\");\n        should.not.exist(result.__proto__.foo);\n        result = config.decode(\"[Section]\\n__proto__:bar\\n\");\n        expect(result.Section.__proto__).to.not.equal(\"bar\");\n    });\n\n    it('valueTrim should trim custom chars', function () {\n        var config = new Config();\n        expect(config.valueTrim('\"Te\"s\"t\"', '\"')).to.equal('Te\"s\"t');\n        expect(config.valueTrim('\"Te\"s\"t\"', '')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"Te\"s\"t\"', '#')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"\"Te\"s\"t\"\"', '\"\"')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('[Te\"s\"t]', '[]')).to.equal('Te\"s\"t');\n    })\n\n    it('valueIdentifiers should trimed or added', function () {\n        var data = \"[SectionA]\\nkey1='val1'\\nkey2='val2'\\n\";\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.valueIdentifier = \"'\"\n        var result = config.decode(data);\n        expect(result.SectionA.key1).to.equal(\"val1\");\n        expect(result.SectionA.key2).to.equal(\"val2\");\n        var data2 = config.encode(result);\n        expect(data2).to.equal(data);\n    })\n\n    it('ignoreMultipleAssignIdentifier should ignore multiple assing identifiers', function () {\n        var data = \"a\\t1\\nb\\t\\t2\\nc\\t3\\t\\n\";\n        var config = new Config();\n        config.options.assignIdentifier = '\\t'\n        config.options.lineEnding = \"\\n\";\n        config.options.ignoreMultipleAssignIdentifier = true;\n        config.options.trimLines = false;\n        var result = config.decode(data);\n        expect(result.a).to.equal(\"1\");\n        expect(result.b).to.equal(\"2\");\n        expect(result.c).to.equal(\"3\\t\");\n    })\n});\n"], "filenames": ["conf-cfg-ini.js", "conf-cfg-ini.spec.js"], "buggy_code_start_loc": [37, 114], "buggy_code_end_loc": [79, 114], "fixing_code_start_loc": [38, 115], "fixing_code_end_loc": [84, 125], "type": "CWE-1321", "message": "This affects the package conf-cfg-ini before 1.2.2. If an attacker submits a malicious INI file to an application that parses it with decode, they will pollute the prototype on the application. This can be exploited further depending on the context.", "other": {"cve": {"id": "CVE-2020-28441", "sourceIdentifier": "report@snyk.io", "published": "2022-07-25T14:15:09.270", "lastModified": "2022-08-01T12:35:52.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package conf-cfg-ini before 1.2.2. If an attacker submits a malicious INI file to an application that parses it with decode, they will pollute the prototype on the application. This can be exploited further depending on the context."}, {"lang": "es", "value": "Esto afecta al paquete conf-cfg-ini versiones anteriores a 1.2.2. Si un atacante env\u00eda un archivo INI malicioso a una aplicaci\u00f3n que lo analiza con decodificaci\u00f3n, contaminar\u00e1 el prototipo en la aplicaci\u00f3n. Esto puede ser explotado a\u00fan m\u00e1s dependiendo del contexto"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:conf-cfg-ini_project:conf-cfg-ini:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "730DBCED-795E-4FC9-9F90-3CDC41DAC7DA"}]}]}], "references": [{"url": "https://github.com/loge5/conf-cfg-ini/commit/3a88a6c52c31eb6c0f033369eed40aa168a636ea", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-CONFCFGINI-1048973", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/loge5/conf-cfg-ini/commit/3a88a6c52c31eb6c0f033369eed40aa168a636ea"}}