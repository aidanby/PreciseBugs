{"buggy_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjnath/stun_msg.h>\n#include <pjnath/errno.h>\n#include <pjlib-util/crc32.h>\n#include <pjlib-util/hmac_sha1.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n#define THIS_FILE               \"stun_msg.c\"\n#define STUN_XOR_FINGERPRINT    0x5354554eL\n\nstatic int padding_char;\n\nstatic const char *stun_method_names[PJ_STUN_METHOD_MAX] = \n{\n    \"Unknown\",                  /* 0 */\n    \"Binding\",                  /* 1 */\n    \"SharedSecret\",             /* 2 */\n    \"Allocate\",                 /* 3 */\n    \"Refresh\",                  /* 4 */\n    \"???\",                      /* 5 */\n    \"Send\",                     /* 6 */\n    \"Data\",                     /* 7 */\n    \"CreatePermission\",         /* 8 */\n    \"ChannelBind\",              /* 9 */\n    \"Connect\",                  /* 10 */\n    \"ConnectionBind\",           /* 11 */\n    \"ConnectionAttempt\",        /* 12 */\n};\n\nstatic struct\n{\n    int err_code;\n    const char *err_msg;\n} stun_err_msg_map[] = \n{\n    { PJ_STUN_SC_TRY_ALTERNATE,             \"Try Alternate\"}, \n    { PJ_STUN_SC_BAD_REQUEST,               \"Bad Request\"},\n    { PJ_STUN_SC_UNAUTHORIZED,              \"Unauthorized\"},\n    { PJ_STUN_SC_FORBIDDEN,                 \"Forbidden\"},\n    { PJ_STUN_SC_UNKNOWN_ATTRIBUTE,         \"Unknown Attribute\"},\n    //{ PJ_STUN_SC_STALE_CREDENTIALS,       \"Stale Credentials\"},\n    //{ PJ_STUN_SC_INTEGRITY_CHECK_FAILURE, \"Integrity Check Failure\"},\n    //{ PJ_STUN_SC_MISSING_USERNAME,        \"Missing Username\"},\n    //{ PJ_STUN_SC_USE_TLS,                 \"Use TLS\"},\n    //{ PJ_STUN_SC_MISSING_REALM,           \"Missing Realm\"},\n    //{ PJ_STUN_SC_MISSING_NONCE,           \"Missing Nonce\"},\n    //{ PJ_STUN_SC_UNKNOWN_USERNAME,        \"Unknown Username\"},\n    { PJ_STUN_SC_ALLOCATION_MISMATCH,       \"Allocation Mismatch\"},\n    { PJ_STUN_SC_STALE_NONCE,               \"Stale Nonce\"},\n    { PJ_STUN_SC_TRANSITIONING,             \"Active Destination Already Set\"},\n    { PJ_STUN_SC_WRONG_CREDENTIALS,         \"Wrong Credentials\"},\n    { PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO,    \"Unsupported Transport Protocol\"},\n    { PJ_STUN_SC_OPER_TCP_ONLY,             \"Operation for TCP Only\"},\n    { PJ_STUN_SC_CONNECTION_FAILURE,        \"Connection Failure\"},\n    { PJ_STUN_SC_CONNECTION_TIMEOUT,        \"Connection Timeout\"},\n    { PJ_STUN_SC_ALLOCATION_QUOTA_REACHED,  \"Allocation Quota Reached\"},\n    { PJ_STUN_SC_ROLE_CONFLICT,             \"Role Conflict\"},\n    { PJ_STUN_SC_SERVER_ERROR,              \"Server Error\"},\n    { PJ_STUN_SC_INSUFFICIENT_CAPACITY,     \"Insufficient Capacity\"},\n    { PJ_STUN_SC_GLOBAL_FAILURE,            \"Global Failure\"}\n};\n\n\n\nstruct attr_desc\n{\n    const char   *name;\n    pj_status_t (*decode_attr)(pj_pool_t *pool, const pj_uint8_t *buf, \n                               const pj_stun_msg_hdr *msghdr, void **p_attr);\n    pj_status_t (*encode_attr)(const void *a, pj_uint8_t *buf, \n                               unsigned len, const pj_stun_msg_hdr *msghdr,\n                               unsigned *printed);\n    void*       (*clone_attr)(pj_pool_t *pool, const void *src);\n};\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        void **p_attr);\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr);\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed);\nstatic void*       clone_sockaddr_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_string_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_msgint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_errcode_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_unknown_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr);\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed);\nstatic void*       clone_uint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_uint64_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_binary_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr, \n                                     void **p_attr);\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed);\nstatic void*       clone_empty_attr(pj_pool_t *pool, const void *src);\n\nstatic struct attr_desc mandatory_attr_desc[] = \n{\n    {\n        /* type zero */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAPPED_ADDR, */\n        \"MAPPED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESPONSE_ADDR, */\n        \"RESPONSE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGE_REQUEST, */\n        \"CHANGE-REQUEST\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_SOURCE_ADDR, */\n        \"SOURCE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGED_ADDR, */\n        \"CHANGED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USERNAME, */\n        \"USERNAME\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PASSWORD, */\n        \"PASSWORD\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_MESSAGE_INTEGRITY, */\n        \"MESSAGE-INTEGRITY\",\n        &decode_msgint_attr,\n        &encode_msgint_attr,\n        &clone_msgint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ERROR_CODE, */\n        \"ERROR-CODE\",\n        &decode_errcode_attr,\n        &encode_errcode_attr,\n        &clone_errcode_attr\n    },\n    {\n        /* PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, */\n        \"UNKNOWN-ATTRIBUTES\",\n        &decode_unknown_attr,\n        &encode_unknown_attr,\n        &clone_unknown_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFLECTED_FROM, */\n        \"REFLECTED-FROM\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANNEL_NUMBER (0x000C) */\n        \"CHANNEL-NUMBER\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_LIFETIME, */\n        \"LIFETIME\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x000E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAGIC_COOKIE */\n        \"MAGIC-COOKIE\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_BANDWIDTH, */\n        \"BANDWIDTH\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x0011 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_PEER_ADDRESS, */\n        \"XOR-PEER-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DATA, */\n        \"DATA\",\n        &decode_binary_attr,\n        &encode_binary_attr,\n        &clone_binary_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REALM, */\n        \"REALM\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_NONCE, */\n        \"NONCE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_RELAYED_ADDR, */\n        \"XOR-RELAYED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_ADDR_FAMILY, */\n        \"REQUESTED-ADDRESS-FAMILY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_EVEN_PORT, */\n        \"EVEN-PORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_TRANSPORT, */\n        \"REQUESTED-TRANSPORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DONT_FRAGMENT */\n        \"DONT-FRAGMENT\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x001B is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001C is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001D is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001F is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_MAPPED_ADDRESS, */\n        \"XOR-MAPPED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_TIMER_VAL, */\n        \"TIMER-VAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESERVATION_TOKEN, */\n        \"RESERVATION-TOKEN\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_REFLECTED_FROM, */\n        \"XOR-REFLECTED-FROM\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PRIORITY, */\n        \"PRIORITY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USE_CANDIDATE, */\n        \"USE-CANDIDATE\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x0026 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0027 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0028 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0029 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_CONNECTION_ID, */\n        \"CONNECTION-ID\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x002b is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002c is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002d is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002e is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002f is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_ICMP, */\n        \"ICMP\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n\n    /* Sentinel */\n    {\n        /* PJ_STUN_ATTR_END_MANDATORY_ATTR */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    }\n};\n\nstatic struct attr_desc extended_attr_desc[] =\n{\n    {\n        /* ID 0x8021 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_SOFTWARE, */\n        \"SOFTWARE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ALTERNATE_SERVER, */\n        \"ALTERNATE-SERVER\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFRESH_INTERVAL, */\n        \"REFRESH-INTERVAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x8025 is not assigned*/\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PADDING, 0x8026 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* CACHE-TIMEOUT, 0x8027 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_FINGERPRINT, */\n        \"FINGERPRINT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLED, */\n        \"ICE-CONTROLLED\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLING, */\n        \"ICE-CONTROLLING\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    }\n};\n\n\n\n/*\n * Get STUN message type name.\n */\nPJ_DEF(const char*) pj_stun_get_method_name(unsigned msg_type)\n{\n    unsigned method = PJ_STUN_GET_METHOD(msg_type);\n\n    if (method >= PJ_ARRAY_SIZE(stun_method_names))\n        return \"???\";\n\n    return stun_method_names[method];\n}\n\n\n/*\n * Get STUN message class name.\n */\nPJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type)\n{\n    if (PJ_STUN_IS_REQUEST(msg_type))\n        return \"request\";\n    else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type))\n        return \"success response\";\n    else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type))\n        return \"error response\";\n    else if (PJ_STUN_IS_INDICATION(msg_type))\n        return \"indication\";\n    else\n        return \"???\";\n}\n\n\nstatic const struct attr_desc *find_attr_desc(unsigned attr_type)\n{\n    struct attr_desc *desc;\n\n    /* Check that attr_desc array is valid */\n    pj_assert(PJ_ARRAY_SIZE(mandatory_attr_desc)==\n              PJ_STUN_ATTR_END_MANDATORY_ATTR+1);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_END_MANDATORY_ATTR].decode_attr\n              == NULL);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_USE_CANDIDATE].decode_attr \n              == &decode_empty_attr);\n    pj_assert(PJ_ARRAY_SIZE(extended_attr_desc) ==\n              PJ_STUN_ATTR_END_EXTENDED_ATTR-PJ_STUN_ATTR_START_EXTENDED_ATTR);\n\n    if (attr_type < PJ_STUN_ATTR_END_MANDATORY_ATTR)\n        desc = &mandatory_attr_desc[attr_type];\n    else if (attr_type >= PJ_STUN_ATTR_START_EXTENDED_ATTR &&\n             attr_type < PJ_STUN_ATTR_END_EXTENDED_ATTR)\n        desc = &extended_attr_desc[attr_type-PJ_STUN_ATTR_START_EXTENDED_ATTR];\n    else\n        return NULL;\n\n    return desc->decode_attr == NULL ? NULL : desc;\n}\n\n\n/*\n * Get STUN attribute name.\n */\nPJ_DEF(const char*) pj_stun_get_attr_name(unsigned attr_type)\n{\n    const struct attr_desc *attr_desc;\n\n    attr_desc = find_attr_desc(attr_type);\n    if (!attr_desc || attr_desc->name==NULL)\n        return \"???\";\n\n    return attr_desc->name;\n}\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n */\nPJ_DEF(pj_str_t) pj_stun_get_err_reason(int err_code)\n{\n#if 0\n    /* Find error using linear search */\n    unsigned i;\n\n    for (i=0; i<PJ_ARRAY_SIZE(stun_err_msg_map); ++i) {\n        if (stun_err_msg_map[i].err_code == err_code)\n            return pj_str((char*)stun_err_msg_map[i].err_msg);\n    }\n    return pj_str(NULL);\n#else\n    /* Find error message using binary search */\n    int first = 0;\n    int n = PJ_ARRAY_SIZE(stun_err_msg_map);\n\n    while (n > 0) {\n        int half = n/2;\n        int mid = first + half;\n\n        if (stun_err_msg_map[mid].err_code < err_code) {\n            first = mid+1;\n            n -= (half+1);\n        } else if (stun_err_msg_map[mid].err_code > err_code) {\n            n = half;\n        } else {\n            first = mid;\n            break;\n        }\n    }\n\n\n    if (stun_err_msg_map[first].err_code == err_code) {\n        return pj_str((char*)stun_err_msg_map[first].err_msg);\n    } else {\n        return pj_str(NULL);\n    }\n#endif\n}\n\n\n/*\n * Set padding character.\n */\nPJ_DEF(int) pj_stun_set_padding_char(int chr)\n{\n    int old_pad = padding_char;\n    padding_char = chr;\n    return old_pad;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n\n#define INIT_ATTR(a,t,l)    (a)->hdr.type=(pj_uint16_t)(t), \\\n                            (a)->hdr.length=(pj_uint16_t)(l)\n#define ATTR_HDR_LEN        sizeof(pj_stun_attr_hdr)\n\nstatic pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint16_t) (((pj_uint16_t)buf[pos + 0] << 8) | \\\n                          ((pj_uint16_t)buf[pos + 1] << 0));\n}\n\n/*unused PJ_INLINE(pj_uint16_t) GETVAL16N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htons(GETVAL16H(buf,pos));\n}*/\n\nstatic void PUTVAL16H(pj_uint8_t *buf, unsigned pos, pj_uint16_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF00) >> 8);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF) >> 0);\n}\n\nPJ_INLINE(pj_uint32_t) GETVAL32H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint32_t) (((pj_uint32_t)buf[pos + 0] << 24UL) | \\\n                          ((pj_uint32_t)buf[pos + 1] << 16UL) | \\\n                          ((pj_uint32_t)buf[pos + 2] <<  8UL) | \\\n                          ((pj_uint32_t)buf[pos + 3] <<  0UL));\n}\n\n/*unused PJ_INLINE(pj_uint32_t) GETVAL32N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htonl(GETVAL32H(buf,pos));\n}*/\n\nstatic void PUTVAL32H(pj_uint8_t *buf, unsigned pos, pj_uint32_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF000000UL) >> 24);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF0000UL) >> 16);\n    buf[pos+2] = (pj_uint8_t) ((hval & 0x0000FF00UL) >>  8);\n    buf[pos+3] = (pj_uint8_t) ((hval & 0x000000FFUL) >>  0);\n}\n\nstatic void GETVAL64H(const pj_uint8_t *buf, unsigned pos, pj_timestamp *ts)\n{\n    ts->u32.hi = GETVAL32H(buf, pos);\n    ts->u32.lo = GETVAL32H(buf, pos+4);\n}\n\nstatic void PUTVAL64H(pj_uint8_t *buf, unsigned pos, const pj_timestamp *ts)\n{\n    PUTVAL32H(buf, pos, ts->u32.hi);\n    PUTVAL32H(buf, pos+4, ts->u32.lo);\n}\n\n\nstatic void GETATTRHDR(const pj_uint8_t *buf, pj_stun_attr_hdr *hdr)\n{\n    hdr->type = GETVAL16H(buf, 0);\n    hdr->length = GETVAL16H(buf, 2);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic IP address container\n */\n#define STUN_GENERIC_IPV4_ADDR_LEN      8\n#define STUN_GENERIC_IPV6_ADDR_LEN      20\n\n/*\n * Init sockaddr attr\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_init( pj_stun_sockaddr_attr *attr,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len)\n{\n    unsigned attr_len;\n\n    PJ_ASSERT_RETURN(attr && addr_len && addr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(addr_len == sizeof(pj_sockaddr_in) ||\n                     addr_len == sizeof(pj_sockaddr_in6), PJ_EINVAL);\n\n    attr_len = pj_sockaddr_get_addr_len(addr) + 4;\n    INIT_ATTR(attr, attr_type, attr_len);\n\n    pj_memcpy(&attr->sockaddr, addr, addr_len);\n    attr->xor_ed = xor_ed;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a generic STUN IP address attribute for IPv4 address.\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n                                                 int attr_type,\n                                                 pj_bool_t xor_ed,\n                                                 const pj_sockaddr_t *addr,\n                                                 unsigned addr_len,\n                                                 pj_stun_sockaddr_attr **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    *p_attr = attr;\n    return pj_stun_sockaddr_attr_init(attr, attr_type, xor_ed, \n                                      addr, addr_len);\n}\n\n\n/*\n * Create and add generic STUN IP address attribute to a STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type, \n                                                  pj_bool_t xor_ed,\n                                                  const pj_sockaddr_t *addr,\n                                                  unsigned addr_len)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = pj_stun_sockaddr_attr_create(pool, attr_type, xor_ed,\n                                                 addr, addr_len, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr, \n                                        void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    int af;\n    unsigned addr_len;\n    pj_uint32_t val;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN &&\n        attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n    {\n        return PJNATH_ESTUNINATTRLEN;\n    }\n\n    /* Check address family */\n    val = *(pj_uint8_t*)(buf + ATTR_HDR_LEN + 1);\n\n    /* Check address family is valid */\n    if (val == 1) {\n        if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET();\n        addr_len = 4;\n    } else if (val == 2) {\n        if (attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET6();\n        addr_len = 16;\n    } else {\n        /* Invalid address family */\n        return PJNATH_EINVAF;\n    }\n\n    /* Get port and address */\n    pj_sockaddr_init(af, &attr->sockaddr, NULL, 0);\n    pj_sockaddr_set_port(&attr->sockaddr, \n                         GETVAL16H(buf, ATTR_HDR_LEN+2));\n    pj_memcpy(pj_sockaddr_get_addr(&attr->sockaddr),\n              buf+ATTR_HDR_LEN+4,\n              addr_len);\n\n    /* Done */\n    *p_attr = (void*)attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = decode_sockaddr_attr(pool, buf, msghdr, p_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    attr = *(pj_stun_sockaddr_attr**)p_attr;\n\n    attr->xor_ed = PJ_TRUE;\n\n    if (attr->sockaddr.addr.sa_family == pj_AF_INET()) {\n        attr->sockaddr.ipv4.sin_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n        attr->sockaddr.ipv4.sin_addr.s_addr ^= pj_htonl(PJ_STUN_MAGIC);\n    } else if (attr->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        unsigned i;\n        pj_uint8_t *dst = (pj_uint8_t*) &attr->sockaddr.ipv6.sin6_addr;\n        pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\n        attr->sockaddr.ipv6.sin6_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\n        /* If the IP address family is IPv6, X-Address is computed by\n         * taking the mapped IP address in host byte order, XOR'ing it\n         * with the concatenation of the magic cookie and the 96-bit \n         * transaction ID, and converting the result to network byte \n         * order.\n         */\n        for (i=0; i<4; ++i) {\n            dst[i] ^= ((const pj_uint8_t*)&magic)[i];\n        }\n        pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n        for (i=0; i<12; ++i) {\n            dst[i+4] ^= msghdr->tsx_id[i];\n        }\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed)\n{\n    pj_uint8_t *start_buf = buf;\n    const pj_stun_sockaddr_attr *ca = \n        (const pj_stun_sockaddr_attr *)a;\n\n    PJ_CHECK_STACK();\n    \n    /* Common: attribute type */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    if (ca->sockaddr.addr.sa_family == pj_AF_INET()) {\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV4_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV4_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 1 for IPv4 */\n        *buf++ = 1;\n\n        /* IPv4 address */\n        if (ca->xor_ed) {\n            pj_uint32_t addr;\n            pj_uint16_t port;\n\n            addr = ca->sockaddr.ipv4.sin_addr.s_addr;\n            port = ca->sockaddr.ipv4.sin_port;\n\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            addr ^= pj_htonl(PJ_STUN_MAGIC);\n\n            /* Port */\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &addr, 4);\n            buf += 4;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_addr, 4);\n            buf += 4;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else if (ca->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        /* IPv6 address */\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV6_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV6_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 2 for IPv6 */\n        *buf++ = 2;\n\n        /* IPv6 address */\n        if (ca->xor_ed) {\n            unsigned i;\n            pj_uint8_t *dst;\n            const pj_uint8_t *src;\n            pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n            pj_uint16_t port = ca->sockaddr.ipv6.sin6_port;\n\n            /* Port */\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            dst = buf;\n            src = (const pj_uint8_t*) &ca->sockaddr.ipv6.sin6_addr;\n            for (i=0; i<4; ++i) {\n                dst[i] = (pj_uint8_t)(src[i] ^ ((const pj_uint8_t*)&magic)[i]);\n            }\n            pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n            for (i=0; i<12; ++i) {\n                dst[i+4] = (pj_uint8_t)(src[i+4] ^ msghdr->tsx_id[i]);\n            }\n\n            buf += 16;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_addr, 16);\n            buf += 16;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *printed = (unsigned)(buf - start_buf);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_sockaddr_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_sockaddr_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_sockaddr_attr);\n    pj_memcpy(dst, src, sizeof(pj_stun_sockaddr_attr));\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic string attribute\n */\n\n/*\n * Initialize a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_init( pj_stun_string_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_str_t *value)\n{\n    if (value && value->slen) {\n        INIT_ATTR(attr, attr_type, value->slen);\n        attr->value.slen = value->slen;\n        pj_strdup(pool, &attr->value, value);\n    } else {\n        INIT_ATTR(attr, attr_type, 0);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_str_t *value,\n                                               pj_stun_string_attr **p_attr)\n{\n    pj_stun_string_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && value && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    *p_attr = attr;\n\n    return pj_stun_string_attr_init(attr, pool, attr_type, value);\n}\n\n\n/*\n * Create and add STUN generic string attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_str_t *value)\n{\n    pj_stun_string_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_string_attr_create(pool, attr_type, value, \n                                                &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_string_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN);\n    value.slen = attr->hdr.length;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->value, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_string_attr *ca = \n        (const pj_stun_string_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = ((unsigned)ca->value.slen + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed) {\n        *printed = 0;\n        return PJ_ETOOSMALL;\n    }\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    /* Special treatment for SOFTWARE attribute:\n     * This attribute had caused interop problem when talking to \n     * legacy RFC 3489 STUN servers, due to different \"length\"\n     * rules with RFC 5389.\n     */\n    if (msghdr->magic != PJ_STUN_MAGIC ||\n        ca->hdr.type == PJ_STUN_ATTR_SOFTWARE)\n    {\n        /* Set the length to be 4-bytes aligned so that we can\n         * communicate with RFC 3489 endpoints\n         */\n        PUTVAL16H(buf, 2, (pj_uint16_t)((ca->value.slen + 3) & (~3)));\n    } else {\n        /* Use RFC 5389 rule */\n        PUTVAL16H(buf, 2, (pj_uint16_t)ca->value.slen);\n    }\n\n    /* Copy the string */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->value.ptr, ca->value.slen);\n\n    /* Add padding character, if string is not 4-bytes aligned. */\n    if (ca->value.slen & 0x03) {\n        pj_uint8_t pad[3];\n        pj_memset(pad, padding_char, sizeof(pad));\n        pj_memcpy(buf+ATTR_HDR_LEN+ca->value.slen, pad,\n                  4-(ca->value.slen & 0x03));\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_string_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_string_attr *asrc = (const pj_stun_string_attr*)src;\n    pj_stun_string_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_string_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_attr_hdr));\n    pj_strdup(pool, &dst->value, &asrc->value);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN empty attribute (used by USE-CANDIDATE).\n */\n\n/*\n * Create a STUN empty attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n                                              int attr_type,\n                                              pj_stun_empty_attr **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    INIT_ATTR(attr, attr_type, 0);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create STUN empty attribute and add the attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_empty_attr( pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type)\n{\n    pj_stun_empty_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_empty_attr_create(pool, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     void **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that the struct address is valid */\n    pj_assert(sizeof(pj_stun_empty_attr) == ATTR_HDR_LEN);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 0)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed)\n{\n    const pj_stun_empty_attr *ca = (pj_stun_empty_attr*)a;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, 0);\n\n    /* Done */\n    *printed = ATTR_HDR_LEN;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_empty_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_empty_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_empty_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_empty_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic 32bit integer attribute.\n */\n\n/*\n * Create a STUN generic 32bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n                                             int attr_type,\n                                             pj_uint32_t value,\n                                             pj_stun_uint_attr **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    INIT_ATTR(attr, attr_type, 4);\n    attr->value = value;\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 32bit value attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n                                              pj_stun_msg *msg,\n                                              int attr_type,\n                                              pj_uint32_t value)\n{\n    pj_stun_uint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed)\n{\n    const pj_stun_uint_attr *ca = (const pj_stun_uint_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 8) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)4);\n    PUTVAL32H(buf, 4, ca->value);\n    \n    /* Done */\n    *printed = 8;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint_attr));\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Create a STUN generic 64bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint64_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_timestamp *value,\n                                               pj_stun_uint64_attr **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    INIT_ATTR(attr, attr_type, 8);\n\n    if (value) {\n        attr->value.u32.hi = value->u32.hi;\n        attr->value.u32.lo = value->u32.lo;\n    }\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 64bit value attribute to the message. */\nPJ_DEF(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_timestamp *value)\n{\n    pj_stun_uint64_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint64_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    if (attr->hdr.length != 8)\n        return PJNATH_ESTUNINATTRLEN;\n\n    GETVAL64H(buf, 4, &attr->value);    \n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_uint64_attr *ca = (const pj_stun_uint64_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 12) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)8);\n    PUTVAL64H(buf, 4, &ca->value);\n\n    /* Done */\n    *printed = 12;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint64_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint64_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint64_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint64_attr));\n\n    return (void*)dst;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN MESSAGE-INTEGRITY attribute.\n */\n\n/*\n * Create a STUN MESSAGE-INTEGRITY attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n                                               pj_stun_msgint_attr **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_MESSAGE_INTEGRITY, 20);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg)\n{\n    pj_stun_msgint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_msgint_attr_create(pool, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 20)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Copy hmac */\n    pj_memcpy(attr->hmac, buf+4, 20);\n\n    /* Done */\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_msgint_attr *ca = (const pj_stun_msgint_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < 24) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, ca->hdr.length);\n\n    pj_memcpy(buf+4, ca->hmac, 20);\n\n    /* Done */\n    *printed = 24;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_msgint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_msgint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_msgint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_msgint_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN ERROR-CODE\n */\n\n/*\n * Create a STUN ERROR-CODE attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n                                                int err_code,\n                                                const pj_str_t *err_reason,\n                                                pj_stun_errcode_attr **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    char err_buf[80];\n    pj_str_t str;\n\n    PJ_ASSERT_RETURN(pool && err_code && p_attr, PJ_EINVAL);\n\n    if (err_reason == NULL) {\n        str = pj_stun_get_err_reason(err_code);\n        if (str.slen == 0) {\n            str.slen = pj_ansi_snprintf(err_buf, sizeof(err_buf),\n                                        \"Unknown error %d\", err_code);\n            str.ptr = err_buf;\n        }\n        err_reason = &str;\n    }\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_ERROR_CODE, 4+err_reason->slen);\n    attr->err_code = err_code;\n    pj_strdup(pool, &attr->reason, err_reason);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int err_code,\n                                                 const pj_str_t *err_reason)\n{\n    pj_stun_errcode_attr *err_attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_errcode_attr_create(pool, err_code, err_reason,\n                                         &err_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &err_attr->hdr);\n}\n\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    /* Make sure the length is never negative */\n    if (value.slen < 0)\n        value.slen = 0;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_errcode_attr *ca = \n        (const pj_stun_errcode_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(4 + ca->reason.slen));\n    PUTVAL16H(buf, 4, 0);\n    buf[6] = (pj_uint8_t)(ca->err_code / 100);\n    buf[7] = (pj_uint8_t)(ca->err_code % 100);\n\n    /* Copy error string */\n    pj_memcpy(buf + ATTR_HDR_LEN + 4, ca->reason.ptr, ca->reason.slen);\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_errcode_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_errcode_attr *asrc = (const pj_stun_errcode_attr*)src;\n    pj_stun_errcode_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_errcode_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_errcode_attr));\n    pj_strdup(pool, &dst->reason, &asrc->reason);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN UNKNOWN-ATTRIBUTES attribute\n */\n\n/*\n * Create an empty instance of STUN UNKNOWN-ATTRIBUTES attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n                                                unsigned attr_cnt,\n                                                const pj_uint16_t attr_array[],\n                                                pj_stun_unknown_attr **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && attr_cnt < PJ_STUN_MAX_ATTR && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, attr_cnt * 2);\n\n    attr->attr_count = attr_cnt;\n    for (i=0; i<attr_cnt; ++i) {\n        attr->attrs[i] = attr_array[i];\n    }\n\n    /* If the number of unknown attributes is an odd number, one of the\n     * attributes MUST be repeated in the list.\n     */\n    /* No longer necessary\n    if ((attr_cnt & 0x01)) {\n        attr->attrs[attr_cnt] = attr_array[attr_cnt-1];\n    }\n    */\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 unsigned attr_cnt,\n                                                 const pj_uint16_t attr_type[])\n{\n    pj_stun_unknown_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_unknown_attr_create(pool, attr_cnt, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    const pj_uint16_t *punk_attr;\n    unsigned i;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    GETATTRHDR(buf, &attr->hdr);\n \n    attr->attr_count = (attr->hdr.length >> 1);\n    if (attr->attr_count > PJ_STUN_MAX_ATTR)\n        return PJ_ETOOMANY;\n\n    punk_attr = (const pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i<attr->attr_count; ++i) {\n        attr->attrs[i] = pj_ntohs(punk_attr[i]);\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_unknown_attr *ca = (const pj_stun_unknown_attr*) a;\n    pj_uint16_t *dst_unk_attr;\n    unsigned i;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that buffer is enough */\n    if (len < ATTR_HDR_LEN + (ca->attr_count << 1))\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(ca->attr_count << 1));\n\n    /* Copy individual attribute */\n    dst_unk_attr = (pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i < ca->attr_count; ++i, ++dst_unk_attr) {\n        *dst_unk_attr = pj_htons(ca->attrs[i]);\n    }\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + (ca->attr_count << 1) + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_unknown_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_unknown_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_unknown_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_unknown_attr));\n    \n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic binary attribute\n */\n\n/*\n * Initialize STUN binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_init( pj_stun_binary_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_uint8_t *data,\n                                              unsigned length)\n{\n    PJ_ASSERT_RETURN(attr_type, PJ_EINVAL);\n\n    INIT_ATTR(attr, attr_type, length);\n\n    attr->magic = PJ_STUN_MAGIC;\n\n    if (data && length) {\n        attr->length = length;\n        attr->data = (pj_uint8_t*) pj_pool_alloc(pool, length);\n        pj_memcpy(attr->data, data, length);\n    } else {\n        attr->data = NULL;\n        attr->length = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_uint8_t *data,\n                                               unsigned length,\n                                               pj_stun_binary_attr **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && attr_type && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    *p_attr = attr;\n    return pj_stun_binary_attr_init(attr, pool, attr_type, data, length);\n}\n\n\n/* Create and add binary attr. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_uint8_t *data,\n                                                unsigned length)\n{\n    pj_stun_binary_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_binary_attr_create(pool, attr_type,\n                                        data, length, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr,\n                                      void **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Copy the data to the attribute */\n    attr->length = attr->hdr.length;\n    attr->data = (pj_uint8_t*) pj_pool_alloc(pool, attr->length);\n    pj_memcpy(attr->data, buf+ATTR_HDR_LEN, attr->length);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_binary_attr *ca = (const pj_stun_binary_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = (ca->length + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed)\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t) ca->length);\n\n    /* Copy the data */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->data, ca->length);\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_binary_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_binary_attr *asrc = (const pj_stun_binary_attr*)src;\n    pj_stun_binary_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_binary_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_binary_attr));\n\n    if (asrc->length) {\n        dst->data = (pj_uint8_t*) pj_pool_alloc(pool, asrc->length);\n        pj_memcpy(dst->data, asrc->data, asrc->length);\n    }\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Initialize a generic STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_init( pj_stun_msg *msg,\n                                      unsigned msg_type,\n                                      pj_uint32_t magic,\n                                      const pj_uint8_t tsx_id[12])\n{\n    PJ_ASSERT_RETURN(msg && msg_type, PJ_EINVAL);\n\n    msg->hdr.type = (pj_uint16_t) msg_type;\n    msg->hdr.length = 0;\n    msg->hdr.magic = magic;\n    msg->attr_count = 0;\n\n    if (tsx_id) {\n        pj_memcpy(&msg->hdr.tsx_id, tsx_id, sizeof(msg->hdr.tsx_id));\n    } else {\n        struct transaction_id\n        {\n            pj_uint32_t     proc_id;\n            pj_uint32_t     random;\n            pj_uint32_t     counter;\n        } id;\n        static pj_uint32_t pj_stun_tsx_id_counter;\n\n        if (!pj_stun_tsx_id_counter)\n            pj_stun_tsx_id_counter = pj_rand();\n\n        id.proc_id = pj_getpid();\n        id.random = pj_rand();\n        id.counter = pj_stun_tsx_id_counter++;\n\n        pj_memcpy(&msg->hdr.tsx_id, &id, sizeof(msg->hdr.tsx_id));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_create( pj_pool_t *pool,\n                                        unsigned msg_type,\n                                        pj_uint32_t magic,\n                                        const pj_uint8_t tsx_id[12],\n                                        pj_stun_msg **p_msg)\n{\n    pj_stun_msg *msg;\n\n    PJ_ASSERT_RETURN(pool && msg_type && p_msg, PJ_EINVAL);\n\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    *p_msg = msg;\n    return pj_stun_msg_init(msg, msg_type, magic, tsx_id);\n}\n\n\n/*\n * Clone a STUN message with all of its attributes.\n */\nPJ_DEF(pj_stun_msg*) pj_stun_msg_clone( pj_pool_t *pool,\n                                        const pj_stun_msg *src)\n{\n    pj_stun_msg *dst;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && src, NULL);\n\n    dst = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(dst, src, sizeof(pj_stun_msg));\n\n    /* Duplicate the attributes */\n    for (i=0, dst->attr_count=0; i<src->attr_count; ++i) {\n        dst->attr[dst->attr_count] = pj_stun_attr_clone(pool, src->attr[i]);\n        if (dst->attr[dst->attr_count])\n            ++dst->attr_count;\n    }\n\n    return dst;\n}\n\n\n/*\n * Add STUN attribute to STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n                                         pj_stun_attr_hdr *attr)\n{\n    PJ_ASSERT_RETURN(msg && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->attr_count < PJ_STUN_MAX_ATTR, PJ_ETOOMANY);\n\n    msg->attr[msg->attr_count++] = attr;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check that the PDU is potentially a valid STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, pj_size_t pdu_len,\n                                      unsigned options)\n{\n    pj_uint32_t msg_len;\n\n    PJ_ASSERT_RETURN(pdu, PJ_EINVAL);\n\n    if (pdu_len < sizeof(pj_stun_msg_hdr))\n        return PJNATH_EINSTUNMSGLEN;\n\n    /* First byte of STUN message is always 0x00 or 0x01. */\n    if (*pdu != 0x00 && *pdu != 0x01)\n        return PJNATH_EINSTUNMSGTYPE;\n\n    /* Check the PDU length */\n    msg_len = GETVAL16H(pdu, 2);\n    if ((msg_len + 20 > pdu_len) || \n        ((options & PJ_STUN_IS_DATAGRAM) && msg_len + 20 != pdu_len))\n    {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* STUN message is always padded to the nearest 4 bytes, thus\n     * the last two bits of the length field are always zero.\n     */\n    if ((msg_len & 0x03) != 0) {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* If magic is set, then there is great possibility that this is\n     * a STUN message.\n     */\n    if (GETVAL32H(pdu, 4) == PJ_STUN_MAGIC) {\n\n        /* Check if FINGERPRINT attribute is present */\n        if ((options & PJ_STUN_NO_FINGERPRINT_CHECK )==0 && \n            GETVAL16H(pdu, msg_len + 20 - 8) == PJ_STUN_ATTR_FINGERPRINT) \n        {\n            pj_uint16_t attr_len = GETVAL16H(pdu, msg_len + 20 - 8 + 2);\n            pj_uint32_t fingerprint = GETVAL32H(pdu, msg_len + 20 - 8 + 4);\n            pj_uint32_t crc;\n\n            if (attr_len != 4)\n                return PJNATH_ESTUNINATTRLEN;\n\n            crc = pj_crc32_calc(pdu, msg_len + 20 - 8);\n            crc ^= STUN_XOR_FINGERPRINT;\n\n            if (crc != fingerprint)\n                return PJNATH_ESTUNFINGERPRINT;\n        }\n    }\n\n    /* Could be a STUN message */\n    return PJ_SUCCESS;\n}\n\n\n/* Create error response */\nPJ_DEF(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n                                                const pj_stun_msg *req_msg,\n                                                unsigned err_code,\n                                                const pj_str_t *err_msg,\n                                                pj_stun_msg **p_response)\n{\n    unsigned msg_type = req_msg->hdr.type;\n    pj_stun_msg *response = NULL;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_response, PJ_EINVAL);\n\n    PJ_ASSERT_RETURN(PJ_STUN_IS_REQUEST(msg_type), \n                     PJNATH_EINSTUNMSGTYPE);\n\n    /* Create response or error response */\n    if (err_code)\n        msg_type |= PJ_STUN_ERROR_RESPONSE_BIT;\n    else\n        msg_type |= PJ_STUN_SUCCESS_RESPONSE_BIT;\n\n    status = pj_stun_msg_create(pool, msg_type, req_msg->hdr.magic, \n                                req_msg->hdr.tsx_id, &response);\n    if (status != PJ_SUCCESS) {\n        return status;\n    }\n\n    /* Add error code attribute */\n    if (err_code) {\n        status = pj_stun_msg_add_errcode_attr(pool, response, \n                                              err_code, err_msg);\n        if (status != PJ_SUCCESS) {\n            return status;\n        }\n    }\n\n    *p_response = response;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse incoming packet into STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                       const pj_uint8_t *pdu,\n                                       pj_size_t pdu_len,\n                                       unsigned options,\n                                       pj_stun_msg **p_msg,\n                                       pj_size_t *p_parsed_len,\n                                       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n        *p_parsed_len = 0;\n    if (p_response)\n        *p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n        status = pj_stun_msg_check(pdu, pdu_len, options);\n        if (status != PJ_SUCCESS)\n            return status;\n    } else {\n        /* For safety, verify packet length at least */\n        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;\n        if (msg_len > pdu_len ||\n            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))\n        {\n            return PJNATH_EINSTUNMSGLEN;\n        }\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n        p_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= ATTR_HDR_LEN) {\n        unsigned attr_type, attr_val_len;\n        const struct attr_desc *adesc;\n\n        /* Get attribute type and length. If length is not aligned\n         * to 4 bytes boundary, add padding.\n         */\n        attr_type = GETVAL16H(pdu, 0);\n        attr_val_len = GETVAL16H(pdu, 2);\n        attr_val_len = (attr_val_len + 3) & (~3);\n\n        /* Check length */\n        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {\n            pj_str_t err_msg;\n            char err_msg_buf[80];\n\n            err_msg.ptr = err_msg_buf;\n            err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n                                            \"Attribute %s has invalid length\",\n                                            pj_stun_get_attr_name(attr_type));\n\n            PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n                      (int)err_msg.slen, err_msg.ptr));\n\n            if (p_response) {\n                pj_stun_msg_create_response(pool, msg, \n                                            PJ_STUN_SC_BAD_REQUEST, \n                                            &err_msg, p_response);\n            }\n            return PJNATH_ESTUNINATTRLEN;\n        }\n\n        /* Get the attribute descriptor */\n        adesc = find_attr_desc(attr_type);\n\n        if (adesc == NULL) {\n            /* Unrecognized attribute */\n            pj_stun_binary_attr *attr = NULL;\n\n            PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n                      attr_type));\n\n            /* Is this a fatal condition? */\n            if (attr_type <= 0x7FFF) {\n                /* This is a mandatory attribute, we must return error\n                 * if we don't understand the attribute.\n                 */\n                if (p_response) {\n                    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n                    status = pj_stun_msg_create_response(pool, msg,\n                                                         err_code, NULL, \n                                                         p_response);\n                    if (status==PJ_SUCCESS) {\n                        pj_uint16_t d = (pj_uint16_t)attr_type;\n                        pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n                    }\n                }\n\n                return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Create binary attribute to represent this */\n            status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n                                                GETVAL16H(pdu, 2), &attr);\n            if (status != PJ_SUCCESS) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing unknown STUN attribute type %d\",\n                          attr_type));\n\n                return status;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = &attr->hdr;\n\n        } else {\n            void *attr;\n            char err_msg1[PJ_ERR_MSG_SIZE],\n                 err_msg2[PJ_ERR_MSG_SIZE];\n\n            /* Parse the attribute */\n            status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n            if (status != PJ_SUCCESS) {\n                pj_strerror(status, err_msg1, sizeof(err_msg1));\n\n                if (p_response) {\n                    pj_str_t e;\n\n                    e.ptr = err_msg2;\n                    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n                                             \"%s in %s\",\n                                             err_msg1,\n                                             pj_stun_get_attr_name(attr_type));\n                    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n                        e.slen = sizeof(err_msg2) - 1;\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_BAD_REQUEST,\n                                                &e, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing STUN attribute %s: %s\",\n                          pj_stun_get_attr_name(attr_type), \n                          err_msg1));\n\n                return status;\n            }\n\n            if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n                !has_fingerprint) \n            {\n                if (has_msg_int) {\n                    /* Already has MESSAGE-INTEGRITY */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_msg_int = PJ_TRUE;\n\n            } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n                if (has_fingerprint) {\n                    /* Already has FINGERPRINT */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_fingerprint = PJ_TRUE;\n            } else {\n                if (has_fingerprint) {\n                    /* Another attribute is found which is not FINGERPRINT\n                     * after FINGERPRINT. Note that non-FINGERPRINT is\n                     * allowed to appear after M-I\n                     */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNFINGERPOS;\n                }\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n        }\n\n        /* Next attribute */\n        if (attr_val_len + 4 >= pdu_len) {\n            pdu += pdu_len;\n            pdu_len = 0;\n        } else {\n            pdu += (attr_val_len + 4);\n            pdu_len -= (attr_val_len + 4);\n        }\n    }\n\n    if (pdu_len > 0) {\n        /* Stray trailing bytes */\n        PJ_LOG(4,(THIS_FILE, \n                  \"Error decoding STUN message: unparsed trailing %d bytes\",\n                  pdu_len));\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n        *p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}\n\n/*\nstatic char *print_binary(const pj_uint8_t *data, unsigned data_len)\n{\n    static char static_buffer[1024];\n    char *buffer = static_buffer;\n    unsigned length=sizeof(static_buffer), i;\n\n    if (length < data_len * 2 + 8)\n        return \"\";\n\n    pj_ansi_sprintf(buffer, \", data=\");\n    buffer += 7;\n\n    for (i=0; i<data_len; ++i) {\n        pj_ansi_sprintf(buffer, \"%02x\", (*data) & 0xFF);\n        buffer += 2;\n        data++;\n    }\n\n    pj_ansi_sprintf(buffer, \"\\n\");\n    buffer++;\n\n    return static_buffer;\n}\n*/\n\n/*\n * Print the message structure to a buffer.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n                                       pj_uint8_t *buf, pj_size_t buf_size,\n                                       unsigned options,\n                                       const pj_str_t *key,\n                                       pj_size_t *p_msg_len)\n{\n    pj_uint8_t *start = buf;\n    pj_stun_msgint_attr *amsgint = NULL;\n    pj_stun_fingerprint_attr *afingerprint = NULL;\n    unsigned printed = 0, body_len;\n    pj_status_t status;\n    unsigned i;\n\n\n    PJ_ASSERT_RETURN(msg && buf && buf_size, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(options);\n    PJ_ASSERT_RETURN(options == 0, PJ_EINVAL);\n\n    /* Copy the message header part and convert the header fields to\n     * network byte order\n     */\n    if (buf_size < sizeof(pj_stun_msg_hdr))\n        return PJ_ETOOSMALL;\n    \n    PUTVAL16H(buf, 0, msg->hdr.type);\n    PUTVAL16H(buf, 2, 0);   /* length will be calculated later */\n    PUTVAL32H(buf, 4, msg->hdr.magic);\n    pj_memcpy(buf+8, msg->hdr.tsx_id, sizeof(msg->hdr.tsx_id));\n\n    buf += sizeof(pj_stun_msg_hdr);\n    buf_size -= sizeof(pj_stun_msg_hdr);\n\n    /* Encode each attribute to the message */\n    for (i=0; i<msg->attr_count; ++i) {\n        const struct attr_desc *adesc;\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            pj_assert(amsgint == NULL);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n            /* Stop when encountering MESSAGE-INTEGRITY */\n            break;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n            break;\n        }\n\n        adesc = find_attr_desc(attr_hdr->type);\n        if (adesc) {\n            status = adesc->encode_attr(attr_hdr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        } else {\n            /* This may be a generic attribute */\n            const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*) \n                                                   attr_hdr;\n            PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, PJ_EBUG);\n            status = encode_binary_attr(bin_attr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        }\n\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* We may have stopped printing attribute because we found\n     * MESSAGE-INTEGRITY or FINGERPRINT. Scan the rest of the\n     * attributes.\n     */\n    for ( ++i; i<msg->attr_count; ++i) {\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        /* There mustn't any attribute after FINGERPRINT */\n        PJ_ASSERT_RETURN(afingerprint == NULL, PJNATH_ESTUNFINGERPOS);\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            /* There mustn't be MESSAGE-INTEGRITY before */\n            PJ_ASSERT_RETURN(amsgint == NULL, \n                             PJNATH_ESTUNMSGINTPOS);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n        }\n    }\n\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n    /*\n     * This is the old style MESSAGE-INTEGRITY and FINGERPRINT\n     * calculation, used in rfc3489bis-06 and older.\n     */\n    /* We MUST update the message length in the header NOW before\n     * calculating MESSAGE-INTEGRITY and FINGERPRINT. \n     * Note that length is not including the 20 bytes header.\n      */\n    if (amsgint && afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24 + 8);\n    } else if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else if (afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 8);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#else\n    /* If MESSAGE-INTEGRITY is present, include the M-I attribute\n     * in message length before calculating M-I\n     */\n    if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\n    /* hdr->length = pj_htons(length); */\n    PUTVAL16H(start, 2, (pj_uint16_t)body_len);\n\n    /* Calculate message integrity, if present */\n    if (amsgint != NULL) {\n        pj_hmac_sha1_context ctx;\n\n        /* Key MUST be specified */\n        PJ_ASSERT_RETURN(key, PJ_EINVALIDOP);\n\n        /* MESSAGE-INTEGRITY must be the last attribute in the message, or\n         * the last attribute before FINGERPRINT.\n         */\n        if (msg->attr_count>1 && i < msg->attr_count-2) {\n            /* Should not happen for message generated by us */\n            pj_assert(PJ_FALSE);\n            return PJNATH_ESTUNMSGINTPOS;\n\n        } else if (i == msg->attr_count-2)  {\n            if (msg->attr[i+1]->type != PJ_STUN_ATTR_FINGERPRINT) {\n                /* Should not happen for message generated by us */\n                pj_assert(PJ_FALSE);\n                return PJNATH_ESTUNMSGINTPOS;\n            } else {\n                afingerprint = (pj_stun_fingerprint_attr*) msg->attr[i+1];\n            }\n        }\n\n        /* Calculate HMAC-SHA1 digest, add zero padding to input\n         * if necessary to make the input 64 bytes aligned.\n         */\n        pj_hmac_sha1_init(&ctx, (const pj_uint8_t*)key->ptr, \n                          (unsigned)key->slen);\n        pj_hmac_sha1_update(&ctx, (const pj_uint8_t*)start, \n                            (unsigned)(buf-start));\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        // These are obsoleted in rfc3489bis-08\n        if ((buf-start) & 0x3F) {\n            pj_uint8_t zeroes[64];\n            pj_bzero(zeroes, sizeof(zeroes));\n            pj_hmac_sha1_update(&ctx, zeroes, 64-((buf-start) & 0x3F));\n        }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n        pj_hmac_sha1_final(&ctx, amsgint->hmac);\n\n        /* Put this attribute in the message */\n        status = encode_msgint_attr(amsgint, buf, (unsigned)buf_size, \n                                    &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Calculate FINGERPRINT if present */\n    if (afingerprint != NULL) {\n\n#if !PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        /* Update message length */\n        PUTVAL16H(start, 2, \n                 (pj_uint16_t)(GETVAL16H(start, 2)+8));\n#endif\n\n        afingerprint->value = pj_crc32_calc(start, buf-start);\n        afingerprint->value ^= STUN_XOR_FINGERPRINT;\n\n        /* Put this attribute in the message */\n        status = encode_uint_attr(afingerprint, buf, (unsigned)buf_size, \n                                  &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Update message length. */\n    msg->hdr.length = (pj_uint16_t) ((buf - start) - 20);\n\n    /* Return the length */\n    if (p_msg_len)\n        *p_msg_len = (buf - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_msg_find_attr( const pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 unsigned index)\n{\n    PJ_ASSERT_RETURN(msg, NULL);\n\n    for (; index < msg->attr_count; ++index) {\n        if (msg->attr[index]->type == attr_type)\n            return (pj_stun_attr_hdr*) msg->attr[index];\n    }\n\n    return NULL;\n}\n\n\n/*\n * Clone a STUN attribute.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_attr_clone( pj_pool_t *pool,\n                                              const pj_stun_attr_hdr *attr)\n{\n    const struct attr_desc *adesc;\n\n    /* Get the attribute descriptor */\n    adesc = find_attr_desc(attr->type);\n    if (adesc) {\n        return (pj_stun_attr_hdr*) (*adesc->clone_attr)(pool, attr);\n    } else {\n        /* Clone generic attribute */\n        const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*)\n                                               attr;\n        PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, NULL);\n        if (bin_attr->magic == PJ_STUN_MAGIC) {\n            return (pj_stun_attr_hdr*) clone_binary_attr(pool, attr);\n        } else {\n            return NULL;\n        }\n    }\n}\n\n\n"], "fixing_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjnath/stun_msg.h>\n#include <pjnath/errno.h>\n#include <pjlib-util/crc32.h>\n#include <pjlib-util/hmac_sha1.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n#define THIS_FILE               \"stun_msg.c\"\n#define STUN_XOR_FINGERPRINT    0x5354554eL\n\nstatic int padding_char;\n\nstatic const char *stun_method_names[PJ_STUN_METHOD_MAX] = \n{\n    \"Unknown\",                  /* 0 */\n    \"Binding\",                  /* 1 */\n    \"SharedSecret\",             /* 2 */\n    \"Allocate\",                 /* 3 */\n    \"Refresh\",                  /* 4 */\n    \"???\",                      /* 5 */\n    \"Send\",                     /* 6 */\n    \"Data\",                     /* 7 */\n    \"CreatePermission\",         /* 8 */\n    \"ChannelBind\",              /* 9 */\n    \"Connect\",                  /* 10 */\n    \"ConnectionBind\",           /* 11 */\n    \"ConnectionAttempt\",        /* 12 */\n};\n\nstatic struct\n{\n    int err_code;\n    const char *err_msg;\n} stun_err_msg_map[] = \n{\n    { PJ_STUN_SC_TRY_ALTERNATE,             \"Try Alternate\"}, \n    { PJ_STUN_SC_BAD_REQUEST,               \"Bad Request\"},\n    { PJ_STUN_SC_UNAUTHORIZED,              \"Unauthorized\"},\n    { PJ_STUN_SC_FORBIDDEN,                 \"Forbidden\"},\n    { PJ_STUN_SC_UNKNOWN_ATTRIBUTE,         \"Unknown Attribute\"},\n    //{ PJ_STUN_SC_STALE_CREDENTIALS,       \"Stale Credentials\"},\n    //{ PJ_STUN_SC_INTEGRITY_CHECK_FAILURE, \"Integrity Check Failure\"},\n    //{ PJ_STUN_SC_MISSING_USERNAME,        \"Missing Username\"},\n    //{ PJ_STUN_SC_USE_TLS,                 \"Use TLS\"},\n    //{ PJ_STUN_SC_MISSING_REALM,           \"Missing Realm\"},\n    //{ PJ_STUN_SC_MISSING_NONCE,           \"Missing Nonce\"},\n    //{ PJ_STUN_SC_UNKNOWN_USERNAME,        \"Unknown Username\"},\n    { PJ_STUN_SC_ALLOCATION_MISMATCH,       \"Allocation Mismatch\"},\n    { PJ_STUN_SC_STALE_NONCE,               \"Stale Nonce\"},\n    { PJ_STUN_SC_TRANSITIONING,             \"Active Destination Already Set\"},\n    { PJ_STUN_SC_WRONG_CREDENTIALS,         \"Wrong Credentials\"},\n    { PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO,    \"Unsupported Transport Protocol\"},\n    { PJ_STUN_SC_OPER_TCP_ONLY,             \"Operation for TCP Only\"},\n    { PJ_STUN_SC_CONNECTION_FAILURE,        \"Connection Failure\"},\n    { PJ_STUN_SC_CONNECTION_TIMEOUT,        \"Connection Timeout\"},\n    { PJ_STUN_SC_ALLOCATION_QUOTA_REACHED,  \"Allocation Quota Reached\"},\n    { PJ_STUN_SC_ROLE_CONFLICT,             \"Role Conflict\"},\n    { PJ_STUN_SC_SERVER_ERROR,              \"Server Error\"},\n    { PJ_STUN_SC_INSUFFICIENT_CAPACITY,     \"Insufficient Capacity\"},\n    { PJ_STUN_SC_GLOBAL_FAILURE,            \"Global Failure\"}\n};\n\n\n\nstruct attr_desc\n{\n    const char   *name;\n    pj_status_t (*decode_attr)(pj_pool_t *pool, const pj_uint8_t *buf, \n                               const pj_stun_msg_hdr *msghdr, void **p_attr);\n    pj_status_t (*encode_attr)(const void *a, pj_uint8_t *buf, \n                               unsigned len, const pj_stun_msg_hdr *msghdr,\n                               unsigned *printed);\n    void*       (*clone_attr)(pj_pool_t *pool, const void *src);\n};\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        void **p_attr);\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr);\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed);\nstatic void*       clone_sockaddr_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_string_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_msgint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_errcode_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_unknown_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr);\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed);\nstatic void*       clone_uint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_uint64_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_binary_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr, \n                                     void **p_attr);\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed);\nstatic void*       clone_empty_attr(pj_pool_t *pool, const void *src);\n\nstatic struct attr_desc mandatory_attr_desc[] = \n{\n    {\n        /* type zero */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAPPED_ADDR, */\n        \"MAPPED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESPONSE_ADDR, */\n        \"RESPONSE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGE_REQUEST, */\n        \"CHANGE-REQUEST\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_SOURCE_ADDR, */\n        \"SOURCE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGED_ADDR, */\n        \"CHANGED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USERNAME, */\n        \"USERNAME\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PASSWORD, */\n        \"PASSWORD\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_MESSAGE_INTEGRITY, */\n        \"MESSAGE-INTEGRITY\",\n        &decode_msgint_attr,\n        &encode_msgint_attr,\n        &clone_msgint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ERROR_CODE, */\n        \"ERROR-CODE\",\n        &decode_errcode_attr,\n        &encode_errcode_attr,\n        &clone_errcode_attr\n    },\n    {\n        /* PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, */\n        \"UNKNOWN-ATTRIBUTES\",\n        &decode_unknown_attr,\n        &encode_unknown_attr,\n        &clone_unknown_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFLECTED_FROM, */\n        \"REFLECTED-FROM\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANNEL_NUMBER (0x000C) */\n        \"CHANNEL-NUMBER\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_LIFETIME, */\n        \"LIFETIME\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x000E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAGIC_COOKIE */\n        \"MAGIC-COOKIE\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_BANDWIDTH, */\n        \"BANDWIDTH\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x0011 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_PEER_ADDRESS, */\n        \"XOR-PEER-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DATA, */\n        \"DATA\",\n        &decode_binary_attr,\n        &encode_binary_attr,\n        &clone_binary_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REALM, */\n        \"REALM\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_NONCE, */\n        \"NONCE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_RELAYED_ADDR, */\n        \"XOR-RELAYED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_ADDR_FAMILY, */\n        \"REQUESTED-ADDRESS-FAMILY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_EVEN_PORT, */\n        \"EVEN-PORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_TRANSPORT, */\n        \"REQUESTED-TRANSPORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DONT_FRAGMENT */\n        \"DONT-FRAGMENT\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x001B is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001C is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001D is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001F is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_MAPPED_ADDRESS, */\n        \"XOR-MAPPED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_TIMER_VAL, */\n        \"TIMER-VAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESERVATION_TOKEN, */\n        \"RESERVATION-TOKEN\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_REFLECTED_FROM, */\n        \"XOR-REFLECTED-FROM\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PRIORITY, */\n        \"PRIORITY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USE_CANDIDATE, */\n        \"USE-CANDIDATE\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x0026 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0027 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0028 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0029 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_CONNECTION_ID, */\n        \"CONNECTION-ID\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x002b is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002c is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002d is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002e is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002f is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_ICMP, */\n        \"ICMP\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n\n    /* Sentinel */\n    {\n        /* PJ_STUN_ATTR_END_MANDATORY_ATTR */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    }\n};\n\nstatic struct attr_desc extended_attr_desc[] =\n{\n    {\n        /* ID 0x8021 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_SOFTWARE, */\n        \"SOFTWARE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ALTERNATE_SERVER, */\n        \"ALTERNATE-SERVER\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFRESH_INTERVAL, */\n        \"REFRESH-INTERVAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x8025 is not assigned*/\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PADDING, 0x8026 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* CACHE-TIMEOUT, 0x8027 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_FINGERPRINT, */\n        \"FINGERPRINT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLED, */\n        \"ICE-CONTROLLED\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLING, */\n        \"ICE-CONTROLLING\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    }\n};\n\n\n\n/*\n * Get STUN message type name.\n */\nPJ_DEF(const char*) pj_stun_get_method_name(unsigned msg_type)\n{\n    unsigned method = PJ_STUN_GET_METHOD(msg_type);\n\n    if (method >= PJ_ARRAY_SIZE(stun_method_names))\n        return \"???\";\n\n    return stun_method_names[method];\n}\n\n\n/*\n * Get STUN message class name.\n */\nPJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type)\n{\n    if (PJ_STUN_IS_REQUEST(msg_type))\n        return \"request\";\n    else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type))\n        return \"success response\";\n    else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type))\n        return \"error response\";\n    else if (PJ_STUN_IS_INDICATION(msg_type))\n        return \"indication\";\n    else\n        return \"???\";\n}\n\n\nstatic const struct attr_desc *find_attr_desc(unsigned attr_type)\n{\n    struct attr_desc *desc;\n\n    /* Check that attr_desc array is valid */\n    pj_assert(PJ_ARRAY_SIZE(mandatory_attr_desc)==\n              PJ_STUN_ATTR_END_MANDATORY_ATTR+1);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_END_MANDATORY_ATTR].decode_attr\n              == NULL);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_USE_CANDIDATE].decode_attr \n              == &decode_empty_attr);\n    pj_assert(PJ_ARRAY_SIZE(extended_attr_desc) ==\n              PJ_STUN_ATTR_END_EXTENDED_ATTR-PJ_STUN_ATTR_START_EXTENDED_ATTR);\n\n    if (attr_type < PJ_STUN_ATTR_END_MANDATORY_ATTR)\n        desc = &mandatory_attr_desc[attr_type];\n    else if (attr_type >= PJ_STUN_ATTR_START_EXTENDED_ATTR &&\n             attr_type < PJ_STUN_ATTR_END_EXTENDED_ATTR)\n        desc = &extended_attr_desc[attr_type-PJ_STUN_ATTR_START_EXTENDED_ATTR];\n    else\n        return NULL;\n\n    return desc->decode_attr == NULL ? NULL : desc;\n}\n\n\n/*\n * Get STUN attribute name.\n */\nPJ_DEF(const char*) pj_stun_get_attr_name(unsigned attr_type)\n{\n    const struct attr_desc *attr_desc;\n\n    attr_desc = find_attr_desc(attr_type);\n    if (!attr_desc || attr_desc->name==NULL)\n        return \"???\";\n\n    return attr_desc->name;\n}\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n */\nPJ_DEF(pj_str_t) pj_stun_get_err_reason(int err_code)\n{\n#if 0\n    /* Find error using linear search */\n    unsigned i;\n\n    for (i=0; i<PJ_ARRAY_SIZE(stun_err_msg_map); ++i) {\n        if (stun_err_msg_map[i].err_code == err_code)\n            return pj_str((char*)stun_err_msg_map[i].err_msg);\n    }\n    return pj_str(NULL);\n#else\n    /* Find error message using binary search */\n    int first = 0;\n    int n = PJ_ARRAY_SIZE(stun_err_msg_map);\n\n    while (n > 0) {\n        int half = n/2;\n        int mid = first + half;\n\n        if (stun_err_msg_map[mid].err_code < err_code) {\n            first = mid+1;\n            n -= (half+1);\n        } else if (stun_err_msg_map[mid].err_code > err_code) {\n            n = half;\n        } else {\n            first = mid;\n            break;\n        }\n    }\n\n\n    if (stun_err_msg_map[first].err_code == err_code) {\n        return pj_str((char*)stun_err_msg_map[first].err_msg);\n    } else {\n        return pj_str(NULL);\n    }\n#endif\n}\n\n\n/*\n * Set padding character.\n */\nPJ_DEF(int) pj_stun_set_padding_char(int chr)\n{\n    int old_pad = padding_char;\n    padding_char = chr;\n    return old_pad;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n\n#define INIT_ATTR(a,t,l)    (a)->hdr.type=(pj_uint16_t)(t), \\\n                            (a)->hdr.length=(pj_uint16_t)(l)\n#define ATTR_HDR_LEN        sizeof(pj_stun_attr_hdr)\n\nstatic pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint16_t) (((pj_uint16_t)buf[pos + 0] << 8) | \\\n                          ((pj_uint16_t)buf[pos + 1] << 0));\n}\n\n/*unused PJ_INLINE(pj_uint16_t) GETVAL16N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htons(GETVAL16H(buf,pos));\n}*/\n\nstatic void PUTVAL16H(pj_uint8_t *buf, unsigned pos, pj_uint16_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF00) >> 8);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF) >> 0);\n}\n\nPJ_INLINE(pj_uint32_t) GETVAL32H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint32_t) (((pj_uint32_t)buf[pos + 0] << 24UL) | \\\n                          ((pj_uint32_t)buf[pos + 1] << 16UL) | \\\n                          ((pj_uint32_t)buf[pos + 2] <<  8UL) | \\\n                          ((pj_uint32_t)buf[pos + 3] <<  0UL));\n}\n\n/*unused PJ_INLINE(pj_uint32_t) GETVAL32N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htonl(GETVAL32H(buf,pos));\n}*/\n\nstatic void PUTVAL32H(pj_uint8_t *buf, unsigned pos, pj_uint32_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF000000UL) >> 24);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF0000UL) >> 16);\n    buf[pos+2] = (pj_uint8_t) ((hval & 0x0000FF00UL) >>  8);\n    buf[pos+3] = (pj_uint8_t) ((hval & 0x000000FFUL) >>  0);\n}\n\nstatic void GETVAL64H(const pj_uint8_t *buf, unsigned pos, pj_timestamp *ts)\n{\n    ts->u32.hi = GETVAL32H(buf, pos);\n    ts->u32.lo = GETVAL32H(buf, pos+4);\n}\n\nstatic void PUTVAL64H(pj_uint8_t *buf, unsigned pos, const pj_timestamp *ts)\n{\n    PUTVAL32H(buf, pos, ts->u32.hi);\n    PUTVAL32H(buf, pos+4, ts->u32.lo);\n}\n\n\nstatic void GETATTRHDR(const pj_uint8_t *buf, pj_stun_attr_hdr *hdr)\n{\n    hdr->type = GETVAL16H(buf, 0);\n    hdr->length = GETVAL16H(buf, 2);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic IP address container\n */\n#define STUN_GENERIC_IPV4_ADDR_LEN      8\n#define STUN_GENERIC_IPV6_ADDR_LEN      20\n\n/*\n * Init sockaddr attr\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_init( pj_stun_sockaddr_attr *attr,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len)\n{\n    unsigned attr_len;\n\n    PJ_ASSERT_RETURN(attr && addr_len && addr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(addr_len == sizeof(pj_sockaddr_in) ||\n                     addr_len == sizeof(pj_sockaddr_in6), PJ_EINVAL);\n\n    attr_len = pj_sockaddr_get_addr_len(addr) + 4;\n    INIT_ATTR(attr, attr_type, attr_len);\n\n    pj_memcpy(&attr->sockaddr, addr, addr_len);\n    attr->xor_ed = xor_ed;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a generic STUN IP address attribute for IPv4 address.\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n                                                 int attr_type,\n                                                 pj_bool_t xor_ed,\n                                                 const pj_sockaddr_t *addr,\n                                                 unsigned addr_len,\n                                                 pj_stun_sockaddr_attr **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    *p_attr = attr;\n    return pj_stun_sockaddr_attr_init(attr, attr_type, xor_ed, \n                                      addr, addr_len);\n}\n\n\n/*\n * Create and add generic STUN IP address attribute to a STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type, \n                                                  pj_bool_t xor_ed,\n                                                  const pj_sockaddr_t *addr,\n                                                  unsigned addr_len)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = pj_stun_sockaddr_attr_create(pool, attr_type, xor_ed,\n                                                 addr, addr_len, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr, \n                                        void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    int af;\n    unsigned addr_len;\n    pj_uint32_t val;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN &&\n        attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n    {\n        return PJNATH_ESTUNINATTRLEN;\n    }\n\n    /* Check address family */\n    val = *(pj_uint8_t*)(buf + ATTR_HDR_LEN + 1);\n\n    /* Check address family is valid */\n    if (val == 1) {\n        if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET();\n        addr_len = 4;\n    } else if (val == 2) {\n        if (attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET6();\n        addr_len = 16;\n    } else {\n        /* Invalid address family */\n        return PJNATH_EINVAF;\n    }\n\n    /* Get port and address */\n    pj_sockaddr_init(af, &attr->sockaddr, NULL, 0);\n    pj_sockaddr_set_port(&attr->sockaddr, \n                         GETVAL16H(buf, ATTR_HDR_LEN+2));\n    pj_memcpy(pj_sockaddr_get_addr(&attr->sockaddr),\n              buf+ATTR_HDR_LEN+4,\n              addr_len);\n\n    /* Done */\n    *p_attr = (void*)attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = decode_sockaddr_attr(pool, buf, msghdr, p_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    attr = *(pj_stun_sockaddr_attr**)p_attr;\n\n    attr->xor_ed = PJ_TRUE;\n\n    if (attr->sockaddr.addr.sa_family == pj_AF_INET()) {\n        attr->sockaddr.ipv4.sin_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n        attr->sockaddr.ipv4.sin_addr.s_addr ^= pj_htonl(PJ_STUN_MAGIC);\n    } else if (attr->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        unsigned i;\n        pj_uint8_t *dst = (pj_uint8_t*) &attr->sockaddr.ipv6.sin6_addr;\n        pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\n        attr->sockaddr.ipv6.sin6_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\n        /* If the IP address family is IPv6, X-Address is computed by\n         * taking the mapped IP address in host byte order, XOR'ing it\n         * with the concatenation of the magic cookie and the 96-bit \n         * transaction ID, and converting the result to network byte \n         * order.\n         */\n        for (i=0; i<4; ++i) {\n            dst[i] ^= ((const pj_uint8_t*)&magic)[i];\n        }\n        pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n        for (i=0; i<12; ++i) {\n            dst[i+4] ^= msghdr->tsx_id[i];\n        }\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed)\n{\n    pj_uint8_t *start_buf = buf;\n    const pj_stun_sockaddr_attr *ca = \n        (const pj_stun_sockaddr_attr *)a;\n\n    PJ_CHECK_STACK();\n    \n    /* Common: attribute type */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    if (ca->sockaddr.addr.sa_family == pj_AF_INET()) {\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV4_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV4_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 1 for IPv4 */\n        *buf++ = 1;\n\n        /* IPv4 address */\n        if (ca->xor_ed) {\n            pj_uint32_t addr;\n            pj_uint16_t port;\n\n            addr = ca->sockaddr.ipv4.sin_addr.s_addr;\n            port = ca->sockaddr.ipv4.sin_port;\n\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            addr ^= pj_htonl(PJ_STUN_MAGIC);\n\n            /* Port */\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &addr, 4);\n            buf += 4;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_addr, 4);\n            buf += 4;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else if (ca->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        /* IPv6 address */\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV6_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV6_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 2 for IPv6 */\n        *buf++ = 2;\n\n        /* IPv6 address */\n        if (ca->xor_ed) {\n            unsigned i;\n            pj_uint8_t *dst;\n            const pj_uint8_t *src;\n            pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n            pj_uint16_t port = ca->sockaddr.ipv6.sin6_port;\n\n            /* Port */\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            dst = buf;\n            src = (const pj_uint8_t*) &ca->sockaddr.ipv6.sin6_addr;\n            for (i=0; i<4; ++i) {\n                dst[i] = (pj_uint8_t)(src[i] ^ ((const pj_uint8_t*)&magic)[i]);\n            }\n            pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n            for (i=0; i<12; ++i) {\n                dst[i+4] = (pj_uint8_t)(src[i+4] ^ msghdr->tsx_id[i]);\n            }\n\n            buf += 16;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_addr, 16);\n            buf += 16;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *printed = (unsigned)(buf - start_buf);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_sockaddr_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_sockaddr_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_sockaddr_attr);\n    pj_memcpy(dst, src, sizeof(pj_stun_sockaddr_attr));\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic string attribute\n */\n\n/*\n * Initialize a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_init( pj_stun_string_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_str_t *value)\n{\n    if (value && value->slen) {\n        INIT_ATTR(attr, attr_type, value->slen);\n        attr->value.slen = value->slen;\n        pj_strdup(pool, &attr->value, value);\n    } else {\n        INIT_ATTR(attr, attr_type, 0);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_str_t *value,\n                                               pj_stun_string_attr **p_attr)\n{\n    pj_stun_string_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && value && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    *p_attr = attr;\n\n    return pj_stun_string_attr_init(attr, pool, attr_type, value);\n}\n\n\n/*\n * Create and add STUN generic string attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_str_t *value)\n{\n    pj_stun_string_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_string_attr_create(pool, attr_type, value, \n                                                &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_string_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN);\n    value.slen = attr->hdr.length;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->value, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_string_attr *ca = \n        (const pj_stun_string_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = ((unsigned)ca->value.slen + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed) {\n        *printed = 0;\n        return PJ_ETOOSMALL;\n    }\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    /* Special treatment for SOFTWARE attribute:\n     * This attribute had caused interop problem when talking to \n     * legacy RFC 3489 STUN servers, due to different \"length\"\n     * rules with RFC 5389.\n     */\n    if (msghdr->magic != PJ_STUN_MAGIC ||\n        ca->hdr.type == PJ_STUN_ATTR_SOFTWARE)\n    {\n        /* Set the length to be 4-bytes aligned so that we can\n         * communicate with RFC 3489 endpoints\n         */\n        PUTVAL16H(buf, 2, (pj_uint16_t)((ca->value.slen + 3) & (~3)));\n    } else {\n        /* Use RFC 5389 rule */\n        PUTVAL16H(buf, 2, (pj_uint16_t)ca->value.slen);\n    }\n\n    /* Copy the string */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->value.ptr, ca->value.slen);\n\n    /* Add padding character, if string is not 4-bytes aligned. */\n    if (ca->value.slen & 0x03) {\n        pj_uint8_t pad[3];\n        pj_memset(pad, padding_char, sizeof(pad));\n        pj_memcpy(buf+ATTR_HDR_LEN+ca->value.slen, pad,\n                  4-(ca->value.slen & 0x03));\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_string_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_string_attr *asrc = (const pj_stun_string_attr*)src;\n    pj_stun_string_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_string_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_attr_hdr));\n    pj_strdup(pool, &dst->value, &asrc->value);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN empty attribute (used by USE-CANDIDATE).\n */\n\n/*\n * Create a STUN empty attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n                                              int attr_type,\n                                              pj_stun_empty_attr **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    INIT_ATTR(attr, attr_type, 0);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create STUN empty attribute and add the attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_empty_attr( pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type)\n{\n    pj_stun_empty_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_empty_attr_create(pool, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     void **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that the struct address is valid */\n    pj_assert(sizeof(pj_stun_empty_attr) == ATTR_HDR_LEN);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 0)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed)\n{\n    const pj_stun_empty_attr *ca = (pj_stun_empty_attr*)a;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, 0);\n\n    /* Done */\n    *printed = ATTR_HDR_LEN;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_empty_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_empty_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_empty_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_empty_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic 32bit integer attribute.\n */\n\n/*\n * Create a STUN generic 32bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n                                             int attr_type,\n                                             pj_uint32_t value,\n                                             pj_stun_uint_attr **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    INIT_ATTR(attr, attr_type, 4);\n    attr->value = value;\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 32bit value attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n                                              pj_stun_msg *msg,\n                                              int attr_type,\n                                              pj_uint32_t value)\n{\n    pj_stun_uint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed)\n{\n    const pj_stun_uint_attr *ca = (const pj_stun_uint_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 8) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)4);\n    PUTVAL32H(buf, 4, ca->value);\n    \n    /* Done */\n    *printed = 8;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint_attr));\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Create a STUN generic 64bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint64_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_timestamp *value,\n                                               pj_stun_uint64_attr **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    INIT_ATTR(attr, attr_type, 8);\n\n    if (value) {\n        attr->value.u32.hi = value->u32.hi;\n        attr->value.u32.lo = value->u32.lo;\n    }\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 64bit value attribute to the message. */\nPJ_DEF(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_timestamp *value)\n{\n    pj_stun_uint64_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint64_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    if (attr->hdr.length != 8)\n        return PJNATH_ESTUNINATTRLEN;\n\n    GETVAL64H(buf, 4, &attr->value);    \n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_uint64_attr *ca = (const pj_stun_uint64_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 12) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)8);\n    PUTVAL64H(buf, 4, &ca->value);\n\n    /* Done */\n    *printed = 12;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint64_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint64_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint64_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint64_attr));\n\n    return (void*)dst;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN MESSAGE-INTEGRITY attribute.\n */\n\n/*\n * Create a STUN MESSAGE-INTEGRITY attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n                                               pj_stun_msgint_attr **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_MESSAGE_INTEGRITY, 20);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg)\n{\n    pj_stun_msgint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_msgint_attr_create(pool, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 20)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Copy hmac */\n    pj_memcpy(attr->hmac, buf+4, 20);\n\n    /* Done */\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_msgint_attr *ca = (const pj_stun_msgint_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < 24) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, ca->hdr.length);\n\n    pj_memcpy(buf+4, ca->hmac, 20);\n\n    /* Done */\n    *printed = 24;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_msgint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_msgint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_msgint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_msgint_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN ERROR-CODE\n */\n\n/*\n * Create a STUN ERROR-CODE attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n                                                int err_code,\n                                                const pj_str_t *err_reason,\n                                                pj_stun_errcode_attr **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    char err_buf[80];\n    pj_str_t str;\n\n    PJ_ASSERT_RETURN(pool && err_code && p_attr, PJ_EINVAL);\n\n    if (err_reason == NULL) {\n        str = pj_stun_get_err_reason(err_code);\n        if (str.slen == 0) {\n            str.slen = pj_ansi_snprintf(err_buf, sizeof(err_buf),\n                                        \"Unknown error %d\", err_code);\n            str.ptr = err_buf;\n        }\n        err_reason = &str;\n    }\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_ERROR_CODE, 4+err_reason->slen);\n    attr->err_code = err_code;\n    pj_strdup(pool, &attr->reason, err_reason);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int err_code,\n                                                 const pj_str_t *err_reason)\n{\n    pj_stun_errcode_attr *err_attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_errcode_attr_create(pool, err_code, err_reason,\n                                         &err_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &err_attr->hdr);\n}\n\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length < 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_errcode_attr *ca = \n        (const pj_stun_errcode_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(4 + ca->reason.slen));\n    PUTVAL16H(buf, 4, 0);\n    buf[6] = (pj_uint8_t)(ca->err_code / 100);\n    buf[7] = (pj_uint8_t)(ca->err_code % 100);\n\n    /* Copy error string */\n    pj_memcpy(buf + ATTR_HDR_LEN + 4, ca->reason.ptr, ca->reason.slen);\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_errcode_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_errcode_attr *asrc = (const pj_stun_errcode_attr*)src;\n    pj_stun_errcode_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_errcode_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_errcode_attr));\n    pj_strdup(pool, &dst->reason, &asrc->reason);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN UNKNOWN-ATTRIBUTES attribute\n */\n\n/*\n * Create an empty instance of STUN UNKNOWN-ATTRIBUTES attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n                                                unsigned attr_cnt,\n                                                const pj_uint16_t attr_array[],\n                                                pj_stun_unknown_attr **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && attr_cnt < PJ_STUN_MAX_ATTR && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, attr_cnt * 2);\n\n    attr->attr_count = attr_cnt;\n    for (i=0; i<attr_cnt; ++i) {\n        attr->attrs[i] = attr_array[i];\n    }\n\n    /* If the number of unknown attributes is an odd number, one of the\n     * attributes MUST be repeated in the list.\n     */\n    /* No longer necessary\n    if ((attr_cnt & 0x01)) {\n        attr->attrs[attr_cnt] = attr_array[attr_cnt-1];\n    }\n    */\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 unsigned attr_cnt,\n                                                 const pj_uint16_t attr_type[])\n{\n    pj_stun_unknown_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_unknown_attr_create(pool, attr_cnt, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    const pj_uint16_t *punk_attr;\n    unsigned i;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    GETATTRHDR(buf, &attr->hdr);\n \n    attr->attr_count = (attr->hdr.length >> 1);\n    if (attr->attr_count > PJ_STUN_MAX_ATTR)\n        return PJ_ETOOMANY;\n\n    punk_attr = (const pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i<attr->attr_count; ++i) {\n        attr->attrs[i] = pj_ntohs(punk_attr[i]);\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_unknown_attr *ca = (const pj_stun_unknown_attr*) a;\n    pj_uint16_t *dst_unk_attr;\n    unsigned i;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that buffer is enough */\n    if (len < ATTR_HDR_LEN + (ca->attr_count << 1))\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(ca->attr_count << 1));\n\n    /* Copy individual attribute */\n    dst_unk_attr = (pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i < ca->attr_count; ++i, ++dst_unk_attr) {\n        *dst_unk_attr = pj_htons(ca->attrs[i]);\n    }\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + (ca->attr_count << 1) + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_unknown_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_unknown_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_unknown_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_unknown_attr));\n    \n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic binary attribute\n */\n\n/*\n * Initialize STUN binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_init( pj_stun_binary_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_uint8_t *data,\n                                              unsigned length)\n{\n    PJ_ASSERT_RETURN(attr_type, PJ_EINVAL);\n\n    INIT_ATTR(attr, attr_type, length);\n\n    attr->magic = PJ_STUN_MAGIC;\n\n    if (data && length) {\n        attr->length = length;\n        attr->data = (pj_uint8_t*) pj_pool_alloc(pool, length);\n        pj_memcpy(attr->data, data, length);\n    } else {\n        attr->data = NULL;\n        attr->length = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_uint8_t *data,\n                                               unsigned length,\n                                               pj_stun_binary_attr **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && attr_type && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    *p_attr = attr;\n    return pj_stun_binary_attr_init(attr, pool, attr_type, data, length);\n}\n\n\n/* Create and add binary attr. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_uint8_t *data,\n                                                unsigned length)\n{\n    pj_stun_binary_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_binary_attr_create(pool, attr_type,\n                                        data, length, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr,\n                                      void **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Copy the data to the attribute */\n    attr->length = attr->hdr.length;\n    attr->data = (pj_uint8_t*) pj_pool_alloc(pool, attr->length);\n    pj_memcpy(attr->data, buf+ATTR_HDR_LEN, attr->length);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_binary_attr *ca = (const pj_stun_binary_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = (ca->length + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed)\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t) ca->length);\n\n    /* Copy the data */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->data, ca->length);\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_binary_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_binary_attr *asrc = (const pj_stun_binary_attr*)src;\n    pj_stun_binary_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_binary_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_binary_attr));\n\n    if (asrc->length) {\n        dst->data = (pj_uint8_t*) pj_pool_alloc(pool, asrc->length);\n        pj_memcpy(dst->data, asrc->data, asrc->length);\n    }\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Initialize a generic STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_init( pj_stun_msg *msg,\n                                      unsigned msg_type,\n                                      pj_uint32_t magic,\n                                      const pj_uint8_t tsx_id[12])\n{\n    PJ_ASSERT_RETURN(msg && msg_type, PJ_EINVAL);\n\n    msg->hdr.type = (pj_uint16_t) msg_type;\n    msg->hdr.length = 0;\n    msg->hdr.magic = magic;\n    msg->attr_count = 0;\n\n    if (tsx_id) {\n        pj_memcpy(&msg->hdr.tsx_id, tsx_id, sizeof(msg->hdr.tsx_id));\n    } else {\n        struct transaction_id\n        {\n            pj_uint32_t     proc_id;\n            pj_uint32_t     random;\n            pj_uint32_t     counter;\n        } id;\n        static pj_uint32_t pj_stun_tsx_id_counter;\n\n        if (!pj_stun_tsx_id_counter)\n            pj_stun_tsx_id_counter = pj_rand();\n\n        id.proc_id = pj_getpid();\n        id.random = pj_rand();\n        id.counter = pj_stun_tsx_id_counter++;\n\n        pj_memcpy(&msg->hdr.tsx_id, &id, sizeof(msg->hdr.tsx_id));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_create( pj_pool_t *pool,\n                                        unsigned msg_type,\n                                        pj_uint32_t magic,\n                                        const pj_uint8_t tsx_id[12],\n                                        pj_stun_msg **p_msg)\n{\n    pj_stun_msg *msg;\n\n    PJ_ASSERT_RETURN(pool && msg_type && p_msg, PJ_EINVAL);\n\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    *p_msg = msg;\n    return pj_stun_msg_init(msg, msg_type, magic, tsx_id);\n}\n\n\n/*\n * Clone a STUN message with all of its attributes.\n */\nPJ_DEF(pj_stun_msg*) pj_stun_msg_clone( pj_pool_t *pool,\n                                        const pj_stun_msg *src)\n{\n    pj_stun_msg *dst;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && src, NULL);\n\n    dst = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(dst, src, sizeof(pj_stun_msg));\n\n    /* Duplicate the attributes */\n    for (i=0, dst->attr_count=0; i<src->attr_count; ++i) {\n        dst->attr[dst->attr_count] = pj_stun_attr_clone(pool, src->attr[i]);\n        if (dst->attr[dst->attr_count])\n            ++dst->attr_count;\n    }\n\n    return dst;\n}\n\n\n/*\n * Add STUN attribute to STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n                                         pj_stun_attr_hdr *attr)\n{\n    PJ_ASSERT_RETURN(msg && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->attr_count < PJ_STUN_MAX_ATTR, PJ_ETOOMANY);\n\n    msg->attr[msg->attr_count++] = attr;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check that the PDU is potentially a valid STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, pj_size_t pdu_len,\n                                      unsigned options)\n{\n    pj_uint32_t msg_len;\n\n    PJ_ASSERT_RETURN(pdu, PJ_EINVAL);\n\n    if (pdu_len < sizeof(pj_stun_msg_hdr))\n        return PJNATH_EINSTUNMSGLEN;\n\n    /* First byte of STUN message is always 0x00 or 0x01. */\n    if (*pdu != 0x00 && *pdu != 0x01)\n        return PJNATH_EINSTUNMSGTYPE;\n\n    /* Check the PDU length */\n    msg_len = GETVAL16H(pdu, 2);\n    if ((msg_len + 20 > pdu_len) || \n        ((options & PJ_STUN_IS_DATAGRAM) && msg_len + 20 != pdu_len))\n    {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* STUN message is always padded to the nearest 4 bytes, thus\n     * the last two bits of the length field are always zero.\n     */\n    if ((msg_len & 0x03) != 0) {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* If magic is set, then there is great possibility that this is\n     * a STUN message.\n     */\n    if (GETVAL32H(pdu, 4) == PJ_STUN_MAGIC) {\n\n        /* Check if FINGERPRINT attribute is present */\n        if ((options & PJ_STUN_NO_FINGERPRINT_CHECK )==0 && \n            GETVAL16H(pdu, msg_len + 20 - 8) == PJ_STUN_ATTR_FINGERPRINT) \n        {\n            pj_uint16_t attr_len = GETVAL16H(pdu, msg_len + 20 - 8 + 2);\n            pj_uint32_t fingerprint = GETVAL32H(pdu, msg_len + 20 - 8 + 4);\n            pj_uint32_t crc;\n\n            if (attr_len != 4)\n                return PJNATH_ESTUNINATTRLEN;\n\n            crc = pj_crc32_calc(pdu, msg_len + 20 - 8);\n            crc ^= STUN_XOR_FINGERPRINT;\n\n            if (crc != fingerprint)\n                return PJNATH_ESTUNFINGERPRINT;\n        }\n    }\n\n    /* Could be a STUN message */\n    return PJ_SUCCESS;\n}\n\n\n/* Create error response */\nPJ_DEF(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n                                                const pj_stun_msg *req_msg,\n                                                unsigned err_code,\n                                                const pj_str_t *err_msg,\n                                                pj_stun_msg **p_response)\n{\n    unsigned msg_type = req_msg->hdr.type;\n    pj_stun_msg *response = NULL;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_response, PJ_EINVAL);\n\n    PJ_ASSERT_RETURN(PJ_STUN_IS_REQUEST(msg_type), \n                     PJNATH_EINSTUNMSGTYPE);\n\n    /* Create response or error response */\n    if (err_code)\n        msg_type |= PJ_STUN_ERROR_RESPONSE_BIT;\n    else\n        msg_type |= PJ_STUN_SUCCESS_RESPONSE_BIT;\n\n    status = pj_stun_msg_create(pool, msg_type, req_msg->hdr.magic, \n                                req_msg->hdr.tsx_id, &response);\n    if (status != PJ_SUCCESS) {\n        return status;\n    }\n\n    /* Add error code attribute */\n    if (err_code) {\n        status = pj_stun_msg_add_errcode_attr(pool, response, \n                                              err_code, err_msg);\n        if (status != PJ_SUCCESS) {\n            return status;\n        }\n    }\n\n    *p_response = response;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse incoming packet into STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                       const pj_uint8_t *pdu,\n                                       pj_size_t pdu_len,\n                                       unsigned options,\n                                       pj_stun_msg **p_msg,\n                                       pj_size_t *p_parsed_len,\n                                       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n        *p_parsed_len = 0;\n    if (p_response)\n        *p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n        status = pj_stun_msg_check(pdu, pdu_len, options);\n        if (status != PJ_SUCCESS)\n            return status;\n    } else {\n        /* For safety, verify packet length at least */\n        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;\n        if (msg_len > pdu_len ||\n            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))\n        {\n            return PJNATH_EINSTUNMSGLEN;\n        }\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n        p_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= ATTR_HDR_LEN) {\n        unsigned attr_type, attr_val_len;\n        const struct attr_desc *adesc;\n\n        /* Get attribute type and length. If length is not aligned\n         * to 4 bytes boundary, add padding.\n         */\n        attr_type = GETVAL16H(pdu, 0);\n        attr_val_len = GETVAL16H(pdu, 2);\n        attr_val_len = (attr_val_len + 3) & (~3);\n\n        /* Check length */\n        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {\n            pj_str_t err_msg;\n            char err_msg_buf[80];\n\n            err_msg.ptr = err_msg_buf;\n            err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n                                            \"Attribute %s has invalid length\",\n                                            pj_stun_get_attr_name(attr_type));\n\n            PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n                      (int)err_msg.slen, err_msg.ptr));\n\n            if (p_response) {\n                pj_stun_msg_create_response(pool, msg, \n                                            PJ_STUN_SC_BAD_REQUEST, \n                                            &err_msg, p_response);\n            }\n            return PJNATH_ESTUNINATTRLEN;\n        }\n\n        /* Get the attribute descriptor */\n        adesc = find_attr_desc(attr_type);\n\n        if (adesc == NULL) {\n            /* Unrecognized attribute */\n            pj_stun_binary_attr *attr = NULL;\n\n            PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n                      attr_type));\n\n            /* Is this a fatal condition? */\n            if (attr_type <= 0x7FFF) {\n                /* This is a mandatory attribute, we must return error\n                 * if we don't understand the attribute.\n                 */\n                if (p_response) {\n                    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n                    status = pj_stun_msg_create_response(pool, msg,\n                                                         err_code, NULL, \n                                                         p_response);\n                    if (status==PJ_SUCCESS) {\n                        pj_uint16_t d = (pj_uint16_t)attr_type;\n                        pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n                    }\n                }\n\n                return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Create binary attribute to represent this */\n            status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n                                                GETVAL16H(pdu, 2), &attr);\n            if (status != PJ_SUCCESS) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing unknown STUN attribute type %d\",\n                          attr_type));\n\n                return status;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = &attr->hdr;\n\n        } else {\n            void *attr;\n            char err_msg1[PJ_ERR_MSG_SIZE],\n                 err_msg2[PJ_ERR_MSG_SIZE];\n\n            /* Parse the attribute */\n            status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n            if (status != PJ_SUCCESS) {\n                pj_strerror(status, err_msg1, sizeof(err_msg1));\n\n                if (p_response) {\n                    pj_str_t e;\n\n                    e.ptr = err_msg2;\n                    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n                                             \"%s in %s\",\n                                             err_msg1,\n                                             pj_stun_get_attr_name(attr_type));\n                    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n                        e.slen = sizeof(err_msg2) - 1;\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_BAD_REQUEST,\n                                                &e, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing STUN attribute %s: %s\",\n                          pj_stun_get_attr_name(attr_type), \n                          err_msg1));\n\n                return status;\n            }\n\n            if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n                !has_fingerprint) \n            {\n                if (has_msg_int) {\n                    /* Already has MESSAGE-INTEGRITY */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_msg_int = PJ_TRUE;\n\n            } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n                if (has_fingerprint) {\n                    /* Already has FINGERPRINT */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_fingerprint = PJ_TRUE;\n            } else {\n                if (has_fingerprint) {\n                    /* Another attribute is found which is not FINGERPRINT\n                     * after FINGERPRINT. Note that non-FINGERPRINT is\n                     * allowed to appear after M-I\n                     */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNFINGERPOS;\n                }\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n        }\n\n        /* Next attribute */\n        if (attr_val_len + 4 >= pdu_len) {\n            pdu += pdu_len;\n            pdu_len = 0;\n        } else {\n            pdu += (attr_val_len + 4);\n            pdu_len -= (attr_val_len + 4);\n        }\n    }\n\n    if (pdu_len > 0) {\n        /* Stray trailing bytes */\n        PJ_LOG(4,(THIS_FILE, \n                  \"Error decoding STUN message: unparsed trailing %d bytes\",\n                  pdu_len));\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n        *p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}\n\n/*\nstatic char *print_binary(const pj_uint8_t *data, unsigned data_len)\n{\n    static char static_buffer[1024];\n    char *buffer = static_buffer;\n    unsigned length=sizeof(static_buffer), i;\n\n    if (length < data_len * 2 + 8)\n        return \"\";\n\n    pj_ansi_sprintf(buffer, \", data=\");\n    buffer += 7;\n\n    for (i=0; i<data_len; ++i) {\n        pj_ansi_sprintf(buffer, \"%02x\", (*data) & 0xFF);\n        buffer += 2;\n        data++;\n    }\n\n    pj_ansi_sprintf(buffer, \"\\n\");\n    buffer++;\n\n    return static_buffer;\n}\n*/\n\n/*\n * Print the message structure to a buffer.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n                                       pj_uint8_t *buf, pj_size_t buf_size,\n                                       unsigned options,\n                                       const pj_str_t *key,\n                                       pj_size_t *p_msg_len)\n{\n    pj_uint8_t *start = buf;\n    pj_stun_msgint_attr *amsgint = NULL;\n    pj_stun_fingerprint_attr *afingerprint = NULL;\n    unsigned printed = 0, body_len;\n    pj_status_t status;\n    unsigned i;\n\n\n    PJ_ASSERT_RETURN(msg && buf && buf_size, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(options);\n    PJ_ASSERT_RETURN(options == 0, PJ_EINVAL);\n\n    /* Copy the message header part and convert the header fields to\n     * network byte order\n     */\n    if (buf_size < sizeof(pj_stun_msg_hdr))\n        return PJ_ETOOSMALL;\n    \n    PUTVAL16H(buf, 0, msg->hdr.type);\n    PUTVAL16H(buf, 2, 0);   /* length will be calculated later */\n    PUTVAL32H(buf, 4, msg->hdr.magic);\n    pj_memcpy(buf+8, msg->hdr.tsx_id, sizeof(msg->hdr.tsx_id));\n\n    buf += sizeof(pj_stun_msg_hdr);\n    buf_size -= sizeof(pj_stun_msg_hdr);\n\n    /* Encode each attribute to the message */\n    for (i=0; i<msg->attr_count; ++i) {\n        const struct attr_desc *adesc;\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            pj_assert(amsgint == NULL);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n            /* Stop when encountering MESSAGE-INTEGRITY */\n            break;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n            break;\n        }\n\n        adesc = find_attr_desc(attr_hdr->type);\n        if (adesc) {\n            status = adesc->encode_attr(attr_hdr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        } else {\n            /* This may be a generic attribute */\n            const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*) \n                                                   attr_hdr;\n            PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, PJ_EBUG);\n            status = encode_binary_attr(bin_attr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        }\n\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* We may have stopped printing attribute because we found\n     * MESSAGE-INTEGRITY or FINGERPRINT. Scan the rest of the\n     * attributes.\n     */\n    for ( ++i; i<msg->attr_count; ++i) {\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        /* There mustn't any attribute after FINGERPRINT */\n        PJ_ASSERT_RETURN(afingerprint == NULL, PJNATH_ESTUNFINGERPOS);\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            /* There mustn't be MESSAGE-INTEGRITY before */\n            PJ_ASSERT_RETURN(amsgint == NULL, \n                             PJNATH_ESTUNMSGINTPOS);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n        }\n    }\n\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n    /*\n     * This is the old style MESSAGE-INTEGRITY and FINGERPRINT\n     * calculation, used in rfc3489bis-06 and older.\n     */\n    /* We MUST update the message length in the header NOW before\n     * calculating MESSAGE-INTEGRITY and FINGERPRINT. \n     * Note that length is not including the 20 bytes header.\n      */\n    if (amsgint && afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24 + 8);\n    } else if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else if (afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 8);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#else\n    /* If MESSAGE-INTEGRITY is present, include the M-I attribute\n     * in message length before calculating M-I\n     */\n    if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\n    /* hdr->length = pj_htons(length); */\n    PUTVAL16H(start, 2, (pj_uint16_t)body_len);\n\n    /* Calculate message integrity, if present */\n    if (amsgint != NULL) {\n        pj_hmac_sha1_context ctx;\n\n        /* Key MUST be specified */\n        PJ_ASSERT_RETURN(key, PJ_EINVALIDOP);\n\n        /* MESSAGE-INTEGRITY must be the last attribute in the message, or\n         * the last attribute before FINGERPRINT.\n         */\n        if (msg->attr_count>1 && i < msg->attr_count-2) {\n            /* Should not happen for message generated by us */\n            pj_assert(PJ_FALSE);\n            return PJNATH_ESTUNMSGINTPOS;\n\n        } else if (i == msg->attr_count-2)  {\n            if (msg->attr[i+1]->type != PJ_STUN_ATTR_FINGERPRINT) {\n                /* Should not happen for message generated by us */\n                pj_assert(PJ_FALSE);\n                return PJNATH_ESTUNMSGINTPOS;\n            } else {\n                afingerprint = (pj_stun_fingerprint_attr*) msg->attr[i+1];\n            }\n        }\n\n        /* Calculate HMAC-SHA1 digest, add zero padding to input\n         * if necessary to make the input 64 bytes aligned.\n         */\n        pj_hmac_sha1_init(&ctx, (const pj_uint8_t*)key->ptr, \n                          (unsigned)key->slen);\n        pj_hmac_sha1_update(&ctx, (const pj_uint8_t*)start, \n                            (unsigned)(buf-start));\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        // These are obsoleted in rfc3489bis-08\n        if ((buf-start) & 0x3F) {\n            pj_uint8_t zeroes[64];\n            pj_bzero(zeroes, sizeof(zeroes));\n            pj_hmac_sha1_update(&ctx, zeroes, 64-((buf-start) & 0x3F));\n        }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n        pj_hmac_sha1_final(&ctx, amsgint->hmac);\n\n        /* Put this attribute in the message */\n        status = encode_msgint_attr(amsgint, buf, (unsigned)buf_size, \n                                    &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Calculate FINGERPRINT if present */\n    if (afingerprint != NULL) {\n\n#if !PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        /* Update message length */\n        PUTVAL16H(start, 2, \n                 (pj_uint16_t)(GETVAL16H(start, 2)+8));\n#endif\n\n        afingerprint->value = pj_crc32_calc(start, buf-start);\n        afingerprint->value ^= STUN_XOR_FINGERPRINT;\n\n        /* Put this attribute in the message */\n        status = encode_uint_attr(afingerprint, buf, (unsigned)buf_size, \n                                  &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Update message length. */\n    msg->hdr.length = (pj_uint16_t) ((buf - start) - 20);\n\n    /* Return the length */\n    if (p_msg_len)\n        *p_msg_len = (buf - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_msg_find_attr( const pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 unsigned index)\n{\n    PJ_ASSERT_RETURN(msg, NULL);\n\n    for (; index < msg->attr_count; ++index) {\n        if (msg->attr[index]->type == attr_type)\n            return (pj_stun_attr_hdr*) msg->attr[index];\n    }\n\n    return NULL;\n}\n\n\n/*\n * Clone a STUN attribute.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_attr_clone( pj_pool_t *pool,\n                                              const pj_stun_attr_hdr *attr)\n{\n    const struct attr_desc *adesc;\n\n    /* Get the attribute descriptor */\n    adesc = find_attr_desc(attr->type);\n    if (adesc) {\n        return (pj_stun_attr_hdr*) (*adesc->clone_attr)(pool, attr);\n    } else {\n        /* Clone generic attribute */\n        const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*)\n                                               attr;\n        PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, NULL);\n        if (bin_attr->magic == PJ_STUN_MAGIC) {\n            return (pj_stun_attr_hdr*) clone_binary_attr(pool, attr);\n        } else {\n            return NULL;\n        }\n    }\n}\n\n\n"], "filenames": ["pjnath/src/pjnath/stun_msg.c"], "buggy_code_start_loc": [1441], "buggy_code_end_loc": [1768], "fixing_code_start_loc": [1440], "fixing_code_end_loc": [1768], "type": "CWE-122", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. This issue is similar to GHSA-9pfh-r8x4-w26w. Possible buffer overread when parsing a certain STUN message. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as commit in the master branch.", "other": {"cve": {"id": "CVE-2022-23547", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-23T15:15:14.917", "lastModified": "2023-01-04T21:01:10.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. This issue is similar to GHSA-9pfh-r8x4-w26w. Possible buffer overread when parsing a certain STUN message. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as commit in the master branch."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pjsip:pjsip:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.13.1", "matchCriteriaId": "269DF17C-C86C-41C2-A98F-B1F757CECAFF"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/bc4812d31a67d5e2f973fbfaf950d6118226cf36", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-9pfh-r8x4-w26w", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-cxwq-5g9x-x7fr", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/bc4812d31a67d5e2f973fbfaf950d6118226cf36"}}