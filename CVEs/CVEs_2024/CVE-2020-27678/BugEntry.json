{"buggy_code": ["/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n/*\n * Copyright (c) 2019, Joyent, Inc.\n */\n\n#include <syslog.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <malloc.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#include <security/pam_appl.h>\n#include <security/pam_modules.h>\n#include <sys/mman.h>\n\n#include <libintl.h>\n\n#include \"pam_impl.h\"\n\nstatic char *pam_snames [PAM_NUM_MODULE_TYPES] = {\n\tPAM_ACCOUNT_NAME,\n\tPAM_AUTH_NAME,\n\tPAM_PASSWORD_NAME,\n\tPAM_SESSION_NAME\n};\n\nstatic char *pam_inames [PAM_MAX_ITEMS] = {\n/* NONE */\t\tNULL,\n/* PAM_SERVICE */\t\"service\",\n/* PAM_USER */\t\t\"user\",\n/* PAM_TTY */\t\t\"tty\",\n/* PAM_RHOST */\t\t\"rhost\",\n/* PAM_CONV */\t\t\"conv\",\n/* PAM_AUTHTOK */\t\"authtok\",\n/* PAM_OLDAUTHTOK */\t\"oldauthtok\",\n/* PAM_RUSER */\t\t\"ruser\",\n/* PAM_USER_PROMPT */\t\"user_prompt\",\n/* PAM_REPOSITORY */\t\"repository\",\n/* PAM_RESOURCE */\t\"resource\",\n/* PAM_AUSER */\t\t\"auser\",\n/* Undefined Items */\n};\n\n/*\n * This extra definition is needed in order to build this library\n * on pre-64-bit-aware systems.\n */\n#if !defined(_LFS64_LARGEFILE)\n#define\tstat64\tstat\n#endif\t/* !defined(_LFS64_LARGEFILE) */\n\n/* functions to dynamically load modules */\nstatic int\tload_modules(pam_handle_t *, int, char *, pamtab_t *);\nstatic void\t*open_module(pam_handle_t *, char *);\nstatic int\tload_function(void *, char *, int (**func)());\n\n/* functions to read and store the pam.conf configuration file */\nstatic int\topen_pam_conf(struct pam_fh **, pam_handle_t *, char *);\nstatic void\tclose_pam_conf(struct pam_fh *);\nstatic int\tread_pam_conf(pam_handle_t *, char *);\nstatic int\tget_pam_conf_entry(struct pam_fh *, pam_handle_t *,\n    pamtab_t **);\nstatic char\t*read_next_token(char **);\nstatic char\t*nextline(struct pam_fh *, pam_handle_t *, int *);\nstatic int\tverify_pam_conf(pamtab_t *, char *);\n\n/* functions to clean up and free memory */\nstatic void\tclean_up(pam_handle_t *);\nstatic void\tfree_pamconf(pamtab_t *);\nstatic void\tfree_pam_conf_info(pam_handle_t *);\nstatic void\tfree_env(env_list *);\n\n/* convenience functions for I18N/L10N communication */\n\nstatic void\tfree_resp(int, struct pam_response *);\nstatic int\tdo_conv(pam_handle_t *, int, int,\n    char messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE], void *,\n    struct pam_response **);\n\nstatic int\tlog_priority;\t/* pam_trace syslog priority & facility */\nstatic int\tpam_debug = 0;\n\nstatic char *\npam_trace_iname(int item_type, char *iname_buf)\n{\n\tchar *name;\n\n\tif (item_type <= 0 ||\n\t    item_type >= PAM_MAX_ITEMS ||\n\t    (name = pam_inames[item_type]) == NULL) {\n\t\t(void) sprintf(iname_buf, \"%d\", item_type);\n\t\treturn (iname_buf);\n\t}\n\treturn (name);\n}\n\nstatic char *\npam_trace_fname(int flag)\n{\n\tif (flag & PAM_BINDING)\n\t\treturn (PAM_BINDING_NAME);\n\tif (flag & PAM_INCLUDE)\n\t\treturn (PAM_INCLUDE_NAME);\n\tif (flag & PAM_OPTIONAL)\n\t\treturn (PAM_OPTIONAL_NAME);\n\tif (flag & PAM_REQUIRED)\n\t\treturn (PAM_REQUIRED_NAME);\n\tif (flag & PAM_REQUISITE)\n\t\treturn (PAM_REQUISITE_NAME);\n\tif (flag & PAM_SUFFICIENT)\n\t\treturn (PAM_SUFFICIENT_NAME);\n\treturn (\"bad flag name\");\n}\n\nstatic char *\npam_trace_cname(pam_handle_t *pamh)\n{\n\tif (pamh->pam_conf_name[pamh->include_depth] == NULL)\n\t\treturn (\"NULL\");\n\treturn (pamh->pam_conf_name[pamh->include_depth]);\n}\n\n#include <deflt.h>\n#include <stdarg.h>\n/*\n * pam_settrace - setup configuration for pam tracing\n *\n * turn on PAM debug if \"magic\" file exists\n * if exists (original), pam_debug = PAM_DEBUG_DEFAULT,\n * log_priority = LOG_DEBUG(7) and log_facility = LOG_AUTH(4).\n *\n * if has contents, keywork=value pairs:\n *\n *\t\"log_priority=\" 0-7, the pam_trace syslog priority to use\n *\t\t(see sys/syslog.h)\n *\t\"log_facility=\" 0-23, the pam_trace syslog facility to use\n *\t\t(see sys/syslog.h)\n *\t\"debug_flags=\" PAM_DEBUG_DEFAULT (0x0001), log traditional\n *\t\t\t(original) debugging.\n *\t\tPlus the logical or of:\n *\t\t    PAM_DEBUG_ITEM (0x0002), log item values and\n *\t\t\tpam_get_item.\n *\t\t    PAM_DEBUG_MODULE (0x0004), log module return status.\n *\t\t    PAM_DEBUG_CONF (0x0008), log pam.conf parsing.\n *\t\t    PAM_DEBUG_DATA (0x0010), get/set_data.\n *\t\t    PAM_DEBUG_CONV (0x0020), conversation/response.\n *\n *\t\t    If compiled with DEBUG:\n *\t\t    PAM_DEBUG_AUTHTOK (0x8000), display AUTHTOK value if\n *\t\t\t\tPAM_DEBUG_ITEM is set and results from\n *\t\t\t\tPAM_PROMPT_ECHO_OFF responses.\n *\t\t    USE CAREFULLY, THIS EXPOSES THE USER'S PASSWORDS.\n *\n *\t\tor set to 0 and off even if PAM_DEBUG file exists.\n *\n * Output has the general form:\n * <whatever was set syslog> PAM[<pid>]: <interface>(<handle> and other info)\n * <whatever was set syslog> PAM[<pid>]: details requested for <interface> call\n *\tWhere:\t<pid> is the process ID of the calling process.\n *\t\t<handle> is the Hex value of the pam_handle associated with the\n *\t\t\tcall.\n */\n\nstatic void\npam_settrace()\n{\n\tvoid\t*defp;\n\n\tif ((defp = defopen_r(PAM_DEBUG)) != NULL) {\n\t\tchar\t*arg;\n\t\tint\tcode;\n\t\tint\tfacility = LOG_AUTH;\n\n\t\tpam_debug = PAM_DEBUG_DEFAULT;\n\t\tlog_priority = LOG_DEBUG;\n\n\t\t(void) defcntl_r(DC_SETFLAGS, DC_CASE, defp);\n\t\tif ((arg = defread_r(LOG_PRIORITY, defp)) != NULL) {\n\t\t\tcode = (int)strtol(arg, NULL, 10);\n\t\t\tif ((code & ~LOG_PRIMASK) == 0) {\n\t\t\t\tlog_priority = code;\n\t\t\t}\n\t\t}\n\t\tif ((arg = defread_r(LOG_FACILITY, defp)) != NULL) {\n\t\t\tcode = (int)strtol(arg, NULL, 10);\n\t\t\tif (code < LOG_NFACILITIES) {\n\t\t\t\tfacility = code << 3;\n\t\t\t}\n\t\t}\n\t\tif ((arg = defread_r(DEBUG_FLAGS, defp)) != NULL) {\n\t\t\tpam_debug = (int)strtol(arg, NULL, 0);\n\t\t}\n\t\tdefclose_r(defp);\n\n\t\tlog_priority |= facility;\n\t}\n}\n\n/*\n * pam_trace - logs tracing messages\n *\n *\tflag = debug_flags from /etc/pam_debug\n *\tformat and args = message to print (PAM[<pid>]: is prepended).\n *\n *\tglobal log_priority = pam_trace syslog (log_priority | log_facility)\n *\t\tfrom /etc/pam_debug\n */\n/*PRINTFLIKE2*/\nstatic void\npam_trace(int flag, char *format, ...)\n{\n\tva_list args;\n\tchar message[1024];\n\tint savemask;\n\n\tif ((pam_debug & flag) == 0)\n\t\treturn;\n\n\tsavemask = setlogmask(LOG_MASK(log_priority & LOG_PRIMASK));\n\t(void) snprintf(message, sizeof (message), \"PAM[%ld]: %s\",\n\t    (long)getpid(), format);\n\tva_start(args, format);\n\t(void) vsyslog(log_priority, message, args);\n\tva_end(args);\n\t(void) setlogmask(savemask);\n}\n\n/*\n * __pam_log - logs PAM syslog messages\n *\n *\tpriority = message priority\n *\tformat and args = message to log\n */\n/*PRINTFLIKE2*/\nvoid\n__pam_log(int priority, const char *format, ...)\n{\n\tva_list args;\n\tint savemask = setlogmask(LOG_MASK(priority & LOG_PRIMASK));\n\n\tva_start(args, format);\n\t(void) vsyslog(priority, format, args);\n\tva_end(args);\n\t(void) setlogmask(savemask);\n}\n\n\n/*\n *\t\t\tpam_XXXXX routines\n *\n *\tThese are the entry points to the authentication switch\n */\n\n/*\n * pam_start\t\t- initiate an authentication transaction and\n *\t\t\t  set parameter values to be used during the\n *\t\t\t  transaction\n */\n\nint\npam_start(const char *service, const char *user,\n    const struct pam_conv *pam_conv, pam_handle_t **pamh)\n{\n\tint\terr;\n\n\t*pamh = calloc(1, sizeof (struct pam_handle));\n\n\tpam_settrace();\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_start(%s,%s,%p:%p) - debug = %x\",\n\t    service ? service : \"NULL\", user ? user : \"NULL\", (void *)pam_conv,\n\t    (void *)*pamh, pam_debug);\n\n\tif (*pamh == NULL)\n\t\treturn (PAM_BUF_ERR);\n\n\t(*pamh)->pam_inmodule = RO_OK;\t\t/* OK to set RO items */\n\tif ((err = pam_set_item(*pamh, PAM_SERVICE, (void *)service))\n\t    != PAM_SUCCESS) {\n\t\tclean_up(*pamh);\n\t\t*pamh = NULL;\n\t\treturn (err);\n\t}\n\n\tif ((err = pam_set_item(*pamh, PAM_USER, (void *)user))\n\t    != PAM_SUCCESS) {\n\t\tclean_up(*pamh);\n\t\t*pamh = NULL;\n\t\treturn (err);\n\t}\n\n\tif ((err = pam_set_item(*pamh, PAM_CONV, (void *)pam_conv))\n\t    != PAM_SUCCESS) {\n\t\tclean_up(*pamh);\n\t\t*pamh = NULL;\n\t\treturn (err);\n\t}\n\n\t(*pamh)->pam_inmodule = RW_OK;\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * pam_end - terminate an authentication transaction\n */\n\nint\npam_end(pam_handle_t *pamh, int pam_status)\n{\n\tstruct pam_module_data *psd, *p;\n\tfd_list *expired;\n\tfd_list *traverse;\n\tenv_list *env_expired;\n\tenv_list *env_traverse;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_end(%p): status = %s\", (void *)pamh,\n\t    pam_strerror(pamh, pam_status));\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\t/* call the cleanup routines for module specific data */\n\n\tpsd = pamh->ssd;\n\twhile (psd) {\n\t\tif (psd->cleanup) {\n\t\t\tpsd->cleanup(pamh, psd->data, pam_status);\n\t\t}\n\t\tp = psd;\n\t\tpsd = p->next;\n\t\tfree(p->module_data_name);\n\t\tfree(p);\n\t}\n\tpamh->ssd = NULL;\n\n\t/* dlclose all module fds */\n\ttraverse = pamh->fd;\n\twhile (traverse) {\n\t\texpired = traverse;\n\t\ttraverse = traverse->next;\n\t\t(void) dlclose(expired->mh);\n\t\tfree(expired);\n\t}\n\tpamh->fd = 0;\n\n\t/* remove all environment variables */\n\tenv_traverse = pamh->pam_env;\n\twhile (env_traverse) {\n\t\tenv_expired = env_traverse;\n\t\tenv_traverse = env_traverse->next;\n\t\tfree_env(env_expired);\n\t}\n\n\tclean_up(pamh);\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * pam_set_item\t\t- set the value of a parameter that can be\n *\t\t\t  retrieved via a call to pam_get_item()\n */\n\nint\npam_set_item(pam_handle_t *pamh, int item_type, const void *item)\n{\n\tstruct pam_item *pip;\n\tint\tsize;\n\tchar\tiname_buf[PAM_MAX_MSG_SIZE];\n\n\tif (((pam_debug & PAM_DEBUG_ITEM) == 0) || (pamh == NULL)) {\n\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t    \"pam_set_item(%p:%s)\", (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf));\n\t}\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\t/* check read only items */\n\tif ((item_type == PAM_SERVICE) && (pamh->pam_inmodule != RO_OK))\n\t\treturn (PAM_PERM_DENIED);\n\n\t/*\n\t * Check that item_type is within valid range\n\t */\n\n\tif (item_type <= 0 || item_type >= PAM_MAX_ITEMS)\n\t\treturn (PAM_SYMBOL_ERR);\n\n\tpip = &(pamh->ps_item[item_type]);\n\n\tswitch (item_type) {\n\tcase PAM_AUTHTOK:\n\tcase PAM_OLDAUTHTOK:\n\t\tif (pip->pi_addr != NULL)\n\t\t\t(void) memset(pip->pi_addr, 0, pip->pi_size);\n\t\t/*FALLTHROUGH*/\n\tcase PAM_SERVICE:\n\tcase PAM_USER:\n\tcase PAM_TTY:\n\tcase PAM_RHOST:\n\tcase PAM_RUSER:\n\tcase PAM_USER_PROMPT:\n\tcase PAM_RESOURCE:\n\tcase PAM_AUSER:\n\t\tif (pip->pi_addr != NULL) {\n\t\t\tfree(pip->pi_addr);\n\t\t}\n\n\t\tif (item == NULL) {\n\t\t\tpip->pi_addr = NULL;\n\t\t\tpip->pi_size = 0;\n\t\t} else {\n\t\t\tpip->pi_addr = strdup((char *)item);\n\t\t\tif (pip->pi_addr == NULL) {\n\t\t\t\tpip->pi_size = 0;\n\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t}\n\t\t\tpip->pi_size = strlen(pip->pi_addr);\n\t\t}\n\t\tbreak;\n\tcase PAM_CONV:\n\t\tif (pip->pi_addr != NULL)\n\t\t\tfree(pip->pi_addr);\n\t\tsize = sizeof (struct pam_conv);\n\t\tif ((pip->pi_addr = calloc(1, size)) == NULL)\n\t\t\treturn (PAM_BUF_ERR);\n\t\tif (item != NULL)\n\t\t\t(void) memcpy(pip->pi_addr, item, (unsigned int) size);\n\t\telse\n\t\t\t(void) memset(pip->pi_addr, 0, size);\n\t\tpip->pi_size = size;\n\t\tbreak;\n\tcase PAM_REPOSITORY:\n\t\tif (pip->pi_addr != NULL) {\n\t\t\tpam_repository_t *auth_rep;\n\n\t\t\tauth_rep = (pam_repository_t *)pip->pi_addr;\n\t\t\tif (auth_rep->type != NULL)\n\t\t\t\tfree(auth_rep->type);\n\t\t\tif (auth_rep->scope != NULL)\n\t\t\t\tfree(auth_rep->scope);\n\t\t\tfree(auth_rep);\n\t\t}\n\t\tif (item != NULL) {\n\t\t\tpam_repository_t *s, *d;\n\n\t\t\tsize = sizeof (struct pam_repository);\n\t\t\tpip->pi_addr = calloc(1, size);\n\t\t\tif (pip->pi_addr == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\n\t\t\ts = (struct pam_repository *)item;\n\t\t\td = (struct pam_repository *)pip->pi_addr;\n\n\t\t\td->type = strdup(s->type);\n\t\t\tif (d->type == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\td->scope = malloc(s->scope_len);\n\t\t\tif (d->scope == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t(void) memcpy(d->scope, s->scope, s->scope_len);\n\t\t\td->scope_len = s->scope_len;\n\t\t}\n\t\tpip->pi_size = size;\n\t\tbreak;\n\tdefault:\n\t\treturn (PAM_SYMBOL_ERR);\n\t}\n\tswitch (item_type) {\n\tcase PAM_CONV:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_set_item(%p:%s)=%p\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    item ? (void *)((struct pam_conv *)item)->conv :\n\t\t    (void *)0);\n\t\tbreak;\n\tcase PAM_REPOSITORY:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_set_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    item ? (((struct pam_repository *)item)->type ?\n\t\t    ((struct pam_repository *)item)->type : \"NULL\") :\n\t\t    \"NULL\");\n\t\tbreak;\n\tcase PAM_AUTHTOK:\n\tcase PAM_OLDAUTHTOK:\n#ifdef\tDEBUG\n\t\tif (pam_debug & PAM_DEBUG_AUTHTOK)\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_set_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    item ? (char *)item : \"NULL\");\n\t\telse\n#endif\t/* DEBUG */\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_set_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    item ? \"********\" : \"NULL\");\n\t\tbreak;\n\tdefault:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_set_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    item ? (char *)item : \"NULL\");\n\t}\n\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * pam_get_item\t\t- read the value of a parameter specified in\n *\t\t\t  the call to pam_set_item()\n */\n\nint\npam_get_item(const pam_handle_t *pamh, int item_type, void **item)\n{\n\tstruct pam_item *pip;\n\tchar\tiname_buf[PAM_MAX_MSG_SIZE];\n\n\tif (((pam_debug & PAM_DEBUG_ITEM) == 0) || (pamh == NULL)) {\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)\",\n\t\t    (void *)pamh, pam_trace_iname(item_type, iname_buf));\n\t}\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\tif (item_type <= 0 || item_type >= PAM_MAX_ITEMS)\n\t\treturn (PAM_SYMBOL_ERR);\n\n\tif ((pamh->pam_inmodule != WO_OK) &&\n\t    ((item_type == PAM_AUTHTOK || item_type == PAM_OLDAUTHTOK))) {\n\t\t__pam_log(LOG_AUTH | LOG_NOTICE, \"pam_get_item(%s) called from \"\n\t\t    \"a non module context\",\n\t\t    pam_trace_iname(item_type, iname_buf));\n\t\treturn (PAM_PERM_DENIED);\n\t}\n\n\tpip = (struct pam_item *)&(pamh->ps_item[item_type]);\n\n\t*item = pip->pi_addr;\n\tswitch (item_type) {\n\tcase PAM_CONV:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)=%p\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    (void *)((struct pam_conv *)*item)->conv);\n\t\tbreak;\n\tcase PAM_REPOSITORY:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    *item ? (((struct pam_repository *)*item)->type ?\n\t\t    ((struct pam_repository *)*item)->type : \"NULL\") :\n\t\t    \"NULL\");\n\t\tbreak;\n\tcase PAM_AUTHTOK:\n\tcase PAM_OLDAUTHTOK:\n#ifdef\tDEBUG\n\t\tif (pam_debug & PAM_DEBUG_AUTHTOK)\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_get_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    *item ? *(char **)item : \"NULL\");\n\t\telse\n#endif\t/* DEBUG */\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_get_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    *item ? \"********\" : \"NULL\");\n\t\tbreak;\n\tdefault:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    *item ? *(char **)item : \"NULL\");\n\t}\n\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * parse_user_name         - process the user response: ignore\n *                           '\\t' or ' ' before or after a user name.\n *                           user_input is a null terminated string.\n *                           *ret_username will be the user name.\n */\n\nstatic int\nparse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\n\t/* Set the default value for *ret_username */\n\t*ret_username = NULL;\n\n\t/*\n\t * Set the initial value for username - this is a buffer holds\n\t * the user name.\n\t */\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\n\t/*\n\t * The user_input is guaranteed to be terminated by a null character.\n\t */\n\tptr = user_input;\n\n\t/* Skip all the leading whitespaces if there are any. */\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\n\tif (*ptr == '\\0') {\n\t\t/*\n\t\t * We should never get here since the user_input we got\n\t\t * in pam_get_user() is not all whitespaces nor just \"\\0\".\n\t\t */\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\t/*\n\t * username will be the first string we get from user_input\n\t * - we skip leading whitespaces and ignore trailing whitespaces\n\t */\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\t/* ret_username will be freed in pam_get_user(). */\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * Get the value of PAM_USER. If not set, then use the convenience function\n * to prompt for the user. Use prompt if specified, else use PAM_USER_PROMPT\n * if it is set, else use default.\n */\n#define\tWHITESPACE\t0\n#define\tUSERNAME\t1\n\nint\npam_get_user(pam_handle_t *pamh, char **user, const char *prompt_override)\n{\n\tint\tstatus;\n\tchar\t*prompt = NULL;\n\tchar    *real_username;\n\tstruct pam_response *ret_resp = NULL;\n\tchar messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE];\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_get_user(%p, %p, %s)\", (void *)pamh, (void *)*user,\n\t    prompt_override ? prompt_override : \"NULL\");\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\tif ((status = pam_get_item(pamh, PAM_USER, (void **)user))\n\t    != PAM_SUCCESS) {\n\t\treturn (status);\n\t}\n\n\t/* if the user is set, return it */\n\n\tif (*user != NULL && *user[0] != '\\0') {\n\t\treturn (PAM_SUCCESS);\n\t}\n\n\t/*\n\t * if the module is requesting a special prompt, use it.\n\t * else use PAM_USER_PROMPT.\n\t */\n\n\tif (prompt_override != NULL) {\n\t\tprompt = (char *)prompt_override;\n\t} else {\n\t\tstatus = pam_get_item(pamh, PAM_USER_PROMPT, (void**)&prompt);\n\t\tif (status != PAM_SUCCESS) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\t/* if the prompt is not set, use default */\n\n\tif (prompt == NULL || prompt[0] == '\\0') {\n\t\tprompt = dgettext(TEXT_DOMAIN, \"Please enter user name: \");\n\t}\n\n\t/* prompt for the user */\n\n\t(void) strncpy(messages[0], prompt, sizeof (messages[0]));\n\n\tfor (;;) {\n\t\tint state = WHITESPACE;\n\n\t\tstatus = do_conv(pamh, PAM_PROMPT_ECHO_ON, 1, messages,\n\t\t    NULL, &ret_resp);\n\n\t\tif (status != PAM_SUCCESS) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tif (ret_resp->resp && ret_resp->resp[0] != '\\0') {\n\t\t\tint len = strlen(ret_resp->resp);\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif ((ret_resp->resp[i] != ' ') &&\n\t\t\t\t    (ret_resp->resp[i] != '\\t')) {\n\t\t\t\t\tstate = USERNAME;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state == USERNAME)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* essentially empty response, try again */\n\t\tfree_resp(1, ret_resp);\n\t\tret_resp = NULL;\n\t}\n\n\t/* set PAM_USER */\n\t/* Parse the user input to get the user name. */\n\tstatus = parse_user_name(ret_resp->resp, &real_username);\n\n\tif (status != PAM_SUCCESS) {\n\t\tif (real_username != NULL)\n\t\t\tfree(real_username);\n\t\tfree_resp(1, ret_resp);\n\t\treturn (status);\n\t}\n\n\tstatus = pam_set_item(pamh, PAM_USER, real_username);\n\n\tfree(real_username);\n\n\tfree_resp(1, ret_resp);\n\tif (status != PAM_SUCCESS) {\n\t\treturn (status);\n\t}\n\n\t/*\n\t * finally, get PAM_USER. We have to call pam_get_item to get\n\t * the value of user because pam_set_item mallocs the memory.\n\t */\n\n\tstatus = pam_get_item(pamh, PAM_USER, (void**)user);\n\treturn (status);\n}\n\n/*\n * Set module specific data\n */\n\nint\npam_set_data(pam_handle_t *pamh, const char *module_data_name, void *data,\n    void (*cleanup)(pam_handle_t *pamh, void *data, int pam_end_status))\n{\n\tstruct pam_module_data *psd;\n\n\tpam_trace(PAM_DEBUG_DATA,\n\t    \"pam_set_data(%p:%s:%d)=%p\", (void *)pamh,\n\t    (module_data_name != NULL) ? module_data_name : \"NULL\",\n\t    (pamh != NULL) ? pamh->pam_inmodule : -1, data);\n\tif (pamh == NULL || (pamh->pam_inmodule != WO_OK) ||\n\t    module_data_name == NULL) {\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\t/* check if module data already exists */\n\n\tfor (psd = pamh->ssd; psd; psd = psd->next) {\n\t\tif (strcmp(psd->module_data_name, module_data_name) == 0) {\n\t\t\t/* clean up original data before setting the new data */\n\t\t\tif (psd->cleanup) {\n\t\t\t\tpsd->cleanup(pamh, psd->data, PAM_SUCCESS);\n\t\t\t}\n\t\t\tpsd->data = (void *)data;\n\t\t\tpsd->cleanup = cleanup;\n\t\t\treturn (PAM_SUCCESS);\n\t\t}\n\t}\n\n\tpsd = malloc(sizeof (struct pam_module_data));\n\tif (psd == NULL)\n\t\treturn (PAM_BUF_ERR);\n\n\tpsd->module_data_name = strdup(module_data_name);\n\tif (psd->module_data_name == NULL) {\n\t\tfree(psd);\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\tpsd->data = (void *)data;\n\tpsd->cleanup = cleanup;\n\tpsd->next = pamh->ssd;\n\tpamh->ssd = psd;\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * get module specific data\n */\n\nint\npam_get_data(const pam_handle_t *pamh, const char *module_data_name,\n    const void **data)\n{\n\tstruct pam_module_data *psd;\n\n\tif (pamh == NULL || (pamh->pam_inmodule != WO_OK) ||\n\t    module_data_name == NULL) {\n\t\tpam_trace(PAM_DEBUG_DATA,\n\t\t    \"pam_get_data(%p:%s:%d)=%p\", (void *)pamh,\n\t\t    module_data_name ? module_data_name : \"NULL\",\n\t\t    pamh->pam_inmodule, *data);\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\tfor (psd = pamh->ssd; psd; psd = psd->next) {\n\t\tif (strcmp(psd->module_data_name, module_data_name) == 0) {\n\t\t\t*data = psd->data;\n\t\t\tpam_trace(PAM_DEBUG_DATA,\n\t\t\t    \"pam_get_data(%p:%s)=%p\", (void *)pamh,\n\t\t\t    module_data_name, *data);\n\t\t\treturn (PAM_SUCCESS);\n\t\t}\n\t}\n\tpam_trace(PAM_DEBUG_DATA,\n\t    \"pam_get_data(%p:%s)=%s\", (void *)pamh, module_data_name,\n\t    \"PAM_NO_MODULE_DATA\");\n\n\treturn (PAM_NO_MODULE_DATA);\n}\n\n/*\n * PAM equivalent to strerror()\n */\n/* ARGSUSED */\nconst char *\npam_strerror(pam_handle_t *pamh, int errnum)\n{\n\tswitch (errnum) {\n\tcase PAM_SUCCESS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Success\"));\n\tcase PAM_OPEN_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Dlopen failure\"));\n\tcase PAM_SYMBOL_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Symbol not found\"));\n\tcase PAM_SERVICE_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Error in underlying service module\"));\n\tcase PAM_SYSTEM_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"System error\"));\n\tcase PAM_BUF_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Memory buffer error\"));\n\tcase PAM_CONV_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Conversation failure\"));\n\tcase PAM_PERM_DENIED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Permission denied\"));\n\tcase PAM_MAXTRIES:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Maximum number of attempts exceeded\"));\n\tcase PAM_AUTH_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Authentication failed\"));\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Get new authentication token\"));\n\tcase PAM_CRED_INSUFFICIENT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Insufficient credentials\"));\n\tcase PAM_AUTHINFO_UNAVAIL:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Can not retrieve authentication info\"));\n\tcase PAM_USER_UNKNOWN:\n\t\treturn (dgettext(TEXT_DOMAIN, \"No account present for user\"));\n\tcase PAM_CRED_UNAVAIL:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Can not retrieve user credentials\"));\n\tcase PAM_CRED_EXPIRED:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"User credentials have expired\"));\n\tcase PAM_CRED_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Failure setting user credentials\"));\n\tcase PAM_ACCT_EXPIRED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"User account has expired\"));\n\tcase PAM_AUTHTOK_EXPIRED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"User password has expired\"));\n\tcase PAM_SESSION_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Can not make/remove entry for session\"));\n\tcase PAM_AUTHTOK_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token manipulation error\"));\n\tcase PAM_AUTHTOK_RECOVERY_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token can not be recovered\"));\n\tcase PAM_AUTHTOK_LOCK_BUSY:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token lock busy\"));\n\tcase PAM_AUTHTOK_DISABLE_AGING:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token aging disabled\"));\n\tcase PAM_NO_MODULE_DATA:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Module specific data not found\"));\n\tcase PAM_IGNORE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Ignore module\"));\n\tcase PAM_ABORT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"General PAM failure \"));\n\tcase PAM_TRY_AGAIN:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Unable to complete operation. Try again\"));\n\tdefault:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Unknown error\"));\n\t}\n}\n\nstatic void *\nsm_name(int ind)\n{\n\tswitch (ind) {\n\tcase PAM_AUTHENTICATE:\n\t\treturn (PAM_SM_AUTHENTICATE);\n\tcase PAM_SETCRED:\n\t\treturn (PAM_SM_SETCRED);\n\tcase PAM_ACCT_MGMT:\n\t\treturn (PAM_SM_ACCT_MGMT);\n\tcase PAM_OPEN_SESSION:\n\t\treturn (PAM_SM_OPEN_SESSION);\n\tcase PAM_CLOSE_SESSION:\n\t\treturn (PAM_SM_CLOSE_SESSION);\n\tcase PAM_CHAUTHTOK:\n\t\treturn (PAM_SM_CHAUTHTOK);\n\t}\n\treturn (NULL);\n}\n\nstatic int\n(*func(pamtab_t *modulep, int ind))()\n{\n\tvoid\t*funcp;\n\n\tif ((funcp = modulep->function_ptr) == NULL)\n\t\treturn (NULL);\n\n\tswitch (ind) {\n\tcase PAM_AUTHENTICATE:\n\t\treturn (((struct auth_module *)funcp)->pam_sm_authenticate);\n\tcase PAM_SETCRED:\n\t\treturn (((struct auth_module *)funcp)->pam_sm_setcred);\n\tcase PAM_ACCT_MGMT:\n\t\treturn (((struct account_module *)funcp)->pam_sm_acct_mgmt);\n\tcase PAM_OPEN_SESSION:\n\t\treturn (((struct session_module *)funcp)->pam_sm_open_session);\n\tcase PAM_CLOSE_SESSION:\n\t\treturn (((struct session_module *)funcp)->pam_sm_close_session);\n\tcase PAM_CHAUTHTOK:\n\t\treturn (((struct password_module *)funcp)->pam_sm_chauthtok);\n\t}\n\treturn (NULL);\n}\n\n/*\n * Run through the PAM service module stack for the given module type.\n */\nstatic int\nrun_stack(pam_handle_t *pamh, int flags, int type, int def_err, int ind,\n    char *function_name)\n{\n\tint\terr = PAM_SYSTEM_ERR;  /* preset */\n\tint\toptional_error = 0;\n\tint\trequired_error = 0;\n\tint\tsuccess = 0;\n\tpamtab_t *modulep;\n\tint\t(*sm_func)();\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\t/* read initial entries from pam.conf */\n\tif ((err = read_pam_conf(pamh, PAM_CONFIG)) != PAM_SUCCESS) {\n\t\treturn (err);\n\t}\n\n\tif ((modulep =\n\t    pamh->pam_conf_info[pamh->include_depth][type]) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"%s no initial module present\",\n\t\t    pam_trace_cname(pamh));\n\t\tgoto exit_return;\n\t}\n\n\tpamh->pam_inmodule = WO_OK;\t/* OK to get AUTHTOK */\ninclude:\n\tpam_trace(PAM_DEBUG_MODULE,\n\t    \"[%d:%s]:run_stack:%s(%p, %x): %s\", pamh->include_depth,\n\t    pam_trace_cname(pamh), function_name, (void *)pamh, flags,\n\t    modulep ? modulep->module_path : \"NULL\");\n\n\twhile (modulep != NULL) {\n\t\tif (modulep->pam_flag & PAM_INCLUDE) {\n\t\t\t/* save the return location */\n\t\t\tpamh->pam_conf_modulep[pamh->include_depth] =\n\t\t\t    modulep->next;\n\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t    \"setting for include[%d:%p]\",\n\t\t\t    pamh->include_depth, (void *)modulep->next);\n\t\t\tif (pamh->include_depth++ >= PAM_MAX_INCLUDE) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"run_stack: includes too deep %d \"\n\t\t\t\t    \"found trying to include %s from %s, %d \"\n\t\t\t\t    \"allowed\", pamh->include_depth,\n\t\t\t\t    modulep->module_path, pamh->pam_conf_name\n\t\t\t\t    [PAM_MAX_INCLUDE] == NULL ? \"NULL\" :\n\t\t\t\t    pamh->pam_conf_name[PAM_MAX_INCLUDE],\n\t\t\t\t    PAM_MAX_INCLUDE);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif ((err = read_pam_conf(pamh,\n\t\t\t    modulep->module_path)) != PAM_SUCCESS) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"run_stack[%d:%s]: can't read included \"\n\t\t\t\t    \"conf %s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    modulep->module_path);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif ((modulep = pamh->pam_conf_info\n\t\t\t    [pamh->include_depth][type]) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"run_stack[%d:%s]: no include module \"\n\t\t\t\t    \"present %s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh), function_name);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif (modulep->pam_flag & PAM_INCLUDE) {\n\t\t\t\t/* first line another include */\n\t\t\t\tgoto include;\n\t\t\t}\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT, \"include[%d:%s]\"\n\t\t\t    \"(%p, %s)=%s\", pamh->include_depth,\n\t\t\t    pam_trace_cname(pamh), (void *)pamh,\n\t\t\t    function_name, modulep->module_path);\n\t\t\tif ((err = load_modules(pamh, type, sm_name(ind),\n\t\t\t    pamh->pam_conf_info\n\t\t\t    [pamh->include_depth][type])) != PAM_SUCCESS) {\n\t\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t\t    \"[%d:%s]:%s(%p, %x): load_modules failed\",\n\t\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t\t    function_name, (void *)pamh, flags);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif ((modulep = pamh->pam_conf_info\n\t\t\t    [pamh->include_depth][type]) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"%s no initial module present\",\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t} else if ((err = load_modules(pamh, type, sm_name(ind),\n\t\t    modulep)) != PAM_SUCCESS) {\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t    \"[%d:%s]:%s(%p, %x): load_modules failed\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    function_name, (void *)pamh, flags);\n\t\t\tgoto exit_return;\n\t\t}  /* PAM_INCLUDE */\n\t\tsm_func = func(modulep, ind);\n\t\tif (sm_func) {\n\t\t\terr = sm_func(pamh, flags, modulep->module_argc,\n\t\t\t    (const char **)modulep->module_argv);\n\n\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t    \"[%d:%s]:%s(%p, %x): %s returned %s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t    modulep->module_path, pam_strerror(pamh, err));\n\n\t\t\tswitch (err) {\n\t\t\tcase PAM_IGNORE:\n\t\t\t\t/* do nothing */\n\t\t\t\tbreak;\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tif ((modulep->pam_flag & PAM_SUFFI_BIND) &&\n\t\t\t\t    !required_error) {\n\t\t\t\t\tpamh->pam_inmodule = RW_OK;\n\t\t\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t\t\t    \"[%d:%s]:%s(%p, %x): %s: success\",\n\t\t\t\t\t    pamh->include_depth,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t\t    (modulep->pam_flag & PAM_BINDING) ?\n\t\t\t\t\t    PAM_BINDING_NAME :\n\t\t\t\t\t    PAM_SUFFICIENT_NAME);\n\t\t\t\t\tgoto exit_return;\n\t\t\t\t}\n\t\t\t\tsuccess = 1;\n\t\t\t\tbreak;\n\t\t\tcase PAM_TRY_AGAIN:\n\t\t\t\t/*\n\t\t\t\t * We need to return immediately, and\n\t\t\t\t * we shouldn't reset the AUTHTOK item\n\t\t\t\t * since it is not an error per-se.\n\t\t\t\t */\n\t\t\t\tpamh->pam_inmodule = RW_OK;\n\t\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t\t    \"[%d:%s]:%s(%p, %x): TRY_AGAIN: %s\",\n\t\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t    pam_strerror(pamh, required_error ?\n\t\t\t\t    required_error : err));\n\t\t\t\terr = required_error ? required_error : err;\n\t\t\t\tgoto exit_return;\n\t\t\tdefault:\n\t\t\t\tif (modulep->pam_flag & PAM_REQUISITE) {\n\t\t\t\t\tpamh->pam_inmodule = RW_OK;\n\t\t\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t\t\t    \"[%d:%s]:%s(%p, %x): requisite: %s\",\n\t\t\t\t\t    pamh->include_depth,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t\t    pam_strerror(pamh,\n\t\t\t\t\t    required_error ? required_error :\n\t\t\t\t\t    err));\n\t\t\t\t\terr = required_error ?\n\t\t\t\t\t    required_error : err;\n\t\t\t\t\tgoto exit_return;\n\t\t\t\t} else if (modulep->pam_flag & PAM_REQRD_BIND) {\n\t\t\t\t\tif (!required_error)\n\t\t\t\t\t\trequired_error = err;\n\t\t\t\t} else {\n\t\t\t\t\tif (!optional_error)\n\t\t\t\t\t\toptional_error = err;\n\t\t\t\t}\n\t\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t\t    \"[%d:%s]:%s(%p, %x): error %s\",\n\t\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t    pam_strerror(pamh, err));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmodulep = modulep->next;\n\t}\n\n\tpam_trace(PAM_DEBUG_MODULE, \"[%d:%s]:stack_end:%s(%p, %x): %s %s: %s\",\n\t    pamh->include_depth, pam_trace_cname(pamh), function_name,\n\t    (void *)pamh, flags, pamh->include_depth ? \"included\" : \"final\",\n\t    required_error ? \"required\" : success ? \"success\" :\n\t    optional_error ? \"optional\" : \"default\",\n\t    pam_strerror(pamh, required_error ? required_error :\n\t    success ? PAM_SUCCESS : optional_error ? optional_error : def_err));\n\tif (pamh->include_depth > 0) {\n\t\tfree_pam_conf_info(pamh);\n\t\tpamh->include_depth--;\n\t\t/* continue at next entry */\n\t\tmodulep = pamh->pam_conf_modulep[pamh->include_depth];\n\t\tpam_trace(PAM_DEBUG_MODULE, \"looping for include[%d:%p]\",\n\t\t    pamh->include_depth, (void *)modulep);\n\t\tgoto include;\n\t}\n\tfree_pam_conf_info(pamh);\n\tpamh->pam_inmodule = RW_OK;\n\tif (required_error != 0)\n\t\treturn (required_error);\n\telse if (success != 0)\n\t\treturn (PAM_SUCCESS);\n\telse if (optional_error != 0)\n\t\treturn (optional_error);\n\telse\n\t\treturn (def_err);\n\nexit_return:\n\t/*\n\t * All done at whatever depth we're at.\n\t * Go back to not having read /etc/pam.conf\n\t */\n\twhile (pamh->include_depth > 0) {\n\t\tfree_pam_conf_info(pamh);\n\t\tpamh->include_depth--;\n\t}\n\tfree_pam_conf_info(pamh);\n\tpamh->pam_inmodule = RW_OK;\n\treturn (err);\n}\n\n/*\n * pam_authenticate - authenticate a user\n */\n\nint\npam_authenticate(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_AUTH_MODULE, PAM_AUTH_ERR,\n\t    PAM_AUTHENTICATE, \"pam_authenticate\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_setcred - modify or retrieve user credentials\n */\n\nint\npam_setcred(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_AUTH_MODULE, PAM_CRED_ERR,\n\t    PAM_SETCRED, \"pam_setcred\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_acct_mgmt - check password aging, account expiration\n */\n\nint\npam_acct_mgmt(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_ACCOUNT_MODULE, PAM_ACCT_EXPIRED,\n\t    PAM_ACCT_MGMT, \"pam_acct_mgmt\");\n\n\tif (retval != PAM_SUCCESS &&\n\t    retval != PAM_NEW_AUTHTOK_REQD) {\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\t}\n\treturn (retval);\n}\n\n/*\n * pam_open_session - begin session management\n */\n\nint\npam_open_session(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_SESSION_MODULE, PAM_SESSION_ERR,\n\t    PAM_OPEN_SESSION, \"pam_open_session\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_close_session - terminate session management\n */\n\nint\npam_close_session(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_SESSION_MODULE, PAM_SESSION_ERR,\n\t    PAM_CLOSE_SESSION, \"pam_close_session\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_chauthtok - change user authentication token\n */\n\nint\npam_chauthtok(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\t/* do not let apps use PAM_PRELIM_CHECK or PAM_UPDATE_AUTHTOK */\n\tif (flags & (PAM_PRELIM_CHECK | PAM_UPDATE_AUTHTOK)) {\n\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t    \"pam_chauthtok(%p, %x): %s\", (void *)pamh, flags,\n\t\t    pam_strerror(pamh, PAM_SYMBOL_ERR));\n\t\treturn (PAM_SYMBOL_ERR);\n\t}\n\n\t/* 1st pass: PRELIM CHECK */\n\tretval = run_stack(pamh, flags | PAM_PRELIM_CHECK, PAM_PASSWORD_MODULE,\n\t    PAM_AUTHTOK_ERR, PAM_CHAUTHTOK, \"pam_chauthtok-prelim\");\n\n\tif (retval == PAM_TRY_AGAIN)\n\t\treturn (retval);\n\n\tif (retval != PAM_SUCCESS) {\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\t\treturn (retval);\n\t}\n\n\t/* 2nd pass: UPDATE AUTHTOK */\n\tretval = run_stack(pamh, flags | PAM_UPDATE_AUTHTOK,\n\t    PAM_PASSWORD_MODULE, PAM_AUTHTOK_ERR, PAM_CHAUTHTOK,\n\t    \"pam_chauthtok-update\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\n\treturn (retval);\n}\n\n/*\n * pam_putenv - add an environment variable to the PAM handle\n *\tif name_value == 'NAME=VALUE'\tthen set variable to the value\n *\tif name_value == 'NAME='\tthen set variable to an empty value\n *\tif name_value == 'NAME'\t\tthen delete the variable\n */\n\nint\npam_putenv(pam_handle_t *pamh, const char *name_value)\n{\n\tint\t\terror = PAM_SYSTEM_ERR;\n\tchar\t\t*equal_sign = 0;\n\tchar\t\t*name = NULL, *value = NULL, *tmp_value = NULL;\n\tenv_list\t*traverse, *trail;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_putenv(%p, %s)\", (void *)pamh,\n\t    name_value ? name_value : \"NULL\");\n\n\tif (pamh == NULL || name_value == NULL)\n\t\tgoto out;\n\n\t/* see if we were passed 'NAME=VALUE', 'NAME=', or 'NAME' */\n\tif ((equal_sign = strchr(name_value, '=')) != 0) {\n\t\tif ((name = calloc(equal_sign - name_value + 1,\n\t\t    sizeof (char))) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\t(void) strncpy(name, name_value, equal_sign - name_value);\n\t\tif ((value = strdup(++equal_sign)) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((name = strdup(name_value)) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* check to see if we already have this variable in the PAM handle */\n\ttraverse = pamh->pam_env;\n\ttrail = traverse;\n\twhile (traverse && strncmp(traverse->name, name, strlen(name))) {\n\t\ttrail = traverse;\n\t\ttraverse = traverse->next;\n\t}\n\n\tif (traverse) {\n\t\t/* found a match */\n\t\tif (value == 0) {\n\t\t\t/* remove the env variable */\n\t\t\tif (pamh->pam_env == traverse)\n\t\t\t\tpamh->pam_env = traverse->next;\n\t\t\telse\n\t\t\t\ttrail->next = traverse->next;\n\t\t\tfree_env(traverse);\n\t\t} else if (strlen(value) == 0) {\n\t\t\t/* set env variable to empty value */\n\t\t\tif ((tmp_value = strdup(\"\")) == 0) {\n\t\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(traverse->value);\n\t\t\ttraverse->value = tmp_value;\n\t\t} else {\n\t\t\t/* set the new value */\n\t\t\tif ((tmp_value = strdup(value)) == 0) {\n\t\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(traverse->value);\n\t\t\ttraverse->value = tmp_value;\n\t\t}\n\n\t} else if (traverse == 0 && value) {\n\t\t/*\n\t\t * could not find a match in the PAM handle.\n\t\t * add the new value if there is one\n\t\t */\n\t\tif ((traverse = calloc(1, sizeof (env_list))) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((traverse->name = strdup(name)) == 0) {\n\t\t\tfree_env(traverse);\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((traverse->value = strdup(value)) == 0) {\n\t\t\tfree_env(traverse);\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (trail == 0) {\n\t\t\t/* new head of list */\n\t\t\tpamh->pam_env = traverse;\n\t\t} else {\n\t\t\t/* adding to end of list */\n\t\t\ttrail->next = traverse;\n\t\t}\n\t}\n\n\terror = PAM_SUCCESS;\nout:\n\tif (error != PAM_SUCCESS) {\n\t\tif (traverse) {\n\t\t\tif (traverse->name)\n\t\t\t\tfree(traverse->name);\n\t\t\tif (traverse->value)\n\t\t\t\tfree(traverse->value);\n\t\t\tfree(traverse);\n\t\t}\n\t}\n\tif (name)\n\t\tfree(name);\n\tif (value)\n\t\tfree(value);\n\treturn (error);\n}\n\n/*\n * pam_getenv - retrieve an environment variable from the PAM handle\n */\nchar *\npam_getenv(pam_handle_t *pamh, const char *name)\n{\n\tint\t\terror = PAM_SYSTEM_ERR;\n\tenv_list\t*traverse;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_getenv(%p, %p)\", (void *)pamh, (void *)name);\n\n\tif (pamh == NULL || name == NULL)\n\t\tgoto out;\n\n\t/* check to see if we already have this variable in the PAM handle */\n\ttraverse = pamh->pam_env;\n\twhile (traverse && strncmp(traverse->name, name, strlen(name))) {\n\t\ttraverse = traverse->next;\n\t}\n\terror = (traverse ? PAM_SUCCESS : PAM_SYSTEM_ERR);\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_getenv(%p, %s)=%s\", (void *)pamh, name,\n\t    traverse ? traverse->value : \"NULL\");\nout:\n\treturn (error ? NULL : strdup(traverse->value));\n}\n\n/*\n * pam_getenvlist - retrieve all environment variables from the PAM handle\n *                  in a NULL terminated array. On error, return NULL.\n */\nchar **\npam_getenvlist(pam_handle_t *pamh)\n{\n\tint\t\terror = PAM_SYSTEM_ERR;\n\tchar\t\t**list = 0;\n\tint\t\tlength = 0;\n\tenv_list\t*traverse;\n\tchar\t\t*tenv;\n\tsize_t\t\ttenv_size;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_getenvlist(%p)\", (void *)pamh);\n\n\tif (pamh == NULL)\n\t\tgoto out;\n\n\t/* find out how many environment variables we have */\n\ttraverse = pamh->pam_env;\n\twhile (traverse) {\n\t\tlength++;\n\t\ttraverse = traverse->next;\n\t}\n\n\t/* allocate the array we will return to the caller */\n\tif ((list = calloc(length + 1, sizeof (char *))) == NULL) {\n\t\terror = PAM_BUF_ERR;\n\t\tgoto out;\n\t}\n\n\t/* add the variables one by one */\n\tlength = 0;\n\ttraverse = pamh->pam_env;\n\twhile (traverse != NULL) {\n\t\ttenv_size = strlen(traverse->name) +\n\t\t    strlen(traverse->value) + 2; /* name=val\\0 */\n\t\tif ((tenv = malloc(tenv_size)) == NULL) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\t/*LINTED*/\n\t\t(void) sprintf(tenv, \"%s=%s\", traverse->name, traverse->value);\n\t\tlist[length++] = tenv;\n\t\ttraverse = traverse->next;\n\t}\n\tlist[length] = NULL;\n\n\terror = PAM_SUCCESS;\nout:\n\tif (error != PAM_SUCCESS) {\n\t\t/* free the partially constructed list */\n\t\tif (list) {\n\t\t\tlength = 0;\n\t\t\twhile (list[length] != NULL) {\n\t\t\t\tfree(list[length]);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tfree(list);\n\t\t}\n\t}\n\treturn (error ? NULL : list);\n}\n\n/*\n * Routines to load a requested module on demand\n */\n\n/*\n * load_modules - load the requested module.\n *\t\t  if the dlopen or dlsym fail, then\n *\t\t  the module is ignored.\n */\n\nstatic int\nload_modules(pam_handle_t *pamh, int type, char *function_name,\n    pamtab_t *pam_entry)\n{\n\tvoid\t*mh;\n\tstruct\tauth_module *authp;\n\tstruct\taccount_module *accountp;\n\tstruct\tsession_module *sessionp;\n\tstruct\tpassword_module *passwdp;\n\tint\tloading_functions = 0; /* are we currently loading functions? */\n\n\tpam_trace(PAM_DEBUG_MODULE, \"load_modules[%d:%s](%p, %s)=%s:%s\",\n\t    pamh->include_depth, pam_trace_cname(pamh), (void *)pamh,\n\t    function_name, pam_trace_fname(pam_entry->pam_flag),\n\t    pam_entry->module_path);\n\n\twhile (pam_entry != NULL) {\n\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t    \"while load_modules[%d:%s](%p, %s)=%s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), (void *)pamh,\n\t\t    function_name, pam_entry->module_path);\n\n\t\tif (pam_entry->pam_flag & PAM_INCLUDE) {\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t    \"done load_modules[%d:%s](%p, %s)=%s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    (void *)pamh, function_name,\n\t\t\t    pam_entry->module_path);\n\t\t\treturn (PAM_SUCCESS);\n\t\t}\n\t\tswitch (type) {\n\t\tcase PAM_AUTH_MODULE:\n\n\t\t\t/* if the function has already been loaded, return */\n\t\t\tauthp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (((strcmp(function_name, PAM_SM_AUTHENTICATE)\n\t\t\t    == 0) && authp && authp->pam_sm_authenticate) ||\n\t\t\t    ((strcmp(function_name, PAM_SM_SETCRED) == 0) &&\n\t\t\t    authp && authp->pam_sm_setcred))) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\t/* function has not been loaded yet */\n\t\t\tloading_functions = 1;\n\t\t\tif (authp == NULL) {\n\t\t\t\tauthp = calloc(1, sizeof (struct auth_module));\n\t\t\t\tif (authp == NULL)\n\t\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t}\n\n\t\t\t/* if open_module fails, return error */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(authp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\t/* load the authentication function */\n\t\t\tif (strcmp(function_name, PAM_SM_AUTHENTICATE) == 0) {\n\t\t\t\tif (load_function(mh, PAM_SM_AUTHENTICATE,\n\t\t\t\t    &authp->pam_sm_authenticate)\n\t\t\t\t    != PAM_SUCCESS) {\n\t\t\t\t\t/* return error if dlsym fails */\n\t\t\t\t\tfree(authp);\n\t\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t\t}\n\n\t\t\t/* load the setcred function */\n\t\t\t} else if (strcmp(function_name, PAM_SM_SETCRED) == 0) {\n\t\t\t\tif (load_function(mh, PAM_SM_SETCRED,\n\t\t\t\t    &authp->pam_sm_setcred) != PAM_SUCCESS) {\n\t\t\t\t\t/* return error if dlsym fails */\n\t\t\t\t\tfree(authp);\n\t\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpam_entry->function_ptr = authp;\n\t\t\tbreak;\n\t\tcase PAM_ACCOUNT_MODULE:\n\t\t\taccountp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (strcmp(function_name, PAM_SM_ACCT_MGMT) == 0) &&\n\t\t\t    accountp && accountp->pam_sm_acct_mgmt) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If functions are added to the account module,\n\t\t\t * verify that one of the other functions hasn't\n\t\t\t * already loaded it.  See PAM_AUTH_MODULE code.\n\t\t\t */\n\t\t\tloading_functions = 1;\n\t\t\taccountp = calloc(1, sizeof (struct account_module));\n\t\t\tif (accountp == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\n\t\t\t/* if open_module fails, return error */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(accountp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\tif (load_function(mh, PAM_SM_ACCT_MGMT,\n\t\t\t    &accountp->pam_sm_acct_mgmt) != PAM_SUCCESS) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: pam_sm_acct_mgmt() \"\n\t\t\t\t    \"missing\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\tfree(accountp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t}\n\t\t\tpam_entry->function_ptr = accountp;\n\t\t\tbreak;\n\t\tcase PAM_SESSION_MODULE:\n\t\t\tsessionp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (((strcmp(function_name,\n\t\t\t    PAM_SM_OPEN_SESSION) == 0) &&\n\t\t\t    sessionp && sessionp->pam_sm_open_session) ||\n\t\t\t    ((strcmp(function_name,\n\t\t\t    PAM_SM_CLOSE_SESSION) == 0) &&\n\t\t\t    sessionp && sessionp->pam_sm_close_session))) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\tloading_functions = 1;\n\t\t\tif (sessionp == NULL) {\n\t\t\t\tsessionp = calloc(1,\n\t\t\t\t    sizeof (struct session_module));\n\t\t\t\tif (sessionp == NULL)\n\t\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t}\n\n\t\t\t/* if open_module fails, return error */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(sessionp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\tif ((strcmp(function_name, PAM_SM_OPEN_SESSION) == 0) &&\n\t\t\t    load_function(mh, PAM_SM_OPEN_SESSION,\n\t\t\t    &sessionp->pam_sm_open_session) != PAM_SUCCESS) {\n\t\t\t\tfree(sessionp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t} else if ((strcmp(function_name,\n\t\t\t    PAM_SM_CLOSE_SESSION) == 0) &&\n\t\t\t    load_function(mh, PAM_SM_CLOSE_SESSION,\n\t\t\t    &sessionp->pam_sm_close_session) != PAM_SUCCESS) {\n\t\t\t\tfree(sessionp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t}\n\t\t\tpam_entry->function_ptr = sessionp;\n\t\t\tbreak;\n\t\tcase PAM_PASSWORD_MODULE:\n\t\t\tpasswdp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (strcmp(function_name, PAM_SM_CHAUTHTOK) == 0) &&\n\t\t\t    passwdp && passwdp->pam_sm_chauthtok) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If functions are added to the password module,\n\t\t\t * verify that one of the other functions hasn't\n\t\t\t * already loaded it.  See PAM_AUTH_MODULE code.\n\t\t\t */\n\t\t\tloading_functions = 1;\n\t\t\tpasswdp = calloc(1, sizeof (struct password_module));\n\t\t\tif (passwdp == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\n\t\t\t/* if open_module fails, continue */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(passwdp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\tif (load_function(mh, PAM_SM_CHAUTHTOK,\n\t\t\t    &passwdp->pam_sm_chauthtok) != PAM_SUCCESS) {\n\t\t\t\tfree(passwdp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t}\n\t\t\tpam_entry->function_ptr = passwdp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t    \"load_modules[%d:%s](%p, %s): unsupported type %d\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    (void *)pamh, function_name, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tpam_entry = pam_entry->next;\n\t} /* while */\n\n\tpam_trace(PAM_DEBUG_MODULE, \"load_modules[%d:%s](%p, %s)=done\",\n\t    pamh->include_depth, pam_trace_cname(pamh), (void *)pamh,\n\t    function_name);\n\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * open_module\t\t- Open the module first checking for\n *\t\t\t  propers modes and ownerships on the file.\n */\n\nstatic void *\nopen_module(pam_handle_t *pamh, char *module_so)\n{\n\tstruct stat64\tstb;\n\tchar\t\t*errmsg;\n\tvoid\t\t*lfd;\n\tfd_list\t\t*module_fds = 0;\n\tfd_list\t\t*trail = 0;\n\tfd_list\t\t*traverse = 0;\n\n\t/* Check the ownership and file modes */\n\tif (stat64(module_so, &stb) < 0) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t    \"open_module[%d:%s]: stat(%s) failed: %s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so,\n\t\t    strerror(errno));\n\t\treturn (NULL);\n\t}\n\tif (stb.st_uid != (uid_t)0) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_module[%d:%s]: Owner of the module %s is not root\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so);\n\t\treturn (NULL);\n\t}\n\tif (stb.st_mode & S_IWGRP) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_module[%d:%s]: module %s writable by group\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so);\n\t\treturn (NULL);\n\t}\n\tif (stb.st_mode & S_IWOTH) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_module[%d:%s]: module %s writable by world\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Perform the dlopen()\n\t */\n\tlfd = (void *)dlopen(module_so, RTLD_LAZY);\n\n\tif (lfd == NULL) {\n\t\terrmsg = dlerror();\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"open_module[%d:%s]: %s \"\n\t\t    \"failed: %s\", pamh->include_depth, pam_trace_cname(pamh),\n\t\t    module_so, errmsg != NULL ? errmsg : \"Unknown error\");\n\t\treturn (NULL);\n\t} else {\n\t\t/* add this fd to the pam handle */\n\t\tif ((module_fds = calloc(1, sizeof (fd_list))) == 0) {\n\t\t\t(void) dlclose(lfd);\n\t\t\tlfd = 0;\n\t\t\treturn (NULL);\n\t\t}\n\t\tmodule_fds->mh = lfd;\n\n\t\tif (pamh->fd == 0) {\n\t\t\t/* adding new head of list */\n\t\t\tpamh->fd = module_fds;\n\t\t} else {\n\t\t\t/* appending to end of list */\n\t\t\ttraverse = pamh->fd;\n\t\t\twhile (traverse) {\n\t\t\t\ttrail = traverse;\n\t\t\t\ttraverse = traverse->next;\n\t\t\t}\n\t\t\ttrail->next = module_fds;\n\t\t}\n\t}\n\n\treturn (lfd);\n}\n\n/*\n * load_function - call dlsym() to resolve the function address\n */\nstatic int\nload_function(void *lfd, char *name, int (**func)())\n{\n\tchar *errmsg = NULL;\n\n\tif (lfd == NULL)\n\t\treturn (PAM_SYMBOL_ERR);\n\n\t*func = (int (*)())dlsym(lfd, name);\n\tif (*func == NULL) {\n\t\terrmsg = dlerror();\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"dlsym failed %s: error %s\",\n\t\t    name, errmsg != NULL ? errmsg : \"Unknown error\");\n\t\treturn (PAM_SYMBOL_ERR);\n\t}\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"load_function: successful load of %s\", name);\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * Routines to read the pam.conf configuration file\n */\n\n/*\n * open_pam_conf - open the pam.conf config file\n */\n\nstatic int\nopen_pam_conf(struct pam_fh **pam_fh, pam_handle_t *pamh, char *config)\n{\n\tstruct stat64\tstb;\n\tint\t\tfd;\n\n\tif ((fd = open(config, O_RDONLY)) == -1) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: open(%s) failed: %s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config,\n\t\t    strerror(errno));\n\t\treturn (0);\n\t}\n\t/* Check the ownership and file modes */\n\tif (fstat64(fd, &stb) < 0) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: stat(%s) failed: %s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config,\n\t\t    strerror(errno));\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif (stb.st_uid != (uid_t)0) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: Owner of %s is not root\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config);\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif (stb.st_mode & S_IWGRP) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: %s writable by group\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config);\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif (stb.st_mode & S_IWOTH) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: %s writable by world\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config);\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif ((*pam_fh = calloc(1, sizeof (struct pam_fh))) == NULL) {\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\t(*pam_fh)->fconfig = fd;\n\t(*pam_fh)->bufsize = (size_t)stb.st_size;\n\tif (((*pam_fh)->data = mmap(0, (*pam_fh)->bufsize, PROT_READ,\n\t    MAP_PRIVATE, (*pam_fh)->fconfig, 0)) == MAP_FAILED) {\n\t\t(void) close(fd);\n\t\tfree (*pam_fh);\n\t\treturn (0);\n\t}\n\t(*pam_fh)->bufferp = (*pam_fh)->data;\n\n\treturn (1);\n}\n\n/*\n * close_pam_conf - close pam.conf\n */\n\nstatic void\nclose_pam_conf(struct pam_fh *pam_fh)\n{\n\t(void) munmap(pam_fh->data, pam_fh->bufsize);\n\t(void) close(pam_fh->fconfig);\n\tfree(pam_fh);\n}\n\n/*\n * read_pam_conf - read in each entry in pam.conf and store info\n *\t\t   under the pam handle.\n */\n\nstatic int\nread_pam_conf(pam_handle_t *pamh, char *config)\n{\n\tstruct pam_fh\t*pam_fh;\n\tpamtab_t\t*pamentp;\n\tpamtab_t\t*tpament;\n\tchar\t\t*service;\n\tint\t\terror;\n\tint\t\ti = pamh->include_depth;\t/* include depth */\n\t/*\n\t * service types:\n\t * error (-1), \"auth\" (0), \"account\" (1), \"session\" (2), \"password\" (3)\n\t */\n\tint service_found[PAM_NUM_MODULE_TYPES+1] = {0, 0, 0, 0, 0};\n\n\t(void) pam_get_item(pamh, PAM_SERVICE, (void **)&service);\n\tif (service == NULL || *service == '\\0') {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"No service name\");\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\tpamh->pam_conf_name[i] = strdup(config);\n\tpam_trace(PAM_DEBUG_CONF, \"read_pam_conf[%d:%s](%p) open(%s)\",\n\t    i, pam_trace_cname(pamh), (void *)pamh, config);\n\tif (open_pam_conf(&pam_fh, pamh, config) == 0) {\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\twhile ((error =\n\t    get_pam_conf_entry(pam_fh, pamh, &pamentp)) == PAM_SUCCESS &&\n\t    pamentp) {\n\n\t\t/* See if entry is this service and valid */\n\t\tif (verify_pam_conf(pamentp, service)) {\n\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t    \"read_pam_conf[%d:%s](%p): bad entry error %s\",\n\t\t\t    i, pam_trace_cname(pamh), (void *)pamh, service);\n\n\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\tfree_pamconf(pamentp);\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(pamentp->pam_service, service) == 0) {\n\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t    \"read_pam_conf[%d:%s](%p): processing %s\",\n\t\t\t    i, pam_trace_cname(pamh), (void *)pamh, service);\n\t\t\t/* process first service entry */\n\t\t\tif (service_found[pamentp->pam_type + 1] == 0) {\n\t\t\t\t/* purge \"other\" entries */\n\t\t\t\twhile ((tpament = pamh->pam_conf_info[i]\n\t\t\t\t    [pamentp->pam_type]) != NULL) {\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t\t    \"read_pam_conf(%p): purging \"\n\t\t\t\t\t    \"\\\"other\\\"[%d:%s][%s]\",\n\t\t\t\t\t    (void *)pamh, i,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\t\tpamh->pam_conf_info[i]\n\t\t\t\t\t    [pamentp->pam_type] = tpament->next;\n\t\t\t\t\tfree_pamconf(tpament);\n\t\t\t\t}\n\t\t\t\t/* add first service entry */\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): adding 1st \"\n\t\t\t\t    \"%s[%d:%s][%s]\",\n\t\t\t\t    (void *)pamh, service, i,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\tpamh->pam_conf_info[i][pamentp->pam_type] =\n\t\t\t\t    pamentp;\n\t\t\t\tservice_found[pamentp->pam_type + 1] = 1;\n\t\t\t} else {\n\t\t\t\t/* append more service entries */\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): adding more \"\n\t\t\t\t    \"%s[%d:%s][%s]\",\n\t\t\t\t    (void *)pamh, service, i,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\ttpament =\n\t\t\t\t    pamh->pam_conf_info[i][pamentp->pam_type];\n\t\t\t\twhile (tpament->next != NULL) {\n\t\t\t\t\ttpament = tpament->next;\n\t\t\t\t}\n\t\t\t\ttpament->next = pamentp;\n\t\t\t}\n\t\t} else if (service_found[pamentp->pam_type + 1] == 0) {\n\t\t\t/* See if \"other\" entry available and valid */\n\t\t\tif (verify_pam_conf(pamentp, \"other\")) {\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): bad entry error %s \"\n\t\t\t\t    \"\\\"other\\\"[%d:%s]\",\n\t\t\t\t    (void *)pamh, service, i,\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\t\tfree_pamconf(pamentp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcasecmp(pamentp->pam_service, \"other\") == 0) {\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): processing \"\n\t\t\t\t    \"\\\"other\\\"[%d:%s]\", (void *)pamh, i,\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\tif ((tpament = pamh->pam_conf_info[i]\n\t\t\t\t    [pamentp->pam_type]) == NULL) {\n\t\t\t\t\t/* add first \"other\" entry */\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t\t    \"read_pam_conf(%p): adding 1st \"\n\t\t\t\t\t    \"other[%d:%s][%s]\", (void *)pamh, i,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\t\tpamh->pam_conf_info[i]\n\t\t\t\t\t    [pamentp->pam_type] = pamentp;\n\t\t\t\t} else {\n\t\t\t\t\t/* append more \"other\" entries */\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t\t    \"read_pam_conf(%p): adding more \"\n\t\t\t\t\t    \"other[%d:%s][%s]\", (void *)pamh, i,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\t\twhile (tpament->next != NULL) {\n\t\t\t\t\t\ttpament = tpament->next;\n\t\t\t\t\t}\n\t\t\t\t\ttpament->next = pamentp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* irrelevant entry */\n\t\t\t\tfree_pamconf(pamentp);\n\t\t\t}\n\t\t} else {\n\t\t\t/* irrelevant entry */\n\t\t\tfree_pamconf(pamentp);\n\t\t}\n\t}\nout:\n\t(void) close_pam_conf(pam_fh);\n\tif (error != PAM_SUCCESS)\n\t\tfree_pam_conf_info(pamh);\n\treturn (error);\n}\n\n/*\n * get_pam_conf_entry - get a pam.conf entry\n */\n\nstatic int\nget_pam_conf_entry(struct pam_fh *pam_fh, pam_handle_t *pamh, pamtab_t **pam)\n{\n\tchar\t\t*cp, *arg;\n\tint\t\targc;\n\tchar\t\t*tmp, *tmp_free;\n\tint\t\ti;\n\tchar\t\t*current_line = NULL;\n\tint\t\terror = PAM_SYSTEM_ERR;\t/* preset to error */\n\tint\t\terr;\n\n\t/* get the next line from pam.conf */\n\tif ((cp = nextline(pam_fh, pamh, &err)) == NULL) {\n\t\t/* no more lines in pam.conf ==> return */\n\t\terror = PAM_SUCCESS;\n\t\t*pam = NULL;\n\t\tgoto out;\n\t}\n\n\tif ((*pam = calloc(1, sizeof (pamtab_t))) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\n\t/* copy full line for error reporting */\n\tif ((current_line = strdup(cp)) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\n\tpam_trace(PAM_DEBUG_CONF,\n\t    \"pam.conf[%s] entry:\\t%s\", pam_trace_cname(pamh), current_line);\n\n\t/* get service name (e.g. login, su, passwd) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing SERVICE NAME\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\tgoto out;\n\t}\n\tif (((*pam)->pam_service = strdup(arg)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\n\t/* get module type (e.g. authentication, acct mgmt) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing MODULE TYPE\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\t(*pam)->pam_type = -1;\t/* 0 is a valid value */\n\t\tgoto getflag;\n\t}\n\tif (strcasecmp(arg, PAM_AUTH_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_AUTH_MODULE;\n\t} else if (strcasecmp(arg, PAM_ACCOUNT_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_ACCOUNT_MODULE;\n\t} else if (strcasecmp(arg, PAM_SESSION_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_SESSION_MODULE;\n\t} else if (strcasecmp(arg, PAM_PASSWORD_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_PASSWORD_MODULE;\n\t} else {\n\t\t/* error */\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: invalid module \"\n\t\t    \"type: %s\", pam_trace_cname(pamh), current_line, arg);\n\t\t(*pam)->pam_type = -1;\t/* 0 is a valid value */\n\t}\n\ngetflag:\n\t/* get pam flag (e.g., requisite, required, sufficient, optional) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing CONTROL FLAG\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\tgoto getpath;\n\t}\n\tif (strcasecmp(arg, PAM_BINDING_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_BINDING;\n\t} else if (strcasecmp(arg, PAM_INCLUDE_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_INCLUDE;\n\t} else if (strcasecmp(arg, PAM_OPTIONAL_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_OPTIONAL;\n\t} else if (strcasecmp(arg, PAM_REQUIRED_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_REQUIRED;\n\t} else if (strcasecmp(arg, PAM_REQUISITE_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_REQUISITE;\n\t} else if (strcasecmp(arg, PAM_SUFFICIENT_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_SUFFICIENT;\n\t} else {\n\t\t/* error */\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"\\tinvalid control flag: %s\", arg);\n\t}\n\ngetpath:\n\t/* get module path (e.g. /usr/lib/security/pam_unix_auth.so.1) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing MODULE PATH\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\terror = PAM_SUCCESS;\t/* success */\n\t\tgoto out;\n\t}\n\tif (arg[0] != '/') {\n\t\tsize_t len;\n\t\t/*\n\t\t * If module path does not start with \"/\", then\n\t\t * prepend PAM_LIB_DIR (/usr/lib/security/).\n\t\t */\n\t\t/* sizeof (PAM_LIB_DIR) has room for '\\0' */\n\t\tlen = sizeof (PAM_LIB_DIR) + sizeof (PAM_ISA_DIR) + strlen(arg);\n\t\tif (((*pam)->module_path = malloc(len)) == NULL) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((*pam)->pam_flag & PAM_INCLUDE) {\n\t\t\t(void) snprintf((*pam)->module_path, len, \"%s%s\",\n\t\t\t    PAM_LIB_DIR, arg);\n\t\t} else {\n\t\t\t(void) snprintf((*pam)->module_path, len, \"%s%s%s\",\n\t\t\t    PAM_LIB_DIR, PAM_ISA_DIR, arg);\n\t\t}\n\t} else {\n\t\t/* Full path provided for module */\n\t\tchar *isa;\n\n\t\t/* Check for Instruction Set Architecture indicator */\n\t\tif ((isa = strstr(arg, PAM_ISA)) != NULL) {\n\t\t\tsize_t len;\n\t\t\tlen = strlen(arg) - (sizeof (PAM_ISA)-1) +\n\t\t\t    sizeof (PAM_ISA_DIR);\n\n\t\t\t/* substitute the architecture dependent path */\n\t\t\tif (((*pam)->module_path = malloc(len)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"strdup: out of memory\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*isa = '\\000';\n\t\t\tisa += strlen(PAM_ISA);\n\t\t\t(void) snprintf((*pam)->module_path, len, \"%s%s%s\",\n\t\t\t    arg, PAM_ISA_DIR, isa);\n\t\t} else if (((*pam)->module_path = strdup(arg)) == 0) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* count the number of module-specific options first */\n\targc = 0;\n\tif ((tmp = strdup(cp)) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\ttmp_free = tmp;\n\tfor (arg = read_next_token(&tmp); arg; arg = read_next_token(&tmp))\n\t\targc++;\n\tfree(tmp_free);\n\n\t/* allocate array for the module-specific options */\n\tif (argc > 0) {\n\t\tif (((*pam)->module_argv =\n\t\t    calloc(argc+1, sizeof (char *))) == 0) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"calloc: out of memory\");\n\t\t\tgoto out;\n\t\t}\n\t\ti = 0;\n\t\tfor (arg = read_next_token(&cp); arg;\n\t\t    arg = read_next_token(&cp)) {\n\t\t\t(*pam)->module_argv[i] = strdup(arg);\n\t\t\tif ((*pam)->module_argv[i] == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\t(*pam)->module_argv[argc] = NULL;\n\t}\n\t(*pam)->module_argc = argc;\n\n\terror = PAM_SUCCESS;\t/* success */\n\t(*pam)->pam_err = err;\t/* was the line truncated */\n\nout:\n\tif (current_line)\n\t\tfree(current_line);\n\tif (error != PAM_SUCCESS) {\n\t\t/* on error free this */\n\t\tif (*pam)\n\t\t\tfree_pamconf(*pam);\n\t}\n\treturn (error);\n}\n\n\n/*\n * read_next_token - skip tab and space characters and return the next token\n */\n\nstatic char *\nread_next_token(char **cpp)\n{\n\tregister char *cp = *cpp;\n\tchar *start;\n\n\tif (cp == (char *)0) {\n\t\t*cpp = (char *)0;\n\t\treturn ((char *)0);\n\t}\n\twhile (*cp == ' ' || *cp == '\\t')\n\t\tcp++;\n\tif (*cp == '\\0') {\n\t\t*cpp = (char *)0;\n\t\treturn ((char *)0);\n\t}\n\tstart = cp;\n\twhile (*cp && *cp != ' ' && *cp != '\\t')\n\t\tcp++;\n\tif (*cp != '\\0')\n\t\t*cp++ = '\\0';\n\t*cpp = cp;\n\treturn (start);\n}\n\nstatic char *\npam_conf_strnchr(char *sp, int c, intptr_t count)\n{\n\twhile (count) {\n\t\tif (*sp == (char)c)\n\t\t\treturn ((char *)sp);\n\t\telse {\n\t\t\tsp++;\n\t\t\tcount--;\n\t\t}\n\t};\n\treturn (NULL);\n}\n\n/*\n * nextline - skip all blank lines and comments\n */\n\nstatic char *\nnextline(struct pam_fh *pam_fh, pam_handle_t *pamh, int *err)\n{\n\tchar\t*ll;\n\tint\tfind_a_line = 0;\n\tchar\t*data = pam_fh->data;\n\tchar\t*bufferp = pam_fh->bufferp;\n\tchar\t*bufferendp = &data[pam_fh->bufsize];\n\tsize_t\tinput_len;\n\n\t/*\n\t * Skip the blank line, comment line\n\t */\n\twhile (!find_a_line) {\n\t\t/* if we are at the end of the buffer, there is no next line */\n\t\tif (bufferp == bufferendp)\n\t\t\treturn (NULL);\n\n\t\t/* skip blank line */\n\t\twhile (*bufferp == '\\n') {\n\t\t\t/*\n\t\t\t * If we are at the end of the buffer, there is\n\t\t\t * no next line.\n\t\t\t */\n\t\t\tif (++bufferp == bufferendp) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\t/* else we check *bufferp again */\n\t\t}\n\n\t\t/* skip comment line */\n\t\twhile (*bufferp == '#') {\n\t\t\tif ((ll = pam_conf_strnchr(bufferp, '\\n',\n\t\t\t    bufferendp - bufferp)) != NULL) {\n\t\t\t\tbufferp = ll;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * this comment line the last line.\n\t\t\t\t * no next line\n\t\t\t\t */\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we are at the end of the buffer, there is\n\t\t\t * no next line.\n\t\t\t */\n\t\t\tif (bufferp == bufferendp) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\n\t\tif ((*bufferp != '\\n') && (*bufferp != '#')) {\n\t\t\tfind_a_line = 1;\n\t\t}\n\t}\n\n\t*err = PAM_SUCCESS;\n\t/* now we find one line */\n\tif ((ll = pam_conf_strnchr(bufferp, '\\n', bufferendp - bufferp))\n\t    != NULL) {\n\t\tif ((input_len = ll - bufferp) >= sizeof (pam_fh->line)) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t    \"nextline[%d:%s]: pam.conf line too long %.256s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    bufferp);\n\t\t\tinput_len = sizeof (pam_fh->line) - 1;\n\t\t\t*err = PAM_SERVICE_ERR;\n\t\t}\n\t\t(void) strncpy(pam_fh->line, bufferp, input_len);\n\t\tpam_fh->line[input_len] = '\\0';\n\t\tpam_fh->bufferp = ll++;\n\t} else {\n\t\tll = bufferendp;\n\t\tif ((input_len = ll - bufferp) >= sizeof (pam_fh->line)) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t    \"nextline[%d:%s]: pam.conf line too long %.256s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    bufferp);\n\t\t\tinput_len = sizeof (pam_fh->line) - 1;\n\t\t\t*err = PAM_SERVICE_ERR;\n\t\t}\n\t\t(void) strncpy(pam_fh->line, bufferp, input_len);\n\t\tpam_fh->line[input_len] = '\\0';\n\t\tpam_fh->bufferp = ll;\n\t}\n\n\treturn (pam_fh->line);\n}\n\n/*\n * verify_pam_conf - verify that the pam_conf entry is filled in.\n *\n *\tTrue = Error if there is no service.\n *\tTrue = Error if there is a service and it matches the requested service\n *\t\tbut, the type, flag, line overflow, or path is in error.\n */\n\nstatic int\nverify_pam_conf(pamtab_t *pam, char *service)\n{\n\treturn ((pam->pam_service == (char *)NULL) ||\n\t    ((strcasecmp(pam->pam_service, service) == 0) &&\n\t    ((pam->pam_type == -1) ||\n\t    (pam->pam_flag == 0) ||\n\t    (pam->pam_err != PAM_SUCCESS) ||\n\t    (pam->module_path == (char *)NULL))));\n}\n\n/*\n * Routines to free allocated storage\n */\n\n/*\n * clean_up -  free allocated storage in the pam handle\n */\n\nstatic void\nclean_up(pam_handle_t *pamh)\n{\n\tint i;\n\tpam_repository_t *auth_rep;\n\n\tif (pamh) {\n\t\twhile (pamh->include_depth >= 0) {\n\t\t\tfree_pam_conf_info(pamh);\n\t\t\tpamh->include_depth--;\n\t\t}\n\n\t\t/* Cleanup PAM_REPOSITORY structure */\n\t\tauth_rep = pamh->ps_item[PAM_REPOSITORY].pi_addr;\n\t\tif (auth_rep != NULL) {\n\t\t\tif (auth_rep->type != NULL)\n\t\t\t\tfree(auth_rep->type);\n\t\t\tif (auth_rep->scope != NULL)\n\t\t\t\tfree(auth_rep->scope);\n\t\t}\n\n\t\tfor (i = 0; i < PAM_MAX_ITEMS; i++) {\n\t\t\tif (pamh->ps_item[i].pi_addr != NULL) {\n\t\t\t\tif (i == PAM_AUTHTOK || i == PAM_OLDAUTHTOK) {\n\t\t\t\t\t(void) memset(pamh->ps_item[i].pi_addr,\n\t\t\t\t\t    0, pamh->ps_item[i].pi_size);\n\t\t\t\t}\n\t\t\t\tfree(pamh->ps_item[i].pi_addr);\n\t\t\t}\n\t\t}\n\t\tfree(pamh);\n\t}\n}\n\n/*\n * free_pamconf - free memory used to store pam.conf entry\n */\n\nstatic void\nfree_pamconf(pamtab_t *cp)\n{\n\tint i;\n\n\tif (cp) {\n\t\tif (cp->pam_service)\n\t\t\tfree(cp->pam_service);\n\t\tif (cp->module_path)\n\t\t\tfree(cp->module_path);\n\t\tfor (i = 0; i < cp->module_argc; i++) {\n\t\t\tif (cp->module_argv[i])\n\t\t\t\tfree(cp->module_argv[i]);\n\t\t}\n\t\tif (cp->module_argc > 0)\n\t\t\tfree(cp->module_argv);\n\t\tif (cp->function_ptr)\n\t\t\tfree(cp->function_ptr);\n\n\t\tfree(cp);\n\t}\n}\n\n/*\n * free_pam_conf_info - free memory used to store all pam.conf info\n *\t\t\tunder the pam handle\n */\n\nstatic void\nfree_pam_conf_info(pam_handle_t *pamh)\n{\n\tpamtab_t *pamentp;\n\tpamtab_t *pament_trail;\n\tint i = pamh->include_depth;\n\tint j;\n\n\tfor (j = 0; j < PAM_NUM_MODULE_TYPES; j++) {\n\t\tpamentp = pamh->pam_conf_info[i][j];\n\t\tpamh->pam_conf_info[i][j] = NULL;\n\t\tpament_trail = pamentp;\n\t\twhile (pamentp) {\n\t\t\tpamentp = pamentp->next;\n\t\t\tfree_pamconf(pament_trail);\n\t\t\tpament_trail = pamentp;\n\t\t}\n\t}\n\tif (pamh->pam_conf_name[i] != NULL) {\n\t\tfree(pamh->pam_conf_name[i]);\n\t\tpamh->pam_conf_name[i] = NULL;\n\t}\n}\n\nstatic void\nfree_env(env_list *pam_env)\n{\n\tif (pam_env) {\n\t\tif (pam_env->name)\n\t\t\tfree(pam_env->name);\n\t\tif (pam_env->value)\n\t\t\tfree(pam_env->value);\n\t\tfree(pam_env);\n\t}\n}\n\n/*\n *\tInternal convenience functions for Solaris PAM service modules.\n */\n\n#include <libintl.h>\n#include <nl_types.h>\n#include <synch.h>\n#include <locale.h>\n#include <thread.h>\n\ntypedef struct pam_msg_data {\n\tnl_catd fd;\n} pam_msg_data_t;\n\n/*\n * free_resp():\n *\tfree storage for responses used in the call back \"pam_conv\" functions\n */\n\nvoid\nfree_resp(int num_msg, struct pam_response *resp)\n{\n\tint\t\t\ti;\n\tstruct pam_response\t*r;\n\n\tif (resp) {\n\t\tr = resp;\n\t\tfor (i = 0; i < num_msg; i++, r++) {\n\t\t\tif (r->resp) {\n\t\t\t\t/* clear before freeing -- may be a password */\n\t\t\t\tbzero(r->resp, strlen(r->resp));\n\t\t\t\tfree(r->resp);\n\t\t\t\tr->resp = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(resp);\n\t}\n}\n\nstatic int\ndo_conv(pam_handle_t *pamh, int msg_style, int num_msg,\n    char messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE], void *conv_apdp,\n    struct pam_response *ret_respp[])\n{\n\tstruct pam_message\t*msg;\n\tstruct pam_message\t*m;\n\tint\t\t\ti;\n\tint\t\t\tk;\n\tint\t\t\tretcode;\n\tstruct pam_conv\t\t*pam_convp;\n\n\tif ((retcode = pam_get_item(pamh, PAM_CONV,\n\t    (void **)&pam_convp)) != PAM_SUCCESS) {\n\t\treturn (retcode);\n\t}\n\n\t/*\n\t * When pam_set_item() is called to set PAM_CONV and the\n\t * item is NULL, memset(pip->pi_addr, 0, size) is called.\n\t * So at this point, we should check whether pam_convp->conv\n\t * is NULL or not.\n\t */\n\tif ((pam_convp == NULL) || (pam_convp->conv == NULL))\n\t\treturn (PAM_SYSTEM_ERR);\n\n\ti = 0;\n\tk = num_msg;\n\n\tmsg = calloc(num_msg, sizeof (struct pam_message));\n\tif (msg == NULL) {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\tm = msg;\n\n\twhile (k--) {\n\t\t/*\n\t\t * fill out the message structure to display prompt message\n\t\t */\n\t\tm->msg_style = msg_style;\n\t\tm->msg = messages[i];\n\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t    \"pam_conv_msg(%p:%d[%d]=%s)\",\n\t\t    (void *)pamh, msg_style, i, messages[i]);\n\t\tm++;\n\t\ti++;\n\t}\n\n\t/*\n\t * The UNIX pam modules always calls __pam_get_authtok() and\n\t * __pam_display_msg() with a NULL pointer as the conv_apdp.\n\t * In case the conv_apdp is NULL and the pam_convp->appdata_ptr\n\t * is not NULL, we should pass the pam_convp->appdata_ptr\n\t * to the conversation function.\n\t */\n\tif (conv_apdp == NULL && pam_convp->appdata_ptr != NULL)\n\t\tconv_apdp = pam_convp->appdata_ptr;\n\n\t/*\n\t * Call conv function to display the prompt.\n\t */\n\tretcode = (pam_convp->conv)(num_msg, &msg, ret_respp, conv_apdp);\n\tpam_trace(PAM_DEBUG_CONV,\n\t    \"pam_conv_resp(%p pam_conv = %s) ret_respp = %p\",\n\t    (void *)pamh, pam_strerror(pamh, retcode), (void *)ret_respp);\n\tif (*ret_respp == NULL) {\n\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t    \"pam_conv_resp(%p No response requested)\", (void *)pamh);\n\t} else if ((pam_debug & (PAM_DEBUG_CONV | PAM_DEBUG_AUTHTOK)) != 0) {\n\t\tstruct pam_response *r = *ret_respp;\n\n\t\tfor (i = 0; i < num_msg; i++, r++) {\n\t\t\tif (r->resp == NULL) {\n\t\t\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t\t\t    \"pam_conv_resp(%p:\"\n\t\t\t\t    \"[%d] NULL response string)\",\n\t\t\t\t    (void *)pamh, i);\n\t\t\t} else {\n\t\t\t\tif (msg_style == PAM_PROMPT_ECHO_OFF) {\n#ifdef\tDEBUG\n\t\t\t\t\tpam_trace(PAM_DEBUG_AUTHTOK,\n\t\t\t\t\t    \"pam_conv_resp(%p:[%d]=%s, \"\n\t\t\t\t\t    \"code=%d)\",\n\t\t\t\t\t    (void *)pamh, i, r->resp,\n\t\t\t\t\t    r->resp_retcode);\n#endif\t/* DEBUG */\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t\t\t\t    \"pam_conv_resp(%p:[%d] len=%lu, \"\n\t\t\t\t\t    \"code=%d)\",\n\t\t\t\t\t    (void *)pamh, i,\n\t\t\t\t\t    (ulong_t)strlen(r->resp),\n\t\t\t\t\t    r->resp_retcode);\n\t\t\t\t} else {\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t\t\t\t    \"pam_conv_resp(%p:[%d]=%s, \"\n\t\t\t\t\t    \"code=%d)\",\n\t\t\t\t\t    (void *)pamh, i, r->resp,\n\t\t\t\t\t    r->resp_retcode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (msg)\n\t\tfree(msg);\n\treturn (retcode);\n}\n\n/*\n * __pam_display_msg():\n *\tdisplay message by calling the call back functions\n *\tprovided by the application through \"pam_conv\" structure\n */\n\nint\n__pam_display_msg(pam_handle_t *pamh, int msg_style, int num_msg,\n    char messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE], void *conv_apdp)\n{\n\tstruct pam_response\t*ret_respp = NULL;\n\tint ret;\n\n\tret = do_conv(pamh, msg_style, num_msg, messages,\n\t    conv_apdp, &ret_respp);\n\n\tif (ret_respp != NULL)\n\t\tfree_resp(num_msg, ret_respp);\n\n\treturn (ret);\n}\n\n/*\n * __pam_get_authtok()\n *\tretrieves a password of at most PASS_MAX length from the pam\n *\thandle (pam_get_item) or from the input stream (do_conv).\n *\n * This function allocates memory for the new authtok.\n * Applications calling this function are responsible for\n * freeing this memory.\n *\n * If \"source\" is\n *\tPAM_HANDLE\n * and \"type\" is:\n *\tPAM_AUTHTOK - password is taken from pam handle (PAM_AUTHTOK)\n *\tPAM_OLDAUTHTOK - password is taken from pam handle (PAM_OLDAUTHTOK)\n *\n * If \"source\" is\n *\tPAM_PROMPT\n * and \"type\" is:\n *\t0:\t\tPrompt for new passwd, do not even attempt\n *\t\t\tto store it in the pam handle.\n *\tPAM_AUTHTOK:\tPrompt for new passwd, store in pam handle as\n *\t\t\tPAM_AUTHTOK item if this value is not already set.\n *\tPAM_OLDAUTHTOK:\tPrompt for new passwd, store in pam handle as\n *\t\t\tPAM_OLDAUTHTOK item if this value is not\n *\t\t\talready set.\n */\nint\n__pam_get_authtok(pam_handle_t *pamh, int source, int type, char *prompt,\n    char **authtok)\n{\n\tint error = PAM_SYSTEM_ERR;\n\tchar *new_password = NULL;\n\tstruct pam_response *ret_resp = NULL;\n\tchar messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE];\n\n\tif ((*authtok = calloc(PASS_MAX+1, sizeof (char))) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\n\tif (prompt == NULL)\n\t\tprompt = dgettext(TEXT_DOMAIN, \"password: \");\n\n\tswitch (source) {\n\tcase PAM_HANDLE:\n\n\t\t/* get password from pam handle item list */\n\n\t\tswitch (type) {\n\t\tcase PAM_AUTHTOK:\n\t\tcase PAM_OLDAUTHTOK:\n\n\t\t\tif ((error = pam_get_item(pamh, type,\n\t\t\t    (void **)&new_password)) != PAM_SUCCESS)\n\t\t\t\tgoto err_ret;\n\n\t\t\tif (new_password == NULL || new_password[0] == '\\0') {\n\t\t\t\tfree(*authtok);\n\t\t\t\t*authtok = NULL;\n\t\t\t} else {\n\t\t\t\t(void) strlcpy(*authtok, new_password,\n\t\t\t\t    PASS_MAX+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t    \"__pam_get_authtok() invalid type: %d\", type);\n\t\t\terror = PAM_SYMBOL_ERR;\n\t\t\tgoto err_ret;\n\t\t}\n\t\tbreak;\n\tcase PAM_PROMPT:\n\n\t\t/*\n\t\t * Prompt for new password and save in pam handle item list\n\t\t * if the that item is not already set.\n\t\t */\n\n\t\t(void) strncpy(messages[0], prompt, sizeof (messages[0]));\n\t\tif ((error = do_conv(pamh, PAM_PROMPT_ECHO_OFF, 1, messages,\n\t\t    NULL, &ret_resp)) != PAM_SUCCESS)\n\t\t\tgoto err_ret;\n\n\t\tif (ret_resp->resp == NULL) {\n\t\t\t/* getpass didn't return anything */\n\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\tgoto err_ret;\n\t\t}\n\n\t\t/* save the new password if this item was NULL */\n\t\tif (type) {\n\t\t\tif ((error = pam_get_item(pamh, type,\n\t\t\t    (void **)&new_password)) != PAM_SUCCESS) {\n\t\t\t\tfree_resp(1, ret_resp);\n\t\t\t\tgoto err_ret;\n\t\t\t}\n\t\t\tif (new_password == NULL)\n\t\t\t\t(void) pam_set_item(pamh, type, ret_resp->resp);\n\t\t}\n\n\t\t(void) strlcpy(*authtok, ret_resp->resp, PASS_MAX+1);\n\t\tfree_resp(1, ret_resp);\n\t\tbreak;\n\tdefault:\n\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t    \"__pam_get_authtok() invalid source: %d\", source);\n\t\terror = PAM_SYMBOL_ERR;\n\t\tgoto err_ret;\n\t}\n\n\treturn (PAM_SUCCESS);\n\nerr_ret:\n\tbzero(*authtok, PASS_MAX+1);\n\tfree(*authtok);\n\t*authtok = NULL;\n\treturn (error);\n}\n"], "fixing_code": ["/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n/*\n * Copyright 2020, Joyent, Inc.\n */\n\n#include <syslog.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <malloc.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#include <security/pam_appl.h>\n#include <security/pam_modules.h>\n#include <sys/mman.h>\n\n#include <libintl.h>\n\n#include \"pam_impl.h\"\n\nstatic char *pam_snames [PAM_NUM_MODULE_TYPES] = {\n\tPAM_ACCOUNT_NAME,\n\tPAM_AUTH_NAME,\n\tPAM_PASSWORD_NAME,\n\tPAM_SESSION_NAME\n};\n\nstatic char *pam_inames [PAM_MAX_ITEMS] = {\n/* NONE */\t\tNULL,\n/* PAM_SERVICE */\t\"service\",\n/* PAM_USER */\t\t\"user\",\n/* PAM_TTY */\t\t\"tty\",\n/* PAM_RHOST */\t\t\"rhost\",\n/* PAM_CONV */\t\t\"conv\",\n/* PAM_AUTHTOK */\t\"authtok\",\n/* PAM_OLDAUTHTOK */\t\"oldauthtok\",\n/* PAM_RUSER */\t\t\"ruser\",\n/* PAM_USER_PROMPT */\t\"user_prompt\",\n/* PAM_REPOSITORY */\t\"repository\",\n/* PAM_RESOURCE */\t\"resource\",\n/* PAM_AUSER */\t\t\"auser\",\n/* Undefined Items */\n};\n\n/*\n * This extra definition is needed in order to build this library\n * on pre-64-bit-aware systems.\n */\n#if !defined(_LFS64_LARGEFILE)\n#define\tstat64\tstat\n#endif\t/* !defined(_LFS64_LARGEFILE) */\n\n/* functions to dynamically load modules */\nstatic int\tload_modules(pam_handle_t *, int, char *, pamtab_t *);\nstatic void\t*open_module(pam_handle_t *, char *);\nstatic int\tload_function(void *, char *, int (**func)());\n\n/* functions to read and store the pam.conf configuration file */\nstatic int\topen_pam_conf(struct pam_fh **, pam_handle_t *, char *);\nstatic void\tclose_pam_conf(struct pam_fh *);\nstatic int\tread_pam_conf(pam_handle_t *, char *);\nstatic int\tget_pam_conf_entry(struct pam_fh *, pam_handle_t *,\n    pamtab_t **);\nstatic char\t*read_next_token(char **);\nstatic char\t*nextline(struct pam_fh *, pam_handle_t *, int *);\nstatic int\tverify_pam_conf(pamtab_t *, char *);\n\n/* functions to clean up and free memory */\nstatic void\tclean_up(pam_handle_t *);\nstatic void\tfree_pamconf(pamtab_t *);\nstatic void\tfree_pam_conf_info(pam_handle_t *);\nstatic void\tfree_env(env_list *);\n\n/* convenience functions for I18N/L10N communication */\n\nstatic void\tfree_resp(int, struct pam_response *);\nstatic int\tdo_conv(pam_handle_t *, int, int,\n    char messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE], void *,\n    struct pam_response **);\n\nstatic int\tlog_priority;\t/* pam_trace syslog priority & facility */\nstatic int\tpam_debug = 0;\n\nstatic char *\npam_trace_iname(int item_type, char *iname_buf)\n{\n\tchar *name;\n\n\tif (item_type <= 0 ||\n\t    item_type >= PAM_MAX_ITEMS ||\n\t    (name = pam_inames[item_type]) == NULL) {\n\t\t(void) sprintf(iname_buf, \"%d\", item_type);\n\t\treturn (iname_buf);\n\t}\n\treturn (name);\n}\n\nstatic char *\npam_trace_fname(int flag)\n{\n\tif (flag & PAM_BINDING)\n\t\treturn (PAM_BINDING_NAME);\n\tif (flag & PAM_INCLUDE)\n\t\treturn (PAM_INCLUDE_NAME);\n\tif (flag & PAM_OPTIONAL)\n\t\treturn (PAM_OPTIONAL_NAME);\n\tif (flag & PAM_REQUIRED)\n\t\treturn (PAM_REQUIRED_NAME);\n\tif (flag & PAM_REQUISITE)\n\t\treturn (PAM_REQUISITE_NAME);\n\tif (flag & PAM_SUFFICIENT)\n\t\treturn (PAM_SUFFICIENT_NAME);\n\treturn (\"bad flag name\");\n}\n\nstatic char *\npam_trace_cname(pam_handle_t *pamh)\n{\n\tif (pamh->pam_conf_name[pamh->include_depth] == NULL)\n\t\treturn (\"NULL\");\n\treturn (pamh->pam_conf_name[pamh->include_depth]);\n}\n\n#include <deflt.h>\n#include <stdarg.h>\n/*\n * pam_settrace - setup configuration for pam tracing\n *\n * turn on PAM debug if \"magic\" file exists\n * if exists (original), pam_debug = PAM_DEBUG_DEFAULT,\n * log_priority = LOG_DEBUG(7) and log_facility = LOG_AUTH(4).\n *\n * if has contents, keywork=value pairs:\n *\n *\t\"log_priority=\" 0-7, the pam_trace syslog priority to use\n *\t\t(see sys/syslog.h)\n *\t\"log_facility=\" 0-23, the pam_trace syslog facility to use\n *\t\t(see sys/syslog.h)\n *\t\"debug_flags=\" PAM_DEBUG_DEFAULT (0x0001), log traditional\n *\t\t\t(original) debugging.\n *\t\tPlus the logical or of:\n *\t\t    PAM_DEBUG_ITEM (0x0002), log item values and\n *\t\t\tpam_get_item.\n *\t\t    PAM_DEBUG_MODULE (0x0004), log module return status.\n *\t\t    PAM_DEBUG_CONF (0x0008), log pam.conf parsing.\n *\t\t    PAM_DEBUG_DATA (0x0010), get/set_data.\n *\t\t    PAM_DEBUG_CONV (0x0020), conversation/response.\n *\n *\t\t    If compiled with DEBUG:\n *\t\t    PAM_DEBUG_AUTHTOK (0x8000), display AUTHTOK value if\n *\t\t\t\tPAM_DEBUG_ITEM is set and results from\n *\t\t\t\tPAM_PROMPT_ECHO_OFF responses.\n *\t\t    USE CAREFULLY, THIS EXPOSES THE USER'S PASSWORDS.\n *\n *\t\tor set to 0 and off even if PAM_DEBUG file exists.\n *\n * Output has the general form:\n * <whatever was set syslog> PAM[<pid>]: <interface>(<handle> and other info)\n * <whatever was set syslog> PAM[<pid>]: details requested for <interface> call\n *\tWhere:\t<pid> is the process ID of the calling process.\n *\t\t<handle> is the Hex value of the pam_handle associated with the\n *\t\t\tcall.\n */\n\nstatic void\npam_settrace()\n{\n\tvoid\t*defp;\n\n\tif ((defp = defopen_r(PAM_DEBUG)) != NULL) {\n\t\tchar\t*arg;\n\t\tint\tcode;\n\t\tint\tfacility = LOG_AUTH;\n\n\t\tpam_debug = PAM_DEBUG_DEFAULT;\n\t\tlog_priority = LOG_DEBUG;\n\n\t\t(void) defcntl_r(DC_SETFLAGS, DC_CASE, defp);\n\t\tif ((arg = defread_r(LOG_PRIORITY, defp)) != NULL) {\n\t\t\tcode = (int)strtol(arg, NULL, 10);\n\t\t\tif ((code & ~LOG_PRIMASK) == 0) {\n\t\t\t\tlog_priority = code;\n\t\t\t}\n\t\t}\n\t\tif ((arg = defread_r(LOG_FACILITY, defp)) != NULL) {\n\t\t\tcode = (int)strtol(arg, NULL, 10);\n\t\t\tif (code < LOG_NFACILITIES) {\n\t\t\t\tfacility = code << 3;\n\t\t\t}\n\t\t}\n\t\tif ((arg = defread_r(DEBUG_FLAGS, defp)) != NULL) {\n\t\t\tpam_debug = (int)strtol(arg, NULL, 0);\n\t\t}\n\t\tdefclose_r(defp);\n\n\t\tlog_priority |= facility;\n\t}\n}\n\n/*\n * pam_trace - logs tracing messages\n *\n *\tflag = debug_flags from /etc/pam_debug\n *\tformat and args = message to print (PAM[<pid>]: is prepended).\n *\n *\tglobal log_priority = pam_trace syslog (log_priority | log_facility)\n *\t\tfrom /etc/pam_debug\n */\n/*PRINTFLIKE2*/\nstatic void\npam_trace(int flag, char *format, ...)\n{\n\tva_list args;\n\tchar message[1024];\n\tint savemask;\n\n\tif ((pam_debug & flag) == 0)\n\t\treturn;\n\n\tsavemask = setlogmask(LOG_MASK(log_priority & LOG_PRIMASK));\n\t(void) snprintf(message, sizeof (message), \"PAM[%ld]: %s\",\n\t    (long)getpid(), format);\n\tva_start(args, format);\n\t(void) vsyslog(log_priority, message, args);\n\tva_end(args);\n\t(void) setlogmask(savemask);\n}\n\n/*\n * __pam_log - logs PAM syslog messages\n *\n *\tpriority = message priority\n *\tformat and args = message to log\n */\n/*PRINTFLIKE2*/\nvoid\n__pam_log(int priority, const char *format, ...)\n{\n\tva_list args;\n\tint savemask = setlogmask(LOG_MASK(priority & LOG_PRIMASK));\n\n\tva_start(args, format);\n\t(void) vsyslog(priority, format, args);\n\tva_end(args);\n\t(void) setlogmask(savemask);\n}\n\n\n/*\n *\t\t\tpam_XXXXX routines\n *\n *\tThese are the entry points to the authentication switch\n */\n\n/*\n * pam_start\t\t- initiate an authentication transaction and\n *\t\t\t  set parameter values to be used during the\n *\t\t\t  transaction\n */\n\nint\npam_start(const char *service, const char *user,\n    const struct pam_conv *pam_conv, pam_handle_t **pamh)\n{\n\tint\terr;\n\n\t*pamh = calloc(1, sizeof (struct pam_handle));\n\n\tpam_settrace();\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_start(%s,%s,%p:%p) - debug = %x\",\n\t    service ? service : \"NULL\", user ? user : \"NULL\", (void *)pam_conv,\n\t    (void *)*pamh, pam_debug);\n\n\tif (*pamh == NULL)\n\t\treturn (PAM_BUF_ERR);\n\n\t(*pamh)->pam_inmodule = RO_OK;\t\t/* OK to set RO items */\n\tif ((err = pam_set_item(*pamh, PAM_SERVICE, (void *)service))\n\t    != PAM_SUCCESS) {\n\t\tclean_up(*pamh);\n\t\t*pamh = NULL;\n\t\treturn (err);\n\t}\n\n\tif ((err = pam_set_item(*pamh, PAM_USER, (void *)user))\n\t    != PAM_SUCCESS) {\n\t\tclean_up(*pamh);\n\t\t*pamh = NULL;\n\t\treturn (err);\n\t}\n\n\tif ((err = pam_set_item(*pamh, PAM_CONV, (void *)pam_conv))\n\t    != PAM_SUCCESS) {\n\t\tclean_up(*pamh);\n\t\t*pamh = NULL;\n\t\treturn (err);\n\t}\n\n\t(*pamh)->pam_inmodule = RW_OK;\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * pam_end - terminate an authentication transaction\n */\n\nint\npam_end(pam_handle_t *pamh, int pam_status)\n{\n\tstruct pam_module_data *psd, *p;\n\tfd_list *expired;\n\tfd_list *traverse;\n\tenv_list *env_expired;\n\tenv_list *env_traverse;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_end(%p): status = %s\", (void *)pamh,\n\t    pam_strerror(pamh, pam_status));\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\t/* call the cleanup routines for module specific data */\n\n\tpsd = pamh->ssd;\n\twhile (psd) {\n\t\tif (psd->cleanup) {\n\t\t\tpsd->cleanup(pamh, psd->data, pam_status);\n\t\t}\n\t\tp = psd;\n\t\tpsd = p->next;\n\t\tfree(p->module_data_name);\n\t\tfree(p);\n\t}\n\tpamh->ssd = NULL;\n\n\t/* dlclose all module fds */\n\ttraverse = pamh->fd;\n\twhile (traverse) {\n\t\texpired = traverse;\n\t\ttraverse = traverse->next;\n\t\t(void) dlclose(expired->mh);\n\t\tfree(expired);\n\t}\n\tpamh->fd = 0;\n\n\t/* remove all environment variables */\n\tenv_traverse = pamh->pam_env;\n\twhile (env_traverse) {\n\t\tenv_expired = env_traverse;\n\t\tenv_traverse = env_traverse->next;\n\t\tfree_env(env_expired);\n\t}\n\n\tclean_up(pamh);\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * pam_set_item\t\t- set the value of a parameter that can be\n *\t\t\t  retrieved via a call to pam_get_item()\n */\n\nint\npam_set_item(pam_handle_t *pamh, int item_type, const void *item)\n{\n\tstruct pam_item *pip;\n\tint\tsize;\n\tchar\tiname_buf[PAM_MAX_MSG_SIZE];\n\n\tif (((pam_debug & PAM_DEBUG_ITEM) == 0) || (pamh == NULL)) {\n\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t    \"pam_set_item(%p:%s)\", (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf));\n\t}\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\t/* check read only items */\n\tif ((item_type == PAM_SERVICE) && (pamh->pam_inmodule != RO_OK))\n\t\treturn (PAM_PERM_DENIED);\n\n\t/*\n\t * Check that item_type is within valid range\n\t */\n\n\tif (item_type <= 0 || item_type >= PAM_MAX_ITEMS)\n\t\treturn (PAM_SYMBOL_ERR);\n\n\tpip = &(pamh->ps_item[item_type]);\n\n\tswitch (item_type) {\n\tcase PAM_AUTHTOK:\n\tcase PAM_OLDAUTHTOK:\n\t\tif (pip->pi_addr != NULL)\n\t\t\t(void) memset(pip->pi_addr, 0, pip->pi_size);\n\t\t/*FALLTHROUGH*/\n\tcase PAM_SERVICE:\n\tcase PAM_USER:\n\tcase PAM_TTY:\n\tcase PAM_RHOST:\n\tcase PAM_RUSER:\n\tcase PAM_USER_PROMPT:\n\tcase PAM_RESOURCE:\n\tcase PAM_AUSER:\n\t\tif (pip->pi_addr != NULL) {\n\t\t\tfree(pip->pi_addr);\n\t\t}\n\n\t\tif (item == NULL) {\n\t\t\tpip->pi_addr = NULL;\n\t\t\tpip->pi_size = 0;\n\t\t} else {\n\t\t\tpip->pi_addr = strdup((char *)item);\n\t\t\tif (pip->pi_addr == NULL) {\n\t\t\t\tpip->pi_size = 0;\n\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t}\n\t\t\tpip->pi_size = strlen(pip->pi_addr);\n\t\t}\n\t\tbreak;\n\tcase PAM_CONV:\n\t\tif (pip->pi_addr != NULL)\n\t\t\tfree(pip->pi_addr);\n\t\tsize = sizeof (struct pam_conv);\n\t\tif ((pip->pi_addr = calloc(1, size)) == NULL)\n\t\t\treturn (PAM_BUF_ERR);\n\t\tif (item != NULL)\n\t\t\t(void) memcpy(pip->pi_addr, item, (unsigned int) size);\n\t\telse\n\t\t\t(void) memset(pip->pi_addr, 0, size);\n\t\tpip->pi_size = size;\n\t\tbreak;\n\tcase PAM_REPOSITORY:\n\t\tif (pip->pi_addr != NULL) {\n\t\t\tpam_repository_t *auth_rep;\n\n\t\t\tauth_rep = (pam_repository_t *)pip->pi_addr;\n\t\t\tif (auth_rep->type != NULL)\n\t\t\t\tfree(auth_rep->type);\n\t\t\tif (auth_rep->scope != NULL)\n\t\t\t\tfree(auth_rep->scope);\n\t\t\tfree(auth_rep);\n\t\t}\n\t\tif (item != NULL) {\n\t\t\tpam_repository_t *s, *d;\n\n\t\t\tsize = sizeof (struct pam_repository);\n\t\t\tpip->pi_addr = calloc(1, size);\n\t\t\tif (pip->pi_addr == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\n\t\t\ts = (struct pam_repository *)item;\n\t\t\td = (struct pam_repository *)pip->pi_addr;\n\n\t\t\td->type = strdup(s->type);\n\t\t\tif (d->type == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\td->scope = malloc(s->scope_len);\n\t\t\tif (d->scope == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t(void) memcpy(d->scope, s->scope, s->scope_len);\n\t\t\td->scope_len = s->scope_len;\n\t\t}\n\t\tpip->pi_size = size;\n\t\tbreak;\n\tdefault:\n\t\treturn (PAM_SYMBOL_ERR);\n\t}\n\tswitch (item_type) {\n\tcase PAM_CONV:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_set_item(%p:%s)=%p\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    item ? (void *)((struct pam_conv *)item)->conv :\n\t\t    (void *)0);\n\t\tbreak;\n\tcase PAM_REPOSITORY:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_set_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    item ? (((struct pam_repository *)item)->type ?\n\t\t    ((struct pam_repository *)item)->type : \"NULL\") :\n\t\t    \"NULL\");\n\t\tbreak;\n\tcase PAM_AUTHTOK:\n\tcase PAM_OLDAUTHTOK:\n#ifdef\tDEBUG\n\t\tif (pam_debug & PAM_DEBUG_AUTHTOK)\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_set_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    item ? (char *)item : \"NULL\");\n\t\telse\n#endif\t/* DEBUG */\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_set_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    item ? \"********\" : \"NULL\");\n\t\tbreak;\n\tdefault:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_set_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    item ? (char *)item : \"NULL\");\n\t}\n\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * pam_get_item\t\t- read the value of a parameter specified in\n *\t\t\t  the call to pam_set_item()\n */\n\nint\npam_get_item(const pam_handle_t *pamh, int item_type, void **item)\n{\n\tstruct pam_item *pip;\n\tchar\tiname_buf[PAM_MAX_MSG_SIZE];\n\n\tif (((pam_debug & PAM_DEBUG_ITEM) == 0) || (pamh == NULL)) {\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)\",\n\t\t    (void *)pamh, pam_trace_iname(item_type, iname_buf));\n\t}\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\tif (item_type <= 0 || item_type >= PAM_MAX_ITEMS)\n\t\treturn (PAM_SYMBOL_ERR);\n\n\tif ((pamh->pam_inmodule != WO_OK) &&\n\t    ((item_type == PAM_AUTHTOK || item_type == PAM_OLDAUTHTOK))) {\n\t\t__pam_log(LOG_AUTH | LOG_NOTICE, \"pam_get_item(%s) called from \"\n\t\t    \"a non module context\",\n\t\t    pam_trace_iname(item_type, iname_buf));\n\t\treturn (PAM_PERM_DENIED);\n\t}\n\n\tpip = (struct pam_item *)&(pamh->ps_item[item_type]);\n\n\t*item = pip->pi_addr;\n\tswitch (item_type) {\n\tcase PAM_CONV:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)=%p\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    (void *)((struct pam_conv *)*item)->conv);\n\t\tbreak;\n\tcase PAM_REPOSITORY:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    *item ? (((struct pam_repository *)*item)->type ?\n\t\t    ((struct pam_repository *)*item)->type : \"NULL\") :\n\t\t    \"NULL\");\n\t\tbreak;\n\tcase PAM_AUTHTOK:\n\tcase PAM_OLDAUTHTOK:\n#ifdef\tDEBUG\n\t\tif (pam_debug & PAM_DEBUG_AUTHTOK)\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_get_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    *item ? *(char **)item : \"NULL\");\n\t\telse\n#endif\t/* DEBUG */\n\t\t\tpam_trace(PAM_DEBUG_ITEM,\n\t\t\t    \"pam_get_item(%p:%s)=%s\", (void *)pamh,\n\t\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t\t    *item ? \"********\" : \"NULL\");\n\t\tbreak;\n\tdefault:\n\t\tpam_trace(PAM_DEBUG_ITEM, \"pam_get_item(%p:%s)=%s\",\n\t\t    (void *)pamh,\n\t\t    pam_trace_iname(item_type, iname_buf),\n\t\t    *item ? *(char **)item : \"NULL\");\n\t}\n\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * parse_user_name         - process the user response: ignore\n *                           '\\t' or ' ' before or after a user name.\n *                           user_input is a null terminated string.\n *                           *ret_username will be the user name.\n */\n\nstatic int\nparse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\n\t/* Set the default value for *ret_username */\n\t*ret_username = NULL;\n\n\t/*\n\t * Set the initial value for username - this is a buffer holds\n\t * the user name.\n\t */\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\n\t/*\n\t * The user_input is guaranteed to be terminated by a null character.\n\t */\n\tptr = user_input;\n\n\t/* Skip all the leading whitespaces if there are any. */\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\n\tif (*ptr == '\\0') {\n\t\t/*\n\t\t * We should never get here since the user_input we got\n\t\t * in pam_get_user() is not all whitespaces nor just \"\\0\".\n\t\t */\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\t/*\n\t * username will be the first string we get from user_input\n\t * - we skip leading whitespaces and ignore trailing whitespaces\n\t */\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t') ||\n\t\t    (index >= PAM_MAX_RESP_SIZE)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\t/* ret_username will be freed in pam_get_user(). */\n\tif (index >= PAM_MAX_RESP_SIZE ||\n\t    (*ret_username = strdup(username)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * Get the value of PAM_USER. If not set, then use the convenience function\n * to prompt for the user. Use prompt if specified, else use PAM_USER_PROMPT\n * if it is set, else use default.\n */\n#define\tWHITESPACE\t0\n#define\tUSERNAME\t1\n\nint\npam_get_user(pam_handle_t *pamh, char **user, const char *prompt_override)\n{\n\tint\tstatus;\n\tchar\t*prompt = NULL;\n\tchar    *real_username;\n\tstruct pam_response *ret_resp = NULL;\n\tchar messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE];\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_get_user(%p, %p, %s)\", (void *)pamh, (void *)*user,\n\t    prompt_override ? prompt_override : \"NULL\");\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\tif ((status = pam_get_item(pamh, PAM_USER, (void **)user))\n\t    != PAM_SUCCESS) {\n\t\treturn (status);\n\t}\n\n\t/* if the user is set, return it */\n\n\tif (*user != NULL && *user[0] != '\\0') {\n\t\treturn (PAM_SUCCESS);\n\t}\n\n\t/*\n\t * if the module is requesting a special prompt, use it.\n\t * else use PAM_USER_PROMPT.\n\t */\n\n\tif (prompt_override != NULL) {\n\t\tprompt = (char *)prompt_override;\n\t} else {\n\t\tstatus = pam_get_item(pamh, PAM_USER_PROMPT, (void**)&prompt);\n\t\tif (status != PAM_SUCCESS) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\t/* if the prompt is not set, use default */\n\n\tif (prompt == NULL || prompt[0] == '\\0') {\n\t\tprompt = dgettext(TEXT_DOMAIN, \"Please enter user name: \");\n\t}\n\n\t/* prompt for the user */\n\n\t(void) strncpy(messages[0], prompt, sizeof (messages[0]));\n\n\tfor (;;) {\n\t\tint state = WHITESPACE;\n\n\t\tstatus = do_conv(pamh, PAM_PROMPT_ECHO_ON, 1, messages,\n\t\t    NULL, &ret_resp);\n\n\t\tif (status != PAM_SUCCESS) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tif (ret_resp->resp && ret_resp->resp[0] != '\\0') {\n\t\t\tint len = strlen(ret_resp->resp);\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif ((ret_resp->resp[i] != ' ') &&\n\t\t\t\t    (ret_resp->resp[i] != '\\t')) {\n\t\t\t\t\tstate = USERNAME;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state == USERNAME)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* essentially empty response, try again */\n\t\tfree_resp(1, ret_resp);\n\t\tret_resp = NULL;\n\t}\n\n\t/* set PAM_USER */\n\t/* Parse the user input to get the user name. */\n\tstatus = parse_user_name(ret_resp->resp, &real_username);\n\n\tif (status != PAM_SUCCESS) {\n\t\tif (real_username != NULL)\n\t\t\tfree(real_username);\n\t\tfree_resp(1, ret_resp);\n\t\treturn (status);\n\t}\n\n\tstatus = pam_set_item(pamh, PAM_USER, real_username);\n\n\tfree(real_username);\n\n\tfree_resp(1, ret_resp);\n\tif (status != PAM_SUCCESS) {\n\t\treturn (status);\n\t}\n\n\t/*\n\t * finally, get PAM_USER. We have to call pam_get_item to get\n\t * the value of user because pam_set_item mallocs the memory.\n\t */\n\n\tstatus = pam_get_item(pamh, PAM_USER, (void**)user);\n\treturn (status);\n}\n\n/*\n * Set module specific data\n */\n\nint\npam_set_data(pam_handle_t *pamh, const char *module_data_name, void *data,\n    void (*cleanup)(pam_handle_t *pamh, void *data, int pam_end_status))\n{\n\tstruct pam_module_data *psd;\n\n\tpam_trace(PAM_DEBUG_DATA,\n\t    \"pam_set_data(%p:%s:%d)=%p\", (void *)pamh,\n\t    (module_data_name != NULL) ? module_data_name : \"NULL\",\n\t    (pamh != NULL) ? pamh->pam_inmodule : -1, data);\n\tif (pamh == NULL || (pamh->pam_inmodule != WO_OK) ||\n\t    module_data_name == NULL) {\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\t/* check if module data already exists */\n\n\tfor (psd = pamh->ssd; psd; psd = psd->next) {\n\t\tif (strcmp(psd->module_data_name, module_data_name) == 0) {\n\t\t\t/* clean up original data before setting the new data */\n\t\t\tif (psd->cleanup) {\n\t\t\t\tpsd->cleanup(pamh, psd->data, PAM_SUCCESS);\n\t\t\t}\n\t\t\tpsd->data = (void *)data;\n\t\t\tpsd->cleanup = cleanup;\n\t\t\treturn (PAM_SUCCESS);\n\t\t}\n\t}\n\n\tpsd = malloc(sizeof (struct pam_module_data));\n\tif (psd == NULL)\n\t\treturn (PAM_BUF_ERR);\n\n\tpsd->module_data_name = strdup(module_data_name);\n\tif (psd->module_data_name == NULL) {\n\t\tfree(psd);\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\tpsd->data = (void *)data;\n\tpsd->cleanup = cleanup;\n\tpsd->next = pamh->ssd;\n\tpamh->ssd = psd;\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * get module specific data\n */\n\nint\npam_get_data(const pam_handle_t *pamh, const char *module_data_name,\n    const void **data)\n{\n\tstruct pam_module_data *psd;\n\n\tif (pamh == NULL || (pamh->pam_inmodule != WO_OK) ||\n\t    module_data_name == NULL) {\n\t\tpam_trace(PAM_DEBUG_DATA,\n\t\t    \"pam_get_data(%p:%s:%d)=%p\", (void *)pamh,\n\t\t    module_data_name ? module_data_name : \"NULL\",\n\t\t    pamh->pam_inmodule, *data);\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\tfor (psd = pamh->ssd; psd; psd = psd->next) {\n\t\tif (strcmp(psd->module_data_name, module_data_name) == 0) {\n\t\t\t*data = psd->data;\n\t\t\tpam_trace(PAM_DEBUG_DATA,\n\t\t\t    \"pam_get_data(%p:%s)=%p\", (void *)pamh,\n\t\t\t    module_data_name, *data);\n\t\t\treturn (PAM_SUCCESS);\n\t\t}\n\t}\n\tpam_trace(PAM_DEBUG_DATA,\n\t    \"pam_get_data(%p:%s)=%s\", (void *)pamh, module_data_name,\n\t    \"PAM_NO_MODULE_DATA\");\n\n\treturn (PAM_NO_MODULE_DATA);\n}\n\n/*\n * PAM equivalent to strerror()\n */\n/* ARGSUSED */\nconst char *\npam_strerror(pam_handle_t *pamh, int errnum)\n{\n\tswitch (errnum) {\n\tcase PAM_SUCCESS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Success\"));\n\tcase PAM_OPEN_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Dlopen failure\"));\n\tcase PAM_SYMBOL_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Symbol not found\"));\n\tcase PAM_SERVICE_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Error in underlying service module\"));\n\tcase PAM_SYSTEM_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"System error\"));\n\tcase PAM_BUF_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Memory buffer error\"));\n\tcase PAM_CONV_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Conversation failure\"));\n\tcase PAM_PERM_DENIED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Permission denied\"));\n\tcase PAM_MAXTRIES:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Maximum number of attempts exceeded\"));\n\tcase PAM_AUTH_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Authentication failed\"));\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Get new authentication token\"));\n\tcase PAM_CRED_INSUFFICIENT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Insufficient credentials\"));\n\tcase PAM_AUTHINFO_UNAVAIL:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Can not retrieve authentication info\"));\n\tcase PAM_USER_UNKNOWN:\n\t\treturn (dgettext(TEXT_DOMAIN, \"No account present for user\"));\n\tcase PAM_CRED_UNAVAIL:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Can not retrieve user credentials\"));\n\tcase PAM_CRED_EXPIRED:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"User credentials have expired\"));\n\tcase PAM_CRED_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Failure setting user credentials\"));\n\tcase PAM_ACCT_EXPIRED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"User account has expired\"));\n\tcase PAM_AUTHTOK_EXPIRED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"User password has expired\"));\n\tcase PAM_SESSION_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Can not make/remove entry for session\"));\n\tcase PAM_AUTHTOK_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token manipulation error\"));\n\tcase PAM_AUTHTOK_RECOVERY_ERR:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token can not be recovered\"));\n\tcase PAM_AUTHTOK_LOCK_BUSY:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token lock busy\"));\n\tcase PAM_AUTHTOK_DISABLE_AGING:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Authentication token aging disabled\"));\n\tcase PAM_NO_MODULE_DATA:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Module specific data not found\"));\n\tcase PAM_IGNORE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Ignore module\"));\n\tcase PAM_ABORT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"General PAM failure \"));\n\tcase PAM_TRY_AGAIN:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"Unable to complete operation. Try again\"));\n\tdefault:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Unknown error\"));\n\t}\n}\n\nstatic void *\nsm_name(int ind)\n{\n\tswitch (ind) {\n\tcase PAM_AUTHENTICATE:\n\t\treturn (PAM_SM_AUTHENTICATE);\n\tcase PAM_SETCRED:\n\t\treturn (PAM_SM_SETCRED);\n\tcase PAM_ACCT_MGMT:\n\t\treturn (PAM_SM_ACCT_MGMT);\n\tcase PAM_OPEN_SESSION:\n\t\treturn (PAM_SM_OPEN_SESSION);\n\tcase PAM_CLOSE_SESSION:\n\t\treturn (PAM_SM_CLOSE_SESSION);\n\tcase PAM_CHAUTHTOK:\n\t\treturn (PAM_SM_CHAUTHTOK);\n\t}\n\treturn (NULL);\n}\n\nstatic int\n(*func(pamtab_t *modulep, int ind))()\n{\n\tvoid\t*funcp;\n\n\tif ((funcp = modulep->function_ptr) == NULL)\n\t\treturn (NULL);\n\n\tswitch (ind) {\n\tcase PAM_AUTHENTICATE:\n\t\treturn (((struct auth_module *)funcp)->pam_sm_authenticate);\n\tcase PAM_SETCRED:\n\t\treturn (((struct auth_module *)funcp)->pam_sm_setcred);\n\tcase PAM_ACCT_MGMT:\n\t\treturn (((struct account_module *)funcp)->pam_sm_acct_mgmt);\n\tcase PAM_OPEN_SESSION:\n\t\treturn (((struct session_module *)funcp)->pam_sm_open_session);\n\tcase PAM_CLOSE_SESSION:\n\t\treturn (((struct session_module *)funcp)->pam_sm_close_session);\n\tcase PAM_CHAUTHTOK:\n\t\treturn (((struct password_module *)funcp)->pam_sm_chauthtok);\n\t}\n\treturn (NULL);\n}\n\n/*\n * Run through the PAM service module stack for the given module type.\n */\nstatic int\nrun_stack(pam_handle_t *pamh, int flags, int type, int def_err, int ind,\n    char *function_name)\n{\n\tint\terr = PAM_SYSTEM_ERR;  /* preset */\n\tint\toptional_error = 0;\n\tint\trequired_error = 0;\n\tint\tsuccess = 0;\n\tpamtab_t *modulep;\n\tint\t(*sm_func)();\n\n\tif (pamh == NULL)\n\t\treturn (PAM_SYSTEM_ERR);\n\n\t/* read initial entries from pam.conf */\n\tif ((err = read_pam_conf(pamh, PAM_CONFIG)) != PAM_SUCCESS) {\n\t\treturn (err);\n\t}\n\n\tif ((modulep =\n\t    pamh->pam_conf_info[pamh->include_depth][type]) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"%s no initial module present\",\n\t\t    pam_trace_cname(pamh));\n\t\tgoto exit_return;\n\t}\n\n\tpamh->pam_inmodule = WO_OK;\t/* OK to get AUTHTOK */\ninclude:\n\tpam_trace(PAM_DEBUG_MODULE,\n\t    \"[%d:%s]:run_stack:%s(%p, %x): %s\", pamh->include_depth,\n\t    pam_trace_cname(pamh), function_name, (void *)pamh, flags,\n\t    modulep ? modulep->module_path : \"NULL\");\n\n\twhile (modulep != NULL) {\n\t\tif (modulep->pam_flag & PAM_INCLUDE) {\n\t\t\t/* save the return location */\n\t\t\tpamh->pam_conf_modulep[pamh->include_depth] =\n\t\t\t    modulep->next;\n\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t    \"setting for include[%d:%p]\",\n\t\t\t    pamh->include_depth, (void *)modulep->next);\n\t\t\tif (pamh->include_depth++ >= PAM_MAX_INCLUDE) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"run_stack: includes too deep %d \"\n\t\t\t\t    \"found trying to include %s from %s, %d \"\n\t\t\t\t    \"allowed\", pamh->include_depth,\n\t\t\t\t    modulep->module_path, pamh->pam_conf_name\n\t\t\t\t    [PAM_MAX_INCLUDE] == NULL ? \"NULL\" :\n\t\t\t\t    pamh->pam_conf_name[PAM_MAX_INCLUDE],\n\t\t\t\t    PAM_MAX_INCLUDE);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif ((err = read_pam_conf(pamh,\n\t\t\t    modulep->module_path)) != PAM_SUCCESS) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"run_stack[%d:%s]: can't read included \"\n\t\t\t\t    \"conf %s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    modulep->module_path);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif ((modulep = pamh->pam_conf_info\n\t\t\t    [pamh->include_depth][type]) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"run_stack[%d:%s]: no include module \"\n\t\t\t\t    \"present %s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh), function_name);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif (modulep->pam_flag & PAM_INCLUDE) {\n\t\t\t\t/* first line another include */\n\t\t\t\tgoto include;\n\t\t\t}\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT, \"include[%d:%s]\"\n\t\t\t    \"(%p, %s)=%s\", pamh->include_depth,\n\t\t\t    pam_trace_cname(pamh), (void *)pamh,\n\t\t\t    function_name, modulep->module_path);\n\t\t\tif ((err = load_modules(pamh, type, sm_name(ind),\n\t\t\t    pamh->pam_conf_info\n\t\t\t    [pamh->include_depth][type])) != PAM_SUCCESS) {\n\t\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t\t    \"[%d:%s]:%s(%p, %x): load_modules failed\",\n\t\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t\t    function_name, (void *)pamh, flags);\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t\tif ((modulep = pamh->pam_conf_info\n\t\t\t    [pamh->include_depth][type]) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"%s no initial module present\",\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\tgoto exit_return;\n\t\t\t}\n\t\t} else if ((err = load_modules(pamh, type, sm_name(ind),\n\t\t    modulep)) != PAM_SUCCESS) {\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t    \"[%d:%s]:%s(%p, %x): load_modules failed\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    function_name, (void *)pamh, flags);\n\t\t\tgoto exit_return;\n\t\t}  /* PAM_INCLUDE */\n\t\tsm_func = func(modulep, ind);\n\t\tif (sm_func) {\n\t\t\terr = sm_func(pamh, flags, modulep->module_argc,\n\t\t\t    (const char **)modulep->module_argv);\n\n\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t    \"[%d:%s]:%s(%p, %x): %s returned %s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t    modulep->module_path, pam_strerror(pamh, err));\n\n\t\t\tswitch (err) {\n\t\t\tcase PAM_IGNORE:\n\t\t\t\t/* do nothing */\n\t\t\t\tbreak;\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tif ((modulep->pam_flag & PAM_SUFFI_BIND) &&\n\t\t\t\t    !required_error) {\n\t\t\t\t\tpamh->pam_inmodule = RW_OK;\n\t\t\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t\t\t    \"[%d:%s]:%s(%p, %x): %s: success\",\n\t\t\t\t\t    pamh->include_depth,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t\t    (modulep->pam_flag & PAM_BINDING) ?\n\t\t\t\t\t    PAM_BINDING_NAME :\n\t\t\t\t\t    PAM_SUFFICIENT_NAME);\n\t\t\t\t\tgoto exit_return;\n\t\t\t\t}\n\t\t\t\tsuccess = 1;\n\t\t\t\tbreak;\n\t\t\tcase PAM_TRY_AGAIN:\n\t\t\t\t/*\n\t\t\t\t * We need to return immediately, and\n\t\t\t\t * we shouldn't reset the AUTHTOK item\n\t\t\t\t * since it is not an error per-se.\n\t\t\t\t */\n\t\t\t\tpamh->pam_inmodule = RW_OK;\n\t\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t\t    \"[%d:%s]:%s(%p, %x): TRY_AGAIN: %s\",\n\t\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t    pam_strerror(pamh, required_error ?\n\t\t\t\t    required_error : err));\n\t\t\t\terr = required_error ? required_error : err;\n\t\t\t\tgoto exit_return;\n\t\t\tdefault:\n\t\t\t\tif (modulep->pam_flag & PAM_REQUISITE) {\n\t\t\t\t\tpamh->pam_inmodule = RW_OK;\n\t\t\t\t\tpam_trace(PAM_DEBUG_MODULE,\n\t\t\t\t\t    \"[%d:%s]:%s(%p, %x): requisite: %s\",\n\t\t\t\t\t    pamh->include_depth,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t\t    pam_strerror(pamh,\n\t\t\t\t\t    required_error ? required_error :\n\t\t\t\t\t    err));\n\t\t\t\t\terr = required_error ?\n\t\t\t\t\t    required_error : err;\n\t\t\t\t\tgoto exit_return;\n\t\t\t\t} else if (modulep->pam_flag & PAM_REQRD_BIND) {\n\t\t\t\t\tif (!required_error)\n\t\t\t\t\t\trequired_error = err;\n\t\t\t\t} else {\n\t\t\t\t\tif (!optional_error)\n\t\t\t\t\t\toptional_error = err;\n\t\t\t\t}\n\t\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t\t    \"[%d:%s]:%s(%p, %x): error %s\",\n\t\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t\t    function_name, (void *)pamh, flags,\n\t\t\t\t    pam_strerror(pamh, err));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmodulep = modulep->next;\n\t}\n\n\tpam_trace(PAM_DEBUG_MODULE, \"[%d:%s]:stack_end:%s(%p, %x): %s %s: %s\",\n\t    pamh->include_depth, pam_trace_cname(pamh), function_name,\n\t    (void *)pamh, flags, pamh->include_depth ? \"included\" : \"final\",\n\t    required_error ? \"required\" : success ? \"success\" :\n\t    optional_error ? \"optional\" : \"default\",\n\t    pam_strerror(pamh, required_error ? required_error :\n\t    success ? PAM_SUCCESS : optional_error ? optional_error : def_err));\n\tif (pamh->include_depth > 0) {\n\t\tfree_pam_conf_info(pamh);\n\t\tpamh->include_depth--;\n\t\t/* continue at next entry */\n\t\tmodulep = pamh->pam_conf_modulep[pamh->include_depth];\n\t\tpam_trace(PAM_DEBUG_MODULE, \"looping for include[%d:%p]\",\n\t\t    pamh->include_depth, (void *)modulep);\n\t\tgoto include;\n\t}\n\tfree_pam_conf_info(pamh);\n\tpamh->pam_inmodule = RW_OK;\n\tif (required_error != 0)\n\t\treturn (required_error);\n\telse if (success != 0)\n\t\treturn (PAM_SUCCESS);\n\telse if (optional_error != 0)\n\t\treturn (optional_error);\n\telse\n\t\treturn (def_err);\n\nexit_return:\n\t/*\n\t * All done at whatever depth we're at.\n\t * Go back to not having read /etc/pam.conf\n\t */\n\twhile (pamh->include_depth > 0) {\n\t\tfree_pam_conf_info(pamh);\n\t\tpamh->include_depth--;\n\t}\n\tfree_pam_conf_info(pamh);\n\tpamh->pam_inmodule = RW_OK;\n\treturn (err);\n}\n\n/*\n * pam_authenticate - authenticate a user\n */\n\nint\npam_authenticate(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_AUTH_MODULE, PAM_AUTH_ERR,\n\t    PAM_AUTHENTICATE, \"pam_authenticate\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_setcred - modify or retrieve user credentials\n */\n\nint\npam_setcred(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_AUTH_MODULE, PAM_CRED_ERR,\n\t    PAM_SETCRED, \"pam_setcred\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_acct_mgmt - check password aging, account expiration\n */\n\nint\npam_acct_mgmt(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_ACCOUNT_MODULE, PAM_ACCT_EXPIRED,\n\t    PAM_ACCT_MGMT, \"pam_acct_mgmt\");\n\n\tif (retval != PAM_SUCCESS &&\n\t    retval != PAM_NEW_AUTHTOK_REQD) {\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\t}\n\treturn (retval);\n}\n\n/*\n * pam_open_session - begin session management\n */\n\nint\npam_open_session(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_SESSION_MODULE, PAM_SESSION_ERR,\n\t    PAM_OPEN_SESSION, \"pam_open_session\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_close_session - terminate session management\n */\n\nint\npam_close_session(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\tretval = run_stack(pamh, flags, PAM_SESSION_MODULE, PAM_SESSION_ERR,\n\t    PAM_CLOSE_SESSION, \"pam_close_session\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\treturn (retval);\n}\n\n/*\n * pam_chauthtok - change user authentication token\n */\n\nint\npam_chauthtok(pam_handle_t *pamh, int flags)\n{\n\tint\tretval;\n\n\t/* do not let apps use PAM_PRELIM_CHECK or PAM_UPDATE_AUTHTOK */\n\tif (flags & (PAM_PRELIM_CHECK | PAM_UPDATE_AUTHTOK)) {\n\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t    \"pam_chauthtok(%p, %x): %s\", (void *)pamh, flags,\n\t\t    pam_strerror(pamh, PAM_SYMBOL_ERR));\n\t\treturn (PAM_SYMBOL_ERR);\n\t}\n\n\t/* 1st pass: PRELIM CHECK */\n\tretval = run_stack(pamh, flags | PAM_PRELIM_CHECK, PAM_PASSWORD_MODULE,\n\t    PAM_AUTHTOK_ERR, PAM_CHAUTHTOK, \"pam_chauthtok-prelim\");\n\n\tif (retval == PAM_TRY_AGAIN)\n\t\treturn (retval);\n\n\tif (retval != PAM_SUCCESS) {\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\t\treturn (retval);\n\t}\n\n\t/* 2nd pass: UPDATE AUTHTOK */\n\tretval = run_stack(pamh, flags | PAM_UPDATE_AUTHTOK,\n\t    PAM_PASSWORD_MODULE, PAM_AUTHTOK_ERR, PAM_CHAUTHTOK,\n\t    \"pam_chauthtok-update\");\n\n\tif (retval != PAM_SUCCESS)\n\t\t(void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n\n\treturn (retval);\n}\n\n/*\n * pam_putenv - add an environment variable to the PAM handle\n *\tif name_value == 'NAME=VALUE'\tthen set variable to the value\n *\tif name_value == 'NAME='\tthen set variable to an empty value\n *\tif name_value == 'NAME'\t\tthen delete the variable\n */\n\nint\npam_putenv(pam_handle_t *pamh, const char *name_value)\n{\n\tint\t\terror = PAM_SYSTEM_ERR;\n\tchar\t\t*equal_sign = 0;\n\tchar\t\t*name = NULL, *value = NULL, *tmp_value = NULL;\n\tenv_list\t*traverse, *trail;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_putenv(%p, %s)\", (void *)pamh,\n\t    name_value ? name_value : \"NULL\");\n\n\tif (pamh == NULL || name_value == NULL)\n\t\tgoto out;\n\n\t/* see if we were passed 'NAME=VALUE', 'NAME=', or 'NAME' */\n\tif ((equal_sign = strchr(name_value, '=')) != 0) {\n\t\tif ((name = calloc(equal_sign - name_value + 1,\n\t\t    sizeof (char))) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\t(void) strncpy(name, name_value, equal_sign - name_value);\n\t\tif ((value = strdup(++equal_sign)) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((name = strdup(name_value)) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* check to see if we already have this variable in the PAM handle */\n\ttraverse = pamh->pam_env;\n\ttrail = traverse;\n\twhile (traverse && strncmp(traverse->name, name, strlen(name))) {\n\t\ttrail = traverse;\n\t\ttraverse = traverse->next;\n\t}\n\n\tif (traverse) {\n\t\t/* found a match */\n\t\tif (value == 0) {\n\t\t\t/* remove the env variable */\n\t\t\tif (pamh->pam_env == traverse)\n\t\t\t\tpamh->pam_env = traverse->next;\n\t\t\telse\n\t\t\t\ttrail->next = traverse->next;\n\t\t\tfree_env(traverse);\n\t\t} else if (strlen(value) == 0) {\n\t\t\t/* set env variable to empty value */\n\t\t\tif ((tmp_value = strdup(\"\")) == 0) {\n\t\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(traverse->value);\n\t\t\ttraverse->value = tmp_value;\n\t\t} else {\n\t\t\t/* set the new value */\n\t\t\tif ((tmp_value = strdup(value)) == 0) {\n\t\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(traverse->value);\n\t\t\ttraverse->value = tmp_value;\n\t\t}\n\n\t} else if (traverse == 0 && value) {\n\t\t/*\n\t\t * could not find a match in the PAM handle.\n\t\t * add the new value if there is one\n\t\t */\n\t\tif ((traverse = calloc(1, sizeof (env_list))) == 0) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((traverse->name = strdup(name)) == 0) {\n\t\t\tfree_env(traverse);\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((traverse->value = strdup(value)) == 0) {\n\t\t\tfree_env(traverse);\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (trail == 0) {\n\t\t\t/* new head of list */\n\t\t\tpamh->pam_env = traverse;\n\t\t} else {\n\t\t\t/* adding to end of list */\n\t\t\ttrail->next = traverse;\n\t\t}\n\t}\n\n\terror = PAM_SUCCESS;\nout:\n\tif (error != PAM_SUCCESS) {\n\t\tif (traverse) {\n\t\t\tif (traverse->name)\n\t\t\t\tfree(traverse->name);\n\t\t\tif (traverse->value)\n\t\t\t\tfree(traverse->value);\n\t\t\tfree(traverse);\n\t\t}\n\t}\n\tif (name)\n\t\tfree(name);\n\tif (value)\n\t\tfree(value);\n\treturn (error);\n}\n\n/*\n * pam_getenv - retrieve an environment variable from the PAM handle\n */\nchar *\npam_getenv(pam_handle_t *pamh, const char *name)\n{\n\tint\t\terror = PAM_SYSTEM_ERR;\n\tenv_list\t*traverse;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_getenv(%p, %p)\", (void *)pamh, (void *)name);\n\n\tif (pamh == NULL || name == NULL)\n\t\tgoto out;\n\n\t/* check to see if we already have this variable in the PAM handle */\n\ttraverse = pamh->pam_env;\n\twhile (traverse && strncmp(traverse->name, name, strlen(name))) {\n\t\ttraverse = traverse->next;\n\t}\n\terror = (traverse ? PAM_SUCCESS : PAM_SYSTEM_ERR);\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_getenv(%p, %s)=%s\", (void *)pamh, name,\n\t    traverse ? traverse->value : \"NULL\");\nout:\n\treturn (error ? NULL : strdup(traverse->value));\n}\n\n/*\n * pam_getenvlist - retrieve all environment variables from the PAM handle\n *                  in a NULL terminated array. On error, return NULL.\n */\nchar **\npam_getenvlist(pam_handle_t *pamh)\n{\n\tint\t\terror = PAM_SYSTEM_ERR;\n\tchar\t\t**list = 0;\n\tint\t\tlength = 0;\n\tenv_list\t*traverse;\n\tchar\t\t*tenv;\n\tsize_t\t\ttenv_size;\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"pam_getenvlist(%p)\", (void *)pamh);\n\n\tif (pamh == NULL)\n\t\tgoto out;\n\n\t/* find out how many environment variables we have */\n\ttraverse = pamh->pam_env;\n\twhile (traverse) {\n\t\tlength++;\n\t\ttraverse = traverse->next;\n\t}\n\n\t/* allocate the array we will return to the caller */\n\tif ((list = calloc(length + 1, sizeof (char *))) == NULL) {\n\t\terror = PAM_BUF_ERR;\n\t\tgoto out;\n\t}\n\n\t/* add the variables one by one */\n\tlength = 0;\n\ttraverse = pamh->pam_env;\n\twhile (traverse != NULL) {\n\t\ttenv_size = strlen(traverse->name) +\n\t\t    strlen(traverse->value) + 2; /* name=val\\0 */\n\t\tif ((tenv = malloc(tenv_size)) == NULL) {\n\t\t\terror = PAM_BUF_ERR;\n\t\t\tgoto out;\n\t\t}\n\t\t/*LINTED*/\n\t\t(void) sprintf(tenv, \"%s=%s\", traverse->name, traverse->value);\n\t\tlist[length++] = tenv;\n\t\ttraverse = traverse->next;\n\t}\n\tlist[length] = NULL;\n\n\terror = PAM_SUCCESS;\nout:\n\tif (error != PAM_SUCCESS) {\n\t\t/* free the partially constructed list */\n\t\tif (list) {\n\t\t\tlength = 0;\n\t\t\twhile (list[length] != NULL) {\n\t\t\t\tfree(list[length]);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tfree(list);\n\t\t}\n\t}\n\treturn (error ? NULL : list);\n}\n\n/*\n * Routines to load a requested module on demand\n */\n\n/*\n * load_modules - load the requested module.\n *\t\t  if the dlopen or dlsym fail, then\n *\t\t  the module is ignored.\n */\n\nstatic int\nload_modules(pam_handle_t *pamh, int type, char *function_name,\n    pamtab_t *pam_entry)\n{\n\tvoid\t*mh;\n\tstruct\tauth_module *authp;\n\tstruct\taccount_module *accountp;\n\tstruct\tsession_module *sessionp;\n\tstruct\tpassword_module *passwdp;\n\tint\tloading_functions = 0; /* are we currently loading functions? */\n\n\tpam_trace(PAM_DEBUG_MODULE, \"load_modules[%d:%s](%p, %s)=%s:%s\",\n\t    pamh->include_depth, pam_trace_cname(pamh), (void *)pamh,\n\t    function_name, pam_trace_fname(pam_entry->pam_flag),\n\t    pam_entry->module_path);\n\n\twhile (pam_entry != NULL) {\n\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t    \"while load_modules[%d:%s](%p, %s)=%s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), (void *)pamh,\n\t\t    function_name, pam_entry->module_path);\n\n\t\tif (pam_entry->pam_flag & PAM_INCLUDE) {\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t    \"done load_modules[%d:%s](%p, %s)=%s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    (void *)pamh, function_name,\n\t\t\t    pam_entry->module_path);\n\t\t\treturn (PAM_SUCCESS);\n\t\t}\n\t\tswitch (type) {\n\t\tcase PAM_AUTH_MODULE:\n\n\t\t\t/* if the function has already been loaded, return */\n\t\t\tauthp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (((strcmp(function_name, PAM_SM_AUTHENTICATE)\n\t\t\t    == 0) && authp && authp->pam_sm_authenticate) ||\n\t\t\t    ((strcmp(function_name, PAM_SM_SETCRED) == 0) &&\n\t\t\t    authp && authp->pam_sm_setcred))) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\t/* function has not been loaded yet */\n\t\t\tloading_functions = 1;\n\t\t\tif (authp == NULL) {\n\t\t\t\tauthp = calloc(1, sizeof (struct auth_module));\n\t\t\t\tif (authp == NULL)\n\t\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t}\n\n\t\t\t/* if open_module fails, return error */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(authp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\t/* load the authentication function */\n\t\t\tif (strcmp(function_name, PAM_SM_AUTHENTICATE) == 0) {\n\t\t\t\tif (load_function(mh, PAM_SM_AUTHENTICATE,\n\t\t\t\t    &authp->pam_sm_authenticate)\n\t\t\t\t    != PAM_SUCCESS) {\n\t\t\t\t\t/* return error if dlsym fails */\n\t\t\t\t\tfree(authp);\n\t\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t\t}\n\n\t\t\t/* load the setcred function */\n\t\t\t} else if (strcmp(function_name, PAM_SM_SETCRED) == 0) {\n\t\t\t\tif (load_function(mh, PAM_SM_SETCRED,\n\t\t\t\t    &authp->pam_sm_setcred) != PAM_SUCCESS) {\n\t\t\t\t\t/* return error if dlsym fails */\n\t\t\t\t\tfree(authp);\n\t\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpam_entry->function_ptr = authp;\n\t\t\tbreak;\n\t\tcase PAM_ACCOUNT_MODULE:\n\t\t\taccountp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (strcmp(function_name, PAM_SM_ACCT_MGMT) == 0) &&\n\t\t\t    accountp && accountp->pam_sm_acct_mgmt) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If functions are added to the account module,\n\t\t\t * verify that one of the other functions hasn't\n\t\t\t * already loaded it.  See PAM_AUTH_MODULE code.\n\t\t\t */\n\t\t\tloading_functions = 1;\n\t\t\taccountp = calloc(1, sizeof (struct account_module));\n\t\t\tif (accountp == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\n\t\t\t/* if open_module fails, return error */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(accountp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\tif (load_function(mh, PAM_SM_ACCT_MGMT,\n\t\t\t    &accountp->pam_sm_acct_mgmt) != PAM_SUCCESS) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: pam_sm_acct_mgmt() \"\n\t\t\t\t    \"missing\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\tfree(accountp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t}\n\t\t\tpam_entry->function_ptr = accountp;\n\t\t\tbreak;\n\t\tcase PAM_SESSION_MODULE:\n\t\t\tsessionp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (((strcmp(function_name,\n\t\t\t    PAM_SM_OPEN_SESSION) == 0) &&\n\t\t\t    sessionp && sessionp->pam_sm_open_session) ||\n\t\t\t    ((strcmp(function_name,\n\t\t\t    PAM_SM_CLOSE_SESSION) == 0) &&\n\t\t\t    sessionp && sessionp->pam_sm_close_session))) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\tloading_functions = 1;\n\t\t\tif (sessionp == NULL) {\n\t\t\t\tsessionp = calloc(1,\n\t\t\t\t    sizeof (struct session_module));\n\t\t\t\tif (sessionp == NULL)\n\t\t\t\t\treturn (PAM_BUF_ERR);\n\t\t\t}\n\n\t\t\t/* if open_module fails, return error */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(sessionp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\tif ((strcmp(function_name, PAM_SM_OPEN_SESSION) == 0) &&\n\t\t\t    load_function(mh, PAM_SM_OPEN_SESSION,\n\t\t\t    &sessionp->pam_sm_open_session) != PAM_SUCCESS) {\n\t\t\t\tfree(sessionp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t} else if ((strcmp(function_name,\n\t\t\t    PAM_SM_CLOSE_SESSION) == 0) &&\n\t\t\t    load_function(mh, PAM_SM_CLOSE_SESSION,\n\t\t\t    &sessionp->pam_sm_close_session) != PAM_SUCCESS) {\n\t\t\t\tfree(sessionp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t}\n\t\t\tpam_entry->function_ptr = sessionp;\n\t\t\tbreak;\n\t\tcase PAM_PASSWORD_MODULE:\n\t\t\tpasswdp = pam_entry->function_ptr;\n\t\t\tif (!loading_functions &&\n\t\t\t    (strcmp(function_name, PAM_SM_CHAUTHTOK) == 0) &&\n\t\t\t    passwdp && passwdp->pam_sm_chauthtok) {\n\t\t\t\treturn (PAM_SUCCESS);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If functions are added to the password module,\n\t\t\t * verify that one of the other functions hasn't\n\t\t\t * already loaded it.  See PAM_AUTH_MODULE code.\n\t\t\t */\n\t\t\tloading_functions = 1;\n\t\t\tpasswdp = calloc(1, sizeof (struct password_module));\n\t\t\tif (passwdp == NULL)\n\t\t\t\treturn (PAM_BUF_ERR);\n\n\t\t\t/* if open_module fails, continue */\n\t\t\tif ((mh = open_module(pamh,\n\t\t\t    pam_entry->module_path)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"load_modules[%d:%s]: can not open module \"\n\t\t\t\t    \"%s\", pamh->include_depth,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_entry->module_path);\n\t\t\t\tfree(passwdp);\n\t\t\t\treturn (PAM_OPEN_ERR);\n\t\t\t}\n\n\t\t\tif (load_function(mh, PAM_SM_CHAUTHTOK,\n\t\t\t    &passwdp->pam_sm_chauthtok) != PAM_SUCCESS) {\n\t\t\t\tfree(passwdp);\n\t\t\t\treturn (PAM_SYMBOL_ERR);\n\t\t\t}\n\t\t\tpam_entry->function_ptr = passwdp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpam_trace(PAM_DEBUG_DEFAULT,\n\t\t\t    \"load_modules[%d:%s](%p, %s): unsupported type %d\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    (void *)pamh, function_name, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tpam_entry = pam_entry->next;\n\t} /* while */\n\n\tpam_trace(PAM_DEBUG_MODULE, \"load_modules[%d:%s](%p, %s)=done\",\n\t    pamh->include_depth, pam_trace_cname(pamh), (void *)pamh,\n\t    function_name);\n\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * open_module\t\t- Open the module first checking for\n *\t\t\t  propers modes and ownerships on the file.\n */\n\nstatic void *\nopen_module(pam_handle_t *pamh, char *module_so)\n{\n\tstruct stat64\tstb;\n\tchar\t\t*errmsg;\n\tvoid\t\t*lfd;\n\tfd_list\t\t*module_fds = 0;\n\tfd_list\t\t*trail = 0;\n\tfd_list\t\t*traverse = 0;\n\n\t/* Check the ownership and file modes */\n\tif (stat64(module_so, &stb) < 0) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t    \"open_module[%d:%s]: stat(%s) failed: %s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so,\n\t\t    strerror(errno));\n\t\treturn (NULL);\n\t}\n\tif (stb.st_uid != (uid_t)0) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_module[%d:%s]: Owner of the module %s is not root\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so);\n\t\treturn (NULL);\n\t}\n\tif (stb.st_mode & S_IWGRP) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_module[%d:%s]: module %s writable by group\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so);\n\t\treturn (NULL);\n\t}\n\tif (stb.st_mode & S_IWOTH) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_module[%d:%s]: module %s writable by world\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), module_so);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Perform the dlopen()\n\t */\n\tlfd = (void *)dlopen(module_so, RTLD_LAZY);\n\n\tif (lfd == NULL) {\n\t\terrmsg = dlerror();\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"open_module[%d:%s]: %s \"\n\t\t    \"failed: %s\", pamh->include_depth, pam_trace_cname(pamh),\n\t\t    module_so, errmsg != NULL ? errmsg : \"Unknown error\");\n\t\treturn (NULL);\n\t} else {\n\t\t/* add this fd to the pam handle */\n\t\tif ((module_fds = calloc(1, sizeof (fd_list))) == 0) {\n\t\t\t(void) dlclose(lfd);\n\t\t\tlfd = 0;\n\t\t\treturn (NULL);\n\t\t}\n\t\tmodule_fds->mh = lfd;\n\n\t\tif (pamh->fd == 0) {\n\t\t\t/* adding new head of list */\n\t\t\tpamh->fd = module_fds;\n\t\t} else {\n\t\t\t/* appending to end of list */\n\t\t\ttraverse = pamh->fd;\n\t\t\twhile (traverse) {\n\t\t\t\ttrail = traverse;\n\t\t\t\ttraverse = traverse->next;\n\t\t\t}\n\t\t\ttrail->next = module_fds;\n\t\t}\n\t}\n\n\treturn (lfd);\n}\n\n/*\n * load_function - call dlsym() to resolve the function address\n */\nstatic int\nload_function(void *lfd, char *name, int (**func)())\n{\n\tchar *errmsg = NULL;\n\n\tif (lfd == NULL)\n\t\treturn (PAM_SYMBOL_ERR);\n\n\t*func = (int (*)())dlsym(lfd, name);\n\tif (*func == NULL) {\n\t\terrmsg = dlerror();\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"dlsym failed %s: error %s\",\n\t\t    name, errmsg != NULL ? errmsg : \"Unknown error\");\n\t\treturn (PAM_SYMBOL_ERR);\n\t}\n\n\tpam_trace(PAM_DEBUG_DEFAULT,\n\t    \"load_function: successful load of %s\", name);\n\treturn (PAM_SUCCESS);\n}\n\n/*\n * Routines to read the pam.conf configuration file\n */\n\n/*\n * open_pam_conf - open the pam.conf config file\n */\n\nstatic int\nopen_pam_conf(struct pam_fh **pam_fh, pam_handle_t *pamh, char *config)\n{\n\tstruct stat64\tstb;\n\tint\t\tfd;\n\n\tif ((fd = open(config, O_RDONLY)) == -1) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: open(%s) failed: %s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config,\n\t\t    strerror(errno));\n\t\treturn (0);\n\t}\n\t/* Check the ownership and file modes */\n\tif (fstat64(fd, &stb) < 0) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: stat(%s) failed: %s\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config,\n\t\t    strerror(errno));\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif (stb.st_uid != (uid_t)0) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: Owner of %s is not root\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config);\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif (stb.st_mode & S_IWGRP) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: %s writable by group\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config);\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif (stb.st_mode & S_IWOTH) {\n\t\t__pam_log(LOG_AUTH | LOG_ALERT,\n\t\t    \"open_pam_conf[%d:%s]: %s writable by world\",\n\t\t    pamh->include_depth, pam_trace_cname(pamh), config);\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\tif ((*pam_fh = calloc(1, sizeof (struct pam_fh))) == NULL) {\n\t\t(void) close(fd);\n\t\treturn (0);\n\t}\n\t(*pam_fh)->fconfig = fd;\n\t(*pam_fh)->bufsize = (size_t)stb.st_size;\n\tif (((*pam_fh)->data = mmap(0, (*pam_fh)->bufsize, PROT_READ,\n\t    MAP_PRIVATE, (*pam_fh)->fconfig, 0)) == MAP_FAILED) {\n\t\t(void) close(fd);\n\t\tfree (*pam_fh);\n\t\treturn (0);\n\t}\n\t(*pam_fh)->bufferp = (*pam_fh)->data;\n\n\treturn (1);\n}\n\n/*\n * close_pam_conf - close pam.conf\n */\n\nstatic void\nclose_pam_conf(struct pam_fh *pam_fh)\n{\n\t(void) munmap(pam_fh->data, pam_fh->bufsize);\n\t(void) close(pam_fh->fconfig);\n\tfree(pam_fh);\n}\n\n/*\n * read_pam_conf - read in each entry in pam.conf and store info\n *\t\t   under the pam handle.\n */\n\nstatic int\nread_pam_conf(pam_handle_t *pamh, char *config)\n{\n\tstruct pam_fh\t*pam_fh;\n\tpamtab_t\t*pamentp;\n\tpamtab_t\t*tpament;\n\tchar\t\t*service;\n\tint\t\terror;\n\tint\t\ti = pamh->include_depth;\t/* include depth */\n\t/*\n\t * service types:\n\t * error (-1), \"auth\" (0), \"account\" (1), \"session\" (2), \"password\" (3)\n\t */\n\tint service_found[PAM_NUM_MODULE_TYPES+1] = {0, 0, 0, 0, 0};\n\n\t(void) pam_get_item(pamh, PAM_SERVICE, (void **)&service);\n\tif (service == NULL || *service == '\\0') {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"No service name\");\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\tpamh->pam_conf_name[i] = strdup(config);\n\tpam_trace(PAM_DEBUG_CONF, \"read_pam_conf[%d:%s](%p) open(%s)\",\n\t    i, pam_trace_cname(pamh), (void *)pamh, config);\n\tif (open_pam_conf(&pam_fh, pamh, config) == 0) {\n\t\treturn (PAM_SYSTEM_ERR);\n\t}\n\n\twhile ((error =\n\t    get_pam_conf_entry(pam_fh, pamh, &pamentp)) == PAM_SUCCESS &&\n\t    pamentp) {\n\n\t\t/* See if entry is this service and valid */\n\t\tif (verify_pam_conf(pamentp, service)) {\n\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t    \"read_pam_conf[%d:%s](%p): bad entry error %s\",\n\t\t\t    i, pam_trace_cname(pamh), (void *)pamh, service);\n\n\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\tfree_pamconf(pamentp);\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(pamentp->pam_service, service) == 0) {\n\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t    \"read_pam_conf[%d:%s](%p): processing %s\",\n\t\t\t    i, pam_trace_cname(pamh), (void *)pamh, service);\n\t\t\t/* process first service entry */\n\t\t\tif (service_found[pamentp->pam_type + 1] == 0) {\n\t\t\t\t/* purge \"other\" entries */\n\t\t\t\twhile ((tpament = pamh->pam_conf_info[i]\n\t\t\t\t    [pamentp->pam_type]) != NULL) {\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t\t    \"read_pam_conf(%p): purging \"\n\t\t\t\t\t    \"\\\"other\\\"[%d:%s][%s]\",\n\t\t\t\t\t    (void *)pamh, i,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\t\tpamh->pam_conf_info[i]\n\t\t\t\t\t    [pamentp->pam_type] = tpament->next;\n\t\t\t\t\tfree_pamconf(tpament);\n\t\t\t\t}\n\t\t\t\t/* add first service entry */\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): adding 1st \"\n\t\t\t\t    \"%s[%d:%s][%s]\",\n\t\t\t\t    (void *)pamh, service, i,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\tpamh->pam_conf_info[i][pamentp->pam_type] =\n\t\t\t\t    pamentp;\n\t\t\t\tservice_found[pamentp->pam_type + 1] = 1;\n\t\t\t} else {\n\t\t\t\t/* append more service entries */\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): adding more \"\n\t\t\t\t    \"%s[%d:%s][%s]\",\n\t\t\t\t    (void *)pamh, service, i,\n\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\ttpament =\n\t\t\t\t    pamh->pam_conf_info[i][pamentp->pam_type];\n\t\t\t\twhile (tpament->next != NULL) {\n\t\t\t\t\ttpament = tpament->next;\n\t\t\t\t}\n\t\t\t\ttpament->next = pamentp;\n\t\t\t}\n\t\t} else if (service_found[pamentp->pam_type + 1] == 0) {\n\t\t\t/* See if \"other\" entry available and valid */\n\t\t\tif (verify_pam_conf(pamentp, \"other\")) {\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): bad entry error %s \"\n\t\t\t\t    \"\\\"other\\\"[%d:%s]\",\n\t\t\t\t    (void *)pamh, service, i,\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\t\tfree_pamconf(pamentp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcasecmp(pamentp->pam_service, \"other\") == 0) {\n\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t    \"read_pam_conf(%p): processing \"\n\t\t\t\t    \"\\\"other\\\"[%d:%s]\", (void *)pamh, i,\n\t\t\t\t    pam_trace_cname(pamh));\n\t\t\t\tif ((tpament = pamh->pam_conf_info[i]\n\t\t\t\t    [pamentp->pam_type]) == NULL) {\n\t\t\t\t\t/* add first \"other\" entry */\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t\t    \"read_pam_conf(%p): adding 1st \"\n\t\t\t\t\t    \"other[%d:%s][%s]\", (void *)pamh, i,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\t\tpamh->pam_conf_info[i]\n\t\t\t\t\t    [pamentp->pam_type] = pamentp;\n\t\t\t\t} else {\n\t\t\t\t\t/* append more \"other\" entries */\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONF,\n\t\t\t\t\t    \"read_pam_conf(%p): adding more \"\n\t\t\t\t\t    \"other[%d:%s][%s]\", (void *)pamh, i,\n\t\t\t\t\t    pam_trace_cname(pamh),\n\t\t\t\t\t    pam_snames[pamentp->pam_type]);\n\t\t\t\t\twhile (tpament->next != NULL) {\n\t\t\t\t\t\ttpament = tpament->next;\n\t\t\t\t\t}\n\t\t\t\t\ttpament->next = pamentp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* irrelevant entry */\n\t\t\t\tfree_pamconf(pamentp);\n\t\t\t}\n\t\t} else {\n\t\t\t/* irrelevant entry */\n\t\t\tfree_pamconf(pamentp);\n\t\t}\n\t}\nout:\n\t(void) close_pam_conf(pam_fh);\n\tif (error != PAM_SUCCESS)\n\t\tfree_pam_conf_info(pamh);\n\treturn (error);\n}\n\n/*\n * get_pam_conf_entry - get a pam.conf entry\n */\n\nstatic int\nget_pam_conf_entry(struct pam_fh *pam_fh, pam_handle_t *pamh, pamtab_t **pam)\n{\n\tchar\t\t*cp, *arg;\n\tint\t\targc;\n\tchar\t\t*tmp, *tmp_free;\n\tint\t\ti;\n\tchar\t\t*current_line = NULL;\n\tint\t\terror = PAM_SYSTEM_ERR;\t/* preset to error */\n\tint\t\terr;\n\n\t/* get the next line from pam.conf */\n\tif ((cp = nextline(pam_fh, pamh, &err)) == NULL) {\n\t\t/* no more lines in pam.conf ==> return */\n\t\terror = PAM_SUCCESS;\n\t\t*pam = NULL;\n\t\tgoto out;\n\t}\n\n\tif ((*pam = calloc(1, sizeof (pamtab_t))) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\n\t/* copy full line for error reporting */\n\tif ((current_line = strdup(cp)) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\n\tpam_trace(PAM_DEBUG_CONF,\n\t    \"pam.conf[%s] entry:\\t%s\", pam_trace_cname(pamh), current_line);\n\n\t/* get service name (e.g. login, su, passwd) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing SERVICE NAME\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\tgoto out;\n\t}\n\tif (((*pam)->pam_service = strdup(arg)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\n\t/* get module type (e.g. authentication, acct mgmt) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing MODULE TYPE\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\t(*pam)->pam_type = -1;\t/* 0 is a valid value */\n\t\tgoto getflag;\n\t}\n\tif (strcasecmp(arg, PAM_AUTH_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_AUTH_MODULE;\n\t} else if (strcasecmp(arg, PAM_ACCOUNT_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_ACCOUNT_MODULE;\n\t} else if (strcasecmp(arg, PAM_SESSION_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_SESSION_MODULE;\n\t} else if (strcasecmp(arg, PAM_PASSWORD_NAME) == 0) {\n\t\t(*pam)->pam_type = PAM_PASSWORD_MODULE;\n\t} else {\n\t\t/* error */\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: invalid module \"\n\t\t    \"type: %s\", pam_trace_cname(pamh), current_line, arg);\n\t\t(*pam)->pam_type = -1;\t/* 0 is a valid value */\n\t}\n\ngetflag:\n\t/* get pam flag (e.g., requisite, required, sufficient, optional) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing CONTROL FLAG\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\tgoto getpath;\n\t}\n\tif (strcasecmp(arg, PAM_BINDING_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_BINDING;\n\t} else if (strcasecmp(arg, PAM_INCLUDE_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_INCLUDE;\n\t} else if (strcasecmp(arg, PAM_OPTIONAL_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_OPTIONAL;\n\t} else if (strcasecmp(arg, PAM_REQUIRED_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_REQUIRED;\n\t} else if (strcasecmp(arg, PAM_REQUISITE_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_REQUISITE;\n\t} else if (strcasecmp(arg, PAM_SUFFICIENT_NAME) == 0) {\n\t\t(*pam)->pam_flag = PAM_SUFFICIENT;\n\t} else {\n\t\t/* error */\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"\\tinvalid control flag: %s\", arg);\n\t}\n\ngetpath:\n\t/* get module path (e.g. /usr/lib/security/pam_unix_auth.so.1) */\n\tif ((arg = read_next_token(&cp)) == 0) {\n\t\t__pam_log(LOG_AUTH | LOG_CRIT,\n\t\t    \"illegal pam.conf[%s] entry: %s: missing MODULE PATH\",\n\t\t    pam_trace_cname(pamh), current_line);\n\t\terror = PAM_SUCCESS;\t/* success */\n\t\tgoto out;\n\t}\n\tif (arg[0] != '/') {\n\t\tsize_t len;\n\t\t/*\n\t\t * If module path does not start with \"/\", then\n\t\t * prepend PAM_LIB_DIR (/usr/lib/security/).\n\t\t */\n\t\t/* sizeof (PAM_LIB_DIR) has room for '\\0' */\n\t\tlen = sizeof (PAM_LIB_DIR) + sizeof (PAM_ISA_DIR) + strlen(arg);\n\t\tif (((*pam)->module_path = malloc(len)) == NULL) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((*pam)->pam_flag & PAM_INCLUDE) {\n\t\t\t(void) snprintf((*pam)->module_path, len, \"%s%s\",\n\t\t\t    PAM_LIB_DIR, arg);\n\t\t} else {\n\t\t\t(void) snprintf((*pam)->module_path, len, \"%s%s%s\",\n\t\t\t    PAM_LIB_DIR, PAM_ISA_DIR, arg);\n\t\t}\n\t} else {\n\t\t/* Full path provided for module */\n\t\tchar *isa;\n\n\t\t/* Check for Instruction Set Architecture indicator */\n\t\tif ((isa = strstr(arg, PAM_ISA)) != NULL) {\n\t\t\tsize_t len;\n\t\t\tlen = strlen(arg) - (sizeof (PAM_ISA)-1) +\n\t\t\t    sizeof (PAM_ISA_DIR);\n\n\t\t\t/* substitute the architecture dependent path */\n\t\t\tif (((*pam)->module_path = malloc(len)) == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t\t    \"strdup: out of memory\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*isa = '\\000';\n\t\t\tisa += strlen(PAM_ISA);\n\t\t\t(void) snprintf((*pam)->module_path, len, \"%s%s%s\",\n\t\t\t    arg, PAM_ISA_DIR, isa);\n\t\t} else if (((*pam)->module_path = strdup(arg)) == 0) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* count the number of module-specific options first */\n\targc = 0;\n\tif ((tmp = strdup(cp)) == NULL) {\n\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup: out of memory\");\n\t\tgoto out;\n\t}\n\ttmp_free = tmp;\n\tfor (arg = read_next_token(&tmp); arg; arg = read_next_token(&tmp))\n\t\targc++;\n\tfree(tmp_free);\n\n\t/* allocate array for the module-specific options */\n\tif (argc > 0) {\n\t\tif (((*pam)->module_argv =\n\t\t    calloc(argc+1, sizeof (char *))) == 0) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"calloc: out of memory\");\n\t\t\tgoto out;\n\t\t}\n\t\ti = 0;\n\t\tfor (arg = read_next_token(&cp); arg;\n\t\t    arg = read_next_token(&cp)) {\n\t\t\t(*pam)->module_argv[i] = strdup(arg);\n\t\t\tif ((*pam)->module_argv[i] == NULL) {\n\t\t\t\t__pam_log(LOG_AUTH | LOG_ERR, \"strdup failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\t(*pam)->module_argv[argc] = NULL;\n\t}\n\t(*pam)->module_argc = argc;\n\n\terror = PAM_SUCCESS;\t/* success */\n\t(*pam)->pam_err = err;\t/* was the line truncated */\n\nout:\n\tif (current_line)\n\t\tfree(current_line);\n\tif (error != PAM_SUCCESS) {\n\t\t/* on error free this */\n\t\tif (*pam)\n\t\t\tfree_pamconf(*pam);\n\t}\n\treturn (error);\n}\n\n\n/*\n * read_next_token - skip tab and space characters and return the next token\n */\n\nstatic char *\nread_next_token(char **cpp)\n{\n\tregister char *cp = *cpp;\n\tchar *start;\n\n\tif (cp == (char *)0) {\n\t\t*cpp = (char *)0;\n\t\treturn ((char *)0);\n\t}\n\twhile (*cp == ' ' || *cp == '\\t')\n\t\tcp++;\n\tif (*cp == '\\0') {\n\t\t*cpp = (char *)0;\n\t\treturn ((char *)0);\n\t}\n\tstart = cp;\n\twhile (*cp && *cp != ' ' && *cp != '\\t')\n\t\tcp++;\n\tif (*cp != '\\0')\n\t\t*cp++ = '\\0';\n\t*cpp = cp;\n\treturn (start);\n}\n\nstatic char *\npam_conf_strnchr(char *sp, int c, intptr_t count)\n{\n\twhile (count) {\n\t\tif (*sp == (char)c)\n\t\t\treturn ((char *)sp);\n\t\telse {\n\t\t\tsp++;\n\t\t\tcount--;\n\t\t}\n\t};\n\treturn (NULL);\n}\n\n/*\n * nextline - skip all blank lines and comments\n */\n\nstatic char *\nnextline(struct pam_fh *pam_fh, pam_handle_t *pamh, int *err)\n{\n\tchar\t*ll;\n\tint\tfind_a_line = 0;\n\tchar\t*data = pam_fh->data;\n\tchar\t*bufferp = pam_fh->bufferp;\n\tchar\t*bufferendp = &data[pam_fh->bufsize];\n\tsize_t\tinput_len;\n\n\t/*\n\t * Skip the blank line, comment line\n\t */\n\twhile (!find_a_line) {\n\t\t/* if we are at the end of the buffer, there is no next line */\n\t\tif (bufferp == bufferendp)\n\t\t\treturn (NULL);\n\n\t\t/* skip blank line */\n\t\twhile (*bufferp == '\\n') {\n\t\t\t/*\n\t\t\t * If we are at the end of the buffer, there is\n\t\t\t * no next line.\n\t\t\t */\n\t\t\tif (++bufferp == bufferendp) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\t/* else we check *bufferp again */\n\t\t}\n\n\t\t/* skip comment line */\n\t\twhile (*bufferp == '#') {\n\t\t\tif ((ll = pam_conf_strnchr(bufferp, '\\n',\n\t\t\t    bufferendp - bufferp)) != NULL) {\n\t\t\t\tbufferp = ll;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * this comment line the last line.\n\t\t\t\t * no next line\n\t\t\t\t */\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we are at the end of the buffer, there is\n\t\t\t * no next line.\n\t\t\t */\n\t\t\tif (bufferp == bufferendp) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\n\t\tif ((*bufferp != '\\n') && (*bufferp != '#')) {\n\t\t\tfind_a_line = 1;\n\t\t}\n\t}\n\n\t*err = PAM_SUCCESS;\n\t/* now we find one line */\n\tif ((ll = pam_conf_strnchr(bufferp, '\\n', bufferendp - bufferp))\n\t    != NULL) {\n\t\tif ((input_len = ll - bufferp) >= sizeof (pam_fh->line)) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t    \"nextline[%d:%s]: pam.conf line too long %.256s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    bufferp);\n\t\t\tinput_len = sizeof (pam_fh->line) - 1;\n\t\t\t*err = PAM_SERVICE_ERR;\n\t\t}\n\t\t(void) strncpy(pam_fh->line, bufferp, input_len);\n\t\tpam_fh->line[input_len] = '\\0';\n\t\tpam_fh->bufferp = ll++;\n\t} else {\n\t\tll = bufferendp;\n\t\tif ((input_len = ll - bufferp) >= sizeof (pam_fh->line)) {\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t    \"nextline[%d:%s]: pam.conf line too long %.256s\",\n\t\t\t    pamh->include_depth, pam_trace_cname(pamh),\n\t\t\t    bufferp);\n\t\t\tinput_len = sizeof (pam_fh->line) - 1;\n\t\t\t*err = PAM_SERVICE_ERR;\n\t\t}\n\t\t(void) strncpy(pam_fh->line, bufferp, input_len);\n\t\tpam_fh->line[input_len] = '\\0';\n\t\tpam_fh->bufferp = ll;\n\t}\n\n\treturn (pam_fh->line);\n}\n\n/*\n * verify_pam_conf - verify that the pam_conf entry is filled in.\n *\n *\tTrue = Error if there is no service.\n *\tTrue = Error if there is a service and it matches the requested service\n *\t\tbut, the type, flag, line overflow, or path is in error.\n */\n\nstatic int\nverify_pam_conf(pamtab_t *pam, char *service)\n{\n\treturn ((pam->pam_service == (char *)NULL) ||\n\t    ((strcasecmp(pam->pam_service, service) == 0) &&\n\t    ((pam->pam_type == -1) ||\n\t    (pam->pam_flag == 0) ||\n\t    (pam->pam_err != PAM_SUCCESS) ||\n\t    (pam->module_path == (char *)NULL))));\n}\n\n/*\n * Routines to free allocated storage\n */\n\n/*\n * clean_up -  free allocated storage in the pam handle\n */\n\nstatic void\nclean_up(pam_handle_t *pamh)\n{\n\tint i;\n\tpam_repository_t *auth_rep;\n\n\tif (pamh) {\n\t\twhile (pamh->include_depth >= 0) {\n\t\t\tfree_pam_conf_info(pamh);\n\t\t\tpamh->include_depth--;\n\t\t}\n\n\t\t/* Cleanup PAM_REPOSITORY structure */\n\t\tauth_rep = pamh->ps_item[PAM_REPOSITORY].pi_addr;\n\t\tif (auth_rep != NULL) {\n\t\t\tif (auth_rep->type != NULL)\n\t\t\t\tfree(auth_rep->type);\n\t\t\tif (auth_rep->scope != NULL)\n\t\t\t\tfree(auth_rep->scope);\n\t\t}\n\n\t\tfor (i = 0; i < PAM_MAX_ITEMS; i++) {\n\t\t\tif (pamh->ps_item[i].pi_addr != NULL) {\n\t\t\t\tif (i == PAM_AUTHTOK || i == PAM_OLDAUTHTOK) {\n\t\t\t\t\t(void) memset(pamh->ps_item[i].pi_addr,\n\t\t\t\t\t    0, pamh->ps_item[i].pi_size);\n\t\t\t\t}\n\t\t\t\tfree(pamh->ps_item[i].pi_addr);\n\t\t\t}\n\t\t}\n\t\tfree(pamh);\n\t}\n}\n\n/*\n * free_pamconf - free memory used to store pam.conf entry\n */\n\nstatic void\nfree_pamconf(pamtab_t *cp)\n{\n\tint i;\n\n\tif (cp) {\n\t\tif (cp->pam_service)\n\t\t\tfree(cp->pam_service);\n\t\tif (cp->module_path)\n\t\t\tfree(cp->module_path);\n\t\tfor (i = 0; i < cp->module_argc; i++) {\n\t\t\tif (cp->module_argv[i])\n\t\t\t\tfree(cp->module_argv[i]);\n\t\t}\n\t\tif (cp->module_argc > 0)\n\t\t\tfree(cp->module_argv);\n\t\tif (cp->function_ptr)\n\t\t\tfree(cp->function_ptr);\n\n\t\tfree(cp);\n\t}\n}\n\n/*\n * free_pam_conf_info - free memory used to store all pam.conf info\n *\t\t\tunder the pam handle\n */\n\nstatic void\nfree_pam_conf_info(pam_handle_t *pamh)\n{\n\tpamtab_t *pamentp;\n\tpamtab_t *pament_trail;\n\tint i = pamh->include_depth;\n\tint j;\n\n\tfor (j = 0; j < PAM_NUM_MODULE_TYPES; j++) {\n\t\tpamentp = pamh->pam_conf_info[i][j];\n\t\tpamh->pam_conf_info[i][j] = NULL;\n\t\tpament_trail = pamentp;\n\t\twhile (pamentp) {\n\t\t\tpamentp = pamentp->next;\n\t\t\tfree_pamconf(pament_trail);\n\t\t\tpament_trail = pamentp;\n\t\t}\n\t}\n\tif (pamh->pam_conf_name[i] != NULL) {\n\t\tfree(pamh->pam_conf_name[i]);\n\t\tpamh->pam_conf_name[i] = NULL;\n\t}\n}\n\nstatic void\nfree_env(env_list *pam_env)\n{\n\tif (pam_env) {\n\t\tif (pam_env->name)\n\t\t\tfree(pam_env->name);\n\t\tif (pam_env->value)\n\t\t\tfree(pam_env->value);\n\t\tfree(pam_env);\n\t}\n}\n\n/*\n *\tInternal convenience functions for Solaris PAM service modules.\n */\n\n#include <libintl.h>\n#include <nl_types.h>\n#include <synch.h>\n#include <locale.h>\n#include <thread.h>\n\ntypedef struct pam_msg_data {\n\tnl_catd fd;\n} pam_msg_data_t;\n\n/*\n * free_resp():\n *\tfree storage for responses used in the call back \"pam_conv\" functions\n */\n\nvoid\nfree_resp(int num_msg, struct pam_response *resp)\n{\n\tint\t\t\ti;\n\tstruct pam_response\t*r;\n\n\tif (resp) {\n\t\tr = resp;\n\t\tfor (i = 0; i < num_msg; i++, r++) {\n\t\t\tif (r->resp) {\n\t\t\t\t/* clear before freeing -- may be a password */\n\t\t\t\tbzero(r->resp, strlen(r->resp));\n\t\t\t\tfree(r->resp);\n\t\t\t\tr->resp = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(resp);\n\t}\n}\n\nstatic int\ndo_conv(pam_handle_t *pamh, int msg_style, int num_msg,\n    char messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE], void *conv_apdp,\n    struct pam_response *ret_respp[])\n{\n\tstruct pam_message\t*msg;\n\tstruct pam_message\t*m;\n\tint\t\t\ti;\n\tint\t\t\tk;\n\tint\t\t\tretcode;\n\tstruct pam_conv\t\t*pam_convp;\n\n\tif ((retcode = pam_get_item(pamh, PAM_CONV,\n\t    (void **)&pam_convp)) != PAM_SUCCESS) {\n\t\treturn (retcode);\n\t}\n\n\t/*\n\t * When pam_set_item() is called to set PAM_CONV and the\n\t * item is NULL, memset(pip->pi_addr, 0, size) is called.\n\t * So at this point, we should check whether pam_convp->conv\n\t * is NULL or not.\n\t */\n\tif ((pam_convp == NULL) || (pam_convp->conv == NULL))\n\t\treturn (PAM_SYSTEM_ERR);\n\n\ti = 0;\n\tk = num_msg;\n\n\tmsg = calloc(num_msg, sizeof (struct pam_message));\n\tif (msg == NULL) {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\tm = msg;\n\n\twhile (k--) {\n\t\t/*\n\t\t * fill out the message structure to display prompt message\n\t\t */\n\t\tm->msg_style = msg_style;\n\t\tm->msg = messages[i];\n\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t    \"pam_conv_msg(%p:%d[%d]=%s)\",\n\t\t    (void *)pamh, msg_style, i, messages[i]);\n\t\tm++;\n\t\ti++;\n\t}\n\n\t/*\n\t * The UNIX pam modules always calls __pam_get_authtok() and\n\t * __pam_display_msg() with a NULL pointer as the conv_apdp.\n\t * In case the conv_apdp is NULL and the pam_convp->appdata_ptr\n\t * is not NULL, we should pass the pam_convp->appdata_ptr\n\t * to the conversation function.\n\t */\n\tif (conv_apdp == NULL && pam_convp->appdata_ptr != NULL)\n\t\tconv_apdp = pam_convp->appdata_ptr;\n\n\t/*\n\t * Call conv function to display the prompt.\n\t */\n\tretcode = (pam_convp->conv)(num_msg, &msg, ret_respp, conv_apdp);\n\tpam_trace(PAM_DEBUG_CONV,\n\t    \"pam_conv_resp(%p pam_conv = %s) ret_respp = %p\",\n\t    (void *)pamh, pam_strerror(pamh, retcode), (void *)ret_respp);\n\tif (*ret_respp == NULL) {\n\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t    \"pam_conv_resp(%p No response requested)\", (void *)pamh);\n\t} else if ((pam_debug & (PAM_DEBUG_CONV | PAM_DEBUG_AUTHTOK)) != 0) {\n\t\tstruct pam_response *r = *ret_respp;\n\n\t\tfor (i = 0; i < num_msg; i++, r++) {\n\t\t\tif (r->resp == NULL) {\n\t\t\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t\t\t    \"pam_conv_resp(%p:\"\n\t\t\t\t    \"[%d] NULL response string)\",\n\t\t\t\t    (void *)pamh, i);\n\t\t\t} else {\n\t\t\t\tif (msg_style == PAM_PROMPT_ECHO_OFF) {\n#ifdef\tDEBUG\n\t\t\t\t\tpam_trace(PAM_DEBUG_AUTHTOK,\n\t\t\t\t\t    \"pam_conv_resp(%p:[%d]=%s, \"\n\t\t\t\t\t    \"code=%d)\",\n\t\t\t\t\t    (void *)pamh, i, r->resp,\n\t\t\t\t\t    r->resp_retcode);\n#endif\t/* DEBUG */\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t\t\t\t    \"pam_conv_resp(%p:[%d] len=%lu, \"\n\t\t\t\t\t    \"code=%d)\",\n\t\t\t\t\t    (void *)pamh, i,\n\t\t\t\t\t    (ulong_t)strlen(r->resp),\n\t\t\t\t\t    r->resp_retcode);\n\t\t\t\t} else {\n\t\t\t\t\tpam_trace(PAM_DEBUG_CONV,\n\t\t\t\t\t    \"pam_conv_resp(%p:[%d]=%s, \"\n\t\t\t\t\t    \"code=%d)\",\n\t\t\t\t\t    (void *)pamh, i, r->resp,\n\t\t\t\t\t    r->resp_retcode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (msg)\n\t\tfree(msg);\n\treturn (retcode);\n}\n\n/*\n * __pam_display_msg():\n *\tdisplay message by calling the call back functions\n *\tprovided by the application through \"pam_conv\" structure\n */\n\nint\n__pam_display_msg(pam_handle_t *pamh, int msg_style, int num_msg,\n    char messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE], void *conv_apdp)\n{\n\tstruct pam_response\t*ret_respp = NULL;\n\tint ret;\n\n\tret = do_conv(pamh, msg_style, num_msg, messages,\n\t    conv_apdp, &ret_respp);\n\n\tif (ret_respp != NULL)\n\t\tfree_resp(num_msg, ret_respp);\n\n\treturn (ret);\n}\n\n/*\n * __pam_get_authtok()\n *\tretrieves a password of at most PASS_MAX length from the pam\n *\thandle (pam_get_item) or from the input stream (do_conv).\n *\n * This function allocates memory for the new authtok.\n * Applications calling this function are responsible for\n * freeing this memory.\n *\n * If \"source\" is\n *\tPAM_HANDLE\n * and \"type\" is:\n *\tPAM_AUTHTOK - password is taken from pam handle (PAM_AUTHTOK)\n *\tPAM_OLDAUTHTOK - password is taken from pam handle (PAM_OLDAUTHTOK)\n *\n * If \"source\" is\n *\tPAM_PROMPT\n * and \"type\" is:\n *\t0:\t\tPrompt for new passwd, do not even attempt\n *\t\t\tto store it in the pam handle.\n *\tPAM_AUTHTOK:\tPrompt for new passwd, store in pam handle as\n *\t\t\tPAM_AUTHTOK item if this value is not already set.\n *\tPAM_OLDAUTHTOK:\tPrompt for new passwd, store in pam handle as\n *\t\t\tPAM_OLDAUTHTOK item if this value is not\n *\t\t\talready set.\n */\nint\n__pam_get_authtok(pam_handle_t *pamh, int source, int type, char *prompt,\n    char **authtok)\n{\n\tint error = PAM_SYSTEM_ERR;\n\tchar *new_password = NULL;\n\tstruct pam_response *ret_resp = NULL;\n\tchar messages[PAM_MAX_NUM_MSG][PAM_MAX_MSG_SIZE];\n\n\tif ((*authtok = calloc(PASS_MAX+1, sizeof (char))) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\n\tif (prompt == NULL)\n\t\tprompt = dgettext(TEXT_DOMAIN, \"password: \");\n\n\tswitch (source) {\n\tcase PAM_HANDLE:\n\n\t\t/* get password from pam handle item list */\n\n\t\tswitch (type) {\n\t\tcase PAM_AUTHTOK:\n\t\tcase PAM_OLDAUTHTOK:\n\n\t\t\tif ((error = pam_get_item(pamh, type,\n\t\t\t    (void **)&new_password)) != PAM_SUCCESS)\n\t\t\t\tgoto err_ret;\n\n\t\t\tif (new_password == NULL || new_password[0] == '\\0') {\n\t\t\t\tfree(*authtok);\n\t\t\t\t*authtok = NULL;\n\t\t\t} else {\n\t\t\t\t(void) strlcpy(*authtok, new_password,\n\t\t\t\t    PASS_MAX+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t\t    \"__pam_get_authtok() invalid type: %d\", type);\n\t\t\terror = PAM_SYMBOL_ERR;\n\t\t\tgoto err_ret;\n\t\t}\n\t\tbreak;\n\tcase PAM_PROMPT:\n\n\t\t/*\n\t\t * Prompt for new password and save in pam handle item list\n\t\t * if the that item is not already set.\n\t\t */\n\n\t\t(void) strncpy(messages[0], prompt, sizeof (messages[0]));\n\t\tif ((error = do_conv(pamh, PAM_PROMPT_ECHO_OFF, 1, messages,\n\t\t    NULL, &ret_resp)) != PAM_SUCCESS)\n\t\t\tgoto err_ret;\n\n\t\tif (ret_resp->resp == NULL) {\n\t\t\t/* getpass didn't return anything */\n\t\t\terror = PAM_SYSTEM_ERR;\n\t\t\tgoto err_ret;\n\t\t}\n\n\t\t/* save the new password if this item was NULL */\n\t\tif (type) {\n\t\t\tif ((error = pam_get_item(pamh, type,\n\t\t\t    (void **)&new_password)) != PAM_SUCCESS) {\n\t\t\t\tfree_resp(1, ret_resp);\n\t\t\t\tgoto err_ret;\n\t\t\t}\n\t\t\tif (new_password == NULL)\n\t\t\t\t(void) pam_set_item(pamh, type, ret_resp->resp);\n\t\t}\n\n\t\t(void) strlcpy(*authtok, ret_resp->resp, PASS_MAX+1);\n\t\tfree_resp(1, ret_resp);\n\t\tbreak;\n\tdefault:\n\t\t__pam_log(LOG_AUTH | LOG_ERR,\n\t\t    \"__pam_get_authtok() invalid source: %d\", source);\n\t\terror = PAM_SYMBOL_ERR;\n\t\tgoto err_ret;\n\t}\n\n\treturn (PAM_SUCCESS);\n\nerr_ret:\n\tbzero(*authtok, PASS_MAX+1);\n\tfree(*authtok);\n\t*authtok = NULL;\n\treturn (error);\n}\n"], "filenames": ["usr/src/lib/libpam/pam_framework.c"], "buggy_code_start_loc": [27], "buggy_code_end_loc": [672], "fixing_code_start_loc": [27], "fixing_code_end_loc": [672], "type": "CWE-120", "message": "An issue was discovered in illumos before 2020-10-22, as used in OmniOS before r151030by, r151032ay, and r151034y and SmartOS before 20201022. There is a buffer overflow in parse_user_name in lib/libpam/pam_framework.c.", "other": {"cve": {"id": "CVE-2020-27678", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-26T12:17:12.693", "lastModified": "2020-10-27T17:34:13.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in illumos before 2020-10-22, as used in OmniOS before r151030by, r151032ay, and r151034y and SmartOS before 20201022. There is a buffer overflow in parse_user_name in lib/libpam/pam_framework.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en illumos antes del 22-10-2020, como es usado en OmniOS versiones anteriores a r151030by, r151032ay y r151034y y SmartOS versiones anteriores a 20201022. Se presenta un desbordamiento de b\u00fafer en la funci\u00f3n parse_user_name en la biblioteca lib/libpam/pam_framework.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:illumos:illumos:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-10-22", "matchCriteriaId": "FCBBCFC9-C8F7-472C-AFFC-2C9DB468A719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:joyent:smartos:*:*:*:*:*:*:*:*", "versionEndExcluding": "20201022", "matchCriteriaId": "B9CD98CE-647E-4654-9F8E-A32440D8B993"}, {"vulnerable": true, "criteria": "cpe:2.3:o:omniosce:omnios:*:*:*:*:community:*:*:*", "versionEndExcluding": "r151030by", "matchCriteriaId": "1A57BCA3-0D16-4232-9AA5-355827FC73F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:omniosce:omnios:*:*:*:*:community:*:*:*", "versionStartIncluding": "r151032", "versionEndIncluding": "r151032ay", "matchCriteriaId": "D53ADD04-9E73-4D07-AC1E-D9E545801EAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:omniosce:omnios:*:*:*:*:*:*:*:*", "versionStartIncluding": "r151034", "versionEndExcluding": "r151034y", "matchCriteriaId": "67552C06-4B78-452B-A911-9C56F673B523"}]}]}], "references": [{"url": "https://github.com/illumos/illumos-gate/commit/1d276e0b382cf066dae93640746d8b4c54d15452", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/illumos/illumos-gate/commit/1d276e0b382cf066dae93640746d8b4c54d15452"}}