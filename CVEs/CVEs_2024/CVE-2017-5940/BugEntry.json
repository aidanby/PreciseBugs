{"buggy_code": ["/*\n * Copyright (C) 2014-2016 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include \"firejail.h\"\n#include <sys/mount.h>\n#include <linux/limits.h>\n#include <glob.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <grp.h>\n#include <ftw.h>\n\nstatic void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file(\"/etc/skel/.zshrc\", fname, u, g, 0644);\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, u, g, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file(\"/etc/skel/.cshrc\", fname, u, g, 0644);\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, u, g, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0) \n\t\t\treturn;\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file(\"/etc/skel/.bashrc\", fname, u, g, 0644);\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t}\n\t\tfree(fname);\n\t}\n}\n\nstatic int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tfs_build_mnt_dir();\n\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file \n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n\nstatic int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tfs_build_mnt_dir();\n\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file \n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n\nstatic void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\tfs_logger2(\"clone\", dest);\n\t\n\t// delete the temporary file\n\tunlink(src);\n}\n\nstatic void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}\n\n\n// private mode (--private=homedir):\n// \tmount homedir on top of /home/user,\n// \ttmpfs on top of  /root in nonroot mode,\n// \tset skel files,\n// \trestore .Xauthority\nvoid fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\t\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\t\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\t\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\tif (mount(private_homedir, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\t\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}\n\n// private mode (--private):\n//\tmount tmpfs over /home/user,\n// \ttmpfs on top of  /root in nonroot mode,\n// \tset skel files,\n// \trestore .Xauthority\nvoid fs_private(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\t// mask /home\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /home directory\\n\");\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting home directory\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// mask /root\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /root directory\\n\");\n\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\terrExit(\"mounting root directory\");\n\tfs_logger(\"tmpfs /root\");\n\n\tif (u != 0) {\n\t\t// create /home/user\n\t\tif (arg_debug)\n\t\t\tprintf(\"Create a new user directory\\n\");\n\t\tif (mkdir(homedir, S_IRWXU) == -1) {\n\t\t\tif (mkpath_as_root(homedir) == -1)\n\t\t\t\terrExit(\"mkpath\");\n\t\t\tif (mkdir(homedir, S_IRWXU) == -1)\n\t\t\t\terrExit(\"mkdir\");\n\t\t}\n\t\tif (chown(homedir, u, g) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger2(\"mkdir\", homedir);\n\t}\n\t\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n}\n\n// check new private home directory (--private= option) - exit if it fails\nvoid fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private);\n\t\n\t// Expand the home directory\n\tchar *tmp = expand_home(cfg.home_private, cfg.homedir);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\t\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)\n\t || is_link(cfg.home_private)\n\t || strstr(cfg.home_private, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n\n\t// check home directory and chroot home directory have the same owner\n\tstruct stat s2;\n\tint rv = stat(cfg.home_private, &s2);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory\\n\", cfg.home_private);\n\t\texit(1);\n\t}\n\n\tstruct stat s1;\n\trv = stat(cfg.homedir, &s1);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory, full path name required\\n\", cfg.homedir);\n\t\texit(1);\n\t}\n\tif (s1.st_uid != s2.st_uid) {\n\t\tprintf(\"Error: --private directory should be owned by the current user\\n\");\n\t\texit(1);\n\t}\n}\n\n//***********************************************************************************\n// --private-home\n//***********************************************************************************\n#define PRIVATE_COPY_LIMIT (500 * 1024 *1024)\nstatic int size_limit_reached = 0;\nstatic unsigned file_cnt = 0;\nstatic unsigned size_cnt = 0;\nstatic char *check_dir_or_file(const char *name);\n\nint fs_copydir(const char *path, const struct stat *st, int ftype, struct FTW *sftw) {\n\t(void) st;\n\t(void) sftw;\n\tif (size_limit_reached)\n\t\treturn 0;\n\n\tstruct stat s;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s%s\", RUN_HOME_DIR, path + strlen(cfg.homedir)) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// don't copy it if we already have the file\n\tif (stat(dest, &s) == 0) {\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\t\n\t// extract mode and ownership\n\tif (stat(path, &s) != 0) {\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\n\t// check uid\n\tif (s.st_uid != firejail_uid || s.st_gid != firejail_gid) {\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\n\tif ((s.st_size + size_cnt) > PRIVATE_COPY_LIMIT) {\n\t\tsize_limit_reached = 1;\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\n\tfile_cnt++;\n\tsize_cnt += s.st_size;\n\n\tif(ftype == FTW_F)\n\t\tcopy_file(path, dest, firejail_uid, firejail_gid, s.st_mode);\n\telse if (ftype == FTW_D) {\n\t\tif (mkdir(dest, s.st_mode) == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(dest, s.st_mode) < 0) {\n\t\t\tfprintf(stderr, \"Error: cannot change mode for %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tif (chown(dest, firejail_uid, firejail_gid) < 0) {\n\t\t\tfprintf(stderr, \"Error: cannot change ownership for %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\n#if 0\nstruct stat s2;\t\t\nif (stat(dest, &s2) == 0) {\n    printf(\"%s\\t\", dest);\n    printf((S_ISDIR(s.st_mode))  ? \"d\" : \"-\");\n    printf((s.st_mode & S_IRUSR) ? \"r\" : \"-\");\n    printf((s.st_mode & S_IWUSR) ? \"w\" : \"-\");\n    printf((s.st_mode & S_IXUSR) ? \"x\" : \"-\");\n    printf((s.st_mode & S_IRGRP) ? \"r\" : \"-\");\n    printf((s.st_mode & S_IWGRP) ? \"w\" : \"-\");\n    printf((s.st_mode & S_IXGRP) ? \"x\" : \"-\");\n    printf((s.st_mode & S_IROTH) ? \"r\" : \"-\");\n    printf((s.st_mode & S_IWOTH) ? \"w\" : \"-\");\n    printf((s.st_mode & S_IXOTH) ? \"x\" : \"-\");\n    printf(\"\\n\");\n}\n#endif\t\t\n\t\t\n\t\tfs_logger2(\"clone\", path);\n\t}\t\t\n\t\t\n\tfree(dest);\n\treturn(0);\n}\n\nstatic void duplicate(char *name) {\n\tchar *fname = check_dir_or_file(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: duplicating %s\\n\", fname);\n\tassert(strncmp(fname, cfg.homedir, strlen(cfg.homedir)) == 0);\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\t\n\tif(nftw(fname, fs_copydir, 1, FTW_PHYS) != 0) {\n\t\tfprintf(stderr, \"Error: unable to copy template dir\\n\");\n\t\texit(1);\n\t}\n\tfs_logger_print();\t// save the current log\n\n\tfree(fname);\n}\n\n\n\nstatic char *check_dir_or_file(const char *name) {\n\tassert(name);\n\tstruct stat s;\n\n\t// basic checks\n\tinvalid_filename(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: checking %s\\n\", name);\n\n\t// expand home directory\n\tchar *fname = expand_home(name, cfg.homedir);\n\tif (!fname) {\n\t\tfprintf(stderr, \"Error: file %s not found.\\n\", name);\n\t\texit(1);\n\t}\n\n\t// If it doesn't start with '/', it must be relative to homedir\n\tif (fname[0] != '/') {\n\t\tchar* tmp;\n\t\tif (asprintf(&tmp, \"%s/%s\", cfg.homedir, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfree(fname);\n\t\tfname = tmp;\n\t}\n\n\t// check the file is in user home directory\n\tchar *rname = realpath(fname, NULL);\n\tif (!rname) {\n\t\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\t\texit(1);\n\t}\n\tif (strncmp(rname, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: file %s is not in user home directory\\n\", name);\n\t\texit(1);\n\t}\n\t\n\t// a full home directory is not allowed\n\tif (strcmp(rname, cfg.homedir) == 0) {\n\t\tfprintf(stderr, \"Error: invalid directory %s\\n\", rname);\n\t\texit(1);\n\t}\n\t\n\t// only top files and directories in user home are allowed\n\tchar *ptr = rname + strlen(cfg.homedir);\n\tif (*ptr == '\\0') {\n\t\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\t\texit(1);\n\t}\n\tptr++;\n\tptr = strchr(ptr, '/');\n\tif (ptr) {\n\t\tif (*ptr != '\\0') {\n\t\t\tfprintf(stderr, \"Error: only top files and directories in user home are allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: file %s not found.\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// check uid\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tif (s.st_uid != uid || s.st_gid != gid) {\n\t\tfprintf(stderr, \"Error: only files or directories created by the current user are allowed.\\n\");\n\t\texit(1);\n\t}\n\n\t// dir or regular file\n\tif (S_ISDIR(s.st_mode) || S_ISREG(s.st_mode)) {\n\t\tfree(fname);\n\t\treturn rname;\t\t\t  // regular exit from the function\n\t}\n\n\tfprintf(stderr, \"Error: invalid file type, %s.\\n\", fname);\n\texit(1);\n}\n\n\n// check directory list specified by user (--private-home option) - exit if it fails\nvoid fs_check_home_list(void) {\n\tif (strstr(cfg.home_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private-home list\\n\");\n\t\texit(1);\n\t}\n\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tchar *tmp = check_dir_or_file(ptr);\n\tfree(tmp);\n\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\ttmp = check_dir_or_file(ptr);\n\t\tfree(tmp);\n\t}\n\n\tfree(dlist);\n}\n\n\n\n// private mode (--private-home=list):\n// \tmount homedir on top of /home/user,\n// \ttmpfs on top of  /root in nonroot mode,\n// \ttmpfs on top of /tmp in root mode,\n// \tset skel files,\n// \trestore .Xauthority\nvoid fs_private_home_list(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = firejail_uid;\n\tgid_t g = firejail_gid;\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\n\t// create /run/firejail/mnt/home directory\n\tfs_build_mnt_dir();\n\tint rv = mkdir(RUN_HOME_DIR, 0755);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_HOME_DIR, u, g) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_HOME_DIR, 0755) < 0)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_HOME_DIR, u, g, 0755);\n\n\tfs_logger_print();\t// save the current log\n\n\t// copy the list of files in the new home directory\n\t// using a new child process without root privileges\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t\t// drop privileges\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (setgid(getgid()) < 0)\n\t\t\terrExit(\"setgid/getgid\");\n\t\tif (setuid(getuid()) < 0)\n\t\t\terrExit(\"setuid/getuid\");\n\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(cfg.home_private_keep);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tduplicate(ptr);\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr);\n\n\t\tif (!arg_quiet) {\n\t\t\tif (size_limit_reached)\n\t\t\t\tfprintf(stderr, \"Warning: private-home copy limit of %u MB reached, not all the files were copied\\n\", \n\t\t\t\t\tPRIVATE_COPY_LIMIT / (1024 *1024));\n\t\t\telse\n\t\t\t\tprintf(\"Private home: %u files, total size %u bytes\\n\", file_cnt, size_cnt);\n\t\t}\n\n\t\tfs_logger_print();\t// save the current log\n\t\tfree(dlist);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2014-2016 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include \"firejail.h\"\n#include <sys/mount.h>\n#include <linux/limits.h>\n#include <glob.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <grp.h>\n#include <ftw.h>\n\nstatic void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644);\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, u, g, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644);\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, u, g, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0) \n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644);\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t}\n\t\tfree(fname);\n\t}\n}\n\nstatic int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tfs_build_mnt_dir();\n\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n\nstatic int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tfs_build_mnt_dir();\n\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n\nstatic void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\tfs_logger2(\"clone\", dest);\n\t\n\t// delete the temporary file\n\tunlink(src);\n}\n\nstatic void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}\n\n\n// private mode (--private=homedir):\n// \tmount homedir on top of /home/user,\n// \ttmpfs on top of  /root in nonroot mode,\n// \tset skel files,\n// \trestore .Xauthority\nvoid fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\t\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\t\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\t\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\tif (mount(private_homedir, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\t\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}\n\n// private mode (--private):\n//\tmount tmpfs over /home/user,\n// \ttmpfs on top of  /root in nonroot mode,\n// \tset skel files,\n// \trestore .Xauthority\nvoid fs_private(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\t// mask /home\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /home directory\\n\");\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting home directory\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// mask /root\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /root directory\\n\");\n\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\terrExit(\"mounting root directory\");\n\tfs_logger(\"tmpfs /root\");\n\n\tif (u != 0) {\n\t\t// create /home/user\n\t\tif (arg_debug)\n\t\t\tprintf(\"Create a new user directory\\n\");\n\t\tif (mkdir(homedir, S_IRWXU) == -1) {\n\t\t\tif (mkpath_as_root(homedir) == -1)\n\t\t\t\terrExit(\"mkpath\");\n\t\t\tif (mkdir(homedir, S_IRWXU) == -1)\n\t\t\t\terrExit(\"mkdir\");\n\t\t}\n\t\tif (chown(homedir, u, g) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger2(\"mkdir\", homedir);\n\t}\n\t\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n}\n\n// check new private home directory (--private= option) - exit if it fails\nvoid fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private);\n\t\n\t// Expand the home directory\n\tchar *tmp = expand_home(cfg.home_private, cfg.homedir);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\t\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)\n\t || is_link(cfg.home_private)\n\t || strstr(cfg.home_private, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n\n\t// check home directory and chroot home directory have the same owner\n\tstruct stat s2;\n\tint rv = stat(cfg.home_private, &s2);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory\\n\", cfg.home_private);\n\t\texit(1);\n\t}\n\n\tstruct stat s1;\n\trv = stat(cfg.homedir, &s1);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory, full path name required\\n\", cfg.homedir);\n\t\texit(1);\n\t}\n\tif (s1.st_uid != s2.st_uid) {\n\t\tprintf(\"Error: --private directory should be owned by the current user\\n\");\n\t\texit(1);\n\t}\n}\n\n//***********************************************************************************\n// --private-home\n//***********************************************************************************\n#define PRIVATE_COPY_LIMIT (500 * 1024 *1024)\nstatic int size_limit_reached = 0;\nstatic unsigned file_cnt = 0;\nstatic unsigned size_cnt = 0;\nstatic char *check_dir_or_file(const char *name);\n\nint fs_copydir(const char *path, const struct stat *st, int ftype, struct FTW *sftw) {\n\t(void) st;\n\t(void) sftw;\n\tif (size_limit_reached)\n\t\treturn 0;\n\n\tstruct stat s;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s%s\", RUN_HOME_DIR, path + strlen(cfg.homedir)) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// don't copy it if we already have the file\n\tif (stat(dest, &s) == 0) {\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\t\n\t// extract mode and ownership\n\tif (stat(path, &s) != 0) {\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\n\t// check uid\n\tif (s.st_uid != firejail_uid || s.st_gid != firejail_gid) {\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\n\tif ((s.st_size + size_cnt) > PRIVATE_COPY_LIMIT) {\n\t\tsize_limit_reached = 1;\n\t\tfree(dest);\n\t\treturn 0;\n\t}\n\n\tfile_cnt++;\n\tsize_cnt += s.st_size;\n\n\tif(ftype == FTW_F)\n\t\tcopy_file(path, dest, firejail_uid, firejail_gid, s.st_mode);\n\telse if (ftype == FTW_D) {\n\t\tif (mkdir(dest, s.st_mode) == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(dest, s.st_mode) < 0) {\n\t\t\tfprintf(stderr, \"Error: cannot change mode for %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tif (chown(dest, firejail_uid, firejail_gid) < 0) {\n\t\t\tfprintf(stderr, \"Error: cannot change ownership for %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\n#if 0\nstruct stat s2;\t\t\nif (stat(dest, &s2) == 0) {\n    printf(\"%s\\t\", dest);\n    printf((S_ISDIR(s.st_mode))  ? \"d\" : \"-\");\n    printf((s.st_mode & S_IRUSR) ? \"r\" : \"-\");\n    printf((s.st_mode & S_IWUSR) ? \"w\" : \"-\");\n    printf((s.st_mode & S_IXUSR) ? \"x\" : \"-\");\n    printf((s.st_mode & S_IRGRP) ? \"r\" : \"-\");\n    printf((s.st_mode & S_IWGRP) ? \"w\" : \"-\");\n    printf((s.st_mode & S_IXGRP) ? \"x\" : \"-\");\n    printf((s.st_mode & S_IROTH) ? \"r\" : \"-\");\n    printf((s.st_mode & S_IWOTH) ? \"w\" : \"-\");\n    printf((s.st_mode & S_IXOTH) ? \"x\" : \"-\");\n    printf(\"\\n\");\n}\n#endif\t\t\n\t\t\n\t\tfs_logger2(\"clone\", path);\n\t}\t\t\n\t\t\n\tfree(dest);\n\treturn(0);\n}\n\nstatic void duplicate(char *name) {\n\tchar *fname = check_dir_or_file(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: duplicating %s\\n\", fname);\n\tassert(strncmp(fname, cfg.homedir, strlen(cfg.homedir)) == 0);\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\t\n\tif(nftw(fname, fs_copydir, 1, FTW_PHYS) != 0) {\n\t\tfprintf(stderr, \"Error: unable to copy template dir\\n\");\n\t\texit(1);\n\t}\n\tfs_logger_print();\t// save the current log\n\n\tfree(fname);\n}\n\n\n\nstatic char *check_dir_or_file(const char *name) {\n\tassert(name);\n\tstruct stat s;\n\n\t// basic checks\n\tinvalid_filename(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: checking %s\\n\", name);\n\n\t// expand home directory\n\tchar *fname = expand_home(name, cfg.homedir);\n\tif (!fname) {\n\t\tfprintf(stderr, \"Error: file %s not found.\\n\", name);\n\t\texit(1);\n\t}\n\n\t// If it doesn't start with '/', it must be relative to homedir\n\tif (fname[0] != '/') {\n\t\tchar* tmp;\n\t\tif (asprintf(&tmp, \"%s/%s\", cfg.homedir, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfree(fname);\n\t\tfname = tmp;\n\t}\n\n\t// check the file is in user home directory\n\tchar *rname = realpath(fname, NULL);\n\tif (!rname) {\n\t\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\t\texit(1);\n\t}\n\tif (strncmp(rname, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: file %s is not in user home directory\\n\", name);\n\t\texit(1);\n\t}\n\t\n\t// a full home directory is not allowed\n\tif (strcmp(rname, cfg.homedir) == 0) {\n\t\tfprintf(stderr, \"Error: invalid directory %s\\n\", rname);\n\t\texit(1);\n\t}\n\t\n\t// only top files and directories in user home are allowed\n\tchar *ptr = rname + strlen(cfg.homedir);\n\tif (*ptr == '\\0') {\n\t\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\t\texit(1);\n\t}\n\tptr++;\n\tptr = strchr(ptr, '/');\n\tif (ptr) {\n\t\tif (*ptr != '\\0') {\n\t\t\tfprintf(stderr, \"Error: only top files and directories in user home are allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: file %s not found.\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// check uid\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tif (s.st_uid != uid || s.st_gid != gid) {\n\t\tfprintf(stderr, \"Error: only files or directories created by the current user are allowed.\\n\");\n\t\texit(1);\n\t}\n\n\t// dir or regular file\n\tif (S_ISDIR(s.st_mode) || S_ISREG(s.st_mode)) {\n\t\tfree(fname);\n\t\treturn rname;\t\t\t  // regular exit from the function\n\t}\n\n\tfprintf(stderr, \"Error: invalid file type, %s.\\n\", fname);\n\texit(1);\n}\n\n\n// check directory list specified by user (--private-home option) - exit if it fails\nvoid fs_check_home_list(void) {\n\tif (strstr(cfg.home_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private-home list\\n\");\n\t\texit(1);\n\t}\n\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tchar *tmp = check_dir_or_file(ptr);\n\tfree(tmp);\n\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\ttmp = check_dir_or_file(ptr);\n\t\tfree(tmp);\n\t}\n\n\tfree(dlist);\n}\n\n\n\n// private mode (--private-home=list):\n// \tmount homedir on top of /home/user,\n// \ttmpfs on top of  /root in nonroot mode,\n// \ttmpfs on top of /tmp in root mode,\n// \tset skel files,\n// \trestore .Xauthority\nvoid fs_private_home_list(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = firejail_uid;\n\tgid_t g = firejail_gid;\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\n\t// create /run/firejail/mnt/home directory\n\tfs_build_mnt_dir();\n\tint rv = mkdir(RUN_HOME_DIR, 0755);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_HOME_DIR, u, g) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_HOME_DIR, 0755) < 0)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_HOME_DIR, u, g, 0755);\n\n\tfs_logger_print();\t// save the current log\n\n\t// copy the list of files in the new home directory\n\t// using a new child process without root privileges\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t\t// drop privileges\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (setgid(getgid()) < 0)\n\t\t\terrExit(\"setgid/getgid\");\n\t\tif (setuid(getuid()) < 0)\n\t\t\terrExit(\"setuid/getuid\");\n\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(cfg.home_private_keep);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tduplicate(ptr);\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr);\n\n\t\tif (!arg_quiet) {\n\t\t\tif (size_limit_reached)\n\t\t\t\tfprintf(stderr, \"Warning: private-home copy limit of %u MB reached, not all the files were copied\\n\", \n\t\t\t\t\tPRIVATE_COPY_LIMIT / (1024 *1024));\n\t\t\telse\n\t\t\t\tprintf(\"Private home: %u files, total size %u bytes\\n\", file_cnt, size_cnt);\n\t\t}\n\n\t\tfs_logger_print();\t// save the current log\n\t\tfree(dlist);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}\n"], "filenames": ["src/firejail/fs_home.c"], "buggy_code_start_loc": [44], "buggy_code_end_loc": [130], "fixing_code_start_loc": [45], "fixing_code_end_loc": [142], "type": "CWE-269", "message": "Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.", "other": {"cve": {"id": "CVE-2017-5940", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T18:59:00.160", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180."}, {"lang": "es", "value": "Firejail en versiones anteriores a 0.9.44.6 y 0.9.38.x LTS en versiones anteriores a 0.9.38.10 LTS no aborda exhaustivamente los casos dotfile durante su intento de impedir el acceso a los archivos de usuario con un euid de cero, lo que permite a usuarios locales llevar a cabo ataques sybox-escape a trav\u00e9s de vectores que implican un enlace simb\u00f3lico y la opci\u00f3n --private. NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2017-5180."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:firejail_project:firejail:*:*:*:*:lts:*:*:*", "versionStartIncluding": "0.9.38", "versionEndIncluding": "0.9.38.10", "matchCriteriaId": "FBA4F089-E878-4C63-B9E7-F8ED37724459"}, {"vulnerable": true, "criteria": "cpe:2.3:a:firejail_project:firejail:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.40", "versionEndIncluding": "0.9.44.6", "matchCriteriaId": "B40A5CA1-1D35-4A2C-9F9F-4BC968AB0E42"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/01/31/16", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96221", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://firejail.wordpress.com/download-2/release-notes/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/netblue30/firejail/commit/38d418505e9ee2d326557e5639e8da49c298858f", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netblue30/firejail/commit/38d418505e9ee2d326557e5639e8da49c298858f"}}