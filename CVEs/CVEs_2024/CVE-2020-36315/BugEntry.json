{"buggy_code": ["/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (C) 2007-2020 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the RSA cryptosystem.\n *\n * @ingroup cp\n */\n\n#include <string.h>\n\n#include \"relic_core.h\"\n#include \"relic_conf.h\"\n#include \"relic_rand.h\"\n#include \"relic_bn.h\"\n#include \"relic_util.h\"\n#include \"relic_cp.h\"\n#include \"relic_md.h\"\n#include \"relic_multi.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Length of chosen padding scheme.\n */\n#if CP_RSAPD == PKCS1\n#define RSA_PAD_LEN\t\t(11)\n#elif CP_RSAPD == PKCS2\n#define RSA_PAD_LEN\t\t(2 * RLC_MD_LEN + 2)\n#else\n#define RSA_PAD_LEN\t\t(2)\n#endif\n\n/**\n * Identifier for encrypted messages.\n */\n#define RSA_PUB\t\t\t(02)\n\n/**\n * Identifier for signed messages.\n */\n#define RSA_PRV\t\t\t(01)\n\n/**\n * Byte used as padding unit.\n */\n#define RSA_PAD\t\t\t(0xFF)\n\n/**\n * Byte used as padding unit in PSS signatures.\n */\n#define RSA_PSS\t\t\t(0xBC)\n\n/**\n * Identifier for encryption.\n */\n#define RSA_ENC\t\t\t\t1\n\n/**\n * Identifier for decryption.\n */\n#define RSA_DEC\t\t\t\t2\n\n/**\n * Identifier for signature.\n */\n#define RSA_SIG\t\t\t\t3\n\n/**\n * Identifier for verification.\n */\n#define RSA_VER\t\t\t\t4\n\n/**\n * Identifier for second encryption step.\n */\n#define RSA_ENC_FIN\t\t\t5\n\n/**\n * Identifier for second sining step.\n */\n#define RSA_SIG_FIN\t\t\t6\n\n/**\n * Identifier for signature of a precomputed hash.\n */\n#define RSA_SIG_HASH\t\t7\n\n/**\n * Identifier for verification of a precomputed hash.\n */\n#define RSA_VER_HASH\t\t8\n\n#if CP_RSAPD == BASIC\n\n/**\n * Applies or removes simple encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_basic(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t pad = 0;\n\tint result = RLC_OK;\n\tbn_t t;\n\n\tRLC_TRY {\n\t\tbn_null(t);\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\t*p_len = 1;\n\t\t\t\tdo {\n\t\t\t\t\t(*p_len)++;\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad == 0 && m_len > 0);\n\t\t\t\tif (pad != RSA_PAD) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS1\n\n/**\n * ASN.1 identifier of the hash function SHA-224.\n */\nstatic const uint8_t sh224_id[] =\n\t\t{ 0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c };\n\n/**\n * ASN.1 identifier of the hash function SHA-256.\n */\nstatic const uint8_t sh256_id[] =\n\t\t{ 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20 };\n\n/**\n * ASN.1 identifier of the hash function SHA-384.\n */\nstatic const uint8_t sh384_id[] =\n\t\t{ 0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30 };\n\n/**\n * ASN.1 identifier of the hash function SHA-512.\n */\nstatic const uint8_t sh512_id[] =\n\t\t{ 0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40 };\n\n/**\n * Returns a pointer to the ASN.1 identifier of a hash function according to the\n * PKCS#1 v1.5 padding standard.\n *\n * @param[in] md\t\t\t- the hash function.\n * @param[in, out] len\t\t- the length of the identifier.\n * @return The pointer to the hash function identifier.\n */\nstatic uint8_t *hash_id(int md, int *len) {\n\tswitch (md) {\n\t\tcase SH224:\n\t\t\t*len = sizeof(sh224_id);\n\t\t\treturn (uint8_t *)sh224_id;\n\t\tcase SH256:\n\t\t\t*len = sizeof(sh256_id);\n\t\t\treturn (uint8_t *)sh256_id;\n\t\tcase SH384:\n\t\t\t*len = sizeof(sh384_id);\n\t\t\treturn (uint8_t *)sh384_id;\n\t\tcase SH512:\n\t\t\t*len = sizeof(sh512_id);\n\t\t\treturn (uint8_t *)sh512_id;\n\t\tdefault:\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn NULL;\n\t}\n}\n\n/**\n * Applies or removes a PKCS#1 v1.5 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t *id, pad = 0;\n\tint len, result = RLC_OK;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* EB = 00 | 02 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PUB);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tdo {\n\t\t\t\t\t\trand_bytes(&pad, 1);\n\t\t\t\t\t} while (pad == 0);\n\t\t\t\t\tbn_add_dig(m, m, pad);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\n\t\t\t\t*p_len = m_len;\n\t\t\t\tm_len--;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad != RSA_PUB) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t*p_len -= (m_len - 1);\n\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len - len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\tbn_lsh(m, m, 8 * len);\n\t\t\t\tbn_read_bin(t, id, len);\n\t\t\t\tbn_add(m, m, t);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tm_len--;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad != RSA_PRV) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\tif (m_len == 0) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\tm_len -= len;\n\n\t\t\t\tbn_rsh(t, m, m_len * 8);\n\t\t\t\tint r = 0;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tr |= pad - id[len - i - 1];\n\t\t\t\t\tbn_rsh(t, t, 8);\n\t\t\t\t}\n\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\tresult = (r == 0 ? RLC_OK : RLC_ERR);\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tm_len--;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad != RSA_PRV) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\tif (m_len == 0) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS2\n\n/**\n * Applies or removes a PKCS#1 v2.1 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n        uint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];\n        /* MSVC does not allow dynamic stack arrays */\n        uint8_t *mask = RLC_ALLOCA(uint8_t, k_len);\n\tint result = RLC_OK;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* DB = lHash | PS | 01 | D. */\n\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\t*p_len = k_len - 2 * RLC_MD_LEN - 2 - m_len;\n\t\t\t\tbn_lsh(m, m, *p_len * 8);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0x01);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_ENC_FIN:\n\t\t\t\t/* EB = 00 | maskedSeed | maskedDB. */\n\t\t\t\trand_bytes(h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t}\n\t\t\t\tbn_write_bin(mask, k_len - RLC_MD_LEN - 1, m);\n\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t}\n\t\t\t\tbn_read_bin(t, h1, RLC_MD_LEN);\n\t\t\t\tbn_lsh(t, t, 8 * (k_len - RLC_MD_LEN - 1));\n\t\t\t\tbn_add(t, t, m);\n\t\t\t\tbn_copy(m, t);\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\tbn_write_bin(mask, m_len, m);\n\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, m_len);\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t}\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t}\n\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\tpad = 0;\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\tpad |= h1[i] - h2[i];\n\t\t\t\t}\n\t\t\t\tif (result == RLC_OK) {\n\t\t\t\t\tresult = (pad ? RLC_ERR : RLC_OK);\n\t\t\t\t}\n\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t*p_len = bn_size_bin(m);\n\t\t\t\t(*p_len)--;\n\t\t\t\tbn_rsh(t, m, *p_len * 8);\n\t\t\t\tif (bn_cmp_dig(t, 1) != RLC_EQ) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tbn_mod_2b(m, m, *p_len * 8);\n\t\t\t\t*p_len = k_len - *p_len;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* M' = 00 00 00 00 00 00 00 00 | H(M). */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 64);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, RLC_MD_LEN * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_FIN:\n\t\t\t\tmemset(mask, 0, 8);\n\t\t\t\tbn_write_bin(mask + 8, RLC_MD_LEN, m);\n\t\t\t\tmd_map(h1, mask, RLC_MD_LEN + 8);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tt->dp[0] ^= 0x01;\n\t\t\t\t/* m_len is now the size in bits of the modulus. */\n\t\t\t\tbn_lsh(t, t, 8 * RLC_MD_LEN);\n\t\t\t\tbn_add(m, t, m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PSS);\n\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\tbn_set_bit(m, i, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tbn_mod_2b(t, m, 8);\n\t\t\t\tif (bn_cmp_dig(t, RSA_PSS) != RLC_EQ) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = m_len; i < 8 * k_len; i++) {\n\t\t\t\t\t\tif (bn_get_bit(m, i) != 0) {\n\t\t\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbn_rsh(m, m, 8);\n\t\t\t\t\tbn_mod_2b(t, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tbn_rsh(m, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm->dp[0] ^= 0x01;\n\t\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\t\tbn_set_bit(m, i - ((RLC_MD_LEN + 1) * 8), 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (!bn_is_zero(m)) {\n\t\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t\t}\n\t\t\t\t\tbn_read_bin(m, h2, RLC_MD_LEN);\n\t\t\t\t\t*p_len = k_len - RLC_MD_LEN;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n        RLC_FREE(mask);\n\n\treturn result;\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_rsa_gen(rsa_t pub, rsa_t prv, int bits) {\n\tbn_t t, r;\n\tint result = RLC_OK;\n\n\tif (pub == NULL || prv == NULL || bits == 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tbn_null(t);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(r);\n\n\t\t/* Generate different primes p and q. */\n\t\tdo {\n\t\t\tbn_gen_prime(prv->crt->p, bits / 2);\n\t\t\tbn_gen_prime(prv->crt->q, bits / 2);\n\t\t} while (bn_cmp(prv->crt->p, prv->crt->q) == RLC_EQ);\n\n\t\t/* Swap p and q so that p is smaller. */\n\t\tif (bn_cmp(prv->crt->p, prv->crt->q) != RLC_LT) {\n\t\t\tbn_copy(t, prv->crt->p);\n\t\t\tbn_copy(prv->crt->p, prv->crt->q);\n\t\t\tbn_copy(prv->crt->q, t);\n\t\t}\n\n\t\t/* n = pq. */\n\t\tbn_mul(pub->crt->n, prv->crt->p, prv->crt->q);\n\t\tbn_copy(prv->crt->n, pub->crt->n);\n\t\tbn_sub_dig(prv->crt->p, prv->crt->p, 1);\n\t\tbn_sub_dig(prv->crt->q, prv->crt->q, 1);\n\n\t\t/* phi(n) = (p - 1)(q - 1). */\n\t\tbn_mul(t, prv->crt->p, prv->crt->q);\n\n\t\tbn_set_2b(pub->e, 16);\n\t\tbn_add_dig(pub->e, pub->e, 1);\n\n#if !defined(CP_CRT)\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\tresult = RLC_OK;\n\t\t}\n#else\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* dP = d mod (p - 1). */\n\t\t\tbn_mod(prv->crt->dp, prv->d, prv->crt->p);\n\t\t\t/* dQ = d mod (q - 1). */\n\t\t\tbn_mod(prv->crt->dq, prv->d, prv->crt->q);\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\t/* qInv = q^(-1) mod p. */\n\t\t\tbn_mod_inv(prv->crt->qi, prv->crt->q, prv->crt->p);\n\n\t\t\tresult = RLC_OK;\n\t\t}\n#endif /* CP_CRT */\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(r);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_enc(uint8_t *out, int *out_len, uint8_t *in, int in_len, rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(pub->crt->n);\n\n\tif (pub == NULL || in_len <= 0 || in_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#endif\n\t\t\tbn_read_bin(m, in, in_len);\n\t\t\tbn_add(eb, eb, m);\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC_FIN);\n#endif\n\t\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\t*out_len = size;\n\t\t\t\tmemset(out, 0, *out_len);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_dec(uint8_t *out, int *out_len, uint8_t *in, int in_len, rsa_t prv) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(prv->crt->n);\n\n\tif (prv == NULL || in_len != size || in_len < RSA_PAD_LEN) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, in, in_len);\n#if !defined(CP_CRT)\n\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else\n\n\t\tbn_copy(m, eb);\n\n#if MULTI == OPENMP\n\t\tomp_set_num_threads(CORES);\n\t\t#pragma omp parallel copyin(core_ctx) firstprivate(prv)\n\t\t{\n\t\t\t#pragma omp sections\n\t\t\t{\n\t\t\t\t#pragma omp section\n\t\t\t\t{\n#endif\n\t\t\t\t\t/* m1 = c^dP mod p. */\n\t\t\t\t\tbn_mxp(eb, eb, prv->crt->dp, prv->crt->p);\n\n#if MULTI == OPENMP\n\t\t\t\t}\n\t\t\t\t#pragma omp section\n\t\t\t\t{\n#endif\n\t\t\t\t\t/* m2 = c^dQ mod q. */\n\t\t\t\t\tbn_mxp(m, m, prv->crt->dq, prv->crt->q);\n\n#if MULTI == OPENMP\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\t/* m1 = m1 - m2 mod p. */\n\t\tbn_sub(eb, eb, m);\n\t\twhile (bn_sign(eb) == RLC_NEG) {\n\t\t\tbn_add(eb, eb, prv->crt->p);\n\t\t}\n\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t/* m1 = qInv(m1 - m2) mod p. */\n\t\tbn_mul(eb, eb, prv->crt->qi);\n\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t/* m = m2 + m1 * q. */\n\t\tbn_mul(eb, eb, prv->crt->q);\n\t\tbn_add(eb, eb, m);\n\n#endif /* CP_CRT */\n\n\t\tif (bn_cmp(eb, prv->crt->n) != RLC_LT) {\n\t\t\tresult = RLC_ERR;\n\t\t}\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#endif\n\t\t\tsize = size - pad_len;\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\tmemset(out, 0, size);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t\t*out_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_sig(uint8_t *sig, int *sig_len, uint8_t *msg, int msg_len, int hash, rsa_t prv) {\n\tbn_t m, eb;\n\tint pad_len, size, result = RLC_OK;\n\tuint8_t h[RLC_MD_LEN];\n\n\tif (prv == NULL || msg_len < 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(prv->crt->n) - 1;\n\tsize = (size / 8) + (size % 8 > 0);\n\tif (pad_len > (size - 2)) {\n\t\treturn RLC_ERR;\n\t}\n#else\n\tsize = bn_size_bin(prv->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n\t\tint operation = (!hash ? RSA_SIG : RSA_SIG_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#endif\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h, msg, msg_len);\n\t\t\t\tbn_read_bin(m, h, RLC_MD_LEN);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t} else {\n\t\t\t\tbn_read_bin(m, msg, msg_len);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t}\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, bn_bits(prv->crt->n), size, RSA_SIG_FIN);\n#endif\n\n\t\t\tbn_copy(m, eb);\n\n#if !defined(CP_CRT)\n\t\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else  /* CP_CRT */\n\n#if MULTI == OPENMP\n\t\t\tomp_set_num_threads(CORES);\n\t\t\t#pragma omp parallel copyin(core_ctx) firstprivate(prv)\n\t\t\t{\n\t\t\t\t#pragma omp sections\n\t\t\t\t{\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m1 = c^dP mod p. */\n\t\t\t\t\t\tbn_mxp(eb, eb, prv->crt->dp, prv->crt->p);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m2 = c^dQ mod q. */\n\t\t\t\t\t\tbn_mxp(m, m, prv->crt->dq, prv->crt->q);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t/* m1 = m1 - m2 mod p. */\n\t\t\tbn_sub(eb, eb, m);\n\t\t\twhile (bn_sign(eb) == RLC_NEG) {\n\t\t\t\tbn_add(eb, eb, prv->crt->p);\n\t\t\t}\n\t\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t\t/* m1 = qInv(m1 - m2) mod p. */\n\t\t\tbn_mul(eb, eb, prv->crt->qi);\n\t\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t\t/* m = m2 + m1 * q. */\n\t\t\tbn_mul(eb, eb, prv->crt->q);\n\t\t\tbn_add(eb, eb, m);\n\t\t\tbn_mod(eb, eb, prv->crt->n);\n\n#endif /* CP_CRT */\n\n\t\t\tsize = bn_size_bin(prv->crt->n);\n\n\t\t\tif (size <= *sig_len) {\n\t\t\t\tmemset(sig, 0, size);\n\t\t\t\tbn_write_bin(sig, size, eb);\n\t\t\t\t*sig_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_ver(uint8_t *sig, int sig_len, uint8_t *msg, int msg_len, int hash, rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result;\n\tuint8_t *h1 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN) + 8);\n\tuint8_t *h2 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN));\n\n\t/* We suppose that the signature is invalid. */\n\tresult = 0;\n\n\tif (h1 == NULL || h2 == NULL) {\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t\treturn 0;\n\t}\n\n\tif (pub == NULL || msg_len < 0) {\n\t\treturn 0;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(pub->crt->n) - 1;\n\tif (size % 8 == 0) {\n\t\tsize = size / 8 - 1;\n\t} else {\n\t\tsize = bn_size_bin(pub->crt->n);\n\t}\n\tif (pad_len > (size - 2)) {\n\t\treturn 0;\n\t}\n#else\n\tsize = bn_size_bin(pub->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn 0;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, sig, sig_len);\n\n\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\tint operation = (!hash ? RSA_VER : RSA_VER_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, bn_bits(pub->crt->n), size, operation) == RLC_OK) {\n#endif\n\n#if CP_RSAPD == PKCS2\n\t\t\tmemset(h1, 0, 8);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, RLC_MD_LEN);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\tmemcpy(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, msg_len);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, msg_len);\n\t\t\t}\n#else\n\t\t\tmemset(h1, 0, RLC_MAX(msg_len, RLC_MD_LEN));\n\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h2, msg, msg_len);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, msg, msg_len);\n\t\t\t}\n#endif\n\t\t\tresult = (result == RLC_EQ ? 1 : 0);\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t}\n\n\treturn result;\n}\n"], "fixing_code": ["/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (C) 2007-2020 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the RSA cryptosystem.\n *\n * @ingroup cp\n */\n\n#include <string.h>\n\n#include \"relic_core.h\"\n#include \"relic_conf.h\"\n#include \"relic_rand.h\"\n#include \"relic_bn.h\"\n#include \"relic_util.h\"\n#include \"relic_cp.h\"\n#include \"relic_md.h\"\n#include \"relic_multi.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Length of chosen padding scheme.\n */\n#if CP_RSAPD == PKCS1\n#define RSA_PAD_LEN\t\t(11)\n#elif CP_RSAPD == PKCS2\n#define RSA_PAD_LEN\t\t(2 * RLC_MD_LEN + 2)\n#else\n#define RSA_PAD_LEN\t\t(2)\n#endif\n\n/**\n * Identifier for encrypted messages.\n */\n#define RSA_PUB\t\t\t(02)\n\n/**\n * Identifier for signed messages.\n */\n#define RSA_PRV\t\t\t(01)\n\n/**\n * Byte used as padding unit.\n */\n#define RSA_PAD\t\t\t(0xFF)\n\n/**\n * Byte used as padding unit in PSS signatures.\n */\n#define RSA_PSS\t\t\t(0xBC)\n\n/**\n * Identifier for encryption.\n */\n#define RSA_ENC\t\t\t\t1\n\n/**\n * Identifier for decryption.\n */\n#define RSA_DEC\t\t\t\t2\n\n/**\n * Identifier for signature.\n */\n#define RSA_SIG\t\t\t\t3\n\n/**\n * Identifier for verification.\n */\n#define RSA_VER\t\t\t\t4\n\n/**\n * Identifier for second encryption step.\n */\n#define RSA_ENC_FIN\t\t\t5\n\n/**\n * Identifier for second sining step.\n */\n#define RSA_SIG_FIN\t\t\t6\n\n/**\n * Identifier for signature of a precomputed hash.\n */\n#define RSA_SIG_HASH\t\t7\n\n/**\n * Identifier for verification of a precomputed hash.\n */\n#define RSA_VER_HASH\t\t8\n\n#if CP_RSAPD == BASIC\n\n/**\n * Applies or removes simple encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_basic(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t pad = 0;\n\tint result = RLC_ERR;\n\tbn_t t;\n\n\tRLC_TRY {\n\t\tbn_null(t);\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t*p_len = 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\t(*p_len)++;\n\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t} while (pad == 0 && m_len > 0);\n\t\t\t\t\tif (pad == RSA_PAD) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS1\n\n/**\n * ASN.1 identifier of the hash function SHA-224.\n */\nstatic const uint8_t sh224_id[] =\n\t\t{ 0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c };\n\n/**\n * ASN.1 identifier of the hash function SHA-256.\n */\nstatic const uint8_t sh256_id[] =\n\t\t{ 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20 };\n\n/**\n * ASN.1 identifier of the hash function SHA-384.\n */\nstatic const uint8_t sh384_id[] =\n\t\t{ 0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30 };\n\n/**\n * ASN.1 identifier of the hash function SHA-512.\n */\nstatic const uint8_t sh512_id[] =\n\t\t{ 0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,\n\t\t\t0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40 };\n\n/**\n * Returns a pointer to the ASN.1 identifier of a hash function according to the\n * PKCS#1 v1.5 padding standard.\n *\n * @param[in] md\t\t\t- the hash function.\n * @param[in, out] len\t\t- the length of the identifier.\n * @return The pointer to the hash function identifier.\n */\nstatic uint8_t *hash_id(int md, int *len) {\n\tswitch (md) {\n\t\tcase SH224:\n\t\t\t*len = sizeof(sh224_id);\n\t\t\treturn (uint8_t *)sh224_id;\n\t\tcase SH256:\n\t\t\t*len = sizeof(sh256_id);\n\t\t\treturn (uint8_t *)sh256_id;\n\t\tcase SH384:\n\t\t\t*len = sizeof(sh384_id);\n\t\t\treturn (uint8_t *)sh384_id;\n\t\tcase SH512:\n\t\t\t*len = sizeof(sh512_id);\n\t\t\treturn (uint8_t *)sh512_id;\n\t\tdefault:\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn NULL;\n\t}\n}\n\n/**\n * Applies or removes a PKCS#1 v1.5 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t *id, pad = 0;\n\tint len, result = RLC_ERR;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* EB = 00 | 02 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PUB);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tdo {\n\t\t\t\t\t\trand_bytes(&pad, 1);\n\t\t\t\t\t} while (pad == 0);\n\t\t\t\t\tbn_add_dig(m, m, pad);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t*p_len = m_len;\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PUB) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\t*p_len -= (m_len - 1);\n\t\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\t\t\tresult = (m_len > 0 ? RLC_OK : RLC_ERR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len - len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\tbn_lsh(m, m, 8 * len);\n\t\t\t\tbn_read_bin(t, id, len);\n\t\t\t\tbn_add(m, m, t);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PRV) {\n\t\t\t\t\t\tint counter = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\t\t\tm_len -= len;\n\n\t\t\t\t\t\tbn_rsh(t, m, m_len * 8);\n\t\t\t\t\t\tint r = 0;\n\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t\tr |= pad ^ id[len - i - 1];\n\t\t\t\t\t\t\tbn_rsh(t, t, 8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\t\t\tif (r && m_len > 0 && counter >= 8) {\n\t\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PRV) {\n\t\t\t\t\t\tint counter = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\t\t\tif (m_len > 0 && counter >= 8) {\n\t\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS2\n\n/**\n * Applies or removes a PKCS#1 v2.1 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n        uint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];\n        /* MSVC does not allow dynamic stack arrays */\n        uint8_t *mask = RLC_ALLOCA(uint8_t, k_len);\n\tint result = RLC_ERR;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* DB = lHash | PS | 01 | D. */\n\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\t*p_len = k_len - 2 * RLC_MD_LEN - 2 - m_len;\n\t\t\t\tbn_lsh(m, m, *p_len * 8);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0x01);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_ENC_FIN:\n\t\t\t\t/* EB = 00 | maskedSeed | maskedDB. */\n\t\t\t\trand_bytes(h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t}\n\t\t\t\tbn_write_bin(mask, k_len - RLC_MD_LEN - 1, m);\n\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t}\n\t\t\t\tbn_read_bin(t, h1, RLC_MD_LEN);\n\t\t\t\tbn_lsh(t, t, 8 * (k_len - RLC_MD_LEN - 1));\n\t\t\t\tbn_add(t, t, m);\n\t\t\t\tbn_copy(m, t);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(mask, m_len, m);\n\t\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, m_len);\n\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t\t}\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\t\tpad = 0;\n\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\t\tpad |= h1[i] ^ h2[i];\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t\t*p_len = bn_size_bin(m);\n\t\t\t\t\t(*p_len)--;\n\t\t\t\t\tbn_rsh(t, m, *p_len * 8);\n\t\t\t\t\tif (pad == 0 && bn_cmp_dig(t, 1) == RLC_EQ) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, *p_len * 8);\n\t\t\t\t\t*p_len = k_len - *p_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* M' = 00 00 00 00 00 00 00 00 | H(M). */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 64);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, RLC_MD_LEN * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_FIN:\n\t\t\t\tmemset(mask, 0, 8);\n\t\t\t\tbn_write_bin(mask + 8, RLC_MD_LEN, m);\n\t\t\t\tmd_map(h1, mask, RLC_MD_LEN + 8);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tt->dp[0] ^= 0x01;\n\t\t\t\t/* m_len is now the size in bits of the modulus. */\n\t\t\t\tbn_lsh(t, t, 8 * RLC_MD_LEN);\n\t\t\t\tbn_add(m, t, m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PSS);\n\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\tbn_set_bit(m, i, 0);\n\t\t\t\t}\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tbn_mod_2b(t, m, 8);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad == RSA_PSS) {\n\t\t\t\t\tint r = 1;\n\t\t\t\t\tfor (int i = m_len; i < 8 * k_len; i++) {\n\t\t\t\t\t\tif (bn_get_bit(m, i) != 0) {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbn_rsh(m, m, 8);\n\t\t\t\t\tbn_mod_2b(t, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tbn_rsh(m, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm->dp[0] ^= 0x01;\n\t\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\t\tbn_set_bit(m, i - ((RLC_MD_LEN + 1) * 8), 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (r == 1 && bn_is_zero(m)) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_read_bin(m, h2, RLC_MD_LEN);\n\t\t\t\t\t*p_len = k_len - RLC_MD_LEN;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n        RLC_FREE(mask);\n\n\treturn result;\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_rsa_gen(rsa_t pub, rsa_t prv, int bits) {\n\tbn_t t, r;\n\tint result = RLC_OK;\n\n\tif (pub == NULL || prv == NULL || bits == 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tbn_null(t);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(r);\n\n\t\t/* Generate different primes p and q. */\n\t\tdo {\n\t\t\tbn_gen_prime(prv->crt->p, bits / 2);\n\t\t\tbn_gen_prime(prv->crt->q, bits / 2);\n\t\t} while (bn_cmp(prv->crt->p, prv->crt->q) == RLC_EQ);\n\n\t\t/* Swap p and q so that p is smaller. */\n\t\tif (bn_cmp(prv->crt->p, prv->crt->q) != RLC_LT) {\n\t\t\tbn_copy(t, prv->crt->p);\n\t\t\tbn_copy(prv->crt->p, prv->crt->q);\n\t\t\tbn_copy(prv->crt->q, t);\n\t\t}\n\n\t\t/* n = pq. */\n\t\tbn_mul(pub->crt->n, prv->crt->p, prv->crt->q);\n\t\tbn_copy(prv->crt->n, pub->crt->n);\n\t\tbn_sub_dig(prv->crt->p, prv->crt->p, 1);\n\t\tbn_sub_dig(prv->crt->q, prv->crt->q, 1);\n\n\t\t/* phi(n) = (p - 1)(q - 1). */\n\t\tbn_mul(t, prv->crt->p, prv->crt->q);\n\n\t\tbn_set_2b(pub->e, 16);\n\t\tbn_add_dig(pub->e, pub->e, 1);\n\n#if !defined(CP_CRT)\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\tresult = RLC_OK;\n\t\t}\n#else\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* dP = d mod (p - 1). */\n\t\t\tbn_mod(prv->crt->dp, prv->d, prv->crt->p);\n\t\t\t/* dQ = d mod (q - 1). */\n\t\t\tbn_mod(prv->crt->dq, prv->d, prv->crt->q);\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\t/* qInv = q^(-1) mod p. */\n\t\t\tbn_mod_inv(prv->crt->qi, prv->crt->q, prv->crt->p);\n\n\t\t\tresult = RLC_OK;\n\t\t}\n#endif /* CP_CRT */\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(r);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_enc(uint8_t *out, int *out_len, uint8_t *in, int in_len, rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(pub->crt->n);\n\n\tif (pub == NULL || in_len <= 0 || in_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#endif\n\t\t\tbn_read_bin(m, in, in_len);\n\t\t\tbn_add(eb, eb, m);\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC_FIN);\n#endif\n\t\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\t*out_len = size;\n\t\t\t\tmemset(out, 0, *out_len);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_dec(uint8_t *out, int *out_len, uint8_t *in, int in_len, rsa_t prv) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(prv->crt->n);\n\n\tif (prv == NULL || in_len != size || in_len < RSA_PAD_LEN) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, in, in_len);\n#if !defined(CP_CRT)\n\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else\n\n\t\tbn_copy(m, eb);\n\n#if MULTI == OPENMP\n\t\tomp_set_num_threads(CORES);\n\t\t#pragma omp parallel copyin(core_ctx) firstprivate(prv)\n\t\t{\n\t\t\t#pragma omp sections\n\t\t\t{\n\t\t\t\t#pragma omp section\n\t\t\t\t{\n#endif\n\t\t\t\t\t/* m1 = c^dP mod p. */\n\t\t\t\t\tbn_mxp(eb, eb, prv->crt->dp, prv->crt->p);\n\n#if MULTI == OPENMP\n\t\t\t\t}\n\t\t\t\t#pragma omp section\n\t\t\t\t{\n#endif\n\t\t\t\t\t/* m2 = c^dQ mod q. */\n\t\t\t\t\tbn_mxp(m, m, prv->crt->dq, prv->crt->q);\n\n#if MULTI == OPENMP\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\t/* m1 = m1 - m2 mod p. */\n\t\tbn_sub(eb, eb, m);\n\t\twhile (bn_sign(eb) == RLC_NEG) {\n\t\t\tbn_add(eb, eb, prv->crt->p);\n\t\t}\n\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t/* m1 = qInv(m1 - m2) mod p. */\n\t\tbn_mul(eb, eb, prv->crt->qi);\n\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t/* m = m2 + m1 * q. */\n\t\tbn_mul(eb, eb, prv->crt->q);\n\t\tbn_add(eb, eb, m);\n\n#endif /* CP_CRT */\n\n\t\tif (bn_cmp(eb, prv->crt->n) != RLC_LT) {\n\t\t\tresult = RLC_ERR;\n\t\t}\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#endif\n\t\t\tsize = size - pad_len;\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\tmemset(out, 0, size);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t\t*out_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_sig(uint8_t *sig, int *sig_len, uint8_t *msg, int msg_len, int hash, rsa_t prv) {\n\tbn_t m, eb;\n\tint pad_len, size, result = RLC_OK;\n\tuint8_t h[RLC_MD_LEN];\n\n\tif (prv == NULL || msg_len < 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(prv->crt->n) - 1;\n\tsize = (size / 8) + (size % 8 > 0);\n\tif (pad_len > (size - 2)) {\n\t\treturn RLC_ERR;\n\t}\n#else\n\tsize = bn_size_bin(prv->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n\t\tint operation = (!hash ? RSA_SIG : RSA_SIG_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#endif\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h, msg, msg_len);\n\t\t\t\tbn_read_bin(m, h, RLC_MD_LEN);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t} else {\n\t\t\t\tbn_read_bin(m, msg, msg_len);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t}\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, bn_bits(prv->crt->n), size, RSA_SIG_FIN);\n#endif\n\n\t\t\tbn_copy(m, eb);\n\n#if !defined(CP_CRT)\n\t\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else  /* CP_CRT */\n\n#if MULTI == OPENMP\n\t\t\tomp_set_num_threads(CORES);\n\t\t\t#pragma omp parallel copyin(core_ctx) firstprivate(prv)\n\t\t\t{\n\t\t\t\t#pragma omp sections\n\t\t\t\t{\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m1 = c^dP mod p. */\n\t\t\t\t\t\tbn_mxp(eb, eb, prv->crt->dp, prv->crt->p);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m2 = c^dQ mod q. */\n\t\t\t\t\t\tbn_mxp(m, m, prv->crt->dq, prv->crt->q);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t/* m1 = m1 - m2 mod p. */\n\t\t\tbn_sub(eb, eb, m);\n\t\t\twhile (bn_sign(eb) == RLC_NEG) {\n\t\t\t\tbn_add(eb, eb, prv->crt->p);\n\t\t\t}\n\t\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t\t/* m1 = qInv(m1 - m2) mod p. */\n\t\t\tbn_mul(eb, eb, prv->crt->qi);\n\t\t\tbn_mod(eb, eb, prv->crt->p);\n\t\t\t/* m = m2 + m1 * q. */\n\t\t\tbn_mul(eb, eb, prv->crt->q);\n\t\t\tbn_add(eb, eb, m);\n\t\t\tbn_mod(eb, eb, prv->crt->n);\n\n#endif /* CP_CRT */\n\n\t\t\tsize = bn_size_bin(prv->crt->n);\n\n\t\t\tif (size <= *sig_len) {\n\t\t\t\tmemset(sig, 0, size);\n\t\t\t\tbn_write_bin(sig, size, eb);\n\t\t\t\t*sig_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_ver(uint8_t *sig, int sig_len, uint8_t *msg, int msg_len, int hash, rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result;\n\tuint8_t *h1 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN) + 8);\n\tuint8_t *h2 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN));\n\n\t/* We suppose that the signature is invalid. */\n\tresult = 0;\n\n\tif (h1 == NULL || h2 == NULL) {\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t\treturn 0;\n\t}\n\n\tif (pub == NULL || msg_len < 0) {\n\t\treturn 0;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(pub->crt->n) - 1;\n\tif (size % 8 == 0) {\n\t\tsize = size / 8 - 1;\n\t} else {\n\t\tsize = bn_size_bin(pub->crt->n);\n\t}\n\tif (pad_len > (size - 2)) {\n\t\treturn 0;\n\t}\n#else\n\tsize = bn_size_bin(pub->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn 0;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, sig, sig_len);\n\n\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\tint operation = (!hash ? RSA_VER : RSA_VER_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, bn_bits(pub->crt->n), size, operation) == RLC_OK) {\n#endif\n\n#if CP_RSAPD == PKCS2\n\t\t\tmemset(h1, 0, 8);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, RLC_MD_LEN);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\tmemcpy(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, msg_len);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, msg_len);\n\t\t\t}\n#else\n\t\t\tmemset(h1, 0, RLC_MAX(msg_len, RLC_MD_LEN));\n\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h2, msg, msg_len);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, msg, msg_len);\n\t\t\t}\n#endif\n\t\t\tresult = (result == RLC_EQ ? 1 : 0);\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t}\n\n\treturn result;\n}\n"], "filenames": ["src/cp/relic_cp_rsa.c"], "buggy_code_start_loc": [132], "buggy_code_end_loc": [560], "fixing_code_start_loc": [132], "fixing_code_end_loc": [560], "type": "CWE-327", "message": "In RELIC before 2020-08-01, RSA PKCS#1 v1.5 signature forgery can occur because certain checks of the padding (and of the first two bytes) are inadequate. NOTE: this requires that a low public exponent (such as 3) is being used. The product, by default, does not generate RSA keys with such a low number.", "other": {"cve": {"id": "CVE-2020-36315", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-07T21:15:15.870", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In RELIC before 2020-08-01, RSA PKCS#1 v1.5 signature forgery can occur because certain checks of the padding (and of the first two bytes) are inadequate. NOTE: this requires that a low public exponent (such as 3) is being used. The product, by default, does not generate RSA keys with such a low number."}, {"lang": "es", "value": "En RELIC antes del 01-08-2020, la falsificaci\u00f3n de firma RSA PKCS # 1 v1.5 puede ocurrir porque determinadas comprobaciones de relleno (y de los primeros dos bytes) son inadecuadas.&#xa0;NOTA: esto requiere que un exponente p\u00fablico bajo sea utilizado (como 3).&#xa0;El producto, por defecto, no genera claves RSA con un n\u00famero tan bajo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-327"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:relic_project:relic:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-08-01", "matchCriteriaId": "30E26998-9B9A-4DAD-BCBA-1022C26623C7"}]}]}], "references": [{"url": "https://github.com/relic-toolkit/relic/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/relic-toolkit/relic/commit/76c9a1fdf19d9e92e566a77376673e522aae9f80", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/relic-toolkit/relic/issues/154", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/relic-toolkit/relic/tree/32eb4c257fc80328061d66639b1cdb35dbed51a2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/relic-toolkit/relic/commit/76c9a1fdf19d9e92e566a77376673e522aae9f80"}}