{"buggy_code": ["/*\n * Copyright (C) 2002,2003 by Andreas Gruenbacher <a.gruenbacher@computer.org>\n *\n * Fixes from William Schumacher incorporated on 15 March 2001.\n *    (Reported by Charles Bertsch, <CBertsch@microtest.com>).\n */\n\n/*\n *  This file contains generic functions for manipulating\n *  POSIX 1003.1e draft standard 17 ACLs.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    atomic_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}\nEXPORT_SYMBOL(get_cached_acl);\n\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\treturn rcu_dereference(*acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(get_cached_acl_rcu);\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\nEXPORT_SYMBOL(set_cached_acl);\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(forget_cached_acl);\n\nvoid forget_all_cached_acls(struct inode *inode)\n{\n\t__forget_cached_acl(&inode->i_acl);\n\t__forget_cached_acl(&inode->i_default_acl);\n}\nEXPORT_SYMBOL(forget_all_cached_acls);\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}\nEXPORT_SYMBOL(get_acl);\n\n/*\n * Init a fresh posix_acl\n */\nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\tatomic_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}\nEXPORT_SYMBOL(posix_acl_init);\n\n/*\n * Allocate a new ACL with the specified number of entries.\n */\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_alloc);\n\n/*\n * Clone an ACL.\n */\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\n\n/*\n * Check if an acl is valid. Returns 0 if it is, or -E... otherwise.\n */\nint\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(posix_acl_valid);\n\n/*\n * Returns 0 if the acl can be exactly represented in the traditional\n * file mode permission bits, or else 1. Returns -E... on error.\n */\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\nEXPORT_SYMBOL(posix_acl_equiv_mode);\n\n/*\n * Create an ACL representing the file mode permission bits of an inode.\n */\nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_from_mode);\n\n/*\n * Return 0 if current is granted want access to the inode\n * by the acl. Returns -E... otherwise.\n */\nint\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\n{\n\tconst struct posix_acl_entry *pa, *pe, *mask_obj;\n\tint found = 0;\n\n\twant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\t/* (May have been checked already) */\n\t\t\t\tif (uid_eq(inode->i_uid, current_fsuid()))\n                                        goto check_perm;\n                                break;\n                        case ACL_USER:\n\t\t\t\tif (uid_eq(pa->e_uid, current_fsuid()))\n                                        goto mask;\n\t\t\t\tbreak;\n                        case ACL_GROUP_OBJ:\n                                if (in_group_p(inode->i_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n\t\t\t\tbreak;\n                        case ACL_GROUP:\n\t\t\t\tif (in_group_p(pa->e_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n                                break;\n                        case ACL_MASK:\n                                break;\n                        case ACL_OTHER:\n\t\t\t\tif (found)\n\t\t\t\t\treturn -EACCES;\n\t\t\t\telse\n\t\t\t\t\tgoto check_perm;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\treturn -EIO;\n\nmask:\n\tfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n\t\tif (mask_obj->e_tag == ACL_MASK) {\n\t\t\tif ((pa->e_perm & mask_obj->e_perm & want) == want)\n\t\t\t\treturn 0;\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\ncheck_perm:\n\tif ((pa->e_perm & want) == want)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/*\n * Modify acl when creating a new inode. The caller must ensure the acl is\n * only referenced once.\n *\n * mode_p initially must contain the mode parameter to the open() / creat()\n * system calls. All permissions that are not granted by the acl are removed.\n * The permissions in the acl are changed to reflect the mode_p parameter.\n */\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\n\n/*\n * Modify the ACL for the chmod syscall.\n */\nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}\n\nint\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_create);\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_chmod);\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}\nEXPORT_SYMBOL(posix_acl_chmod);\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tret = -ENOMEM;\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto err_release;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto err_release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nerr_release_clone:\n\tposix_acl_release(clone);\nerr_release:\n\tposix_acl_release(p);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(posix_acl_create);\n\n/**\n * posix_acl_update_mode  -  update mode in set_acl\n *\n * Update the file mode when setting an ACL: compute the new file permission\n * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n * file mode, set *acl to NULL to indicate that no ACL should be set.\n *\n * As with chmod, clear the setgit bit if the caller is not in the owning group\n * or capable of CAP_FSETID (see inode_change_ok).\n *\n * Called from set_acl inode operations.\n */\nint posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}\nEXPORT_SYMBOL(posix_acl_update_mode);\n\n/*\n * Fix up the uids and gids in posix acl extended attributes in place.\n */\nstatic void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}\n\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}\n\n/*\n * Convert from extended attribute to in-memory representation.\n */\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL (posix_acl_from_xattr);\n\n/*\n * Convert from in-memory to extended attribute representation.\n */\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\nEXPORT_SYMBOL (posix_acl_to_xattr);\n\nstatic int\nposix_acl_xattr_get(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, void *value, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nint\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}\nEXPORT_SYMBOL(set_posix_acl);\n\nstatic int\nposix_acl_xattr_set(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct posix_acl *acl = NULL;\n\tint ret;\n\n\tif (value) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t}\n\tret = set_posix_acl(inode, handler->flags, acl);\n\tposix_acl_release(acl);\n\treturn ret;\n}\n\nstatic bool\nposix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}\n\nconst struct xattr_handler posix_acl_access_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_ACCESS,\n\t.flags = ACL_TYPE_ACCESS,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);\n\nconst struct xattr_handler posix_acl_default_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_DEFAULT,\n\t.flags = ACL_TYPE_DEFAULT,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_default_xattr_handler);\n\nint simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}\n\nint simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2002,2003 by Andreas Gruenbacher <a.gruenbacher@computer.org>\n *\n * Fixes from William Schumacher incorporated on 15 March 2001.\n *    (Reported by Charles Bertsch, <CBertsch@microtest.com>).\n */\n\n/*\n *  This file contains generic functions for manipulating\n *  POSIX 1003.1e draft standard 17 ACLs.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    atomic_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}\nEXPORT_SYMBOL(get_cached_acl);\n\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\treturn rcu_dereference(*acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(get_cached_acl_rcu);\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\nEXPORT_SYMBOL(set_cached_acl);\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(forget_cached_acl);\n\nvoid forget_all_cached_acls(struct inode *inode)\n{\n\t__forget_cached_acl(&inode->i_acl);\n\t__forget_cached_acl(&inode->i_default_acl);\n}\nEXPORT_SYMBOL(forget_all_cached_acls);\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}\nEXPORT_SYMBOL(get_acl);\n\n/*\n * Init a fresh posix_acl\n */\nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\tatomic_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}\nEXPORT_SYMBOL(posix_acl_init);\n\n/*\n * Allocate a new ACL with the specified number of entries.\n */\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_alloc);\n\n/*\n * Clone an ACL.\n */\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\n\n/*\n * Check if an acl is valid. Returns 0 if it is, or -E... otherwise.\n */\nint\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(posix_acl_valid);\n\n/*\n * Returns 0 if the acl can be exactly represented in the traditional\n * file mode permission bits, or else 1. Returns -E... on error.\n */\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\nEXPORT_SYMBOL(posix_acl_equiv_mode);\n\n/*\n * Create an ACL representing the file mode permission bits of an inode.\n */\nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_from_mode);\n\n/*\n * Return 0 if current is granted want access to the inode\n * by the acl. Returns -E... otherwise.\n */\nint\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\n{\n\tconst struct posix_acl_entry *pa, *pe, *mask_obj;\n\tint found = 0;\n\n\twant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\t/* (May have been checked already) */\n\t\t\t\tif (uid_eq(inode->i_uid, current_fsuid()))\n                                        goto check_perm;\n                                break;\n                        case ACL_USER:\n\t\t\t\tif (uid_eq(pa->e_uid, current_fsuid()))\n                                        goto mask;\n\t\t\t\tbreak;\n                        case ACL_GROUP_OBJ:\n                                if (in_group_p(inode->i_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n\t\t\t\tbreak;\n                        case ACL_GROUP:\n\t\t\t\tif (in_group_p(pa->e_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n                                break;\n                        case ACL_MASK:\n                                break;\n                        case ACL_OTHER:\n\t\t\t\tif (found)\n\t\t\t\t\treturn -EACCES;\n\t\t\t\telse\n\t\t\t\t\tgoto check_perm;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\treturn -EIO;\n\nmask:\n\tfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n\t\tif (mask_obj->e_tag == ACL_MASK) {\n\t\t\tif ((pa->e_perm & mask_obj->e_perm & want) == want)\n\t\t\t\treturn 0;\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\ncheck_perm:\n\tif ((pa->e_perm & want) == want)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/*\n * Modify acl when creating a new inode. The caller must ensure the acl is\n * only referenced once.\n *\n * mode_p initially must contain the mode parameter to the open() / creat()\n * system calls. All permissions that are not granted by the acl are removed.\n * The permissions in the acl are changed to reflect the mode_p parameter.\n */\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\n\n/*\n * Modify the ACL for the chmod syscall.\n */\nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}\n\nint\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_create);\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_chmod);\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}\nEXPORT_SYMBOL(posix_acl_chmod);\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tret = -ENOMEM;\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto err_release;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto err_release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nerr_release_clone:\n\tposix_acl_release(clone);\nerr_release:\n\tposix_acl_release(p);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(posix_acl_create);\n\n/**\n * posix_acl_update_mode  -  update mode in set_acl\n *\n * Update the file mode when setting an ACL: compute the new file permission\n * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n * file mode, set *acl to NULL to indicate that no ACL should be set.\n *\n * As with chmod, clear the setgit bit if the caller is not in the owning group\n * or capable of CAP_FSETID (see inode_change_ok).\n *\n * Called from set_acl inode operations.\n */\nint posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}\nEXPORT_SYMBOL(posix_acl_update_mode);\n\n/*\n * Fix up the uids and gids in posix acl extended attributes in place.\n */\nstatic void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}\n\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}\n\n/*\n * Convert from extended attribute to in-memory representation.\n */\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL (posix_acl_from_xattr);\n\n/*\n * Convert from in-memory to extended attribute representation.\n */\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\nEXPORT_SYMBOL (posix_acl_to_xattr);\n\nstatic int\nposix_acl_xattr_get(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, void *value, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nint\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}\nEXPORT_SYMBOL(set_posix_acl);\n\nstatic int\nposix_acl_xattr_set(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct posix_acl *acl = NULL;\n\tint ret;\n\n\tif (value) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t}\n\tret = set_posix_acl(inode, handler->flags, acl);\n\tposix_acl_release(acl);\n\treturn ret;\n}\n\nstatic bool\nposix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}\n\nconst struct xattr_handler posix_acl_access_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_ACCESS,\n\t.flags = ACL_TYPE_ACCESS,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);\n\nconst struct xattr_handler posix_acl_default_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_DEFAULT,\n\t.flags = ACL_TYPE_DEFAULT,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_default_xattr_handler);\n\nint simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_update_mode(inode,\n\t\t\t\t&inode->i_mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}\n\nint simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn 0;\n}\n"], "filenames": ["fs/posix_acl.c"], "buggy_code_start_loc": [925], "buggy_code_end_loc": [930], "fixing_code_start_loc": [925], "fixing_code_end_loc": [929], "type": "NVD-CWE-noinfo", "message": "The simple_set_acl function in fs/posix_acl.c in the Linux kernel before 4.9.6 preserves the setgid bit during a setxattr call involving a tmpfs filesystem, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7097.", "other": {"cve": {"id": "CVE-2017-5551", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-06T06:59:00.717", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The simple_set_acl function in fs/posix_acl.c in the Linux kernel before 4.9.6 preserves the setgid bit during a setxattr call involving a tmpfs filesystem, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7097."}, {"lang": "es", "value": "La funci\u00f3n simple_set_acl en fs/posix_acl.c en el kernel de Linux en versiones anteriores a 4.9.6 preserva el bit setgid durante una llamada setxattr que implica un sistema de archivos tmpfs, lo que permite a usuarios locales obtener privilegios de grupo aprovechando la existencia de un programa setgid con restricciones sobre los permisos de ejecuci\u00f3n. NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2016-7097."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9.5", "matchCriteriaId": "56274F09-9AD1-471A-8663-69116F7C8615"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=497de07d89c1410d76a15bec2bb41f24a2a89f31", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3791", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/21/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95717", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038053", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1416126", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/497de07d89c1410d76a15bec2bb41f24a2a89f31", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/497de07d89c1410d76a15bec2bb41f24a2a89f31"}}