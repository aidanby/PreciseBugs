{"buggy_code": ["/* Generated by re2c 1.1.1 */\n#include \"ext_scanners.h\"\n#include <stdlib.h>\n\nbufsize_t _ext_scan_at(bufsize_t (*scanner)(const unsigned char *),\n                       unsigned char *ptr, int len, bufsize_t offset) {\n  bufsize_t res;\n\n  if (ptr == NULL || offset >= len) {\n    return 0;\n  } else {\n    unsigned char lim = ptr[len];\n\n    ptr[len] = '\\0';\n    res = scanner(ptr + offset);\n    ptr[len] = lim;\n  }\n\n  return res;\n}\n\nbufsize_t _scan_table_start(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 64, 0,  64, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  64, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 128, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0,\n    };\n    yych = *(marker = p);\n    if (yych <= '{') {\n      if (yych <= 0x1F) {\n        if (yych <= '\\t') {\n          if (yych <= 0x08)\n            goto yy3;\n          goto yy4;\n        } else {\n          if (yych <= '\\n')\n            goto yy2;\n          if (yych <= '\\f')\n            goto yy4;\n          goto yy3;\n        }\n      } else {\n        if (yych <= '-') {\n          if (yych <= ' ')\n            goto yy4;\n          if (yych <= ',')\n            goto yy3;\n          goto yy5;\n        } else {\n          if (yych == ':')\n            goto yy6;\n          goto yy3;\n        }\n      }\n    } else {\n      if (yych <= 0xEC) {\n        if (yych <= 0xC1) {\n          if (yych <= '|')\n            goto yy4;\n          if (yych <= 0x7F)\n            goto yy3;\n        } else {\n          if (yych <= 0xDF)\n            goto yy7;\n          if (yych <= 0xE0)\n            goto yy9;\n          goto yy10;\n        }\n      } else {\n        if (yych <= 0xF0) {\n          if (yych <= 0xED)\n            goto yy11;\n          if (yych <= 0xEF)\n            goto yy10;\n          goto yy12;\n        } else {\n          if (yych <= 0xF3)\n            goto yy13;\n          if (yych <= 0xF4)\n            goto yy14;\n        }\n      }\n    }\n  yy2 : { return 0; }\n  yy3:\n    ++p;\n    goto yy2;\n  yy4:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 64) {\n      goto yy15;\n    }\n    if (yych == '-')\n      goto yy17;\n    if (yych == ':')\n      goto yy19;\n    goto yy2;\n  yy5:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 128) {\n      goto yy17;\n    }\n    if (yych <= ' ') {\n      if (yych <= 0x08)\n        goto yy2;\n      if (yych <= '\\r')\n        goto yy21;\n      if (yych <= 0x1F)\n        goto yy2;\n      goto yy21;\n    } else {\n      if (yych <= ':') {\n        if (yych <= '9')\n          goto yy2;\n        goto yy20;\n      } else {\n        if (yych == '|')\n          goto yy21;\n        goto yy2;\n      }\n    }\n  yy6:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 128) {\n      goto yy17;\n    }\n    goto yy2;\n  yy7:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy8;\n    if (yych <= 0xBF)\n      goto yy3;\n  yy8:\n    p = marker;\n    goto yy2;\n  yy9:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy8;\n    if (yych <= 0xBF)\n      goto yy7;\n    goto yy8;\n  yy10:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy8;\n    if (yych <= 0xBF)\n      goto yy7;\n    goto yy8;\n  yy11:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy8;\n    if (yych <= 0x9F)\n      goto yy7;\n    goto yy8;\n  yy12:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy8;\n    if (yych <= 0xBF)\n      goto yy10;\n    goto yy8;\n  yy13:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy8;\n    if (yych <= 0xBF)\n      goto yy10;\n    goto yy8;\n  yy14:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy8;\n    if (yych <= 0x8F)\n      goto yy10;\n    goto yy8;\n  yy15:\n    yych = *++p;\n    if (yybm[0 + yych] & 64) {\n      goto yy15;\n    }\n    if (yych == '-')\n      goto yy17;\n    if (yych == ':')\n      goto yy19;\n    goto yy8;\n  yy17:\n    yych = *++p;\n    if (yybm[0 + yych] & 128) {\n      goto yy17;\n    }\n    if (yych <= 0x1F) {\n      if (yych <= '\\n') {\n        if (yych <= 0x08)\n          goto yy8;\n        if (yych <= '\\t')\n          goto yy20;\n        goto yy22;\n      } else {\n        if (yych <= '\\f')\n          goto yy20;\n        if (yych <= '\\r')\n          goto yy24;\n        goto yy8;\n      }\n    } else {\n      if (yych <= ':') {\n        if (yych <= ' ')\n          goto yy20;\n        if (yych <= '9')\n          goto yy8;\n        goto yy20;\n      } else {\n        if (yych == '|')\n          goto yy25;\n        goto yy8;\n      }\n    }\n  yy19:\n    yych = *++p;\n    if (yybm[0 + yych] & 128) {\n      goto yy17;\n    }\n    goto yy8;\n  yy20:\n    yych = *++p;\n  yy21:\n    if (yych <= '\\r') {\n      if (yych <= '\\t') {\n        if (yych <= 0x08)\n          goto yy8;\n        goto yy20;\n      } else {\n        if (yych <= '\\n')\n          goto yy22;\n        if (yych <= '\\f')\n          goto yy20;\n        goto yy24;\n      }\n    } else {\n      if (yych <= ' ') {\n        if (yych <= 0x1F)\n          goto yy8;\n        goto yy20;\n      } else {\n        if (yych == '|')\n          goto yy25;\n        goto yy8;\n      }\n    }\n  yy22:\n    ++p;\n    { return (bufsize_t)(p - start); }\n  yy24:\n    yych = *++p;\n    if (yych == '\\n')\n      goto yy22;\n    goto yy8;\n  yy25:\n    yych = *++p;\n    if (yybm[0 + yych] & 128) {\n      goto yy17;\n    }\n    if (yych <= '\\r') {\n      if (yych <= '\\t') {\n        if (yych <= 0x08)\n          goto yy8;\n        goto yy25;\n      } else {\n        if (yych <= '\\n')\n          goto yy22;\n        if (yych <= '\\f')\n          goto yy25;\n        goto yy24;\n      }\n    } else {\n      if (yych <= ' ') {\n        if (yych <= 0x1F)\n          goto yy8;\n        goto yy25;\n      } else {\n        if (yych == ':')\n          goto yy19;\n        goto yy8;\n      }\n    }\n  }\n}\n\nbufsize_t _scan_table_cell(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 0,  64, 64, 0,  64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 128, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 0,  64,\n        64, 64, 0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,\n    };\n    yych = *(marker = p);\n    if (yybm[0 + yych] & 64) {\n      goto yy30;\n    }\n    if (yych <= 0xE0) {\n      if (yych <= '\\\\') {\n        if (yych <= '\\n')\n          goto yy29;\n        if (yych <= '\\r')\n          goto yy32;\n        goto yy34;\n      } else {\n        if (yych <= '|')\n          goto yy32;\n        if (yych <= 0xC1)\n          goto yy29;\n        if (yych <= 0xDF)\n          goto yy36;\n        goto yy38;\n      }\n    } else {\n      if (yych <= 0xEF) {\n        if (yych == 0xED)\n          goto yy40;\n        goto yy39;\n      } else {\n        if (yych <= 0xF0)\n          goto yy41;\n        if (yych <= 0xF3)\n          goto yy42;\n        if (yych <= 0xF4)\n          goto yy43;\n      }\n    }\n  yy29 : { return (bufsize_t)(p - start); }\n  yy30:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 64) {\n      goto yy30;\n    }\n    if (yych <= 0xEC) {\n      if (yych <= 0xC1) {\n        if (yych <= '\\r')\n          goto yy29;\n        if (yych <= '\\\\')\n          goto yy34;\n        goto yy29;\n      } else {\n        if (yych <= 0xDF)\n          goto yy36;\n        if (yych <= 0xE0)\n          goto yy38;\n        goto yy39;\n      }\n    } else {\n      if (yych <= 0xF0) {\n        if (yych <= 0xED)\n          goto yy40;\n        if (yych <= 0xEF)\n          goto yy39;\n        goto yy41;\n      } else {\n        if (yych <= 0xF3)\n          goto yy42;\n        if (yych <= 0xF4)\n          goto yy43;\n        goto yy29;\n      }\n    }\n  yy32:\n    ++p;\n    { return 0; }\n  yy34:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 128) {\n      goto yy34;\n    }\n    if (yych <= 0xDF) {\n      if (yych <= '\\f') {\n        if (yych == '\\n')\n          goto yy29;\n        goto yy30;\n      } else {\n        if (yych <= '\\r')\n          goto yy29;\n        if (yych <= 0x7F)\n          goto yy30;\n        if (yych <= 0xC1)\n          goto yy29;\n      }\n    } else {\n      if (yych <= 0xEF) {\n        if (yych <= 0xE0)\n          goto yy38;\n        if (yych == 0xED)\n          goto yy40;\n        goto yy39;\n      } else {\n        if (yych <= 0xF0)\n          goto yy41;\n        if (yych <= 0xF3)\n          goto yy42;\n        if (yych <= 0xF4)\n          goto yy43;\n        goto yy29;\n      }\n    }\n  yy36:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy30;\n  yy37:\n    p = marker;\n    goto yy29;\n  yy38:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy36;\n    goto yy37;\n  yy39:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy36;\n    goto yy37;\n  yy40:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0x9F)\n      goto yy36;\n    goto yy37;\n  yy41:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy39;\n    goto yy37;\n  yy42:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy39;\n    goto yy37;\n  yy43:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0x8F)\n      goto yy39;\n    goto yy37;\n  }\n}\n\nbufsize_t _scan_table_cell_end(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    unsigned int yyaccept = 0;\n    static const unsigned char yybm[] = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 128, 128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0,\n    };\n    yych = *(marker = p);\n    if (yych <= 0xDF) {\n      if (yych <= '{') {\n        if (yych != '\\n')\n          goto yy47;\n      } else {\n        if (yych <= '|')\n          goto yy48;\n        if (yych <= 0x7F)\n          goto yy47;\n        if (yych >= 0xC2)\n          goto yy51;\n      }\n    } else {\n      if (yych <= 0xEF) {\n        if (yych <= 0xE0)\n          goto yy53;\n        if (yych == 0xED)\n          goto yy55;\n        goto yy54;\n      } else {\n        if (yych <= 0xF0)\n          goto yy56;\n        if (yych <= 0xF3)\n          goto yy57;\n        if (yych <= 0xF4)\n          goto yy58;\n      }\n    }\n  yy46 : { return 0; }\n  yy47:\n    ++p;\n    goto yy46;\n  yy48:\n    yyaccept = 1;\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 128) {\n      goto yy48;\n    }\n    if (yych <= 0x08)\n      goto yy50;\n    if (yych <= '\\n')\n      goto yy59;\n    if (yych <= '\\r')\n      goto yy60;\n  yy50 : { return (bufsize_t)(p - start); }\n  yy51:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy52;\n    if (yych <= 0xBF)\n      goto yy47;\n  yy52:\n    p = marker;\n    if (yyaccept == 0) {\n      goto yy46;\n    } else {\n      goto yy50;\n    }\n  yy53:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy52;\n    if (yych <= 0xBF)\n      goto yy51;\n    goto yy52;\n  yy54:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy52;\n    if (yych <= 0xBF)\n      goto yy51;\n    goto yy52;\n  yy55:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy52;\n    if (yych <= 0x9F)\n      goto yy51;\n    goto yy52;\n  yy56:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy52;\n    if (yych <= 0xBF)\n      goto yy54;\n    goto yy52;\n  yy57:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy52;\n    if (yych <= 0xBF)\n      goto yy54;\n    goto yy52;\n  yy58:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy52;\n    if (yych <= 0x8F)\n      goto yy54;\n    goto yy52;\n  yy59:\n    ++p;\n    goto yy50;\n  yy60:\n    yych = *++p;\n    if (yych == '\\n')\n      goto yy59;\n    goto yy52;\n  }\n}\n\nbufsize_t _scan_table_row_end(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 128, 128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0,\n    };\n    yych = *(marker = p);\n    if (yych <= 0xC1) {\n      if (yych <= '\\f') {\n        if (yych <= 0x08)\n          goto yy64;\n        if (yych == '\\n')\n          goto yy66;\n        goto yy65;\n      } else {\n        if (yych <= 0x1F) {\n          if (yych <= '\\r')\n            goto yy68;\n          goto yy64;\n        } else {\n          if (yych <= ' ')\n            goto yy65;\n          if (yych <= 0x7F)\n            goto yy64;\n        }\n      }\n    } else {\n      if (yych <= 0xED) {\n        if (yych <= 0xDF)\n          goto yy69;\n        if (yych <= 0xE0)\n          goto yy71;\n        if (yych <= 0xEC)\n          goto yy72;\n        goto yy73;\n      } else {\n        if (yych <= 0xF0) {\n          if (yych <= 0xEF)\n            goto yy72;\n          goto yy74;\n        } else {\n          if (yych <= 0xF3)\n            goto yy75;\n          if (yych <= 0xF4)\n            goto yy76;\n        }\n      }\n    }\n  yy63 : { return 0; }\n  yy64:\n    ++p;\n    goto yy63;\n  yy65:\n    yych = *(marker = ++p);\n    if (yych <= 0x08)\n      goto yy63;\n    if (yych <= '\\r')\n      goto yy78;\n    if (yych == ' ')\n      goto yy78;\n    goto yy63;\n  yy66:\n    ++p;\n    { return (bufsize_t)(p - start); }\n  yy68:\n    yych = *++p;\n    if (yych == '\\n')\n      goto yy66;\n    goto yy63;\n  yy69:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy70;\n    if (yych <= 0xBF)\n      goto yy64;\n  yy70:\n    p = marker;\n    goto yy63;\n  yy71:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy70;\n    if (yych <= 0xBF)\n      goto yy69;\n    goto yy70;\n  yy72:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy70;\n    if (yych <= 0xBF)\n      goto yy69;\n    goto yy70;\n  yy73:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy70;\n    if (yych <= 0x9F)\n      goto yy69;\n    goto yy70;\n  yy74:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy70;\n    if (yych <= 0xBF)\n      goto yy72;\n    goto yy70;\n  yy75:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy70;\n    if (yych <= 0xBF)\n      goto yy72;\n    goto yy70;\n  yy76:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy70;\n    if (yych <= 0x8F)\n      goto yy72;\n    goto yy70;\n  yy77:\n    yych = *++p;\n  yy78:\n    if (yybm[0 + yych] & 128) {\n      goto yy77;\n    }\n    if (yych <= 0x08)\n      goto yy70;\n    if (yych <= '\\n')\n      goto yy66;\n    if (yych >= 0x0E)\n      goto yy70;\n    yych = *++p;\n    if (yych == '\\n')\n      goto yy66;\n    goto yy70;\n  }\n}\nbufsize_t _scan_tasklist(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   64,  0, 64, 64, 0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        64,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n    };\n    yych = *(marker = p);\n    if (yych <= '/') {\n      if (yych <= 0x1F) {\n        if (yych <= '\\t') {\n          if (yych <= 0x08)\n            goto yy83;\n          goto yy84;\n        } else {\n          if (yych <= '\\n')\n            goto yy82;\n          if (yych <= '\\f')\n            goto yy84;\n          goto yy83;\n        }\n      } else {\n        if (yych <= '+') {\n          if (yych <= ' ')\n            goto yy84;\n          if (yych <= ')')\n            goto yy83;\n          goto yy85;\n        } else {\n          if (yych == '-')\n            goto yy85;\n          goto yy83;\n        }\n      }\n    } else {\n      if (yych <= 0xEC) {\n        if (yych <= 0xC1) {\n          if (yych <= '9')\n            goto yy86;\n          if (yych <= 0x7F)\n            goto yy83;\n        } else {\n          if (yych <= 0xDF)\n            goto yy87;\n          if (yych <= 0xE0)\n            goto yy89;\n          goto yy90;\n        }\n      } else {\n        if (yych <= 0xF0) {\n          if (yych <= 0xED)\n            goto yy91;\n          if (yych <= 0xEF)\n            goto yy90;\n          goto yy92;\n        } else {\n          if (yych <= 0xF3)\n            goto yy93;\n          if (yych <= 0xF4)\n            goto yy94;\n        }\n      }\n    }\n  yy82 : { return 0; }\n  yy83:\n    ++p;\n    goto yy82;\n  yy84:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 64) {\n      goto yy95;\n    }\n    if (yych <= ',') {\n      if (yych <= ')')\n        goto yy82;\n      if (yych <= '+')\n        goto yy97;\n      goto yy82;\n    } else {\n      if (yych <= '-')\n        goto yy97;\n      if (yych <= '/')\n        goto yy82;\n      if (yych <= '9')\n        goto yy98;\n      goto yy82;\n    }\n  yy85:\n    yych = *(marker = ++p);\n    if (yych <= '\\n') {\n      if (yych == '\\t')\n        goto yy99;\n      goto yy82;\n    } else {\n      if (yych <= '\\f')\n        goto yy99;\n      if (yych == ' ')\n        goto yy99;\n      goto yy82;\n    }\n  yy86:\n    yych = *(marker = ++p);\n    if (yych <= 0x1F) {\n      if (yych <= '\\t') {\n        if (yych <= 0x08)\n          goto yy102;\n        goto yy97;\n      } else {\n        if (yych <= '\\n')\n          goto yy82;\n        if (yych <= '\\f')\n          goto yy97;\n        goto yy102;\n      }\n    } else {\n      if (yych <= 0x7F) {\n        if (yych <= ' ')\n          goto yy97;\n        goto yy102;\n      } else {\n        if (yych <= 0xC1)\n          goto yy82;\n        if (yych <= 0xF4)\n          goto yy102;\n        goto yy82;\n      }\n    }\n  yy87:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy83;\n  yy88:\n    p = marker;\n    goto yy82;\n  yy89:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy87;\n    goto yy88;\n  yy90:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy87;\n    goto yy88;\n  yy91:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0x9F)\n      goto yy87;\n    goto yy88;\n  yy92:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy90;\n    goto yy88;\n  yy93:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy90;\n    goto yy88;\n  yy94:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0x8F)\n      goto yy90;\n    goto yy88;\n  yy95:\n    yych = *++p;\n    if (yybm[0 + yych] & 64) {\n      goto yy95;\n    }\n    if (yych <= ',') {\n      if (yych <= ')')\n        goto yy88;\n      if (yych >= ',')\n        goto yy88;\n    } else {\n      if (yych <= '-')\n        goto yy97;\n      if (yych <= '/')\n        goto yy88;\n      if (yych <= '9')\n        goto yy98;\n      goto yy88;\n    }\n  yy97:\n    yych = *++p;\n    if (yych == '[')\n      goto yy88;\n    goto yy100;\n  yy98:\n    yych = *++p;\n    if (yych <= '\\n') {\n      if (yych == '\\t')\n        goto yy97;\n      goto yy102;\n    } else {\n      if (yych <= '\\f')\n        goto yy97;\n      if (yych == ' ')\n        goto yy97;\n      goto yy102;\n    }\n  yy99:\n    yych = *++p;\n  yy100:\n    if (yych <= '\\f') {\n      if (yych == '\\t')\n        goto yy99;\n      if (yych <= '\\n')\n        goto yy88;\n      goto yy99;\n    } else {\n      if (yych <= ' ') {\n        if (yych <= 0x1F)\n          goto yy88;\n        goto yy99;\n      } else {\n        if (yych == '[')\n          goto yy110;\n        goto yy88;\n      }\n    }\n  yy101:\n    yych = *++p;\n  yy102:\n    if (yybm[0 + yych] & 128) {\n      goto yy101;\n    }\n    if (yych <= 0xC1) {\n      if (yych <= '\\f') {\n        if (yych <= 0x08)\n          goto yy97;\n        if (yych == '\\n')\n          goto yy88;\n        goto yy99;\n      } else {\n        if (yych == ' ')\n          goto yy99;\n        if (yych <= 0x7F)\n          goto yy97;\n        goto yy88;\n      }\n    } else {\n      if (yych <= 0xED) {\n        if (yych <= 0xDF)\n          goto yy103;\n        if (yych <= 0xE0)\n          goto yy104;\n        if (yych <= 0xEC)\n          goto yy105;\n        goto yy106;\n      } else {\n        if (yych <= 0xF0) {\n          if (yych <= 0xEF)\n            goto yy105;\n          goto yy107;\n        } else {\n          if (yych <= 0xF3)\n            goto yy108;\n          if (yych <= 0xF4)\n            goto yy109;\n          goto yy88;\n        }\n      }\n    }\n  yy103:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy97;\n    goto yy88;\n  yy104:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy103;\n    goto yy88;\n  yy105:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy103;\n    goto yy88;\n  yy106:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0x9F)\n      goto yy103;\n    goto yy88;\n  yy107:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy105;\n    goto yy88;\n  yy108:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0xBF)\n      goto yy105;\n    goto yy88;\n  yy109:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy88;\n    if (yych <= 0x8F)\n      goto yy105;\n    goto yy88;\n  yy110:\n    yych = *++p;\n    if (yych <= 'W') {\n      if (yych != ' ')\n        goto yy88;\n    } else {\n      if (yych <= 'X')\n        goto yy111;\n      if (yych != 'x')\n        goto yy88;\n    }\n  yy111:\n    yych = *++p;\n    if (yych != ']')\n      goto yy88;\n    yych = *++p;\n    if (yych <= '\\n') {\n      if (yych != '\\t')\n        goto yy88;\n    } else {\n      if (yych <= '\\f')\n        goto yy113;\n      if (yych != ' ')\n        goto yy88;\n    }\n  yy113:\n    yych = *++p;\n    if (yych <= '\\n') {\n      if (yych == '\\t')\n        goto yy113;\n    } else {\n      if (yych <= '\\f')\n        goto yy113;\n      if (yych == ' ')\n        goto yy113;\n    }\n    { return (bufsize_t)(p - start); }\n  }\n}\n", "#include <stdlib.h>\n#include \"ext_scanners.h\"\n\nbufsize_t _ext_scan_at(bufsize_t (*scanner)(const unsigned char *), unsigned char *ptr, int len, bufsize_t offset)\n{\n\tbufsize_t res;\n\n        if (ptr == NULL || offset >= len) {\n          return 0;\n        } else {\n\t  unsigned char lim = ptr[len];\n\n\t  ptr[len] = '\\0';\n\t  res = scanner(ptr + offset);\n\t  ptr[len] = lim;\n        }\n\n\treturn res;\n}\n\n/*!re2c\n  re2c:define:YYCTYPE  = \"unsigned char\";\n  re2c:define:YYCURSOR = p;\n  re2c:define:YYMARKER = marker;\n  re2c:define:YYCTXMARKER = marker;\n  re2c:yyfill:enable = 0;\n\n  spacechar = [ \\t\\v\\f];\n  newline = [\\r]?[\\n];\n  escaped_char = [\\\\][|!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{}~-];\n\n  table_marker = (spacechar*[:]?[-]+[:]?spacechar*);\n  table_cell = (escaped_char|[^|\\r\\n])*;\n\n  tasklist = spacechar*(\"-\"|\"+\"|\"*\"|[0-9]+.)spacechar+(\"[ ]\"|\"[x]\")spacechar+;\n*/\n\nbufsize_t _scan_table_start(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n/*!re2c\n  [|]? table_marker ([|] table_marker)* [|]? spacechar* newline { return (bufsize_t)(p - start); }\n  .? { return 0; }\n*/\n}\n\nbufsize_t _scan_table_cell(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n/*!re2c\n  table_cell { return (bufsize_t)(p - start); }\n  .? { return 0; }\n*/\n}\n\nbufsize_t _scan_table_cell_end(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n/*!re2c\n  [|] spacechar* newline? { return (bufsize_t)(p - start); }\n  .? { return 0; }\n*/\n}\n\nbufsize_t _scan_table_row_end(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n/*!re2c\n  spacechar* newline { return (bufsize_t)(p - start); }\n  .? { return 0; }\n*/\n}\nbufsize_t _scan_tasklist(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n/*!re2c\n  tasklist { return (bufsize_t)(p - start); }\n  .? { return 0; }\n*/\n}\n", "#include <cmark-gfm-extension_api.h>\n#include <html.h>\n#include <inlines.h>\n#include <parser.h>\n#include <references.h>\n#include <string.h>\n#include <render.h>\n\n#include \"ext_scanners.h\"\n#include \"strikethrough.h\"\n#include \"table.h\"\n#include \"cmark-gfm-core-extensions.h\"\n\ncmark_node_type CMARK_NODE_TABLE, CMARK_NODE_TABLE_ROW,\n    CMARK_NODE_TABLE_CELL;\n\ntypedef struct {\n  uint16_t n_columns;\n  int paragraph_offset;\n  cmark_llist *cells;\n} table_row;\n\ntypedef struct {\n  uint16_t n_columns;\n  uint8_t *alignments;\n} node_table;\n\ntypedef struct {\n  bool is_header;\n} node_table_row;\n\ntypedef struct {\n  cmark_strbuf *buf;\n  int start_offset, end_offset, internal_offset;\n} node_cell;\n\nstatic void free_table_cell(cmark_mem *mem, void *data) {\n  node_cell *cell = (node_cell *)data;\n  cmark_strbuf_free((cmark_strbuf *)cell->buf);\n  mem->free(cell->buf);\n  mem->free(cell);\n}\n\nstatic void free_table_row(cmark_mem *mem, table_row *row) {\n  if (!row)\n    return;\n\n  cmark_llist_free_full(mem, row->cells, (cmark_free_func)free_table_cell);\n\n  mem->free(row);\n}\n\nstatic void free_node_table(cmark_mem *mem, void *ptr) {\n  node_table *t = (node_table *)ptr;\n  mem->free(t->alignments);\n  mem->free(t);\n}\n\nstatic void free_node_table_row(cmark_mem *mem, void *ptr) {\n  mem->free(ptr);\n}\n\nstatic int get_n_table_columns(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return -1;\n\n  return (int)((node_table *)node->as.opaque)->n_columns;\n}\n\nstatic int set_n_table_columns(cmark_node *node, uint16_t n_columns) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->n_columns = n_columns;\n  return 1;\n}\n\nstatic uint8_t *get_table_alignments(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nstatic int set_table_alignments(cmark_node *node, uint8_t *alignments) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->alignments = alignments;\n  return 1;\n}\n\nstatic cmark_strbuf *unescape_pipes(cmark_mem *mem, unsigned char *string, bufsize_t len)\n{\n  cmark_strbuf *res = (cmark_strbuf *)mem->calloc(1, sizeof(cmark_strbuf));\n  bufsize_t r, w;\n\n  cmark_strbuf_init(mem, res, len + 1);\n  cmark_strbuf_put(res, string, len);\n  cmark_strbuf_putc(res, '\\0');\n\n  for (r = 0, w = 0; r < len; ++r) {\n    if (res->ptr[r] == '\\\\' && res->ptr[r + 1] == '|')\n      r++;\n\n    res->ptr[w++] = res->ptr[r];\n  }\n\n  cmark_strbuf_truncate(res, w);\n\n  return res;\n}\n\nstatic table_row *row_from_string(cmark_syntax_extension *self,\n                                  cmark_parser *parser, unsigned char *string,\n                                  int len) {\n  table_row *row = NULL;\n  bufsize_t cell_matched = 1, pipe_matched = 1, offset;\n  int cell_end_offset;\n\n  row = (table_row *)parser->mem->calloc(1, sizeof(table_row));\n  row->n_columns = 0;\n  row->cells = NULL;\n\n  offset = scan_table_cell_end(string, len, 0);\n\n  // Parse the cells of the row. Stop if we reach the end of the input, or if we\n  // cannot detect any more cells.\n  while (offset < len && (cell_matched || pipe_matched)) {\n    cell_matched = scan_table_cell(string, len, offset);\n    pipe_matched = scan_table_cell_end(string, len, offset + cell_matched);\n\n    if (cell_matched || pipe_matched) {\n      cell_end_offset = offset + cell_matched - 1;\n\n      if (string[cell_end_offset] == '\\n' || string[cell_end_offset] == '\\r') {\n        row->paragraph_offset = cell_end_offset;\n\n        cmark_llist_free_full(parser->mem, row->cells, (cmark_free_func)free_table_cell);\n        row->cells = NULL;\n        row->n_columns = 0;\n      } else {\n        cmark_strbuf *cell_buf = unescape_pipes(parser->mem, string + offset,\n            cell_matched);\n        cmark_strbuf_trim(cell_buf);\n\n        node_cell *cell = (node_cell *)parser->mem->calloc(1, sizeof(*cell));\n        cell->buf = cell_buf;\n        cell->start_offset = offset;\n        cell->end_offset = cell_end_offset;\n\n        while (cell->start_offset > 0 && string[cell->start_offset - 1] != '|') {\n          --cell->start_offset;\n          ++cell->internal_offset;\n        }\n\n        row->n_columns += 1;\n        row->cells = cmark_llist_append(parser->mem, row->cells, cell);\n      }\n    }\n\n    offset += cell_matched + pipe_matched;\n\n    if (!pipe_matched) {\n      pipe_matched = scan_table_row_end(string, len, offset);\n      offset += pipe_matched;\n    }\n  }\n\n  if (offset != len || !row->n_columns) {\n    free_table_row(parser->mem, row);\n    row = NULL;\n  }\n\n  return row;\n}\n\nstatic void try_inserting_table_header_paragraph(cmark_parser *parser,\n                                                 cmark_node *parent_container,\n                                                 unsigned char *parent_string,\n                                                 int paragraph_offset) {\n  cmark_node *paragraph;\n  cmark_strbuf *paragraph_content;\n\n  paragraph = cmark_node_new_with_mem(CMARK_NODE_PARAGRAPH, parser->mem);\n\n  paragraph_content = unescape_pipes(parser->mem, parent_string, paragraph_offset);\n  cmark_strbuf_trim(paragraph_content);\n  cmark_node_set_string_content(paragraph, (char *) paragraph_content->ptr);\n  cmark_strbuf_free(paragraph_content);\n  parser->mem->free(paragraph_content);\n\n  if (!cmark_node_insert_before(parent_container, paragraph)) {\n    parser->mem->free(paragraph);\n  }\n}\n\nstatic cmark_node *try_opening_table_header(cmark_syntax_extension *self,\n                                            cmark_parser *parser,\n                                            cmark_node *parent_container,\n                                            unsigned char *input, int len) {\n  bufsize_t matched =\n      scan_table_start(input, len, cmark_parser_get_first_nonspace(parser));\n  cmark_node *table_header;\n  table_row *header_row = NULL;\n  table_row *marker_row = NULL;\n  node_table_row *ntr;\n  const char *parent_string;\n  uint16_t i;\n\n  if (!matched)\n    return parent_container;\n\n  parent_string = cmark_node_get_string_content(parent_container);\n\n  cmark_arena_push();\n\n  header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                               (int)strlen(parent_string));\n\n  if (!header_row) {\n    free_table_row(parser->mem, header_row);\n    cmark_arena_pop();\n    return parent_container;\n  }\n\n  marker_row = row_from_string(self, parser,\n                               input + cmark_parser_get_first_nonspace(parser),\n                               len - cmark_parser_get_first_nonspace(parser));\n\n  assert(marker_row);\n\n  if (header_row->n_columns != marker_row->n_columns) {\n    free_table_row(parser->mem, header_row);\n    free_table_row(parser->mem, marker_row);\n    cmark_arena_pop();\n    return parent_container;\n  }\n\n  if (cmark_arena_pop()) {\n    header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                                 (int)strlen(parent_string));\n    marker_row = row_from_string(self, parser,\n                                 input + cmark_parser_get_first_nonspace(parser),\n                                 len - cmark_parser_get_first_nonspace(parser));\n  }\n\n  if (!cmark_node_set_type(parent_container, CMARK_NODE_TABLE)) {\n    free_table_row(parser->mem, header_row);\n    free_table_row(parser->mem, marker_row);\n    return parent_container;\n  }\n\n  if (header_row->paragraph_offset) {\n    try_inserting_table_header_paragraph(parser, parent_container, (unsigned char *)parent_string,\n                                         header_row->paragraph_offset);\n  }\n\n  cmark_node_set_syntax_extension(parent_container, self);\n\n  parent_container->as.opaque = parser->mem->calloc(1, sizeof(node_table));\n\n  set_n_table_columns(parent_container, header_row->n_columns);\n\n  uint8_t *alignments =\n      (uint8_t *)parser->mem->calloc(header_row->n_columns, sizeof(uint8_t));\n  cmark_llist *it = marker_row->cells;\n  for (i = 0; it; it = it->next, ++i) {\n    node_cell *node = (node_cell *)it->data;\n    bool left = node->buf->ptr[0] == ':', right = node->buf->ptr[node->buf->size - 1] == ':';\n\n    if (left && right)\n      alignments[i] = 'c';\n    else if (left)\n      alignments[i] = 'l';\n    else if (right)\n      alignments[i] = 'r';\n  }\n  set_table_alignments(parent_container, alignments);\n\n  table_header =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_header, self);\n  table_header->end_column = parent_container->start_column + (int)strlen(parent_string) - 2;\n  table_header->start_line = table_header->end_line = parent_container->start_line;\n\n  table_header->as.opaque = ntr = (node_table_row *)parser->mem->calloc(1, sizeof(node_table_row));\n  ntr->is_header = true;\n\n  {\n    cmark_llist *tmp;\n\n    for (tmp = header_row->cells; tmp; tmp = tmp->next) {\n      node_cell *cell = (node_cell *) tmp->data;\n      cmark_node *header_cell = cmark_parser_add_child(parser, table_header,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      header_cell->start_line = header_cell->end_line = parent_container->start_line;\n      header_cell->internal_offset = cell->internal_offset;\n      header_cell->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(header_cell, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(header_cell, self);\n    }\n  }\n\n  cmark_parser_advance_offset(\n      parser, (char *)input,\n      (int)strlen((char *)input) - 1 - cmark_parser_get_offset(parser), false);\n\n  free_table_row(parser->mem, header_row);\n  free_table_row(parser->mem, marker_row);\n  return parent_container;\n}\n\nstatic cmark_node *try_opening_table_row(cmark_syntax_extension *self,\n                                         cmark_parser *parser,\n                                         cmark_node *parent_container,\n                                         unsigned char *input, int len) {\n  cmark_node *table_row_block;\n  table_row *row;\n\n  if (cmark_parser_is_blank(parser))\n    return NULL;\n\n  table_row_block =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_row_block, self);\n  table_row_block->end_column = parent_container->end_column;\n  table_row_block->as.opaque = parser->mem->calloc(1, sizeof(node_table_row));\n\n  row = row_from_string(self, parser, input + cmark_parser_get_first_nonspace(parser),\n      len - cmark_parser_get_first_nonspace(parser));\n\n  {\n    cmark_llist *tmp;\n    int i, table_columns = get_n_table_columns(parent_container);\n\n    for (tmp = row->cells, i = 0; tmp && i < table_columns; tmp = tmp->next, ++i) {\n      node_cell *cell = (node_cell *) tmp->data;\n      cmark_node *node = cmark_parser_add_child(parser, table_row_block,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      node->internal_offset = cell->internal_offset;\n      node->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(node, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(node, self);\n    }\n\n    for (; i < table_columns; ++i) {\n      cmark_node *node = cmark_parser_add_child(\n          parser, table_row_block, CMARK_NODE_TABLE_CELL, 0);\n      cmark_node_set_syntax_extension(node, self);\n    }\n  }\n\n  free_table_row(parser->mem, row);\n\n  cmark_parser_advance_offset(parser, (char *)input,\n                              len - 1 - cmark_parser_get_offset(parser), false);\n\n  return table_row_block;\n}\n\nstatic cmark_node *try_opening_table_block(cmark_syntax_extension *self,\n                                           int indented, cmark_parser *parser,\n                                           cmark_node *parent_container,\n                                           unsigned char *input, int len) {\n  cmark_node_type parent_type = cmark_node_get_type(parent_container);\n\n  if (!indented && parent_type == CMARK_NODE_PARAGRAPH) {\n    return try_opening_table_header(self, parser, parent_container, input, len);\n  } else if (!indented && parent_type == CMARK_NODE_TABLE) {\n    return try_opening_table_row(self, parser, parent_container, input, len);\n  }\n\n  return NULL;\n}\n\nstatic int matches(cmark_syntax_extension *self, cmark_parser *parser,\n                   unsigned char *input, int len,\n                   cmark_node *parent_container) {\n  int res = 0;\n\n  if (cmark_node_get_type(parent_container) == CMARK_NODE_TABLE) {\n    cmark_arena_push();\n    table_row *new_row = row_from_string(\n        self, parser, input + cmark_parser_get_first_nonspace(parser),\n        len - cmark_parser_get_first_nonspace(parser));\n    if (new_row && new_row->n_columns)\n      res = 1;\n    free_table_row(parser->mem, new_row);\n    cmark_arena_pop();\n  }\n\n  return res;\n}\n\nstatic const char *get_type_string(cmark_syntax_extension *self,\n                                   cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return \"table\";\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (((node_table_row *)node->as.opaque)->is_header)\n      return \"table_header\";\n    else\n      return \"table_row\";\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return \"table_cell\";\n  }\n\n  return \"<unknown>\";\n}\n\nstatic int can_contain(cmark_syntax_extension *extension, cmark_node *node,\n                       cmark_node_type child_type) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return child_type == CMARK_NODE_TABLE_ROW;\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    return child_type == CMARK_NODE_TABLE_CELL;\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return child_type == CMARK_NODE_TEXT || child_type == CMARK_NODE_CODE ||\n           child_type == CMARK_NODE_EMPH || child_type == CMARK_NODE_STRONG ||\n           child_type == CMARK_NODE_LINK || child_type == CMARK_NODE_IMAGE ||\n           child_type == CMARK_NODE_STRIKETHROUGH ||\n           child_type == CMARK_NODE_HTML_INLINE ||\n           child_type == CMARK_NODE_FOOTNOTE_REFERENCE;\n  }\n  return false;\n}\n\nstatic int contains_inlines(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  return node->type == CMARK_NODE_TABLE_CELL;\n}\n\nstatic void commonmark_render(cmark_syntax_extension *extension,\n                              cmark_renderer *renderer, cmark_node *node,\n                              cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    renderer->blankline(renderer);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"|\", false, LITERAL);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (entering) {\n      renderer->out(renderer, node, \" \", false, LITERAL);\n    } else {\n      renderer->out(renderer, node, \" |\", false, LITERAL);\n      if (((node_table_row *)node->parent->as.opaque)->is_header &&\n          !node->next) {\n        int i;\n        uint8_t *alignments = get_table_alignments(node->parent->parent);\n        uint16_t n_cols =\n            ((node_table *)node->parent->parent->as.opaque)->n_columns;\n        renderer->cr(renderer);\n        renderer->out(renderer, node, \"|\", false, LITERAL);\n        for (i = 0; i < n_cols; i++) {\n          switch (alignments[i]) {\n          case 0:   renderer->out(renderer, node, \" --- |\", false, LITERAL); break;\n          case 'l': renderer->out(renderer, node, \" :-- |\", false, LITERAL); break;\n          case 'c': renderer->out(renderer, node, \" :-: |\", false, LITERAL); break;\n          case 'r': renderer->out(renderer, node, \" --: |\", false, LITERAL); break;\n          }\n        }\n        renderer->cr(renderer);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void latex_render(cmark_syntax_extension *extension,\n                         cmark_renderer *renderer, cmark_node *node,\n                         cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{table}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{tabular}{\", false, LITERAL);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n      for (i = 0; i < n_cols; i++) {\n        switch(alignments[i]) {\n        case 0:\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n      renderer->out(renderer, node, \"}\", false, LITERAL);\n      renderer->cr(renderer);\n    } else {\n      renderer->out(renderer, node, \"\\\\end{tabular}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\end{table}\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering) {\n      if (node->next) {\n        renderer->out(renderer, node, \" & \", false, LITERAL);\n      } else {\n        renderer->out(renderer, node, \" \\\\\\\\\", false, LITERAL);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic const char *xml_attr(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (cmark_gfm_extensions_get_table_row_is_header(node->parent)) {\n      uint8_t *alignments = get_table_alignments(node->parent->parent);\n      int i = 0;\n      cmark_node *n;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n      switch (alignments[i]) {\n      case 'l': return \" align=\\\"left\\\"\";\n      case 'c': return \" align=\\\"center\\\"\";\n      case 'r': return \" align=\\\"right\\\"\";\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic void man_render(cmark_syntax_extension *extension,\n                       cmark_renderer *renderer, cmark_node *node,\n                       cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \".TS\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"tab(@);\", false, LITERAL);\n      renderer->cr(renderer);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n\n      for (i = 0; i < n_cols; i++) {\n        switch (alignments[i]) {\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 0:\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n\n      if (n_cols) {\n        renderer->out(renderer, node, \".\", false, LITERAL);\n        renderer->cr(renderer);\n      }\n    } else {\n      renderer->out(renderer, node, \".TE\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering && node->next) {\n      renderer->out(renderer, node, \"@\", false, LITERAL);\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void html_table_add_align(cmark_strbuf* html, const char* align, int options) {\n  if (options & CMARK_OPT_TABLE_PREFER_STYLE_ATTRIBUTES) {\n    cmark_strbuf_puts(html, \" style=\\\"text-align: \");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  } else {\n    cmark_strbuf_puts(html, \" align=\\\"\");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  }\n}\n\nstruct html_table_state {\n  unsigned need_closing_table_body : 1;\n  unsigned in_table_header : 1;\n};\n\nstatic void html_render(cmark_syntax_extension *extension,\n                        cmark_html_renderer *renderer, cmark_node *node,\n                        cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n  cmark_strbuf *html = renderer->html;\n  cmark_node *n;\n\n  // XXX: we just monopolise renderer->opaque.\n  struct html_table_state *table_state =\n      (struct html_table_state *)&renderer->opaque;\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"<table\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n      table_state->need_closing_table_body = false;\n    } else {\n      if (table_state->need_closing_table_body) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</tbody>\");\n        cmark_html_render_cr(html);\n      }\n      table_state->need_closing_table_body = false;\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</table>\");\n      cmark_html_render_cr(html);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        table_state->in_table_header = 1;\n        cmark_strbuf_puts(html, \"<thead>\");\n        cmark_html_render_cr(html);\n      } else if (!table_state->need_closing_table_body) {\n        cmark_strbuf_puts(html, \"<tbody>\");\n        cmark_html_render_cr(html);\n        table_state->need_closing_table_body = 1;\n      }\n      cmark_strbuf_puts(html, \"<tr\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</tr>\");\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</thead>\");\n        table_state->in_table_header = false;\n      }\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    uint8_t *alignments = get_table_alignments(node->parent->parent);\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"<th\");\n      } else {\n        cmark_strbuf_puts(html, \"<td\");\n      }\n\n      int i = 0;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n\n      switch (alignments[i]) {\n      case 'l': html_table_add_align(html, \"left\", options); break;\n      case 'c': html_table_add_align(html, \"center\", options); break;\n      case 'r': html_table_add_align(html, \"right\", options); break;\n      }\n\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"</th>\");\n      } else {\n        cmark_strbuf_puts(html, \"</td>\");\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void opaque_alloc(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table));\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table_row));\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    node->as.opaque = mem->calloc(1, sizeof(node_cell));\n  }\n}\n\nstatic void opaque_free(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    free_node_table(mem, node->as.opaque);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    free_node_table_row(mem, node->as.opaque);\n  }\n}\n\nstatic int escape(cmark_syntax_extension *self, cmark_node *node, int c) {\n  return\n    node->type != CMARK_NODE_TABLE &&\n    node->type != CMARK_NODE_TABLE_ROW &&\n    node->type != CMARK_NODE_TABLE_CELL &&\n    c == '|';\n}\n\ncmark_syntax_extension *create_table_extension(void) {\n  cmark_syntax_extension *self = cmark_syntax_extension_new(\"table\");\n\n  cmark_syntax_extension_set_match_block_func(self, matches);\n  cmark_syntax_extension_set_open_block_func(self, try_opening_table_block);\n  cmark_syntax_extension_set_get_type_string_func(self, get_type_string);\n  cmark_syntax_extension_set_can_contain_func(self, can_contain);\n  cmark_syntax_extension_set_contains_inlines_func(self, contains_inlines);\n  cmark_syntax_extension_set_commonmark_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_plaintext_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_latex_render_func(self, latex_render);\n  cmark_syntax_extension_set_xml_attr_func(self, xml_attr);\n  cmark_syntax_extension_set_man_render_func(self, man_render);\n  cmark_syntax_extension_set_html_render_func(self, html_render);\n  cmark_syntax_extension_set_opaque_alloc_func(self, opaque_alloc);\n  cmark_syntax_extension_set_opaque_free_func(self, opaque_free);\n  cmark_syntax_extension_set_commonmark_escape_func(self, escape);\n  CMARK_NODE_TABLE = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_ROW = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_CELL = cmark_syntax_extension_add_node(0);\n\n  return self;\n}\n\nuint16_t cmark_gfm_extensions_get_table_columns(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->n_columns;\n}\n\nuint8_t *cmark_gfm_extensions_get_table_alignments(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nint cmark_gfm_extensions_set_table_columns(cmark_node *node, uint16_t n_columns) {\n  return set_n_table_columns(node, n_columns);\n}\n\nint cmark_gfm_extensions_set_table_alignments(cmark_node *node, uint16_t ncols, uint8_t *alignments) {\n  uint8_t *a = (uint8_t *)cmark_node_mem(node)->calloc(1, ncols);\n  memcpy(a, alignments, ncols);\n  return set_table_alignments(node, a);\n}\n\nint cmark_gfm_extensions_get_table_row_is_header(cmark_node *node)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  return ((node_table_row *)node->as.opaque)->is_header;\n}\n\nint cmark_gfm_extensions_set_table_row_is_header(cmark_node *node, int is_header)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  ((node_table_row *)node->as.opaque)->is_header = (is_header != 0);\n  return 1;\n}\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport re\nimport argparse\nimport sys\nimport platform\nimport itertools\nimport multiprocessing\nfrom cmark import CMark\n\ndef hash_collisions():\n    REFMAP_SIZE = 16\n    COUNT = 50000\n\n    def badhash(ref):\n        h = 0\n        for c in ref:\n            a = (h << 6) & 0xFFFFFFFF\n            b = (h << 16) & 0xFFFFFFFF\n            h = ord(c) + a + b - h\n            h = h & 0xFFFFFFFF\n\n        return (h % REFMAP_SIZE) == 0\n\n    keys = (\"x%d\" % i for i in itertools.count())\n    collisions = itertools.islice((k for k in keys if badhash(k)), COUNT)\n    bad_key = next(collisions)\n\n    document = ''.join(\"[%s]: /url\\n\\n[%s]\\n\\n\" % (key, bad_key) for key in collisions)\n\n    return document, re.compile(\"(<p>\\[%s\\]</p>\\n){%d}\" % (bad_key, COUNT-1))\n\nallowed_failures = {\"many references\": True}\n\n# list of pairs consisting of input and a regex that must match the output.\npathological = {\n    # note - some pythons have limit of 65535 for {num-matches} in re.\n    \"nested strong emph\":\n                ((\"*a **a \" * 65000) + \"b\" + (\" a** a*\" * 65000),\n                 re.compile(\"(<em>a <strong>a ){65000}b( a</strong> a</em>){65000}\")),\n    \"many emph closers with no openers\":\n                 ((\"a_ \" * 65000),\n                  re.compile(\"(a[_] ){64999}a_\")),\n    \"many emph openers with no closers\":\n                 ((\"_a \" * 65000),\n                  re.compile(\"(_a ){64999}_a\")),\n    \"many link closers with no openers\":\n                 ((\"a]\" * 65000),\n                  re.compile(\"(a\\]){65000}\")),\n    \"many link openers with no closers\":\n                 ((\"[a\" * 65000),\n                  re.compile(\"(\\[a){65000}\")),\n    \"mismatched openers and closers\":\n                 ((\"*a_ \" * 50000),\n                  re.compile(\"([*]a[_] ){49999}[*]a_\")),\n    \"openers and closers multiple of 3\":\n                 ((\"a**b\" + (\"c* \" * 50000)),\n                  re.compile(\"a[*][*]b(c[*] ){49999}c[*]\")),\n    \"link openers and emph closers\":\n                 ((\"[ a_\" * 50000),\n                  re.compile(\"(\\[ a_){50000}\")),\n    \"pattern [ (]( repeated\":\n                 ((\"[ (](\" * 80000),\n                  re.compile(\"(\\[ \\(\\]\\(){80000}\")),\n    \"hard link/emph case\":\n                 (\"**x [a*b**c*](d)\",\n                  re.compile(\"\\\\*\\\\*x <a href=\\\"d\\\">a<em>b\\\\*\\\\*c</em></a>\")),\n    \"nested brackets\":\n                 ((\"[\" * 50000) + \"a\" + (\"]\" * 50000),\n                  re.compile(\"\\[{50000}a\\]{50000}\")),\n    \"nested block quotes\":\n                 (((\"> \" * 50000) + \"a\"),\n                  re.compile(\"(<blockquote>\\n){50000}\")),\n    \"deeply nested lists\":\n                 (\"\".join(map(lambda x: (\"  \" * x + \"* a\\n\"), range(0,1000))),\n                  re.compile(\"<ul>\\n(<li>a\\n<ul>\\n){999}<li>a</li>\\n</ul>\\n(</li>\\n</ul>\\n){999}\")),\n    \"U+0000 in input\":\n                 (\"abc\\u0000de\\u0000\",\n                  re.compile(\"abc\\ufffd?de\\ufffd?\")),\n    \"backticks\":\n                 (\"\".join(map(lambda x: (\"e\" + \"`\" * x), range(1,5000))),\n                  re.compile(\"^<p>[e`]*</p>\\n$\")),\n    \"unclosed links A\":\n                 (\"[a](<b\" * 30000,\n                  re.compile(\"(\\[a\\]\\(&lt;b){30000}\")),\n    \"unclosed links B\":\n                 (\"[a](b\" * 30000,\n                  re.compile(\"(\\[a\\]\\(b){30000}\")),\n#    \"many references\":\n#                 (\"\".join(map(lambda x: (\"[\" + str(x) + \"]: u\\n\"), range(1,5000 * 16))) + \"[0] \" * 5000,\n#                  re.compile(\"(\\[0\\] ){4999}\")),\n    \"reference collisions\": hash_collisions()\n    }\n\nwhitespace_re = re.compile('/s+/')\npassed = 0\nerrored = 0\nignored = 0\nTIMEOUT = 5\n\ndef run_test(inp, regex):\n    parser = argparse.ArgumentParser(description='Run cmark tests.')\n    parser.add_argument('--program', dest='program', nargs='?', default=None,\n            help='program to test')\n    parser.add_argument('--library-dir', dest='library_dir', nargs='?',\n            default=None, help='directory containing dynamic library')\n    args = parser.parse_args(sys.argv[1:])\n    cmark = CMark(prog=args.program, library_dir=args.library_dir)\n\n    [rc, actual, err] = cmark.to_html(inp)\n    if rc != 0:\n        print('[ERRORED (return code %d)]' % rc)\n        print(err)\n        exit(1)\n    elif regex.search(actual):\n        print('[PASSED]')\n    else:\n        print('[FAILED (mismatch)]')\n        print(repr(actual))\n        exit(1)\n\nif __name__ == '__main__':\n    print(\"Testing pathological cases:\")\n    for description in pathological:\n        (inp, regex) = pathological[description]\n        print(description, \"... \", end='')\n        sys.stdout.flush()\n\n        p = multiprocessing.Process(target=run_test, args=(inp, regex))\n        p.start()\n        p.join(TIMEOUT)\n\n        if p.is_alive():\n            p.terminate()\n            p.join()\n            print('[TIMED OUT]')\n            if allowed_failures[description]:\n                ignored += 1\n            else:\n                errored += 1\n        elif p.exitcode != 0:\n            if allowed_failures[description]:\n                ignored += 1\n            else:\n                errored += 1\n        else:\n            passed += 1\n\n    print(\"%d passed, %d errored, %d ignored\" % (passed, errored, ignored))\n    exit(errored)\n"], "fixing_code": ["/* Generated by re2c 1.3 */\n\n#include \"ext_scanners.h\"\n#include <stdlib.h>\n\nbufsize_t _ext_scan_at(bufsize_t (*scanner)(const unsigned char *),\n                       unsigned char *ptr, int len, bufsize_t offset) {\n  bufsize_t res;\n\n  if (ptr == NULL || offset >= len) {\n    return 0;\n  } else {\n    unsigned char lim = ptr[len];\n\n    ptr[len] = '\\0';\n    res = scanner(ptr + offset);\n    ptr[len] = lim;\n  }\n\n  return res;\n}\n\nbufsize_t _scan_table_start(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 64, 0,  64, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  64, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 128, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,   0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0,\n    };\n    yych = *p;\n    if (yych <= ' ') {\n      if (yych <= '\\n') {\n        if (yych == '\\t')\n          goto yy4;\n      } else {\n        if (yych <= '\\f')\n          goto yy4;\n        if (yych >= ' ')\n          goto yy4;\n      }\n    } else {\n      if (yych <= '9') {\n        if (yych == '-')\n          goto yy5;\n      } else {\n        if (yych <= ':')\n          goto yy6;\n        if (yych == '|')\n          goto yy4;\n      }\n    }\n    ++p;\n  yy3 : { return 0; }\n  yy4:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 64) {\n      goto yy7;\n    }\n    if (yych == '-')\n      goto yy10;\n    if (yych == ':')\n      goto yy12;\n    goto yy3;\n  yy5:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 128) {\n      goto yy10;\n    }\n    if (yych <= ' ') {\n      if (yych <= 0x08)\n        goto yy3;\n      if (yych <= '\\r')\n        goto yy14;\n      if (yych <= 0x1F)\n        goto yy3;\n      goto yy14;\n    } else {\n      if (yych <= ':') {\n        if (yych <= '9')\n          goto yy3;\n        goto yy13;\n      } else {\n        if (yych == '|')\n          goto yy14;\n        goto yy3;\n      }\n    }\n  yy6:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 128) {\n      goto yy10;\n    }\n    goto yy3;\n  yy7:\n    yych = *++p;\n    if (yybm[0 + yych] & 64) {\n      goto yy7;\n    }\n    if (yych == '-')\n      goto yy10;\n    if (yych == ':')\n      goto yy12;\n  yy9:\n    p = marker;\n    goto yy3;\n  yy10:\n    yych = *++p;\n    if (yybm[0 + yych] & 128) {\n      goto yy10;\n    }\n    if (yych <= 0x1F) {\n      if (yych <= '\\n') {\n        if (yych <= 0x08)\n          goto yy9;\n        if (yych <= '\\t')\n          goto yy13;\n        goto yy15;\n      } else {\n        if (yych <= '\\f')\n          goto yy13;\n        if (yych <= '\\r')\n          goto yy17;\n        goto yy9;\n      }\n    } else {\n      if (yych <= ':') {\n        if (yych <= ' ')\n          goto yy13;\n        if (yych <= '9')\n          goto yy9;\n        goto yy13;\n      } else {\n        if (yych == '|')\n          goto yy18;\n        goto yy9;\n      }\n    }\n  yy12:\n    yych = *++p;\n    if (yybm[0 + yych] & 128) {\n      goto yy10;\n    }\n    goto yy9;\n  yy13:\n    yych = *++p;\n  yy14:\n    if (yych <= '\\r') {\n      if (yych <= '\\t') {\n        if (yych <= 0x08)\n          goto yy9;\n        goto yy13;\n      } else {\n        if (yych <= '\\n')\n          goto yy15;\n        if (yych <= '\\f')\n          goto yy13;\n        goto yy17;\n      }\n    } else {\n      if (yych <= ' ') {\n        if (yych <= 0x1F)\n          goto yy9;\n        goto yy13;\n      } else {\n        if (yych == '|')\n          goto yy18;\n        goto yy9;\n      }\n    }\n  yy15:\n    ++p;\n    { return (bufsize_t)(p - start); }\n  yy17:\n    yych = *++p;\n    if (yych == '\\n')\n      goto yy15;\n    goto yy9;\n  yy18:\n    yych = *++p;\n    if (yybm[0 + yych] & 128) {\n      goto yy10;\n    }\n    if (yych <= '\\r') {\n      if (yych <= '\\t') {\n        if (yych <= 0x08)\n          goto yy9;\n        goto yy18;\n      } else {\n        if (yych <= '\\n')\n          goto yy15;\n        if (yych <= '\\f')\n          goto yy18;\n        goto yy17;\n      }\n    } else {\n      if (yych <= ' ') {\n        if (yych <= 0x1F)\n          goto yy9;\n        goto yy18;\n      } else {\n        if (yych == ':')\n          goto yy12;\n        goto yy9;\n      }\n    }\n  }\n}\n\nbufsize_t _scan_table_cell(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    unsigned int yyaccept = 0;\n    static const unsigned char yybm[] = {\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 0,  64, 64, 0,  64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 128, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n        64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 0,  64,\n        64, 64, 0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  0,  0,   0,\n    };\n    yych = *p;\n    if (yybm[0 + yych] & 64) {\n      goto yy22;\n    }\n    if (yych <= 0xEC) {\n      if (yych <= 0xC1) {\n        if (yych <= '\\r')\n          goto yy25;\n        if (yych <= '\\\\')\n          goto yy27;\n        goto yy25;\n      } else {\n        if (yych <= 0xDF)\n          goto yy29;\n        if (yych <= 0xE0)\n          goto yy30;\n        goto yy31;\n      }\n    } else {\n      if (yych <= 0xF0) {\n        if (yych <= 0xED)\n          goto yy32;\n        if (yych <= 0xEF)\n          goto yy31;\n        goto yy33;\n      } else {\n        if (yych <= 0xF3)\n          goto yy34;\n        if (yych <= 0xF4)\n          goto yy35;\n        goto yy25;\n      }\n    }\n  yy22:\n    yyaccept = 0;\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 64) {\n      goto yy22;\n    }\n    if (yych <= 0xEC) {\n      if (yych <= 0xC1) {\n        if (yych <= '\\r')\n          goto yy24;\n        if (yych <= '\\\\')\n          goto yy27;\n      } else {\n        if (yych <= 0xDF)\n          goto yy36;\n        if (yych <= 0xE0)\n          goto yy38;\n        goto yy39;\n      }\n    } else {\n      if (yych <= 0xF0) {\n        if (yych <= 0xED)\n          goto yy40;\n        if (yych <= 0xEF)\n          goto yy39;\n        goto yy41;\n      } else {\n        if (yych <= 0xF3)\n          goto yy42;\n        if (yych <= 0xF4)\n          goto yy43;\n      }\n    }\n  yy24 : { return (bufsize_t)(p - start); }\n  yy25:\n    ++p;\n  yy26 : { return 0; }\n  yy27:\n    yyaccept = 0;\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 128) {\n      goto yy27;\n    }\n    if (yych <= 0xDF) {\n      if (yych <= '\\f') {\n        if (yych == '\\n')\n          goto yy24;\n        goto yy22;\n      } else {\n        if (yych <= '\\r')\n          goto yy24;\n        if (yych <= 0x7F)\n          goto yy22;\n        if (yych <= 0xC1)\n          goto yy24;\n        goto yy36;\n      }\n    } else {\n      if (yych <= 0xEF) {\n        if (yych <= 0xE0)\n          goto yy38;\n        if (yych == 0xED)\n          goto yy40;\n        goto yy39;\n      } else {\n        if (yych <= 0xF0)\n          goto yy41;\n        if (yych <= 0xF3)\n          goto yy42;\n        if (yych <= 0xF4)\n          goto yy43;\n        goto yy24;\n      }\n    }\n  yy29:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy26;\n    if (yych <= 0xBF)\n      goto yy22;\n    goto yy26;\n  yy30:\n    yyaccept = 1;\n    yych = *(marker = ++p);\n    if (yych <= 0x9F)\n      goto yy26;\n    if (yych <= 0xBF)\n      goto yy36;\n    goto yy26;\n  yy31:\n    yyaccept = 1;\n    yych = *(marker = ++p);\n    if (yych <= 0x7F)\n      goto yy26;\n    if (yych <= 0xBF)\n      goto yy36;\n    goto yy26;\n  yy32:\n    yyaccept = 1;\n    yych = *(marker = ++p);\n    if (yych <= 0x7F)\n      goto yy26;\n    if (yych <= 0x9F)\n      goto yy36;\n    goto yy26;\n  yy33:\n    yyaccept = 1;\n    yych = *(marker = ++p);\n    if (yych <= 0x8F)\n      goto yy26;\n    if (yych <= 0xBF)\n      goto yy39;\n    goto yy26;\n  yy34:\n    yyaccept = 1;\n    yych = *(marker = ++p);\n    if (yych <= 0x7F)\n      goto yy26;\n    if (yych <= 0xBF)\n      goto yy39;\n    goto yy26;\n  yy35:\n    yyaccept = 1;\n    yych = *(marker = ++p);\n    if (yych <= 0x7F)\n      goto yy26;\n    if (yych <= 0x8F)\n      goto yy39;\n    goto yy26;\n  yy36:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy22;\n  yy37:\n    p = marker;\n    if (yyaccept == 0) {\n      goto yy24;\n    } else {\n      goto yy26;\n    }\n  yy38:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy36;\n    goto yy37;\n  yy39:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy36;\n    goto yy37;\n  yy40:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0x9F)\n      goto yy36;\n    goto yy37;\n  yy41:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy39;\n    goto yy37;\n  yy42:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0xBF)\n      goto yy39;\n    goto yy37;\n  yy43:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy37;\n    if (yych <= 0x8F)\n      goto yy39;\n    goto yy37;\n  }\n}\n\nbufsize_t _scan_table_cell_end(const unsigned char *p) {\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 128, 128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0,\n    };\n    yych = *p;\n    if (yych == '|')\n      goto yy48;\n    ++p;\n    { return 0; }\n  yy48:\n    yych = *++p;\n    if (yybm[0 + yych] & 128) {\n      goto yy48;\n    }\n    { return (bufsize_t)(p - start); }\n  }\n}\n\nbufsize_t _scan_table_row_end(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 128, 128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   128, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0,   0, 0, 0,\n    };\n    yych = *p;\n    if (yych <= '\\f') {\n      if (yych <= 0x08)\n        goto yy53;\n      if (yych == '\\n')\n        goto yy56;\n      goto yy55;\n    } else {\n      if (yych <= '\\r')\n        goto yy58;\n      if (yych == ' ')\n        goto yy55;\n    }\n  yy53:\n    ++p;\n  yy54 : { return 0; }\n  yy55:\n    yych = *(marker = ++p);\n    if (yych <= 0x08)\n      goto yy54;\n    if (yych <= '\\r')\n      goto yy60;\n    if (yych == ' ')\n      goto yy60;\n    goto yy54;\n  yy56:\n    ++p;\n    { return (bufsize_t)(p - start); }\n  yy58:\n    yych = *++p;\n    if (yych == '\\n')\n      goto yy56;\n    goto yy54;\n  yy59:\n    yych = *++p;\n  yy60:\n    if (yybm[0 + yych] & 128) {\n      goto yy59;\n    }\n    if (yych <= 0x08)\n      goto yy61;\n    if (yych <= '\\n')\n      goto yy56;\n    if (yych <= '\\r')\n      goto yy62;\n  yy61:\n    p = marker;\n    goto yy54;\n  yy62:\n    yych = *++p;\n    if (yych == '\\n')\n      goto yy56;\n    goto yy61;\n  }\n}\n\nbufsize_t _scan_tasklist(const unsigned char *p) {\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n\n  {\n    unsigned char yych;\n    static const unsigned char yybm[] = {\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   64,  0, 64, 64, 0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        64,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0,  0,  0, 0, 0,\n    };\n    yych = *p;\n    if (yych <= ' ') {\n      if (yych <= '\\n') {\n        if (yych == '\\t')\n          goto yy67;\n      } else {\n        if (yych <= '\\f')\n          goto yy67;\n        if (yych >= ' ')\n          goto yy67;\n      }\n    } else {\n      if (yych <= ',') {\n        if (yych <= ')')\n          goto yy65;\n        if (yych <= '+')\n          goto yy68;\n      } else {\n        if (yych <= '-')\n          goto yy68;\n        if (yych <= '/')\n          goto yy65;\n        if (yych <= '9')\n          goto yy69;\n      }\n    }\n  yy65:\n    ++p;\n  yy66 : { return 0; }\n  yy67:\n    yych = *(marker = ++p);\n    if (yybm[0 + yych] & 64) {\n      goto yy70;\n    }\n    if (yych <= ',') {\n      if (yych <= ')')\n        goto yy66;\n      if (yych <= '+')\n        goto yy73;\n      goto yy66;\n    } else {\n      if (yych <= '-')\n        goto yy73;\n      if (yych <= '/')\n        goto yy66;\n      if (yych <= '9')\n        goto yy74;\n      goto yy66;\n    }\n  yy68:\n    yych = *(marker = ++p);\n    if (yych <= '\\n') {\n      if (yych == '\\t')\n        goto yy75;\n      goto yy66;\n    } else {\n      if (yych <= '\\f')\n        goto yy75;\n      if (yych == ' ')\n        goto yy75;\n      goto yy66;\n    }\n  yy69:\n    yych = *(marker = ++p);\n    if (yych <= 0x1F) {\n      if (yych <= '\\t') {\n        if (yych <= 0x08)\n          goto yy78;\n        goto yy73;\n      } else {\n        if (yych <= '\\n')\n          goto yy66;\n        if (yych <= '\\f')\n          goto yy73;\n        goto yy78;\n      }\n    } else {\n      if (yych <= 0x7F) {\n        if (yych <= ' ')\n          goto yy73;\n        goto yy78;\n      } else {\n        if (yych <= 0xC1)\n          goto yy66;\n        if (yych <= 0xF4)\n          goto yy78;\n        goto yy66;\n      }\n    }\n  yy70:\n    yych = *++p;\n    if (yybm[0 + yych] & 64) {\n      goto yy70;\n    }\n    if (yych <= ',') {\n      if (yych <= ')')\n        goto yy72;\n      if (yych <= '+')\n        goto yy73;\n    } else {\n      if (yych <= '-')\n        goto yy73;\n      if (yych <= '/')\n        goto yy72;\n      if (yych <= '9')\n        goto yy74;\n    }\n  yy72:\n    p = marker;\n    goto yy66;\n  yy73:\n    yych = *++p;\n    if (yych == '[')\n      goto yy72;\n    goto yy76;\n  yy74:\n    yych = *++p;\n    if (yych <= '\\n') {\n      if (yych == '\\t')\n        goto yy73;\n      goto yy78;\n    } else {\n      if (yych <= '\\f')\n        goto yy73;\n      if (yych == ' ')\n        goto yy73;\n      goto yy78;\n    }\n  yy75:\n    yych = *++p;\n  yy76:\n    if (yych <= '\\f') {\n      if (yych == '\\t')\n        goto yy75;\n      if (yych <= '\\n')\n        goto yy72;\n      goto yy75;\n    } else {\n      if (yych <= ' ') {\n        if (yych <= 0x1F)\n          goto yy72;\n        goto yy75;\n      } else {\n        if (yych == '[')\n          goto yy86;\n        goto yy72;\n      }\n    }\n  yy77:\n    yych = *++p;\n  yy78:\n    if (yybm[0 + yych] & 128) {\n      goto yy77;\n    }\n    if (yych <= 0xC1) {\n      if (yych <= '\\f') {\n        if (yych <= 0x08)\n          goto yy73;\n        if (yych == '\\n')\n          goto yy72;\n        goto yy75;\n      } else {\n        if (yych == ' ')\n          goto yy75;\n        if (yych <= 0x7F)\n          goto yy73;\n        goto yy72;\n      }\n    } else {\n      if (yych <= 0xED) {\n        if (yych <= 0xDF)\n          goto yy79;\n        if (yych <= 0xE0)\n          goto yy80;\n        if (yych <= 0xEC)\n          goto yy81;\n        goto yy82;\n      } else {\n        if (yych <= 0xF0) {\n          if (yych <= 0xEF)\n            goto yy81;\n          goto yy83;\n        } else {\n          if (yych <= 0xF3)\n            goto yy84;\n          if (yych <= 0xF4)\n            goto yy85;\n          goto yy72;\n        }\n      }\n    }\n  yy79:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy72;\n    if (yych <= 0xBF)\n      goto yy73;\n    goto yy72;\n  yy80:\n    yych = *++p;\n    if (yych <= 0x9F)\n      goto yy72;\n    if (yych <= 0xBF)\n      goto yy79;\n    goto yy72;\n  yy81:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy72;\n    if (yych <= 0xBF)\n      goto yy79;\n    goto yy72;\n  yy82:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy72;\n    if (yych <= 0x9F)\n      goto yy79;\n    goto yy72;\n  yy83:\n    yych = *++p;\n    if (yych <= 0x8F)\n      goto yy72;\n    if (yych <= 0xBF)\n      goto yy81;\n    goto yy72;\n  yy84:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy72;\n    if (yych <= 0xBF)\n      goto yy81;\n    goto yy72;\n  yy85:\n    yych = *++p;\n    if (yych <= 0x7F)\n      goto yy72;\n    if (yych <= 0x8F)\n      goto yy81;\n    goto yy72;\n  yy86:\n    yych = *++p;\n    if (yych <= 'W') {\n      if (yych != ' ')\n        goto yy72;\n    } else {\n      if (yych <= 'X')\n        goto yy87;\n      if (yych != 'x')\n        goto yy72;\n    }\n  yy87:\n    yych = *++p;\n    if (yych != ']')\n      goto yy72;\n    yych = *++p;\n    if (yych <= '\\n') {\n      if (yych != '\\t')\n        goto yy72;\n    } else {\n      if (yych <= '\\f')\n        goto yy89;\n      if (yych != ' ')\n        goto yy72;\n    }\n  yy89:\n    yych = *++p;\n    if (yych <= '\\n') {\n      if (yych == '\\t')\n        goto yy89;\n    } else {\n      if (yych <= '\\f')\n        goto yy89;\n      if (yych == ' ')\n        goto yy89;\n    }\n    { return (bufsize_t)(p - start); }\n  }\n}\n", "/*!re2c re2c:flags:no-debug-info = 1; */\n/*!re2c re2c:indent:string = '  '; */\n\n#include <stdlib.h>\n#include \"ext_scanners.h\"\n\nbufsize_t _ext_scan_at(bufsize_t (*scanner)(const unsigned char *), unsigned char *ptr, int len, bufsize_t offset)\n{\n\tbufsize_t res;\n\n        if (ptr == NULL || offset >= len) {\n          return 0;\n        } else {\n\t  unsigned char lim = ptr[len];\n\n\t  ptr[len] = '\\0';\n\t  res = scanner(ptr + offset);\n\t  ptr[len] = lim;\n        }\n\n\treturn res;\n}\n\n/*!re2c\n  re2c:define:YYCTYPE  = \"unsigned char\";\n  re2c:define:YYCURSOR = p;\n  re2c:define:YYMARKER = marker;\n  re2c:yyfill:enable = 0;\n\n  spacechar = [ \\t\\v\\f];\n  newline = [\\r]?[\\n];\n  escaped_char = [\\\\][|!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{}~-];\n\n  table_marker = (spacechar*[:]?[-]+[:]?spacechar*);\n  table_cell = (escaped_char|[^|\\r\\n])+;\n\n  tasklist = spacechar*(\"-\"|\"+\"|\"*\"|[0-9]+.)spacechar+(\"[ ]\"|\"[x]\")spacechar+;\n*/\n\nbufsize_t _scan_table_start(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n  /*!re2c\n    [|]? table_marker ([|] table_marker)* [|]? spacechar* newline {\n      return (bufsize_t)(p - start);\n    }\n    * { return 0; }\n  */\n}\n\nbufsize_t _scan_table_cell(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n  /*!re2c\n    // In fact, `table_cell` matches non-empty table cells only. The empty\n    // string is also a valid table cell, but is handled by the default rule.\n    // This approach prevents re2c's match-empty-string warning.\n    table_cell { return (bufsize_t)(p - start); }\n    * { return 0; }\n  */\n}\n\nbufsize_t _scan_table_cell_end(const unsigned char *p)\n{\n  const unsigned char *start = p;\n  /*!re2c\n    [|] spacechar* { return (bufsize_t)(p - start); }\n    * { return 0; }\n  */\n}\n\nbufsize_t _scan_table_row_end(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n  /*!re2c\n    spacechar* newline { return (bufsize_t)(p - start); }\n    * { return 0; }\n  */\n}\n\nbufsize_t _scan_tasklist(const unsigned char *p)\n{\n  const unsigned char *marker = NULL;\n  const unsigned char *start = p;\n  /*!re2c\n    tasklist { return (bufsize_t)(p - start); }\n    * { return 0; }\n  */\n}\n", "#include <cmark-gfm-extension_api.h>\n#include <html.h>\n#include <inlines.h>\n#include <parser.h>\n#include <references.h>\n#include <string.h>\n#include <render.h>\n\n#include \"ext_scanners.h\"\n#include \"strikethrough.h\"\n#include \"table.h\"\n#include \"cmark-gfm-core-extensions.h\"\n\ncmark_node_type CMARK_NODE_TABLE, CMARK_NODE_TABLE_ROW,\n    CMARK_NODE_TABLE_CELL;\n\ntypedef struct {\n  uint16_t n_columns;\n  int paragraph_offset;\n  cmark_llist *cells;\n} table_row;\n\ntypedef struct {\n  uint16_t n_columns;\n  uint8_t *alignments;\n} node_table;\n\ntypedef struct {\n  bool is_header;\n} node_table_row;\n\ntypedef struct {\n  cmark_strbuf *buf;\n  int start_offset, end_offset, internal_offset;\n} node_cell;\n\nstatic void free_table_cell(cmark_mem *mem, void *data) {\n  node_cell *cell = (node_cell *)data;\n  cmark_strbuf_free((cmark_strbuf *)cell->buf);\n  mem->free(cell->buf);\n  mem->free(cell);\n}\n\nstatic void free_table_row(cmark_mem *mem, table_row *row) {\n  if (!row)\n    return;\n\n  cmark_llist_free_full(mem, row->cells, (cmark_free_func)free_table_cell);\n\n  mem->free(row);\n}\n\nstatic void free_node_table(cmark_mem *mem, void *ptr) {\n  node_table *t = (node_table *)ptr;\n  mem->free(t->alignments);\n  mem->free(t);\n}\n\nstatic void free_node_table_row(cmark_mem *mem, void *ptr) {\n  mem->free(ptr);\n}\n\nstatic int get_n_table_columns(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return -1;\n\n  return (int)((node_table *)node->as.opaque)->n_columns;\n}\n\nstatic int set_n_table_columns(cmark_node *node, uint16_t n_columns) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->n_columns = n_columns;\n  return 1;\n}\n\nstatic uint8_t *get_table_alignments(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nstatic int set_table_alignments(cmark_node *node, uint8_t *alignments) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->alignments = alignments;\n  return 1;\n}\n\nstatic cmark_strbuf *unescape_pipes(cmark_mem *mem, unsigned char *string, bufsize_t len)\n{\n  cmark_strbuf *res = (cmark_strbuf *)mem->calloc(1, sizeof(cmark_strbuf));\n  bufsize_t r, w;\n\n  cmark_strbuf_init(mem, res, len + 1);\n  cmark_strbuf_put(res, string, len);\n  cmark_strbuf_putc(res, '\\0');\n\n  for (r = 0, w = 0; r < len; ++r) {\n    if (res->ptr[r] == '\\\\' && res->ptr[r + 1] == '|')\n      r++;\n\n    res->ptr[w++] = res->ptr[r];\n  }\n\n  cmark_strbuf_truncate(res, w);\n\n  return res;\n}\n\nstatic table_row *row_from_string(cmark_syntax_extension *self,\n                                  cmark_parser *parser, unsigned char *string,\n                                  int len) {\n  // Parses a single table row. It has the following form:\n  // `delim? table_cell (delim table_cell)* delim? newline`\n  // Note that cells are allowed to be empty.\n  //\n  // From the GitHub-flavored Markdown specification:\n  //\n  // > Each row consists of cells containing arbitrary text, in which inlines\n  // > are parsed, separated by pipes (|). A leading and trailing pipe is also\n  // > recommended for clarity of reading, and if there\u2019s otherwise parsing\n  // > ambiguity.\n\n  table_row *row = NULL;\n  bufsize_t cell_matched = 1, pipe_matched = 1, offset;\n  int expect_more_cells = 1;\n  int row_end_offset = 0;\n\n  row = (table_row *)parser->mem->calloc(1, sizeof(table_row));\n  row->n_columns = 0;\n  row->cells = NULL;\n\n  // Scan past the (optional) leading pipe.\n  offset = scan_table_cell_end(string, len, 0);\n\n  // Parse the cells of the row. Stop if we reach the end of the input, or if we\n  // cannot detect any more cells.\n  while (offset < len && expect_more_cells) {\n    cell_matched = scan_table_cell(string, len, offset);\n    pipe_matched = scan_table_cell_end(string, len, offset + cell_matched);\n\n    if (cell_matched || pipe_matched) {\n      // We are guaranteed to have a cell, since (1) either we found some\n      // content and cell_matched, or (2) we found an empty cell followed by a\n      // pipe.\n      cmark_strbuf *cell_buf = unescape_pipes(parser->mem, string + offset,\n          cell_matched);\n      cmark_strbuf_trim(cell_buf);\n\n      node_cell *cell = (node_cell *)parser->mem->calloc(1, sizeof(*cell));\n      cell->buf = cell_buf;\n      cell->start_offset = offset;\n      cell->end_offset = offset + cell_matched - 1;\n\n      while (cell->start_offset > 0 && string[cell->start_offset - 1] != '|') {\n        --cell->start_offset;\n        ++cell->internal_offset;\n      }\n\n      row->n_columns += 1;\n      row->cells = cmark_llist_append(parser->mem, row->cells, cell);\n    }\n\n    offset += cell_matched + pipe_matched;\n\n    if (pipe_matched) {\n      expect_more_cells = 1;\n    } else {\n      // We've scanned the last cell. Check if we have reached the end of the row\n      row_end_offset = scan_table_row_end(string, len, offset);\n      offset += row_end_offset;\n\n      // If the end of the row is not the end of the input,\n      // the row is not a real row but potentially part of the paragraph\n      // preceding the table.\n      if (row_end_offset && offset != len) {\n        row->paragraph_offset = offset;\n\n        cmark_llist_free_full(parser->mem, row->cells, (cmark_free_func)free_table_cell);\n        row->cells = NULL;\n        row->n_columns = 0;\n\n        // Scan past the (optional) leading pipe.\n        offset += scan_table_cell_end(string, len, offset);\n\n        expect_more_cells = 1;\n      } else {\n        expect_more_cells = 0;\n      }\n    }\n  }\n\n  if (offset != len || row->n_columns == 0) {\n    free_table_row(parser->mem, row);\n    row = NULL;\n  }\n\n  return row;\n}\n\nstatic void try_inserting_table_header_paragraph(cmark_parser *parser,\n                                                 cmark_node *parent_container,\n                                                 unsigned char *parent_string,\n                                                 int paragraph_offset) {\n  cmark_node *paragraph;\n  cmark_strbuf *paragraph_content;\n\n  paragraph = cmark_node_new_with_mem(CMARK_NODE_PARAGRAPH, parser->mem);\n\n  paragraph_content = unescape_pipes(parser->mem, parent_string, paragraph_offset);\n  cmark_strbuf_trim(paragraph_content);\n  cmark_node_set_string_content(paragraph, (char *) paragraph_content->ptr);\n  cmark_strbuf_free(paragraph_content);\n  parser->mem->free(paragraph_content);\n\n  if (!cmark_node_insert_before(parent_container, paragraph)) {\n    parser->mem->free(paragraph);\n  }\n}\n\nstatic cmark_node *try_opening_table_header(cmark_syntax_extension *self,\n                                            cmark_parser *parser,\n                                            cmark_node *parent_container,\n                                            unsigned char *input, int len) {\n  cmark_node *table_header;\n  table_row *header_row = NULL;\n  table_row *marker_row = NULL;\n  node_table_row *ntr;\n  const char *parent_string;\n  uint16_t i;\n\n  if (!scan_table_start(input, len, cmark_parser_get_first_nonspace(parser))) {\n    return parent_container;\n  }\n\n  // Since scan_table_start was successful, we must have a marker row.\n  marker_row = row_from_string(self, parser,\n                               input + cmark_parser_get_first_nonspace(parser),\n                               len - cmark_parser_get_first_nonspace(parser));\n  assert(marker_row);\n\n  cmark_arena_push();\n\n  // Check for a matching header row. We call `row_from_string` with the entire\n  // (potentially long) parent container as input, but this should be safe since\n  // `row_from_string` bails out early if it does not find a row.\n  parent_string = cmark_node_get_string_content(parent_container);\n  header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                               (int)strlen(parent_string));\n  if (!header_row || header_row->n_columns != marker_row->n_columns) {\n    free_table_row(parser->mem, marker_row);\n    free_table_row(parser->mem, header_row);\n    cmark_arena_pop();\n    return parent_container;\n  }\n\n  if (cmark_arena_pop()) {\n    marker_row = row_from_string(\n        self, parser, input + cmark_parser_get_first_nonspace(parser),\n        len - cmark_parser_get_first_nonspace(parser));\n    header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                                 (int)strlen(parent_string));\n  }\n\n  if (!cmark_node_set_type(parent_container, CMARK_NODE_TABLE)) {\n    free_table_row(parser->mem, header_row);\n    free_table_row(parser->mem, marker_row);\n    return parent_container;\n  }\n\n  if (header_row->paragraph_offset) {\n    try_inserting_table_header_paragraph(parser, parent_container, (unsigned char *)parent_string,\n                                         header_row->paragraph_offset);\n  }\n\n  cmark_node_set_syntax_extension(parent_container, self);\n  parent_container->as.opaque = parser->mem->calloc(1, sizeof(node_table));\n  set_n_table_columns(parent_container, header_row->n_columns);\n\n  uint8_t *alignments =\n      (uint8_t *)parser->mem->calloc(header_row->n_columns, sizeof(uint8_t));\n  cmark_llist *it = marker_row->cells;\n  for (i = 0; it; it = it->next, ++i) {\n    node_cell *node = (node_cell *)it->data;\n    bool left = node->buf->ptr[0] == ':', right = node->buf->ptr[node->buf->size - 1] == ':';\n\n    if (left && right)\n      alignments[i] = 'c';\n    else if (left)\n      alignments[i] = 'l';\n    else if (right)\n      alignments[i] = 'r';\n  }\n  set_table_alignments(parent_container, alignments);\n\n  table_header =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_header, self);\n  table_header->end_column = parent_container->start_column + (int)strlen(parent_string) - 2;\n  table_header->start_line = table_header->end_line = parent_container->start_line;\n\n  table_header->as.opaque = ntr = (node_table_row *)parser->mem->calloc(1, sizeof(node_table_row));\n  ntr->is_header = true;\n\n  {\n    cmark_llist *tmp;\n\n    for (tmp = header_row->cells; tmp; tmp = tmp->next) {\n      node_cell *cell = (node_cell *) tmp->data;\n      cmark_node *header_cell = cmark_parser_add_child(parser, table_header,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      header_cell->start_line = header_cell->end_line = parent_container->start_line;\n      header_cell->internal_offset = cell->internal_offset;\n      header_cell->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(header_cell, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(header_cell, self);\n    }\n  }\n\n  cmark_parser_advance_offset(\n      parser, (char *)input,\n      (int)strlen((char *)input) - 1 - cmark_parser_get_offset(parser), false);\n\n  free_table_row(parser->mem, header_row);\n  free_table_row(parser->mem, marker_row);\n  return parent_container;\n}\n\nstatic cmark_node *try_opening_table_row(cmark_syntax_extension *self,\n                                         cmark_parser *parser,\n                                         cmark_node *parent_container,\n                                         unsigned char *input, int len) {\n  cmark_node *table_row_block;\n  table_row *row;\n\n  if (cmark_parser_is_blank(parser))\n    return NULL;\n\n  table_row_block =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_row_block, self);\n  table_row_block->end_column = parent_container->end_column;\n  table_row_block->as.opaque = parser->mem->calloc(1, sizeof(node_table_row));\n\n  row = row_from_string(self, parser, input + cmark_parser_get_first_nonspace(parser),\n      len - cmark_parser_get_first_nonspace(parser));\n\n  {\n    cmark_llist *tmp;\n    int i, table_columns = get_n_table_columns(parent_container);\n\n    for (tmp = row->cells, i = 0; tmp && i < table_columns; tmp = tmp->next, ++i) {\n      node_cell *cell = (node_cell *) tmp->data;\n      cmark_node *node = cmark_parser_add_child(parser, table_row_block,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      node->internal_offset = cell->internal_offset;\n      node->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(node, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(node, self);\n    }\n\n    for (; i < table_columns; ++i) {\n      cmark_node *node = cmark_parser_add_child(\n          parser, table_row_block, CMARK_NODE_TABLE_CELL, 0);\n      cmark_node_set_syntax_extension(node, self);\n    }\n  }\n\n  free_table_row(parser->mem, row);\n\n  cmark_parser_advance_offset(parser, (char *)input,\n                              len - 1 - cmark_parser_get_offset(parser), false);\n\n  return table_row_block;\n}\n\nstatic cmark_node *try_opening_table_block(cmark_syntax_extension *self,\n                                           int indented, cmark_parser *parser,\n                                           cmark_node *parent_container,\n                                           unsigned char *input, int len) {\n  cmark_node_type parent_type = cmark_node_get_type(parent_container);\n\n  if (!indented && parent_type == CMARK_NODE_PARAGRAPH) {\n    return try_opening_table_header(self, parser, parent_container, input, len);\n  } else if (!indented && parent_type == CMARK_NODE_TABLE) {\n    return try_opening_table_row(self, parser, parent_container, input, len);\n  }\n\n  return NULL;\n}\n\nstatic int matches(cmark_syntax_extension *self, cmark_parser *parser,\n                   unsigned char *input, int len,\n                   cmark_node *parent_container) {\n  int res = 0;\n\n  if (cmark_node_get_type(parent_container) == CMARK_NODE_TABLE) {\n    cmark_arena_push();\n    table_row *new_row = row_from_string(\n        self, parser, input + cmark_parser_get_first_nonspace(parser),\n        len - cmark_parser_get_first_nonspace(parser));\n    if (new_row && new_row->n_columns)\n      res = 1;\n    free_table_row(parser->mem, new_row);\n    cmark_arena_pop();\n  }\n\n  return res;\n}\n\nstatic const char *get_type_string(cmark_syntax_extension *self,\n                                   cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return \"table\";\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (((node_table_row *)node->as.opaque)->is_header)\n      return \"table_header\";\n    else\n      return \"table_row\";\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return \"table_cell\";\n  }\n\n  return \"<unknown>\";\n}\n\nstatic int can_contain(cmark_syntax_extension *extension, cmark_node *node,\n                       cmark_node_type child_type) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return child_type == CMARK_NODE_TABLE_ROW;\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    return child_type == CMARK_NODE_TABLE_CELL;\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return child_type == CMARK_NODE_TEXT || child_type == CMARK_NODE_CODE ||\n           child_type == CMARK_NODE_EMPH || child_type == CMARK_NODE_STRONG ||\n           child_type == CMARK_NODE_LINK || child_type == CMARK_NODE_IMAGE ||\n           child_type == CMARK_NODE_STRIKETHROUGH ||\n           child_type == CMARK_NODE_HTML_INLINE ||\n           child_type == CMARK_NODE_FOOTNOTE_REFERENCE;\n  }\n  return false;\n}\n\nstatic int contains_inlines(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  return node->type == CMARK_NODE_TABLE_CELL;\n}\n\nstatic void commonmark_render(cmark_syntax_extension *extension,\n                              cmark_renderer *renderer, cmark_node *node,\n                              cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    renderer->blankline(renderer);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"|\", false, LITERAL);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (entering) {\n      renderer->out(renderer, node, \" \", false, LITERAL);\n    } else {\n      renderer->out(renderer, node, \" |\", false, LITERAL);\n      if (((node_table_row *)node->parent->as.opaque)->is_header &&\n          !node->next) {\n        int i;\n        uint8_t *alignments = get_table_alignments(node->parent->parent);\n        uint16_t n_cols =\n            ((node_table *)node->parent->parent->as.opaque)->n_columns;\n        renderer->cr(renderer);\n        renderer->out(renderer, node, \"|\", false, LITERAL);\n        for (i = 0; i < n_cols; i++) {\n          switch (alignments[i]) {\n          case 0:   renderer->out(renderer, node, \" --- |\", false, LITERAL); break;\n          case 'l': renderer->out(renderer, node, \" :-- |\", false, LITERAL); break;\n          case 'c': renderer->out(renderer, node, \" :-: |\", false, LITERAL); break;\n          case 'r': renderer->out(renderer, node, \" --: |\", false, LITERAL); break;\n          }\n        }\n        renderer->cr(renderer);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void latex_render(cmark_syntax_extension *extension,\n                         cmark_renderer *renderer, cmark_node *node,\n                         cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{table}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{tabular}{\", false, LITERAL);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n      for (i = 0; i < n_cols; i++) {\n        switch(alignments[i]) {\n        case 0:\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n      renderer->out(renderer, node, \"}\", false, LITERAL);\n      renderer->cr(renderer);\n    } else {\n      renderer->out(renderer, node, \"\\\\end{tabular}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\end{table}\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering) {\n      if (node->next) {\n        renderer->out(renderer, node, \" & \", false, LITERAL);\n      } else {\n        renderer->out(renderer, node, \" \\\\\\\\\", false, LITERAL);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic const char *xml_attr(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (cmark_gfm_extensions_get_table_row_is_header(node->parent)) {\n      uint8_t *alignments = get_table_alignments(node->parent->parent);\n      int i = 0;\n      cmark_node *n;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n      switch (alignments[i]) {\n      case 'l': return \" align=\\\"left\\\"\";\n      case 'c': return \" align=\\\"center\\\"\";\n      case 'r': return \" align=\\\"right\\\"\";\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic void man_render(cmark_syntax_extension *extension,\n                       cmark_renderer *renderer, cmark_node *node,\n                       cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \".TS\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"tab(@);\", false, LITERAL);\n      renderer->cr(renderer);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n\n      for (i = 0; i < n_cols; i++) {\n        switch (alignments[i]) {\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 0:\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n\n      if (n_cols) {\n        renderer->out(renderer, node, \".\", false, LITERAL);\n        renderer->cr(renderer);\n      }\n    } else {\n      renderer->out(renderer, node, \".TE\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering && node->next) {\n      renderer->out(renderer, node, \"@\", false, LITERAL);\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void html_table_add_align(cmark_strbuf* html, const char* align, int options) {\n  if (options & CMARK_OPT_TABLE_PREFER_STYLE_ATTRIBUTES) {\n    cmark_strbuf_puts(html, \" style=\\\"text-align: \");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  } else {\n    cmark_strbuf_puts(html, \" align=\\\"\");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  }\n}\n\nstruct html_table_state {\n  unsigned need_closing_table_body : 1;\n  unsigned in_table_header : 1;\n};\n\nstatic void html_render(cmark_syntax_extension *extension,\n                        cmark_html_renderer *renderer, cmark_node *node,\n                        cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n  cmark_strbuf *html = renderer->html;\n  cmark_node *n;\n\n  // XXX: we just monopolise renderer->opaque.\n  struct html_table_state *table_state =\n      (struct html_table_state *)&renderer->opaque;\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"<table\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n      table_state->need_closing_table_body = false;\n    } else {\n      if (table_state->need_closing_table_body) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</tbody>\");\n        cmark_html_render_cr(html);\n      }\n      table_state->need_closing_table_body = false;\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</table>\");\n      cmark_html_render_cr(html);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        table_state->in_table_header = 1;\n        cmark_strbuf_puts(html, \"<thead>\");\n        cmark_html_render_cr(html);\n      } else if (!table_state->need_closing_table_body) {\n        cmark_strbuf_puts(html, \"<tbody>\");\n        cmark_html_render_cr(html);\n        table_state->need_closing_table_body = 1;\n      }\n      cmark_strbuf_puts(html, \"<tr\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</tr>\");\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</thead>\");\n        table_state->in_table_header = false;\n      }\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    uint8_t *alignments = get_table_alignments(node->parent->parent);\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"<th\");\n      } else {\n        cmark_strbuf_puts(html, \"<td\");\n      }\n\n      int i = 0;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n\n      switch (alignments[i]) {\n      case 'l': html_table_add_align(html, \"left\", options); break;\n      case 'c': html_table_add_align(html, \"center\", options); break;\n      case 'r': html_table_add_align(html, \"right\", options); break;\n      }\n\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"</th>\");\n      } else {\n        cmark_strbuf_puts(html, \"</td>\");\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void opaque_alloc(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table));\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table_row));\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    node->as.opaque = mem->calloc(1, sizeof(node_cell));\n  }\n}\n\nstatic void opaque_free(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    free_node_table(mem, node->as.opaque);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    free_node_table_row(mem, node->as.opaque);\n  }\n}\n\nstatic int escape(cmark_syntax_extension *self, cmark_node *node, int c) {\n  return\n    node->type != CMARK_NODE_TABLE &&\n    node->type != CMARK_NODE_TABLE_ROW &&\n    node->type != CMARK_NODE_TABLE_CELL &&\n    c == '|';\n}\n\ncmark_syntax_extension *create_table_extension(void) {\n  cmark_syntax_extension *self = cmark_syntax_extension_new(\"table\");\n\n  cmark_syntax_extension_set_match_block_func(self, matches);\n  cmark_syntax_extension_set_open_block_func(self, try_opening_table_block);\n  cmark_syntax_extension_set_get_type_string_func(self, get_type_string);\n  cmark_syntax_extension_set_can_contain_func(self, can_contain);\n  cmark_syntax_extension_set_contains_inlines_func(self, contains_inlines);\n  cmark_syntax_extension_set_commonmark_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_plaintext_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_latex_render_func(self, latex_render);\n  cmark_syntax_extension_set_xml_attr_func(self, xml_attr);\n  cmark_syntax_extension_set_man_render_func(self, man_render);\n  cmark_syntax_extension_set_html_render_func(self, html_render);\n  cmark_syntax_extension_set_opaque_alloc_func(self, opaque_alloc);\n  cmark_syntax_extension_set_opaque_free_func(self, opaque_free);\n  cmark_syntax_extension_set_commonmark_escape_func(self, escape);\n  CMARK_NODE_TABLE = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_ROW = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_CELL = cmark_syntax_extension_add_node(0);\n\n  return self;\n}\n\nuint16_t cmark_gfm_extensions_get_table_columns(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->n_columns;\n}\n\nuint8_t *cmark_gfm_extensions_get_table_alignments(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nint cmark_gfm_extensions_set_table_columns(cmark_node *node, uint16_t n_columns) {\n  return set_n_table_columns(node, n_columns);\n}\n\nint cmark_gfm_extensions_set_table_alignments(cmark_node *node, uint16_t ncols, uint8_t *alignments) {\n  uint8_t *a = (uint8_t *)cmark_node_mem(node)->calloc(1, ncols);\n  memcpy(a, alignments, ncols);\n  return set_table_alignments(node, a);\n}\n\nint cmark_gfm_extensions_get_table_row_is_header(cmark_node *node)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  return ((node_table_row *)node->as.opaque)->is_header;\n}\n\nint cmark_gfm_extensions_set_table_row_is_header(cmark_node *node, int is_header)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  ((node_table_row *)node->as.opaque)->is_header = (is_header != 0);\n  return 1;\n}\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport re\nimport argparse\nimport sys\nimport platform\nimport itertools\nimport multiprocessing\nfrom cmark import CMark\n\ndef hash_collisions():\n    REFMAP_SIZE = 16\n    COUNT = 50000\n\n    def badhash(ref):\n        h = 0\n        for c in ref:\n            a = (h << 6) & 0xFFFFFFFF\n            b = (h << 16) & 0xFFFFFFFF\n            h = ord(c) + a + b - h\n            h = h & 0xFFFFFFFF\n\n        return (h % REFMAP_SIZE) == 0\n\n    keys = (\"x%d\" % i for i in itertools.count())\n    collisions = itertools.islice((k for k in keys if badhash(k)), COUNT)\n    bad_key = next(collisions)\n\n    document = ''.join(\"[%s]: /url\\n\\n[%s]\\n\\n\" % (key, bad_key) for key in collisions)\n\n    return document, re.compile(\"(<p>\\[%s\\]</p>\\n){%d}\" % (bad_key, COUNT-1))\n\nallowed_failures = {\"many references\": True}\n\n# list of pairs consisting of input and a regex that must match the output.\npathological = {\n    # note - some pythons have limit of 65535 for {num-matches} in re.\n    \"nested strong emph\":\n                ((\"*a **a \" * 65000) + \"b\" + (\" a** a*\" * 65000),\n                 re.compile(\"(<em>a <strong>a ){65000}b( a</strong> a</em>){65000}\")),\n    \"many emph closers with no openers\":\n                 ((\"a_ \" * 65000),\n                  re.compile(\"(a[_] ){64999}a_\")),\n    \"many emph openers with no closers\":\n                 ((\"_a \" * 65000),\n                  re.compile(\"(_a ){64999}_a\")),\n    \"many link closers with no openers\":\n                 ((\"a]\" * 65000),\n                  re.compile(\"(a\\]){65000}\")),\n    \"many link openers with no closers\":\n                 ((\"[a\" * 65000),\n                  re.compile(\"(\\[a){65000}\")),\n    \"mismatched openers and closers\":\n                 ((\"*a_ \" * 50000),\n                  re.compile(\"([*]a[_] ){49999}[*]a_\")),\n    \"openers and closers multiple of 3\":\n                 ((\"a**b\" + (\"c* \" * 50000)),\n                  re.compile(\"a[*][*]b(c[*] ){49999}c[*]\")),\n    \"link openers and emph closers\":\n                 ((\"[ a_\" * 50000),\n                  re.compile(\"(\\[ a_){50000}\")),\n    \"pattern [ (]( repeated\":\n                 ((\"[ (](\" * 80000),\n                  re.compile(\"(\\[ \\(\\]\\(){80000}\")),\n    \"hard link/emph case\":\n                 (\"**x [a*b**c*](d)\",\n                  re.compile(\"\\\\*\\\\*x <a href=\\\"d\\\">a<em>b\\\\*\\\\*c</em></a>\")),\n    \"nested brackets\":\n                 ((\"[\" * 50000) + \"a\" + (\"]\" * 50000),\n                  re.compile(\"\\[{50000}a\\]{50000}\")),\n    \"nested block quotes\":\n                 (((\"> \" * 50000) + \"a\"),\n                  re.compile(\"(<blockquote>\\n){50000}\")),\n    \"deeply nested lists\":\n                 (\"\".join(map(lambda x: (\"  \" * x + \"* a\\n\"), range(0,1000))),\n                  re.compile(\"<ul>\\n(<li>a\\n<ul>\\n){999}<li>a</li>\\n</ul>\\n(</li>\\n</ul>\\n){999}\")),\n    \"U+0000 in input\":\n                 (\"abc\\u0000de\\u0000\",\n                  re.compile(\"abc\\ufffd?de\\ufffd?\")),\n    \"backticks\":\n                 (\"\".join(map(lambda x: (\"e\" + \"`\" * x), range(1,5000))),\n                  re.compile(\"^<p>[e`]*</p>\\n$\")),\n    \"unclosed links A\":\n                 (\"[a](<b\" * 30000,\n                  re.compile(\"(\\[a\\]\\(&lt;b){30000}\")),\n    \"unclosed links B\":\n                 (\"[a](b\" * 30000,\n                  re.compile(\"(\\[a\\]\\(b){30000}\")),\n    \"tables\":\n                 (\"aaa\\rbbb\\n-\\v\\n\" * 30000,\n                  re.compile(\"^<p>aaa</p>\\n<table>\\n<thead>\\n<tr>\\n<th>bbb</th>\\n</tr>\\n</thead>\\n<tbody>\\n(<tr>\\n<td>aaa</td>\\n</tr>\\n<tr>\\n<td>bbb</td>\\n</tr>\\n<tr>\\n<td>-\\x0b</td>\\n</tr>\\n){29999}</tbody>\\n</table>\\n$\")),\n#    \"many references\":\n#                 (\"\".join(map(lambda x: (\"[\" + str(x) + \"]: u\\n\"), range(1,5000 * 16))) + \"[0] \" * 5000,\n#                  re.compile(\"(\\[0\\] ){4999}\")),\n    \"reference collisions\": hash_collisions()\n    }\n\nwhitespace_re = re.compile('/s+/')\npassed = 0\nerrored = 0\nignored = 0\nTIMEOUT = 5\n\ndef run_test(inp, regex):\n    parser = argparse.ArgumentParser(description='Run cmark tests.')\n    parser.add_argument('--program', dest='program', nargs='?', default=None,\n            help='program to test')\n    parser.add_argument('--library-dir', dest='library_dir', nargs='?',\n            default=None, help='directory containing dynamic library')\n    args = parser.parse_args(sys.argv[1:])\n    cmark = CMark(prog=args.program, library_dir=args.library_dir, extensions=\"table\")\n\n    [rc, actual, err] = cmark.to_html(inp)\n    if rc != 0:\n        print('[ERRORED (return code %d)]' % rc)\n        print(err)\n        exit(1)\n    elif regex.search(actual):\n        print('[PASSED]')\n    else:\n        print('[FAILED (mismatch)]')\n        print(repr(actual))\n        exit(1)\n\nif __name__ == '__main__':\n    print(\"Testing pathological cases:\")\n    for description in pathological:\n        (inp, regex) = pathological[description]\n        print(description, \"... \", end='')\n        sys.stdout.flush()\n\n        p = multiprocessing.Process(target=run_test, args=(inp, regex))\n        p.start()\n        p.join(TIMEOUT)\n\n        if p.is_alive():\n            p.terminate()\n            p.join()\n            print('[TIMED OUT]')\n            if allowed_failures[description]:\n                ignored += 1\n            else:\n                errored += 1\n        elif p.exitcode != 0:\n            if allowed_failures[description]:\n                ignored += 1\n            else:\n                errored += 1\n        else:\n            passed += 1\n\n    print(\"%d passed, %d errored, %d ignored\" % (passed, errored, ignored))\n    exit(errored)\n"], "filenames": ["extensions/ext_scanners.c", "extensions/ext_scanners.re", "extensions/table.c", "test/pathological_tests.py"], "buggy_code_start_loc": [1, 0, 116, 89], "buggy_code_end_loc": [1156, 85, 263, 110], "fixing_code_start_loc": [1, 1, 117, 90], "fixing_code_end_loc": [876, 92, 281, 113], "type": "CWE-20", "message": "The table extension in GitHub Flavored Markdown before version 0.29.0.gfm.1 takes O(n * n) time to parse certain inputs. An attacker could craft a markdown table which would take an unreasonably long time to process, causing a denial of service. This issue does not affect the upstream cmark project. The issue has been fixed in version 0.29.0.gfm.1.", "other": {"cve": {"id": "CVE-2020-5238", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-01T23:15:10.443", "lastModified": "2023-01-28T01:44:36.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The table extension in GitHub Flavored Markdown before version 0.29.0.gfm.1 takes O(n * n) time to parse certain inputs. An attacker could craft a markdown table which would take an unreasonably long time to process, causing a denial of service. This issue does not affect the upstream cmark project. The issue has been fixed in version 0.29.0.gfm.1."}, {"lang": "es", "value": "La extensi\u00f3n de tabla en GitHub Flavored Markdown anterior a la versi\u00f3n 0.29.0.gfm.1 toma un tiempo O(n*n) en analizar determinadas entradas. Un atacante podr\u00eda crear una tabla de descuento que tomar\u00eda un tiempo irrazonablemente largo de procesar, causando una denegaci\u00f3n de servicio. Este problema no afecta el proyecto cmark aguas arriba. El problema se ha corregido en la versi\u00f3n 0.29.0.gfm.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:github_flavored_markdown_project:github_flavored_markdown:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.29.0.gfm.1", "matchCriteriaId": "03BEE25C-79A2-4668-8F9E-5FCB7B749E75"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/github/cmark-gfm/commit/85d895289c5ab67f988ca659493a64abb5fec7b4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/github/cmark-gfm/security/advisories/GHSA-7gc6-9qr5-hc85", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TCDHBTUFIOYRIS5HAS6PZNBNMB7IOAX3/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WMQFOQQCWOAMQ4I2XIVCVOXXIJ75HDCW/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZGJH2A4VAV54X6NSCNNGSEIGIIY5N2VR/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/github/cmark-gfm/commit/85d895289c5ab67f988ca659493a64abb5fec7b4"}}