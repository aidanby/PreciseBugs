{"buggy_code": ["/*\n *  linux/kernel/signal.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  1997-11-02  Modified for POSIX.1b signals by Richard Henderson\n *\n *  2003-06-02  Jim Houston - Concurrent Computer Corp.\n *\t\tChanges to use preallocated sigqueue structures\n *\t\tto allow signals to be sent reliably.\n */\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/tty.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/signalfd.h>\n#include <linux/ratelimit.h>\n#include <linux/tracehook.h>\n#include <linux/capability.h>\n#include <linux/freezer.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/signal.h>\n\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/siginfo.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n\n/*\n * SLAB caches for signal bits.\n */\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nint print_fatal_signals __read_mostly;\n\nstatic void __user *sig_handler(struct task_struct *t, int sig)\n{\n\treturn t->sighand->action[sig - 1].sa.sa_handler;\n}\n\nstatic int sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t\t(handler == SIG_DFL && sig_kernel_ignore(sig));\n}\n\nstatic int sig_task_ignored(struct task_struct *t, int sig,\n\t\tint from_ancestor_ns)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\thandler == SIG_DFL && !from_ancestor_ns)\n\t\treturn 1;\n\n\treturn sig_handler_ignored(handler, sig);\n}\n\nstatic int sig_ignored(struct task_struct *t, int sig, int from_ancestor_ns)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn 0;\n\n\tif (!sig_task_ignored(t, sig, from_ancestor_ns))\n\t\treturn 0;\n\n\t/*\n\t * Tracers may want to know about even ignored signals.\n\t */\n\treturn !tracehook_consider_ignored_signal(t, sig);\n}\n\n/*\n * Re-calculate pending state from the set of locally pending\n * signals, globally pending signals, and blocked signals.\n */\nstatic inline int has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}\n\n#define PENDING(p,b) has_pending_signals(&(p)->signal, (b))\n\nstatic int recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif (t->signal->group_stop_count > 0 ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn 1;\n\t}\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn 0;\n}\n\n/*\n * After recalculating TIF_SIGPENDING, we need to make sure the task wakes up.\n * This is superfluous when called on current, the wakeup is a harmless no-op.\n */\nvoid recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}\n\nvoid recalc_sigpending(void)\n{\n\tif (unlikely(tracehook_force_sigpending()))\n\t\tset_thread_flag(TIF_SIGPENDING);\n\telse if (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}\n\n/* Given the mask, find the first available signal that should be serviced. */\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE))\n\nint next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}\n\n/*\n * allocate a new signal queue record\n * - this may be called without locks if and only if t == current, otherwise an\n *   appopriate lock must be held to stop the target task from exiting\n */\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}\n\n/*\n * Flush all pending signals for a task.\n */\nvoid __flush_signals(struct task_struct *t)\n{\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n}\n\nvoid flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\t__flush_signals(t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}\n\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}\n\nvoid flush_itimer_signals(void)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\t__flush_itimer_signals(&tsk->pending);\n\t__flush_itimer_signals(&tsk->signal->shared_pending);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}\n\nvoid ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}\n\n/*\n * Flush all handlers for a task.\n */\n\nvoid\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}\n\nint unhandled_signal(struct task_struct *tsk, int sig)\n{\n\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;\n\tif (is_global_init(tsk))\n\t\treturn 1;\n\tif (handler != SIG_IGN && handler != SIG_DFL)\n\t\treturn 0;\n\treturn !tracehook_consider_fatal_signal(tsk, sig);\n}\n\n\n/* Notify the system that a driver wants to block all signals for this\n * process, and wants to be notified if any signals at all were to be\n * sent/acted upon.  If the notifier routine returns non-zero, then the\n * signal will be acted upon after all.  If the notifier routine returns 0,\n * then then signal will be blocked.  Only one block per process is\n * allowed.  priv is a pointer to private data that the notifier routine\n * can use to determine if the signal should be blocked or not.  */\n\nvoid\nblock_all_signals(int (*notifier)(void *priv), void *priv, sigset_t *mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tcurrent->notifier_mask = mask;\n\tcurrent->notifier_data = priv;\n\tcurrent->notifier = notifier;\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n}\n\n/* Notify the system that blocking has ended. */\n\nvoid\nunblock_all_signals(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tcurrent->notifier = NULL;\n\tcurrent->notifier_data = NULL;\n\trecalc_sigpending();\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n}\n\nstatic void collect_signal(int sig, struct sigpending *list, siginfo_t *info)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/* Ok, it wasn't in the queue.  This must be\n\t\t   a fast-pathed signal or we must have been\n\t\t   out of queue space.  So zero out the info.\n\t\t */\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}\n\nstatic int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tsiginfo_t *info)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig) {\n\t\tif (current->notifier) {\n\t\t\tif (sigismember(current->notifier_mask, sig)) {\n\t\t\t\tif (!(current->notifier)(current->notifier_data)) {\n\t\t\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcollect_signal(sig, pending, info);\n\t}\n\n\treturn sig;\n}\n\n/*\n * Dequeue a signal and return the element to the caller, which is \n * expected to free it.\n *\n * All callers have to hold the siglock.\n */\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)\n{\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info);\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr.tv64 != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\ttsk->signal->flags |= SIGNAL_STOP_DEQUEUED;\n\t}\n\tif ((info->si_code & __SI_MASK) == __SI_TIMER && info->si_sys_private) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tdo_schedule_next_timer(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\t}\n\treturn signr;\n}\n\n/*\n * Tell a process that it has a new active signal..\n *\n * NOTE! we rely on the previous spin_lock to\n * lock interrupts for us! We can only be called with\n * \"siglock\" held, and the local interrupt must\n * have been disabled when that got acquired!\n *\n * No need to set need_resched since signal event passing\n * goes through ->blocked\n */\nvoid signal_wake_up(struct task_struct *t, int resume)\n{\n\tunsigned int mask;\n\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\n\t/*\n\t * For SIGKILL, we want to wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tmask = TASK_INTERRUPTIBLE;\n\tif (resume)\n\t\tmask |= TASK_WAKEKILL;\n\tif (!wake_up_state(t, mask))\n\t\tkick_process(t);\n}\n\n/*\n * Remove signals in mask from the pending set and queue.\n * Returns 1 if any signals were found.\n *\n * All callers must be holding the siglock.\n *\n * This version takes a sigset mask and looks at all signals,\n * not just those in the first mask word.\n */\nstatic int rm_from_queue_full(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn 0;\n\n\tsignandsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\treturn 1;\n}\n/*\n * Remove signals in mask from the pending set and queue.\n * Returns 1 if any signals were found.\n *\n * All callers must be holding the siglock.\n */\nstatic int rm_from_queue(unsigned long mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\n\tif (!sigtestsetmask(&s->signal, mask))\n\t\treturn 0;\n\n\tsigdelsetmask(&s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (q->info.si_signo < SIGRTMIN &&\n\t\t    (mask & sigmask(q->info.si_signo))) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic inline int is_si_special(const struct siginfo *info)\n{\n\treturn info <= SEND_SIG_FORCED;\n}\n\nstatic inline bool si_fromuser(const struct siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}\n\n/*\n * Bad permissions for sending the signal\n * - the caller must hold the RCU read lock\n */\nstatic int check_kill_permission(int sig, struct siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tconst struct cred *cred, *tcred;\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tcred = current_cred();\n\ttcred = __task_cred(t);\n\tif (!same_thread_group(current, t) &&\n\t    (cred->euid ^ tcred->suid) &&\n\t    (cred->euid ^ tcred->uid) &&\n\t    (cred->uid  ^ tcred->suid) &&\n\t    (cred->uid  ^ tcred->uid) &&\n\t    !capable(CAP_KILL)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, 0);\n}\n\n/*\n * Handle magic process-wide effects of stop/continue signals. Unlike\n * the signal actions, these happen immediately at signal-generation\n * time regardless of blocking, ignoring, or handling.  This does the\n * actual continuing for SIGCONT, but not the actual stopping for stop\n * signals. The process stop is done as a signal action for SIG_DFL.\n *\n * Returns true if the signal should be actually delivered, otherwise\n * it should be dropped.\n */\nstatic int prepare_signal(int sig, struct task_struct *p, int from_ancestor_ns)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\tif (unlikely(signal->flags & SIGNAL_GROUP_EXIT)) {\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\trm_from_queue(sigmask(SIGCONT), &signal->shared_pending);\n\t\tt = p;\n\t\tdo {\n\t\t\trm_from_queue(sigmask(SIGCONT), &t->pending);\n\t\t} while_each_thread(p, t);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues,\n\t\t * and wake all threads.\n\t\t */\n\t\trm_from_queue(SIG_KERNEL_STOP_MASK, &signal->shared_pending);\n\t\tt = p;\n\t\tdo {\n\t\t\tunsigned int state;\n\t\t\trm_from_queue(SIG_KERNEL_STOP_MASK, &t->pending);\n\t\t\t/*\n\t\t\t * If there is a handler for SIGCONT, we must make\n\t\t\t * sure that no thread returns to user mode before\n\t\t\t * we post the signal, in case it was the only\n\t\t\t * thread eligible to run the signal handler--then\n\t\t\t * it must not do anything between resuming and\n\t\t\t * running the handler.  With the TIF_SIGPENDING\n\t\t\t * flag set, the thread will pause and acquire the\n\t\t\t * siglock that we hold now and until we've queued\n\t\t\t * the pending signal.\n\t\t\t *\n\t\t\t * Wake up the stopped thread _after_ setting\n\t\t\t * TIF_SIGPENDING\n\t\t\t */\n\t\t\tstate = __TASK_STOPPED;\n\t\t\tif (sig_user_defined(t, SIGCONT) && !sigismember(&t->blocked, SIGCONT)) {\n\t\t\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\t\t\tstate |= TASK_INTERRUPTIBLE;\n\t\t\t}\n\t\t\twake_up_state(t, state);\n\t\t} while_each_thread(p, t);\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal_to_deliver().\n\t\t\t */\n\t\t\tsignal->flags = why | SIGNAL_STOP_CONTINUED;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We are not stopped, but there could be a stop\n\t\t\t * signal in the middle of being processed after\n\t\t\t * being removed from the queue.  Clear that too.\n\t\t\t */\n\t\t\tsignal->flags &= ~SIGNAL_STOP_DEQUEUED;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, from_ancestor_ns);\n}\n\n/*\n * Test if P wants to take SIG.  After we've checked all threads with this,\n * it's equivalent to finding no threads not blocking SIG.  Any threads not\n * blocking SIG were ruled out because they are not running and already\n * have pending signals.  Such threads will dequeue from the shared queue\n * as soon as they're available, so putting the signal on the shared queue\n * will be equivalent to sending it to one such thread.\n */\nstatic inline int wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn 0;\n\tif (p->flags & PF_EXITING)\n\t\treturn 0;\n\tif (sig == SIGKILL)\n\t\treturn 1;\n\tif (task_is_stopped_or_traced(p))\n\t\treturn 0;\n\treturn task_curr(p) || !signal_pending(p);\n}\n\nstatic void complete_signal(int sig, struct task_struct *p, int group)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if (!group || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL ||\n\t     !tracehook_consider_fatal_signal(t, sig))) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}\n\nstatic inline int legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}\n\nstatic int __send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\n\ttrace_signal_generate(sig, info, t);\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tif (!prepare_signal(sig, t, from_ancestor_ns))\n\t\treturn 0;\n\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tif (legacy_queue(pending, sig))\n\t\treturn 0;\n\t/*\n\t * fast-pathed signals for kernel-internal things like SIGSTOP\n\t * or SIGKILL.\n\t */\n\tif (info == SEND_SIG_FORCED)\n\t\tgoto out_set;\n\n\t/* Real-time signals must be queued if sent by sigqueue, or\n\t   some other real-time mechanism.  It is implementation\n\t   defined whether kill() does so.  We attempt to do so, on\n\t   the principle of least surprise, but since kill is not\n\t   allowed to fail with EAGAIN when low on memory we just\n\t   make sure at least one signal gets delivered and don't\n\t   pass on the info struct.  */\n\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n\t\toverride_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = current_uid();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\ttrace_signal_overflow_fail(sig, group, info);\n\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\ttrace_signal_lose_info(sig, group, info);\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\n\treturn 0;\n}\n\nstatic int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, group, from_ancestor_ns);\n}\n\nstatic void print_fatal_signal(struct pt_regs *regs, int signr)\n{\n\tprintk(\"%s/%d: potentially unexpected fatal signal %d.\\n\",\n\t\tcurrent->comm, task_pid_nr(current), signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n\tprintk(\"code at %08lx: \", regs->ip);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->ip + i)))\n\t\t\t\tbreak;\n\t\t\tprintk(\"%02x \", insn);\n\t\t}\n\t}\n#endif\n\tprintk(\"\\n\");\n\tpreempt_disable();\n\tshow_regs(regs);\n\tpreempt_enable();\n}\n\nstatic int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}\n\n__setup(\"print-fatal-signals=\", setup_print_fatal_signals);\n\nint\n__group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, 1);\n}\n\nstatic int\nspecific_send_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\treturn send_signal(sig, info, t, 0);\n}\n\nint do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,\n\t\t\tbool group)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, group);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Force a signal that the process can't ignore: if necessary\n * we unblock the signal and change any SIG_IGN to SIG_DFL.\n *\n * Note: If we unblock the signal, we always reset it to SIG_DFL,\n * since we do not want to have a signal handler that was blocked\n * be invoked when user space had explicitly blocked it.\n *\n * We don't want to have recursive SIGSEGV's etc, for example,\n * that is why we also clear SIGNAL_UNKILLABLE.\n */\nint\nforce_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\tif (action->sa.sa_handler == SIG_DFL)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = specific_send_sig_info(sig, info, t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}\n\n/*\n * Nuke all other threads in the group.\n */\nint zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}\n\n/*\n * send signal info to all the members of a group\n */\nint group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, true);\n\n\treturn ret;\n}\n\n/*\n * __kill_pgrp_info() sends a signal to a process group: this is what the tty\n * control characters do (^C, ^Z etc)\n * - the caller must hold at least a readlock on tasklist_lock\n */\nint __kill_pgrp_info(int sig, struct siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}\n\nint kill_pid_info(int sig, struct siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\trcu_read_lock();\nretry:\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (p) {\n\t\terror = group_send_sig_info(sig, info, p);\n\t\tif (unlikely(error == -ESRCH))\n\t\t\t/*\n\t\t\t * The task was unhashed in between, try again.\n\t\t\t * If it is dead, pid_task() will return NULL,\n\t\t\t * if we race with de_thread() it will find the\n\t\t\t * new leader.\n\t\t\t */\n\t\t\tgoto retry;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nint\nkill_proc_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}\n\n/* like kill_pid_info(), but doesn't use uid/euid of \"current\" */\nint kill_pid_info_as_uid(int sig, struct siginfo *info, struct pid *pid,\n\t\t      uid_t uid, uid_t euid, u32 secid)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tconst struct cred *pcred;\n\tunsigned long flags;\n\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\n\trcu_read_lock();\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tpcred = __task_cred(p);\n\tif (si_fromuser(info) &&\n\t    euid != pcred->suid && euid != pcred->uid &&\n\t    uid  != pcred->suid && uid  != pcred->uid) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, secid);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (sig) {\n\t\tif (lock_task_sighand(p, &flags)) {\n\t\t\tret = __send_signal(sig, info, p, 1, 0);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kill_pid_info_as_uid);\n\n/*\n * kill_something_info() interprets pid in interesting ways just like kill(2).\n *\n * POSIX specifies that kill(-1,sig) is unspecified, but what we have\n * is probably wrong.  Should make it like BSD or SYSV.\n */\n\nstatic int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\n\n/*\n * These are for backward compatibility with the rest of the kernel source.\n */\n\nint\nsend_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, false);\n}\n\n#define __si_special(priv) \\\n\t((priv) ? SEND_SIG_PRIV : SEND_SIG_NOINFO)\n\nint\nsend_sig(int sig, struct task_struct *p, int priv)\n{\n\treturn send_sig_info(sig, __si_special(priv), p);\n}\n\nvoid\nforce_sig(int sig, struct task_struct *p)\n{\n\tforce_sig_info(sig, SEND_SIG_PRIV, p);\n}\n\n/*\n * When things go south during signal handling, we\n * will force a SIGSEGV. And if the signal that caused\n * the problem was already a SIGSEGV, we'll want to\n * make sure we don't even try to deliver the signal..\n */\nint\nforce_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n\treturn 0;\n}\n\nint kill_pgrp(struct pid *pid, int sig, int priv)\n{\n\tint ret;\n\n\tread_lock(&tasklist_lock);\n\tret = __kill_pgrp_info(sig, __si_special(priv), pid);\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(kill_pgrp);\n\nint kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}\nEXPORT_SYMBOL(kill_pid);\n\n/*\n * These functions support sending signals using preallocated sigqueue\n * structures.  This is needed \"because realtime applications cannot\n * afford to lose notifications of asynchronous events, like timer\n * expirations or I/O completions\".  In the case of Posix Timers\n * we allocate the sigqueue structure from the timer_create.  If this\n * allocation fails we are able to report the failure to the application\n * with an EAGAIN error.\n */\nstruct sigqueue *sigqueue_alloc(void)\n{\n\tstruct sigqueue *q = __sigqueue_alloc(-1, current, GFP_KERNEL, 0);\n\n\tif (q)\n\t\tq->flags |= SIGQUEUE_PREALLOC;\n\n\treturn q;\n}\n\nvoid sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}\n\nint send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tif (!prepare_signal(sig, t, 0))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nout:\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}\n\n/*\n * Let a parent know about the death of a child.\n * For a stopped/continued status change, use do_notify_parent_cldstop instead.\n *\n * Returns -1 if our parent ignored us and so we've switched to\n * self-reaping, or else @sig.\n */\nint do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tint ret = sig;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!task_ptrace(tsk) &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * we are under tasklist_lock here so our parent is tied to\n\t * us and cannot exit and release its namespace.\n\t *\n\t * the only it can is to switch its nsproxy with sys_unshare,\n\t * bu uncharing pid namespaces is not allowed, so we'll always\n\t * see relevant namespace\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, tsk->parent->nsproxy->pid_ns);\n\tinfo.si_uid = __task_cred(tsk)->uid;\n\trcu_read_unlock();\n\n\tinfo.si_utime = cputime_to_clock_t(cputime_add(tsk->utime,\n\t\t\t\ttsk->signal->utime));\n\tinfo.si_stime = cputime_to_clock_t(cputime_add(tsk->stime,\n\t\t\t\ttsk->signal->stime));\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!task_ptrace(tsk) && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tret = tsk->exit_signal = -1;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = -1;\n\t}\n\tif (valid_signal(sig) && sig > 0)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn ret;\n}\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk, int why)\n{\n\tstruct siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\n\tif (task_ptrace(tsk))\n\t\tparent = tsk->parent;\n\telse {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() abot the following 3 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, parent->nsproxy->pid_ns);\n\tinfo.si_uid = __task_cred(tsk)->uid;\n\trcu_read_unlock();\n\n\tinfo.si_utime = cputime_to_clock_t(tsk->utime);\n\tinfo.si_stime = cputime_to_clock_t(tsk->stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}\n\nstatic inline int may_ptrace_stop(void)\n{\n\tif (!likely(task_ptrace(current)))\n\t\treturn 0;\n\t/*\n\t * Are we in the middle of do_coredump?\n\t * If so and our tracer is also part of the coredump stopping\n\t * is a deadlock situation, and pointless because our tracer\n\t * is dead so don't allow us to stop.\n\t * If SIGKILL was already sent before the caller unlocked\n\t * ->siglock we must see ->core_state != NULL. Otherwise it\n\t * is safe to enter schedule().\n\t */\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n * Return nonzero if there is a SIGKILL that should be waking us up.\n * Called with the siglock held.\n */\nstatic int sigkill_pending(struct task_struct *tsk)\n{\n\treturn\tsigismember(&tsk->pending.signal, SIGKILL) ||\n\t\tsigismember(&tsk->signal->shared_pending.signal, SIGKILL);\n}\n\n/*\n * This must be called with current->sighand->siglock held.\n *\n * This should be the path for all ptrace stops.\n * We always set current->last_siginfo while stopped here.\n * That makes it a way to test a stopped process for\n * being ptrace-stopped vs being job-control-stopped.\n *\n * If we actually decide not to stop at all because the tracer\n * is gone, we keep current->exit_code unless clear_code.\n */\nstatic void ptrace_stop(int exit_code, int clear_code, siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If there is a group stop in progress,\n\t * we must participate in the bookkeeping.\n\t */\n\tif (current->signal->group_stop_count > 0)\n\t\t--current->signal->group_stop_count;\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/* Let the debugger run.  */\n\t__set_current_state(TASK_TRACED);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\tdo_notify_parent_cldstop(current, CLD_TRAPPED);\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tschedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * While in TASK_TRACED, we were considered \"frozen enough\".\n\t * Now that we woke up, it's crucial if we're supposed to be\n\t * frozen that we freeze now before running anything substantial.\n\t */\n\ttry_to_freeze();\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}\n\nvoid ptrace_notify(int exit_code)\n{\n\tsiginfo_t info;\n\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\n\tmemset(&info, 0, sizeof info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\t/* Let the debugger run.  */\n\tspin_lock_irq(&current->sighand->siglock);\n\tptrace_stop(exit_code, 1, &info);\n\tspin_unlock_irq(&current->sighand->siglock);\n}\n\n/*\n * This performs the stopping for SIGSTOP and other stop signals.\n * We have to stop all threads in the thread group.\n * Returns nonzero if we've actually stopped and released the siglock.\n * Returns zero if we didn't stop and still hold the siglock.\n */\nstatic int do_signal_stop(int signr)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint notify;\n\n\tif (!sig->group_stop_count) {\n\t\tstruct task_struct *t;\n\n\t\tif (!likely(sig->flags & SIGNAL_STOP_DEQUEUED) ||\n\t\t    unlikely(signal_group_exit(sig)))\n\t\t\treturn 0;\n\t\t/*\n\t\t * There is no group stop already in progress.\n\t\t * We must initiate one now.\n\t\t */\n\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 1;\n\t\tfor (t = next_thread(current); t != current; t = next_thread(t))\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!(t->flags & PF_EXITING) &&\n\t\t\t    !task_is_stopped_or_traced(t)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t}\n\t}\n\t/*\n\t * If there are no other threads in the group, or if there is\n\t * a group stop in progress and we are the last to stop, report\n\t * to the parent.  When ptraced, every thread reports itself.\n\t */\n\tnotify = sig->group_stop_count == 1 ? CLD_STOPPED : 0;\n\tnotify = tracehook_notify_jctl(notify, CLD_STOPPED);\n\t/*\n\t * tracehook_notify_jctl() can drop and reacquire siglock, so\n\t * we keep ->group_stop_count != 0 before the call. If SIGCONT\n\t * or SIGKILL comes in between ->group_stop_count == 0.\n\t */\n\tif (sig->group_stop_count) {\n\t\tif (!--sig->group_stop_count)\n\t\t\tsig->flags = SIGNAL_STOP_STOPPED;\n\t\tcurrent->exit_code = sig->group_exit_code;\n\t\t__set_current_state(TASK_STOPPED);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (notify) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, notify);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\tdo {\n\t\tschedule();\n\t} while (try_to_freeze());\n\n\ttracehook_finish_jctl();\n\tcurrent->exit_code = 0;\n\n\treturn 1;\n}\n\nstatic int ptrace_signal(int signr, siginfo_t *info,\n\t\t\t struct pt_regs *regs, void *cookie)\n{\n\tif (!task_ptrace(current))\n\t\treturn signr;\n\n\tptrace_signal_deliver(regs, cookie);\n\n\t/* Let the debugger run.  */\n\tptrace_stop(signr, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\n\tcurrent->exit_code = 0;\n\n\t/* Update the siginfo structure if the signal has\n\t   changed.  If the debugger wanted something\n\t   specific in the siginfo structure then it should\n\t   have updated *info via PTRACE_SETSIGINFO.  */\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = task_uid(current->parent);\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}\n\nint get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,\n\t\t\t  struct pt_regs *regs, void *cookie)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\nrelock:\n\t/*\n\t * We'll jump back here after any time we were stopped in TASK_STOPPED.\n\t * While in TASK_STOPPED, we were considered \"frozen enough\".\n\t * Now that we woke up, it's crucial if we're supposed to be\n\t * frozen that we freeze now before running anything substantial.\n\t */\n\ttry_to_freeze();\n\n\tspin_lock_irq(&sighand->siglock);\n\t/*\n\t * Every stopped thread goes here after wakeup. Check to see if\n\t * we should notify the parent, prepare_signal(SIGCONT) encodes\n\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.\n\t */\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why = (signal->flags & SIGNAL_STOP_CONTINUED)\n\t\t\t\t? CLD_CONTINUED : CLD_STOPPED;\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\n\t\twhy = tracehook_notify_jctl(why, CLD_CONTINUED);\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\tif (why) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current->group_leader, why);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t\tgoto relock;\n\t}\n\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\t\t/*\n\t\t * Tracing can induce an artifical signal and choose sigaction.\n\t\t * The return value in @signr determines the default action,\n\t\t * but @info->si_signo is the signal number we will report.\n\t\t */\n\t\tsignr = tracehook_get_signal(current, regs, info, return_ka);\n\t\tif (unlikely(signr < 0))\n\t\t\tgoto relock;\n\t\tif (unlikely(signr != 0))\n\t\t\tka = return_ka;\n\t\telse {\n\t\t\tif (unlikely(signal->group_stop_count > 0) &&\n\t\t\t    do_signal_stop(0))\n\t\t\t\tgoto relock;\n\n\t\t\tsignr = dequeue_signal(current, &current->blocked,\n\t\t\t\t\t       info);\n\n\t\t\tif (!signr)\n\t\t\t\tbreak; /* will return 0 */\n\n\t\t\tif (signr != SIGKILL) {\n\t\t\t\tsignr = ptrace_signal(signr, info,\n\t\t\t\t\t\t      regs, cookie);\n\t\t\t\tif (!signr)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tka = &sighand->action[signr-1];\n\t\t}\n\n\t\t/* Trace actually delivered signals. */\n\t\ttrace_signal_deliver(signr, info, ka);\n\n\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */\n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\t/* Run the handler.  */\n\t\t\t*return_ka = *ka;\n\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\n\t\t\tbreak; /* will return non-zero \"signr\" value */\n\t\t}\n\n\t\t/*\n\t\t * Now we are doing the default action for this signal.\n\t\t */\n\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Global init gets no signals it doesn't want.\n\t\t * Container-init gets no signals it doesn't want from same\n\t\t * container.\n\t\t *\n\t\t * Note that if global/container-init sees a sig_kernel_only()\n\t\t * signal here, the signal must have been generated internally\n\t\t * or must have come from an ancestor namespace. In either\n\t\t * case, the signal cannot be dropped.\n\t\t */\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\t/*\n\t\t\t * The default action is to stop all threads in\n\t\t\t * the thread group.  The job control signals\n\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP\n\t\t\t * always works.  Note that siglock needs to be\n\t\t\t * dropped during the call to is_orphaned_pgrp()\n\t\t\t * because of lock ordering with tasklist_lock.\n\t\t\t * This allows an intervening SIGCONT to be posted.\n\t\t\t * We need to check for that and bail out if necessary.\n\t\t\t */\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t\t\t/* signals can be posted during this window */\n\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\n\t\t\tif (likely(do_signal_stop(info->si_signo))) {\n\t\t\t\t/* It released the siglock.  */\n\t\t\t\tgoto relock;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We didn't actually stop, due to a race\n\t\t\t * with SIGCONT or something like that.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Anything else is fatal, maybe with a core dump.\n\t\t */\n\t\tcurrent->flags |= PF_SIGNALED;\n\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(regs, info->si_signo);\n\t\t\t/*\n\t\t\t * If it was able to dump core, this kills all\n\t\t\t * other threads in the group and synchronizes with\n\t\t\t * their demise.  If we lost the race with another\n\t\t\t * thread getting here, it set group_exit_code\n\t\t\t * first and our do_group_exit call below will use\n\t\t\t * that value and ignore the one we pass it.\n\t\t\t */\n\t\t\tdo_coredump(info->si_signo, info->si_signo, regs);\n\t\t}\n\n\t\t/*\n\t\t * Death signals, no core dump.\n\t\t */\n\t\tdo_group_exit(info->si_signo);\n\t\t/* NOTREACHED */\n\t}\n\tspin_unlock_irq(&sighand->siglock);\n\treturn signr;\n}\n\nvoid exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tstruct task_struct *t;\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\t/* It could be that __group_complete_signal() choose us to\n\t * notify about group-wide signal. Another thread should be\n\t * woken now to take the signal since we will not.\n\t */\n\tfor (t = tsk; (t = next_thread(t)) != tsk; )\n\t\tif (!signal_pending(t) && !(t->flags & PF_EXITING))\n\t\t\trecalc_sigpending_and_wake(t);\n\n\tif (unlikely(tsk->signal->group_stop_count) &&\n\t\t\t!--tsk->signal->group_stop_count) {\n\t\ttsk->signal->flags = SIGNAL_STOP_STOPPED;\n\t\tgroup_stop = tracehook_notify_jctl(CLD_STOPPED, CLD_STOPPED);\n\t}\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\n\nEXPORT_SYMBOL(recalc_sigpending);\nEXPORT_SYMBOL_GPL(dequeue_signal);\nEXPORT_SYMBOL(flush_signals);\nEXPORT_SYMBOL(force_sig);\nEXPORT_SYMBOL(send_sig);\nEXPORT_SYMBOL(send_sig_info);\nEXPORT_SYMBOL(sigprocmask);\nEXPORT_SYMBOL(block_all_signals);\nEXPORT_SYMBOL(unblock_all_signals);\n\n\n/*\n * System call entry points.\n */\n\nSYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current_thread_info()->restart_block;\n\treturn restart->fn(restart);\n}\n\nlong do_no_restart_syscall(struct restart_block *param)\n{\n\treturn -EINTR;\n}\n\n/*\n * We don't need to get the kernel lock - this is all local to this\n * particular thread.. (and that's good, because this is _heavily_\n * used by various programs)\n */\n\n/*\n * This is also useful for kernel threads that want to temporarily\n * (or permanently) block certain signals.\n *\n * NOTE! Unlike the user-mode sys_sigprocmask(), the kernel\n * interface happily blocks \"unblockable\" signals like SIGKILL\n * and friends.\n */\nint sigprocmask(int how, sigset_t *set, sigset_t *oldset)\n{\n\tint error;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (oldset)\n\t\t*oldset = current->blocked;\n\n\terror = 0;\n\tswitch (how) {\n\tcase SIG_BLOCK:\n\t\tsigorsets(&current->blocked, &current->blocked, set);\n\t\tbreak;\n\tcase SIG_UNBLOCK:\n\t\tsignandsets(&current->blocked, &current->blocked, set);\n\t\tbreak;\n\tcase SIG_SETMASK:\n\t\tcurrent->blocked = *set;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, set,\n\t\tsigset_t __user *, oset, size_t, sigsetsize)\n{\n\tint error = -EINVAL;\n\tsigset_t old_set, new_set;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\tgoto out;\n\n\tif (set) {\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&new_set, set, sizeof(*set)))\n\t\t\tgoto out;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, &old_set);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (oset)\n\t\t\tgoto set_old;\n\t} else if (oset) {\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\told_set = current->blocked;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\tset_old:\n\t\terror = -EFAULT;\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\tgoto out;\n\t}\n\terror = 0;\nout:\n\treturn error;\n}\n\nlong do_sigpending(void __user *set, unsigned long sigsetsize)\n{\n\tlong error = -EINVAL;\n\tsigset_t pending;\n\n\tif (sigsetsize > sizeof(sigset_t))\n\t\tgoto out;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigorsets(&pending, &current->pending.signal,\n\t\t  &current->signal->shared_pending.signal);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Outside the lock because only this thread touches it.  */\n\tsigandsets(&pending, &current->blocked, &pending);\n\n\terror = -EFAULT;\n\tif (!copy_to_user(set, &pending, sigsetsize))\n\t\terror = 0;\n\nout:\n\treturn error;\n}\t\n\nSYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, set, size_t, sigsetsize)\n{\n\treturn do_sigpending(set, sigsetsize);\n}\n\n#ifndef HAVE_ARCH_COPY_SIGINFO_TO_USER\n\nint copy_siginfo_to_user(siginfo_t __user *to, siginfo_t *from)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, to, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (from->si_code < 0)\n\t\treturn __copy_to_user(to, from, sizeof(siginfo_t))\n\t\t\t? -EFAULT : 0;\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * Please remember to update the signalfd_copyinfo() function\n\t * inside fs/signalfd.c too, in case siginfo_t changes.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t */\n\terr = __put_user(from->si_signo, &to->si_signo);\n\terr |= __put_user(from->si_errno, &to->si_errno);\n\terr |= __put_user((short)from->si_code, &to->si_code);\n\tswitch (from->si_code & __SI_MASK) {\n\tcase __SI_KILL:\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\tbreak;\n\tcase __SI_TIMER:\n\t\t err |= __put_user(from->si_tid, &to->si_tid);\n\t\t err |= __put_user(from->si_overrun, &to->si_overrun);\n\t\t err |= __put_user(from->si_ptr, &to->si_ptr);\n\t\tbreak;\n\tcase __SI_POLL:\n\t\terr |= __put_user(from->si_band, &to->si_band);\n\t\terr |= __put_user(from->si_fd, &to->si_fd);\n\t\tbreak;\n\tcase __SI_FAULT:\n\t\terr |= __put_user(from->si_addr, &to->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\terr |= __put_user(from->si_trapno, &to->si_trapno);\n#endif\n#ifdef BUS_MCEERR_AO\n\t\t/* \n\t\t * Other callers might not initialize the si_lsb field,\n\t \t * so check explicitely for the right codes here.\n\t\t */\n\t\tif (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO)\n\t\t\terr |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);\n#endif\n\t\tbreak;\n\tcase __SI_CHLD:\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\terr |= __put_user(from->si_status, &to->si_status);\n\t\terr |= __put_user(from->si_utime, &to->si_utime);\n\t\terr |= __put_user(from->si_stime, &to->si_stime);\n\t\tbreak;\n\tcase __SI_RT: /* This is not generated by the kernel as of now. */\n\tcase __SI_MESGQ: /* But this is */\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\terr |= __put_user(from->si_ptr, &to->si_ptr);\n\t\tbreak;\n\tdefault: /* this is just in case for now ... */\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#endif\n\nSYSCALL_DEFINE4(rt_sigtimedwait, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo, const struct timespec __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tint ret, sig;\n\tsigset_t these;\n\tstruct timespec ts;\n\tsiginfo_t info;\n\tlong timeout = 0;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\t\t\n\t/*\n\t * Invert the set of allowed signals to get those we\n\t * want to block.\n\t */\n\tsigdelsetmask(&these, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\tsignotset(&these);\n\n\tif (uts) {\n\t\tif (copy_from_user(&ts, uts, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\tif (ts.tv_nsec >= 1000000000L || ts.tv_nsec < 0\n\t\t    || ts.tv_sec < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsig = dequeue_signal(current, &these, &info);\n\tif (!sig) {\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (uts)\n\t\t\ttimeout = (timespec_to_jiffies(&ts)\n\t\t\t\t   + (ts.tv_sec || ts.tv_nsec));\n\n\t\tif (timeout) {\n\t\t\t/* None ready -- temporarily unblock those we're\n\t\t\t * interested while we are sleeping in so that we'll\n\t\t\t * be awakened when they arrive.  */\n\t\t\tcurrent->real_blocked = current->blocked;\n\t\t\tsigandsets(&current->blocked, &current->blocked, &these);\n\t\t\trecalc_sigpending();\n\t\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t\ttimeout = schedule_timeout_interruptible(timeout);\n\n\t\t\tspin_lock_irq(&current->sighand->siglock);\n\t\t\tsig = dequeue_signal(current, &these, &info);\n\t\t\tcurrent->blocked = current->real_blocked;\n\t\t\tsiginitset(&current->real_blocked, 0);\n\t\t\trecalc_sigpending();\n\t\t}\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (sig) {\n\t\tret = sig;\n\t\tif (uinfo) {\n\t\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t} else {\n\t\tret = -EAGAIN;\n\t\tif (timeout)\n\t\t\tret = -EINTR;\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\treturn kill_something_info(sig, &info, pid);\n}\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, false);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nstatic int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}\n\n/**\n *  sys_tgkill - send signal to one specific thread\n *  @tgid: the thread group ID of the thread\n *  @pid: the PID of the thread\n *  @sig: signal to be sent\n *\n *  This syscall also checks the @tgid and returns -ESRCH even if the PID\n *  exists but it's not belonging to the target process anymore. This\n *  method solves the problem of threads exiting and PIDs getting reused.\n */\nSYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(tgid, pid, sig);\n}\n\n/*\n *  Send a signal to only one task, even if it's a CLONE_THREAD task.\n */\nSYSCALL_DEFINE2(tkill, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(0, pid, sig);\n}\n\nSYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t   Nor can they impersonate a kill(), which adds source info.  */\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}\n\nlong do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t   Nor can they impersonate a kill(), which adds source info.  */\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}\n\nSYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}\n\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tstruct task_struct *t = current;\n\tstruct k_sigaction *k;\n\tsigset_t mask;\n\n\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n\t\treturn -EINVAL;\n\n\tk = &t->sighand->action[sig-1];\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (oact)\n\t\t*oact = *k;\n\n\tif (act) {\n\t\tsigdelsetmask(&act->sa.sa_mask,\n\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\t*k = *act;\n\t\t/*\n\t\t * POSIX 3.3.1.3:\n\t\t *  \"Setting a signal action to SIG_IGN for a signal that is\n\t\t *   pending shall cause the pending signal to be discarded,\n\t\t *   whether or not it is blocked.\"\n\t\t *\n\t\t *  \"Setting a signal action to SIG_DFL for a signal that is\n\t\t *   pending and whose default action is to ignore the signal\n\t\t *   (for example, SIGCHLD), shall cause the pending signal to\n\t\t *   be discarded, whether or not it is blocked\"\n\t\t */\n\t\tif (sig_handler_ignored(sig_handler(t, sig), sig)) {\n\t\t\tsigemptyset(&mask);\n\t\t\tsigaddset(&mask, sig);\n\t\t\trm_from_queue_full(&mask, &t->signal->shared_pending);\n\t\t\tdo {\n\t\t\t\trm_from_queue_full(&mask, &t->pending);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != current);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn 0;\n}\n\nint \ndo_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)\n{\n\tstack_t oss;\n\tint error;\n\n\toss.ss_sp = (void __user *) current->sas_ss_sp;\n\toss.ss_size = current->sas_ss_size;\n\toss.ss_flags = sas_ss_flags(sp);\n\n\tif (uss) {\n\t\tvoid __user *ss_sp;\n\t\tsize_t ss_size;\n\t\tint ss_flags;\n\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, uss, sizeof(*uss)))\n\t\t\tgoto out;\n\t\terror = __get_user(ss_sp, &uss->ss_sp) |\n\t\t\t__get_user(ss_flags, &uss->ss_flags) |\n\t\t\t__get_user(ss_size, &uss->ss_size);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = -EPERM;\n\t\tif (on_sig_stack(sp))\n\t\t\tgoto out;\n\n\t\terror = -EINVAL;\n\t\t/*\n\t\t *\n\t\t * Note - this code used to test ss_flags incorrectly\n\t\t *  \t  old code may have been written using ss_flags==0\n\t\t *\t  to mean ss_flags==SS_ONSTACK (as this was the only\n\t\t *\t  way that worked) - this fix preserves that older\n\t\t *\t  mechanism\n\t\t */\n\t\tif (ss_flags != SS_DISABLE && ss_flags != SS_ONSTACK && ss_flags != 0)\n\t\t\tgoto out;\n\n\t\tif (ss_flags == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\terror = -ENOMEM;\n\t\t\tif (ss_size < MINSIGSTKSZ)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcurrent->sas_ss_sp = (unsigned long) ss_sp;\n\t\tcurrent->sas_ss_size = ss_size;\n\t}\n\n\terror = 0;\n\tif (uoss) {\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_WRITE, uoss, sizeof(*uoss)))\n\t\t\tgoto out;\n\t\terror = __put_user(oss.ss_sp, &uoss->ss_sp) |\n\t\t\t__put_user(oss.ss_size, &uoss->ss_size) |\n\t\t\t__put_user(oss.ss_flags, &uoss->ss_flags);\n\t}\n\nout:\n\treturn error;\n}\n\n#ifdef __ARCH_WANT_SYS_SIGPENDING\n\nSYSCALL_DEFINE1(sigpending, old_sigset_t __user *, set)\n{\n\treturn do_sigpending(set, sizeof(*set));\n}\n\n#endif\n\n#ifdef __ARCH_WANT_SYS_SIGPROCMASK\n/* Some platforms have their own version with special arguments others\n   support only sys_rt_sigprocmask.  */\n\nSYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, set,\n\t\told_sigset_t __user *, oset)\n{\n\tint error;\n\told_sigset_t old_set, new_set;\n\n\tif (set) {\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&new_set, set, sizeof(*set)))\n\t\t\tgoto out;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\told_set = current->blocked.sig[0];\n\n\t\terror = 0;\n\t\tswitch (how) {\n\t\tdefault:\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&current->blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&current->blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcurrent->blocked.sig[0] = new_set;\n\t\t\tbreak;\n\t\t}\n\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (oset)\n\t\t\tgoto set_old;\n\t} else if (oset) {\n\t\told_set = current->blocked.sig[0];\n\tset_old:\n\t\terror = -EFAULT;\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\tgoto out;\n\t}\n\terror = 0;\nout:\n\treturn error;\n}\n#endif /* __ARCH_WANT_SYS_SIGPROCMASK */\n\n#ifdef __ARCH_WANT_SYS_RT_SIGACTION\nSYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct sigaction __user *, act,\n\t\tstruct sigaction __user *, oact,\n\t\tsize_t, sigsetsize)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret = -EINVAL;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\tgoto out;\n\n\tif (act) {\n\t\tif (copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\n\n\tif (!ret && oact) {\n\t\tif (copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa)))\n\t\t\treturn -EFAULT;\n\t}\nout:\n\treturn ret;\n}\n#endif /* __ARCH_WANT_SYS_RT_SIGACTION */\n\n#ifdef __ARCH_WANT_SYS_SGETMASK\n\n/*\n * For backwards compatibility.  Functionality superseded by sigprocmask.\n */\nSYSCALL_DEFINE0(sgetmask)\n{\n\t/* SMP safe */\n\treturn current->blocked.sig[0];\n}\n\nSYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\told = current->blocked.sig[0];\n\n\tsiginitset(&current->blocked, newmask & ~(sigmask(SIGKILL)|\n\t\t\t\t\t\t  sigmask(SIGSTOP)));\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn old;\n}\n#endif /* __ARCH_WANT_SGETMASK */\n\n#ifdef __ARCH_WANT_SYS_SIGNAL\n/*\n * For backwards compatibility.  Functionality superseded by sigaction.\n */\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\tnew_sa.sa.sa_handler = handler;\n\tnew_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n\tsigemptyset(&new_sa.sa.sa_mask);\n\n\tret = do_sigaction(sig, &new_sa, &old_sa);\n\n\treturn ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}\n#endif /* __ARCH_WANT_SYS_SIGNAL */\n\n#ifdef __ARCH_WANT_SYS_PAUSE\n\nSYSCALL_DEFINE0(pause)\n{\n\tcurrent->state = TASK_INTERRUPTIBLE;\n\tschedule();\n\treturn -ERESTARTNOHAND;\n}\n\n#endif\n\n#ifdef __ARCH_WANT_SYS_RT_SIGSUSPEND\nSYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset, unewset, sizeof(newset)))\n\t\treturn -EFAULT;\n\tsigdelsetmask(&newset, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->saved_sigmask = current->blocked;\n\tcurrent->blocked = newset;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tcurrent->state = TASK_INTERRUPTIBLE;\n\tschedule();\n\tset_restore_sigmask();\n\treturn -ERESTARTNOHAND;\n}\n#endif /* __ARCH_WANT_SYS_RT_SIGSUSPEND */\n\n__attribute__((weak)) const char *arch_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}\n\nvoid __init signals_init(void)\n{\n\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC);\n}\n\n#ifdef CONFIG_KGDB_KDB\n#include <linux/kdb.h>\n/*\n * kdb_send_sig_info - Allows kdb to send signals without exposing\n * signal internals.  This function checks if the required locks are\n * available before calling the main signal code, to avoid kdb\n * deadlocks.\n */\nvoid\nkdb_send_sig_info(struct task_struct *t, struct siginfo *info)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint sig, new_t;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tspin_unlock(&t->sighand->siglock);\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (t->state != TASK_RUNNING && new_t) {\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tsig = info->si_signo;\n\tif (send_sig_info(sig, info, t))\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}\n#endif\t/* CONFIG_KGDB_KDB */\n"], "fixing_code": ["/*\n *  linux/kernel/signal.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  1997-11-02  Modified for POSIX.1b signals by Richard Henderson\n *\n *  2003-06-02  Jim Houston - Concurrent Computer Corp.\n *\t\tChanges to use preallocated sigqueue structures\n *\t\tto allow signals to be sent reliably.\n */\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/tty.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/signalfd.h>\n#include <linux/ratelimit.h>\n#include <linux/tracehook.h>\n#include <linux/capability.h>\n#include <linux/freezer.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/signal.h>\n\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/siginfo.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n\n/*\n * SLAB caches for signal bits.\n */\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nint print_fatal_signals __read_mostly;\n\nstatic void __user *sig_handler(struct task_struct *t, int sig)\n{\n\treturn t->sighand->action[sig - 1].sa.sa_handler;\n}\n\nstatic int sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t\t(handler == SIG_DFL && sig_kernel_ignore(sig));\n}\n\nstatic int sig_task_ignored(struct task_struct *t, int sig,\n\t\tint from_ancestor_ns)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\thandler == SIG_DFL && !from_ancestor_ns)\n\t\treturn 1;\n\n\treturn sig_handler_ignored(handler, sig);\n}\n\nstatic int sig_ignored(struct task_struct *t, int sig, int from_ancestor_ns)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn 0;\n\n\tif (!sig_task_ignored(t, sig, from_ancestor_ns))\n\t\treturn 0;\n\n\t/*\n\t * Tracers may want to know about even ignored signals.\n\t */\n\treturn !tracehook_consider_ignored_signal(t, sig);\n}\n\n/*\n * Re-calculate pending state from the set of locally pending\n * signals, globally pending signals, and blocked signals.\n */\nstatic inline int has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}\n\n#define PENDING(p,b) has_pending_signals(&(p)->signal, (b))\n\nstatic int recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif (t->signal->group_stop_count > 0 ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn 1;\n\t}\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn 0;\n}\n\n/*\n * After recalculating TIF_SIGPENDING, we need to make sure the task wakes up.\n * This is superfluous when called on current, the wakeup is a harmless no-op.\n */\nvoid recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}\n\nvoid recalc_sigpending(void)\n{\n\tif (unlikely(tracehook_force_sigpending()))\n\t\tset_thread_flag(TIF_SIGPENDING);\n\telse if (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}\n\n/* Given the mask, find the first available signal that should be serviced. */\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE))\n\nint next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}\n\n/*\n * allocate a new signal queue record\n * - this may be called without locks if and only if t == current, otherwise an\n *   appopriate lock must be held to stop the target task from exiting\n */\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}\n\n/*\n * Flush all pending signals for a task.\n */\nvoid __flush_signals(struct task_struct *t)\n{\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n}\n\nvoid flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\t__flush_signals(t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}\n\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}\n\nvoid flush_itimer_signals(void)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\t__flush_itimer_signals(&tsk->pending);\n\t__flush_itimer_signals(&tsk->signal->shared_pending);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}\n\nvoid ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}\n\n/*\n * Flush all handlers for a task.\n */\n\nvoid\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}\n\nint unhandled_signal(struct task_struct *tsk, int sig)\n{\n\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;\n\tif (is_global_init(tsk))\n\t\treturn 1;\n\tif (handler != SIG_IGN && handler != SIG_DFL)\n\t\treturn 0;\n\treturn !tracehook_consider_fatal_signal(tsk, sig);\n}\n\n\n/* Notify the system that a driver wants to block all signals for this\n * process, and wants to be notified if any signals at all were to be\n * sent/acted upon.  If the notifier routine returns non-zero, then the\n * signal will be acted upon after all.  If the notifier routine returns 0,\n * then then signal will be blocked.  Only one block per process is\n * allowed.  priv is a pointer to private data that the notifier routine\n * can use to determine if the signal should be blocked or not.  */\n\nvoid\nblock_all_signals(int (*notifier)(void *priv), void *priv, sigset_t *mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tcurrent->notifier_mask = mask;\n\tcurrent->notifier_data = priv;\n\tcurrent->notifier = notifier;\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n}\n\n/* Notify the system that blocking has ended. */\n\nvoid\nunblock_all_signals(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tcurrent->notifier = NULL;\n\tcurrent->notifier_data = NULL;\n\trecalc_sigpending();\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n}\n\nstatic void collect_signal(int sig, struct sigpending *list, siginfo_t *info)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/* Ok, it wasn't in the queue.  This must be\n\t\t   a fast-pathed signal or we must have been\n\t\t   out of queue space.  So zero out the info.\n\t\t */\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}\n\nstatic int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tsiginfo_t *info)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig) {\n\t\tif (current->notifier) {\n\t\t\tif (sigismember(current->notifier_mask, sig)) {\n\t\t\t\tif (!(current->notifier)(current->notifier_data)) {\n\t\t\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcollect_signal(sig, pending, info);\n\t}\n\n\treturn sig;\n}\n\n/*\n * Dequeue a signal and return the element to the caller, which is \n * expected to free it.\n *\n * All callers have to hold the siglock.\n */\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)\n{\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info);\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr.tv64 != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\ttsk->signal->flags |= SIGNAL_STOP_DEQUEUED;\n\t}\n\tif ((info->si_code & __SI_MASK) == __SI_TIMER && info->si_sys_private) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tdo_schedule_next_timer(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\t}\n\treturn signr;\n}\n\n/*\n * Tell a process that it has a new active signal..\n *\n * NOTE! we rely on the previous spin_lock to\n * lock interrupts for us! We can only be called with\n * \"siglock\" held, and the local interrupt must\n * have been disabled when that got acquired!\n *\n * No need to set need_resched since signal event passing\n * goes through ->blocked\n */\nvoid signal_wake_up(struct task_struct *t, int resume)\n{\n\tunsigned int mask;\n\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\n\t/*\n\t * For SIGKILL, we want to wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tmask = TASK_INTERRUPTIBLE;\n\tif (resume)\n\t\tmask |= TASK_WAKEKILL;\n\tif (!wake_up_state(t, mask))\n\t\tkick_process(t);\n}\n\n/*\n * Remove signals in mask from the pending set and queue.\n * Returns 1 if any signals were found.\n *\n * All callers must be holding the siglock.\n *\n * This version takes a sigset mask and looks at all signals,\n * not just those in the first mask word.\n */\nstatic int rm_from_queue_full(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn 0;\n\n\tsignandsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\treturn 1;\n}\n/*\n * Remove signals in mask from the pending set and queue.\n * Returns 1 if any signals were found.\n *\n * All callers must be holding the siglock.\n */\nstatic int rm_from_queue(unsigned long mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\n\tif (!sigtestsetmask(&s->signal, mask))\n\t\treturn 0;\n\n\tsigdelsetmask(&s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (q->info.si_signo < SIGRTMIN &&\n\t\t    (mask & sigmask(q->info.si_signo))) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic inline int is_si_special(const struct siginfo *info)\n{\n\treturn info <= SEND_SIG_FORCED;\n}\n\nstatic inline bool si_fromuser(const struct siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}\n\n/*\n * Bad permissions for sending the signal\n * - the caller must hold the RCU read lock\n */\nstatic int check_kill_permission(int sig, struct siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tconst struct cred *cred, *tcred;\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tcred = current_cred();\n\ttcred = __task_cred(t);\n\tif (!same_thread_group(current, t) &&\n\t    (cred->euid ^ tcred->suid) &&\n\t    (cred->euid ^ tcred->uid) &&\n\t    (cred->uid  ^ tcred->suid) &&\n\t    (cred->uid  ^ tcred->uid) &&\n\t    !capable(CAP_KILL)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, 0);\n}\n\n/*\n * Handle magic process-wide effects of stop/continue signals. Unlike\n * the signal actions, these happen immediately at signal-generation\n * time regardless of blocking, ignoring, or handling.  This does the\n * actual continuing for SIGCONT, but not the actual stopping for stop\n * signals. The process stop is done as a signal action for SIG_DFL.\n *\n * Returns true if the signal should be actually delivered, otherwise\n * it should be dropped.\n */\nstatic int prepare_signal(int sig, struct task_struct *p, int from_ancestor_ns)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\tif (unlikely(signal->flags & SIGNAL_GROUP_EXIT)) {\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\trm_from_queue(sigmask(SIGCONT), &signal->shared_pending);\n\t\tt = p;\n\t\tdo {\n\t\t\trm_from_queue(sigmask(SIGCONT), &t->pending);\n\t\t} while_each_thread(p, t);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues,\n\t\t * and wake all threads.\n\t\t */\n\t\trm_from_queue(SIG_KERNEL_STOP_MASK, &signal->shared_pending);\n\t\tt = p;\n\t\tdo {\n\t\t\tunsigned int state;\n\t\t\trm_from_queue(SIG_KERNEL_STOP_MASK, &t->pending);\n\t\t\t/*\n\t\t\t * If there is a handler for SIGCONT, we must make\n\t\t\t * sure that no thread returns to user mode before\n\t\t\t * we post the signal, in case it was the only\n\t\t\t * thread eligible to run the signal handler--then\n\t\t\t * it must not do anything between resuming and\n\t\t\t * running the handler.  With the TIF_SIGPENDING\n\t\t\t * flag set, the thread will pause and acquire the\n\t\t\t * siglock that we hold now and until we've queued\n\t\t\t * the pending signal.\n\t\t\t *\n\t\t\t * Wake up the stopped thread _after_ setting\n\t\t\t * TIF_SIGPENDING\n\t\t\t */\n\t\t\tstate = __TASK_STOPPED;\n\t\t\tif (sig_user_defined(t, SIGCONT) && !sigismember(&t->blocked, SIGCONT)) {\n\t\t\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\t\t\tstate |= TASK_INTERRUPTIBLE;\n\t\t\t}\n\t\t\twake_up_state(t, state);\n\t\t} while_each_thread(p, t);\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal_to_deliver().\n\t\t\t */\n\t\t\tsignal->flags = why | SIGNAL_STOP_CONTINUED;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We are not stopped, but there could be a stop\n\t\t\t * signal in the middle of being processed after\n\t\t\t * being removed from the queue.  Clear that too.\n\t\t\t */\n\t\t\tsignal->flags &= ~SIGNAL_STOP_DEQUEUED;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, from_ancestor_ns);\n}\n\n/*\n * Test if P wants to take SIG.  After we've checked all threads with this,\n * it's equivalent to finding no threads not blocking SIG.  Any threads not\n * blocking SIG were ruled out because they are not running and already\n * have pending signals.  Such threads will dequeue from the shared queue\n * as soon as they're available, so putting the signal on the shared queue\n * will be equivalent to sending it to one such thread.\n */\nstatic inline int wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn 0;\n\tif (p->flags & PF_EXITING)\n\t\treturn 0;\n\tif (sig == SIGKILL)\n\t\treturn 1;\n\tif (task_is_stopped_or_traced(p))\n\t\treturn 0;\n\treturn task_curr(p) || !signal_pending(p);\n}\n\nstatic void complete_signal(int sig, struct task_struct *p, int group)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if (!group || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL ||\n\t     !tracehook_consider_fatal_signal(t, sig))) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}\n\nstatic inline int legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}\n\nstatic int __send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\n\ttrace_signal_generate(sig, info, t);\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tif (!prepare_signal(sig, t, from_ancestor_ns))\n\t\treturn 0;\n\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tif (legacy_queue(pending, sig))\n\t\treturn 0;\n\t/*\n\t * fast-pathed signals for kernel-internal things like SIGSTOP\n\t * or SIGKILL.\n\t */\n\tif (info == SEND_SIG_FORCED)\n\t\tgoto out_set;\n\n\t/* Real-time signals must be queued if sent by sigqueue, or\n\t   some other real-time mechanism.  It is implementation\n\t   defined whether kill() does so.  We attempt to do so, on\n\t   the principle of least surprise, but since kill is not\n\t   allowed to fail with EAGAIN when low on memory we just\n\t   make sure at least one signal gets delivered and don't\n\t   pass on the info struct.  */\n\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n\t\toverride_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = current_uid();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\ttrace_signal_overflow_fail(sig, group, info);\n\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\ttrace_signal_lose_info(sig, group, info);\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\n\treturn 0;\n}\n\nstatic int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, group, from_ancestor_ns);\n}\n\nstatic void print_fatal_signal(struct pt_regs *regs, int signr)\n{\n\tprintk(\"%s/%d: potentially unexpected fatal signal %d.\\n\",\n\t\tcurrent->comm, task_pid_nr(current), signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n\tprintk(\"code at %08lx: \", regs->ip);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->ip + i)))\n\t\t\t\tbreak;\n\t\t\tprintk(\"%02x \", insn);\n\t\t}\n\t}\n#endif\n\tprintk(\"\\n\");\n\tpreempt_disable();\n\tshow_regs(regs);\n\tpreempt_enable();\n}\n\nstatic int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}\n\n__setup(\"print-fatal-signals=\", setup_print_fatal_signals);\n\nint\n__group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, 1);\n}\n\nstatic int\nspecific_send_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\treturn send_signal(sig, info, t, 0);\n}\n\nint do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,\n\t\t\tbool group)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, group);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Force a signal that the process can't ignore: if necessary\n * we unblock the signal and change any SIG_IGN to SIG_DFL.\n *\n * Note: If we unblock the signal, we always reset it to SIG_DFL,\n * since we do not want to have a signal handler that was blocked\n * be invoked when user space had explicitly blocked it.\n *\n * We don't want to have recursive SIGSEGV's etc, for example,\n * that is why we also clear SIGNAL_UNKILLABLE.\n */\nint\nforce_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\tif (action->sa.sa_handler == SIG_DFL)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = specific_send_sig_info(sig, info, t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}\n\n/*\n * Nuke all other threads in the group.\n */\nint zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}\n\n/*\n * send signal info to all the members of a group\n */\nint group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, true);\n\n\treturn ret;\n}\n\n/*\n * __kill_pgrp_info() sends a signal to a process group: this is what the tty\n * control characters do (^C, ^Z etc)\n * - the caller must hold at least a readlock on tasklist_lock\n */\nint __kill_pgrp_info(int sig, struct siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}\n\nint kill_pid_info(int sig, struct siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\trcu_read_lock();\nretry:\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (p) {\n\t\terror = group_send_sig_info(sig, info, p);\n\t\tif (unlikely(error == -ESRCH))\n\t\t\t/*\n\t\t\t * The task was unhashed in between, try again.\n\t\t\t * If it is dead, pid_task() will return NULL,\n\t\t\t * if we race with de_thread() it will find the\n\t\t\t * new leader.\n\t\t\t */\n\t\t\tgoto retry;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nint\nkill_proc_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}\n\n/* like kill_pid_info(), but doesn't use uid/euid of \"current\" */\nint kill_pid_info_as_uid(int sig, struct siginfo *info, struct pid *pid,\n\t\t      uid_t uid, uid_t euid, u32 secid)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tconst struct cred *pcred;\n\tunsigned long flags;\n\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\n\trcu_read_lock();\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tpcred = __task_cred(p);\n\tif (si_fromuser(info) &&\n\t    euid != pcred->suid && euid != pcred->uid &&\n\t    uid  != pcred->suid && uid  != pcred->uid) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, secid);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (sig) {\n\t\tif (lock_task_sighand(p, &flags)) {\n\t\t\tret = __send_signal(sig, info, p, 1, 0);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kill_pid_info_as_uid);\n\n/*\n * kill_something_info() interprets pid in interesting ways just like kill(2).\n *\n * POSIX specifies that kill(-1,sig) is unspecified, but what we have\n * is probably wrong.  Should make it like BSD or SYSV.\n */\n\nstatic int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\n\n/*\n * These are for backward compatibility with the rest of the kernel source.\n */\n\nint\nsend_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, false);\n}\n\n#define __si_special(priv) \\\n\t((priv) ? SEND_SIG_PRIV : SEND_SIG_NOINFO)\n\nint\nsend_sig(int sig, struct task_struct *p, int priv)\n{\n\treturn send_sig_info(sig, __si_special(priv), p);\n}\n\nvoid\nforce_sig(int sig, struct task_struct *p)\n{\n\tforce_sig_info(sig, SEND_SIG_PRIV, p);\n}\n\n/*\n * When things go south during signal handling, we\n * will force a SIGSEGV. And if the signal that caused\n * the problem was already a SIGSEGV, we'll want to\n * make sure we don't even try to deliver the signal..\n */\nint\nforce_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n\treturn 0;\n}\n\nint kill_pgrp(struct pid *pid, int sig, int priv)\n{\n\tint ret;\n\n\tread_lock(&tasklist_lock);\n\tret = __kill_pgrp_info(sig, __si_special(priv), pid);\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(kill_pgrp);\n\nint kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}\nEXPORT_SYMBOL(kill_pid);\n\n/*\n * These functions support sending signals using preallocated sigqueue\n * structures.  This is needed \"because realtime applications cannot\n * afford to lose notifications of asynchronous events, like timer\n * expirations or I/O completions\".  In the case of Posix Timers\n * we allocate the sigqueue structure from the timer_create.  If this\n * allocation fails we are able to report the failure to the application\n * with an EAGAIN error.\n */\nstruct sigqueue *sigqueue_alloc(void)\n{\n\tstruct sigqueue *q = __sigqueue_alloc(-1, current, GFP_KERNEL, 0);\n\n\tif (q)\n\t\tq->flags |= SIGQUEUE_PREALLOC;\n\n\treturn q;\n}\n\nvoid sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}\n\nint send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tif (!prepare_signal(sig, t, 0))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nout:\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}\n\n/*\n * Let a parent know about the death of a child.\n * For a stopped/continued status change, use do_notify_parent_cldstop instead.\n *\n * Returns -1 if our parent ignored us and so we've switched to\n * self-reaping, or else @sig.\n */\nint do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tint ret = sig;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!task_ptrace(tsk) &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * we are under tasklist_lock here so our parent is tied to\n\t * us and cannot exit and release its namespace.\n\t *\n\t * the only it can is to switch its nsproxy with sys_unshare,\n\t * bu uncharing pid namespaces is not allowed, so we'll always\n\t * see relevant namespace\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, tsk->parent->nsproxy->pid_ns);\n\tinfo.si_uid = __task_cred(tsk)->uid;\n\trcu_read_unlock();\n\n\tinfo.si_utime = cputime_to_clock_t(cputime_add(tsk->utime,\n\t\t\t\ttsk->signal->utime));\n\tinfo.si_stime = cputime_to_clock_t(cputime_add(tsk->stime,\n\t\t\t\ttsk->signal->stime));\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!task_ptrace(tsk) && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tret = tsk->exit_signal = -1;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = -1;\n\t}\n\tif (valid_signal(sig) && sig > 0)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn ret;\n}\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk, int why)\n{\n\tstruct siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\n\tif (task_ptrace(tsk))\n\t\tparent = tsk->parent;\n\telse {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() abot the following 3 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, parent->nsproxy->pid_ns);\n\tinfo.si_uid = __task_cred(tsk)->uid;\n\trcu_read_unlock();\n\n\tinfo.si_utime = cputime_to_clock_t(tsk->utime);\n\tinfo.si_stime = cputime_to_clock_t(tsk->stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}\n\nstatic inline int may_ptrace_stop(void)\n{\n\tif (!likely(task_ptrace(current)))\n\t\treturn 0;\n\t/*\n\t * Are we in the middle of do_coredump?\n\t * If so and our tracer is also part of the coredump stopping\n\t * is a deadlock situation, and pointless because our tracer\n\t * is dead so don't allow us to stop.\n\t * If SIGKILL was already sent before the caller unlocked\n\t * ->siglock we must see ->core_state != NULL. Otherwise it\n\t * is safe to enter schedule().\n\t */\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n * Return nonzero if there is a SIGKILL that should be waking us up.\n * Called with the siglock held.\n */\nstatic int sigkill_pending(struct task_struct *tsk)\n{\n\treturn\tsigismember(&tsk->pending.signal, SIGKILL) ||\n\t\tsigismember(&tsk->signal->shared_pending.signal, SIGKILL);\n}\n\n/*\n * This must be called with current->sighand->siglock held.\n *\n * This should be the path for all ptrace stops.\n * We always set current->last_siginfo while stopped here.\n * That makes it a way to test a stopped process for\n * being ptrace-stopped vs being job-control-stopped.\n *\n * If we actually decide not to stop at all because the tracer\n * is gone, we keep current->exit_code unless clear_code.\n */\nstatic void ptrace_stop(int exit_code, int clear_code, siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If there is a group stop in progress,\n\t * we must participate in the bookkeeping.\n\t */\n\tif (current->signal->group_stop_count > 0)\n\t\t--current->signal->group_stop_count;\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/* Let the debugger run.  */\n\t__set_current_state(TASK_TRACED);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\tdo_notify_parent_cldstop(current, CLD_TRAPPED);\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tschedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * While in TASK_TRACED, we were considered \"frozen enough\".\n\t * Now that we woke up, it's crucial if we're supposed to be\n\t * frozen that we freeze now before running anything substantial.\n\t */\n\ttry_to_freeze();\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}\n\nvoid ptrace_notify(int exit_code)\n{\n\tsiginfo_t info;\n\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\n\tmemset(&info, 0, sizeof info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\t/* Let the debugger run.  */\n\tspin_lock_irq(&current->sighand->siglock);\n\tptrace_stop(exit_code, 1, &info);\n\tspin_unlock_irq(&current->sighand->siglock);\n}\n\n/*\n * This performs the stopping for SIGSTOP and other stop signals.\n * We have to stop all threads in the thread group.\n * Returns nonzero if we've actually stopped and released the siglock.\n * Returns zero if we didn't stop and still hold the siglock.\n */\nstatic int do_signal_stop(int signr)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint notify;\n\n\tif (!sig->group_stop_count) {\n\t\tstruct task_struct *t;\n\n\t\tif (!likely(sig->flags & SIGNAL_STOP_DEQUEUED) ||\n\t\t    unlikely(signal_group_exit(sig)))\n\t\t\treturn 0;\n\t\t/*\n\t\t * There is no group stop already in progress.\n\t\t * We must initiate one now.\n\t\t */\n\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 1;\n\t\tfor (t = next_thread(current); t != current; t = next_thread(t))\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!(t->flags & PF_EXITING) &&\n\t\t\t    !task_is_stopped_or_traced(t)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t}\n\t}\n\t/*\n\t * If there are no other threads in the group, or if there is\n\t * a group stop in progress and we are the last to stop, report\n\t * to the parent.  When ptraced, every thread reports itself.\n\t */\n\tnotify = sig->group_stop_count == 1 ? CLD_STOPPED : 0;\n\tnotify = tracehook_notify_jctl(notify, CLD_STOPPED);\n\t/*\n\t * tracehook_notify_jctl() can drop and reacquire siglock, so\n\t * we keep ->group_stop_count != 0 before the call. If SIGCONT\n\t * or SIGKILL comes in between ->group_stop_count == 0.\n\t */\n\tif (sig->group_stop_count) {\n\t\tif (!--sig->group_stop_count)\n\t\t\tsig->flags = SIGNAL_STOP_STOPPED;\n\t\tcurrent->exit_code = sig->group_exit_code;\n\t\t__set_current_state(TASK_STOPPED);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (notify) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, notify);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\tdo {\n\t\tschedule();\n\t} while (try_to_freeze());\n\n\ttracehook_finish_jctl();\n\tcurrent->exit_code = 0;\n\n\treturn 1;\n}\n\nstatic int ptrace_signal(int signr, siginfo_t *info,\n\t\t\t struct pt_regs *regs, void *cookie)\n{\n\tif (!task_ptrace(current))\n\t\treturn signr;\n\n\tptrace_signal_deliver(regs, cookie);\n\n\t/* Let the debugger run.  */\n\tptrace_stop(signr, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\n\tcurrent->exit_code = 0;\n\n\t/* Update the siginfo structure if the signal has\n\t   changed.  If the debugger wanted something\n\t   specific in the siginfo structure then it should\n\t   have updated *info via PTRACE_SETSIGINFO.  */\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = task_uid(current->parent);\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}\n\nint get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,\n\t\t\t  struct pt_regs *regs, void *cookie)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\nrelock:\n\t/*\n\t * We'll jump back here after any time we were stopped in TASK_STOPPED.\n\t * While in TASK_STOPPED, we were considered \"frozen enough\".\n\t * Now that we woke up, it's crucial if we're supposed to be\n\t * frozen that we freeze now before running anything substantial.\n\t */\n\ttry_to_freeze();\n\n\tspin_lock_irq(&sighand->siglock);\n\t/*\n\t * Every stopped thread goes here after wakeup. Check to see if\n\t * we should notify the parent, prepare_signal(SIGCONT) encodes\n\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.\n\t */\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why = (signal->flags & SIGNAL_STOP_CONTINUED)\n\t\t\t\t? CLD_CONTINUED : CLD_STOPPED;\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\n\t\twhy = tracehook_notify_jctl(why, CLD_CONTINUED);\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\tif (why) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current->group_leader, why);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t\tgoto relock;\n\t}\n\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\t\t/*\n\t\t * Tracing can induce an artifical signal and choose sigaction.\n\t\t * The return value in @signr determines the default action,\n\t\t * but @info->si_signo is the signal number we will report.\n\t\t */\n\t\tsignr = tracehook_get_signal(current, regs, info, return_ka);\n\t\tif (unlikely(signr < 0))\n\t\t\tgoto relock;\n\t\tif (unlikely(signr != 0))\n\t\t\tka = return_ka;\n\t\telse {\n\t\t\tif (unlikely(signal->group_stop_count > 0) &&\n\t\t\t    do_signal_stop(0))\n\t\t\t\tgoto relock;\n\n\t\t\tsignr = dequeue_signal(current, &current->blocked,\n\t\t\t\t\t       info);\n\n\t\t\tif (!signr)\n\t\t\t\tbreak; /* will return 0 */\n\n\t\t\tif (signr != SIGKILL) {\n\t\t\t\tsignr = ptrace_signal(signr, info,\n\t\t\t\t\t\t      regs, cookie);\n\t\t\t\tif (!signr)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tka = &sighand->action[signr-1];\n\t\t}\n\n\t\t/* Trace actually delivered signals. */\n\t\ttrace_signal_deliver(signr, info, ka);\n\n\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */\n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\t/* Run the handler.  */\n\t\t\t*return_ka = *ka;\n\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\n\t\t\tbreak; /* will return non-zero \"signr\" value */\n\t\t}\n\n\t\t/*\n\t\t * Now we are doing the default action for this signal.\n\t\t */\n\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Global init gets no signals it doesn't want.\n\t\t * Container-init gets no signals it doesn't want from same\n\t\t * container.\n\t\t *\n\t\t * Note that if global/container-init sees a sig_kernel_only()\n\t\t * signal here, the signal must have been generated internally\n\t\t * or must have come from an ancestor namespace. In either\n\t\t * case, the signal cannot be dropped.\n\t\t */\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\t/*\n\t\t\t * The default action is to stop all threads in\n\t\t\t * the thread group.  The job control signals\n\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP\n\t\t\t * always works.  Note that siglock needs to be\n\t\t\t * dropped during the call to is_orphaned_pgrp()\n\t\t\t * because of lock ordering with tasklist_lock.\n\t\t\t * This allows an intervening SIGCONT to be posted.\n\t\t\t * We need to check for that and bail out if necessary.\n\t\t\t */\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t\t\t/* signals can be posted during this window */\n\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\n\t\t\tif (likely(do_signal_stop(info->si_signo))) {\n\t\t\t\t/* It released the siglock.  */\n\t\t\t\tgoto relock;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We didn't actually stop, due to a race\n\t\t\t * with SIGCONT or something like that.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Anything else is fatal, maybe with a core dump.\n\t\t */\n\t\tcurrent->flags |= PF_SIGNALED;\n\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(regs, info->si_signo);\n\t\t\t/*\n\t\t\t * If it was able to dump core, this kills all\n\t\t\t * other threads in the group and synchronizes with\n\t\t\t * their demise.  If we lost the race with another\n\t\t\t * thread getting here, it set group_exit_code\n\t\t\t * first and our do_group_exit call below will use\n\t\t\t * that value and ignore the one we pass it.\n\t\t\t */\n\t\t\tdo_coredump(info->si_signo, info->si_signo, regs);\n\t\t}\n\n\t\t/*\n\t\t * Death signals, no core dump.\n\t\t */\n\t\tdo_group_exit(info->si_signo);\n\t\t/* NOTREACHED */\n\t}\n\tspin_unlock_irq(&sighand->siglock);\n\treturn signr;\n}\n\nvoid exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tstruct task_struct *t;\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\t/* It could be that __group_complete_signal() choose us to\n\t * notify about group-wide signal. Another thread should be\n\t * woken now to take the signal since we will not.\n\t */\n\tfor (t = tsk; (t = next_thread(t)) != tsk; )\n\t\tif (!signal_pending(t) && !(t->flags & PF_EXITING))\n\t\t\trecalc_sigpending_and_wake(t);\n\n\tif (unlikely(tsk->signal->group_stop_count) &&\n\t\t\t!--tsk->signal->group_stop_count) {\n\t\ttsk->signal->flags = SIGNAL_STOP_STOPPED;\n\t\tgroup_stop = tracehook_notify_jctl(CLD_STOPPED, CLD_STOPPED);\n\t}\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\n\nEXPORT_SYMBOL(recalc_sigpending);\nEXPORT_SYMBOL_GPL(dequeue_signal);\nEXPORT_SYMBOL(flush_signals);\nEXPORT_SYMBOL(force_sig);\nEXPORT_SYMBOL(send_sig);\nEXPORT_SYMBOL(send_sig_info);\nEXPORT_SYMBOL(sigprocmask);\nEXPORT_SYMBOL(block_all_signals);\nEXPORT_SYMBOL(unblock_all_signals);\n\n\n/*\n * System call entry points.\n */\n\nSYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current_thread_info()->restart_block;\n\treturn restart->fn(restart);\n}\n\nlong do_no_restart_syscall(struct restart_block *param)\n{\n\treturn -EINTR;\n}\n\n/*\n * We don't need to get the kernel lock - this is all local to this\n * particular thread.. (and that's good, because this is _heavily_\n * used by various programs)\n */\n\n/*\n * This is also useful for kernel threads that want to temporarily\n * (or permanently) block certain signals.\n *\n * NOTE! Unlike the user-mode sys_sigprocmask(), the kernel\n * interface happily blocks \"unblockable\" signals like SIGKILL\n * and friends.\n */\nint sigprocmask(int how, sigset_t *set, sigset_t *oldset)\n{\n\tint error;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (oldset)\n\t\t*oldset = current->blocked;\n\n\terror = 0;\n\tswitch (how) {\n\tcase SIG_BLOCK:\n\t\tsigorsets(&current->blocked, &current->blocked, set);\n\t\tbreak;\n\tcase SIG_UNBLOCK:\n\t\tsignandsets(&current->blocked, &current->blocked, set);\n\t\tbreak;\n\tcase SIG_SETMASK:\n\t\tcurrent->blocked = *set;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, set,\n\t\tsigset_t __user *, oset, size_t, sigsetsize)\n{\n\tint error = -EINVAL;\n\tsigset_t old_set, new_set;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\tgoto out;\n\n\tif (set) {\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&new_set, set, sizeof(*set)))\n\t\t\tgoto out;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, &old_set);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (oset)\n\t\t\tgoto set_old;\n\t} else if (oset) {\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\told_set = current->blocked;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\tset_old:\n\t\terror = -EFAULT;\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\tgoto out;\n\t}\n\terror = 0;\nout:\n\treturn error;\n}\n\nlong do_sigpending(void __user *set, unsigned long sigsetsize)\n{\n\tlong error = -EINVAL;\n\tsigset_t pending;\n\n\tif (sigsetsize > sizeof(sigset_t))\n\t\tgoto out;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigorsets(&pending, &current->pending.signal,\n\t\t  &current->signal->shared_pending.signal);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Outside the lock because only this thread touches it.  */\n\tsigandsets(&pending, &current->blocked, &pending);\n\n\terror = -EFAULT;\n\tif (!copy_to_user(set, &pending, sigsetsize))\n\t\terror = 0;\n\nout:\n\treturn error;\n}\t\n\nSYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, set, size_t, sigsetsize)\n{\n\treturn do_sigpending(set, sigsetsize);\n}\n\n#ifndef HAVE_ARCH_COPY_SIGINFO_TO_USER\n\nint copy_siginfo_to_user(siginfo_t __user *to, siginfo_t *from)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, to, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (from->si_code < 0)\n\t\treturn __copy_to_user(to, from, sizeof(siginfo_t))\n\t\t\t? -EFAULT : 0;\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * Please remember to update the signalfd_copyinfo() function\n\t * inside fs/signalfd.c too, in case siginfo_t changes.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t */\n\terr = __put_user(from->si_signo, &to->si_signo);\n\terr |= __put_user(from->si_errno, &to->si_errno);\n\terr |= __put_user((short)from->si_code, &to->si_code);\n\tswitch (from->si_code & __SI_MASK) {\n\tcase __SI_KILL:\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\tbreak;\n\tcase __SI_TIMER:\n\t\t err |= __put_user(from->si_tid, &to->si_tid);\n\t\t err |= __put_user(from->si_overrun, &to->si_overrun);\n\t\t err |= __put_user(from->si_ptr, &to->si_ptr);\n\t\tbreak;\n\tcase __SI_POLL:\n\t\terr |= __put_user(from->si_band, &to->si_band);\n\t\terr |= __put_user(from->si_fd, &to->si_fd);\n\t\tbreak;\n\tcase __SI_FAULT:\n\t\terr |= __put_user(from->si_addr, &to->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\terr |= __put_user(from->si_trapno, &to->si_trapno);\n#endif\n#ifdef BUS_MCEERR_AO\n\t\t/* \n\t\t * Other callers might not initialize the si_lsb field,\n\t \t * so check explicitely for the right codes here.\n\t\t */\n\t\tif (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO)\n\t\t\terr |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);\n#endif\n\t\tbreak;\n\tcase __SI_CHLD:\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\terr |= __put_user(from->si_status, &to->si_status);\n\t\terr |= __put_user(from->si_utime, &to->si_utime);\n\t\terr |= __put_user(from->si_stime, &to->si_stime);\n\t\tbreak;\n\tcase __SI_RT: /* This is not generated by the kernel as of now. */\n\tcase __SI_MESGQ: /* But this is */\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\terr |= __put_user(from->si_ptr, &to->si_ptr);\n\t\tbreak;\n\tdefault: /* this is just in case for now ... */\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#endif\n\nSYSCALL_DEFINE4(rt_sigtimedwait, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo, const struct timespec __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tint ret, sig;\n\tsigset_t these;\n\tstruct timespec ts;\n\tsiginfo_t info;\n\tlong timeout = 0;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\t\t\n\t/*\n\t * Invert the set of allowed signals to get those we\n\t * want to block.\n\t */\n\tsigdelsetmask(&these, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\tsignotset(&these);\n\n\tif (uts) {\n\t\tif (copy_from_user(&ts, uts, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\tif (ts.tv_nsec >= 1000000000L || ts.tv_nsec < 0\n\t\t    || ts.tv_sec < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsig = dequeue_signal(current, &these, &info);\n\tif (!sig) {\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (uts)\n\t\t\ttimeout = (timespec_to_jiffies(&ts)\n\t\t\t\t   + (ts.tv_sec || ts.tv_nsec));\n\n\t\tif (timeout) {\n\t\t\t/* None ready -- temporarily unblock those we're\n\t\t\t * interested while we are sleeping in so that we'll\n\t\t\t * be awakened when they arrive.  */\n\t\t\tcurrent->real_blocked = current->blocked;\n\t\t\tsigandsets(&current->blocked, &current->blocked, &these);\n\t\t\trecalc_sigpending();\n\t\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t\ttimeout = schedule_timeout_interruptible(timeout);\n\n\t\t\tspin_lock_irq(&current->sighand->siglock);\n\t\t\tsig = dequeue_signal(current, &these, &info);\n\t\t\tcurrent->blocked = current->real_blocked;\n\t\t\tsiginitset(&current->real_blocked, 0);\n\t\t\trecalc_sigpending();\n\t\t}\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (sig) {\n\t\tret = sig;\n\t\tif (uinfo) {\n\t\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t} else {\n\t\tret = -EAGAIN;\n\t\tif (timeout)\n\t\t\tret = -EINTR;\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\treturn kill_something_info(sig, &info, pid);\n}\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, false);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nstatic int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}\n\n/**\n *  sys_tgkill - send signal to one specific thread\n *  @tgid: the thread group ID of the thread\n *  @pid: the PID of the thread\n *  @sig: signal to be sent\n *\n *  This syscall also checks the @tgid and returns -ESRCH even if the PID\n *  exists but it's not belonging to the target process anymore. This\n *  method solves the problem of threads exiting and PIDs getting reused.\n */\nSYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(tgid, pid, sig);\n}\n\n/*\n *  Send a signal to only one task, even if it's a CLONE_THREAD task.\n */\nSYSCALL_DEFINE2(tkill, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(0, pid, sig);\n}\n\nSYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info.si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info.si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}\n\nlong do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info->si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}\n\nSYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}\n\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tstruct task_struct *t = current;\n\tstruct k_sigaction *k;\n\tsigset_t mask;\n\n\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n\t\treturn -EINVAL;\n\n\tk = &t->sighand->action[sig-1];\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (oact)\n\t\t*oact = *k;\n\n\tif (act) {\n\t\tsigdelsetmask(&act->sa.sa_mask,\n\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\t*k = *act;\n\t\t/*\n\t\t * POSIX 3.3.1.3:\n\t\t *  \"Setting a signal action to SIG_IGN for a signal that is\n\t\t *   pending shall cause the pending signal to be discarded,\n\t\t *   whether or not it is blocked.\"\n\t\t *\n\t\t *  \"Setting a signal action to SIG_DFL for a signal that is\n\t\t *   pending and whose default action is to ignore the signal\n\t\t *   (for example, SIGCHLD), shall cause the pending signal to\n\t\t *   be discarded, whether or not it is blocked\"\n\t\t */\n\t\tif (sig_handler_ignored(sig_handler(t, sig), sig)) {\n\t\t\tsigemptyset(&mask);\n\t\t\tsigaddset(&mask, sig);\n\t\t\trm_from_queue_full(&mask, &t->signal->shared_pending);\n\t\t\tdo {\n\t\t\t\trm_from_queue_full(&mask, &t->pending);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != current);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn 0;\n}\n\nint \ndo_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)\n{\n\tstack_t oss;\n\tint error;\n\n\toss.ss_sp = (void __user *) current->sas_ss_sp;\n\toss.ss_size = current->sas_ss_size;\n\toss.ss_flags = sas_ss_flags(sp);\n\n\tif (uss) {\n\t\tvoid __user *ss_sp;\n\t\tsize_t ss_size;\n\t\tint ss_flags;\n\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, uss, sizeof(*uss)))\n\t\t\tgoto out;\n\t\terror = __get_user(ss_sp, &uss->ss_sp) |\n\t\t\t__get_user(ss_flags, &uss->ss_flags) |\n\t\t\t__get_user(ss_size, &uss->ss_size);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = -EPERM;\n\t\tif (on_sig_stack(sp))\n\t\t\tgoto out;\n\n\t\terror = -EINVAL;\n\t\t/*\n\t\t *\n\t\t * Note - this code used to test ss_flags incorrectly\n\t\t *  \t  old code may have been written using ss_flags==0\n\t\t *\t  to mean ss_flags==SS_ONSTACK (as this was the only\n\t\t *\t  way that worked) - this fix preserves that older\n\t\t *\t  mechanism\n\t\t */\n\t\tif (ss_flags != SS_DISABLE && ss_flags != SS_ONSTACK && ss_flags != 0)\n\t\t\tgoto out;\n\n\t\tif (ss_flags == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\terror = -ENOMEM;\n\t\t\tif (ss_size < MINSIGSTKSZ)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcurrent->sas_ss_sp = (unsigned long) ss_sp;\n\t\tcurrent->sas_ss_size = ss_size;\n\t}\n\n\terror = 0;\n\tif (uoss) {\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_WRITE, uoss, sizeof(*uoss)))\n\t\t\tgoto out;\n\t\terror = __put_user(oss.ss_sp, &uoss->ss_sp) |\n\t\t\t__put_user(oss.ss_size, &uoss->ss_size) |\n\t\t\t__put_user(oss.ss_flags, &uoss->ss_flags);\n\t}\n\nout:\n\treturn error;\n}\n\n#ifdef __ARCH_WANT_SYS_SIGPENDING\n\nSYSCALL_DEFINE1(sigpending, old_sigset_t __user *, set)\n{\n\treturn do_sigpending(set, sizeof(*set));\n}\n\n#endif\n\n#ifdef __ARCH_WANT_SYS_SIGPROCMASK\n/* Some platforms have their own version with special arguments others\n   support only sys_rt_sigprocmask.  */\n\nSYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, set,\n\t\told_sigset_t __user *, oset)\n{\n\tint error;\n\told_sigset_t old_set, new_set;\n\n\tif (set) {\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&new_set, set, sizeof(*set)))\n\t\t\tgoto out;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\told_set = current->blocked.sig[0];\n\n\t\terror = 0;\n\t\tswitch (how) {\n\t\tdefault:\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&current->blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&current->blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcurrent->blocked.sig[0] = new_set;\n\t\t\tbreak;\n\t\t}\n\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (oset)\n\t\t\tgoto set_old;\n\t} else if (oset) {\n\t\told_set = current->blocked.sig[0];\n\tset_old:\n\t\terror = -EFAULT;\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\tgoto out;\n\t}\n\terror = 0;\nout:\n\treturn error;\n}\n#endif /* __ARCH_WANT_SYS_SIGPROCMASK */\n\n#ifdef __ARCH_WANT_SYS_RT_SIGACTION\nSYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct sigaction __user *, act,\n\t\tstruct sigaction __user *, oact,\n\t\tsize_t, sigsetsize)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret = -EINVAL;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\tgoto out;\n\n\tif (act) {\n\t\tif (copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\n\n\tif (!ret && oact) {\n\t\tif (copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa)))\n\t\t\treturn -EFAULT;\n\t}\nout:\n\treturn ret;\n}\n#endif /* __ARCH_WANT_SYS_RT_SIGACTION */\n\n#ifdef __ARCH_WANT_SYS_SGETMASK\n\n/*\n * For backwards compatibility.  Functionality superseded by sigprocmask.\n */\nSYSCALL_DEFINE0(sgetmask)\n{\n\t/* SMP safe */\n\treturn current->blocked.sig[0];\n}\n\nSYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\told = current->blocked.sig[0];\n\n\tsiginitset(&current->blocked, newmask & ~(sigmask(SIGKILL)|\n\t\t\t\t\t\t  sigmask(SIGSTOP)));\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn old;\n}\n#endif /* __ARCH_WANT_SGETMASK */\n\n#ifdef __ARCH_WANT_SYS_SIGNAL\n/*\n * For backwards compatibility.  Functionality superseded by sigaction.\n */\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\tnew_sa.sa.sa_handler = handler;\n\tnew_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n\tsigemptyset(&new_sa.sa.sa_mask);\n\n\tret = do_sigaction(sig, &new_sa, &old_sa);\n\n\treturn ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}\n#endif /* __ARCH_WANT_SYS_SIGNAL */\n\n#ifdef __ARCH_WANT_SYS_PAUSE\n\nSYSCALL_DEFINE0(pause)\n{\n\tcurrent->state = TASK_INTERRUPTIBLE;\n\tschedule();\n\treturn -ERESTARTNOHAND;\n}\n\n#endif\n\n#ifdef __ARCH_WANT_SYS_RT_SIGSUSPEND\nSYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset, unewset, sizeof(newset)))\n\t\treturn -EFAULT;\n\tsigdelsetmask(&newset, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->saved_sigmask = current->blocked;\n\tcurrent->blocked = newset;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tcurrent->state = TASK_INTERRUPTIBLE;\n\tschedule();\n\tset_restore_sigmask();\n\treturn -ERESTARTNOHAND;\n}\n#endif /* __ARCH_WANT_SYS_RT_SIGSUSPEND */\n\n__attribute__((weak)) const char *arch_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}\n\nvoid __init signals_init(void)\n{\n\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC);\n}\n\n#ifdef CONFIG_KGDB_KDB\n#include <linux/kdb.h>\n/*\n * kdb_send_sig_info - Allows kdb to send signals without exposing\n * signal internals.  This function checks if the required locks are\n * available before calling the main signal code, to avoid kdb\n * deadlocks.\n */\nvoid\nkdb_send_sig_info(struct task_struct *t, struct siginfo *info)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint sig, new_t;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tspin_unlock(&t->sighand->siglock);\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (t->state != TASK_RUNNING && new_t) {\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tsig = info->si_signo;\n\tif (send_sig_info(sig, info, t))\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}\n#endif\t/* CONFIG_KGDB_KDB */\n"], "filenames": ["kernel/signal.c"], "buggy_code_start_loc": [2424], "buggy_code_end_loc": [2442], "fixing_code_start_loc": [2424], "fixing_code_end_loc": [2451], "type": "NVD-CWE-noinfo", "message": "kernel/signal.c in the Linux kernel before 2.6.39 allows local users to spoof the uid and pid of a signal sender via a sigqueueinfo system call.", "other": {"cve": {"id": "CVE-2011-1182", "sourceIdentifier": "secalert@redhat.com", "published": "2013-03-01T12:37:53.647", "lastModified": "2023-02-13T01:19:08.750", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "kernel/signal.c in the Linux kernel before 2.6.39 allows local users to spoof the uid and pid of a signal sender via a sigqueueinfo system call."}, {"lang": "es", "value": "kernel/signal.c en Linux kernel anterior a v2.6.39 permite a usuarios locales falsear el \"uid\" y el \"pid\" a trav\u00e9s de un env\u00edo de se\u00f1al de una llamada del sistema \"sigqueueinfo\"."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39", "matchCriteriaId": "176353CE-F17E-4776-AD9F-19014DA75B76"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1D8B549B-E57B-4DFE-8A13-CAB06B5356B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_aus:5.6:*:*:*:*:*:*:*", "matchCriteriaId": "E9D9A0B9-D6B1-42C3-9571-72B7B2D72776"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "133AAFA7-AF42-4D7B-8822-AA2E85611BF5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:5.6:*:*:*:*:*:*:*", "matchCriteriaId": "903512FC-0017-4564-9B89-7E64FFB14B11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "54D669D4-6D7E-449D-80C1-28FA44F06FFE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D0AC5CD5-6E58-433C-9EB3-6DFE5656463E"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=da48524eb20662618854bb3df2db01fc65f3070c", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2011-0927.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/03/23/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=690028", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c"}}