{"buggy_code": ["package org.pytorch.serve.archive.utils;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.UUID;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\n\npublic final class ZipUtils {\n\n    private ZipUtils() {}\n\n    public static void unzip(InputStream is, File dest) throws IOException {\n        try (ZipInputStream zis = new ZipInputStream(is)) {\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                String name = entry.getName();\n                File file = new File(dest, name);\n                if (entry.isDirectory()) {\n                    FileUtils.forceMkdir(file);\n                } else {\n                    File parentFile = file.getParentFile();\n                    FileUtils.forceMkdir(parentFile);\n                    try (OutputStream os = Files.newOutputStream(file.toPath())) {\n                        IOUtils.copy(zis, os);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void addToZip(int prefix, File file, FileFilter filter, ZipOutputStream zos)\n            throws IOException {\n        String name = file.getCanonicalPath().substring(prefix);\n        if (name.startsWith(\"/\")) {\n            name = name.substring(1);\n        }\n        if (file.isDirectory()) {\n            if (!name.isEmpty()) {\n                ZipEntry entry = new ZipEntry(name + '/');\n                zos.putNextEntry(entry);\n            }\n            File[] files = file.listFiles(filter);\n            if (files != null) {\n                for (File f : files) {\n                    addToZip(prefix, f, filter, zos);\n                }\n            }\n        } else if (file.isFile()) {\n            ZipEntry entry = new ZipEntry(name);\n            zos.putNextEntry(entry);\n            try (FileInputStream fis = (FileInputStream) Files.newInputStream(file.toPath())) {\n                IOUtils.copy(fis, zos);\n            }\n        }\n    }\n\n    public static File unzip(InputStream is, String eTag, String type, boolean isMar)\n            throws IOException {\n        File tmpDir = FileUtils.getTempDirectory();\n        File modelDir = new File(tmpDir, type);\n        FileUtils.forceMkdir(modelDir);\n\n        File tmp = File.createTempFile(type, \".download\");\n        FileUtils.forceDelete(tmp);\n        FileUtils.forceMkdir(tmp);\n\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new AssertionError(e);\n        }\n        if (isMar) {\n            unzip(new DigestInputStream(is, md), tmp);\n        } else {\n            decompressTarGzipFile(new DigestInputStream(is, md), tmp);\n        }\n        if (eTag == null) {\n            eTag = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        }\n\n        File dir = new File(modelDir, eTag);\n\n        FileUtils.moveDirectory(tmp, dir);\n\n        return dir;\n    }\n\n    public static void decompressTarGzipFile(InputStream is, File dest) throws IOException {\n        try (GzipCompressorInputStream gzi = new GzipCompressorInputStream(is);\n                TarArchiveInputStream tis = new TarArchiveInputStream(gzi)) {\n            ArchiveEntry entry;\n            while ((entry = tis.getNextEntry()) != null) {\n                String name = entry.getName().substring(entry.getName().indexOf('/') + 1);\n                File file = new File(dest, name);\n                if (entry.isDirectory()) {\n                    FileUtils.forceMkdir(file);\n                } else {\n                    File parentFile = file.getParentFile();\n                    FileUtils.forceMkdir(parentFile);\n                    try (OutputStream os = Files.newOutputStream(file.toPath())) {\n                        IOUtils.copy(tis, os);\n                    }\n                }\n            }\n        }\n    }\n\n    public static File createTempDir(String eTag, String type) throws IOException {\n        File tmpDir = FileUtils.getTempDirectory();\n        File modelDir = new File(tmpDir, type);\n\n        if (eTag == null) {\n            eTag = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        }\n\n        File dir = new File(modelDir, eTag);\n        if (dir.exists()) {\n            FileUtils.forceDelete(dir);\n        }\n        FileUtils.forceMkdir(dir);\n\n        return dir;\n    }\n\n    public static File createSymbolicDir(File source, File dest) throws IOException {\n        String sourceDirName = source.getName();\n        File targetLink = new File(dest, sourceDirName);\n        Files.createSymbolicLink(targetLink.toPath(), source.toPath());\n\n        return targetLink;\n    }\n}\n"], "fixing_code": ["package org.pytorch.serve.archive.utils;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.UUID;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\n\npublic final class ZipUtils {\n\n    private ZipUtils() {}\n\n    public static void unzip(InputStream is, File dest) throws IOException {\n        try (ZipInputStream zis = new ZipInputStream(is)) {\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                File file = new File(dest, entry.getName());\n                File canonicalDestDir = dest.getCanonicalFile();\n                File canonicalFile = file.getCanonicalFile();\n\n                // Check for Zip Slip vulnerability\n                if (!canonicalFile.getPath().startsWith(canonicalDestDir.getPath())) {\n                    throw new IOException(\"Detected Zip Slip vulnerability: \" + entry.getName());\n                }\n\n                if (entry.isDirectory()) {\n                    FileUtils.forceMkdir(file);\n                } else {\n                    File parentFile = file.getParentFile();\n                    FileUtils.forceMkdir(parentFile);\n                    try (OutputStream os = Files.newOutputStream(file.toPath())) {\n                        IOUtils.copy(zis, os);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void addToZip(int prefix, File file, FileFilter filter, ZipOutputStream zos)\n            throws IOException {\n        String name = file.getCanonicalPath().substring(prefix);\n        if (name.startsWith(\"/\")) {\n            name = name.substring(1);\n        }\n        if (file.isDirectory()) {\n            if (!name.isEmpty()) {\n                ZipEntry entry = new ZipEntry(name + '/');\n                zos.putNextEntry(entry);\n            }\n            File[] files = file.listFiles(filter);\n            if (files != null) {\n                for (File f : files) {\n                    addToZip(prefix, f, filter, zos);\n                }\n            }\n        } else if (file.isFile()) {\n            ZipEntry entry = new ZipEntry(name);\n            zos.putNextEntry(entry);\n            try (FileInputStream fis = (FileInputStream) Files.newInputStream(file.toPath())) {\n                IOUtils.copy(fis, zos);\n            }\n        }\n    }\n\n    public static File unzip(InputStream is, String eTag, String type, boolean isMar)\n            throws IOException {\n        File tmpDir = FileUtils.getTempDirectory();\n        File modelDir = new File(tmpDir, type);\n        FileUtils.forceMkdir(modelDir);\n\n        File tmp = File.createTempFile(type, \".download\");\n        FileUtils.forceDelete(tmp);\n        FileUtils.forceMkdir(tmp);\n\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new AssertionError(e);\n        }\n        if (isMar) {\n            unzip(new DigestInputStream(is, md), tmp);\n        } else {\n            decompressTarGzipFile(new DigestInputStream(is, md), tmp);\n        }\n        if (eTag == null) {\n            eTag = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        }\n\n        File dir = new File(modelDir, eTag);\n\n        FileUtils.moveDirectory(tmp, dir);\n\n        return dir;\n    }\n\n    public static void decompressTarGzipFile(InputStream is, File dest) throws IOException {\n        try (GzipCompressorInputStream gzi = new GzipCompressorInputStream(is);\n                TarArchiveInputStream tis = new TarArchiveInputStream(gzi)) {\n            ArchiveEntry entry;\n            while ((entry = tis.getNextEntry()) != null) {\n                String name = entry.getName().substring(entry.getName().indexOf('/') + 1);\n                File file = new File(dest, name);\n                File canonicalDestDir = dest.getCanonicalFile();\n                File canonicalFile = file.getCanonicalFile();\n\n                // Check for Zip Slip vulnerability\n                if (!canonicalFile.getPath().startsWith(canonicalDestDir.getPath())) {\n                    throw new IOException(\"Detected Zip Slip vulnerability: \" + entry.getName());\n                }\n\n                if (entry.isDirectory()) {\n                    FileUtils.forceMkdir(file);\n                } else {\n                    File parentFile = file.getParentFile();\n                    FileUtils.forceMkdir(parentFile);\n                    try (OutputStream os = Files.newOutputStream(file.toPath())) {\n                        IOUtils.copy(tis, os);\n                    }\n                }\n            }\n        }\n    }\n\n    public static File createTempDir(String eTag, String type) throws IOException {\n        File tmpDir = FileUtils.getTempDirectory();\n        File modelDir = new File(tmpDir, type);\n\n        if (eTag == null) {\n            eTag = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        }\n\n        File dir = new File(modelDir, eTag);\n        if (dir.exists()) {\n            FileUtils.forceDelete(dir);\n        }\n        FileUtils.forceMkdir(dir);\n\n        return dir;\n    }\n\n    public static File createSymbolicDir(File source, File dest) throws IOException {\n        String sourceDirName = source.getName();\n        File targetLink = new File(dest, sourceDirName);\n        Files.createSymbolicLink(targetLink.toPath(), source.toPath());\n\n        return targetLink;\n    }\n}\n"], "filenames": ["frontend/archive/src/main/java/org/pytorch/serve/archive/utils/ZipUtils.java"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [110], "fixing_code_start_loc": [31], "fixing_code_end_loc": [126], "type": "CWE-22", "message": "TorchServe is a tool for serving and scaling PyTorch models in production. Starting in version 0.1.0 and prior to version 0.9.0, using the model/workflow management API, there is a chance of uploading potentially harmful archives that contain files that are extracted to any location on the filesystem that is within the process permissions. Leveraging this issue could aid third-party actors in hiding harmful code in open-source/public models, which can be downloaded from the internet, and take advantage of machines running Torchserve. The ZipSlip issue in TorchServe has been fixed by validating the paths of files contained within a zip archive before extracting them. TorchServe release 0.9.0 includes fixes to address the ZipSlip vulnerability.", "other": {"cve": {"id": "CVE-2023-48299", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-21T21:15:09.077", "lastModified": "2023-11-29T02:31:52.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TorchServe is a tool for serving and scaling PyTorch models in production. Starting in version 0.1.0 and prior to version 0.9.0, using the model/workflow management API, there is a chance of uploading potentially harmful archives that contain files that are extracted to any location on the filesystem that is within the process permissions. Leveraging this issue could aid third-party actors in hiding harmful code in open-source/public models, which can be downloaded from the internet, and take advantage of machines running Torchserve. The ZipSlip issue in TorchServe has been fixed by validating the paths of files contained within a zip archive before extracting them. TorchServe release 0.9.0 includes fixes to address the ZipSlip vulnerability."}, {"lang": "es", "value": "TorchServe es una herramienta para servir y escalar modelos de PyTorch en producci\u00f3n. A partir de la versi\u00f3n 0.1.0 y antes de la versi\u00f3n 0.9.0, al utilizar la API de administraci\u00f3n de modelo/flujo de trabajo, existe la posibilidad de cargar archivos potencialmente da\u00f1inos que contengan archivos extra\u00eddos a cualquier ubicaci\u00f3n del sistema de archivos que est\u00e9 dentro de los permisos del proceso. Aprovechar este problema podr\u00eda ayudar a terceros a ocultar c\u00f3digo da\u00f1ino en modelos p\u00fablicos/de c\u00f3digo abierto, que se pueden descargar de Internet, y aprovechar las m\u00e1quinas que ejecutan Torchserve. El problema de Zipslip en TorchServe se solucion\u00f3 validando las rutas de los archivos contenidos en un archivo zip antes de extraerlos. La versi\u00f3n 0.9.0 de TorchServe incluye correcciones para abordar la vulnerabilidad Zipslip."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pytorch:torchserve:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.1.0", "versionEndExcluding": "0.9.0", "matchCriteriaId": "F958D5AE-E57F-4C08-A946-D75B9857CD1B"}]}]}], "references": [{"url": "https://github.com/pytorch/serve/commit/bfb3d42396727614aef625143b4381e64142f9bb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pytorch/serve/pull/2634", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pytorch/serve/releases/tag/v0.9.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/pytorch/serve/security/advisories/GHSA-m2mj-pr4f-h9jp", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pytorch/serve/commit/bfb3d42396727614aef625143b4381e64142f9bb"}}